/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
struct Grid {
   char NAME[101] ;
   int LEVEL ;
   int TYPE ;
   int ORIENT ;
   double ANGLE ;
   int ANGLE_UNIT ;
   double PSTEP ;
   double QSTEP ;
   int PQSTEP_UNIT ;
   double PX ;
   double PY ;
   double QX ;
   double QY ;
   int PQXY_UNIT ;
   double ROT_ANGLE ;
};
struct Port {
   int PORTNUM ;
   double AMP ;
   int AMP_UNIT ;
   double PSC ;
   int PSC_UNIT ;
   double PSH ;
   int PSH_UNIT ;
   double PPA ;
   int PPA_UNIT ;
   double PHEPOL ;
   int PHEPOL_UNIT ;
   int OMIT_POL ;
   struct Port *NEXT ;
};
struct Elem {
   int TYPE ;
   char NAME[101] ;
   int LEVEL ;
   int GEOMETRY ;
   double RADIUS ;
   int RADIUS_UNIT ;
   double PDIM ;
   double QDIM ;
   int PQDIM_UNIT ;
   int MODEL ;
   double EXP ;
   double ANGLEE ;
   double ANGLEH ;
   int ANGLE_UNIT ;
   double TAPERE ;
   double TAPERH ;
   int TAPER_UNIT ;
   int POLARIZATION ;
   double PHEPOL ;
   int PHEPOL_UNIT ;
   int DIRECTION ;
   double GAIN ;
   int GAIN_UNIT ;
   int NPORTS ;
   struct Port *PORT_PTR ;
};
struct Group;
struct Group;
struct PQExp {
   int dummy ;
};
struct GrAmpExc {
   int TYPE ;
   double UNIF_VAL ;
   double CENTRE ;
   double P1_ET ;
   double P2_ET ;
   double Q1_ET ;
   double Q2_ET ;
   int AMP_UNIT ;
   struct PQExp *PQEXP_PTR ;
};
struct GrPhaExc {
   int TYPE ;
   double UNIF_VAL ;
   double CENTRE ;
   double P1_EP ;
   double P2_EP ;
   double Q1_EP ;
   double Q2_EP ;
   int DIRECTION ;
   int OMIT_ANGLE ;
   double ANGLE_START ;
   double ANGLE_STEP ;
   int OMIT_PHASE ;
   double PHASE_START ;
   double PHASE_STEP ;
   double U ;
   double V ;
   double THETA ;
   double PHI ;
   struct PQExp *PQEXP_PTR ;
   int ANGLE_UNIT ;
   int PHASE_UNIT ;
};
struct Err {
   int AMP_TYPE ;
   double AMP_STDEV ;
   double AMP_LINOFFS ;
   double AMP_LINSTEP ;
   double AMP_2NDCENT ;
   double AMP_2NDPET ;
   double AMP_2NDQET ;
   int AMP_UNIT ;
   int PHASE_TYPE ;
   double PHASE_STDEV ;
   double PHASE_LINOFFS ;
   double PHASE_LINSTEP ;
   double PHASE_2NDCENT ;
   double PHASE_2NDPSID ;
   double PHASE_2NDQSID ;
   double PHASE_QUANTSTEP ;
   int PHASE_UNIT ;
};
struct Fail {
   int NUM_FAULTY_EL ;
   double FIXED_AMP ;
   double FIXED_PHASE ;
};
struct AddRem;
struct AddRem;
struct Geomnode;
struct Geomnode;
struct Group {
   char NAME[101] ;
   struct Grid *GRID_PTR ;
   struct Elem *ELEM_PTR ;
   struct AddRem *ADDREM_PTR ;
   struct GrAmpExc *GRAMPEXC_PTR ;
   struct GrPhaExc *GRPHAEXC_PTR ;
   struct Err *ERR_PTR ;
   struct Fail *FAIL_PTR ;
   struct Group *NEXT ;
   int NUM_OF_NODES ;
   int SHAPE ;
   double PSIZE ;
   double QSIZE ;
   struct Geomnode *GEOMNODE_PTR ;
   int BUILT ;
   struct Group *SUPER_GROUP_PTR[5] ;
};
struct Node;
struct Node;
struct AddRem {
   int ADDREM_TYPE ;
   int BLOCK_TYPE ;
   struct Node *NODE_PTR ;
   struct AddRem *NEXT ;
};
struct Node {
   int OMIT_ORIENT ;
   int PCOORD ;
   int QCOORD ;
   double THEA ;
   double PHEA ;
   double PSEA ;
   int ANGLE_UNIT ;
   struct Node *NEXT ;
};
struct charac {
   char info ;
   int LINE_NUM ;
   struct charac *PREV ;
   struct charac *NEXT ;
};
struct Geomport;
struct Geomport;
struct Geomnode {
   int LOC_P ;
   int LOC_Q ;
   double XA ;
   double YA ;
   double ZA ;
   double THEA ;
   double PHEA ;
   double PSEA ;
   struct Geomport *GEOMPORT_PTR ;
   struct Geomnode *NEXT ;
   struct Geomnode *SUBGROUP_PTR ;
   int SHAPE ;
   double PSIZE ;
   double QSIZE ;
};
struct Geomport {
   double AMP ;
   double PSH ;
   double PSC ;
   double PPA ;
   double PHEPOL ;
   struct Geomport *NEXT ;
};
#pragma merger("0","/tmp/cil-CA02UFd4.i","")
#pragma merger("0","/tmp/cil-fXpzBcE_.i","")
extern int _IO_getc(_IO_FILE *__fp ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int putchar(int __c ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asin)(double __x ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
char UserNames[21][101]  ;
char Keywords[126][21]  ;
char ErrorMessages[101][101]  ;
char MOSErrors[21][101]  ;
char GLOBLE_FILENAME[101]  ;
void parserro(struct charac *err_ptr , int errcode , char *s ) ;
void kwdsinit(void) ;
void emsginit(void) ;
void unaminit(void) ;
void moseinit(void) ;
void glvainit(void) ;
char TapeGet(struct charac **tp ) ;
void waitcont(void) ;
int isletter(char ch ) ;
int InKWords(char *WORD ) ;
int InUNames(char *WORD ) ;
void interror(char *subname ) ;
int InserUN(char *WORD ) ;
int EndOfTape(struct charac **p ) ;
void floatsup(void) ;
void nomefile(char *fn ) ;
void prnfile(struct charac *firstel ) ;
int answer(char *domanda ) ;
int readfil3(char *filename , struct charac **firstel , struct charac **lastel ) ;
int GetKeyword(char *kw , struct charac **tp ) ;
int GetUName(char *word , struct charac **tp ) ;
int GetReal(double *reale , struct charac **tp ) ;
int GetUReal(struct charac *p1 , struct charac **pp2 , double *ureal_ptr ) ;
int Get1Real(struct charac *p1 , struct charac **pp2 , double *ureal_ptr ) ;
int GetInt(struct charac *p1 , struct charac **pp2 , int *intero ) ;
int GetNatur(struct charac *p1 , struct charac **pp2 , int *natur_ptr ) ;
int lenunit(struct charac **tp , int *unit ) ;
int angunit(struct charac *p1 , struct charac **pp2 , int *angle_unit_ptr ) ;
int ampunit(struct charac **tp , int *unit_ptr ) ;
int squgrdef(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , int *pstep_unit_ptr ) ;
int recgrdef(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , double *qstep_ptr ,
             int *pqstep_unit_ptr ) ;
int hexgrdef(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , int *pstep_unit_ptr ) ;
int trigrdef(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ,
             double *pstep_ptr , double *qstep_ptr , int *pqstep_unit_ptr , double *px_ptr ,
             double *py_ptr , double *qx_ptr , double *qy_ptr , int *pqxy_unit_ptr ) ;
int griddef1(struct charac *p1 , struct charac **pp2 , struct Grid **grid_ptr ) ;
int doubstep(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , double *qstep_ptr ,
             int *pqstep_unit_ptr ) ;
int angclaus(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) ;
int angstep(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ,
            double *pstep_ptr , double *qstep_ptr , int *pqstep_unit_ptr ) ;
int versdef(struct charac *p1 , struct charac **pp2 , double *px_ptr , double *py_ptr ,
            double *qx_ptr , double *qy_ptr , int *pqxy_unit_ptr ) ;
int sinstep(struct charac *p1 , struct charac **pp2 , double *step_ptr , int *step_unit_ptr ) ;
int recspec(struct charac *p1 , struct charac **pp2 , double *pdim_ptr , double *qdim_ptr ,
            int *pqdim_unit_ptr ) ;
int geomspec(struct charac *p1 , struct charac **pp2 , int *geometry_ptr , double *radius_ptr ,
             int *radius_unit_ptr , double *pdim_ptr , double *qdim_ptr , int *pqdim_unit_ptr ) ;
int circspec(struct charac *p1 , struct charac **pp2 , double *radius_ptr , int *radius_unit_ptr ) ;
int extmod(struct charac *p1 , struct charac **pp2 ) ;
int gaussel(struct charac *p1 , struct charac **pp2 , double *anglee_ptr , double *angleh_ptr ,
            int *angle_unit_ptr , double *tapere_ptr , double *taperh_ptr , int *taper_unit_ptr ) ;
int cosinus(struct charac *p1 , struct charac **pp2 , double *exp_ptr ) ;
int modspec(struct charac *p1 , struct charac **pp2 , int *model_ptr , double *exp_ptr ,
            double *anglee_ptr , double *angleh_ptr , int *angle_unit_ptr , double *tapere_ptr ,
            double *taperh_ptr , int *taper_unit_ptr ) ;
int angval(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) ;
int polor(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) ;
int linpol(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) ;
int circpol(struct charac *p1 , struct charac **pp2 , int *direction_ptr ) ;
int polspec(struct charac *p1 , struct charac **pp2 , int *polarization_ptr , double *phepol_ptr ,
            int *phepol_unit_ptr , int *direction_ptr ) ;
int gainunit(struct charac *p1 , struct charac **pp2 , int *gain_unit_ptr ) ;
int gainval(struct charac *p1 , struct charac **pp2 , double *gain_ptr , int *gain_unit_ptr ) ;
int gainspec(struct charac *p1 , struct charac **pp2 , double *gain_ptr , int *gain_unit_ptr ) ;
int sinelem(struct charac *p1 , struct charac **pp2 , struct Elem **elem_ptr ) ;
int pshdef1(struct charac *p1 , struct charac **pp2 , double *psh_ptr , int *psh_unit_ptr ) ;
int pscdef1(struct charac *p1 , struct charac **pp2 , double *psc_ptr , int *psc_unit_ptr ) ;
int ppadef1(struct charac *p1 , struct charac **pp2 , double *ppa_ptr , int *ppa_unit_ptr ) ;
int polorbis(struct charac *p1 , struct charac **pp2 , double *phepol_ptr , int *phepol_unit_ptr ) ;
int ampval(struct charac *p1 , struct charac **pp2 , double *amp_ptr , int *amp_unit_ptr ) ;
int portamp(struct charac *p1 , struct charac **pp2 , double *amp_ptr , int *amp_unit_ptr ) ;
int portdef(struct charac *p1 , struct charac **pp2 , struct Port *PORT_PTR , int *portnum_ptr ) ;
int portspec(struct charac *p1 , struct charac **pp2 , int *nports_ptr , struct Port **port_ptr ) ;
int elemdef(struct charac *p1 , struct charac **pp2 , struct Elem **elem_ptr ) ;
int nodorien(struct charac *p1 , struct charac **pp2 , double *theta_ptr , double *phi_ptr ,
             double *psi_ptr , int *angle_unit_ptr ) ;
int nodecoor(struct charac *p1 , struct charac **pp2 , int *pcoord_ptr , int *qcoord_ptr ) ;
int nodedef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) ;
int blockdef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) ;
int adddef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) ;
int remdef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) ;
int adremdef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) ;
int grgeodef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) ;
int hexdef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) ;
int polydef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) ;
int greldef(struct charac *p1 , struct charac **pp2 , struct Grid **grid_ptr , struct Elem **elem_ptr ) ;
int secoramp(struct charac *p1 , struct charac **pp2 , double *centre_ptr , double *p1_et_ptr ,
             double *p2_et_ptr , double *q1_et_ptr , double *q2_et_ptr , int *amp_unit_ptr ) ;
int unifamp(struct charac *p1 , struct charac **pp2 , double *unif_val_ptr , int *amp_unit_ptr ) ;
int grampexc(struct charac *p1 , struct charac **pp2 , struct GrAmpExc **grampexc_ptr ) ;
int angledir(struct charac *p1 , struct charac **pp2 , double *theta_ptr , double *phi_ptr ,
             int *angle_unit_ptr ) ;
int uvval(struct charac *p1 , struct charac **pp2 , double *val_ptr ) ;
int uvdir(struct charac *p1 , struct charac **pp2 , double *u_ptr , double *v_ptr ) ;
int beampha(struct charac *p1 , struct charac **pp2 , double *u_ptr , double *v_ptr ,
            double *theta_ptr , double *phi_ptr , int *angle_unit_ptr ) ;
int phaserot(struct charac *p1 , struct charac **pp2 , double *phase_start_ptr , double *phase_step_ptr ,
             int *phase_unit_ptr ) ;
int anglerot(struct charac *p1 , struct charac **pp2 , double *angle_start_ptr , double *angle_step_ptr ,
             int *angle_unit_ptr ) ;
int serotdir(struct charac *p1 , struct charac **pp2 , int *direction_ptr ) ;
int serotpar(struct charac *p1 , struct charac **pp2 , double *angle_start_ptr , double *angle_step_ptr ,
             int *omit_phase_ptr , double *phase_start_ptr , double *phase_step_ptr ,
             int *angle_unit_ptr , int *phase_unit_ptr ) ;
int serotpha(struct charac *p1 , struct charac **pp2 , int *direction_ptr , int *omit_angle_ptr ,
             double *angle_start_ptr , double *angle_step_ptr , int *omit_phase_ptr ,
             double *phase_start_ptr , double *phase_step_ptr , int *angle_unit_ptr ,
             int *phase_unit_ptr ) ;
int secorpha(struct charac *p1 , struct charac **pp2 , double *centre_ptr , double *p1_ep_ptr ,
             double *p2_ep_ptr , double *q1_ep_ptr , double *q2_ep_ptr , int *phase_unit_ptr ) ;
int unifpha(struct charac *p1 , struct charac **pp2 , double *unif_val_ptr , int *phase_unit_ptr ) ;
int grphaexc(struct charac *p1 , struct charac **pp2 , struct GrPhaExc **grphaexc_ptr ) ;
int grexcdef(struct charac *p1 , struct charac **pp2 , struct GrAmpExc **grampexc_ptr ,
             struct GrPhaExc **grphaexc_ptr ) ;
int groupdef(struct charac *p1 , struct charac **pp2 , struct Group **group_ptr ) ;
int intmin(int a , int b ) ;
int intmax(int a , int b ) ;
double doubmin(double a , double b ) ;
double doubmax(double a , double b ) ;
double dcos(double x ) ;
double dsin(double x ) ;
double dacos(double x ) ;
double dasin(double x ) ;
double datan(double x ) ;
int mmconv(double *x_ptr , int unit ) ;
int degconv(double *x_ptr , int unit ) ;
int linconv(double *x_ptr , int unit ) ;
int grwrite(struct Group *group_ptr , char *filename ) ;
int mksnode(struct AddRem *addrem_ptr , struct Geomnode **first_node_ptr , struct Geomnode **last_node_ptr ,
            double pstep , double qstep , double angle , int *nodes_num_ptr , int elem_shape ,
            double elem_pdim , double elem_qdim ) ;
int mksblock(struct AddRem *addrem_ptr , struct Geomnode **first_node_ptr , struct Geomnode **last_node_ptr ,
             double pstep , double qstep , double angle , int *nodes_num_ptr , int elem_shape ,
             double elem_pdim , double elem_qdim ) ;
int mkshex(struct AddRem *addrem_ptr , struct Geomnode **first_node_ptr , struct Geomnode **last_node_ptr ,
           double pstep , double qstep , double angle , int *nodes_num_ptr , int elem_shape ,
           double elem_pdim , double elem_qdim ) ;
int addscan(struct Group *group_ptr ) ;
int extremes(struct Geomnode *gnode_ptr , int *pnum_ptr , int *qnum_ptr ) ;
int simgroup(struct Group *group_ptr ) ;
int fixnodor(struct Node *node_ptr ) ;
int fixsgrel(struct Group *group_ptr ) ;
int fixsgrid(struct Grid *grid ) ;
int fixselem(struct Elem *elem_ptr ) ;
int extsize(struct Geomnode *gnode_ptr , double elem_pdim , double elem_qdim , double *xsize_ptr ,
            double *ysize_ptr ) ;
int sgrrot(struct Geomnode *start_ptr , double XC , double YC , double phi ) ;
int fixgramp(struct GrAmpExc *g ) ;
int fixport(struct Elem *elem_ptr ) ;
int sgrampun(struct GrAmpExc *grampexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ) ;
int simamp(struct Group *group_ptr ) ;
int pqlimits(struct Geomnode *gnode_ptr , struct Geomnode **pmin_ptr , struct Geomnode **pmax_ptr ,
             struct Geomnode **qmin_ptr , struct Geomnode **qmax_ptr ) ;
int sgramp2n(struct GrAmpExc *grampexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ,
             int group_shape ) ;
double secorder(double a , double b , double c , double d , double e , double x ,
                double y ) ;
int simpol(struct Group *group_ptr ) ;
int simpha(struct Group *group_ptr ) ;
int fixgrpha(struct GrPhaExc *g ) ;
int sgrphaun(struct GrPhaExc *grphaexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ) ;
int sgrpha2n(struct GrPhaExc *grphaexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ,
             int group_shape ) ;
int gnodfind(struct Geomnode *gnode_list_start_ptr , struct Geomnode **gnode_ptr ,
             int p , int q ) ;
void gnodevis(int p , int q , double angle , double phase , struct Geomnode *gnode_list_start_ptr ) ;
void seqrotrg(double angle_start , double angle_step , double phase_start , double phase_step ,
              struct Geomnode *g ) ;
void seqrothg(double angle_start , double angle_step , double phase_start , double phase_step ,
              struct Geomnode *g ) ;
int sgrphasr(struct Group *group_ptr ) ;
int main(int argc , char **argv ) 
{ 
  struct charac *first ;
  struct charac *last ;
  struct charac *cp ;
  struct Group *group_ptr ;
  int error ;
  char fn[101] ;
  int tmp ;

  {
  first = (struct charac *)((void *)0);
  last = (struct charac *)((void *)0);
  cp = (struct charac *)((void *)0);
  group_ptr = (struct Group *)((void *)0);
  error = 0;
  if (argc != 2) {
    {
    printf((char const   * __restrict  )"\n\tUSAGE: %s [<source-file-name>]\n\n",
           "space.exe");
    exit(1);
    }
  }
  {
  strcpy((char * __restrict  )(GLOBLE_FILENAME), (char const   * __restrict  )*(argv + 1));
  glvainit();
  nomefile(fn);
  tmp = readfil3(fn, & first, & last);
  }
  if (tmp != 0) {
    {
    exit(1);
    }
  }
  {
  prnfile(first);
  error = groupdef(first, & cp, & group_ptr);
  waitcont();
  }
  if (error != 0) {
    {
    exit(1);
    }
  }
  {
  error = simgroup(group_ptr);
  }
  if (error) {
    {
    exit(1);
    }
  }
  {
  error = simamp(group_ptr);
  }
  if (error) {
    {
    exit(1);
    }
  }
  {
  error = simpha(group_ptr);
  }
  if (error) {
    {
    exit(1);
    }
  }
  {
  simpol(group_ptr);
  waitcont();
  grwrite(group_ptr, fn);
  }
  return (0);
}
}
int adddef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  struct Node *no_ptr ;
  struct Node **node_ptr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
  curr_ptr = & curr;
  no_ptr = (struct Node *)((void *)0);
  node_ptr = & no_ptr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[79], curr_ptr);
  }
  if (error != 0) {
    *addrem_ptr = (struct AddRem *)((void *)0);
    return (1);
  }
  {
  error = nodedef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    parserro(*curr_ptr, 58, (char *)" ");
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"adddef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 0;
    (*addrem_ptr)->BLOCK_TYPE = 0;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = blockdef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    parserro(*curr_ptr, 59, (char *)" ");
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___0 = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp___0;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"adddef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 0;
    (*addrem_ptr)->BLOCK_TYPE = 1;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = polydef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    parserro(*curr_ptr, 60, (char *)" ");
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___1 = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp___1;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"adddef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 0;
    (*addrem_ptr)->BLOCK_TYPE = 2;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = hexdef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    parserro(*curr_ptr, 61, (char *)" ");
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___2 = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp___2;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"adddef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 0;
    (*addrem_ptr)->BLOCK_TYPE = 3;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  *addrem_ptr = (struct AddRem *)((void *)0);
  parserro(*curr_ptr, 62, (char *)" ");
  }
  return (17);
}
}
int addscan(struct Group *group_ptr ) 
{ 
  struct AddRem *add_ptr ;
  struct Geomnode *ap1_ptr ;
  struct Geomnode **app1_ptr ;
  struct Geomnode *ap2_ptr ;
  struct Geomnode **app2_ptr ;
  struct Geomnode *primo_ptr ;
  struct Geomnode *ultimo_ptr ;
  int new_nodes ;
  int *new_nodes_ptr ;
  int pnum ;
  int *pnum_ptr ;
  int qnum ;
  int *qnum_ptr ;
  int elem_shape ;
  double elem_pdim ;
  double elem_qdim ;
  double pstep ;
  double qstep ;
  double angle ;
  double rot_angle ;
  int nodes_num ;
  int group_shape ;
  double group_psize ;
  double group_qsize ;
  double *group_psize_ptr ;
  double *group_qsize_ptr ;

  {
  add_ptr = (struct AddRem *)((void *)0);
  ap1_ptr = (struct Geomnode *)((void *)0);
  app1_ptr = & ap1_ptr;
  ap2_ptr = (struct Geomnode *)((void *)0);
  app2_ptr = & ap2_ptr;
  primo_ptr = (struct Geomnode *)((void *)0);
  ultimo_ptr = (struct Geomnode *)((void *)0);
  new_nodes = 0;
  new_nodes_ptr = & new_nodes;
  pnum = 0;
  pnum_ptr = & pnum;
  qnum = 0;
  qnum_ptr = & qnum;
  group_psize_ptr = & group_psize;
  group_qsize_ptr = & group_qsize;
  pstep = (group_ptr->GRID_PTR)->PSTEP;
  qstep = (group_ptr->GRID_PTR)->QSTEP;
  angle = (group_ptr->GRID_PTR)->ANGLE;
  rot_angle = (group_ptr->GRID_PTR)->ROT_ANGLE;
  elem_pdim = (group_ptr->ELEM_PTR)->PDIM;
  elem_qdim = (group_ptr->ELEM_PTR)->QDIM;
  if ((group_ptr->ELEM_PTR)->GEOMETRY == 0) {
    elem_shape = 3;
  } else {
    elem_shape = 2;
  }
  add_ptr = group_ptr->ADDREM_PTR;
  nodes_num = 0;
  group_shape = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )add_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (add_ptr->ADDREM_TYPE == 1) {
      group_shape = 5;
      add_ptr = add_ptr->NEXT;
      goto while_continue;
    }
    {
    if (add_ptr->BLOCK_TYPE == 0) {
      goto case_0;
    }
    if (add_ptr->BLOCK_TYPE == 1) {
      goto case_1;
    }
    if (add_ptr->BLOCK_TYPE == 2) {
      goto case_2;
    }
    if (add_ptr->BLOCK_TYPE == 3) {
      goto case_3;
    }
    goto switch_default;
    case_0: /* CIL Label */ 
    {
    mksnode(add_ptr, app1_ptr, app2_ptr, pstep, qstep, angle, new_nodes_ptr, elem_shape,
            elem_pdim, elem_qdim);
    }
    if (group_shape == 0) {
      if ((group_ptr->ELEM_PTR)->GEOMETRY == 0) {
        group_shape = 3;
      } else {
        group_shape = 2;
      }
    } else {
      group_shape = 5;
    }
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    mksblock(add_ptr, app1_ptr, app2_ptr, pstep, qstep, angle, new_nodes_ptr, elem_shape,
             elem_pdim, elem_qdim);
    }
    if (group_shape == 0) {
      if (angle == (double )90) {
        group_shape = 3;
      } else {
        group_shape = 5;
      }
    } else {
      group_shape = 5;
    }
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    printf((char const   * __restrict  )"\nFunzione  mkpoly() non disponibile. ");
    }
    goto switch_break;
    case_3: /* CIL Label */ 
    if (elem_shape != 2) {
      {
      printf((char const   * __restrict  )"%s", ErrorMessages[7]);
      }
      return (7);
    }
    {
    mkshex(add_ptr, app1_ptr, app2_ptr, pstep, qstep, angle, new_nodes_ptr, elem_shape,
           elem_pdim, elem_qdim);
    }
    if (group_shape == 0) {
      group_shape = 2;
    } else {
      group_shape = 5;
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    interror((char *)"addscan() -1- ");
    }
    switch_break: /* CIL Label */ ;
    }
    nodes_num += *new_nodes_ptr;
    if ((unsigned long )primo_ptr == (unsigned long )((void *)0)) {
      primo_ptr = *app1_ptr;
    } else {
      ultimo_ptr->NEXT = *app1_ptr;
    }
    ultimo_ptr = *app2_ptr;
    ultimo_ptr->NEXT = (struct Geomnode *)((void *)0);
    add_ptr = add_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  if (rot_angle != (double )0) {
    {
    sgrrot(primo_ptr, (double )0, (double )0, rot_angle);
    group_shape = 5;
    }
  }
  if (group_shape == 2) {
    group_psize = (double )2 * pstep + (double )2 * (elem_pdim / (double )2);
    group_qsize = group_psize;
  } else { //Added block
  if (group_shape == 3) {
    {
    extremes(primo_ptr, pnum_ptr, qnum_ptr);
    group_psize = (double )(*pnum_ptr - 1) * pstep + (double )2 * (elem_pdim / (double )2);
    group_qsize = (double )(*qnum_ptr - 1) * qstep + (double )2 * (elem_qdim / (double )2);
    }
  } else {
    {
    extsize(primo_ptr, elem_pdim, elem_qdim, group_psize_ptr, group_qsize_ptr);
    }
  }
  }
  group_ptr->NUM_OF_NODES = nodes_num;
  group_ptr->SHAPE = group_shape;
  group_ptr->PSIZE = group_psize;
  group_ptr->QSIZE = group_qsize;
  group_ptr->GEOMNODE_PTR = primo_ptr;
  return (0);
}
}
int adremdef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *addrem_ptr = (struct AddRem *)((void *)0);
  error = adddef(*curr_ptr, curr_ptr, addrem_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[62]);
    }
    return (17);
  }
  if (error == 1) {
    {
    error = remdef(*curr_ptr, curr_ptr, addrem_ptr);
    }
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[63]);
    }
    return (17);
  }
  if (error == 1) {
    return (1);
  }
  return (17);
}
}
int ampunit(struct charac **tp , int *unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = *tp;
  *unit_ptr = 0;
  tmp___1 = GetKeyword(Keywords[15], curr_ptr);
  }
  if (tmp___1 == 0) {
    *unit_ptr = 0;
  } else {
    {
    tmp___0 = GetKeyword(Keywords[63], curr_ptr);
    }
    if (tmp___0 == 0) {
      *unit_ptr = 1;
    } else {
      {
      tmp = GetKeyword(Keywords[64], curr_ptr);
      }
      if (tmp == 0) {
        *unit_ptr = 2;
      } else {
        return (1);
      }
    }
  }
  *tp = *curr_ptr;
  return (0);
}
}
int ampval(struct charac *p1 , struct charac **pp2 , double *amp_ptr , int *amp_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetReal(amp_ptr, curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = ampunit(curr_ptr, amp_unit_ptr);
  }
  if (error != 0) {
    *amp_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int angclaus(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *angle_ptr = (double )0;
  *angle_unit_ptr = 0;
  error = GetKeyword(Keywords[23], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetReal(angle_ptr, curr_ptr);
  }
  if (error != 0) {
    *angle_ptr = (double )0;
    return (19);
  }
  {
  error = angunit(*curr_ptr, curr_ptr, angle_unit_ptr);
  }
  if (error != 0) {
    *angle_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int angledir(struct charac *p1 , struct charac **pp2 , double *theta_ptr , double *phi_ptr ,
             int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[70], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetReal(theta_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 73, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[71], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 1, Keywords[71]);
    }
    return (17);
  }
  {
  error = angval(*curr_ptr, curr_ptr, phi_ptr, angle_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 73, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int anglerot(struct charac *p1 , struct charac **pp2 , double *angle_start_ptr , double *angle_step_ptr ,
             int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[23], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[95], curr_ptr);
  error = 0;
  error = GetReal(angle_start_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 75, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[16], curr_ptr);
  error = 0;
  error = angval(*curr_ptr, curr_ptr, angle_step_ptr, angle_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 75, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int angstep(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ,
            double *pstep_ptr , double *qstep_ptr , int *pqstep_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error1 ;
  int error2 ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error1 = 0;
  error2 = 0;
  *angle_ptr = (double )0;
  *angle_unit_ptr = 0;
  *pstep_ptr = (double )0;
  *qstep_ptr = (double )0;
  *pqstep_unit_ptr = 0;
  error1 = angclaus(*curr_ptr, curr_ptr, angle_ptr, angle_unit_ptr);
  }
  if (error1 == 1) {
    *angle_ptr = (double )0;
    *angle_unit_ptr = 0;
  }
  {
  error2 = doubstep(*curr_ptr, curr_ptr, pstep_ptr, qstep_ptr, pqstep_unit_ptr);
  }
  if (error1 == 1) {
    if (error2 == 1) {
      *angle_ptr = (double )0;
      *angle_unit_ptr = 0;
      *pstep_ptr = (double )0;
      *qstep_ptr = (double )0;
      *pqstep_unit_ptr = 0;
      return (1);
    }
  }
  if (error2 != 0) {
    {
    parserro(*curr_ptr, error2, (char *)" ");
    *angle_ptr = (double )0;
    *angle_unit_ptr = 0;
    *pstep_ptr = (double )0;
    *qstep_ptr = (double )0;
    *pqstep_unit_ptr = 0;
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int angunit(struct charac *p1 , struct charac **pp2 , int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  *angle_unit_ptr = 0;
  tmp___0 = GetKeyword(Keywords[51], curr_ptr);
  }
  if (tmp___0 == 0) {
    *angle_unit_ptr = 0;
  } else {
    {
    tmp = GetKeyword(Keywords[52], curr_ptr);
    }
    if (tmp == 0) {
      *angle_unit_ptr = 1;
    } else {
      return (20);
    }
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int angval(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetReal(angle_ptr, curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = angunit(*curr_ptr, curr_ptr, angle_unit_ptr);
  }
  if (error != 0) {
    *angle_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
extern int gets() ;
int answer(char *domanda ) 
{ 
  char s[2] ;

  {
  {
  printf((char const   * __restrict  )"\n%s (Y/N): ", domanda);
  gets(s);
  }
  if ((int )s[0] == 78) {
    return (0);
  } else { //Added block
  if ((int )s[0] == 110) {
    return (0);
  } else {
    return (1);
  }
  }
}
}
int beampha(struct charac *p1 , struct charac **pp2 , double *u_ptr , double *v_ptr ,
            double *theta_ptr , double *phi_ptr , int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[96], curr_ptr);
  error = 0;
  error = uvdir(*curr_ptr, curr_ptr, u_ptr, v_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[73]);
    }
    return (17);
  }
  if (error == 1) {
    {
    error = angledir(*curr_ptr, curr_ptr, theta_ptr, phi_ptr, angle_unit_ptr);
    }
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[73]);
    }
    return (17);
  }
  {
  parserro(*curr_ptr, 73, (char *)" ");
  }
  return (17);
}
}
int blockdef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  int pcoord ;
  int *pcoord_ptr ;
  int qcoord ;
  int *qcoord_ptr ;
  struct Node *primo_ptr ;
  struct Node *ultimo_ptr ;
  struct Node *app_ptr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  curr_ptr = & curr;
  pcoord_ptr = & pcoord;
  qcoord_ptr = & qcoord;
  primo_ptr = (struct Node *)((void *)0);
  ultimo_ptr = (struct Node *)((void *)0);
  app_ptr = (struct Node *)((void *)0);
  *curr_ptr = p1;
  error = 0;
  *node_ptr = (struct Node *)((void *)0);
  error = GetKeyword(Keywords[76], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = nodecoor(*curr_ptr, curr_ptr, pcoord_ptr, qcoord_ptr);
  }
  if (error == 1) {
    {
    parserro(*curr_ptr, 56, (char *)" ");
    }
    return (17);
  }
  if (error == 17) {
    {
    parserro(*curr_ptr, 56, (char *)" ");
    }
    return (17);
  }
  {
  tmp = malloc(sizeof(struct Node ));
  app_ptr = (struct Node *)tmp;
  }
  if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
    {
    parserro(*curr_ptr, 55, (char *)" ");
    interror((char *)"blockdef()");
    exit(1);
    }
  }
  {
  app_ptr->PCOORD = pcoord;
  app_ptr->QCOORD = qcoord;
  app_ptr->THEA = (double )0;
  app_ptr->PHEA = (double )0;
  app_ptr->PSEA = (double )0;
  app_ptr->ANGLE_UNIT = 0;
  app_ptr->NEXT = (struct Node *)((void *)0);
  primo_ptr = app_ptr;
  ultimo_ptr = app_ptr;
  error = nodecoor(*curr_ptr, curr_ptr, pcoord_ptr, qcoord_ptr);
  }
  if (error == 1) {
    {
    parserro(*curr_ptr, 56, (char *)" ");
    }
    return (17);
  }
  if (error == 17) {
    {
    parserro(*curr_ptr, 57, (char *)" ");
    }
    return (17);
  }
  {
  tmp___0 = malloc(sizeof(struct Node ));
  app_ptr = (struct Node *)tmp___0;
  }
  if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
    {
    parserro(*curr_ptr, 55, (char *)" ");
    interror((char *)"blockdef()");
    exit(1);
    }
  }
  app_ptr->PCOORD = pcoord;
  app_ptr->QCOORD = qcoord;
  app_ptr->THEA = (double )0;
  app_ptr->PHEA = (double )0;
  app_ptr->PSEA = (double )0;
  app_ptr->ANGLE_UNIT = 0;
  app_ptr->NEXT = (struct Node *)((void *)0);
  ultimo_ptr->NEXT = app_ptr;
  ultimo_ptr = app_ptr;
  *node_ptr = primo_ptr;
  *pp2 = *curr_ptr;
  return (0);
}
}
int circpol(struct charac *p1 , struct charac **pp2 , int *direction_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  error = 0;
  *curr_ptr = p1;
  *direction_ptr = 0;
  error = GetKeyword(Keywords[38], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[65], curr_ptr);
  }
  if (error == 0) {
    *direction_ptr = 0;
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = GetKeyword(Keywords[66], curr_ptr);
  }
  if (error == 0) {
    *direction_ptr = 1;
    *pp2 = *curr_ptr;
    return (0);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int circspec(struct charac *p1 , struct charac **pp2 , double *radius_ptr , int *radius_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  error = 0;
  *curr_ptr = p1;
  error = GetKeyword(Keywords[38], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[5], curr_ptr);
  error = 0;
  error = Get1Real(*curr_ptr, curr_ptr, radius_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    }
    return (17);
  }
  {
  error = lenunit(curr_ptr, radius_unit_ptr);
  }
  if (error != 0) {
    *radius_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int cosinus(struct charac *p1 , struct charac **pp2 , double *exp_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  error = 0;
  *curr_ptr = p1;
  error = GetKeyword(Keywords[34], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetReal(exp_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 26, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
double dacos(double x ) 
{ 
  double tmp ;

  {
  {
  tmp = acos(x);
  }
  return ((tmp * (double )180) / 3.141592654);
}
}
double dasin(double x ) 
{ 
  double tmp ;

  {
  {
  tmp = asin(x);
  }
  return ((tmp * (double )180) / 3.141592654);
}
}
double datan(double x ) 
{ 
  double tmp ;

  {
  {
  tmp = atan(x);
  }
  return ((tmp * (double )180) / 3.141592654);
}
}
double dcos(double x ) 
{ 
  double tmp ;

  {
  {
  tmp = cos((x * 3.141592654) / (double )180);
  }
  return (tmp);
}
}
int degconv(double *x_ptr , int unit ) 
{ 


  {
  {
  if (unit == 0) {
    goto case_0;
  }
  if (unit == 1) {
    goto case_1;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  goto switch_break;
  case_1: /* CIL Label */ 
  *x_ptr *= (double )180 / 3.141592654;
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  interror((char *)"degconv");
  }
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
double doubmax(double a , double b ) 
{ 


  {
  if (a > b) {
    return (a);
  } else {
    return (b);
  }
}
}
double doubmin(double a , double b ) 
{ 


  {
  if (a < b) {
    return (a);
  } else {
    return (b);
  }
}
}
int doubstep(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , double *qstep_ptr ,
             int *pqstep_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *pstep_ptr = (double )0;
  *qstep_ptr = (double )0;
  *pqstep_unit_ptr = 0;
  error = GetKeyword(Keywords[19], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetUReal(*curr_ptr, curr_ptr, pstep_ptr);
  }
  if (error != 0) {
    *pstep_ptr = (double )0;
    *qstep_ptr = (double )0;
    *pqstep_unit_ptr = 0;
    return (error);
  }
  {
  error = GetKeyword(Keywords[20], curr_ptr);
  }
  if (error != 0) {
    return (17);
  }
  {
  error = GetUReal(*curr_ptr, curr_ptr, qstep_ptr);
  }
  if (error != 0) {
    *pstep_ptr = (double )0;
    *qstep_ptr = (double )0;
    *pqstep_unit_ptr = 0;
    return (error);
  }
  {
  error = lenunit(curr_ptr, pqstep_unit_ptr);
  }
  if (error != 0) {
    *pqstep_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
double dsin(double x ) 
{ 
  double tmp ;

  {
  {
  tmp = sin((x * 3.141592654) / (double )180);
  }
  return (tmp);
}
}
int elemdef(struct charac *p1 , struct charac **pp2 , struct Elem **elem_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  char name[101] ;
  void *tmp ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  tmp = malloc(sizeof(struct Elem ));
  *elem_ptr = (struct Elem *)tmp;
  }
  if ((unsigned long )*elem_ptr == (unsigned long )((void *)0)) {
    {
    parserro(*curr_ptr, 55, (char *)" ");
    interror((char *)"elemdef()");
    }
  }
  {
  error = GetKeyword(Keywords[28], curr_ptr);
  }
  if (error != 0) {
    *elem_ptr = (struct Elem *)((void *)0);
    return (1);
  }
  {
  error = GetUName(name, curr_ptr);
  }
  if (error == 0) {
    {
    strcpy((char * __restrict  )((*elem_ptr)->NAME), (char const   * __restrict  )(name));
    (*elem_ptr)->TYPE = 1;
    *pp2 = *curr_ptr;
    }
    return (0);
  }
  {
  error = sinelem(*curr_ptr, curr_ptr, elem_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  return (17);
}
}
void emsginit(void) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= 100)) {
      goto while_break;
    }
    ErrorMessages[i][0] = (char )'\000';
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  strcpy((char * __restrict  )(ErrorMessages[0]), (char const   * __restrict  )"** ERROR 0: NO ERRORS");
  strcpy((char * __restrict  )(ErrorMessages[1]), (char const   * __restrict  )"** ERROR 1: Keyword expected: ");
  strcpy((char * __restrict  )(ErrorMessages[2]), (char const   * __restrict  )"** ERROR 2: User name expected: ");
  strcpy((char * __restrict  )(ErrorMessages[3]), (char const   * __restrict  )"** ERROR 3: User name already used: ");
  strcpy((char * __restrict  )(ErrorMessages[4]), (char const   * __restrict  )"** ERROR 4: Unexpected end of file.");
  strcpy((char * __restrict  )(ErrorMessages[5]), (char const   * __restrict  )"** ERROR 5: Illegal user name: ");
  strcpy((char * __restrict  )(ErrorMessages[6]), (char const   * __restrict  )"** ERROR 6: Keywords may not be used as user names: ");
  strcpy((char * __restrict  )(ErrorMessages[7]), (char const   * __restrict  )"** WARNING 7: User name too long: ");
  strcpy((char * __restrict  )(ErrorMessages[8]), (char const   * __restrict  )"** ERROR 8: Missing array name declaration.");
  strcpy((char * __restrict  )(ErrorMessages[9]), (char const   * __restrict  )"** ERROR 9: Missing array surface definition.");
  strcpy((char * __restrict  )(ErrorMessages[10]), (char const   * __restrict  )"** ERROR 10: Incorrect array surface definition.");
  strcpy((char * __restrict  )(ErrorMessages[11]), (char const   * __restrict  )"** ERROR 11: No valid real value found.");
  strcpy((char * __restrict  )(ErrorMessages[12]), (char const   * __restrict  )"** ERROR 12: Negative value found: ");
  strcpy((char * __restrict  )(ErrorMessages[13]), (char const   * __restrict  )"** ERROR 13: Real not found.");
  strcpy((char * __restrict  )(ErrorMessages[14]), (char const   * __restrict  )"** ERROR 14: No length unit found, millimetres assumed.");
  strcpy((char * __restrict  )(ErrorMessages[15]), (char const   * __restrict  )"** ERROR 15: Incorrect cylinder AXIS declaration. Axis must be X or Y.");
  strcpy((char * __restrict  )(ErrorMessages[16]), (char const   * __restrict  )"** ERROR 16: Incorrect GRID definition.");
  strcpy((char * __restrict  )(ErrorMessages[17]), (char const   * __restrict  )"** ERROR 17: Incorrect definition.");
  strcpy((char * __restrict  )(ErrorMessages[18]), (char const   * __restrict  )"** ERROR 18: Missing double step definition.");
  strcpy((char * __restrict  )(ErrorMessages[19]), (char const   * __restrict  )"** ERROR 19: No valid angle value found.");
  strcpy((char * __restrict  )(ErrorMessages[20]), (char const   * __restrict  )"** ERROR 20: No angle unit found, degrees assumed.");
  strcpy((char * __restrict  )(ErrorMessages[21]), (char const   * __restrict  )"** ERROR 21: Can not open input file:");
  strcpy((char * __restrict  )(ErrorMessages[22]), (char const   * __restrict  )"** ERROR 22: Out of memory during input file reading.");
  strcpy((char * __restrict  )(ErrorMessages[23]), (char const   * __restrict  )"** ERROR 23: Empty input file:");
  strcpy((char * __restrict  )(ErrorMessages[24]), (char const   * __restrict  )"** ERROR 24: Incorrect ELEMENT definition.");
  strcpy((char * __restrict  )(ErrorMessages[25]), (char const   * __restrict  )"** ERROR 25: Incorrect RECTANGULAR element definition.");
  strcpy((char * __restrict  )(ErrorMessages[26]), (char const   * __restrict  )"** ERROR 26: Missing COSINUS parameter.");
  strcpy((char * __restrict  )(ErrorMessages[27]), (char const   * __restrict  )"** ERROR 27: No valid amplitude value found.");
  strcpy((char * __restrict  )(ErrorMessages[28]), (char const   * __restrict  )"** ERROR 28: Incorrect CIRCULAR element definition ");
  strcpy((char * __restrict  )(ErrorMessages[29]), (char const   * __restrict  )"** ERROR 29: Missing GAUSSIAN parameter(s).");
  strcpy((char * __restrict  )(ErrorMessages[30]), (char const   * __restrict  )"** ERROR 30: Incorrect element ORIENTATION definition.");
  strcpy((char * __restrict  )(ErrorMessages[31]), (char const   * __restrict  )"** ERROR 31: Incorrect element LINEAR polarization definition.");
  strcpy((char * __restrict  )(ErrorMessages[32]), (char const   * __restrict  )"** ERROR 32: Incorrect element CIRCULAR polarization definition.");
  strcpy((char * __restrict  )(ErrorMessages[33]), (char const   * __restrict  )"** ERROR 33: No angle unit found, dB assumed.");
  strcpy((char * __restrict  )(ErrorMessages[34]), (char const   * __restrict  )"** ERROR 34: Incorrect element GEOMETRY definition.");
  strcpy((char * __restrict  )(ErrorMessages[35]), (char const   * __restrict  )"** ERROR 35: Incorrect element MODEL definition.");
  strcpy((char * __restrict  )(ErrorMessages[36]), (char const   * __restrict  )"** ERROR 36: Incorrect element POLARIZATION definition.");
  strcpy((char * __restrict  )(ErrorMessages[37]), (char const   * __restrict  )"** ERROR 37: No phase value found.");
  strcpy((char * __restrict  )(ErrorMessages[38]), (char const   * __restrict  )"** ERROR 38: Incorrect element POL_ORIENT definition.");
  strcpy((char * __restrict  )(ErrorMessages[39]), (char const   * __restrict  )"** ERROR 39: Incorrect element PORT AMPLITUDE definition.");
  strcpy((char * __restrict  )(ErrorMessages[40]), (char const   * __restrict  )"** ERROR 40: Incorrect element PORT phase definition.");
  strcpy((char * __restrict  )(ErrorMessages[41]), (char const   * __restrict  )"** ERROR 41: Natural number expected.");
  strcpy((char * __restrict  )(ErrorMessages[42]), (char const   * __restrict  )"** ERROR 42: Integer not found.");
  strcpy((char * __restrict  )(ErrorMessages[43]), (char const   * __restrict  )"** ERROR 43: Number too long: ");
  strcpy((char * __restrict  )(ErrorMessages[44]), (char const   * __restrict  )"** ERROR 44: Natural not found.");
  strcpy((char * __restrict  )(ErrorMessages[45]), (char const   * __restrict  )"** ERROR 45: Null value found.");
  strcpy((char * __restrict  )(ErrorMessages[46]), (char const   * __restrict  )"** ERROR 46: Too few PORT definitions.");
  strcpy((char * __restrict  )(ErrorMessages[47]), (char const   * __restrict  )"** ERROR 47: Incorrect definition at PORT: ");
  strcpy((char * __restrict  )(ErrorMessages[48]), (char const   * __restrict  )"** ERROR 48: Incorrect element GAIN definition.");
  strcpy((char * __restrict  )(ErrorMessages[49]), (char const   * __restrict  )"** ERROR 49: Incorrect element PORTS definition.");
  strcpy((char * __restrict  )(ErrorMessages[50]), (char const   * __restrict  )"** ERROR 50: Missing P coordinate.");
  strcpy((char * __restrict  )(ErrorMessages[51]), (char const   * __restrict  )"** ERROR 51: Missing Q coordinate.");
  strcpy((char * __restrict  )(ErrorMessages[52]), (char const   * __restrict  )"** ERROR 52: Missing NODE coordinates.");
  strcpy((char * __restrict  )(ErrorMessages[53]), (char const   * __restrict  )"** ERROR 53: Incorrect NODE coordinates definition.");
  strcpy((char * __restrict  )(ErrorMessages[54]), (char const   * __restrict  )"** ERROR 54: Incorrect NODE ORIENTATION definition.");
  strcpy((char * __restrict  )(ErrorMessages[55]), (char const   * __restrict  )"** ERROR 55: Out of memory during input data reading.");
  strcpy((char * __restrict  )(ErrorMessages[56]), (char const   * __restrict  )"** ERROR 56: Missing BLOCK coordinate(s).");
  strcpy((char * __restrict  )(ErrorMessages[57]), (char const   * __restrict  )"** ERROR 57: Incorrect BLOCK coordinates definition.");
  strcpy((char * __restrict  )(ErrorMessages[58]), (char const   * __restrict  )"** ERROR 58: Incorrect NODE definition.");
  strcpy((char * __restrict  )(ErrorMessages[59]), (char const   * __restrict  )"** ERROR 59: Incorrect BLOCK definition.");
  strcpy((char * __restrict  )(ErrorMessages[60]), (char const   * __restrict  )"** ERROR 60: Incorrect POLYGON definition.");
  strcpy((char * __restrict  )(ErrorMessages[61]), (char const   * __restrict  )"** ERROR 61: Incorrect HEXAGON definition.");
  strcpy((char * __restrict  )(ErrorMessages[62]), (char const   * __restrict  )"** ERROR 62: Incorrect ADD statement.");
  strcpy((char * __restrict  )(ErrorMessages[63]), (char const   * __restrict  )"** ERROR 63: Incorrect REMOVE statement.");
  strcpy((char * __restrict  )(ErrorMessages[64]), (char const   * __restrict  )"** ERROR 64: Incorrect ADD or REMOVE statement.");
  strcpy((char * __restrict  )(ErrorMessages[65]), (char const   * __restrict  )"** ERROR 65: 3 or more node coordinates expected.");
  strcpy((char * __restrict  )(ErrorMessages[66]), (char const   * __restrict  )"** ERROR 66: Incorrect or missing node coordinates.");
  strcpy((char * __restrict  )(ErrorMessages[67]), (char const   * __restrict  )"** ERROR 67: Missing ELEMENT definition after GRID definition.");
  strcpy((char * __restrict  )(ErrorMessages[68]), (char const   * __restrict  )"** ERROR 68: Missing SECOND ORDER parameter(s).");
  strcpy((char * __restrict  )(ErrorMessages[69]), (char const   * __restrict  )"** ERROR 69: Incorrect SECOND ORDER amplitude definition.");
  strcpy((char * __restrict  )(ErrorMessages[70]), (char const   * __restrict  )"** ERROR 70: Incorrect GROUP EXCITATION AMPLITUDE definition.");
  strcpy((char * __restrict  )(ErrorMessages[71]), (char const   * __restrict  )"** ERROR 71: Missing POINTING parameter(s).");
  strcpy((char * __restrict  )(ErrorMessages[72]), (char const   * __restrict  )"** ERROR 72: U or V value out of range [-1,1].");
  strcpy((char * __restrict  )(ErrorMessages[73]), (char const   * __restrict  )"** ERROR 73: Incorrect POINTING direction definition.");
  strcpy((char * __restrict  )(ErrorMessages[74]), (char const   * __restrict  )"** ERROR 74: Incorrect PHASE parameters.");
  strcpy((char * __restrict  )(ErrorMessages[75]), (char const   * __restrict  )"** ERROR 75: Incorrect ANGLE parameters.");
  strcpy((char * __restrict  )(ErrorMessages[76]), (char const   * __restrict  )"** ERROR 76: Incorrect SECOND ORDER phase definition.");
  strcpy((char * __restrict  )(ErrorMessages[77]), (char const   * __restrict  )"** ERROR 77: Incorrect ROTATION SEQUENTIAL phase definition.");
  strcpy((char * __restrict  )(ErrorMessages[78]), (char const   * __restrict  )"** ERROR 78: Incorrect POINTING phase definition.");
  strcpy((char * __restrict  )(ErrorMessages[79]), (char const   * __restrict  )"** ERROR 79: Incorrect AMPLITUDE excitation definition.");
  strcpy((char * __restrict  )(ErrorMessages[80]), (char const   * __restrict  )"** ERROR 80: Incorrect PHASE excitation definition.");
  strcpy((char * __restrict  )(ErrorMessages[81]), (char const   * __restrict  )"** ERROR 81: Missing GROUP name.");
  strcpy((char * __restrict  )(ErrorMessages[82]), (char const   * __restrict  )"** ERROR 82: Incorrect GROUP definition, group: ");
  strcpy((char * __restrict  )(ErrorMessages[83]), (char const   * __restrict  )"** ERROR 83: Missing coordinate(s) in: ADD_GROUP ");
  strcpy((char * __restrict  )(ErrorMessages[84]), (char const   * __restrict  )"** ERROR 84: Missing DISPLACE coordinate(s).");
  strcpy((char * __restrict  )(ErrorMessages[85]), (char const   * __restrict  )"** ERROR 85: Missing MOVE coordinate(s).");
  strcpy((char * __restrict  )(ErrorMessages[86]), (char const   * __restrict  )"** ERROR 86: Missing coordinate(s) in: PLACE_GROUP ");
  strcpy((char * __restrict  )(ErrorMessages[87]), (char const   * __restrict  )"** ERROR 87: Missing GROUP definition in array: ");
  strcpy((char * __restrict  )(ErrorMessages[88]), (char const   * __restrict  )"** ERROR 88: Incorrect GROUP definition in array:");
  strcpy((char * __restrict  )(ErrorMessages[89]), (char const   * __restrict  )"** ERROR 89: Incorrect DISPLACE_AT statement.");
  strcpy((char * __restrict  )(ErrorMessages[90]), (char const   * __restrict  )"** ERROR 90: Incorrect MOVE_TO statement.");
  strcpy((char * __restrict  )(ErrorMessages[91]), (char const   * __restrict  )"** ERROR 91: Missing ADD_GROUP or PLACE_GROUP statement.");
  strcpy((char * __restrict  )(ErrorMessages[92]), (char const   * __restrict  )"** ERROR 92: Incorrect ADD_GROUP or PLACE_GROUP statement.");
  strcpy((char * __restrict  )(ErrorMessages[93]), (char const   * __restrict  )"** ERROR 93: Incorrect PORTS number.");
  strcpy((char * __restrict  )(ErrorMessages[94]), (char const   * __restrict  )"** ERROR 94: At least one ADD statement is required.");
  strcpy((char * __restrict  )(ErrorMessages[95]), (char const   * __restrict  )"** ERROR 95: ");
  strcpy((char * __restrict  )(ErrorMessages[96]), (char const   * __restrict  )"** ERROR 96: ");
  strcpy((char * __restrict  )(ErrorMessages[97]), (char const   * __restrict  )"** ERROR 97: ");
  strcpy((char * __restrict  )(ErrorMessages[98]), (char const   * __restrict  )"** ERROR 98: ");
  strcpy((char * __restrict  )(ErrorMessages[99]), (char const   * __restrict  )"** ERROR 99: ");
  }
  return;
}
}
int EndOfTape(struct charac **p ) 
{ 


  {
  if ((unsigned long )*p == (unsigned long )((void *)0)) {
    return (1);
  }
  return (0);
}
}
int extmod(struct charac *p1 , struct charac **pp2 ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  error = 0;
  *curr_ptr = p1;
  error = GetKeyword(Keywords[33], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int extremes(struct Geomnode *gnode_ptr , int *pnum_ptr , int *qnum_ptr ) 
{ 
  struct Geomnode *app_ptr ;
  int pmin ;
  int pmax ;
  int qmin ;
  int qmax ;

  {
  pmin = 2147483647;
  pmax = (-0x7FFFFFFF-1);
  qmin = 2147483647;
  qmax = (-0x7FFFFFFF-1);
  app_ptr = gnode_ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (app_ptr->LOC_P < pmin) {
      pmin = app_ptr->LOC_P;
    }
    if (app_ptr->LOC_P > pmax) {
      pmax = app_ptr->LOC_P;
    }
    if (app_ptr->LOC_Q < qmin) {
      qmin = app_ptr->LOC_Q;
    }
    if (app_ptr->LOC_Q > qmax) {
      qmax = app_ptr->LOC_Q;
    }
    app_ptr = app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  *pnum_ptr = (pmax - pmin) + 1;
  *qnum_ptr = (qmax - qmin) + 1;
  return (0);
}
}
int extsize(struct Geomnode *gnode_ptr , double elem_pdim , double elem_qdim , double *xsize_ptr ,
            double *ysize_ptr ) 
{ 
  struct Geomnode *app_ptr ;
  double xmin ;
  double xmax ;
  double ymin ;
  double ymax ;

  {
  xmin = (double )1.79769313486231570815e+308L;
  xmax = (double )2.22507385850720138309e-308L;
  ymin = (double )1.79769313486231570815e+308L;
  ymax = (double )2.22507385850720138309e-308L;
  app_ptr = gnode_ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (app_ptr->XA < xmin) {
      xmin = app_ptr->XA;
    }
    if (app_ptr->XA > xmax) {
      xmax = app_ptr->XA;
    }
    if (app_ptr->YA < ymin) {
      ymin = app_ptr->YA;
    }
    if (app_ptr->YA > ymax) {
      ymax = app_ptr->YA;
    }
    app_ptr = app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  *xsize_ptr = (xmax - xmin) + (double )2 * (elem_pdim / (double )2);
  *ysize_ptr = (ymax - ymin) + (double )2 * (elem_qdim / (double )2);
  return (0);
}
}
int fixgramp(struct GrAmpExc *g ) 
{ 
  double unif_val ;
  double *unif_val_ptr ;
  double centre ;
  double *centre_ptr ;
  double p1_et ;
  double *p1_et_ptr ;
  double p2_et ;
  double *p2_et_ptr ;
  double q1_et ;
  double *q1_et_ptr ;
  double q2_et ;
  double *q2_et_ptr ;
  int amp_unit ;

  {
  unif_val_ptr = & unif_val;
  centre_ptr = & centre;
  p1_et_ptr = & p1_et;
  p2_et_ptr = & p2_et;
  q1_et_ptr = & q1_et;
  q2_et_ptr = & q2_et;
  unif_val = g->UNIF_VAL;
  centre = g->CENTRE;
  p1_et = g->P1_ET;
  p2_et = g->P2_ET;
  q1_et = g->Q1_ET;
  q2_et = g->Q2_ET;
  amp_unit = g->AMP_UNIT;
  {
  if (g->TYPE == 0) {
    goto case_0;
  }
  if (g->TYPE == 1) {
    goto case_1;
  }
  if (g->TYPE == 2) {
    goto case_2;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  if (unif_val == (double )0) {
    unif_val = (double )1;
  }
  {
  linconv(unif_val_ptr, amp_unit);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  linconv(centre_ptr, amp_unit);
  linconv(p1_et_ptr, amp_unit);
  linconv(p2_et_ptr, amp_unit);
  linconv(q1_et_ptr, amp_unit);
  linconv(q2_et_ptr, amp_unit);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  printf((char const   * __restrict  )"\nPQEXPR: not available");
  exit(1);
  interror((char *)"fixgramp()");
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  interror((char *)"\nfixgramp(): group amplitude type not correct");
  }
  switch_break: /* CIL Label */ ;
  }
  g->UNIF_VAL = unif_val;
  g->CENTRE = centre;
  g->P1_ET = p1_et;
  g->P2_ET = p2_et;
  g->Q1_ET = q1_et;
  g->Q2_ET = q2_et;
  g->AMP_UNIT = 0;
  return (0);
}
}
int fixgrpha(struct GrPhaExc *g ) 
{ 


  {
  {
  if (g->TYPE == 0) {
    goto case_0;
  }
  if (g->TYPE == 1) {
    goto case_1;
  }
  if (g->TYPE == 2) {
    goto case_2;
  }
  if (g->TYPE == 3) {
    goto case_3;
  }
  if (g->TYPE == 4) {
    goto case_4;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  if (g->UNIF_VAL == (double )0) {
    g->UNIF_VAL = (double )0;
  }
  {
  degconv(& g->UNIF_VAL, g->PHASE_UNIT);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  degconv(& g->CENTRE, g->PHASE_UNIT);
  degconv(& g->P1_EP, g->PHASE_UNIT);
  degconv(& g->P2_EP, g->PHASE_UNIT);
  degconv(& g->Q1_EP, g->PHASE_UNIT);
  degconv(& g->Q2_EP, g->PHASE_UNIT);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  printf((char const   * __restrict  )"\nPQEXPR: not available");
  exit(1);
  interror((char *)"fixgrpha()");
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  if (g->OMIT_ANGLE == 0) {
    {
    degconv(& g->ANGLE_START, g->ANGLE_UNIT);
    degconv(& g->ANGLE_STEP, g->ANGLE_UNIT);
    }
  }
  if (g->OMIT_PHASE == 0) {
    {
    degconv(& g->PHASE_START, g->PHASE_UNIT);
    degconv(& g->PHASE_STEP, g->PHASE_UNIT);
    }
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  degconv(& g->THETA, g->ANGLE_UNIT);
  degconv(& g->PHI, g->ANGLE_UNIT);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  interror((char *)"\nfixgrpha(): GROUP_EXCITATION phase law type not correct");
  }
  switch_break: /* CIL Label */ ;
  }
  g->PHASE_UNIT = 0;
  return (0);
}
}
int fixnodor(struct Node *node_ptr ) 
{ 


  {
  if (node_ptr->OMIT_ORIENT == 1) {
    node_ptr->THEA = (double )0;
    node_ptr->PHEA = (double )0;
    node_ptr->PSEA = (double )0;
    node_ptr->ANGLE_UNIT = 0;
  } else { //Added block
  if (node_ptr->ANGLE_UNIT == 1) {
    node_ptr->THEA *= (double )180 / 3.141592654;
    node_ptr->PHEA *= (double )180 / 3.141592654;
    node_ptr->PSEA *= (double )180 / 3.141592654;
    node_ptr->ANGLE_UNIT = 0;
  }
  }
  return (0);
}
}
int fixport(struct Elem *elem_ptr ) 
{ 
  struct Port *app_ptr ;
  double amp ;
  double *amp_ptr ;
  double ang ;
  double *ang_ptr ;

  {
  amp_ptr = & amp;
  ang_ptr = & ang;
  app_ptr = elem_ptr->PORT_PTR;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    amp = app_ptr->AMP;
    linconv(amp_ptr, app_ptr->AMP_UNIT);
    app_ptr->AMP = amp;
    ang = app_ptr->PSC;
    degconv(ang_ptr, app_ptr->PSC_UNIT);
    app_ptr->PSC = ang;
    ang = app_ptr->PSH;
    degconv(ang_ptr, app_ptr->PSH_UNIT);
    app_ptr->PSH = ang;
    ang = app_ptr->PPA;
    degconv(ang_ptr, app_ptr->PPA_UNIT);
    app_ptr->PPA = ang;
    }
    if (elem_ptr->POLARIZATION == 0) {
      if (app_ptr->OMIT_POL == 1) {
        app_ptr->PHEPOL = elem_ptr->PHEPOL;
        app_ptr->PHEPOL_UNIT = elem_ptr->PHEPOL_UNIT;
      }
      {
      ang = app_ptr->PHEPOL;
      degconv(ang_ptr, app_ptr->PHEPOL_UNIT);
      app_ptr->PHEPOL = ang;
      }
    }
    app_ptr->AMP_UNIT = 0;
    app_ptr->PSC_UNIT = 0;
    app_ptr->PSH_UNIT = 0;
    app_ptr->PPA_UNIT = 0;
    app_ptr->PHEPOL_UNIT = 0;
    app_ptr = app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int fixselem(struct Elem *elem_ptr ) 
{ 
  double radius ;
  double *radius_ptr ;
  int radius_unit ;
  double pdim ;
  double *pdim_ptr ;
  double qdim ;
  double *qdim_ptr ;
  int pqdim_unit ;
  struct Port *port_ptr ;
  void *tmp ;

  {
  radius_ptr = & radius;
  pdim_ptr = & pdim;
  qdim_ptr = & qdim;
  port_ptr = (struct Port *)((void *)0);
  radius = elem_ptr->RADIUS;
  radius_unit = elem_ptr->RADIUS_UNIT;
  pdim = elem_ptr->PDIM;
  qdim = elem_ptr->QDIM;
  pqdim_unit = elem_ptr->PQDIM_UNIT;
  {
  if (elem_ptr->GEOMETRY == 0) {
    goto case_0;
  }
  if (elem_ptr->GEOMETRY == 1) {
    goto case_1;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  mmconv(pdim_ptr, pqdim_unit);
  mmconv(qdim_ptr, pqdim_unit);
  radius = sqrt(pdim * pdim + qdim * qdim);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  mmconv(radius_ptr, radius_unit);
  pdim = (double )2 * radius;
  qdim = (double )2 * radius;
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  interror((char *)"fixselem - 1");
  }
  switch_break: /* CIL Label */ ;
  }
  radius_unit = 0;
  pqdim_unit = 0;
  if (elem_ptr->NPORTS == 0) {
    {
    tmp = malloc(sizeof(struct Port ));
    port_ptr = (struct Port *)tmp;
    }
    if ((unsigned long )port_ptr == (unsigned long )((void *)0)) {
      {
      printf((char const   * __restrict  )"%s", ErrorMessages[55]);
      interror((char *)"fixselem() -2- ");
      }
    }
    port_ptr->PORTNUM = 1;
    port_ptr->AMP = (double )1;
    port_ptr->AMP_UNIT = 0;
    port_ptr->PSC = (double )0;
    port_ptr->PSC_UNIT = 0;
    port_ptr->PSH = (double )0;
    port_ptr->PSH_UNIT = 0;
    port_ptr->PPA = (double )0;
    port_ptr->PPA_UNIT = 0;
    port_ptr->PHEPOL = (double )90;
    port_ptr->PHEPOL_UNIT = 0;
    port_ptr->OMIT_POL = 1;
    port_ptr->NEXT = (struct Port *)((void *)0);
    elem_ptr->NPORTS = 1;
    elem_ptr->PORT_PTR = port_ptr;
  }
  {
  fixport(elem_ptr);
  elem_ptr->RADIUS = radius;
  elem_ptr->RADIUS_UNIT = radius_unit;
  elem_ptr->PDIM = pdim;
  elem_ptr->QDIM = qdim;
  elem_ptr->PQDIM_UNIT = pqdim_unit;
  }
  return (0);
}
}
int fixsgrel(struct Group *group_ptr ) 
{ 
  struct Grid *grid ;
  struct Elem *elem ;
  double pstep ;
  double qstep ;
  double angle ;
  double rot_angle ;
  double radius ;
  double pdim ;
  double qdim ;
  double px ;
  double py ;
  double qx ;
  double qy ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
  grid = group_ptr->GRID_PTR;
  elem = group_ptr->ELEM_PTR;
  fixselem(elem);
  fixsgrid(grid);
  grid->ROT_ANGLE = (double )0;
  }
  {
  if (grid->TYPE == 0) {
    goto case_0;
  }
  if (grid->TYPE == 1) {
    goto case_1;
  }
  if (grid->TYPE == 2) {
    goto case_2;
  }
  if (grid->TYPE == 3) {
    goto case_3;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  if (grid->PSTEP == (double )0) {
    if ((group_ptr->GRPHAEXC_PTR)->TYPE == 3) {
      grid->PSTEP = elem->RADIUS;
      grid->QSTEP = elem->RADIUS;
    } else {
      {
      grid->PSTEP = doubmax(elem->PDIM, elem->QDIM);
      grid->QSTEP = doubmax(elem->PDIM, elem->QDIM);
      }
    }
  } else { //Added block
  if ((group_ptr->GRPHAEXC_PTR)->TYPE == 3) {
    if (grid->PSTEP < elem->RADIUS) {
      {
      printf((char const   * __restrict  )"\n%s%s", MOSErrors[12], group_ptr->NAME);
      }
    }
  } else {
    {
    tmp = doubmax(elem->PDIM, elem->QDIM);
    }
    if (grid->PSTEP < tmp) {
      {
      printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
      }
    }
  }
  }
  grid->ANGLE = (double )90;
  goto switch_break;
  case_1: /* CIL Label */ 
  if (grid->PSTEP == (double )0) {
    if ((group_ptr->GRPHAEXC_PTR)->TYPE == 3) {
      grid->PSTEP = elem->RADIUS;
      grid->QSTEP = elem->RADIUS;
    } else {
      grid->PSTEP = elem->PDIM;
      grid->QSTEP = elem->QDIM;
    }
  } else { //Added block
  if ((group_ptr->GRPHAEXC_PTR)->TYPE == 3) {
    if (grid->PSTEP < elem->RADIUS) {
      {
      printf((char const   * __restrict  )"\n%s%s", MOSErrors[12], group_ptr->NAME);
      }
    }
  } else { //Added block
  if (grid->PSTEP < elem->PDIM) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
    }
  } else { //Added block
  if (grid->QSTEP < elem->QDIM) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
    }
  }
  }
  }
  }
  grid->ANGLE = (double )90;
  goto switch_break;
  case_2: /* CIL Label */ 
  if (elem->GEOMETRY != 1) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[3], group_ptr->NAME);
    exit(1);
    }
  }
  if (grid->PSTEP == (double )0) {
    grid->PSTEP = elem->PDIM;
    grid->QSTEP = elem->PDIM;
  } else { //Added block
  if (grid->PSTEP < elem->PDIM) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
    }
  }
  }
  grid->ANGLE = (double )60;
  goto switch_break;
  case_3: /* CIL Label */ 
  if (grid->PX != (double )0) {
    {
    px = grid->PX;
    py = grid->PY;
    qx = grid->QX;
    qy = grid->QY;
    pstep = sqrt(px * px + py * py);
    qstep = sqrt(qx * qx + qy * qy);
    angle = dacos((px * qx + py * qy) / (pstep * qstep));
    rot_angle = dacos(px / pstep);
    grid->PSTEP = pstep;
    grid->QSTEP = qstep;
    grid->ANGLE = angle;
    grid->ROT_ANGLE = rot_angle;
    }
  } else { //Added block
  if (grid->PSTEP == (double )0) {
    if (grid->QSTEP == (double )0) {
      if (grid->ANGLE == (double )0) {
        {
        if (elem->GEOMETRY == 1) {
          goto case_1___0;
        }
        if (elem->GEOMETRY == 0) {
          goto case_0___0;
        }
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
        radius = elem->PDIM / (double )2;
        angle = (double )60;
        pstep = (double )2 * radius;
        if (angle > (double )45) {
          if (angle <= (double )60) {
            {
            tmp___0 = dcos(angle);
            qstep = (((double )2 * radius) * (double )2) * tmp___0;
            }
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if (angle > (double )60) {
          if (angle <= (double )90) {
            qstep = (double )2 * radius;
          } else {
            {
            interror((char *)"fixsgrel - 3");
            }
          }
        } else {
          {
          interror((char *)"fixsgrel - 3");
          }
        }
        }
        grid->PSTEP = pstep;
        grid->QSTEP = qstep;
        grid->ANGLE = angle;
        goto switch_break___0;
        case_0___0: /* CIL Label */ 
        {
        pdim = elem->PDIM;
        qdim = elem->QDIM;
        angle = datan(((double )2 * qdim) / pdim);
        pstep = pdim;
        tmp___1 = dsin(angle);
        qstep = qdim / tmp___1;
        grid->PSTEP = pstep;
        grid->QSTEP = qstep;
        grid->ANGLE = angle;
        }
        switch_break___0: /* CIL Label */ ;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (grid->PSTEP != (double )0) {
    if (grid->QSTEP != (double )0) {
      if (grid->ANGLE == (double )0) {
        if (elem->GEOMETRY == 1) {
          pstep = grid->PSTEP;
          qstep = grid->QSTEP;
          radius = elem->PDIM / (double )2;
          if (pstep < (double )2 * radius) {
            {
            printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
            pstep = (double )2 * radius;
            qstep = (double )2 * radius;
            }
          } else { //Added block
          if (qstep < (double )2 * radius) {
            {
            printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
            pstep = (double )2 * radius;
            qstep = (double )2 * radius;
            }
          }
          }
          {
          angle = dacos(((qstep * qstep + pstep * pstep) - ((double )4 * radius) * radius) / (((double )2 * pstep) * qstep));
          grid->ANGLE = angle;
          }
        } else { //Added block
        if (elem->GEOMETRY == 0) {
          pstep = grid->PSTEP;
          qstep = grid->QSTEP;
          pdim = elem->PDIM;
          qdim = elem->QDIM;
          if (qstep < qdim) {
            {
            printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
            qstep = qdim;
            }
          } else { //Added block
          if (pstep < pdim) {
            {
            printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
            qstep = qdim;
            }
          }
          }
          {
          angle = dasin(qdim / qstep);
          grid->ANGLE = angle;
          }
        }
        }
      }
    }
  }
  }
  }
  {
  if (elem->GEOMETRY == 1) {
    goto case_1___1;
  }
  if (elem->GEOMETRY == 0) {
    goto case_0___1;
  }
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  pstep = grid->PSTEP;
  qstep = grid->QSTEP;
  radius = elem->PDIM / (double )2;
  if (pstep < (double )2 * radius) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
    }
  } else { //Added block
  if (qstep < (double )2 * radius) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
    }
  }
  }
  if (grid->ANGLE <= (double )45) {
    {
    printf((char const   * __restrict  )"\n%s%f", MOSErrors[4], grid->ANGLE);
    exit(3);
    }
  } else { //Added block
  if (grid->ANGLE > (double )90) {
    {
    printf((char const   * __restrict  )"\n%s%f", MOSErrors[4], grid->ANGLE);
    exit(3);
    }
  }
  }
  goto switch_break___1;
  case_0___1: /* CIL Label */ 
  pstep = grid->PSTEP;
  qstep = grid->QSTEP;
  pdim = elem->PDIM;
  qdim = elem->QDIM;
  if (qstep < qdim) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
    }
  } else { //Added block
  if (pstep < pdim) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[2], group_ptr->NAME);
    }
  }
  }
  {
  tmp___2 = datan(elem->QDIM / elem->PDIM);
  }
  if (grid->ANGLE <= tmp___2) {
    {
    printf((char const   * __restrict  )"\n%s%f", MOSErrors[4], grid->ANGLE);
    exit(3);
    }
  } else { //Added block
  if (grid->ANGLE > (double )90) {
    {
    printf((char const   * __restrict  )"\n%s%f", MOSErrors[4], grid->ANGLE);
    exit(3);
    }
  }
  }
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  {
  printf((char const   * __restrict  )"\n** Generating GROUP: %s.", group_ptr->NAME);
  printf((char const   * __restrict  )"\n** PSTEP,QSTEP set to:%f,%f", grid->PSTEP,
         grid->QSTEP);
  printf((char const   * __restrict  )"\n** Grid ANGLE set to:%f ", grid->ANGLE);
  printf((char const   * __restrict  )"\n** Group ROT_ANGLE set to: %f \n", grid->ROT_ANGLE);
  }
  return (0);
}
}
int fixsgrid(struct Grid *grid ) 
{ 
  double angle ;
  double *angle_ptr ;
  int angle_unit ;
  double pstep ;
  double *pstep_ptr ;
  double qstep ;
  double *qstep_ptr ;
  int pqstep_unit ;
  double px ;
  double *px_ptr ;
  double py ;
  double *py_ptr ;
  double qx ;
  double *qx_ptr ;
  double qy ;
  double *qy_ptr ;
  int pqxy_unit ;
  double rot_angle ;

  {
  angle_ptr = & angle;
  pstep_ptr = & pstep;
  qstep_ptr = & qstep;
  px_ptr = & px;
  py_ptr = & py;
  qx_ptr = & qx;
  qy_ptr = & qy;
  angle = grid->ANGLE;
  angle_unit = grid->ANGLE_UNIT;
  pstep = grid->PSTEP;
  qstep = grid->QSTEP;
  pqstep_unit = grid->PQSTEP_UNIT;
  px = grid->PX;
  py = grid->PY;
  qx = grid->QX;
  qy = grid->QY;
  pqxy_unit = grid->PQXY_UNIT;
  rot_angle = grid->ROT_ANGLE;
  {
  if (grid->TYPE == 4) {
    goto case_4;
  }
  if (grid->TYPE == 0) {
    goto case_0;
  }
  if (grid->TYPE == 1) {
    goto case_1;
  }
  if (grid->TYPE == 2) {
    goto case_2;
  }
  if (grid->TYPE == 3) {
    goto case_3;
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  interror((char *)"fixsgrid - 1");
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  if (pstep != (double )0) {
    {
    mmconv(pstep_ptr, pqstep_unit);
    qstep = pstep;
    }
  } else {
    qstep = (double )0;
  }
  angle = (double )90;
  goto switch_break;
  case_1: /* CIL Label */ 
  if (pstep != (double )0) {
    {
    mmconv(pstep_ptr, pqstep_unit);
    mmconv(qstep_ptr, pqstep_unit);
    }
  } else {
    qstep = (double )0;
  }
  angle = (double )90;
  goto switch_break;
  case_2: /* CIL Label */ 
  if (pstep != (double )0) {
    {
    mmconv(pstep_ptr, pqstep_unit);
    qstep = pstep;
    }
  } else {
    qstep = (double )0;
  }
  angle = (double )60;
  goto switch_break;
  case_3: /* CIL Label */ 
  if (angle != (double )0) {
    {
    degconv(angle_ptr, angle_unit);
    px = (double )0;
    py = (double )0;
    qx = (double )0;
    qy = (double )0;
    }
  }
  if (pstep != (double )0) {
    {
    mmconv(pstep_ptr, pqstep_unit);
    mmconv(qstep_ptr, pqstep_unit);
    px = (double )0;
    py = (double )0;
    qx = (double )0;
    qy = (double )0;
    }
  }
  if (px != (double )0) {
    {
    mmconv(px_ptr, pqxy_unit);
    mmconv(py_ptr, pqxy_unit);
    mmconv(qx_ptr, pqxy_unit);
    mmconv(qy_ptr, pqxy_unit);
    pstep = (double )0;
    qstep = (double )0;
    angle = (double )0;
    }
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  angle_unit = 0;
  pqstep_unit = 0;
  pqxy_unit = 0;
  rot_angle = (double )0;
  grid->ANGLE = angle;
  grid->ANGLE_UNIT = angle_unit;
  grid->PSTEP = pstep;
  grid->QSTEP = qstep;
  grid->PQSTEP_UNIT = pqstep_unit;
  grid->PX = px;
  grid->PY = py;
  grid->QX = qx;
  grid->QY = qy;
  grid->PQXY_UNIT = pqxy_unit;
  grid->ROT_ANGLE = rot_angle;
  return (0);
}
}
void floatsup(void) 
{ 
  double dummy ;

  {
  {
  dummy = 1.0 + 0.0;
  printf((char const   * __restrict  )"*******************************************************************************\n");
  printf((char const   * __restrict  )"                         ARRAY PREPROCESSOR ver. %3.1f\n",
         dummy);
  printf((char const   * __restrict  )"*******************************************************************************\n");
  }
  return;
}
}
int gainspec(struct charac *p1 , struct charac **pp2 , double *gain_ptr , int *gain_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[32], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = gainval(*curr_ptr, curr_ptr, gain_ptr, gain_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 11, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int gainunit(struct charac *p1 , struct charac **pp2 , int *gain_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  *gain_unit_ptr = 2;
  tmp___0 = GetKeyword(Keywords[64], curr_ptr);
  }
  if (tmp___0 == 0) {
    *gain_unit_ptr = 2;
  } else {
    {
    tmp = GetKeyword(Keywords[15], curr_ptr);
    }
    if (tmp == 0) {
      *gain_unit_ptr = 0;
    } else {
      return (33);
    }
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int gainval(struct charac *p1 , struct charac **pp2 , double *gain_ptr , int *gain_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetReal(gain_ptr, curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = gainunit(*curr_ptr, curr_ptr, gain_unit_ptr);
  }
  if (error != 0) {
    *gain_unit_ptr = 2;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int gaussel(struct charac *p1 , struct charac **pp2 , double *anglee_ptr , double *angleh_ptr ,
            int *angle_unit_ptr , double *tapere_ptr , double *taperh_ptr , int *taper_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[35], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[59], curr_ptr);
  error = 0;
  error = GetReal(anglee_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 19, (char *)" ");
    printf((char const   * __restrict  )"\n%s", ErrorMessages[29]);
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[60], curr_ptr);
  error = 0;
  error = GetReal(angleh_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 19, (char *)" ");
    printf((char const   * __restrict  )"\n%s", ErrorMessages[29]);
    }
    return (17);
  }
  {
  error = angunit(*curr_ptr, curr_ptr, angle_unit_ptr);
  }
  if (error != 0) {
    *angle_unit_ptr = 0;
  }
  {
  error = GetKeyword(Keywords[61], curr_ptr);
  error = 0;
  error = GetReal(tapere_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 27, (char *)" ");
    printf((char const   * __restrict  )"\n%s", ErrorMessages[29]);
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[62], curr_ptr);
  error = 0;
  error = GetReal(taperh_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 27, (char *)" ");
    printf((char const   * __restrict  )"\n%s", ErrorMessages[29]);
    }
    return (17);
  }
  {
  error = ampunit(curr_ptr, taper_unit_ptr);
  }
  if (error != 0) {
    *taper_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int geomspec(struct charac *p1 , struct charac **pp2 , int *geometry_ptr , double *radius_ptr ,
             int *radius_unit_ptr , double *pdim_ptr , double *qdim_ptr , int *pqdim_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[29], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 1, Keywords[29]);
    }
    return (1);
  }
  {
  *geometry_ptr = 0;
  error = recspec(*curr_ptr, curr_ptr, pdim_ptr, qdim_ptr, pqdim_unit_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[25]);
    }
    return (17);
  }
  {
  *geometry_ptr = 1;
  error = circspec(*curr_ptr, curr_ptr, radius_ptr, radius_unit_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[28]);
    }
    return (17);
  }
  return (17);
}
}
int Get1Real(struct charac *p1 , struct charac **pp2 , double *ureal_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = GetReal(ureal_ptr, curr_ptr);
  }
  if (error != 0) {
    return (11);
  }
  if (*ureal_ptr < (double )0) {
    return (12);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int GetInt(struct charac *p1 , struct charac **pp2 , int *intero ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int i ;
  char num[6] ;
  char ch ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  curr_ptr = & curr;
  i = 0;
  *curr_ptr = p1;
  ch = TapeGet(curr_ptr);
  tmp = __ctype_b_loc();
  }
  if (((int const   )*(*tmp + (int )ch) & 2048) == 0) {
    if ((int )ch != 43) {
      if ((int )ch != 45) {
        return (42);
      }
    }
  }
  {
  num[i] = ch;
  i ++;
  ch = TapeGet(curr_ptr);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + (int )ch) & 2048) {
      if (! ((unsigned long )*curr_ptr != (unsigned long )((void *)0))) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (i < 5) {
      num[i] = ch;
    }
    {
    i ++;
    ch = TapeGet(curr_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (i >= 5) {
    {
    num[5] = (char )'\000';
    parserro(p1, 43, num);
    }
    return (43);
  } else {
    num[i] = (char )'\000';
  }
  {
  *intero = atoi((char const   *)(num));
  *pp2 = *curr_ptr;
  }
  return (0);
}
}
int GetKeyword(char *kw , struct charac **tp ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  char word[21] ;
  char ch ;
  int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
  i = 0;
  curr_ptr = & curr;
  *curr_ptr = *tp;
  ch = TapeGet(curr_ptr);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )ch) & 8) {
      goto _L;
    } else { //Added block
    if ((int )ch == 95) {
      _L: 
      if (i < 20) {
        if (! ((unsigned long )*curr_ptr != (unsigned long )((void *)0))) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    }
    {
    word[i] = ch;
    i ++;
    ch = TapeGet(curr_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  word[i] = (char )'\000';
  tmp___0 = strcmp((char const   *)kw, (char const   *)(word));
  }
  if (tmp___0 == 0) {
    *tp = *curr_ptr;
    return (0);
  } else {
    return (1);
  }
}
}
int GetNatur(struct charac *p1 , struct charac **pp2 , int *natur_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  int val ;
  int *val_ptr ;

  {
  {
  curr_ptr = & curr;
  val_ptr = & val;
  *curr_ptr = p1;
  error = GetInt(*curr_ptr, curr_ptr, val_ptr);
  }
  if (error != 0) {
    return (44);
  }
  if (*val_ptr < 0) {
    return (12);
  }
  if (*val_ptr == 0) {
    return (45);
  }
  *natur_ptr = *val_ptr;
  *pp2 = *curr_ptr;
  return (0);
}
}
int GetReal(double *reale , struct charac **tp ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int i ;
  char num[101] ;
  char ch ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  curr_ptr = & curr;
  i = 0;
  *curr_ptr = *tp;
  ch = TapeGet(curr_ptr);
  tmp = __ctype_b_loc();
  }
  if (((int const   )*(*tmp + (int )ch) & 2048) == 0) {
    if ((int )ch != 43) {
      if ((int )ch != 45) {
        if ((int )ch != 46) {
          return (13);
        }
      }
    }
  }
  {
  num[i] = ch;
  i ++;
  ch = TapeGet(curr_ptr);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + (int )ch) & 2048) {
      goto _L;
    } else { //Added block
    if ((int )ch == 46) {
      goto _L;
    } else { //Added block
    if ((int )ch == 101) {
      goto _L;
    } else { //Added block
    if ((int )ch == 69) {
      goto _L;
    } else { //Added block
    if ((int )ch == 45) {
      _L: 
      if (! ((unsigned long )*curr_ptr != (unsigned long )((void *)0))) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    }
    }
    }
    }
    if (i < 100) {
      num[i] = ch;
    }
    {
    i ++;
    ch = TapeGet(curr_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (i >= 100) {
    num[100] = (char )'\000';
  } else {
    num[i] = (char )'\000';
  }
  {
  *reale = atof((char const   *)(num));
  *tp = *curr_ptr;
  }
  return (0);
}
}
int GetUName(char *word , struct charac **tp ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  char ch ;
  int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  i = 0;
  curr_ptr = & curr;
  *curr_ptr = *tp;
  ch = TapeGet(curr_ptr);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = isletter(ch);
    }
    if (tmp) {
      goto _L;
    } else {
      {
      tmp___0 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___0 + (int )ch) & 2048) {
        _L: 
        if (! ((unsigned long )*curr_ptr != (unsigned long )((void *)0))) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
    if (i < 100) {
      *(word + i) = ch;
    }
    {
    i ++;
    ch = TapeGet(curr_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (i >= 100) {
    *(word + 100) = (char )'\000';
  } else {
    *(word + i) = (char )'\000';
  }
  if (i > 100) {
    {
    parserro(*tp, 7, word);
    }
  }
  {
  tmp___1 = strlen((char const   *)word);
  }
  if (tmp___1 == 0UL) {
    return (2);
  }
  {
  tmp___2 = isletter(*(word + 0));
  }
  if (tmp___2 == 0) {
    return (5);
  }
  {
  tmp___3 = InKWords(word);
  }
  if (tmp___3 == 1) {
    return (6);
  }
  *tp = *curr_ptr;
  return (0);
}
}
int GetUReal(struct charac *p1 , struct charac **pp2 , double *ureal_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  double val ;
  double *val_ptr ;

  {
  {
  curr_ptr = & curr;
  val_ptr = & val;
  *curr_ptr = p1;
  error = GetReal(val_ptr, curr_ptr);
  }
  if (error != 0) {
    return (11);
  }
  if (*val_ptr < (double )0) {
    return (12);
  }
  *ureal_ptr = *val_ptr;
  *pp2 = *curr_ptr;
  return (0);
}
}
void glvainit(void) 
{ 


  {
  {
  floatsup();
  kwdsinit();
  emsginit();
  unaminit();
  moseinit();
  }
  return;
}
}
void gnodevis(int p , int q , double angle , double phase , struct Geomnode *gnode_list_start_ptr ) 
{ 
  int error ;
  struct Geomnode *gnode_ptr ;

  {
  {
  error = 0;
  error = gnodfind(gnode_list_start_ptr, & gnode_ptr, p, q);
  }
  if (error != 0) {
    {
    interror((char *)"nodevis() - node not found -");
    exit(1);
    }
  }
  (gnode_ptr->GEOMPORT_PTR)->PPA = phase;
  gnode_ptr->PHEA += angle;
  return;
}
}
int gnodfind(struct Geomnode *gnode_list_start_ptr , struct Geomnode **gnode_ptr ,
             int p , int q ) 
{ 


  {
  *gnode_ptr = gnode_list_start_ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((*gnode_ptr)->LOC_P == p) {
      if ((*gnode_ptr)->LOC_Q == q) {
        goto while_break;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (! ((unsigned long )(*gnode_ptr)->NEXT != (unsigned long )((void *)0))) {
      goto while_break;
    }
    }
    *gnode_ptr = (*gnode_ptr)->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  if ((*gnode_ptr)->LOC_P == p) {
    if ((*gnode_ptr)->LOC_Q == q) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
int grampexc(struct charac *p1 , struct charac **pp2 , struct GrAmpExc **grampexc_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  double unif_val ;
  double *unif_val_ptr ;
  double centre ;
  double *centre_ptr ;
  double p1_et ;
  double *p1_et_ptr ;
  double p2_et ;
  double *p2_et_ptr ;
  double q1_et ;
  double *q1_et_ptr ;
  double q2_et ;
  double *q2_et_ptr ;
  int amp_unit ;
  int *amp_unit_ptr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  curr_ptr = & curr;
  unif_val_ptr = & unif_val;
  centre_ptr = & centre;
  p1_et_ptr = & p1_et;
  p2_et_ptr = & p2_et;
  q1_et_ptr = & q1_et;
  q2_et_ptr = & q2_et;
  amp_unit_ptr = & amp_unit;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[42], curr_ptr);
  }
  if (error != 0) {
    *grampexc_ptr = (struct GrAmpExc *)((void *)0);
    return (1);
  }
  {
  error = unifamp(*curr_ptr, curr_ptr, unif_val_ptr, amp_unit_ptr);
  }
  if (error == 0) {
    {
    tmp = malloc(sizeof(struct GrAmpExc ));
    *grampexc_ptr = (struct GrAmpExc *)tmp;
    }
    if ((unsigned long )*grampexc_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"grampexc()");
      }
    }
    (*grampexc_ptr)->TYPE = 0;
    (*grampexc_ptr)->UNIF_VAL = unif_val;
    (*grampexc_ptr)->AMP_UNIT = amp_unit;
    (*grampexc_ptr)->PQEXP_PTR = (struct PQExp *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = secoramp(*curr_ptr, curr_ptr, centre_ptr, p1_et_ptr, p2_et_ptr, q1_et_ptr,
                   q2_et_ptr, amp_unit_ptr);
  }
  if (error == 17) {
    {
    *grampexc_ptr = (struct GrAmpExc *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[69]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___0 = malloc(sizeof(struct GrAmpExc ));
    *grampexc_ptr = (struct GrAmpExc *)tmp___0;
    }
    if ((unsigned long )*grampexc_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"grampexc()");
      }
    }
    (*grampexc_ptr)->TYPE = 1;
    (*grampexc_ptr)->CENTRE = centre;
    (*grampexc_ptr)->P1_ET = p1_et;
    (*grampexc_ptr)->P2_ET = p2_et;
    (*grampexc_ptr)->Q1_ET = q1_et;
    (*grampexc_ptr)->Q2_ET = q2_et;
    (*grampexc_ptr)->AMP_UNIT = amp_unit;
    (*grampexc_ptr)->PQEXP_PTR = (struct PQExp *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  *grampexc_ptr = (struct GrAmpExc *)((void *)0);
  return (17);
}
}
int greldef(struct charac *p1 , struct charac **pp2 , struct Grid **grid_ptr , struct Elem **elem_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  *grid_ptr = (struct Grid *)((void *)0);
  *elem_ptr = (struct Elem *)((void *)0);
  error = 0;
  error = griddef1(*curr_ptr, curr_ptr, grid_ptr);
  }
  if (error == 1) {
    return (1);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[16]);
    }
    return (17);
  }
  {
  error = elemdef(*curr_ptr, curr_ptr, elem_ptr);
  }
  if (error == 1) {
    {
    parserro(*curr_ptr, 67, (char *)" ");
    }
    return (1);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[24]);
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int grexcdef(struct charac *p1 , struct charac **pp2 , struct GrAmpExc **grampexc_ptr ,
             struct GrPhaExc **grphaexc_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  *grampexc_ptr = (struct GrAmpExc *)((void *)0);
  *grphaexc_ptr = (struct GrPhaExc *)((void *)0);
  error = 0;
  error = GetKeyword(Keywords[101], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = grampexc(*curr_ptr, curr_ptr, grampexc_ptr);
  }
  if (error != 0) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[79]);
    }
    return (17);
  }
  {
  error = grphaexc(*curr_ptr, curr_ptr, grphaexc_ptr);
  }
  if (error != 0) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[80]);
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int grgeodef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  struct AddRem *ultimo_ptr ;
  struct AddRem *a_ptr ;
  struct AddRem **app_ptr ;

  {
  {
  curr_ptr = & curr;
  ultimo_ptr = (struct AddRem *)((void *)0);
  a_ptr = (struct AddRem *)((void *)0);
  app_ptr = & a_ptr;
  *curr_ptr = p1;
  error = 0;
  *addrem_ptr = (struct AddRem *)((void *)0);
  error = adddef(*curr_ptr, curr_ptr, addrem_ptr);
  }
  if (error == 1) {
    {
    parserro(*curr_ptr, 94, (char *)" ");
    }
    return (17);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[62]);
    }
    return (17);
  }
  *app_ptr = *addrem_ptr;
  ultimo_ptr = *addrem_ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    error = adremdef(*curr_ptr, curr_ptr, app_ptr);
    }
    if (error == 1) {
      ultimo_ptr->NEXT = (struct AddRem *)((void *)0);
      *pp2 = *curr_ptr;
      return (0);
    }
    if (error == 17) {
      {
      *addrem_ptr = (struct AddRem *)((void *)0);
      printf((char const   * __restrict  )"\n%s", ErrorMessages[64]);
      }
      return (17);
    }
    ultimo_ptr->NEXT = *app_ptr;
    ultimo_ptr = *app_ptr;
    ultimo_ptr->NEXT = (struct AddRem *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
}
}
int griddef1(struct charac *p1 , struct charac **pp2 , struct Grid **grid_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int grid_type ;
  int orient ;
  int *orient_ptr ;
  double pstep ;
  double *pstep_ptr ;
  double qstep ;
  double *qstep_ptr ;
  int pqstep_unit ;
  int *pqstep_unit_ptr ;
  double angle ;
  double *angle_ptr ;
  int angle_unit ;
  int *angle_unit_ptr ;
  double px ;
  double *px_ptr ;
  double py ;
  double *py_ptr ;
  double qx ;
  double *qx_ptr ;
  double qy ;
  double *qy_ptr ;
  int pqxy_unit ;
  int *pqxy_unit_ptr ;
  int error ;
  void *tmp ;

  {
  {
  curr_ptr = & curr;
  orient_ptr = & orient;
  pstep_ptr = & pstep;
  qstep_ptr = & qstep;
  pqstep_unit_ptr = & pqstep_unit;
  angle_ptr = & angle;
  angle_unit_ptr = & angle_unit;
  px_ptr = & px;
  py_ptr = & py;
  qx_ptr = & qx;
  qy_ptr = & qy;
  pqxy_unit_ptr = & pqxy_unit;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[14], curr_ptr);
  }
  if (error != 0) {
    *grid_ptr = (struct Grid *)((void *)0);
    return (1);
  }
  {
  grid_type = 0;
  error = squgrdef(*curr_ptr, curr_ptr, pstep_ptr, pqstep_unit_ptr);
  }
  if (error == 17) {
    {
    *grid_ptr = (struct Grid *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[16]);
    }
    return (17);
  }
  if (error != 0) {
    {
    grid_type = 1;
    error = recgrdef(*curr_ptr, curr_ptr, pstep_ptr, qstep_ptr, pqstep_unit_ptr);
    }
    if (error == 17) {
      {
      printf((char const   * __restrict  )"\n%s", ErrorMessages[16]);
      *grid_ptr = (struct Grid *)((void *)0);
      }
      return (17);
    }
  }
  if (error != 0) {
    {
    grid_type = 2;
    error = hexgrdef(*curr_ptr, curr_ptr, pstep_ptr, pqstep_unit_ptr);
    }
    if (error == 17) {
      {
      *grid_ptr = (struct Grid *)((void *)0);
      printf((char const   * __restrict  )"\n%s", ErrorMessages[16]);
      }
      return (17);
    }
  }
  if (error != 0) {
    {
    grid_type = 3;
    error = trigrdef(*curr_ptr, curr_ptr, angle_ptr, angle_unit_ptr, pstep_ptr, qstep_ptr,
                     pqstep_unit_ptr, px_ptr, py_ptr, qx_ptr, qy_ptr, pqxy_unit_ptr);
    }
    if (error == 17) {
      {
      *grid_ptr = (struct Grid *)((void *)0);
      printf((char const   * __restrict  )"\n%s", ErrorMessages[16]);
      }
      return (17);
    }
  }
  if (error != 0) {
    {
    *grid_ptr = (struct Grid *)((void *)0);
    parserro(*curr_ptr, 16, (char *)" ");
    }
    return (17);
  }
  {
  tmp = malloc(sizeof(struct Grid ));
  *grid_ptr = (struct Grid *)tmp;
  }
  if ((unsigned long )*grid_ptr == (unsigned long )((void *)0)) {
    {
    printf((char const   * __restrict  )"%s", ErrorMessages[55]);
    interror((char *)"griddef1()");
    }
  }
  (*grid_ptr)->TYPE = grid_type;
  (*grid_ptr)->ORIENT = orient;
  (*grid_ptr)->PSTEP = pstep;
  (*grid_ptr)->QSTEP = qstep;
  (*grid_ptr)->PQSTEP_UNIT = pqstep_unit;
  (*grid_ptr)->ANGLE = angle;
  (*grid_ptr)->ANGLE_UNIT = angle_unit;
  (*grid_ptr)->PX = px;
  (*grid_ptr)->PY = py;
  (*grid_ptr)->QX = qx;
  (*grid_ptr)->QY = qy;
  (*grid_ptr)->PQXY_UNIT = pqxy_unit;
  *pp2 = *curr_ptr;
  return (0);
}
}
int groupdef(struct charac *p1 , struct charac **pp2 , struct Group **group_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  char groupname[101] ;
  struct Grid *grid ;
  struct Grid **grid_ptr ;
  struct Elem *elem ;
  struct Elem **elem_ptr ;
  struct AddRem *addrem ;
  struct AddRem **addrem_ptr ;
  struct GrAmpExc *grampexc___0 ;
  struct GrAmpExc **grampexc_ptr ;
  struct GrPhaExc *grphaexc___0 ;
  struct GrPhaExc **grphaexc_ptr ;
  struct Err *err ;
  struct Err **err_ptr ;
  struct Fail *fail ;
  struct Fail **fail_ptr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
  curr_ptr = & curr;
  grid = (struct Grid *)((void *)0);
  grid_ptr = & grid;
  elem = (struct Elem *)((void *)0);
  elem_ptr = & elem;
  addrem = (struct AddRem *)((void *)0);
  addrem_ptr = & addrem;
  grampexc___0 = (struct GrAmpExc *)((void *)0);
  grampexc_ptr = & grampexc___0;
  grphaexc___0 = (struct GrPhaExc *)((void *)0);
  grphaexc_ptr = & grphaexc___0;
  err = (struct Err *)((void *)0);
  err_ptr = & err;
  fail = (struct Fail *)((void *)0);
  fail_ptr = & fail;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[47], curr_ptr);
  }
  if (error != 0) {
    *group_ptr = (struct Group *)((void *)0);
    return (1);
  }
  {
  tmp = GetUName(groupname, curr_ptr);
  }
  if (tmp != 0) {
    {
    parserro(*curr_ptr, 81, (char *)" ");
    }
    return (17);
  }
  {
  tmp___0 = InUNames(groupname);
  }
  if (tmp___0) {
    {
    parserro(*curr_ptr, 3, groupname);
    }
    return (17);
  }
  {
  InserUN(groupname);
  error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
  }
  if (error == 17) {
    return (17);
  }
  if (error == 0) {
    {
    (*grid_ptr)->LEVEL = 1;
    (*elem_ptr)->LEVEL = 1;
    strcpy((char * __restrict  )((*elem_ptr)->NAME), (char const   * __restrict  )"ELEMENT");
    }
  }
  {
  error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 82, groupname);
    }
    return (17);
  }
  {
  error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 82, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[50], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 1, Keywords[50]);
    }
    return (17);
  }
  {
  tmp___1 = malloc(sizeof(struct Group ));
  *group_ptr = (struct Group *)tmp___1;
  }
  if ((unsigned long )*group_ptr == (unsigned long )((void *)0)) {
    {
    parserro(*curr_ptr, 55, (char *)" ");
    interror((char *)"groupdef()");
    }
  }
  {
  strcpy((char * __restrict  )((*group_ptr)->NAME), (char const   * __restrict  )(groupname));
  (*group_ptr)->NUM_OF_NODES = 0;
  (*group_ptr)->SHAPE = 0;
  (*group_ptr)->PSIZE = (double )0;
  (*group_ptr)->QSIZE = (double )0;
  (*group_ptr)->GRID_PTR = *grid_ptr;
  (*group_ptr)->ELEM_PTR = *elem_ptr;
  (*group_ptr)->GRAMPEXC_PTR = *grampexc_ptr;
  (*group_ptr)->GRPHAEXC_PTR = *grphaexc_ptr;
  (*group_ptr)->ADDREM_PTR = *addrem_ptr;
  (*group_ptr)->ERR_PTR = *err_ptr;
  (*group_ptr)->FAIL_PTR = *fail_ptr;
  (*group_ptr)->GEOMNODE_PTR = (struct Geomnode *)((void *)0);
  (*group_ptr)->BUILT = 0;
  (*group_ptr)->SUPER_GROUP_PTR[0] = (struct Group *)((void *)0);
  *pp2 = *curr_ptr;
  }
  return (0);
}
}
int grphaexc(struct charac *p1 , struct charac **pp2 , struct GrPhaExc **grphaexc_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  double unif_val ;
  double *unif_val_ptr ;
  double centre ;
  double *centre_ptr ;
  double p1_ep ;
  double *p1_ep_ptr ;
  double p2_ep ;
  double *p2_ep_ptr ;
  double q1_ep ;
  double *q1_ep_ptr ;
  double q2_ep ;
  double *q2_ep_ptr ;
  int angle_unit ;
  int *angle_unit_ptr ;
  int direction ;
  int *direction_ptr ;
  int omit_angle ;
  int *omit_angle_ptr ;
  double angle_start ;
  double *angle_start_ptr ;
  double angle_step ;
  double *angle_step_ptr ;
  int omit_phase ;
  int *omit_phase_ptr ;
  double phase_start ;
  double *phase_start_ptr ;
  double phase_step ;
  double *phase_step_ptr ;
  double u ;
  double *u_ptr ;
  double v ;
  double *v_ptr ;
  double theta ;
  double *theta_ptr ;
  double phi ;
  double *phi_ptr ;
  int phase_unit ;
  int *phase_unit_ptr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
  curr_ptr = & curr;
  unif_val_ptr = & unif_val;
  centre_ptr = & centre;
  p1_ep_ptr = & p1_ep;
  p2_ep_ptr = & p2_ep;
  q1_ep_ptr = & q1_ep;
  q2_ep_ptr = & q2_ep;
  angle_unit_ptr = & angle_unit;
  direction_ptr = & direction;
  omit_angle_ptr = & omit_angle;
  angle_start_ptr = & angle_start;
  angle_step_ptr = & angle_step;
  omit_phase_ptr = & omit_phase;
  phase_start_ptr = & phase_start;
  phase_step_ptr = & phase_step;
  u_ptr = & u;
  v_ptr = & v;
  theta_ptr = & theta;
  phi_ptr = & phi;
  phase_unit_ptr = & phase_unit;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[43], curr_ptr);
  }
  if (error != 0) {
    *grphaexc_ptr = (struct GrPhaExc *)((void *)0);
    return (1);
  }
  {
  error = unifpha(*curr_ptr, curr_ptr, unif_val_ptr, phase_unit_ptr);
  }
  if (error == 0) {
    {
    tmp = malloc(sizeof(struct GrPhaExc ));
    *grphaexc_ptr = (struct GrPhaExc *)tmp;
    }
    if ((unsigned long )*grphaexc_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"grphaexc()");
      }
    }
    (*grphaexc_ptr)->TYPE = 0;
    (*grphaexc_ptr)->UNIF_VAL = unif_val;
    (*grphaexc_ptr)->PHASE_UNIT = phase_unit;
    (*grphaexc_ptr)->PQEXP_PTR = (struct PQExp *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = secorpha(*curr_ptr, curr_ptr, centre_ptr, p1_ep_ptr, p2_ep_ptr, q1_ep_ptr,
                   q2_ep_ptr, phase_unit_ptr);
  }
  if (error == 17) {
    {
    *grphaexc_ptr = (struct GrPhaExc *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[76]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___0 = malloc(sizeof(struct GrPhaExc ));
    *grphaexc_ptr = (struct GrPhaExc *)tmp___0;
    }
    if ((unsigned long )*grphaexc_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"grphaexc()");
      }
    }
    (*grphaexc_ptr)->TYPE = 1;
    (*grphaexc_ptr)->CENTRE = centre;
    (*grphaexc_ptr)->P1_EP = p1_ep;
    (*grphaexc_ptr)->P2_EP = p2_ep;
    (*grphaexc_ptr)->Q1_EP = q1_ep;
    (*grphaexc_ptr)->Q2_EP = q2_ep;
    (*grphaexc_ptr)->PHASE_UNIT = phase_unit;
    (*grphaexc_ptr)->PQEXP_PTR = (struct PQExp *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = serotpha(*curr_ptr, curr_ptr, direction_ptr, omit_angle_ptr, angle_start_ptr,
                   angle_step_ptr, omit_phase_ptr, phase_start_ptr, phase_step_ptr,
                   angle_unit_ptr, phase_unit_ptr);
  }
  if (error == 17) {
    {
    *grphaexc_ptr = (struct GrPhaExc *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[77]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___1 = malloc(sizeof(struct GrPhaExc ));
    *grphaexc_ptr = (struct GrPhaExc *)tmp___1;
    }
    if ((unsigned long )*grphaexc_ptr == (unsigned long )((void *)0)) {
      {
      printf((char const   * __restrict  )"%s", ErrorMessages[55]);
      interror((char *)"grphaexc()");
      }
    }
    (*grphaexc_ptr)->TYPE = 3;
    (*grphaexc_ptr)->DIRECTION = direction;
    (*grphaexc_ptr)->OMIT_ANGLE = omit_angle;
    (*grphaexc_ptr)->ANGLE_START = angle_start;
    (*grphaexc_ptr)->ANGLE_STEP = angle_step;
    (*grphaexc_ptr)->OMIT_PHASE = omit_phase;
    (*grphaexc_ptr)->PHASE_START = phase_start;
    (*grphaexc_ptr)->PHASE_STEP = phase_step;
    (*grphaexc_ptr)->ANGLE_UNIT = angle_unit;
    (*grphaexc_ptr)->PHASE_UNIT = phase_unit;
    (*grphaexc_ptr)->PQEXP_PTR = (struct PQExp *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = beampha(*curr_ptr, curr_ptr, u_ptr, v_ptr, theta_ptr, phi_ptr, angle_unit_ptr);
  }
  if (error == 17) {
    {
    *grphaexc_ptr = (struct GrPhaExc *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[78]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___2 = malloc(sizeof(struct GrPhaExc ));
    *grphaexc_ptr = (struct GrPhaExc *)tmp___2;
    }
    if ((unsigned long )*grphaexc_ptr == (unsigned long )((void *)0)) {
      {
      printf((char const   * __restrict  )"%s", ErrorMessages[55]);
      interror((char *)"grphaexc()");
      }
    }
    (*grphaexc_ptr)->TYPE = 4;
    (*grphaexc_ptr)->U = u;
    (*grphaexc_ptr)->V = v;
    (*grphaexc_ptr)->THETA = theta;
    (*grphaexc_ptr)->PHI = phi;
    (*grphaexc_ptr)->ANGLE_UNIT = angle_unit;
    (*grphaexc_ptr)->PQEXP_PTR = (struct PQExp *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  *grphaexc_ptr = (struct GrPhaExc *)((void *)0);
  return (17);
}
}
int grwrite(struct Group *group_ptr , char *filename ) 
{ 
  int NEL ;
  int NPORTS ;
  int IDUM ;
  struct Geomnode *geomnode_ptr ;
  struct Geomport *geomport_ptr ;
  char datfilename[101] ;

  {
  IDUM = 0;
  if ((unsigned long )group_ptr == (unsigned long )((void *)0)) {
    {
    interror((char *)" grwrite() -1- ");
    exit(1);
    }
  }
  {
  geomnode_ptr = group_ptr->GEOMNODE_PTR;
  strcpy((char * __restrict  )(datfilename), (char const   * __restrict  )filename);
  strcat((char * __restrict  )(datfilename), (char const   * __restrict  )".dat");
  printf((char const   * __restrict  )"\n** Writing output file: %s", datfilename);
  printf((char const   * __restrict  )"\n\nNEL \nNPORTS");
  printf((char const   * __restrict  )"\nIDUM      REXA     REYA     REZA     THEA     PHEA     PSEA ");
  printf((char const   * __restrict  )"\n          AMP      PSH      PSC      PHEPOL\n");
  NEL = group_ptr->NUM_OF_NODES;
  printf((char const   * __restrict  )"%4d", NEL);
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"%4d", NEL);
  printf((char const   * __restrict  )"\n");
  NPORTS = (group_ptr->ELEM_PTR)->NPORTS;
  printf((char const   * __restrict  )"%4d", NPORTS);
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"%4d", NPORTS);
  printf((char const   * __restrict  )"\n");
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )geomnode_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    IDUM ++;
    printf((char const   * __restrict  )"%4d ", IDUM);
    printf((char const   * __restrict  )"\t%8.2f ", geomnode_ptr->XA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->YA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->ZA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->THEA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->PHEA);
    printf((char const   * __restrict  )"%8.2f", geomnode_ptr->PSEA);
    printf((char const   * __restrict  )"\n");
    printf((char const   * __restrict  )"%4d ", IDUM);
    printf((char const   * __restrict  )"\t%8.2f ", geomnode_ptr->XA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->YA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->ZA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->THEA);
    printf((char const   * __restrict  )"%8.2f ", geomnode_ptr->PHEA);
    printf((char const   * __restrict  )"%8.2f", geomnode_ptr->PSEA);
    printf((char const   * __restrict  )"\n");
    geomport_ptr = geomnode_ptr->GEOMPORT_PTR;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )geomport_ptr != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      printf((char const   * __restrict  )"   \t%8.2f ", geomport_ptr->AMP);
      printf((char const   * __restrict  )"%8.2f ", geomport_ptr->PSH + geomport_ptr->PPA);
      printf((char const   * __restrict  )"%8.2f ", geomport_ptr->PSC);
      printf((char const   * __restrict  )"%8.2f", geomport_ptr->PHEPOL);
      printf((char const   * __restrict  )"\n");
      printf((char const   * __restrict  )"   \t%8.2f ", geomport_ptr->AMP);
      printf((char const   * __restrict  )"%8.2f ", geomport_ptr->PSH + geomport_ptr->PPA);
      printf((char const   * __restrict  )"%8.2f ", geomport_ptr->PSC);
      printf((char const   * __restrict  )"%8.2f", geomport_ptr->PHEPOL);
      printf((char const   * __restrict  )"\n");
      geomport_ptr = geomport_ptr->NEXT;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    geomnode_ptr = geomnode_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  {
  printf((char const   * __restrict  )"\n** End writing output file: %s \n", datfilename);
  }
  return (0);
}
}
int hexdef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  int pcoord ;
  int *pcoord_ptr ;
  int qcoord ;
  int *qcoord_ptr ;
  void *tmp ;

  {
  {
  curr_ptr = & curr;
  pcoord_ptr = & pcoord;
  qcoord_ptr = & qcoord;
  *curr_ptr = p1;
  error = 0;
  *node_ptr = (struct Node *)((void *)0);
  error = GetKeyword(Keywords[78], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = nodecoor(*curr_ptr, curr_ptr, pcoord_ptr, qcoord_ptr);
  }
  if (error == 1) {
    {
    parserro(*curr_ptr, 66, (char *)" ");
    }
    return (17);
  }
  if (error == 17) {
    {
    parserro(*curr_ptr, 66, (char *)" ");
    }
    return (17);
  }
  {
  tmp = malloc(sizeof(struct Node ));
  *node_ptr = (struct Node *)tmp;
  }
  if ((unsigned long )*node_ptr == (unsigned long )((void *)0)) {
    {
    parserro(*curr_ptr, 55, (char *)" ");
    interror((char *)"hexdef()");
    }
  }
  (*node_ptr)->NEXT = (struct Node *)((void *)0);
  (*node_ptr)->PCOORD = pcoord;
  (*node_ptr)->QCOORD = qcoord;
  (*node_ptr)->THEA = (double )0;
  (*node_ptr)->PHEA = (double )0;
  (*node_ptr)->PSEA = (double )0;
  (*node_ptr)->ANGLE_UNIT = 0;
  *pp2 = *curr_ptr;
  return (0);
}
}
int hexgrdef(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , int *pstep_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *pstep_ptr = (double )0;
  *pstep_unit_ptr = 0;
  error = GetKeyword(Keywords[22], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = sinstep(*curr_ptr, curr_ptr, pstep_ptr, pstep_unit_ptr);
  }
  if (error == 1) {
    *pstep_ptr = (double )0;
    *pstep_unit_ptr = 0;
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    *pstep_ptr = (double )0;
    *pstep_unit_ptr = 0;
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int InKWords(char *WORD ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen((char const   *)WORD);
  }
  if (tmp == 0UL) {
    {
    printf((char const   * __restrict  )"**INTERNAL ERROR - InKWords() - empty string passed.**");
    exit(1);
    }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= 125)) {
      goto while_break;
    }
    {
    tmp___0 = strcmp((char const   *)WORD, (char const   *)(Keywords[i]));
    }
    if (tmp___0 == 0) {
      return (1);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int InserUN(char *WORD ) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = strlen((char const   *)WORD);
  }
  if (tmp == 0UL) {
    {
    printf((char const   * __restrict  )"**INTERNAL ERROR - InserUN() - empty string passed.**");
    exit(1);
    }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= 20)) {
      goto while_break;
    }
    {
    tmp___0 = strlen((char const   *)(UserNames[i]));
    }
    if (tmp___0 == 0UL) {
      {
      strcpy((char * __restrict  )(UserNames[i]), (char const   * __restrict  )WORD);
      }
    }
    return (0);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  printf((char const   * __restrict  )"** Internal error ** - InserUN()-: too many user names");
  exit(1);
  }
  return (1);
}
}
void interror(char *subname ) 
{ 


  {
  {
  printf((char const   * __restrict  )"\n\n**ERROR INTERNAL** in function %s\n\n",
         subname);
  printf((char const   * __restrict  )"** PROGRAM STOPPED **\n\n");
  exit(1);
  }
}
}
int intmax(int a , int b ) 
{ 


  {
  if (a > b) {
    return (a);
  } else {
    return (b);
  }
}
}
int intmin(int a , int b ) 
{ 


  {
  if (a < b) {
    return (a);
  } else {
    return (b);
  }
}
}
int InUNames(char *WORD ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen((char const   *)WORD);
  }
  if (tmp == 0UL) {
    {
    printf((char const   * __restrict  )"**INTERNAL ERROR - InUNames() - empty string passed.**");
    exit(1);
    }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= 20)) {
      goto while_break;
    }
    {
    tmp___0 = strcmp((char const   *)WORD, (char const   *)(UserNames[i]));
    }
    if (tmp___0 == 0) {
      return (1);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int isletter(char ch ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + (int )ch) & 1024) {
    return (1);
  } else { //Added block
  if ((int )ch == 95) {
    return (1);
  } else { //Added block
  if ((int )ch == 45) {
    return (1);
  } else {
    return (0);
  }
  }
  }
}
}
void kwdsinit(void) 
{ 
  char i ;
  size_t tmp ;

  {
  i = (char)0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )i <= 125)) {
      goto while_break;
    }
    Keywords[i][0] = (char )'\000';
    i = (char )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
  strcpy((char * __restrict  )(Keywords[0]), (char const   * __restrict  )"PLANE");
  strcpy((char * __restrict  )(Keywords[1]), (char const   * __restrict  )"ARRAY");
  strcpy((char * __restrict  )(Keywords[2]), (char const   * __restrict  )"IS");
  strcpy((char * __restrict  )(Keywords[3]), (char const   * __restrict  )"SURFACE");
  strcpy((char * __restrict  )(Keywords[4]), (char const   * __restrict  )"CYLINDER");
  strcpy((char * __restrict  )(Keywords[5]), (char const   * __restrict  )"RADIUS");
  strcpy((char * __restrict  )(Keywords[6]), (char const   * __restrict  )"mm");
  strcpy((char * __restrict  )(Keywords[7]), (char const   * __restrict  )"cm");
  strcpy((char * __restrict  )(Keywords[8]), (char const   * __restrict  )"dm");
  strcpy((char * __restrict  )(Keywords[9]), (char const   * __restrict  )"m");
  strcpy((char * __restrict  )(Keywords[10]), (char const   * __restrict  )"wl");
  strcpy((char * __restrict  )(Keywords[11]), (char const   * __restrict  )"AXIS");
  strcpy((char * __restrict  )(Keywords[12]), (char const   * __restrict  )"X");
  strcpy((char * __restrict  )(Keywords[13]), (char const   * __restrict  )"Y");
  strcpy((char * __restrict  )(Keywords[14]), (char const   * __restrict  )"GRID");
  strcpy((char * __restrict  )(Keywords[15]), (char const   * __restrict  )"LINEAR");
  strcpy((char * __restrict  )(Keywords[16]), (char const   * __restrict  )"STEP");
  strcpy((char * __restrict  )(Keywords[17]), (char const   * __restrict  )"SQUARE");
  strcpy((char * __restrict  )(Keywords[18]), (char const   * __restrict  )"RECTANGULAR");
  strcpy((char * __restrict  )(Keywords[19]), (char const   * __restrict  )"PSTEP");
  strcpy((char * __restrict  )(Keywords[20]), (char const   * __restrict  )"QSTEP");
  strcpy((char * __restrict  )(Keywords[21]), (char const   * __restrict  )"TRIANGULAR");
  strcpy((char * __restrict  )(Keywords[22]), (char const   * __restrict  )"HEXAGONAL");
  strcpy((char * __restrict  )(Keywords[23]), (char const   * __restrict  )"ANGLE");
  strcpy((char * __restrict  )(Keywords[24]), (char const   * __restrict  )"PX");
  strcpy((char * __restrict  )(Keywords[25]), (char const   * __restrict  )"PY");
  strcpy((char * __restrict  )(Keywords[26]), (char const   * __restrict  )"QX");
  strcpy((char * __restrict  )(Keywords[27]), (char const   * __restrict  )"QY");
  strcpy((char * __restrict  )(Keywords[28]), (char const   * __restrict  )"ELEMENT");
  strcpy((char * __restrict  )(Keywords[29]), (char const   * __restrict  )"GEOMETRY");
  strcpy((char * __restrict  )(Keywords[30]), (char const   * __restrict  )"MODEL");
  strcpy((char * __restrict  )(Keywords[31]), (char const   * __restrict  )"POLARIZATION");
  strcpy((char * __restrict  )(Keywords[32]), (char const   * __restrict  )"GAIN");
  strcpy((char * __restrict  )(Keywords[33]), (char const   * __restrict  )"EXTERNAL");
  strcpy((char * __restrict  )(Keywords[34]), (char const   * __restrict  )"COSINUS");
  strcpy((char * __restrict  )(Keywords[35]), (char const   * __restrict  )"GAUSSIAN");
  strcpy((char * __restrict  )(Keywords[36]), (char const   * __restrict  )"LINEAR");
  strcpy((char * __restrict  )(Keywords[37]), (char const   * __restrict  )"ORIENTATION");
  strcpy((char * __restrict  )(Keywords[38]), (char const   * __restrict  )"CIRCULAR");
  strcpy((char * __restrict  )(Keywords[39]), (char const   * __restrict  )"PORTS");
  strcpy((char * __restrict  )(Keywords[40]), (char const   * __restrict  )"PORT");
  strcpy((char * __restrict  )(Keywords[41]), (char const   * __restrict  )"POL_ORIENT");
  strcpy((char * __restrict  )(Keywords[42]), (char const   * __restrict  )"AMPLITUDE");
  strcpy((char * __restrict  )(Keywords[43]), (char const   * __restrict  )"PHASE");
  strcpy((char * __restrict  )(Keywords[44]), (char const   * __restrict  )"SHAPING");
  strcpy((char * __restrict  )(Keywords[45]), (char const   * __restrict  )"SCANNING");
  strcpy((char * __restrict  )(Keywords[46]), (char const   * __restrict  )"POL_ARRANGEMENT");
  strcpy((char * __restrict  )(Keywords[47]), (char const   * __restrict  )"GROUP");
  strcpy((char * __restrict  )(Keywords[48]), (char const   * __restrict  )"ERRORS");
  strcpy((char * __restrict  )(Keywords[49]), (char const   * __restrict  )"FAILURES");
  strcpy((char * __restrict  )(Keywords[50]), (char const   * __restrict  )"END");
  strcpy((char * __restrict  )(Keywords[51]), (char const   * __restrict  )"deg");
  strcpy((char * __restrict  )(Keywords[52]), (char const   * __restrict  )"rad");
  strcpy((char * __restrict  )(Keywords[53]), (char const   * __restrict  )"PX");
  strcpy((char * __restrict  )(Keywords[54]), (char const   * __restrict  )"PY");
  strcpy((char * __restrict  )(Keywords[55]), (char const   * __restrict  )"QX");
  strcpy((char * __restrict  )(Keywords[56]), (char const   * __restrict  )"QY");
  strcpy((char * __restrict  )(Keywords[57]), (char const   * __restrict  )"PDIM");
  strcpy((char * __restrict  )(Keywords[58]), (char const   * __restrict  )"QDIM");
  strcpy((char * __restrict  )(Keywords[59]), (char const   * __restrict  )"E_ANG");
  strcpy((char * __restrict  )(Keywords[60]), (char const   * __restrict  )"H_ANG");
  strcpy((char * __restrict  )(Keywords[61]), (char const   * __restrict  )"E_TAP");
  strcpy((char * __restrict  )(Keywords[62]), (char const   * __restrict  )"H_TAP");
  strcpy((char * __restrict  )(Keywords[63]), (char const   * __restrict  )"POWER");
  strcpy((char * __restrict  )(Keywords[64]), (char const   * __restrict  )"dB");
  strcpy((char * __restrict  )(Keywords[65]), (char const   * __restrict  )"LH");
  strcpy((char * __restrict  )(Keywords[66]), (char const   * __restrict  )"RH");
  strcpy((char * __restrict  )(Keywords[67]), (char const   * __restrict  )"PHASE_SHAPING");
  strcpy((char * __restrict  )(Keywords[68]), (char const   * __restrict  )"PHASE_SCANNING");
  strcpy((char * __restrict  )(Keywords[69]), (char const   * __restrict  )"PHASE_POL_ARRANG");
  strcpy((char * __restrict  )(Keywords[70]), (char const   * __restrict  )"THETA");
  strcpy((char * __restrict  )(Keywords[71]), (char const   * __restrict  )"PHI");
  strcpy((char * __restrict  )(Keywords[72]), (char const   * __restrict  )"PSI");
  strcpy((char * __restrict  )(Keywords[73]), (char const   * __restrict  )"NODE");
  strcpy((char * __restrict  )(Keywords[74]), (char const   * __restrict  )"P");
  strcpy((char * __restrict  )(Keywords[75]), (char const   * __restrict  )"Q");
  strcpy((char * __restrict  )(Keywords[76]), (char const   * __restrict  )"BLOCK");
  strcpy((char * __restrict  )(Keywords[77]), (char const   * __restrict  )"POLYGON");
  strcpy((char * __restrict  )(Keywords[78]), (char const   * __restrict  )"HEXAGON");
  strcpy((char * __restrict  )(Keywords[79]), (char const   * __restrict  )"ADD");
  strcpy((char * __restrict  )(Keywords[80]), (char const   * __restrict  )"REMOVE");
  strcpy((char * __restrict  )(Keywords[81]), (char const   * __restrict  )"SECOND");
  strcpy((char * __restrict  )(Keywords[82]), (char const   * __restrict  )"ORDER");
  strcpy((char * __restrict  )(Keywords[83]), (char const   * __restrict  )"CENTRE");
  strcpy((char * __restrict  )(Keywords[84]), (char const   * __restrict  )"P1_VAL");
  strcpy((char * __restrict  )(Keywords[85]), (char const   * __restrict  )"P2_VAL");
  strcpy((char * __restrict  )(Keywords[86]), (char const   * __restrict  )"Q1_VAL");
  strcpy((char * __restrict  )(Keywords[87]), (char const   * __restrict  )"Q2_VAL");
  strcpy((char * __restrict  )(Keywords[88]), (char const   * __restrict  )"UNIFORM");
  strcpy((char * __restrict  )(Keywords[89]), (char const   * __restrict  )"P1_VAL");
  strcpy((char * __restrict  )(Keywords[90]), (char const   * __restrict  )"P2_VAL");
  strcpy((char * __restrict  )(Keywords[91]), (char const   * __restrict  )"Q1_VAL");
  strcpy((char * __restrict  )(Keywords[92]), (char const   * __restrict  )"Q2_VAL");
  strcpy((char * __restrict  )(Keywords[93]), (char const   * __restrict  )"CW");
  strcpy((char * __restrict  )(Keywords[94]), (char const   * __restrict  )"CCW");
  strcpy((char * __restrict  )(Keywords[95]), (char const   * __restrict  )"START");
  strcpy((char * __restrict  )(Keywords[96]), (char const   * __restrict  )"POINTING");
  strcpy((char * __restrict  )(Keywords[97]), (char const   * __restrict  )"U");
  strcpy((char * __restrict  )(Keywords[98]), (char const   * __restrict  )"V");
  strcpy((char * __restrict  )(Keywords[99]), (char const   * __restrict  )"ROTATION");
  strcpy((char * __restrict  )(Keywords[100]), (char const   * __restrict  )"SEQUENTIAL");
  strcpy((char * __restrict  )(Keywords[101]), (char const   * __restrict  )"GROUP_EXCITATION");
  strcpy((char * __restrict  )(Keywords[102]), (char const   * __restrict  )"ADD_GROUP");
  strcpy((char * __restrict  )(Keywords[103]), (char const   * __restrict  )"AT");
  strcpy((char * __restrict  )(Keywords[104]), (char const   * __restrict  )"PLACE_GROUP");
  strcpy((char * __restrict  )(Keywords[105]), (char const   * __restrict  )"DISPLACE");
  strcpy((char * __restrict  )(Keywords[106]), (char const   * __restrict  )"MOVE");
  strcpy((char * __restrict  )(Keywords[107]), (char const   * __restrict  )"TO");
  strcpy((char * __restrict  )(Keywords[108]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[109]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[110]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[111]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[112]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[113]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[114]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[115]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[116]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[117]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[118]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[119]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[120]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[121]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[122]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[123]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[124]), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(Keywords[125]), (char const   * __restrict  )"");
  i = (char)0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((int )i <= 125)) {
      goto while_break___0;
    }
    {
    tmp = strlen((char const   *)(Keywords[i]));
    }
    if (tmp > 20UL) {
      {
      printf((char const   * __restrict  )"\n ******** ERROR: KEYWORD no.%d TOO LONG - CORRECT Keywords[] ASSIGNMENT\n",
             (int )i);
      interror((char *)"kwdsinit()");
      }
    }
    i = (char )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
int lenunit(struct charac **tp , int *unit ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = *tp;
  *unit = 0;
  tmp___2 = GetKeyword(Keywords[6], curr_ptr);
  }
  if (tmp___2 == 0) {
    *unit = 0;
  } else {
    {
    tmp___1 = GetKeyword(Keywords[7], curr_ptr);
    }
    if (tmp___1 == 0) {
      *unit = 1;
    } else {
      {
      tmp___0 = GetKeyword(Keywords[8], curr_ptr);
      }
      if (tmp___0 == 0) {
        *unit = 2;
      } else {
        {
        tmp = GetKeyword(Keywords[9], curr_ptr);
        }
        if (tmp == 0) {
          *unit = 3;
        } else {
          return (14);
        }
      }
    }
  }
  *tp = *curr_ptr;
  return (0);
}
}
int linconv(double *x_ptr , int unit ) 
{ 


  {
  {
  if (unit == 0) {
    goto case_0;
  }
  if (unit == 1) {
    goto case_1;
  }
  if (unit == 2) {
    goto case_2;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  *x_ptr = sqrt(*x_ptr);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  *x_ptr = pow((double )10, *x_ptr / (double )20);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  interror((char *)"linconv() -1-");
  }
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
int linpol(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[15], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = polor(*curr_ptr, curr_ptr, angle_ptr, angle_unit_ptr);
  }
  if (error == 1) {
    *angle_ptr = (double )90;
    *angle_unit_ptr = 0;
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[31]);
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int mksblock(struct AddRem *addrem_ptr , struct Geomnode **first_node_ptr , struct Geomnode **last_node_ptr ,
             double pstep , double qstep , double angle , int *nodes_num_ptr , int elem_shape ,
             double elem_pdim , double elem_qdim ) 
{ 
  struct Geomnode *app_ptr ;
  struct Geomnode *primo_ptr ;
  struct Geomnode *ultimo_ptr ;
  int p ;
  int q ;
  int p1 ;
  int q1 ;
  int p2 ;
  int q2 ;
  double x ;
  double y ;
  int *pp1 ;
  int *pp2 ;
  int *qq1 ;
  int *qq2 ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  app_ptr = (struct Geomnode *)((void *)0);
  primo_ptr = (struct Geomnode *)((void *)0);
  ultimo_ptr = (struct Geomnode *)((void *)0);
  pp1 = & p1;
  pp2 = & p2;
  qq1 = & q1;
  qq2 = & q2;
  p1 = (addrem_ptr->NODE_PTR)->PCOORD;
  q1 = (addrem_ptr->NODE_PTR)->QCOORD;
  p2 = ((addrem_ptr->NODE_PTR)->NEXT)->PCOORD;
  q2 = ((addrem_ptr->NODE_PTR)->NEXT)->QCOORD;
  *nodes_num_ptr = 0;
  q = intmin(q1, q2);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___3 = intmax(q1, q2);
    }
    if (! (q <= tmp___3)) {
      goto while_break;
    }
    {
    p = intmin(p1, p2);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___2 = intmax(p1, p2);
      }
      if (! (p <= tmp___2)) {
        goto while_break___0;
      }
      {
      tmp = malloc(sizeof(struct Geomnode ));
      app_ptr = (struct Geomnode *)tmp;
      }
      if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
        {
        printf((char const   * __restrict  )"%s", MOSErrors[0]);
        interror((char *)"mksblock()");
        }
      }
      {
      tmp___0 = dsin(angle);
      y = ((double )q * qstep) * tmp___0;
      tmp___1 = dcos(angle);
      x = (double )p * pstep + ((double )q * qstep) * tmp___1;
      (*nodes_num_ptr) ++;
      app_ptr->LOC_P = p;
      app_ptr->LOC_Q = q;
      app_ptr->XA = x;
      app_ptr->YA = y;
      app_ptr->ZA = (double )0;
      app_ptr->SUBGROUP_PTR = (struct Geomnode *)((void *)0);
      app_ptr->SHAPE = elem_shape;
      app_ptr->PSIZE = elem_pdim;
      app_ptr->QSIZE = elem_qdim;
      app_ptr->THEA = (double )0;
      app_ptr->PHEA = (double )0;
      app_ptr->PSEA = (double )0;
      }
      if ((unsigned long )primo_ptr == (unsigned long )((void *)0)) {
        primo_ptr = app_ptr;
      } else {
        ultimo_ptr->NEXT = app_ptr;
      }
      ultimo_ptr = app_ptr;
      ultimo_ptr->NEXT = (struct Geomnode *)((void *)0);
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
  *first_node_ptr = primo_ptr;
  *last_node_ptr = ultimo_ptr;
  return (0);
}
}
int mkshex(struct AddRem *addrem_ptr , struct Geomnode **first_node_ptr , struct Geomnode **last_node_ptr ,
           double pstep , double qstep , double angle , int *nodes_num_ptr , int elem_shape ,
           double elem_pdim , double elem_qdim ) 
{ 
  struct Geomnode *app_ptr ;
  struct Geomnode *primo_ptr ;
  struct Geomnode *ultimo_ptr ;
  int p ;
  int q ;
  int P[8] ;
  int Q[8] ;
  int i ;
  double x ;
  double y ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  app_ptr = (struct Geomnode *)((void *)0);
  primo_ptr = (struct Geomnode *)((void *)0);
  ultimo_ptr = (struct Geomnode *)((void *)0);
  p = (addrem_ptr->NODE_PTR)->PCOORD;
  q = (addrem_ptr->NODE_PTR)->QCOORD;
  *nodes_num_ptr = 0;
  P[1] = p - 1;
  Q[1] = q + 1;
  P[2] = p;
  Q[2] = q + 1;
  P[3] = p + 1;
  Q[3] = q;
  P[4] = p + 1;
  Q[4] = q - 1;
  P[5] = p;
  Q[5] = q - 1;
  P[6] = p - 1;
  Q[6] = q;
  P[7] = p;
  Q[7] = q;
  i = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= 7)) {
      goto while_break;
    }
    {
    tmp = malloc(sizeof(struct Geomnode ));
    app_ptr = (struct Geomnode *)tmp;
    }
    if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
      {
      printf((char const   * __restrict  )"%s", MOSErrors[0]);
      interror((char *)"mkshex()");
      }
    }
    {
    tmp___0 = dcos(angle);
    x = (double )P[i] * pstep + ((double )Q[i] * qstep) * tmp___0;
    tmp___1 = dsin(angle);
    y = ((double )Q[i] * qstep) * tmp___1;
    (*nodes_num_ptr) ++;
    app_ptr->LOC_P = P[i];
    app_ptr->LOC_Q = Q[i];
    app_ptr->XA = x;
    app_ptr->YA = y;
    app_ptr->ZA = (double )0;
    app_ptr->SUBGROUP_PTR = (struct Geomnode *)((void *)0);
    app_ptr->SHAPE = elem_shape;
    app_ptr->PSIZE = elem_pdim;
    app_ptr->QSIZE = elem_qdim;
    app_ptr->THEA = (double )0;
    app_ptr->PHEA = (double )0;
    app_ptr->PSEA = (double )0;
    }
    if ((unsigned long )primo_ptr == (unsigned long )((void *)0)) {
      primo_ptr = app_ptr;
    } else {
      ultimo_ptr->NEXT = app_ptr;
    }
    ultimo_ptr = app_ptr;
    ultimo_ptr->NEXT = (struct Geomnode *)((void *)0);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  *first_node_ptr = primo_ptr;
  *last_node_ptr = ultimo_ptr;
  return (0);
}
}
int mksnode(struct AddRem *addrem_ptr , struct Geomnode **first_node_ptr , struct Geomnode **last_node_ptr ,
            double pstep , double qstep , double angle , int *nodes_num_ptr , int elem_shape ,
            double elem_pdim , double elem_qdim ) 
{ 
  struct Geomnode *app_ptr ;
  int p ;
  int q ;
  double x ;
  double y ;
  int *pp ;
  int *qq ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
  app_ptr = (struct Geomnode *)((void *)0);
  pp = & p;
  qq = & q;
  p = (addrem_ptr->NODE_PTR)->PCOORD;
  q = (addrem_ptr->NODE_PTR)->QCOORD;
  *nodes_num_ptr = 0;
  tmp = malloc(sizeof(struct Geomnode ));
  app_ptr = (struct Geomnode *)tmp;
  }
  if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
    {
    printf((char const   * __restrict  )"%s", MOSErrors[0]);
    interror((char *)"mksnode()");
    }
  }
  {
  tmp___0 = dcos(angle);
  x = (double )p * pstep + ((double )q * qstep) * tmp___0;
  tmp___1 = dsin(angle);
  y = ((double )q * qstep) * tmp___1;
  (*nodes_num_ptr) ++;
  app_ptr->LOC_P = p;
  app_ptr->LOC_Q = q;
  app_ptr->XA = x;
  app_ptr->YA = y;
  app_ptr->ZA = (double )0;
  app_ptr->SUBGROUP_PTR = (struct Geomnode *)((void *)0);
  app_ptr->NEXT = (struct Geomnode *)((void *)0);
  app_ptr->SHAPE = elem_shape;
  app_ptr->PSIZE = elem_pdim;
  app_ptr->QSIZE = elem_qdim;
  fixnodor(addrem_ptr->NODE_PTR);
  app_ptr->THEA = (addrem_ptr->NODE_PTR)->THEA;
  app_ptr->PHEA = (addrem_ptr->NODE_PTR)->PHEA;
  app_ptr->PSEA = (addrem_ptr->NODE_PTR)->PSEA;
  *first_node_ptr = app_ptr;
  *last_node_ptr = app_ptr;
  }
  return (0);
}
}
int mmconv(double *x_ptr , int unit ) 
{ 


  {
  {
  if (unit == 0) {
    goto case_0;
  }
  if (unit == 1) {
    goto case_1;
  }
  if (unit == 2) {
    goto case_2;
  }
  if (unit == 3) {
    goto case_3;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  goto switch_break;
  case_1: /* CIL Label */ 
  *x_ptr *= (double )10;
  goto switch_break;
  case_2: /* CIL Label */ 
  *x_ptr *= (double )100;
  goto switch_break;
  case_3: /* CIL Label */ 
  *x_ptr *= (double )1000;
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  interror((char *)"mmconv -1- ");
  }
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
int modspec(struct charac *p1 , struct charac **pp2 , int *model_ptr , double *exp_ptr ,
            double *anglee_ptr , double *angleh_ptr , int *angle_unit_ptr , double *tapere_ptr ,
            double *taperh_ptr , int *taper_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[30], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 1, Keywords[30]);
    }
    return (1);
  }
  {
  *model_ptr = 0;
  error = extmod(*curr_ptr, curr_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    return (17);
  }
  {
  *model_ptr = 1;
  error = cosinus(*curr_ptr, curr_ptr, exp_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    return (17);
  }
  {
  *model_ptr = 2;
  error = gaussel(*curr_ptr, curr_ptr, anglee_ptr, angleh_ptr, angle_unit_ptr, tapere_ptr,
                  taperh_ptr, taper_unit_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[28]);
    }
    return (17);
  }
  {
  *model_ptr = 0;
  parserro(*curr_ptr, 35, (char *)" ");
  }
  return (17);
}
}
void moseinit(void) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= 20)) {
      goto while_break;
    }
    MOSErrors[i][0] = (char )'\000';
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  strcpy((char * __restrict  )(MOSErrors[0]), (char const   * __restrict  )"** ERROR  B0: Out of memory during MOS.");
  strcpy((char * __restrict  )(MOSErrors[1]), (char const   * __restrict  )"** ERROR  B1: External ELEMENT not suitable for GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[2]), (char const   * __restrict  )"** WARNING B2: GRID step(s) too small for specified element in GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[3]), (char const   * __restrict  )"** ERROR  B3: RECTANGULAR element not allowed on HEXAGONAL grid in GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[4]), (char const   * __restrict  )"** ERROR  B4: GRID angle out of non ambiguity range; angle=");
  strcpy((char * __restrict  )(MOSErrors[5]), (char const   * __restrict  )"** ERROR  B5: SECOND ORDER law not allowed on irregular groups.");
  strcpy((char * __restrict  )(MOSErrors[6]), (char const   * __restrict  )"** ERROR  B6: AMPLITUDE excitation error in GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[7]), (char const   * __restrict  )"** ERROR  B7: Only CIRCULAR elements allowed for ADD HEXAGON statement.");
  strcpy((char * __restrict  )(MOSErrors[8]), (char const   * __restrict  )"** ERROR  B8: Error in group geometry; GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[9]), (char const   * __restrict  )"** ERROR  B9: PHASE excitation error in GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[10]), (char const   * __restrict  )"** ERROR B10: SEQUENTIAL ROTATION not allowed to multiport elements.");
  strcpy((char * __restrict  )(MOSErrors[11]), (char const   * __restrict  )"** ERROR B11: SEQUENTIAL ROTATION not allowed on irregular shaped groups.");
  strcpy((char * __restrict  )(MOSErrors[12]), (char const   * __restrict  )"** WARNING B12: GRID step(s) too small for sequential rotation in GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[13]), (char const   * __restrict  )"** ERROR B13: Cannot open output file:");
  strcpy((char * __restrict  )(MOSErrors[14]), (char const   * __restrict  )"** ERROR B14: Simple element duplicate definition in GROUP: ");
  strcpy((char * __restrict  )(MOSErrors[15]), (char const   * __restrict  )"** ERROR B15: ");
  strcpy((char * __restrict  )(MOSErrors[16]), (char const   * __restrict  )"** ERROR B16: ");
  strcpy((char * __restrict  )(MOSErrors[17]), (char const   * __restrict  )"** ERROR B17: ");
  strcpy((char * __restrict  )(MOSErrors[18]), (char const   * __restrict  )"** ERROR B18: ");
  strcpy((char * __restrict  )(MOSErrors[19]), (char const   * __restrict  )"** ERROR B19: ");
  }
  return;
}
}
int nodecoor(struct charac *p1 , struct charac **pp2 , int *pcoord_ptr , int *qcoord_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[74], curr_ptr);
  error = 0;
  error = GetInt(*curr_ptr, curr_ptr, pcoord_ptr);
  }
  if (error != 0) {
    return (17);
  }
  {
  error = GetKeyword(Keywords[75], curr_ptr);
  error = 0;
  error = GetInt(*curr_ptr, curr_ptr, qcoord_ptr);
  }
  if (error != 0) {
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int nodedef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  int pcoord ;
  int *pcoord_ptr ;
  int qcoord ;
  int *qcoord_ptr ;
  double thea ;
  double *thea_ptr ;
  double phea ;
  double *phea_ptr ;
  double psea ;
  double *psea_ptr ;
  int angle_unit ;
  int *angle_unit_ptr ;
  int omit_orient ;
  void *tmp ;

  {
  {
  curr_ptr = & curr;
  pcoord_ptr = & pcoord;
  qcoord_ptr = & qcoord;
  thea_ptr = & thea;
  phea_ptr = & phea;
  psea_ptr = & psea;
  angle_unit_ptr = & angle_unit;
  *curr_ptr = p1;
  error = 0;
  omit_orient = 0;
  *node_ptr = (struct Node *)((void *)0);
  error = GetKeyword(Keywords[73], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = nodecoor(*curr_ptr, curr_ptr, pcoord_ptr, qcoord_ptr);
  }
  if (error == 1) {
    {
    parserro(*curr_ptr, 52, (char *)" ");
    }
    return (17);
  }
  if (error == 17) {
    {
    parserro(*curr_ptr, 53, (char *)" ");
    }
    return (17);
  }
  if (error == 0) {
    {
    error = nodorien(*curr_ptr, curr_ptr, thea_ptr, phea_ptr, psea_ptr, angle_unit_ptr);
    }
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[54]);
    }
    return (17);
  }
  if (error == 1) {
    omit_orient = 1;
  }
  {
  tmp = malloc(sizeof(struct Node ));
  *node_ptr = (struct Node *)tmp;
  }
  if ((unsigned long )*node_ptr == (unsigned long )((void *)0)) {
    {
    parserro(*curr_ptr, 55, (char *)" ");
    interror((char *)"nodedef()");
    }
  }
  (*node_ptr)->NEXT = (struct Node *)((void *)0);
  (*node_ptr)->PCOORD = pcoord;
  (*node_ptr)->QCOORD = qcoord;
  (*node_ptr)->THEA = thea;
  (*node_ptr)->PHEA = phea;
  (*node_ptr)->PSEA = psea;
  (*node_ptr)->ANGLE_UNIT = angle_unit;
  (*node_ptr)->OMIT_ORIENT = omit_orient;
  *pp2 = *curr_ptr;
  return (0);
}
}
int nodorien(struct charac *p1 , struct charac **pp2 , double *theta_ptr , double *phi_ptr ,
             double *psi_ptr , int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[37], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[70], curr_ptr);
  error = 0;
  error = GetReal(theta_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 19, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[71], curr_ptr);
  error = 0;
  error = GetReal(phi_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 19, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[72], curr_ptr);
  error = 0;
  error = GetReal(psi_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 19, (char *)" ");
    }
    return (17);
  }
  {
  error = angunit(*curr_ptr, curr_ptr, angle_unit_ptr);
  }
  if (error != 0) {
    *angle_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
void nomefile(char *fn ) 
{ 


  {
  {
  strcpy((char * __restrict  )fn, (char const   * __restrict  )(GLOBLE_FILENAME));
  }
  return;
}
}
static int errline_printed  =    0;
void parserro(struct charac *err_ptr , int errcode , char *s ) 
{ 
  struct charac *p ;
  int n ;
  int i ;

  {
  n = 0;
  p = err_ptr;
  if (! errline_printed) {
    {
    errline_printed = 1;
    printf((char const   * __restrict  )"\nError occurred at line %d", err_ptr->LINE_NUM);
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if ((unsigned long )p->PREV != (unsigned long )((void *)0)) {
        if (! ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      n ++;
      p = p->PREV;
    }
    while_break: /* CIL Label */ ;
    }
    {
    printf((char const   * __restrict  )"\n%4d:\t", p->LINE_NUM);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        if (! (p->LINE_NUM == err_ptr->LINE_NUM)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      {
      printf((char const   * __restrict  )"%c", (int )p->info);
      p = p->NEXT;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    printf((char const   * __restrict  )"\n%    \t");
    i = 1;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i <= n)) {
        goto while_break___1;
      }
      {
      printf((char const   * __restrict  )" ");
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    printf((char const   * __restrict  )"^");
    }
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    printf((char const   * __restrict  )"\n%s\n", ErrorMessages[errcode]);
    }
  } else {
    {
    printf((char const   * __restrict  )"\n%s%s\n", ErrorMessages[errcode], s);
    }
  }
  return;
}
}
int phaserot(struct charac *p1 , struct charac **pp2 , double *phase_start_ptr , double *phase_step_ptr ,
             int *phase_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[43], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[95], curr_ptr);
  error = 0;
  error = GetReal(phase_start_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 74, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[16], curr_ptr);
  error = 0;
  error = angval(*curr_ptr, curr_ptr, phase_step_ptr, phase_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 74, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int polor(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[37], curr_ptr);
  }
  if (error != 0) {
    *angle_ptr = (double )90;
    *angle_unit_ptr = 0;
    return (1);
  }
  {
  *angle_ptr = (double )0;
  *angle_unit_ptr = 0;
  error = GetKeyword(Keywords[12], curr_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  *angle_ptr = (double )90;
  *angle_unit_ptr = 0;
  error = GetKeyword(Keywords[13], curr_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = angval(*curr_ptr, curr_ptr, angle_ptr, angle_unit_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    parserro(*curr_ptr, 30, (char *)" ");
    }
    return (17);
  }
  return (17);
}
}
int polorbis(struct charac *p1 , struct charac **pp2 , double *phepol_ptr , int *phepol_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[41], curr_ptr);
  }
  if (error != 0) {
    *phepol_ptr = (double )90;
    *phepol_unit_ptr = 0;
    return (1);
  }
  {
  *phepol_ptr = (double )0;
  *phepol_unit_ptr = 0;
  error = GetKeyword(Keywords[12], curr_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  *phepol_ptr = (double )90;
  *phepol_unit_ptr = 0;
  error = GetKeyword(Keywords[13], curr_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = angval(*curr_ptr, curr_ptr, phepol_ptr, phepol_unit_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    parserro(*curr_ptr, 30, (char *)" ");
    }
    return (17);
  }
  return (17);
}
}
int polspec(struct charac *p1 , struct charac **pp2 , int *polarization_ptr , double *phepol_ptr ,
            int *phepol_unit_ptr , int *direction_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *polarization_ptr = 0;
  *phepol_ptr = (double )90;
  *phepol_unit_ptr = 0;
  *direction_ptr = 0;
  error = GetKeyword(Keywords[31], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  *polarization_ptr = 0;
  error = linpol(*curr_ptr, curr_ptr, phepol_ptr, phepol_unit_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[31]);
    }
    return (17);
  }
  {
  *polarization_ptr = 1;
  error = circpol(*curr_ptr, curr_ptr, direction_ptr);
  }
  if (error == 0) {
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[32]);
    }
    return (17);
  }
  return (17);
}
}
int polydef(struct charac *p1 , struct charac **pp2 , struct Node **node_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  int cont ;
  struct Node *primo_ptr ;
  struct Node *ultimo_ptr ;
  struct Node *app_ptr ;
  int pcoord ;
  int *pcoord_ptr ;
  int qcoord ;
  int *qcoord_ptr ;
  void *tmp ;

  {
  {
  curr_ptr = & curr;
  cont = 0;
  primo_ptr = (struct Node *)((void *)0);
  ultimo_ptr = (struct Node *)((void *)0);
  app_ptr = (struct Node *)((void *)0);
  pcoord_ptr = & pcoord;
  qcoord_ptr = & qcoord;
  *curr_ptr = p1;
  error = 0;
  *node_ptr = (struct Node *)((void *)0);
  error = GetKeyword(Keywords[77], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    error = nodecoor(*curr_ptr, curr_ptr, pcoord_ptr, qcoord_ptr);
    }
    if (error == 0) {
      {
      cont ++;
      tmp = malloc(sizeof(struct Node ));
      app_ptr = (struct Node *)tmp;
      }
      if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
        {
        parserro(*curr_ptr, 55, (char *)" ");
        interror((char *)"polydef()");
        }
      }
      app_ptr->PCOORD = pcoord;
      app_ptr->QCOORD = qcoord;
      app_ptr->THEA = (double )0;
      app_ptr->PHEA = (double )0;
      app_ptr->PSEA = (double )0;
      app_ptr->ANGLE_UNIT = 0;
      if ((unsigned long )primo_ptr == (unsigned long )((void *)0)) {
        primo_ptr = app_ptr;
        ultimo_ptr = app_ptr;
        app_ptr->NEXT = (struct Node *)((void *)0);
      } else {
        ultimo_ptr->NEXT = app_ptr;
        ultimo_ptr = app_ptr;
        ultimo_ptr->NEXT = (struct Node *)((void *)0);
      }
    }
    if (error != 0) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (cont < 3) {
    {
    *node_ptr = (struct Node *)((void *)0);
    parserro(*curr_ptr, 65, (char *)" ");
    }
    return (17);
  }
  *node_ptr = primo_ptr;
  *pp2 = *curr_ptr;
  return (0);
}
}
int portamp(struct charac *p1 , struct charac **pp2 , double *amp_ptr , int *amp_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[42], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = ampval(*curr_ptr, curr_ptr, amp_ptr, amp_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 27, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int portdef(struct charac *p1 , struct charac **pp2 , struct Port *PORT_PTR , int *portnum_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  double amp ;
  double *amp_ptr ;
  int amp_unit ;
  int *amp_unit_ptr ;
  double psc ;
  double *psc_ptr ;
  int psc_unit ;
  int *psc_unit_ptr ;
  double psh ;
  double *psh_ptr ;
  int psh_unit ;
  int *psh_unit_ptr ;
  double ppa ;
  double *ppa_ptr ;
  int ppa_unit ;
  int *ppa_unit_ptr ;
  double phepol ;
  double *phepol_ptr ;
  int phepol_unit ;
  int *phepol_unit_ptr ;
  int omit_pol ;
  int *omit_pol_ptr ;

  {
  {
  curr_ptr = & curr;
  amp_ptr = & amp;
  amp_unit_ptr = & amp_unit;
  psc_ptr = & psc;
  psc_unit_ptr = & psc_unit;
  psh_ptr = & psh;
  psh_unit_ptr = & psh_unit;
  ppa_ptr = & ppa;
  ppa_unit_ptr = & ppa_unit;
  phepol_ptr = & phepol;
  phepol_unit_ptr = & phepol_unit;
  omit_pol_ptr = & omit_pol;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[40], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 1, Keywords[40]);
    }
    return (1);
  }
  {
  error = GetNatur(*curr_ptr, curr_ptr, portnum_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    }
    return (17);
  }
  {
  *omit_pol_ptr = 0;
  error = polorbis(*curr_ptr, curr_ptr, phepol_ptr, phepol_unit_ptr);
  }
  if (error == 1) {
    *omit_pol_ptr = 1;
    *phepol_ptr = (double )90;
    *phepol_unit_ptr = 0;
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[38]);
    }
    return (17);
  }
  {
  error = portamp(*curr_ptr, curr_ptr, amp_ptr, amp_unit_ptr);
  }
  if (error != 0) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[39]);
    }
    return (17);
  }
  {
  error = pshdef1(*curr_ptr, curr_ptr, psh_ptr, psh_unit_ptr);
  }
  if (error == 1) {
    *psh_ptr = (double )0;
    *psh_unit_ptr = 0;
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[40]);
    }
    return (17);
  }
  {
  error = pscdef1(*curr_ptr, curr_ptr, psc_ptr, psc_unit_ptr);
  }
  if (error == 1) {
    *psc_ptr = (double )0;
    *psc_unit_ptr = 0;
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[40]);
    }
    return (17);
  }
  {
  error = ppadef1(*curr_ptr, curr_ptr, ppa_ptr, ppa_unit_ptr);
  }
  if (error == 1) {
    *ppa_ptr = (double )0;
    *ppa_unit_ptr = 0;
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[40]);
    }
    return (17);
  }
  PORT_PTR->AMP = amp;
  PORT_PTR->AMP_UNIT = amp_unit;
  PORT_PTR->PSC = psc;
  PORT_PTR->PSC_UNIT = psc_unit;
  PORT_PTR->PSH = psh;
  PORT_PTR->PSH_UNIT = psh_unit;
  PORT_PTR->PPA = ppa;
  PORT_PTR->PPA_UNIT = ppa_unit;
  PORT_PTR->PHEPOL = phepol;
  PORT_PTR->PHEPOL_UNIT = phepol_unit;
  PORT_PTR->OMIT_POL = omit_pol;
  *pp2 = *curr_ptr;
  return (0);
}
}
int portspec(struct charac *p1 , struct charac **pp2 , int *nports_ptr , struct Port **port_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  int n ;
  int portnum ;
  int *portnum_ptr ;
  struct Port *primo_ptr ;
  struct Port *ultimo_ptr ;
  struct Port *app_ptr ;
  void *tmp ;

  {
  {
  curr_ptr = & curr;
  portnum_ptr = & portnum;
  primo_ptr = (struct Port *)((void *)0);
  ultimo_ptr = (struct Port *)((void *)0);
  app_ptr = (struct Port *)((void *)0);
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[39], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetNatur(*curr_ptr, curr_ptr, nports_ptr);
  }
  if (error != 0) {
    {
    *nports_ptr = 0;
    parserro(*curr_ptr, 93, (char *)" ");
    }
    return (17);
  }
  n = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (n <= *nports_ptr)) {
      goto while_break;
    }
    {
    tmp = malloc(sizeof(struct Port ));
    app_ptr = (struct Port *)tmp;
    }
    if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"portspec()");
      }
    }
    {
    error = portdef(*curr_ptr, curr_ptr, app_ptr, portnum_ptr);
    }
    if (error == 1) {
      {
      parserro(*curr_ptr, 46, (char *)" ");
      }
      return (17);
    }
    if (error == 17) {
      {
      printf((char const   * __restrict  )"\n%s%d", ErrorMessages[47], n);
      }
      return (17);
    }
    app_ptr->PORTNUM = *portnum_ptr;
    if ((unsigned long )primo_ptr == (unsigned long )((void *)0)) {
      primo_ptr = app_ptr;
    } else {
      ultimo_ptr->NEXT = app_ptr;
    }
    ultimo_ptr = app_ptr;
    ultimo_ptr->NEXT = (struct Port *)((void *)0);
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  *port_ptr = primo_ptr;
  *pp2 = *curr_ptr;
  return (0);
}
}
int ppadef1(struct charac *p1 , struct charac **pp2 , double *ppa_ptr , int *ppa_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[69], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = angval(*curr_ptr, curr_ptr, ppa_ptr, ppa_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 37, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int pqlimits(struct Geomnode *gnode_ptr , struct Geomnode **pmin_ptr , struct Geomnode **pmax_ptr ,
             struct Geomnode **qmin_ptr , struct Geomnode **qmax_ptr ) 
{ 
  struct Geomnode *app_ptr ;
  int pmin ;
  int pmax ;
  int qmin ;
  int qmax ;
  struct Geomnode *tmp ;
  struct Geomnode *tmp___0 ;
  struct Geomnode *tmp___1 ;

  {
  pmin = 2147483647;
  pmax = (-0x7FFFFFFF-1);
  qmin = 2147483647;
  qmax = (-0x7FFFFFFF-1);
  app_ptr = gnode_ptr;
  tmp___1 = app_ptr;
  *qmax_ptr = tmp___1;
  tmp___0 = tmp___1;
  *qmin_ptr = tmp___0;
  tmp = tmp___0;
  *pmax_ptr = tmp;
  *pmin_ptr = tmp;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (app_ptr->LOC_P < pmin) {
      pmin = app_ptr->LOC_P;
      *pmin_ptr = app_ptr;
    }
    if (app_ptr->LOC_P > pmax) {
      pmax = app_ptr->LOC_P;
      *pmax_ptr = app_ptr;
    }
    if (app_ptr->LOC_Q < qmin) {
      qmin = app_ptr->LOC_Q;
      *qmin_ptr = app_ptr;
    }
    if (app_ptr->LOC_Q > qmax) {
      qmax = app_ptr->LOC_Q;
      *qmax_ptr = app_ptr;
    }
    app_ptr = app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
void prnfile(struct charac *firstel ) 
{ 
  struct charac *p ;
  char ch ;
  int line_num ;

  {
  {
  ch = (char )' ';
  line_num = 0;
  printf((char const   * __restrict  )"\n");
  p = firstel;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p->NEXT != (unsigned long )((void *)0))) {
      goto while_break;
    }
    ch = p->info;
    if (p->LINE_NUM > line_num) {
      {
      line_num = p->LINE_NUM;
      printf((char const   * __restrict  )"\n%4d\t", line_num);
      }
    }
    {
    putchar((int )ch);
    p = p->NEXT;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  printf((char const   * __restrict  )"\n");
  }
  return;
}
}
int pscdef1(struct charac *p1 , struct charac **pp2 , double *psc_ptr , int *psc_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[68], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = angval(*curr_ptr, curr_ptr, psc_ptr, psc_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 37, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int pshdef1(struct charac *p1 , struct charac **pp2 , double *psh_ptr , int *psh_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[67], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = angval(*curr_ptr, curr_ptr, psh_ptr, psh_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 37, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int readfil3(char *filename , struct charac **firstel , struct charac **lastel ) 
{ 
  FILE *f ;
  char c ;
  struct charac *p ;
  int line_num ;
  char CR ;
  char adlfilename[101] ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;

  {
  {
  line_num = 1;
  CR = (char )'\n';
  *firstel = (struct charac *)((void *)0);
  *lastel = (struct charac *)((void *)0);
  strcpy((char * __restrict  )(adlfilename), (char const   * __restrict  )filename);
  strcat((char * __restrict  )(adlfilename), (char const   * __restrict  )".adl");
  f = fopen((char const   * __restrict  )(adlfilename), (char const   * __restrict  )"r");
  }
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
    printf((char const   * __restrict  )"%s %s", ErrorMessages[21], adlfilename);
    }
    return (21);
  }
  {
  tmp = _IO_getc(f);
  c = (char )tmp;
  }
  if ((int )c == -1) {
    {
    printf((char const   * __restrict  )"%s %s", ErrorMessages[23], adlfilename);
    }
    return (23);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___1 = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp___1 + (int )c) & 8192)) {
      if (! ((int )c == 44)) {
        goto while_break;
      }
    }
    if ((int )c == (int )CR) {
      line_num ++;
    }
    {
    tmp___0 = _IO_getc(f);
    c = (char )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___2 = malloc(sizeof(struct charac ));
  p = (struct charac *)tmp___2;
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    printf((char const   * __restrict  )"%s", ErrorMessages[22]);
    }
    return (22);
  }
  {
  p->info = c;
  p->LINE_NUM = line_num;
  p->PREV = (struct charac *)((void *)0);
  p->NEXT = (struct charac *)((void *)0);
  *firstel = p;
  *lastel = p;
  printf((char const   * __restrict  )"\n");
  tmp___3 = _IO_getc(f);
  c = (char )tmp___3;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((int )c != -1)) {
      goto while_break___0;
    }
    {
    tmp___9 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___9 + (int )c) & 8192) {
      goto _L;
    } else { //Added block
    if ((int )c == 44) {
      _L: 
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if ((int )c == (int )CR) {
          line_num ++;
        }
        {
        tmp___4 = _IO_getc(f);
        c = (char )tmp___4;
        tmp___5 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___5 + (int )c) & 8192)) {
          if (! ((int )c == 44)) {
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      tmp___6 = malloc(sizeof(struct charac ));
      p = (struct charac *)tmp___6;
      }
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
        printf((char const   * __restrict  )"%s", ErrorMessages[22]);
        }
        return (22);
      }
      p->info = (char )' ';
      p->LINE_NUM = line_num;
      p->PREV = *lastel;
      p->NEXT = (struct charac *)((void *)0);
      (*lastel)->NEXT = p;
      *lastel = p;
    } else {
      {
      tmp___7 = malloc(sizeof(struct charac ));
      p = (struct charac *)tmp___7;
      }
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
        printf((char const   * __restrict  )"%s", ErrorMessages[22]);
        }
        return (22);
      }
      {
      p->info = c;
      p->LINE_NUM = line_num;
      p->PREV = *lastel;
      p->NEXT = (struct charac *)((void *)0);
      (*lastel)->NEXT = p;
      *lastel = p;
      tmp___8 = _IO_getc(f);
      c = (char )tmp___8;
      }
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  fclose(f);
  }
  return (0);
}
}
int recgrdef(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , double *qstep_ptr ,
             int *pqstep_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *pstep_ptr = (double )0;
  *qstep_ptr = (double )0;
  *pqstep_unit_ptr = 0;
  error = GetKeyword(Keywords[18], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = doubstep(*curr_ptr, curr_ptr, pstep_ptr, qstep_ptr, pqstep_unit_ptr);
  }
  if (error == 1) {
    *pstep_ptr = (double )0;
    *qstep_ptr = (double )0;
    *pqstep_unit_ptr = 0;
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    *pstep_ptr = (double )0;
    *qstep_ptr = (double )0;
    *pqstep_unit_ptr = 0;
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int recspec(struct charac *p1 , struct charac **pp2 , double *pdim_ptr , double *qdim_ptr ,
            int *pqdim_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[18], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[57], curr_ptr);
  error = 0;
  error = Get1Real(*curr_ptr, curr_ptr, pdim_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[58], curr_ptr);
  error = 0;
  error = Get1Real(*curr_ptr, curr_ptr, qdim_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    }
    return (17);
  }
  {
  error = lenunit(curr_ptr, pqdim_unit_ptr);
  }
  if (error != 0) {
    *pqdim_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int remdef(struct charac *p1 , struct charac **pp2 , struct AddRem **addrem_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  struct Node *no_ptr ;
  struct Node **node_ptr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
  curr_ptr = & curr;
  no_ptr = (struct Node *)((void *)0);
  node_ptr = & no_ptr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[80], curr_ptr);
  }
  if (error != 0) {
    *addrem_ptr = (struct AddRem *)((void *)0);
    return (1);
  }
  {
  error = nodedef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[58]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"remdef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 1;
    (*addrem_ptr)->BLOCK_TYPE = 0;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = blockdef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[59]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___0 = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp___0;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"remdef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 1;
    (*addrem_ptr)->BLOCK_TYPE = 1;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = polydef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[60]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___1 = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp___1;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"adddef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 1;
    (*addrem_ptr)->BLOCK_TYPE = 2;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = hexdef(*curr_ptr, curr_ptr, node_ptr);
  }
  if (error == 17) {
    {
    *addrem_ptr = (struct AddRem *)((void *)0);
    printf((char const   * __restrict  )"\n%s", ErrorMessages[61]);
    }
    return (17);
  }
  if (error == 0) {
    {
    tmp___2 = malloc(sizeof(struct AddRem ));
    *addrem_ptr = (struct AddRem *)tmp___2;
    }
    if ((unsigned long )*addrem_ptr == (unsigned long )((void *)0)) {
      {
      parserro(*curr_ptr, 55, (char *)" ");
      interror((char *)"adddef()");
      }
    }
    (*addrem_ptr)->ADDREM_TYPE = 1;
    (*addrem_ptr)->BLOCK_TYPE = 3;
    (*addrem_ptr)->NODE_PTR = *node_ptr;
    (*addrem_ptr)->NEXT = (struct AddRem *)((void *)0);
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  *addrem_ptr = (struct AddRem *)((void *)0);
  parserro(*curr_ptr, 63, (char *)" ");
  }
  return (17);
}
}
int secoramp(struct charac *p1 , struct charac **pp2 , double *centre_ptr , double *p1_et_ptr ,
             double *p2_et_ptr , double *q1_et_ptr , double *q2_et_ptr , int *amp_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[81], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[82], curr_ptr);
  error = 0;
  error = GetKeyword(Keywords[83], curr_ptr);
  error = 0;
  error = GetReal(centre_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[84], curr_ptr);
  error = 0;
  error = GetReal(p1_et_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[85], curr_ptr);
  error = 0;
  error = GetReal(p2_et_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[86], curr_ptr);
  error = 0;
  error = GetReal(q1_et_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[87], curr_ptr);
  error = 0;
  error = ampval(*curr_ptr, curr_ptr, q2_et_ptr, amp_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
double secorder(double a , double b , double c , double d , double e , double x ,
                double y ) 
{ 
  double z ;

  {
  z = ((((a * x) * x + (b * y) * y) + c * x) + d * y) + e;
  return (z);
}
}
int secorpha(struct charac *p1 , struct charac **pp2 , double *centre_ptr , double *p1_ep_ptr ,
             double *p2_ep_ptr , double *q1_ep_ptr , double *q2_ep_ptr , int *phase_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[81], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[82], curr_ptr);
  error = 0;
  error = GetKeyword(Keywords[83], curr_ptr);
  error = 0;
  error = GetReal(centre_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[89], curr_ptr);
  error = 0;
  error = GetReal(p1_ep_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[90], curr_ptr);
  error = 0;
  error = GetReal(p2_ep_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[91], curr_ptr);
  error = 0;
  error = GetReal(q1_ep_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[92], curr_ptr);
  error = 0;
  error = angval(*curr_ptr, curr_ptr, q2_ep_ptr, phase_unit_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 68, (char *)" ");
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
void seqrothg(double angle_start , double angle_step , double phase_start , double phase_step ,
              struct Geomnode *g ) 
{ 
  double cph ;
  double can ;
  struct Geomnode *g_app_ptr ;

  {
  cph = phase_start;
  can = angle_start;
  g_app_ptr = g;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )g_app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    (g_app_ptr->GEOMPORT_PTR)->PPA = cph;
    g_app_ptr->PHEA += can;
    cph += phase_step;
    can += angle_step;
    g_app_ptr = g_app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void seqrotrg(double angle_start , double angle_step , double phase_start , double phase_step ,
              struct Geomnode *g ) 
{ 
  struct Geomnode *pmin_ptr ;
  struct Geomnode *pmax_ptr ;
  struct Geomnode *qmin_ptr ;
  struct Geomnode *qmax_ptr ;
  int pmin ;
  int pmax ;
  int qmin ;
  int qmax ;
  int p ;
  int q ;
  int pcorr ;
  int qcorr ;
  int p1 ;
  int p2 ;
  int q1 ;
  int q2 ;
  int nodes_num ;
  int endvisit ;
  int cont ;
  double cph ;
  double can ;

  {
  {
  pqlimits(g, & pmin_ptr, & pmax_ptr, & qmin_ptr, & qmax_ptr);
  pmin = pmin_ptr->LOC_P;
  pmax = pmax_ptr->LOC_P;
  qmin = qmin_ptr->LOC_Q;
  qmax = qmax_ptr->LOC_Q;
  }
  if (pmin > pmax) {
    {
    interror((char *)"seqrotrg() -1- ");
    exit(1);
    }
  } else { //Added block
  if (qmin > qmax) {
    {
    interror((char *)"seqrotrg() -1- ");
    exit(1);
    }
  }
  }
  cph = phase_start;
  can = angle_start;
  nodes_num = ((pmax - pmin) + 1) * ((qmax - qmin) + 1);
  endvisit = 0;
  cont = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! endvisit)) {
      goto while_break;
    }
    if (pmin == pmax) {
      if (qmin == qmax) {
        {
        gnodevis(pmin, qmin, cph, can, g);
        cph += phase_step;
        can += angle_step;
        cont ++;
        }
        if (cont == nodes_num) {
          endvisit = 1;
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      p1 = pmin;
      p2 = pmax - 1;
      q = qmax;
      if (p2 >= p1) {
        pcorr = p1;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (pcorr <= p2) {
            if (! (! endvisit)) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
          {
          gnodevis(pcorr, q, cph, can, g);
          cph += phase_step;
          can += angle_step;
          cont ++;
          }
          if (cont == nodes_num) {
            endvisit = 1;
          }
          pcorr ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      q1 = qmax;
      q2 = qmin + 1;
      p = pmax;
      if (q1 >= q2) {
        qcorr = q1;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (qcorr >= q2) {
            if (! (! endvisit)) {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
          {
          gnodevis(p, qcorr, cph, can, g);
          cph += phase_step;
          can += angle_step;
          cont ++;
          }
          if (cont == nodes_num) {
            endvisit = 1;
          }
          qcorr --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      p1 = pmax;
      p2 = pmin + 1;
      q = qmin;
      if (p1 >= p2) {
        pcorr = p1;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (pcorr >= p2) {
            if (! (! endvisit)) {
              goto while_break___2;
            }
          } else {
            goto while_break___2;
          }
          {
          gnodevis(pcorr, q, cph, can, g);
          cph += phase_step;
          can += angle_step;
          cont ++;
          }
          if (cont == nodes_num) {
            endvisit = 1;
          }
          pcorr --;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      q1 = qmin;
      q2 = qmax - 1;
      p = pmin;
      if (q2 >= q1) {
        qcorr = q1;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (qcorr <= q2) {
            if (! (! endvisit)) {
              goto while_break___3;
            }
          } else {
            goto while_break___3;
          }
          {
          gnodevis(p, qcorr, cph, can, g);
          cph += phase_step;
          can += angle_step;
          cont ++;
          }
          if (cont == nodes_num) {
            endvisit = 1;
          }
          qcorr ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    pmin ++;
    pmax --;
    qmin ++;
    qmax --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int serotdir(struct charac *p1 , struct charac **pp2 , int *direction_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[93], curr_ptr);
  }
  if (error == 0) {
    *direction_ptr = 0;
    *pp2 = *curr_ptr;
    return (0);
  }
  {
  error = GetKeyword(Keywords[94], curr_ptr);
  }
  if (error == 0) {
    *direction_ptr = 1;
    *pp2 = *curr_ptr;
    return (0);
  }
  return (1);
}
}
int serotpar(struct charac *p1 , struct charac **pp2 , double *angle_start_ptr , double *angle_step_ptr ,
             int *omit_phase_ptr , double *phase_start_ptr , double *phase_step_ptr ,
             int *angle_unit_ptr , int *phase_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *omit_phase_ptr = 0;
  error = anglerot(*curr_ptr, curr_ptr, angle_start_ptr, angle_step_ptr, angle_unit_ptr);
  }
  if (error == 17) {
    return (17);
  }
  if (error == 1) {
    *omit_phase_ptr = 1;
    return (1);
  }
  {
  *omit_phase_ptr = 0;
  error = phaserot(*curr_ptr, curr_ptr, phase_start_ptr, phase_step_ptr, phase_unit_ptr);
  }
  if (error == 17) {
    return (17);
  }
  if (error == 1) {
    *omit_phase_ptr = 1;
    *pp2 = *curr_ptr;
    return (0);
  }
  *omit_phase_ptr = 0;
  *pp2 = *curr_ptr;
  return (0);
}
}
int serotpha(struct charac *p1 , struct charac **pp2 , int *direction_ptr , int *omit_angle_ptr ,
             double *angle_start_ptr , double *angle_step_ptr , int *omit_phase_ptr ,
             double *phase_start_ptr , double *phase_step_ptr , int *angle_unit_ptr ,
             int *phase_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *omit_angle_ptr = 0;
  *omit_phase_ptr = 0;
  error = GetKeyword(Keywords[99], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetKeyword(Keywords[100], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 1, Keywords[100]);
    }
    return (17);
  }
  {
  error = serotdir(*curr_ptr, curr_ptr, direction_ptr);
  }
  if (error == 1) {
    *direction_ptr = 0;
  }
  {
  error = serotpar(*curr_ptr, curr_ptr, angle_start_ptr, angle_step_ptr, omit_phase_ptr,
                   phase_start_ptr, phase_step_ptr, angle_unit_ptr, phase_unit_ptr);
  }
  if (error == 17) {
    return (17);
  }
  if (error == 1) {
    *omit_angle_ptr = 1;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int sgramp2n(struct GrAmpExc *grampexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ,
             int group_shape ) 
{ 
  struct Geomport *primo_ptr ;
  struct Geomport *app_ptr ;
  struct Geomport *ultimo_ptr ;
  struct Geomnode *geomnode_app_ptr ;
  struct Geomnode *pmin_tp ;
  struct Geomnode **pmin_ptr ;
  struct Geomnode *pmax_tp ;
  struct Geomnode **pmax_ptr ;
  struct Geomnode *qmin_tp ;
  struct Geomnode **qmin_ptr ;
  struct Geomnode *qmax_tp ;
  struct Geomnode **qmax_ptr ;
  struct Port *port_app_ptr ;
  double centre ;
  double p1_et ;
  double p2_et ;
  double q1_et ;
  double q2_et ;
  double a ;
  double b ;
  double c ;
  double d ;
  double e ;
  double x1 ;
  double y1___0 ;
  double A ;
  double B ;
  double C ;
  double D ;
  double E ;
  double amp_val ;
  double p1x ;
  double p1y ;
  double p2x ;
  double p2y ;
  double q1x ;
  double q1y ;
  double q2x ;
  double q2y ;
  double cex ;
  double cey ;
  double Hx[8] ;
  double Hy[8] ;
  int i ;
  void *tmp ;

  {
  primo_ptr = (struct Geomport *)((void *)0);
  app_ptr = (struct Geomport *)((void *)0);
  ultimo_ptr = (struct Geomport *)((void *)0);
  geomnode_app_ptr = (struct Geomnode *)((void *)0);
  pmin_tp = (struct Geomnode *)((void *)0);
  pmin_ptr = & pmin_tp;
  pmax_tp = (struct Geomnode *)((void *)0);
  pmax_ptr = & pmax_tp;
  qmin_tp = (struct Geomnode *)((void *)0);
  qmin_ptr = & qmin_tp;
  qmax_tp = (struct Geomnode *)((void *)0);
  qmax_ptr = & qmax_tp;
  port_app_ptr = (struct Port *)((void *)0);
  centre = grampexc_ptr->CENTRE;
  p1_et = grampexc_ptr->P1_ET;
  p2_et = grampexc_ptr->P2_ET;
  q1_et = grampexc_ptr->Q1_ET;
  q2_et = grampexc_ptr->Q2_ET;
  if (group_shape == 3) {
    {
    pqlimits(geomnode_ptr, pmin_ptr, pmax_ptr, qmin_ptr, qmax_ptr);
    p1x = (*pmin_ptr)->XA;
    p2x = (*pmax_ptr)->XA;
    q1y = (*qmin_ptr)->YA;
    q2y = (*qmax_ptr)->YA;
    p1y = (q1y + q2y) / (double )2;
    p2y = p1y;
    q1x = (p1x + p2x) / (double )2;
    q2x = q1x;
    cex = q1x;
    cey = p1y;
    }
  } else { //Added block
  if (group_shape == 2) {
    geomnode_app_ptr = geomnode_ptr;
    i = 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i <= 7)) {
        goto while_break;
      }
      if (geomnode_app_ptr) {
        Hx[i] = geomnode_app_ptr->XA;
        Hy[i] = geomnode_app_ptr->YA;
        geomnode_app_ptr = geomnode_app_ptr->NEXT;
      } else {
        {
        printf((char const   * __restrict  )"NULL POINTER!\n");
        exit(1);
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    p1x = Hx[5];
    p1y = Hy[5];
    p2x = Hx[2];
    p2y = Hy[2];
    q1x = (Hx[6] + Hx[7]) / (double )2;
    q1y = Hy[6];
    q2x = (Hx[4] + Hx[3]) / (double )2;
    q2y = Hy[4];
    cex = Hx[1];
    cey = Hy[1];
  } else {
    {
    printf((char const   * __restrict  )"\n%s", MOSErrors[5]);
    }
    return (5);
  }
  }
  x1 = p2x - cex;
  y1___0 = q2y - cey;
  e = centre;
  if (x1 == (double )0) {
    c = (double )0;
    a = c;
  } else {
    a = ((p1_et + p2_et) - (double )2 * e) / (((double )2 * x1) * x1);
    c = (((a * x1) * x1 + e) - p1_et) / x1;
  }
  if (y1___0 == (double )0) {
    d = (double )0;
    b = d;
  } else {
    b = ((q1_et + q2_et) - (double )2 * e) / (((double )2 * y1___0) * y1___0);
    d = (((b * y1___0) * y1___0 + e) - q1_et) / y1___0;
  }
  A = a;
  B = b;
  C = c - ((double )2 * a) * cex;
  D = d - ((double )2 * b) * cey;
  E = ((((a * cex) * cex + (b * cey) * cey) - c * cex) - d * cey) + e;
  geomnode_app_ptr = geomnode_ptr;
  port_app_ptr = port_ptr;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )geomnode_app_ptr != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    amp_val = secorder(A, B, C, D, E, geomnode_app_ptr->XA, geomnode_app_ptr->YA);
    app_ptr = (struct Geomport *)((void *)0);
    ultimo_ptr = app_ptr;
    primo_ptr = ultimo_ptr;
    port_app_ptr = port_ptr;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned long )port_app_ptr != (unsigned long )((void *)0))) {
        goto while_break___1;
      }
      {
      tmp = malloc(sizeof(struct Geomport ));
      app_ptr = (struct Geomport *)tmp;
      }
      if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
        {
        printf((char const   * __restrict  )"%s", ErrorMessages[55]);
        interror((char *)"sgramp2n()");
        }
      }
      app_ptr->AMP = amp_val * port_app_ptr->AMP;
      if ((unsigned long )primo_ptr == (unsigned long )((void *)0)) {
        primo_ptr = app_ptr;
      } else {
        ultimo_ptr->NEXT = app_ptr;
      }
      ultimo_ptr = app_ptr;
      ultimo_ptr->NEXT = (struct Geomport *)((void *)0);
      port_app_ptr = port_app_ptr->NEXT;
    }
    while_break___1: /* CIL Label */ ;
    }
    geomnode_app_ptr->GEOMPORT_PTR = primo_ptr;
    geomnode_app_ptr = geomnode_app_ptr->NEXT;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (0);
}
}
int sgrampun(struct GrAmpExc *grampexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ) 
{ 
  struct Geomport *primo_ptr ;
  struct Geomport *app_ptr ;
  struct Geomport *ultimo_ptr ;
  struct Geomnode *geomnode_app_ptr ;
  struct Port *port_app_ptr ;
  double unif_val ;
  void *tmp ;

  {
  primo_ptr = (struct Geomport *)((void *)0);
  app_ptr = (struct Geomport *)((void *)0);
  ultimo_ptr = (struct Geomport *)((void *)0);
  geomnode_app_ptr = (struct Geomnode *)((void *)0);
  port_app_ptr = (struct Port *)((void *)0);
  unif_val = grampexc_ptr->UNIF_VAL;
  geomnode_app_ptr = geomnode_ptr;
  port_app_ptr = port_ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )geomnode_app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    app_ptr = (struct Geomport *)((void *)0);
    ultimo_ptr = app_ptr;
    primo_ptr = ultimo_ptr;
    port_app_ptr = port_ptr;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )port_app_ptr != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      tmp = malloc(sizeof(struct Geomport ));
      app_ptr = (struct Geomport *)tmp;
      }
      if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
        {
        printf((char const   * __restrict  )"%s", ErrorMessages[55]);
        interror((char *)"sgrampun()");
        }
      }
      app_ptr->AMP = unif_val * port_app_ptr->AMP;
      if ((unsigned long )primo_ptr == (unsigned long )((void *)0)) {
        primo_ptr = app_ptr;
      } else {
        ultimo_ptr->NEXT = app_ptr;
      }
      ultimo_ptr = app_ptr;
      ultimo_ptr->NEXT = (struct Geomport *)((void *)0);
      port_app_ptr = port_app_ptr->NEXT;
    }
    while_break___0: /* CIL Label */ ;
    }
    geomnode_app_ptr->GEOMPORT_PTR = primo_ptr;
    geomnode_app_ptr = geomnode_app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int sgrpha2n(struct GrPhaExc *grphaexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ,
             int group_shape ) 
{ 
  struct Geomport *geomport_app_ptr ;
  struct Geomnode *geomnode_app_ptr ;
  struct Port *port_app_ptr ;
  struct Geomnode *pmin_tp ;
  struct Geomnode **pmin_ptr ;
  struct Geomnode *pmax_tp ;
  struct Geomnode **pmax_ptr ;
  struct Geomnode *qmin_tp ;
  struct Geomnode **qmin_ptr ;
  struct Geomnode *qmax_tp ;
  struct Geomnode **qmax_ptr ;
  double centre ;
  double p1_ep ;
  double p2_ep ;
  double q1_ep ;
  double q2_ep ;
  double a ;
  double b ;
  double c ;
  double d ;
  double e ;
  double x1 ;
  double y1___0 ;
  double A ;
  double B ;
  double C ;
  double D ;
  double E ;
  double phase_val ;
  double p1x ;
  double p1y ;
  double p2x ;
  double p2y ;
  double q1x ;
  double q1y ;
  double q2x ;
  double q2y ;
  double cex ;
  double cey ;
  double Hx[8] ;
  double Hy[8] ;
  int i ;

  {
  geomport_app_ptr = (struct Geomport *)((void *)0);
  geomnode_app_ptr = (struct Geomnode *)((void *)0);
  port_app_ptr = (struct Port *)((void *)0);
  pmin_tp = (struct Geomnode *)((void *)0);
  pmin_ptr = & pmin_tp;
  pmax_tp = (struct Geomnode *)((void *)0);
  pmax_ptr = & pmax_tp;
  qmin_tp = (struct Geomnode *)((void *)0);
  qmin_ptr = & qmin_tp;
  qmax_tp = (struct Geomnode *)((void *)0);
  qmax_ptr = & qmax_tp;
  centre = grphaexc_ptr->CENTRE;
  p1_ep = grphaexc_ptr->P1_EP;
  p2_ep = grphaexc_ptr->P2_EP;
  q1_ep = grphaexc_ptr->Q1_EP;
  q2_ep = grphaexc_ptr->Q2_EP;
  if (group_shape == 3) {
    {
    pqlimits(geomnode_ptr, pmin_ptr, pmax_ptr, qmin_ptr, qmax_ptr);
    p1x = (*pmin_ptr)->XA;
    p2x = (*pmax_ptr)->XA;
    q1y = (*qmin_ptr)->YA;
    q2y = (*qmax_ptr)->YA;
    p1y = (q1y + q2y) / (double )2;
    p2y = p1y;
    q1x = (p1x + p2x) / (double )2;
    q2x = q1x;
    cex = q1x;
    cey = p1y;
    }
  } else { //Added block
  if (group_shape == 2) {
    geomnode_app_ptr = geomnode_ptr;
    i = 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i <= 7)) {
        goto while_break;
      }
      if (geomnode_app_ptr) {
        Hx[i] = geomnode_app_ptr->XA;
        Hy[i] = geomnode_app_ptr->YA;
        geomnode_app_ptr = geomnode_app_ptr->NEXT;
      } else {
        {
        printf((char const   * __restrict  )"NULL POINTER!\n");
        exit(1);
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    p1x = Hx[5];
    p1y = Hy[5];
    p2x = Hx[2];
    p2y = Hy[2];
    q1x = (Hx[6] + Hx[7]) / (double )2;
    q1y = Hy[6];
    q2x = (Hx[4] + Hx[3]) / (double )2;
    q2y = Hy[4];
    cex = Hx[1];
    cey = Hy[1];
  } else {
    {
    printf((char const   * __restrict  )"\n%s", MOSErrors[5]);
    }
    return (5);
  }
  }
  x1 = p2x - cex;
  y1___0 = q2y - cey;
  e = centre;
  if (x1 == (double )0) {
    c = (double )0;
    a = c;
  } else {
    a = ((p1_ep + p2_ep) - (double )2 * e) / (((double )2 * x1) * x1);
    c = (((a * x1) * x1 + e) - p1_ep) / x1;
  }
  if (y1___0 == (double )0) {
    d = (double )0;
    b = d;
  } else {
    b = ((q1_ep + q2_ep) - (double )2 * e) / (((double )2 * y1___0) * y1___0);
    d = (((b * y1___0) * y1___0 + e) - q1_ep) / y1___0;
  }
  A = a;
  B = b;
  C = c - ((double )2 * a) * cex;
  D = d - ((double )2 * b) * cey;
  E = ((((a * cex) * cex + (b * cey) * cey) - c * cex) - d * cey) + e;
  geomnode_app_ptr = geomnode_ptr;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )geomnode_app_ptr != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    phase_val = secorder(A, B, C, D, E, geomnode_app_ptr->XA, geomnode_app_ptr->YA);
    geomport_app_ptr = geomnode_app_ptr->GEOMPORT_PTR;
    port_app_ptr = port_ptr;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned long )port_app_ptr != (unsigned long )((void *)0))) {
        goto while_break___1;
      }
      geomport_app_ptr->PSH = phase_val + port_app_ptr->PSH;
      geomport_app_ptr->PSC = port_app_ptr->PSC;
      geomport_app_ptr->PPA = port_app_ptr->PPA;
      port_app_ptr = port_app_ptr->NEXT;
      geomport_app_ptr = geomport_app_ptr->NEXT;
    }
    while_break___1: /* CIL Label */ ;
    }
    geomnode_app_ptr = geomnode_app_ptr->NEXT;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (0);
}
}
int sgrphasr(struct Group *group_ptr ) 
{ 
  struct Geomnode *geomnode_app_ptr ;
  double angle_start ;
  double angle_step ;
  double phase_start ;
  double phase_step ;
  double sign ;

  {
  geomnode_app_ptr = (struct Geomnode *)((void *)0);
  if ((group_ptr->ELEM_PTR)->NPORTS > 1) {
    {
    printf((char const   * __restrict  )"\n%s", MOSErrors[10]);
    }
    return (10);
  }
  if (group_ptr->SHAPE == 5) {
    {
    printf((char const   * __restrict  )"\n%s", MOSErrors[11]);
    }
    return (11);
  }
  if ((group_ptr->GRPHAEXC_PTR)->DIRECTION == 1) {
    sign = (double )1;
  } else {
    sign = (double )-1;
  }
  if ((group_ptr->GRPHAEXC_PTR)->OMIT_ANGLE == 1) {
    if ((group_ptr->GRPHAEXC_PTR)->OMIT_PHASE == 1) {
      if (group_ptr->NUM_OF_NODES <= 2) {
        phase_start = (double )0;
        angle_start = phase_start;
        phase_step = sign * (double )90;
        angle_step = phase_step;
      } else {
        phase_start = (double )0;
        angle_start = phase_start;
        phase_step = (sign * (double )360) / (double )group_ptr->NUM_OF_NODES;
        angle_step = phase_step;
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((group_ptr->GRPHAEXC_PTR)->OMIT_PHASE == 1) {
    angle_start = (group_ptr->GRPHAEXC_PTR)->ANGLE_START;
    angle_step = (group_ptr->GRPHAEXC_PTR)->ANGLE_STEP;
    phase_start = angle_start;
    phase_step = angle_step;
  } else {
    angle_start = (group_ptr->GRPHAEXC_PTR)->ANGLE_START;
    angle_step = (group_ptr->GRPHAEXC_PTR)->ANGLE_STEP;
    phase_start = (group_ptr->GRPHAEXC_PTR)->PHASE_START;
    phase_step = (group_ptr->GRPHAEXC_PTR)->PHASE_STEP;
  }
  }
  if (group_ptr->SHAPE == 3) {
    {
    seqrotrg(angle_start, angle_step, phase_start, phase_step, group_ptr->GEOMNODE_PTR);
    }
  } else { //Added block
  if (group_ptr->SHAPE == 2) {
    {
    seqrothg(angle_start, angle_step, phase_start, phase_step, group_ptr->GEOMNODE_PTR);
    }
  }
  }
  geomnode_app_ptr = group_ptr->GEOMNODE_PTR;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )geomnode_app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    (geomnode_app_ptr->GEOMPORT_PTR)->PSH = ((group_ptr->ELEM_PTR)->PORT_PTR)->PSH;
    (geomnode_app_ptr->GEOMPORT_PTR)->PSC = ((group_ptr->ELEM_PTR)->PORT_PTR)->PSC;
    (geomnode_app_ptr->GEOMPORT_PTR)->PPA += ((group_ptr->ELEM_PTR)->PORT_PTR)->PPA;
    geomnode_app_ptr = geomnode_app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int sgrphaun(struct GrPhaExc *grphaexc_ptr , struct Geomnode *geomnode_ptr , struct Port *port_ptr ) 
{ 
  struct Geomport *geomport_app_ptr ;
  struct Geomnode *geomnode_app_ptr ;
  struct Port *port_app_ptr ;
  double unif_val ;

  {
  geomport_app_ptr = (struct Geomport *)((void *)0);
  geomnode_app_ptr = (struct Geomnode *)((void *)0);
  port_app_ptr = (struct Port *)((void *)0);
  unif_val = grphaexc_ptr->UNIF_VAL;
  geomnode_app_ptr = geomnode_ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )geomnode_app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    geomport_app_ptr = geomnode_app_ptr->GEOMPORT_PTR;
    port_app_ptr = port_ptr;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )port_app_ptr != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      geomport_app_ptr->PSH = unif_val + port_app_ptr->PSH;
      geomport_app_ptr->PSC = port_app_ptr->PSC;
      geomport_app_ptr->PPA = port_app_ptr->PPA;
      port_app_ptr = port_app_ptr->NEXT;
      geomport_app_ptr = geomport_app_ptr->NEXT;
    }
    while_break___0: /* CIL Label */ ;
    }
    geomnode_app_ptr = geomnode_app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int sgrrot(struct Geomnode *start_ptr , double XC , double YC , double phi ) 
{ 
  struct Geomnode *app_ptr ;
  double XD ;
  double YD ;
  double XE ;
  double YE ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  app_ptr = start_ptr;
  if ((unsigned long )app_ptr == (unsigned long )((void *)0)) {
    {
    interror((char *)"sgrrot - 1 ");
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    XD = app_ptr->XA;
    YD = app_ptr->YA;
    tmp = dcos(phi);
    tmp___0 = dsin(phi);
    XE = ((XD - XC) * tmp - (YD - YC) * tmp___0) + XC;
    tmp___1 = dsin(phi);
    tmp___2 = dcos(phi);
    YE = ((XD - XC) * tmp___1 + (YD - YC) * tmp___2) + YC;
    app_ptr->XA = XE;
    app_ptr->YA = YE;
    app_ptr->PHEA += phi;
    app_ptr = app_ptr->NEXT;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int simamp(struct Group *group_ptr ) 
{ 
  int error ;

  {
  {
  error = 0;
  fixgramp(group_ptr->GRAMPEXC_PTR);
  }
  {
  if ((group_ptr->GRAMPEXC_PTR)->TYPE == 0) {
    goto case_0;
  }
  if ((group_ptr->GRAMPEXC_PTR)->TYPE == 1) {
    goto case_1;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  error = sgrampun(group_ptr->GRAMPEXC_PTR, group_ptr->GEOMNODE_PTR, (group_ptr->ELEM_PTR)->PORT_PTR);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  error = sgramp2n(group_ptr->GRAMPEXC_PTR, group_ptr->GEOMNODE_PTR, (group_ptr->ELEM_PTR)->PORT_PTR,
                   group_ptr->SHAPE);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (error != 0) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[6], group_ptr->NAME);
    }
    return (6);
  } else {
    return (0);
  }
}
}
int simgroup(struct Group *group_ptr ) 
{ 
  int error ;

  {
  {
  error = 0;
  fixsgrel(group_ptr);
  error = addscan(group_ptr);
  }
  if (error != 0) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[8], group_ptr->NAME);
    }
    return (8);
  } else {
    return (0);
  }
}
}
int simpha(struct Group *group_ptr ) 
{ 
  int error ;

  {
  {
  error = 0;
  fixgrpha(group_ptr->GRPHAEXC_PTR);
  }
  {
  if ((group_ptr->GRPHAEXC_PTR)->TYPE == 0) {
    goto case_0;
  }
  if ((group_ptr->GRPHAEXC_PTR)->TYPE == 1) {
    goto case_1;
  }
  if ((group_ptr->GRPHAEXC_PTR)->TYPE == 3) {
    goto case_3;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  error = sgrphaun(group_ptr->GRPHAEXC_PTR, group_ptr->GEOMNODE_PTR, (group_ptr->ELEM_PTR)->PORT_PTR);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  error = sgrpha2n(group_ptr->GRPHAEXC_PTR, group_ptr->GEOMNODE_PTR, (group_ptr->ELEM_PTR)->PORT_PTR,
                   group_ptr->SHAPE);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  error = sgrphasr(group_ptr);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (error != 0) {
    {
    printf((char const   * __restrict  )"\n%s%s", MOSErrors[9], group_ptr->NAME);
    }
    return (9);
  } else {
    return (0);
  }
}
}
int simpol(struct Group *group_ptr ) 
{ 
  struct Geomport *geomport_app_ptr ;
  struct Geomnode *geomnode_app_ptr ;
  struct Port *port_app_ptr ;

  {
  geomnode_app_ptr = group_ptr->GEOMNODE_PTR;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )geomnode_app_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    geomport_app_ptr = geomnode_app_ptr->GEOMPORT_PTR;
    port_app_ptr = (group_ptr->ELEM_PTR)->PORT_PTR;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )port_app_ptr != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      geomport_app_ptr->PHEPOL = port_app_ptr->PHEPOL;
      port_app_ptr = port_app_ptr->NEXT;
      geomport_app_ptr = geomport_app_ptr->NEXT;
    }
    while_break___0: /* CIL Label */ ;
    }
    geomnode_app_ptr = geomnode_app_ptr->NEXT;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int sinelem(struct charac *p1 , struct charac **pp2 , struct Elem **elem_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;
  int geometry ;
  int *geometry_ptr ;
  double radius ;
  double *radius_ptr ;
  int radius_unit ;
  int *radius_unit_ptr ;
  double pdim ;
  double *pdim_ptr ;
  double qdim ;
  double *qdim_ptr ;
  int pqdim_unit ;
  int *pqdim_unit_ptr ;
  int model ;
  int *model_ptr ;
  double exp___0 ;
  double *exp_ptr ;
  double anglee ;
  double *anglee_ptr ;
  double angleh ;
  double *angleh_ptr ;
  int angle_unit ;
  int *angle_unit_ptr ;
  double tapere ;
  double *tapere_ptr ;
  double taperh ;
  double *taperh_ptr ;
  int taper_unit ;
  int *taper_unit_ptr ;
  int polarization ;
  int *polarization_ptr ;
  double phepol ;
  double *phepol_ptr ;
  int phepol_unit ;
  int *phepol_unit_ptr ;
  int direction ;
  int *direction_ptr ;
  double gain ;
  double *gain_ptr ;
  int gain_unit ;
  int *gain_unit_ptr ;
  int nports ;
  int *nports_ptr ;
  struct Port *p_ptr ;
  struct Port **port_ptr ;

  {
  {
  curr_ptr = & curr;
  geometry_ptr = & geometry;
  radius_ptr = & radius;
  radius_unit_ptr = & radius_unit;
  pdim_ptr = & pdim;
  qdim_ptr = & qdim;
  pqdim_unit_ptr = & pqdim_unit;
  model_ptr = & model;
  exp_ptr = & exp___0;
  anglee_ptr = & anglee;
  angleh_ptr = & angleh;
  angle_unit_ptr = & angle_unit;
  tapere_ptr = & tapere;
  taperh_ptr = & taperh;
  taper_unit_ptr = & taper_unit;
  polarization_ptr = & polarization;
  phepol_ptr = & phepol;
  phepol_unit_ptr = & phepol_unit;
  direction_ptr = & direction;
  gain_ptr = & gain;
  gain_unit_ptr = & gain_unit;
  nports_ptr = & nports;
  port_ptr = & p_ptr;
  *curr_ptr = p1;
  error = 0;
  error = geomspec(*curr_ptr, curr_ptr, geometry_ptr, radius_ptr, radius_unit_ptr,
                   pdim_ptr, qdim_ptr, pqdim_unit_ptr);
  }
  if (error == 1) {
    return (1);
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[34]);
    }
    return (17);
  }
  *model_ptr = 0;
  if (error == 0) {
    {
    error = polspec(*curr_ptr, curr_ptr, polarization_ptr, phepol_ptr, phepol_unit_ptr,
                    direction_ptr);
    }
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[36]);
    }
    return (17);
  }
  if (error == 1) {
    *polarization_ptr = 0;
    *phepol_ptr = (double )90;
    *phepol_unit_ptr = 0;
    *direction_ptr = 0;
    error = 0;
  }
  *gain_ptr = (double )0;
  *gain_unit_ptr = 0;
  if (error == 0) {
    {
    error = portspec(*curr_ptr, curr_ptr, nports_ptr, port_ptr);
    }
  }
  if (error == 17) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[49]);
    }
    return (17);
  }
  if (error == 1) {
    *nports_ptr = 0;
    *port_ptr = (struct Port *)((void *)0);
    error = 0;
  }
  {
  (*elem_ptr)->TYPE = 0;
  strcpy((char * __restrict  )((*elem_ptr)->NAME), (char const   * __restrict  )"");
  (*elem_ptr)->GEOMETRY = geometry;
  (*elem_ptr)->RADIUS = radius;
  (*elem_ptr)->RADIUS_UNIT = radius_unit;
  (*elem_ptr)->PDIM = pdim;
  (*elem_ptr)->QDIM = qdim;
  (*elem_ptr)->PQDIM_UNIT = pqdim_unit;
  (*elem_ptr)->MODEL = model;
  (*elem_ptr)->EXP = exp___0;
  (*elem_ptr)->ANGLEE = anglee;
  (*elem_ptr)->ANGLEH = angleh;
  (*elem_ptr)->ANGLE_UNIT = angle_unit;
  (*elem_ptr)->TAPERE = tapere;
  (*elem_ptr)->TAPERH = taperh;
  (*elem_ptr)->TAPER_UNIT = taper_unit;
  (*elem_ptr)->POLARIZATION = polarization;
  (*elem_ptr)->PHEPOL = phepol;
  (*elem_ptr)->PHEPOL_UNIT = phepol_unit;
  (*elem_ptr)->DIRECTION = direction;
  (*elem_ptr)->GAIN = gain;
  (*elem_ptr)->GAIN_UNIT = gain_unit;
  (*elem_ptr)->NPORTS = nports;
  (*elem_ptr)->PORT_PTR = *port_ptr;
  *pp2 = *curr_ptr;
  }
  return (0);
}
}
int sinstep(struct charac *p1 , struct charac **pp2 , double *step_ptr , int *step_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *step_ptr = (double )0;
  *step_unit_ptr = 0;
  error = GetKeyword(Keywords[16], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetUReal(*curr_ptr, curr_ptr, step_ptr);
  }
  if (error != 0) {
    *step_ptr = (double )0;
    return (error);
  }
  {
  error = lenunit(curr_ptr, step_unit_ptr);
  }
  if (error != 0) {
    *step_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int squgrdef(struct charac *p1 , struct charac **pp2 , double *pstep_ptr , int *pstep_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *pstep_ptr = (double )0;
  *pstep_unit_ptr = 0;
  error = GetKeyword(Keywords[17], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = sinstep(*curr_ptr, curr_ptr, pstep_ptr, pstep_unit_ptr);
  }
  if (error == 1) {
    *pstep_ptr = (double )0;
    *pstep_unit_ptr = 0;
    *pp2 = *curr_ptr;
    return (0);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    *pstep_ptr = (double )0;
    *pstep_unit_ptr = 0;
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
char TapeGet(struct charac **tp ) 
{ 
  char ch ;

  {
  if ((unsigned long )*tp == (unsigned long )((void *)0)) {
    ch = (char )'\000';
  } else {
    ch = (*tp)->info;
    *tp = (*tp)->NEXT;
  }
  return (ch);
}
}
int trigrdef(struct charac *p1 , struct charac **pp2 , double *angle_ptr , int *angle_unit_ptr ,
             double *pstep_ptr , double *qstep_ptr , int *pqstep_unit_ptr , double *px_ptr ,
             double *py_ptr , double *qx_ptr , double *qy_ptr , int *pqxy_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *angle_ptr = (double )0;
  *angle_unit_ptr = 0;
  *pstep_ptr = (double )0;
  *qstep_ptr = (double )0;
  *pqstep_unit_ptr = 0;
  *px_ptr = (double )0;
  *py_ptr = (double )0;
  *qx_ptr = (double )0;
  *qy_ptr = (double )0;
  *pqxy_unit_ptr = 0;
  error = GetKeyword(Keywords[21], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = angstep(*curr_ptr, curr_ptr, angle_ptr, angle_unit_ptr, pstep_ptr, qstep_ptr,
                  pqstep_unit_ptr);
  }
  if (error == 17) {
    {
    *angle_ptr = (double )0;
    *angle_unit_ptr = 0;
    *pstep_ptr = (double )0;
    *qstep_ptr = (double )0;
    *pqstep_unit_ptr = 0;
    parserro(*curr_ptr, 94, (char *)" ");
    }
    return (17);
  }
  if (error != 0) {
    {
    error = versdef(*curr_ptr, curr_ptr, px_ptr, py_ptr, qx_ptr, qy_ptr, pqxy_unit_ptr);
    }
    if (error != 1) {
      if (error != 0) {
        {
        parserro(*curr_ptr, error, (char *)" ");
        *px_ptr = (double )0;
        *py_ptr = (double )0;
        *qx_ptr = (double )0;
        *qy_ptr = (double )0;
        *pqxy_unit_ptr = 0;
        }
        return (17);
      }
    }
    if (error == 1) {
      *angle_ptr = (double )0;
      *angle_unit_ptr = 0;
      *pstep_ptr = (double )0;
      *qstep_ptr = (double )0;
      *pqstep_unit_ptr = 0;
      *px_ptr = (double )0;
      *py_ptr = (double )0;
      *qx_ptr = (double )0;
      *qy_ptr = (double )0;
      *pqxy_unit_ptr = 0;
    }
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
void unaminit(void) 
{ 
  char i ;

  {
  i = (char)0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )i <= 20)) {
      goto while_break;
    }
    {
    strcpy((char * __restrict  )(UserNames[i]), (char const   * __restrict  )"");
    i = (char )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int unifamp(struct charac *p1 , struct charac **pp2 , double *unif_val_ptr , int *amp_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[88], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = ampval(*curr_ptr, curr_ptr, unif_val_ptr, amp_unit_ptr);
  }
  if (error != 0) {
    *unif_val_ptr = (double )0;
    *amp_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int unifpha(struct charac *p1 , struct charac **pp2 , double *unif_val_ptr , int *phase_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[88], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = angval(*curr_ptr, curr_ptr, unif_val_ptr, phase_unit_ptr);
  }
  if (error != 0) {
    *unif_val_ptr = (double )0;
    *phase_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int uvdir(struct charac *p1 , struct charac **pp2 , double *u_ptr , double *v_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[97], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = uvval(*curr_ptr, curr_ptr, u_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 71, (char *)" ");
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[98], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, 1, Keywords[98]);
    }
    return (17);
  }
  {
  error = uvval(*curr_ptr, curr_ptr, v_ptr);
  }
  if (error != 0) {
    {
    printf((char const   * __restrict  )"\n%s", ErrorMessages[71]);
    }
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int uvval(struct charac *p1 , struct charac **pp2 , double *val_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = GetReal(val_ptr, curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  if (*val_ptr < (double )-1) {
    {
    parserro(*curr_ptr, 72, (char *)" ");
    }
    return (17);
  } else { //Added block
  if (*val_ptr > (double )1) {
    {
    parserro(*curr_ptr, 72, (char *)" ");
    }
    return (17);
  }
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
int versdef(struct charac *p1 , struct charac **pp2 , double *px_ptr , double *py_ptr ,
            double *qx_ptr , double *qy_ptr , int *pqxy_unit_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  *px_ptr = (double )0;
  *py_ptr = (double )0;
  *qx_ptr = (double )0;
  *qy_ptr = (double )0;
  *pqxy_unit_ptr = 0;
  error = GetKeyword(Keywords[53], curr_ptr);
  }
  if (error != 0) {
    return (1);
  }
  {
  error = GetReal(px_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    *px_ptr = (double )0;
    *py_ptr = (double )0;
    *qx_ptr = (double )0;
    *qy_ptr = (double )0;
    *pqxy_unit_ptr = 0;
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[54], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, Keywords[54]);
    }
    return (17);
  }
  {
  error = GetReal(py_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    *px_ptr = (double )0;
    *py_ptr = (double )0;
    *qx_ptr = (double )0;
    *qy_ptr = (double )0;
    *pqxy_unit_ptr = 0;
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[55], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, Keywords[55]);
    }
    return (17);
  }
  {
  error = GetReal(qx_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    *px_ptr = (double )0;
    *py_ptr = (double )0;
    *qx_ptr = (double )0;
    *qy_ptr = (double )0;
    *pqxy_unit_ptr = 0;
    }
    return (17);
  }
  {
  error = GetKeyword(Keywords[56], curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, Keywords[56]);
    }
    return (17);
  }
  {
  error = GetReal(qy_ptr, curr_ptr);
  }
  if (error != 0) {
    {
    parserro(*curr_ptr, error, (char *)" ");
    *px_ptr = (double )0;
    *py_ptr = (double )0;
    *qx_ptr = (double )0;
    *qy_ptr = (double )0;
    *pqxy_unit_ptr = 0;
    }
    return (17);
  }
  {
  error = lenunit(curr_ptr, pqxy_unit_ptr);
  }
  if (error != 0) {
    *pqxy_unit_ptr = 0;
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
void waitcont(void) 
{ 


  {
  return;
}
}
int xycoord(struct charac *p1 , struct charac **pp2 , double *xcoord_ptr , double *ycoord_ptr ) 
{ 
  struct charac *curr ;
  struct charac **curr_ptr ;
  int error ;

  {
  {
  curr_ptr = & curr;
  *curr_ptr = p1;
  error = 0;
  error = GetKeyword(Keywords[12], curr_ptr);
  error = 0;
  error = GetReal(xcoord_ptr, curr_ptr);
  }
  if (error != 0) {
    return (17);
  }
  {
  error = GetKeyword(Keywords[13], curr_ptr);
  error = 0;
  error = GetReal(ycoord_ptr, curr_ptr);
  }
  if (error != 0) {
    return (17);
  }
  *pp2 = *curr_ptr;
  return (0);
}
}
#pragma merger("0","/tmp/cil-eHzDl9N5.i","")
