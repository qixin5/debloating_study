/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef int __int32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef char *__caddr_t;
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef __caddr_t caddr_t;
typedef unsigned long size_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef void *ptr_t;
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct matcher {
   char *name ;
   void (*compile)(char * , size_t  ) ;
   char *(*execute)(char * , size_t  , char ** ) ;
};
struct stats {
   struct stats *parent ;
   struct stat stat ;
};
enum __anonenum_directories_30 {
    READ_DIRECTORIES = 0,
    RECURSE_DIRECTORIES = 1,
    SKIP_DIRECTORIES = 2
} ;
enum __anonenum_binary_files_31 {
    BINARY_BINARY_FILES = 0,
    TEXT_BINARY_FILES = 1,
    WITHOUT_MATCH_BINARY_FILES = 2
} ;
typedef unsigned long active_reg_t;
typedef unsigned long reg_syntax_t;
enum __anonenum_reg_errcode_t_32 {
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
typedef enum __anonenum_reg_errcode_t_32 reg_errcode_t;
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
struct __anonstruct_regmatch_t_33 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_33 regmatch_t;
typedef int charclass[(((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))];
enum __anonenum_token_34 {
    END = -1,
    EMPTY = 256,
    BACKREF = 257,
    BEGLINE = 258,
    ENDLINE = 259,
    BEGWORD = 260,
    ENDWORD = 261,
    LIMWORD = 262,
    NOTLIMWORD = 263,
    QMARK = 264,
    STAR = 265,
    PLUS = 266,
    REPMN = 267,
    CAT = 268,
    OR = 269,
    ORTOP = 270,
    LPAREN = 271,
    RPAREN = 272,
    CSET = 273
} ;
typedef enum __anonenum_token_34 token;
struct __anonstruct_position_35 {
   unsigned int strchr ;
   unsigned int constraint ;
};
typedef struct __anonstruct_position_35 position;
struct __anonstruct_position_set_36 {
   position *elems ;
   int nelem ;
};
typedef struct __anonstruct_position_set_36 position_set;
struct __anonstruct_dfa_state_37 {
   int hash ;
   position_set elems ;
   char newline ;
   char letter ;
   char backref ;
   unsigned char constraint ;
   int first_end ;
};
typedef struct __anonstruct_dfa_state_37 dfa_state;
struct dfamust {
   int exact ;
   char *must ;
   struct dfamust *next ;
};
struct dfa {
   charclass *charclasses ;
   int cindex ;
   int calloc ;
   token *tokens ;
   int tindex ;
   int talloc ;
   int depth ;
   int nleaves ;
   int nregexps ;
   dfa_state *states ;
   int sindex ;
   int salloc ;
   position_set *follows ;
   int searchflag ;
   int tralloc ;
   int trcount ;
   int **trans ;
   int **realtrans ;
   int **fails ;
   int *success ;
   int *newlines ;
   struct dfamust *musts ;
};
struct __anonstruct_prednames_38 {
   char const   *name ;
   int (*pred)(int  ) ;
};
struct __anonstruct_must_39 {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
};
typedef struct __anonstruct_must_39 must;
struct kwsmatch {
   int strchr ;
   char *beg[1] ;
   size_t size[1] ;
};
typedef ptr_t kwset_t;
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   long temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
struct trie;
struct trie;
struct tree {
   struct tree *llink ;
   struct tree *rlink ;
   struct trie *trie ;
   unsigned char label ;
   char balance ;
};
struct trie {
   unsigned int accepting ;
   struct tree *links ;
   struct trie *parent ;
   struct trie *next ;
   struct trie *fail ;
   int depth ;
   int shift ;
   int maxshift ;
};
struct kwset {
   struct obstack obstack ;
   int words ;
   struct trie *trie ;
   int mind ;
   int maxd ;
   unsigned char delta[256] ;
   struct trie *next[256] ;
   char *target ;
   int mind2 ;
   char *trans ;
};
enum __anonenum_dirs_40 {
    L = 0,
    R = 1
} ;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
struct __dirstream;
typedef struct __dirstream DIR;
typedef char boolean;
enum __anonenum_re_opcode_t_42 {
    no_op = 0,
    succeed = 1,
    exactn = 2,
    anychar = 3,
    charset = 4,
    charset_not = 5,
    start_memory = 6,
    stop_memory = 7,
    duplicate = 8,
    begline = 9,
    endline = 10,
    begbuf = 11,
    endbuf = 12,
    jump = 13,
    jump_past_alt = 14,
    on_failure_jump = 15,
    on_failure_keep_string_jump = 16,
    pop_failure_jump = 17,
    maybe_pop_jump = 18,
    dummy_failure_jump = 19,
    push_dummy_failure = 20,
    succeed_n = 21,
    jump_n = 22,
    set_number_at = 23,
    wordchar = 24,
    notwordchar = 25,
    wordbeg = 26,
    wordend = 27,
    wordbound = 28,
    notwordbound = 29
} ;
typedef enum __anonenum_re_opcode_t_42 re_opcode_t;
union fail_stack_elt {
   unsigned char *pointer ;
   int integer ;
};
typedef union fail_stack_elt fail_stack_elt_t;
struct __anonstruct_fail_stack_type_43 {
   fail_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
typedef struct __anonstruct_fail_stack_type_43 fail_stack_type;
struct __anonstruct_bits_45 {
   unsigned int match_null_string_p : 2 ;
   unsigned int is_active : 1 ;
   unsigned int matched_something : 1 ;
   unsigned int ever_matched_something : 1 ;
};
union __anonunion_register_info_type_44 {
   fail_stack_elt_t word ;
   struct __anonstruct_bits_45 bits ;
};
typedef union __anonunion_register_info_type_44 register_info_type;
typedef unsigned int regnum_t;
typedef long pattern_offset_t;
struct __anonstruct_compile_stack_elt_t_46 {
   pattern_offset_t begalt_offset ;
   pattern_offset_t fixup_alt_jump ;
   pattern_offset_t inner_group_offset ;
   pattern_offset_t laststart_offset ;
   regnum_t regnum ;
};
typedef struct __anonstruct_compile_stack_elt_t_46 compile_stack_elt_t;
struct __anonstruct_compile_stack_type_47 {
   compile_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
typedef struct __anonstruct_compile_stack_type_47 compile_stack_type;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-ldV4twA4.i","")
#pragma merger("0","/tmp/cil-pthx382W.i","")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int puts(char const   *__s ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  dest ,
                                                                                          char const   * __restrict  src ) ;
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
 __attribute__((__noreturn__)) void fatal(char const   *mesg , int errnum ) ;
char *xmalloc(size_t size ) ;
char *xrealloc(char *ptr , size_t size ) ;
struct matcher matchers[6] ;
char const   *matcher  ;
int match_icase  ;
int match_words  ;
int match_lines  ;
unsigned char eolbyte  ;
char *savedir(char const   *dir , off_t name_size ) ;
static struct stats stats_base  ;
static int show_help  ;
static int show_version  ;
static int mmap_option  ;
static char const   short_options[51]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )':', 
        (char const   )'B',      (char const   )':',      (char const   )'C',      (char const   )':', 
        (char const   )':',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'U',      (char const   )'V', 
        (char const   )'X',      (char const   )':',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )':',      (char const   )'e', 
        (char const   )':',      (char const   )'f',      (char const   )':',      (char const   )'h', 
        (char const   )'i',      (char const   )'L',      (char const   )'l',      (char const   )'n', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'u', 
        (char const   )'v',      (char const   )'w',      (char const   )'x',      (char const   )'y', 
        (char const   )'Z',      (char const   )'z',      (char const   )'\000'};
static struct option long_options[35]  = 
  {      {"after-context", 1, (int *)((void *)0), 'A'}, 
        {"basic-regexp", 0, (int *)((void *)0), 'G'}, 
        {"before-context", 1, (int *)((void *)0), 'B'}, 
        {"binary-files", 1, (int *)((void *)0), 128}, 
        {"byte-offset", 0, (int *)((void *)0), 'b'}, 
        {"context", 2, (int *)((void *)0), 'C'}, 
        {"count", 0, (int *)((void *)0), 'c'}, 
        {"directories", 1, (int *)((void *)0), 'd'}, 
        {"extended-regexp", 0, (int *)((void *)0), 'E'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"files-with-matches", 0, (int *)((void *)0), 'l'}, 
        {"files-without-match", 0, (int *)((void *)0), 'L'}, 
        {"fixed-regexp", 0, (int *)((void *)0), 'F'}, 
        {"fixed-strings", 0, (int *)((void *)0), 'F'}, 
        {"help", 0, & show_help, 1}, 
        {"ignore-case", 0, (int *)((void *)0), 'i'}, 
        {"line-number", 0, (int *)((void *)0), 'n'}, 
        {"line-regexp", 0, (int *)((void *)0), 'x'}, 
        {"mmap", 0, & mmap_option, 1}, 
        {"no-filename", 0, (int *)((void *)0), 'h'}, 
        {"no-messages", 0, (int *)((void *)0), 's'}, 
        {"null", 0, (int *)((void *)0), 'Z'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"recursive", 0, (int *)((void *)0), 'r'}, 
        {"regexp", 1, (int *)((void *)0), 'e'}, 
        {"invert-match", 0, (int *)((void *)0), 'v'}, 
        {"silent", 0, (int *)((void *)0), 'q'}, 
        {"text", 0, (int *)((void *)0), 'a'}, 
        {"binary", 0, (int *)((void *)0), 'U'}, 
        {"unix-byte-offsets", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"with-filename", 0, (int *)((void *)0), 'H'}, 
        {"word-regexp", 0, (int *)((void *)0), 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
static char *prog  ;
static char const   *filename  ;
static int errseen  ;
static enum __anonenum_directories_30 directories  ;
static int ck_atoi(char const   *str , int *out ) ;
static  __attribute__((__noreturn__)) void usage(int status ) ;
static void error(char const   *mesg , int errnum ) ;
static void setmatcher(char const   *m ) ;
static int install_matcher(char const   *name ) ;
static int prepend_args(char const   *options , char *buf , char **argv ) ;
static void prepend_default_options(char const   *options , int *pargc , char ***pargv ) ;
static char *page_alloc(size_t size , char **up ) ;
static int reset(int fd , char const   *file , struct stats *stats ) ;
static int fillbuf(size_t save , struct stats *stats ) ;
static int grepbuf(char *beg , char *lim ) ;
static void prtext(char *beg , char *lim , int *nlinesp ) ;
static void prpending(char *lim ) ;
static void prline(char *beg , char *lim , int sep ) ;
static void print_offset_sep(off_t pos , int sep ) ;
static void nlscan(char *lim ) ;
static int grep(int fd , char const   *file , struct stats *stats ) ;
static int grepdir(char const   *dir , struct stats *stats ) ;
static int grepfile(char const   *file , struct stats *stats ) ;
static void (*compile)(char * , size_t  )  ;
static char *(*execute)(char * , size_t  , char ** )  ;
static void error(char const   *mesg , int errnum ) 
{ 
  char *tmp ;

  {
  if (errnum) {
    {
    tmp = strerror(errnum);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: %s: %s\n",
            prog, mesg, tmp);
    }
  } else {
    {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: %s\n",
            prog, mesg);
    }
  }
  errseen = 1;
  return;
}
}
 __attribute__((__noreturn__)) void fatal(char const   *mesg , int errnum ) ;
void fatal(char const   *mesg , int errnum ) 
{ 


  {
  {
  error(mesg, errnum);
  exit(2);
  }
}
}
char *xmalloc(size_t size ) 
{ 
  char *result ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = malloc(size);
  result = (char *)tmp;
  }
  if (size) {
    if (! result) {
      {
      tmp___0 = gettext("memory exhausted");
      fatal((char const   *)tmp___0, 0);
      }
    }
  }
  return (result);
}
}
char *xrealloc(char *ptr , size_t size ) 
{ 
  char *result ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  if (ptr) {
    {
    tmp = realloc((void *)ptr, size);
    result = (char *)tmp;
    }
  } else {
    {
    tmp___0 = malloc(size);
    result = (char *)tmp___0;
    }
  }
  if (size) {
    if (! result) {
      {
      tmp___1 = gettext("memory exhausted");
      fatal((char const   *)tmp___1, 0);
      }
    }
  }
  return (result);
}
}
static int ck_atoi(char const   *str , int *out ) 
{ 
  char const   *p ;

  {
  p = str;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p) {
      goto while_break;
    }
    if ((int const   )*p < 48) {
      return (-1);
    } else { //Added block
    if ((int const   )*p > 57) {
      return (-1);
    }
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *out = atoi((char const   *)optarg);
  }
  return (0);
}
}
static char *ubuffer  ;
static char *buffer  ;
static size_t bufsalloc  ;
static size_t bufalloc  ;
static int bufdesc  ;
static char *bufbeg  ;
static char *buflim  ;
static size_t pagesize  ;
static off_t bufoffset  ;
static int bufmapped  ;
static off_t initial_bufoffset  ;
static char *page_alloc(size_t size , char **up ) 
{ 
  size_t asize ;
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  asize = (size + pagesize) - 1UL;
  if (size <= asize) {
    if (*up) {
      {
      tmp = realloc((void *)*up, asize);
      tmp___1 = tmp;
      }
    } else {
      {
      tmp___0 = malloc(asize);
      tmp___1 = tmp___0;
      }
    }
    p = (char *)tmp___1;
    if (p) {
      *up = p;
      if ((size_t )p % pagesize == 0UL) {
        tmp___2 = p;
      } else {
        tmp___2 = p + (pagesize - (size_t )p % pagesize);
      }
      return (tmp___2);
    }
  }
  return ((char *)((void *)0));
}
}
static int reset(int fd , char const   *file , struct stats *stats ) 
{ 
  size_t ubufsalloc ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  if (pagesize) {
    if ((bufalloc / 5UL) % pagesize == 0UL) {
      bufsalloc = bufalloc / 5UL;
    } else {
      bufsalloc = bufalloc / 5UL + (pagesize - (bufalloc / 5UL) % pagesize);
    }
  } else {
    {
    tmp = getpagesize();
    pagesize = (size_t )tmp;
    }
    if (pagesize == 0UL) {
      {
      abort();
      }
    }
    if (8192UL > pagesize) {
      ubufsalloc = (size_t )8192;
    } else {
      ubufsalloc = pagesize;
    }
    if (ubufsalloc % pagesize == 0UL) {
      bufsalloc = ubufsalloc;
    } else {
      bufsalloc = ubufsalloc + (pagesize - ubufsalloc % pagesize);
    }
    bufalloc = 5UL * bufsalloc;
    if (bufsalloc < ubufsalloc) {
      {
      tmp___0 = gettext("memory exhausted");
      fatal((char const   *)tmp___0, 0);
      }
    } else { //Added block
    if (bufalloc / 5UL != bufsalloc) {
      {
      tmp___0 = gettext("memory exhausted");
      fatal((char const   *)tmp___0, 0);
      }
    } else { //Added block
    if (bufalloc + 1UL < bufalloc) {
      {
      tmp___0 = gettext("memory exhausted");
      fatal((char const   *)tmp___0, 0);
      }
    } else {
      {
      buffer = page_alloc(bufalloc + 1UL, & ubuffer);
      }
      if (! buffer) {
        {
        tmp___0 = gettext("memory exhausted");
        fatal((char const   *)tmp___0, 0);
        }
      }
    }
    }
    }
  }
  {
  buflim = buffer;
  bufdesc = fd;
  tmp___2 = fstat(fd, & stats->stat);
  }
  if (tmp___2 != 0) {
    {
    tmp___1 = __errno_location();
    error("fstat", *tmp___1);
    }
    return (0);
  }
  if ((unsigned int )directories == 2U) {
    if ((stats->stat.st_mode & 61440U) == 16384U) {
      return (0);
    }
  }
  if ((stats->stat.st_mode & 61440U) == 32768U) {
    if (file) {
      bufoffset = (off_t )0;
    } else {
      {
      bufoffset = lseek(fd, (__off_t )0, 1);
      }
      if (bufoffset < 0L) {
        {
        tmp___3 = __errno_location();
        error("lseek", *tmp___3);
        }
        return (0);
      }
    }
    initial_bufoffset = bufoffset;
    if (mmap_option) {
      if ((unsigned long )bufoffset % pagesize == 0UL) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
    } else {
      tmp___4 = 0;
    }
    bufmapped = tmp___4;
  } else {
    bufmapped = 0;
  }
  return (1);
}
}
static int fillbuf(size_t save , struct stats *stats ) 
{ 
  size_t fillsize ;
  int cc ;
  size_t readsize ;
  size_t saved_offset ;
  size_t aligned_save ;
  size_t tmp ;
  size_t maxalloc ;
  size_t newalloc ;
  off_t to_be_read ;
  size_t slop ;
  off_t aligned_to_be_read ;
  size_t tmp___0 ;
  off_t maxalloc_off ;
  char *tmp___1 ;
  size_t mmapsize ;
  int *tmp___2 ;
  __off_t tmp___3 ;
  void *tmp___4 ;
  ssize_t bytesread ;
  int *tmp___5 ;

  {
  fillsize = (size_t )0;
  cc = 1;
  saved_offset = (size_t )(buflim - ubuffer) - save;
  if (bufsalloc < save) {
    if (save % pagesize == 0UL) {
      tmp = save;
    } else {
      tmp = save + (pagesize - save % pagesize);
    }
    aligned_save = tmp;
    maxalloc = (size_t )-1;
    if ((stats->stat.st_mode & 61440U) == 32768U) {
      to_be_read = stats->stat.st_size - bufoffset;
      slop = (unsigned long )to_be_read % pagesize;
      if (slop) {
        tmp___0 = pagesize - slop;
      } else {
        tmp___0 = (size_t )0;
      }
      aligned_to_be_read = (off_t )((size_t )to_be_read + tmp___0);
      maxalloc_off = (off_t )(aligned_save + (size_t )aligned_to_be_read);
      if (0L <= maxalloc_off) {
        if ((size_t )maxalloc_off == (size_t )maxalloc_off) {
          maxalloc = (size_t )maxalloc_off;
        }
      }
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (bufsalloc < save)) {
        goto while_break;
      }
      if (bufsalloc < bufsalloc * 2UL) {
        bufsalloc *= 2UL;
      } else {
        bufsalloc = aligned_save;
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    newalloc = 5UL * bufsalloc;
    if (maxalloc < newalloc) {
      newalloc = maxalloc;
      bufsalloc = aligned_save;
    }
    if (bufsalloc < save) {
      {
      tmp___1 = gettext("memory exhausted");
      fatal((char const   *)tmp___1, 0);
      }
    } else { //Added block
    if (newalloc < save) {
      {
      tmp___1 = gettext("memory exhausted");
      fatal((char const   *)tmp___1, 0);
      }
    } else { //Added block
    if (newalloc == save) {
      if (newalloc != maxalloc) {
        {
        tmp___1 = gettext("memory exhausted");
        fatal((char const   *)tmp___1, 0);
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (bufalloc < newalloc) {
      {
      bufalloc = newalloc;
      buffer = page_alloc(bufalloc + 1UL, & ubuffer);
      }
      if (! buffer) {
        {
        tmp___1 = gettext("memory exhausted");
        fatal((char const   *)tmp___1, 0);
        }
      }
    }
    }
    }
    }
  }
  {
  bufbeg = (buffer + bufsalloc) - save;
  memmove((void *)bufbeg, (void const   *)(ubuffer + saved_offset), save);
  readsize = bufalloc - bufsalloc;
  }
  if (bufmapped) {
    mmapsize = readsize;
    if ((size_t )(stats->stat.st_size - bufoffset) < mmapsize) {
      mmapsize = (size_t )(stats->stat.st_size - bufoffset);
      mmapsize -= mmapsize % pagesize;
    }
    if (mmapsize) {
      {
      tmp___4 = mmap((void *)(buffer + bufsalloc), mmapsize, 3, 18, bufdesc, bufoffset);
      }
      if ((unsigned long )tmp___4 != (unsigned long )((caddr_t )-1)) {
        fillsize = mmapsize;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      bufmapped = 0;
      if (bufoffset != initial_bufoffset) {
        {
        tmp___3 = lseek(bufdesc, bufoffset, 0);
        }
        if (tmp___3 < 0L) {
          {
          tmp___2 = __errno_location();
          error("lseek", *tmp___2);
          cc = 0;
          }
        }
      }
    }
  }
  if (! fillsize) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      bytesread = read(bufdesc, (void *)(buffer + bufsalloc), readsize);
      }
      if (bytesread < 0L) {
        {
        tmp___5 = __errno_location();
        }
        if (! (*tmp___5 == 4)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      goto while_continue___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (bytesread < 0L) {
      cc = 0;
    } else {
      fillsize = (size_t )bytesread;
    }
  }
  bufoffset = (off_t )((size_t )bufoffset + fillsize);
  buflim = (buffer + bufsalloc) + fillsize;
  return (cc);
}
}
static enum __anonenum_binary_files_31 binary_files  ;
static int filename_mask  ;
static int out_quiet  ;
static int out_invert  ;
static int out_file  ;
static int out_line  ;
static int out_byte  ;
static int out_before  ;
static int out_after  ;
static int count_matches  ;
static int list_files  ;
static int no_filenames  ;
static int suppress_errors  ;
static off_t totalcc  ;
static char *lastnl  ;
static char *lastout  ;
static off_t totalnl  ;
static int pending  ;
static int done_on_match  ;
static void nlscan(char *lim ) 
{ 
  char *beg ;
  void *tmp ;

  {
  beg = lastnl;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = memchr((void const   *)beg, (int )eolbyte, (size_t )(lim - beg));
    beg = (char *)tmp;
    }
    if (! beg) {
      goto while_break;
    }
    totalnl ++;
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  lastnl = lim;
  return;
}
}
static void print_offset_sep(off_t pos , int sep ) 
{ 
  char buf[sizeof(pos) * 8UL] ;
  char *p ;

  {
  p = (buf + sizeof(buf)) - 1;
  *p = (char )sep;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    p --;
    *p = (char )(48L + pos % 10L);
    pos /= 10L;
    if (! (pos != 0L)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  fwrite((void const   * __restrict  )p, (size_t )1, (size_t )((buf + sizeof(buf)) - p),
         (FILE * __restrict  )stdout);
  }
  return;
}
}
static void prline(char *beg , char *lim , int sep ) 
{ 
  off_t pos ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  if (out_file) {
    {
    printf((char const   * __restrict  )"%s%c", filename, sep & filename_mask);
    }
  }
  if (out_line) {
    {
    nlscan(beg);
    totalnl ++;
    print_offset_sep(totalnl, sep);
    lastnl = lim;
    }
  }
  if (out_byte) {
    {
    pos = totalcc + (beg - bufbeg);
    print_offset_sep(pos, sep);
    }
  }
  {
  fwrite((void const   * __restrict  )beg, (size_t )1, (size_t )(lim - beg), (FILE * __restrict  )stdout);
  tmp___1 = ferror(stdout);
  }
  if (tmp___1) {
    {
    tmp = __errno_location();
    tmp___0 = gettext("writing output");
    error((char const   *)tmp___0, *tmp);
    }
  }
  lastout = lim;
  return;
}
}
static void prpending(char *lim ) 
{ 
  char *nl ;
  void *tmp ;

  {
  if (! lastout) {
    lastout = bufbeg;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (pending > 0) {
      if (! ((unsigned long )lastout < (unsigned long )lim)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    pending --;
    tmp = memchr((void const   *)lastout, (int )eolbyte, (size_t )(lim - lastout));
    nl = (char *)tmp;
    }
    if ((unsigned long )nl != (unsigned long )((char *)0)) {
      nl ++;
    } else {
      nl = lim;
    }
    {
    prline(lastout, nl, '-');
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int used  ;
static void prtext(char *beg , char *lim , int *nlinesp ) 
{ 
  char *bp ;
  char *p ;
  char *nl ;
  char eol ;
  int i ;
  int n ;
  void *tmp ;
  void *tmp___0 ;

  {
  eol = (char )eolbyte;
  if (! out_quiet) {
    if (pending > 0) {
      {
      prpending(beg);
      }
    }
  }
  p = beg;
  if (! out_quiet) {
    if (lastout) {
      bp = lastout;
    } else {
      bp = bufbeg;
    }
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < out_before)) {
        goto while_break;
      }
      if ((unsigned long )p > (unsigned long )bp) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          p --;
          if ((unsigned long )p > (unsigned long )bp) {
            if (! ((int )*(p + -1) != (int )eol)) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (out_before) {
      goto _L;
    } else { //Added block
    if (out_after) {
      _L: 
      if (used) {
        if ((unsigned long )p != (unsigned long )lastout) {
          {
          puts("--");
          }
        }
      }
    }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned long )p < (unsigned long )beg)) {
        goto while_break___1;
      }
      {
      tmp = memchr((void const   *)p, (int )eol, (size_t )(beg - p));
      nl = (char *)tmp;
      prline(p, nl + 1, '-');
      p = nl + 1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  if (nlinesp) {
    n = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! ((unsigned long )p < (unsigned long )lim)) {
        goto while_break___2;
      }
      {
      tmp___0 = memchr((void const   *)p, (int )eol, (size_t )(lim - p));
      nl = (char *)tmp___0;
      }
      if ((unsigned long )nl != (unsigned long )((char *)0)) {
        nl ++;
      } else {
        nl = lim;
      }
      if (! out_quiet) {
        {
        prline(p, nl, ':');
        }
      }
      p = nl;
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    *nlinesp = n;
  } else { //Added block
  if (! out_quiet) {
    {
    prline(beg, lim, ':');
    }
  }
  }
  if (out_quiet) {
    pending = 0;
  } else {
    pending = out_after;
  }
  used = 1;
  return;
}
}
static int grepbuf(char *beg , char *lim ) 
{ 
  int nlines ;
  int n ;
  register char *p ;
  register char *b ;
  char *endp ;
  char eol ;

  {
  eol = (char )eolbyte;
  nlines = 0;
  p = beg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    b = (*execute)(p, (size_t )(lim - p), & endp);
    }
    if (! ((unsigned long )b != (unsigned long )((char *)0))) {
      goto while_break;
    }
    if ((unsigned long )b == (unsigned long )lim) {
      if ((unsigned long )b > (unsigned long )beg) {
        if ((int )*(b + -1) == (int )eol) {
          goto while_break;
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if ((unsigned long )b == (unsigned long )beg) {
        goto while_break;
      }
      }
    }
    if (! out_invert) {
      {
      prtext(b, endp, (int *)0);
      nlines ++;
      }
      if (done_on_match) {
        return (nlines);
      }
    } else { //Added block
    if ((unsigned long )p < (unsigned long )b) {
      {
      prtext(p, b, & n);
      nlines += n;
      }
    }
    }
    p = endp;
  }
  while_break: /* CIL Label */ ;
  }
  if (out_invert) {
    if ((unsigned long )p < (unsigned long )lim) {
      {
      prtext(p, lim, & n);
      nlines += n;
      }
    }
  }
  return (nlines);
}
}
static int grep(int fd , char const   *file , struct stats *stats ) 
{ 
  int nlines ;
  int i ;
  int not_text ;
  size_t residue ;
  size_t save ;
  char *beg ;
  char *lim ;
  char eol ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
  {
  eol = (char )eolbyte;
  tmp = reset(fd, file, stats);
  }
  if (! tmp) {
    return (0);
  }
  if (file) {
    if ((unsigned int )directories == 1U) {
      if ((stats->stat.st_mode & 61440U) == 16384U) {
        {
        tmp___1 = close(fd);
        }
        if (tmp___1 != 0) {
          {
          tmp___0 = __errno_location();
          error(file, *tmp___0);
          }
        }
        {
        tmp___2 = grepdir(file, stats);
        }
        return (tmp___2 - 2);
      }
    }
  }
  {
  totalcc = (off_t )0;
  lastout = (char *)0;
  totalnl = (off_t )0;
  pending = 0;
  nlines = 0;
  residue = (size_t )0;
  save = (size_t )0;
  tmp___5 = fillbuf(save, stats);
  }
  if (! tmp___5) {
    {
    tmp___4 = __errno_location();
    }
    if (*tmp___4 == 21) {
      if (! suppress_errors) {
        {
        tmp___3 = __errno_location();
        error(filename, *tmp___3);
        }
      }
    } else {
      {
      tmp___3 = __errno_location();
      error(filename, *tmp___3);
      }
    }
    return (0);
  }
  if ((unsigned int )binary_files == 0U) {
    if (! out_quiet) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((unsigned int )binary_files == 2U) {
    _L: 
    if (eol) {
      tmp___6 = '\000';
    } else {
      tmp___6 = '\200';
    }
    {
    tmp___7 = memchr((void const   *)bufbeg, tmp___6, (size_t )(buflim - bufbeg));
    }
    if (tmp___7) {
      tmp___8 = 1;
    } else {
      tmp___8 = 0;
    }
  } else {
    tmp___8 = 0;
  }
  }
  not_text = tmp___8;
  if (not_text) {
    if ((unsigned int )binary_files == 2U) {
      return (0);
    }
  }
  done_on_match += not_text;
  out_quiet += not_text;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    lastnl = bufbeg;
    if (lastout) {
      lastout = bufbeg;
    }
    if ((size_t )(buflim - bufbeg) == save) {
      goto while_break;
    }
    beg = (bufbeg + save) - residue;
    lim = buflim;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )lim > (unsigned long )beg) {
        if (! ((int )*(lim + -1) != (int )eol)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      lim --;
    }
    while_break___0: /* CIL Label */ ;
    }
    residue = (size_t )(buflim - lim);
    if ((unsigned long )beg < (unsigned long )lim) {
      {
      tmp___9 = grepbuf(beg, lim);
      nlines += tmp___9;
      }
      if (pending) {
        {
        prpending(lim);
        }
      }
      if (nlines) {
        if (done_on_match) {
          if (! out_invert) {
            goto finish_grep;
          }
        }
      }
    }
    i = 0;
    beg = lim;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (i < out_before) {
        if ((unsigned long )beg > (unsigned long )bufbeg) {
          if (! ((unsigned long )beg != (unsigned long )lastout)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      i ++;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        beg --;
        if ((unsigned long )beg > (unsigned long )bufbeg) {
          if (! ((int )*(beg + -1) != (int )eol)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((unsigned long )beg != (unsigned long )lastout) {
      lastout = (char *)0;
    }
    save = (size_t )((lim + residue) - beg);
    totalcc = (off_t )((size_t )totalcc + ((size_t )(buflim - bufbeg) - save));
    if (out_line) {
      {
      nlscan(beg);
      }
    }
    {
    tmp___12 = fillbuf(save, stats);
    }
    if (! tmp___12) {
      {
      tmp___11 = __errno_location();
      }
      if (*tmp___11 == 21) {
        if (! suppress_errors) {
          {
          tmp___10 = __errno_location();
          error(filename, *tmp___10);
          }
        }
      } else {
        {
        tmp___10 = __errno_location();
        error(filename, *tmp___10);
        }
      }
      goto finish_grep;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (residue) {
    {
    tmp___13 = buflim;
    buflim ++;
    *tmp___13 = eol;
    tmp___14 = grepbuf((bufbeg + save) - residue, buflim);
    nlines += tmp___14;
    }
    if (pending) {
      {
      prpending(buflim);
      }
    }
  }
  finish_grep: 
  done_on_match -= not_text;
  out_quiet -= not_text;
  if (not_text & ~ out_quiet) {
    if (nlines != 0) {
      {
      tmp___15 = gettext("Binary file %s matches\n");
      printf((char const   * __restrict  )tmp___15, filename);
      }
    }
  }
  return (nlines);
}
}
static int grepfile(char const   *file , struct stats *stats ) 
{ 
  int desc ;
  int count ;
  int status ;
  char *tmp ;
  int *tmp___0 ;
  int e ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  if (! file) {
    {
    desc = 0;
    tmp = gettext("(standard input)");
    filename = (char const   *)tmp;
    }
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      desc = open(file, 0);
      }
      if (desc < 0) {
        {
        tmp___0 = __errno_location();
        }
        if (! (*tmp___0 == 4)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
    if (desc < 0) {
      {
      tmp___1 = __errno_location();
      e = *tmp___1;
      }
      if (e == 21) {
        if ((unsigned int )directories == 1U) {
          {
          tmp___3 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& stats->stat));
          }
          if (tmp___3 != 0) {
            {
            tmp___2 = __errno_location();
            error(file, *tmp___2);
            }
            return (1);
          }
          {
          tmp___4 = grepdir(file, stats);
          }
          return (tmp___4);
        }
      }
      if (! suppress_errors) {
        if ((unsigned int )directories == 2U) {
          {
          if (e == 21) {
            goto case_21;
          }
          if (e == 13) {
            goto case_13;
          }
          goto switch_break;
          case_21: /* CIL Label */ 
          return (1);
          case_13: /* CIL Label */ 
          {
          tmp___5 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& stats->stat));
          }
          if (tmp___5 == 0) {
            if ((stats->stat.st_mode & 61440U) == 16384U) {
              return (1);
            }
          }
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
        {
        error(file, e);
        }
      }
      return (1);
    }
    filename = file;
  }
  {
  count = grep(desc, file, stats);
  }
  if (count < 0) {
    status = count + 2;
  } else {
    if (count_matches) {
      if (out_file) {
        {
        printf((char const   * __restrict  )"%s%c", filename, 58 & filename_mask);
        }
      }
      {
      printf((char const   * __restrict  )"%d\n", count);
      }
    }
    status = ! count;
    if (list_files == 1 - 2 * status) {
      {
      printf((char const   * __restrict  )"%s%c", filename, 10 & filename_mask);
      }
    }
    if (file) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp___8 = close(desc);
        }
        if (! (tmp___8 != 0)) {
          goto while_break___0;
        }
        {
        tmp___7 = __errno_location();
        }
        if (*tmp___7 != 4) {
          {
          tmp___6 = __errno_location();
          error(file, *tmp___6);
          }
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return (status);
}
}
static int grepdir(char const   *dir , struct stats *stats ) 
{ 
  int status ;
  struct stats *ancestor ;
  char *name_space ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  size_t dirlen ;
  size_t tmp___4 ;
  int needs_slash ;
  int tmp___5 ;
  char *file ;
  char *namep ;
  struct stats child ;
  size_t namelen ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
  status = 1;
  ancestor = stats;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    ancestor = ancestor->parent;
    if (! ((unsigned long )ancestor != (unsigned long )((struct stats *)0))) {
      goto while_break;
    }
    if (ancestor->stat.st_ino == stats->stat.st_ino) {
      if (ancestor->stat.st_dev == stats->stat.st_dev) {
        if (! suppress_errors) {
          {
          tmp = gettext("recursive directory loop");
          tmp___0 = gettext("%s: warning: %s: %s\n");
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )tmp___0,
                  prog, dir, tmp);
          }
        }
        return (1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  name_space = savedir(dir, (off_t )((unsigned int )stats->stat.st_size));
  }
  if (! name_space) {
    {
    tmp___3 = __errno_location();
    }
    if (*tmp___3) {
      if (! suppress_errors) {
        {
        tmp___1 = __errno_location();
        error(dir, *tmp___1);
        }
      }
    } else {
      {
      tmp___2 = gettext("Memory exhausted");
      fatal((char const   *)tmp___2, 0);
      }
    }
  } else {
    {
    tmp___4 = strlen(dir);
    dirlen = tmp___4;
    }
    if (dirlen == 0UL) {
      tmp___5 = 0;
    } else { //Added block
    if ((int const   )*(dir + (dirlen - 1UL)) == 47) {
      tmp___5 = 0;
    } else {
      tmp___5 = 1;
    }
    }
    needs_slash = tmp___5;
    file = (char *)((void *)0);
    namep = name_space;
    child.parent = stats;
    out_file += ! no_filenames;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *namep) {
        goto while_break___0;
      }
      {
      tmp___6 = strlen((char const   *)namep);
      namelen = tmp___6;
      file = xrealloc(file, ((dirlen + 1UL) + namelen) + 1UL);
      strcpy((char * __restrict  )file, (char const   * __restrict  )dir);
      *(file + dirlen) = (char )'/';
      strcpy((char * __restrict  )((file + dirlen) + needs_slash), (char const   * __restrict  )namep);
      namep += namelen + 1UL;
      tmp___7 = grepfile((char const   *)file, & child);
      status &= tmp___7;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    out_file -= ! no_filenames;
    if (file) {
      {
      free((void *)file);
      }
    }
    {
    free((void *)name_space);
    }
  }
  return (status);
}
}
static  __attribute__((__noreturn__)) void usage(int status ) ;
static void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  if (status != 0) {
    {
    tmp = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )tmp, prog);
    tmp___0 = gettext("Try `%s --help\' for more information.\n");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )tmp___0, prog);
    }
  } else {
    {
    tmp___1 = gettext("Usage: %s [OPTION]... PATTERN [FILE] ...\n");
    printf((char const   * __restrict  )tmp___1, prog);
    tmp___2 = gettext("Search for PATTERN in each FILE or standard input.\nExample: %s -i \'hello world\' menu.h main.c\n\nRegexp selection and interpretation:\n");
    printf((char const   * __restrict  )tmp___2, prog);
    tmp___3 = gettext("  -E, --extended-regexp     PATTERN is an extended regular expression\n  -F, --fixed-strings       PATTERN is a set of newline-separated strings\n  -G, --basic-regexp        PATTERN is a basic regular expression\n");
    printf((char const   * __restrict  )tmp___3);
    tmp___4 = gettext("  -e, --regexp=PATTERN      use PATTERN as a regular expression\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n");
    printf((char const   * __restrict  )tmp___4);
    tmp___5 = gettext("\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             print version information and exit\n      --help                display this help and exit\n      --mmap                use memory-mapped input if possible\n");
    printf((char const   * __restrict  )tmp___5);
    tmp___6 = gettext("\nOutput control:\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n  -H, --with-filename       print the filename for each match\n  -h, --no-filename         suppress the prefixing filename on output\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE\n                            TYPE is \'binary\', \'text\', or \'without-match\'.\n  -a, --text                equivalent to --binary-files=text\n  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories\n                            ACTION is \'read\', \'recurse\', or \'skip\'.\n  -r, --recursive           equivalent to --directories=recurse.\n  -L, --files-without-match only print FILE names containing no match\n  -l, --files-with-matches  only print FILE names containing matches\n  -c, --count               only print a count of matching lines per FILE\n  -Z, --null                print 0 byte after FILE name\n");
    printf((char const   * __restrict  )tmp___6);
    tmp___7 = gettext("\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context[=NUM]       print NUM (default 2) lines of output context\n                            unless overridden by -A or -B\n  -NUM                      same as --context=NUM\n  -U, --binary              do not strip CR characters at EOL (MSDOS)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\n`egrep\' means `grep -E\'.  `fgrep\' means `grep -F\'.\nWith no FILE, or when FILE is -, read standard input.  If less than\ntwo FILEs given, assume -h.  Exit status is 0 if match, 1 if no match,\nand 2 if trouble.\n");
    printf((char const   * __restrict  )tmp___7);
    tmp___8 = gettext("\nReport bugs to <bug-gnu-utils@gnu.org>.\n");
    printf((char const   * __restrict  )tmp___8);
    }
  }
  {
  exit(status);
  }
}
}
static void setmatcher(char const   *m ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  if (matcher) {
    {
    tmp___0 = strcmp(matcher, m);
    }
    if (tmp___0 != 0) {
      {
      tmp = gettext("conflicting matchers specified");
      fatal((char const   *)tmp, 0);
      }
    }
  }
  matcher = m;
  return;
}
}
static int install_matcher(char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! matchers[i].name) {
      goto while_break;
    }
    {
    tmp = strcmp(name, (char const   *)matchers[i].name);
    }
    if (tmp == 0) {
      compile = matchers[i].compile;
      execute = matchers[i].execute;
      return (1);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int prepend_args(char const   *options , char *buf , char **argv ) 
{ 
  char const   *o ;
  char *b ;
  int n ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
  o = options;
  b = buf;
  n = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp + (int )((unsigned char )*o)) & 8192)) {
        goto while_break___0;
      }
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (! *o) {
      return (n);
    }
    if (argv) {
      *(argv + n) = b;
    }
    n ++;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      tmp___1 = b;
      b ++;
      tmp___3 = o;
      o ++;
      tmp___2 = (char )*tmp___3;
      *tmp___1 = tmp___2;
      if ((int )tmp___2 == 92) {
        if (*o) {
          tmp___0 = o;
          o ++;
          *(b + -1) = (char )*tmp___0;
        }
      }
      if (*o) {
        {
        tmp___4 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___4 + (int )((unsigned char )*o)) & 8192) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    tmp___5 = b;
    b ++;
    *tmp___5 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
}
}
static void prepend_default_options(char const   *options , int *pargc , char ***pargv ) 
{ 
  char *buf ;
  size_t tmp ;
  char *tmp___0 ;
  int prepended ;
  int tmp___1 ;
  int argc ;
  char * const  *argv ;
  char **pp ;
  char *tmp___2 ;
  char **tmp___3 ;
  char * const  *tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char * const  *tmp___8 ;

  {
  if (options) {
    {
    tmp = strlen(options);
    tmp___0 = xmalloc(tmp + 1UL);
    buf = tmp___0;
    tmp___1 = prepend_args(options, buf, (char **)((void *)0));
    prepended = tmp___1;
    argc = *pargc;
    argv = (char * const  *)*pargv;
    tmp___2 = xmalloc((unsigned long )((prepended + argc) + 1) * sizeof(*pp));
    pp = (char **)tmp___2;
    *pargc = prepended + argc;
    *pargv = pp;
    tmp___3 = pp;
    pp ++;
    tmp___4 = argv;
    argv ++;
    *tmp___3 = (char *)*tmp___4;
    tmp___5 = prepend_args(options, buf, pp);
    pp += tmp___5;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp___6 = pp;
      pp ++;
      tmp___8 = argv;
      argv ++;
      tmp___7 = (char *)*tmp___8;
      *tmp___6 = tmp___7;
      if (! tmp___7) {
        goto while_break;
      }
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char *keys ;
  size_t keycc ;
  size_t oldcc ;
  size_t keyalloc ;
  int with_filenames ;
  int opt ;
  int cc ;
  int status ;
  int default_context ;
  unsigned int digit_args_val ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  FILE *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *file ;
  char *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
  *(argv + 0) = (char *)"target5";
  prog = *(argv + 0);
  if (prog) {
    {
    tmp___0 = strrchr((char const   *)prog, '/');
    }
    if (tmp___0) {
      {
      tmp = strrchr((char const   *)prog, '/');
      prog = tmp + 1;
      }
    }
  }
  {
  keys = (char *)((void *)0);
  keycc = (size_t )0;
  with_filenames = 0;
  eolbyte = (unsigned char )'\n';
  filename_mask = ~ 0;
  out_before = -1;
  out_after = out_before;
  default_context = 0;
  digit_args_val = 0U;
  setlocale(6, "");
  bindtextdomain("grep", "/nfs/spectre/u4/jin/research/experiments/grep/docs/grep_2.4.2/lib/locale");
  textdomain("grep");
  tmp___1 = getenv("GREP_OPTIONS");
  prepend_default_options((char const   *)tmp___1, & argc, & argv);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    opt = getopt_long(argc, (char * const  *)argv, short_options, (struct option  const  *)(long_options),
                      (int *)((void *)0));
    }
    if (! (opt != -1)) {
      goto while_break;
    }
    {
    if (opt == 48) {
      goto case_48;
    }
    if (opt == 49) {
      goto case_48;
    }
    if (opt == 50) {
      goto case_48;
    }
    if (opt == 51) {
      goto case_48;
    }
    if (opt == 52) {
      goto case_48;
    }
    if (opt == 53) {
      goto case_48;
    }
    if (opt == 54) {
      goto case_48;
    }
    if (opt == 55) {
      goto case_48;
    }
    if (opt == 56) {
      goto case_48;
    }
    if (opt == 57) {
      goto case_48;
    }
    if (opt == 65) {
      goto case_65;
    }
    if (opt == 66) {
      goto case_66;
    }
    if (opt == 67) {
      goto case_67;
    }
    if (opt == 69) {
      goto case_69;
    }
    if (opt == 70) {
      goto case_70;
    }
    if (opt == 71) {
      goto case_71;
    }
    if (opt == 72) {
      goto case_72;
    }
    if (opt == 73) {
      goto case_73;
    }
    if (opt == 85) {
      goto case_85;
    }
    if (opt == 117) {
      goto case_117;
    }
    if (opt == 86) {
      goto case_86;
    }
    if (opt == 88) {
      goto case_88;
    }
    if (opt == 97) {
      goto case_97;
    }
    if (opt == 98) {
      goto case_98;
    }
    if (opt == 99) {
      goto case_99;
    }
    if (opt == 100) {
      goto case_100;
    }
    if (opt == 101) {
      goto case_101;
    }
    if (opt == 102) {
      goto case_102;
    }
    if (opt == 104) {
      goto case_104;
    }
    if (opt == 105) {
      goto case_105;
    }
    if (opt == 121) {
      goto case_105;
    }
    if (opt == 76) {
      goto case_76;
    }
    if (opt == 108) {
      goto case_108;
    }
    if (opt == 110) {
      goto case_110;
    }
    if (opt == 113) {
      goto case_113;
    }
    if (opt == 114) {
      goto case_114;
    }
    if (opt == 115) {
      goto case_115;
    }
    if (opt == 118) {
      goto case_118;
    }
    if (opt == 119) {
      goto case_119;
    }
    if (opt == 120) {
      goto case_120;
    }
    if (opt == 90) {
      goto case_90;
    }
    if (opt == 122) {
      goto case_122;
    }
    if (opt == 128) {
      goto case_128;
    }
    if (opt == 0) {
      goto case_0;
    }
    goto switch_default;
    case_48: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_57: /* CIL Label */ 
    digit_args_val = (10U * digit_args_val + (unsigned int )opt) - 48U;
    default_context = (int )digit_args_val;
    goto switch_break;
    case_65: /* CIL Label */ 
    if (optarg) {
      {
      tmp___3 = ck_atoi((char const   *)optarg, & out_after);
      }
      if (tmp___3) {
        {
        tmp___2 = gettext("invalid context length argument");
        fatal((char const   *)tmp___2, 0);
        }
      }
    }
    goto switch_break;
    case_66: /* CIL Label */ 
    if (optarg) {
      {
      tmp___5 = ck_atoi((char const   *)optarg, & out_before);
      }
      if (tmp___5) {
        {
        tmp___4 = gettext("invalid context length argument");
        fatal((char const   *)tmp___4, 0);
        }
      }
    }
    goto switch_break;
    case_67: /* CIL Label */ 
    if (optarg) {
      {
      tmp___7 = ck_atoi((char const   *)optarg, & default_context);
      }
      if (tmp___7) {
        {
        tmp___6 = gettext("invalid context length argument");
        fatal((char const   *)tmp___6, 0);
        }
      }
    } else {
      default_context = 2;
    }
    goto switch_break;
    case_69: /* CIL Label */ 
    {
    setmatcher("egrep");
    }
    goto switch_break;
    case_70: /* CIL Label */ 
    {
    setmatcher("fgrep");
    }
    goto switch_break;
    case_71: /* CIL Label */ 
    {
    setmatcher("grep");
    }
    goto switch_break;
    case_72: /* CIL Label */ 
    with_filenames = 1;
    goto switch_break;
    case_73: /* CIL Label */ 
    binary_files = (enum __anonenum_binary_files_31 )2;
    goto switch_break;
    case_85: /* CIL Label */ 
    goto switch_break;
    case_117: /* CIL Label */ 
    goto switch_break;
    case_86: /* CIL Label */ 
    show_version = 1;
    goto switch_break;
    case_88: /* CIL Label */ 
    {
    setmatcher((char const   *)optarg);
    }
    goto switch_break;
    case_97: /* CIL Label */ 
    binary_files = (enum __anonenum_binary_files_31 )1;
    goto switch_break;
    case_98: /* CIL Label */ 
    out_byte = 1;
    goto switch_break;
    case_99: /* CIL Label */ 
    out_quiet = 1;
    count_matches = 1;
    goto switch_break;
    case_100: /* CIL Label */ 
    {
    tmp___11 = strcmp((char const   *)optarg, "read");
    }
    if (tmp___11 == 0) {
      directories = (enum __anonenum_directories_30 )0;
    } else {
      {
      tmp___10 = strcmp((char const   *)optarg, "skip");
      }
      if (tmp___10 == 0) {
        directories = (enum __anonenum_directories_30 )2;
      } else {
        {
        tmp___9 = strcmp((char const   *)optarg, "recurse");
        }
        if (tmp___9 == 0) {
          directories = (enum __anonenum_directories_30 )1;
        } else {
          {
          tmp___8 = gettext("unknown directories method");
          fatal((char const   *)tmp___8, 0);
          }
        }
      }
    }
    goto switch_break;
    case_101: /* CIL Label */ 
    {
    tmp___12 = strlen((char const   *)optarg);
    cc = (int )tmp___12;
    keys = xrealloc(keys, (keycc + (size_t )cc) + 1UL);
    strcpy((char * __restrict  )(keys + keycc), (char const   * __restrict  )optarg);
    keycc += (size_t )cc;
    tmp___13 = keycc;
    keycc ++;
    *(keys + tmp___13) = (char )'\n';
    }
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    tmp___16 = strcmp((char const   *)optarg, "-");
    }
    if (tmp___16 != 0) {
      {
      tmp___15 = fopen((char const   * __restrict  )optarg, (char const   * __restrict  )"r");
      fp = tmp___15;
      }
    } else {
      fp = stdin;
    }
    if (! fp) {
      {
      tmp___17 = __errno_location();
      fatal((char const   *)optarg, *tmp___17);
      }
    }
    keyalloc = (size_t )1;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (keyalloc <= keycc + 1UL)) {
        goto while_break___0;
      }
      keyalloc *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    keys = xrealloc(keys, keyalloc);
    oldcc = keycc;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___18 = feof(fp);
      }
      if (tmp___18) {
        goto while_break___1;
      } else {
        {
        tmp___19 = fread((void * __restrict  )(keys + keycc), (size_t )1, (keyalloc - 1UL) - keycc,
                         (FILE * __restrict  )fp);
        cc = (int )tmp___19;
        }
        if (! (cc > 0)) {
          goto while_break___1;
        }
      }
      keycc += (size_t )cc;
      if (keycc == keyalloc - 1UL) {
        {
        keyalloc *= 2UL;
        keys = xrealloc(keys, keyalloc);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
      fclose(fp);
      }
    }
    if (oldcc != keycc) {
      if ((int )*(keys + (keycc - 1UL)) != 10) {
        tmp___20 = keycc;
        keycc ++;
        *(keys + tmp___20) = (char )'\n';
      }
    }
    goto switch_break;
    case_104: /* CIL Label */ 
    no_filenames = 1;
    goto switch_break;
    case_105: /* CIL Label */ 
    case_121: /* CIL Label */ 
    match_icase = 1;
    goto switch_break;
    case_76: /* CIL Label */ 
    out_quiet = 1;
    list_files = -1;
    done_on_match = 1;
    goto switch_break;
    case_108: /* CIL Label */ 
    out_quiet = 1;
    list_files = 1;
    done_on_match = 1;
    goto switch_break;
    case_110: /* CIL Label */ 
    out_line = 1;
    goto switch_break;
    case_113: /* CIL Label */ 
    done_on_match = 1;
    out_quiet = 1;
    goto switch_break;
    case_114: /* CIL Label */ 
    directories = (enum __anonenum_directories_30 )1;
    goto switch_break;
    case_115: /* CIL Label */ 
    suppress_errors = 1;
    goto switch_break;
    case_118: /* CIL Label */ 
    out_invert = 1;
    goto switch_break;
    case_119: /* CIL Label */ 
    match_words = 1;
    goto switch_break;
    case_120: /* CIL Label */ 
    match_lines = 1;
    goto switch_break;
    case_90: /* CIL Label */ 
    filename_mask = 0;
    goto switch_break;
    case_122: /* CIL Label */ 
    eolbyte = (unsigned char )'\000';
    goto switch_break;
    case_128: /* CIL Label */ 
    {
    tmp___24 = strcmp((char const   *)optarg, "binary");
    }
    if (tmp___24 == 0) {
      binary_files = (enum __anonenum_binary_files_31 )0;
    } else {
      {
      tmp___23 = strcmp((char const   *)optarg, "text");
      }
      if (tmp___23 == 0) {
        binary_files = (enum __anonenum_binary_files_31 )1;
      } else {
        {
        tmp___22 = strcmp((char const   *)optarg, "without-match");
        }
        if (tmp___22 == 0) {
          binary_files = (enum __anonenum_binary_files_31 )2;
        } else {
          {
          tmp___21 = gettext("unknown binary-files type");
          fatal((char const   *)tmp___21, 0);
          }
        }
      }
    }
    goto switch_break;
    case_0: /* CIL Label */ 
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    usage(2);
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (out_after < 0) {
    out_after = default_context;
  }
  if (out_before < 0) {
    out_before = default_context;
  }
  if (! matcher) {
    matcher = "grep";
  }
  if (show_version) {
    {
    tmp___25 = gettext("%s (GNU grep) %s\n");
    printf((char const   * __restrict  )tmp___25, matcher, "2.4.2");
    printf((char const   * __restrict  )"\n");
    tmp___26 = gettext("Copyright 1988, 1992-1999, 2000 Free Software Foundation, Inc.\n");
    printf((char const   * __restrict  )tmp___26);
    tmp___27 = gettext("This is free software; see the source for copying conditions. There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
    printf((char const   * __restrict  )tmp___27);
    printf((char const   * __restrict  )"\n");
    exit(0);
    }
  }
  if (show_help) {
    {
    usage(0);
    }
  }
  if (keys) {
    if (keycc == 0UL) {
      out_invert ^= 1;
    } else {
      keycc --;
    }
  } else { //Added block
  if (optind < argc) {
    {
    tmp___28 = optind;
    optind ++;
    keys = *(argv + tmp___28);
    keycc = strlen((char const   *)keys);
    }
  } else {
    {
    usage(2);
    }
  }
  }
  {
  tmp___29 = install_matcher(matcher);
  }
  if (! tmp___29) {
    {
    tmp___30 = install_matcher("default");
    }
    if (! tmp___30) {
      {
      abort();
      }
    }
  }
  {
  (*compile)(keys, keycc);
  }
  if (argc - optind > 1) {
    if (! no_filenames) {
      out_file = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (with_filenames) {
    out_file = 1;
  }
  }
  if (optind < argc) {
    status = 1;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
      file = *(argv + optind);
      tmp___33 = strcmp((char const   *)file, "-");
      }
      if (tmp___33 == 0) {
        tmp___32 = (char *)((void *)0);
      } else {
        tmp___32 = file;
      }
      {
      tmp___34 = grepfile((char const   *)tmp___32, & stats_base);
      status &= tmp___34;
      optind ++;
      }
      if (! (optind < argc)) {
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
    status = grepfile((char const   *)((char *)((void *)0)), & stats_base);
    }
  }
  {
  tmp___37 = fclose(stdout);
  }
  if (tmp___37 == -1) {
    {
    tmp___35 = __errno_location();
    tmp___36 = gettext("writing output");
    error((char const   *)tmp___36, *tmp___35);
    }
  }
  if (errseen) {
    tmp___38 = 2;
  } else {
    tmp___38 = status;
  }
  {
  exit(tmp___38);
  }
}
}
reg_syntax_t re_syntax_options  ;
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) ;
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
int re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
int re_search(struct re_pattern_buffer *bufp , char const   *string , int size , int startpos ,
              int range , struct re_registers *regs___0 ) ;
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs___0 ,
                int stop ) ;
int re_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
             struct re_registers *regs___0 ) ;
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
               char const   *string2 , int size2 , int pos , struct re_registers *regs___0 ,
               int stop ) ;
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs___0 ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) ;
int regcomp(regex_t *preg , char const   *pattern , int cflags ) ;
int regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) ;
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) ;
void regfree(regex_t *preg ) ;
void dfasyntax(reg_syntax_t bits , int fold , int eol ) ;
void dfacomp(char *s , size_t len , struct dfa *d , int searchflag ) ;
char *dfaexec(struct dfa *d , char *begin , char *end , int newline___0 , int *count ,
              int *backref ) ;
void dfafree(struct dfa *d ) ;
void dfainit(struct dfa *d ) ;
void dfaparse(char *s , size_t len , struct dfa *d ) ;
void dfaanalyze(struct dfa *d , int searchflag ) ;
void dfastate(int s , struct dfa *d , int *trans___0 ) ;
void dfaerror(char const   *mesg ) ;
static void dfamust(struct dfa *dfa___0 ) ;
static ptr_t xcalloc(size_t n , size_t s ) ;
static ptr_t xmalloc_1(size_t n ) ;
static ptr_t xrealloc_1(ptr_t p , size_t n ) ;
static int tstbit(int b , int *c ) ;
static void setbit(int b , int *c ) ;
static void clrbit(int b , int *c ) ;
static void copyset(int *src , int *dst ) ;
static void zeroset(int *s ) ;
static void notset(int *s ) ;
static int equal(int *s1 , int *s2 ) ;
static int charclass_index(int *s ) ;
static int looking_at(char const   *s ) ;
static token lex(void) ;
static void addtok(token t ) ;
static void atom(void) ;
static int nsubtoks(int tindex ) ;
static void copytoks(int tindex , int ntokens ) ;
static void closure(void) ;
static void branch(void) ;
static void regexp(int toplevel ) ;
static void copy(position_set *src , position_set *dst ) ;
static void insert(position p , position_set *s ) ;
static void merge(position_set *s1 , position_set *s2 , position_set *m ) ;
static void delete(position p , position_set *s ) ;
static int state_index(struct dfa *d , position_set *s , int newline___0 , int letter ) ;
static void build_state(int s , struct dfa *d ) ;
static void build_state_zero(struct dfa *d ) ;
static char *icatalloc(char *old , char *new ) ;
static char *icpyalloc(char *string ) ;
static char *istrstr(char *lookin , char *lookfor ) ;
static void ifree(char *cp ) ;
static void freelist(char **cpp ) ;
static char **enlist(char **cpp , char *new , size_t len ) ;
static char **comsubs(char *left , char *right ) ;
static char **addlists(char **old , char **new ) ;
static char **inboth(char **left , char **right ) ;
static ptr_t xcalloc(size_t n , size_t s ) 
{ 
  ptr_t r ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = calloc(n, s);
  r = tmp;
  }
  if (! r) {
    {
    tmp___0 = gettext("Memory exhausted");
    dfaerror((char const   *)tmp___0);
    }
  }
  return (r);
}
}
static ptr_t xmalloc_1(size_t n ) 
{ 
  ptr_t r ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = malloc(n);
  r = tmp;
  }
  if (! r) {
    {
    tmp___0 = gettext("Memory exhausted");
    dfaerror((char const   *)tmp___0);
    }
  }
  return (r);
}
}
static ptr_t xrealloc_1(ptr_t p , size_t n ) 
{ 
  ptr_t r ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = realloc(p, n);
  r = tmp;
  }
  if (! r) {
    {
    tmp___0 = gettext("Memory exhausted");
    dfaerror((char const   *)tmp___0);
    }
  }
  return (r);
}
}
static int tstbit(int b , int *c ) 
{ 


  {
  return (*(c + (unsigned long )b / (8UL * sizeof(int ))) & (1 << (unsigned long )b % (8UL * sizeof(int ))));
}
}
static void setbit(int b , int *c ) 
{ 


  {
  *(c + (unsigned long )b / (8UL * sizeof(int ))) |= 1 << (unsigned long )b % (8UL * sizeof(int ));
  return;
}
}
static void clrbit(int b , int *c ) 
{ 


  {
  *(c + (unsigned long )b / (8UL * sizeof(int ))) &= ~ (1 << (unsigned long )b % (8UL * sizeof(int )));
  return;
}
}
static void copyset(int *src , int *dst ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
      goto while_break;
    }
    *(dst + i) = *(src + i);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void zeroset(int *s ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
      goto while_break;
    }
    *(s + i) = 0;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void notset(int *s ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
      goto while_break;
    }
    *(s + i) = ~ *(s + i);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int equal(int *s1 , int *s2 ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
      goto while_break;
    }
    if (*(s1 + i) != *(s2 + i)) {
      return (0);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static struct dfa *dfa  ;
static int charclass_index(int *s ) 
{ 
  int i ;
  int tmp ;
  ptr_t tmp___0 ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < dfa->cindex)) {
      goto while_break;
    }
    {
    tmp = equal(s, *(dfa->charclasses + i));
    }
    if (tmp) {
      return (i);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (dfa->cindex >= dfa->calloc) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (dfa->cindex >= dfa->calloc)) {
        goto while_break___0;
      }
      dfa->calloc *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    tmp___0 = xrealloc_1((ptr_t )dfa->charclasses, (unsigned long )dfa->calloc * sizeof(charclass ));
    dfa->charclasses = (charclass *)tmp___0;
    }
  }
  {
  (dfa->cindex) ++;
  copyset(s, *(dfa->charclasses + i));
  }
  return (i);
}
}
static reg_syntax_t syntax_bits  ;
static reg_syntax_t syntax_bits_set  ;
static int case_fold  ;
static unsigned char eolbyte_1  ;
void dfasyntax(reg_syntax_t bits , int fold , int eol ) 
{ 


  {
  syntax_bits_set = (reg_syntax_t )1;
  syntax_bits = bits;
  case_fold = fold;
  eolbyte_1 = (unsigned char )eol;
  return;
}
}
static char *lexstart  ;
static char *lexptr  ;
static int lexleft  ;
static token lasttok  ;
static int laststart  ;
static int parens  ;
static int minrep  ;
static int maxrep  ;
static int is_alpha(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 1024));
}
}
static int is_upper(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 256));
}
}
static int is_lower(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 512));
}
}
static int is_digit(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 2048));
}
}
static int is_xdigit(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 4096));
}
}
static int is_space(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 8192));
}
}
static int is_punct(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 4));
}
}
static int is_alnum(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 8));
}
}
static int is_print(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 16384));
}
}
static int is_graph(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 32768));
}
}
static int is_cntrl(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 2));
}
}
static int is_blank(int c ) 
{ 
  int tmp ;

  {
  if (c == 32) {
    tmp = 1;
  } else { //Added block
  if (c == 9) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
static struct __anonstruct_prednames_38 prednames[13]  = 
  {      {":alpha:]", & is_alpha}, 
        {":upper:]", & is_upper}, 
        {":lower:]", & is_lower}, 
        {":digit:]", & is_digit}, 
        {":xdigit:]", & is_xdigit}, 
        {":space:]", & is_space}, 
        {":punct:]", & is_punct}, 
        {":alnum:]", & is_alnum}, 
        {":print:]", & is_print}, 
        {":graph:]", & is_graph}, 
        {":cntrl:]", & is_cntrl}, 
        {":blank:]", & is_blank}, 
        {(char const   *)0, (int (*)(int  ))0}};
static int looking_at(char const   *s ) 
{ 
  size_t len ;
  int tmp ;

  {
  {
  len = strlen(s);
  }
  if ((size_t )lexleft < len) {
    return (0);
  }
  {
  tmp = strncmp(s, (char const   *)lexptr, len);
  }
  return (tmp == 0);
}
}
static token lex(void) 
{ 
  token c ;
  token c1 ;
  token c2 ;
  int backslash ;
  int invert ;
  charclass ccl ;
  int i ;
  char lo[2] ;
  char hi[2] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int lo___0 ;
  int hi___0 ;
  char const   *p ;
  char const   *lim ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  unsigned short const   **tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int (*pred)() ;
  int tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char ch[2] ;
  int tmp___59 ;
  int tmp___60 ;
  unsigned short const   **tmp___61 ;
  unsigned short const   **tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  unsigned short const   **tmp___68 ;
  int tmp___69 ;
  unsigned short const   **tmp___70 ;

  {
  backslash = 0;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < 2)) {
      goto while_break;
    }
    if (! lexleft) {
      lasttok = (token )-1;
      return (lasttok);
    }
    tmp = lexptr;
    lexptr ++;
    c = (token )((unsigned char )*tmp);
    lexleft --;
    {
    if ((int )c == 92) {
      goto case_92;
    }
    if ((int )c == 94) {
      goto case_94;
    }
    if ((int )c == 36) {
      goto case_36;
    }
    if ((int )c == 49) {
      goto case_49;
    }
    if ((int )c == 50) {
      goto case_49;
    }
    if ((int )c == 51) {
      goto case_49;
    }
    if ((int )c == 52) {
      goto case_49;
    }
    if ((int )c == 53) {
      goto case_49;
    }
    if ((int )c == 54) {
      goto case_49;
    }
    if ((int )c == 55) {
      goto case_49;
    }
    if ((int )c == 56) {
      goto case_49;
    }
    if ((int )c == 57) {
      goto case_49;
    }
    if ((int )c == 96) {
      goto case_96;
    }
    if ((int )c == 39) {
      goto case_39;
    }
    if ((int )c == 60) {
      goto case_60;
    }
    if ((int )c == 62) {
      goto case_62;
    }
    if ((int )c == 98) {
      goto case_98;
    }
    if ((int )c == 66) {
      goto case_66;
    }
    if ((int )c == 63) {
      goto case_63;
    }
    if ((int )c == 42) {
      goto case_42;
    }
    if ((int )c == 43) {
      goto case_43;
    }
    if ((int )c == 123) {
      goto case_123;
    }
    if ((int )c == 124) {
      goto case_124;
    }
    if ((int )c == 10) {
      goto case_10;
    }
    if ((int )c == 40) {
      goto case_40;
    }
    if ((int )c == 41) {
      goto case_41;
    }
    if ((int )c == 46) {
      goto case_46;
    }
    if ((int )c == 119) {
      goto case_119;
    }
    if ((int )c == 87) {
      goto case_119;
    }
    if ((int )c == 91) {
      goto case_91;
    }
    goto normal_char;
    case_92: /* CIL Label */ 
    if (backslash) {
      goto normal_char;
    }
    if (lexleft == 0) {
      {
      tmp___0 = gettext("Unfinished \\ escape");
      dfaerror((char const   *)tmp___0);
      }
    }
    backslash = 1;
    goto switch_break;
    case_94: /* CIL Label */ 
    if (backslash) {
      goto normal_char;
    }
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
      lasttok = (token )258;
      return (lasttok);
    } else { //Added block
    if ((int )lasttok == -1) {
      lasttok = (token )258;
      return (lasttok);
    } else { //Added block
    if ((int )lasttok == 271) {
      lasttok = (token )258;
      return (lasttok);
    } else { //Added block
    if ((int )lasttok == 269) {
      lasttok = (token )258;
      return (lasttok);
    }
    }
    }
    }
    goto normal_char;
    case_36: /* CIL Label */ 
    if (backslash) {
      goto normal_char;
    }
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
      lasttok = (token )259;
      return (lasttok);
    } else { //Added block
    if (lexleft == 0) {
      lasttok = (token )259;
      return (lasttok);
    } else {
      if (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        if (lexleft > 0) {
          if ((int )*lexptr == 41) {
            tmp___1 = 1;
          } else {
            tmp___1 = 0;
          }
        } else {
          tmp___1 = 0;
        }
        tmp___3 = tmp___1;
      } else {
        if (lexleft > 1) {
          if ((int )*(lexptr + 0) == 92) {
            if ((int )*(lexptr + 1) == 41) {
              tmp___2 = 1;
            } else {
              tmp___2 = 0;
            }
          } else {
            tmp___2 = 0;
          }
        } else {
          tmp___2 = 0;
        }
        tmp___3 = tmp___2;
      }
      if (tmp___3) {
        lasttok = (token )259;
        return (lasttok);
      } else {
        if (syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          if (lexleft > 0) {
            if ((int )*lexptr == 124) {
              tmp___4 = 1;
            } else {
              tmp___4 = 0;
            }
          } else {
            tmp___4 = 0;
          }
          tmp___6 = tmp___4;
        } else {
          if (lexleft > 1) {
            if ((int )*(lexptr + 0) == 92) {
              if ((int )*(lexptr + 1) == 124) {
                tmp___5 = 1;
              } else {
                tmp___5 = 0;
              }
            } else {
              tmp___5 = 0;
            }
          } else {
            tmp___5 = 0;
          }
          tmp___6 = tmp___5;
        }
        if (tmp___6) {
          lasttok = (token )259;
          return (lasttok);
        } else { //Added block
        if (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          if (lexleft > 0) {
            if ((int )*lexptr == 10) {
              lasttok = (token )259;
              return (lasttok);
            }
          }
        }
        }
      }
    }
    }
    goto normal_char;
    case_49: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_57: /* CIL Label */ 
    if (backslash) {
      if (! (syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        laststart = 0;
        lasttok = (token )257;
        return (lasttok);
      }
    }
    goto normal_char;
    case_96: /* CIL Label */ 
    if (backslash) {
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        lasttok = (token )258;
        return (lasttok);
      }
    }
    goto normal_char;
    case_39: /* CIL Label */ 
    if (backslash) {
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        lasttok = (token )259;
        return (lasttok);
      }
    }
    goto normal_char;
    case_60: /* CIL Label */ 
    if (backslash) {
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        lasttok = (token )260;
        return (lasttok);
      }
    }
    goto normal_char;
    case_62: /* CIL Label */ 
    if (backslash) {
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        lasttok = (token )261;
        return (lasttok);
      }
    }
    goto normal_char;
    case_98: /* CIL Label */ 
    if (backslash) {
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        lasttok = (token )262;
        return (lasttok);
      }
    }
    goto normal_char;
    case_66: /* CIL Label */ 
    if (backslash) {
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        lasttok = (token )263;
        return (lasttok);
      }
    }
    goto normal_char;
    case_63: /* CIL Label */ 
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
      goto normal_char;
    }
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
      if (laststart) {
        goto normal_char;
      }
    }
    lasttok = (token )264;
    return (lasttok);
    case_42: /* CIL Label */ 
    if (backslash) {
      goto normal_char;
    }
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
      if (laststart) {
        goto normal_char;
      }
    }
    lasttok = (token )265;
    return (lasttok);
    case_43: /* CIL Label */ 
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
      goto normal_char;
    }
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
      if (laststart) {
        goto normal_char;
      }
    }
    lasttok = (token )266;
    return (lasttok);
    case_123: /* CIL Label */ 
    if (! (syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    }
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
      if (laststart) {
        goto normal_char;
      }
    }
    if (syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      lo___0 = -1;
      hi___0 = -1;
      p = (char const   *)lexptr;
      lim = p + lexleft;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if ((unsigned long )p != (unsigned long )lim) {
          if (! ((unsigned int )*p - 48U <= 9U)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        if (lo___0 < 0) {
          tmp___7 = 0;
        } else {
          tmp___7 = lo___0 * 10;
        }
        lo___0 = (tmp___7 + (int )*p) - 48;
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if ((unsigned long )p != (unsigned long )lim) {
        if ((int const   )*p == 44) {
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            p ++;
            if ((unsigned long )p != (unsigned long )lim) {
              if (! ((unsigned int )*p - 48U <= 9U)) {
                goto while_break___1;
              }
            } else {
              goto while_break___1;
            }
            if (hi___0 < 0) {
              tmp___8 = 0;
            } else {
              tmp___8 = hi___0 * 10;
            }
            hi___0 = (tmp___8 + (int )*p) - 48;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
          hi___0 = lo___0;
        }
      } else {
        hi___0 = lo___0;
      }
      if ((unsigned long )p == (unsigned long )lim) {
        goto normal_char;
      } else { //Added block
      if ((int const   )*p != 125) {
        goto normal_char;
      } else { //Added block
      if (lo___0 < 0) {
        goto normal_char;
      } else { //Added block
      if (32767 < hi___0) {
        goto normal_char;
      } else { //Added block
      if (0 <= hi___0) {
        if (hi___0 < lo___0) {
          goto normal_char;
        }
      }
      }
      }
      }
      }
    }
    minrep = 0;
    if (! lexleft) {
      {
      tmp___10 = gettext("unfinished repeat count");
      }
      if ((unsigned long )tmp___10 != (unsigned long )((char *)0)) {
        {
        tmp___9 = gettext("unfinished repeat count");
        dfaerror((char const   *)tmp___9);
        }
      } else {
        lasttok = (token )-1;
        return (lasttok);
      }
    }
    tmp___11 = lexptr;
    lexptr ++;
    c = (token )((unsigned char )*tmp___11);
    lexleft --;
    if ((unsigned int )c - 48U <= 9U) {
      minrep = (int )c - 48;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! lexleft) {
          {
          tmp___13 = gettext("unfinished repeat count");
          }
          if ((unsigned long )tmp___13 != (unsigned long )((char *)0)) {
            {
            tmp___12 = gettext("unfinished repeat count");
            dfaerror((char const   *)tmp___12);
            }
          } else {
            lasttok = (token )-1;
            return (lasttok);
          }
        }
        tmp___14 = lexptr;
        lexptr ++;
        c = (token )((unsigned char )*tmp___14);
        lexleft --;
        if (! ((unsigned int )c - 48U <= 9U)) {
          goto while_break___2;
        }
        minrep = (10 * minrep + (int )c) - 48;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
      tmp___15 = gettext("malformed repeat count");
      dfaerror((char const   *)tmp___15);
      }
    }
    if ((int )c == 44) {
      if (! lexleft) {
        {
        tmp___17 = gettext("unfinished repeat count");
        }
        if ((unsigned long )tmp___17 != (unsigned long )((char *)0)) {
          {
          tmp___16 = gettext("unfinished repeat count");
          dfaerror((char const   *)tmp___16);
          }
        } else {
          lasttok = (token )-1;
          return (lasttok);
        }
      }
      tmp___18 = lexptr;
      lexptr ++;
      c = (token )((unsigned char )*tmp___18);
      lexleft --;
      if (! ((unsigned int )c - 48U <= 9U)) {
        maxrep = -1;
      } else {
        maxrep = (int )c - 48;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (! lexleft) {
            {
            tmp___20 = gettext("unfinished repeat count");
            }
            if ((unsigned long )tmp___20 != (unsigned long )((char *)0)) {
              {
              tmp___19 = gettext("unfinished repeat count");
              dfaerror((char const   *)tmp___19);
              }
            } else {
              lasttok = (token )-1;
              return (lasttok);
            }
          }
          tmp___21 = lexptr;
          lexptr ++;
          c = (token )((unsigned char )*tmp___21);
          lexleft --;
          if (! ((unsigned int )c - 48U <= 9U)) {
            goto while_break___3;
          }
          maxrep = (10 * maxrep + (int )c) - 48;
        }
        while_break___3: /* CIL Label */ ;
        }
        if (0 <= maxrep) {
          if (maxrep < minrep) {
            {
            tmp___22 = gettext("malformed repeat count");
            dfaerror((char const   *)tmp___22);
            }
          }
        }
      }
    } else {
      maxrep = minrep;
    }
    if (! (syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if ((int )c != 92) {
        {
        tmp___23 = gettext("malformed repeat count");
        dfaerror((char const   *)tmp___23);
        }
      }
      if (! lexleft) {
        {
        tmp___25 = gettext("unfinished repeat count");
        }
        if ((unsigned long )tmp___25 != (unsigned long )((char *)0)) {
          {
          tmp___24 = gettext("unfinished repeat count");
          dfaerror((char const   *)tmp___24);
          }
        } else {
          lasttok = (token )-1;
          return (lasttok);
        }
      }
      tmp___26 = lexptr;
      lexptr ++;
      c = (token )((unsigned char )*tmp___26);
      lexleft --;
    }
    if ((int )c != 125) {
      {
      tmp___27 = gettext("malformed repeat count");
      dfaerror((char const   *)tmp___27);
      }
    }
    laststart = 0;
    lasttok = (token )267;
    return (lasttok);
    case_124: /* CIL Label */ 
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    }
    laststart = 1;
    lasttok = (token )269;
    return (lasttok);
    case_10: /* CIL Label */ 
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    } else { //Added block
    if (backslash) {
      goto normal_char;
    } else { //Added block
    if (! (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      goto normal_char;
    }
    }
    }
    laststart = 1;
    lasttok = (token )269;
    return (lasttok);
    case_40: /* CIL Label */ 
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    }
    parens ++;
    laststart = 1;
    lasttok = (token )271;
    return (lasttok);
    case_41: /* CIL Label */ 
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    }
    if (parens == 0) {
      if (syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      }
    }
    parens --;
    laststart = 0;
    lasttok = (token )272;
    return (lasttok);
    case_46: /* CIL Label */ 
    if (backslash) {
      goto normal_char;
    }
    {
    zeroset(ccl);
    notset(ccl);
    }
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      {
      clrbit((int )eolbyte_1, ccl);
      }
    }
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
      clrbit('\000', ccl);
      }
    }
    {
    laststart = 0;
    tmp___28 = charclass_index(ccl);
    lasttok = (token )(273 + tmp___28);
    }
    return (lasttok);
    case_119: /* CIL Label */ 
    case_87: /* CIL Label */ 
    if (! backslash) {
      goto normal_char;
    } else { //Added block
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    }
    {
    zeroset(ccl);
    c2 = (token )0;
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ((int )c2 < 1 << 8)) {
        goto while_break___4;
      }
      {
      tmp___29 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___29 + (int )c2) & 8) {
        {
        setbit((int )c2, ccl);
        }
      } else { //Added block
      if ((int )c2 == 95) {
        {
        setbit((int )c2, ccl);
        }
      }
      }
      c2 = (token )((int )c2 + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
    if ((int )c == 87) {
      {
      notset(ccl);
      }
    }
    {
    laststart = 0;
    tmp___30 = charclass_index(ccl);
    lasttok = (token )(273 + tmp___30);
    }
    return (lasttok);
    case_91: /* CIL Label */ 
    if (backslash) {
      goto normal_char;
    }
    {
    zeroset(ccl);
    }
    if (! lexleft) {
      {
      tmp___32 = gettext("Unbalanced [");
      }
      if ((unsigned long )tmp___32 != (unsigned long )((char *)0)) {
        {
        tmp___31 = gettext("Unbalanced [");
        dfaerror((char const   *)tmp___31);
        }
      } else {
        lasttok = (token )-1;
        return (lasttok);
      }
    }
    tmp___33 = lexptr;
    lexptr ++;
    c = (token )((unsigned char )*tmp___33);
    lexleft --;
    if ((int )c == 94) {
      if (! lexleft) {
        {
        tmp___35 = gettext("Unbalanced [");
        }
        if ((unsigned long )tmp___35 != (unsigned long )((char *)0)) {
          {
          tmp___34 = gettext("Unbalanced [");
          dfaerror((char const   *)tmp___34);
          }
        } else {
          lasttok = (token )-1;
          return (lasttok);
        }
      }
      tmp___36 = lexptr;
      lexptr ++;
      c = (token )((unsigned char )*tmp___36);
      lexleft --;
      invert = 1;
    } else {
      invert = 0;
    }
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if ((int )c == 91) {
        if (syntax_bits & ((1UL << 1) << 1)) {
          c1 = (token )0;
          {
          while (1) {
            while_continue___6: /* CIL Label */ ;
            if (! prednames[c1].name) {
              goto while_break___6;
            }
            {
            tmp___43 = looking_at(prednames[c1].name);
            }
            if (tmp___43) {
              pred = (int (*)())prednames[c1].pred;
              if (case_fold) {
                if ((unsigned long )pred == (unsigned long )(& is_upper)) {
                  pred = (int (*)())(& is_alpha);
                } else { //Added block
                if ((unsigned long )pred == (unsigned long )(& is_lower)) {
                  pred = (int (*)())(& is_alpha);
                }
                }
              }
              c2 = (token )0;
              {
              while (1) {
                while_continue___7: /* CIL Label */ ;
                if (! ((int )c2 < 1 << 8)) {
                  goto while_break___7;
                }
                {
                tmp___37 = (*pred)((int )c2);
                }
                if (tmp___37) {
                  {
                  setbit((int )c2, ccl);
                  }
                }
                c2 = (token )((int )c2 + 1);
              }
              while_break___7: /* CIL Label */ ;
              }
              {
              tmp___38 = strlen(prednames[c1].name);
              lexptr += tmp___38;
              tmp___39 = strlen(prednames[c1].name);
              lexleft = (int )((size_t )lexleft - tmp___39);
              }
              if (! lexleft) {
                {
                tmp___41 = gettext("Unbalanced [");
                }
                if ((unsigned long )tmp___41 != (unsigned long )((char *)0)) {
                  {
                  tmp___40 = gettext("Unbalanced [");
                  dfaerror((char const   *)tmp___40);
                  }
                } else {
                  lasttok = (token )-1;
                  return (lasttok);
                }
              }
              tmp___42 = lexptr;
              lexptr ++;
              c1 = (token )((unsigned char )*tmp___42);
              lexleft --;
              goto skip;
            }
            c1 = (token )((int )c1 + 1);
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
      if ((int )c == 92) {
        if (syntax_bits & 1UL) {
          if (! lexleft) {
            {
            tmp___45 = gettext("Unbalanced [");
            }
            if ((unsigned long )tmp___45 != (unsigned long )((char *)0)) {
              {
              tmp___44 = gettext("Unbalanced [");
              dfaerror((char const   *)tmp___44);
              }
            } else {
              lasttok = (token )-1;
              return (lasttok);
            }
          }
          tmp___46 = lexptr;
          lexptr ++;
          c = (token )((unsigned char )*tmp___46);
          lexleft --;
        }
      }
      if (! lexleft) {
        {
        tmp___48 = gettext("Unbalanced [");
        }
        if ((unsigned long )tmp___48 != (unsigned long )((char *)0)) {
          {
          tmp___47 = gettext("Unbalanced [");
          dfaerror((char const   *)tmp___47);
          }
        } else {
          lasttok = (token )-1;
          return (lasttok);
        }
      }
      tmp___49 = lexptr;
      lexptr ++;
      c1 = (token )((unsigned char )*tmp___49);
      lexleft --;
      if ((int )c1 == 45) {
        if (! lexleft) {
          {
          tmp___51 = gettext("Unbalanced [");
          }
          if ((unsigned long )tmp___51 != (unsigned long )((char *)0)) {
            {
            tmp___50 = gettext("Unbalanced [");
            dfaerror((char const   *)tmp___50);
            }
          } else {
            lasttok = (token )-1;
            return (lasttok);
          }
        }
        tmp___52 = lexptr;
        lexptr ++;
        c2 = (token )((unsigned char )*tmp___52);
        lexleft --;
        if ((int )c2 == 93) {
          lexptr --;
          lexleft ++;
          c2 = c;
        } else {
          if ((int )c2 == 92) {
            if (syntax_bits & 1UL) {
              if (! lexleft) {
                {
                tmp___54 = gettext("Unbalanced [");
                }
                if ((unsigned long )tmp___54 != (unsigned long )((char *)0)) {
                  {
                  tmp___53 = gettext("Unbalanced [");
                  dfaerror((char const   *)tmp___53);
                  }
                } else {
                  lasttok = (token )-1;
                  return (lasttok);
                }
              }
              tmp___55 = lexptr;
              lexptr ++;
              c2 = (token )((unsigned char )*tmp___55);
              lexleft --;
            }
          }
          if (! lexleft) {
            {
            tmp___57 = gettext("Unbalanced [");
            }
            if ((unsigned long )tmp___57 != (unsigned long )((char *)0)) {
              {
              tmp___56 = gettext("Unbalanced [");
              dfaerror((char const   *)tmp___56);
              }
            } else {
              lasttok = (token )-1;
              return (lasttok);
            }
          }
          tmp___58 = lexptr;
          lexptr ++;
          c1 = (token )((unsigned char )*tmp___58);
          lexleft --;
        }
      } else {
        c2 = c;
      }
      lo[0] = (char )c;
      lo[1] = (char )'\000';
      hi[0] = (char )c2;
      hi[1] = (char )'\000';
      c = (token )0;
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        if (! ((int )c < 1 << 8)) {
          goto while_break___8;
        }
        {
        ch[0] = (char )c;
        ch[1] = (char )'\000';
        tmp___63 = strcoll((char const   *)(lo), (char const   *)(ch));
        }
        if (tmp___63 <= 0) {
          {
          tmp___64 = strcoll((char const   *)(ch), (char const   *)(hi));
          }
          if (tmp___64 <= 0) {
            {
            setbit((int )c, ccl);
            }
            if (case_fold) {
              {
              tmp___62 = __ctype_b_loc();
              }
              if ((int const   )*(*tmp___62 + (int )c) & 256) {
                {
                tmp___59 = tolower((int )c);
                setbit(tmp___59, ccl);
                }
              } else {
                {
                tmp___61 = __ctype_b_loc();
                }
                if ((int const   )*(*tmp___61 + (int )c) & 512) {
                  {
                  tmp___60 = toupper((int )c);
                  setbit(tmp___60, ccl);
                  }
                }
              }
            }
          }
        }
        c = (token )((int )c + 1);
      }
      while_break___8: /* CIL Label */ ;
      }
      skip: 
      c = c1;
      if (! ((int )c != 93)) {
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    if (invert) {
      {
      notset(ccl);
      }
      if (syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
        clrbit((int )eolbyte_1, ccl);
        }
      }
    }
    {
    laststart = 0;
    tmp___65 = charclass_index(ccl);
    lasttok = (token )(273 + tmp___65);
    }
    return (lasttok);
    normal_char: 
    switch_default: /* CIL Label */ 
    laststart = 0;
    if (case_fold) {
      {
      tmp___70 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___70 + (int )c) & 1024) {
        {
        zeroset(ccl);
        setbit((int )c, ccl);
        tmp___68 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___68 + (int )c) & 256) {
          {
          tmp___66 = tolower((int )c);
          setbit(tmp___66, ccl);
          }
        } else {
          {
          tmp___67 = toupper((int )c);
          setbit(tmp___67, ccl);
          }
        }
        {
        tmp___69 = charclass_index(ccl);
        lasttok = (token )(273 + tmp___69);
        }
        return (lasttok);
      }
    }
    return (c);
    switch_break: /* CIL Label */ ;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  abort();
  }
  return ((token )-1);
}
}
static token tok  ;
static int depth  ;
static void addtok(token t ) 
{ 
  ptr_t tmp ;
  int tmp___0 ;

  {
  if (dfa->tindex >= dfa->talloc) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (dfa->tindex >= dfa->talloc)) {
        goto while_break;
      }
      dfa->talloc *= 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
    tmp = xrealloc_1((ptr_t )dfa->tokens, (unsigned long )dfa->talloc * sizeof(token ));
    dfa->tokens = (token *)tmp;
    }
  }
  tmp___0 = dfa->tindex;
  (dfa->tindex) ++;
  *(dfa->tokens + tmp___0) = t;
  {
  if ((int )t == 264) {
    goto case_264;
  }
  if ((int )t == 265) {
    goto case_264;
  }
  if ((int )t == 266) {
    goto case_264;
  }
  if ((int )t == 268) {
    goto case_268;
  }
  if ((int )t == 269) {
    goto case_268;
  }
  if ((int )t == 270) {
    goto case_268;
  }
  if ((int )t == 256) {
    goto case_256;
  }
  goto switch_default;
  case_264: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_266: /* CIL Label */ 
  goto switch_break;
  case_268: /* CIL Label */ 
  case_269: /* CIL Label */ 
  case_270: /* CIL Label */ 
  depth --;
  goto switch_break;
  switch_default: /* CIL Label */ 
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
  depth ++;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (depth > dfa->depth) {
    dfa->depth = depth;
  }
  return;
}
}
static void atom(void) 
{ 
  char *tmp ;

  {
  if ((int )tok >= 0) {
    if ((int )tok < 1 << 8) {
      {
      addtok(tok);
      tok = lex();
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )tok >= 273) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 257) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 258) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 259) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 260) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 261) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 262) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 263) {
    {
    addtok(tok);
    tok = lex();
    }
  } else { //Added block
  if ((int )tok == 271) {
    {
    tok = lex();
    regexp(0);
    }
    if ((int )tok != 272) {
      {
      tmp = gettext("Unbalanced (");
      dfaerror((char const   *)tmp);
      }
    }
    {
    tok = lex();
    }
  } else {
    {
    addtok((token )256);
    }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  return;
}
}
static int nsubtoks(int tindex ) 
{ 
  int ntoks1 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  if ((int )*(dfa->tokens + (tindex - 1)) == 264) {
    goto case_264;
  }
  if ((int )*(dfa->tokens + (tindex - 1)) == 265) {
    goto case_264;
  }
  if ((int )*(dfa->tokens + (tindex - 1)) == 266) {
    goto case_264;
  }
  if ((int )*(dfa->tokens + (tindex - 1)) == 268) {
    goto case_268;
  }
  if ((int )*(dfa->tokens + (tindex - 1)) == 269) {
    goto case_268;
  }
  if ((int )*(dfa->tokens + (tindex - 1)) == 270) {
    goto case_268;
  }
  goto switch_default;
  switch_default: /* CIL Label */ 
  return (1);
  case_264: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_266: /* CIL Label */ 
  {
  tmp = nsubtoks(tindex - 1);
  }
  return (1 + tmp);
  case_268: /* CIL Label */ 
  case_269: /* CIL Label */ 
  case_270: /* CIL Label */ 
  {
  ntoks1 = nsubtoks(tindex - 1);
  tmp___0 = nsubtoks((tindex - 1) - ntoks1);
  }
  return ((1 + ntoks1) + tmp___0);
  switch_break: /* CIL Label */ ;
  }
}
}
static void copytoks(int tindex , int ntokens ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < ntokens)) {
      goto while_break;
    }
    {
    addtok(*(dfa->tokens + (tindex + i)));
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void closure(void) 
{ 
  int tindex ;
  int ntokens ;
  int i ;

  {
  {
  atom();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )tok == 264)) {
      if (! ((int )tok == 265)) {
        if (! ((int )tok == 266)) {
          if (! ((int )tok == 267)) {
            goto while_break;
          }
        }
      }
    }
    if ((int )tok == 267) {
      {
      ntokens = nsubtoks(dfa->tindex);
      tindex = dfa->tindex - ntokens;
      }
      if (maxrep < 0) {
        {
        addtok((token )266);
        }
      }
      if (minrep == 0) {
        {
        addtok((token )264);
        }
      }
      i = 1;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i < minrep)) {
          goto while_break___0;
        }
        {
        copytoks(tindex, ntokens);
        addtok((token )268);
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (i < maxrep)) {
          goto while_break___1;
        }
        {
        copytoks(tindex, ntokens);
        addtok((token )264);
        addtok((token )268);
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      tok = lex();
      }
    } else {
      {
      addtok(tok);
      tok = lex();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void branch(void) 
{ 


  {
  {
  closure();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )tok != 272) {
      if ((int )tok != 269) {
        if (! ((int )tok >= 0)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    closure();
    addtok((token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void regexp(int toplevel ) 
{ 


  {
  {
  branch();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )tok == 269)) {
      goto while_break;
    }
    {
    tok = lex();
    branch();
    }
    if (toplevel) {
      {
      addtok((token )270);
      }
    } else {
      {
      addtok((token )269);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void dfaparse(char *s , size_t len , struct dfa *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  dfa = d;
  lexptr = s;
  lexstart = lexptr;
  lexleft = (int )len;
  lasttok = (token )-1;
  laststart = 1;
  parens = 0;
  if (! syntax_bits_set) {
    {
    tmp = gettext("No syntax specified");
    dfaerror((char const   *)tmp);
    }
  }
  {
  tok = lex();
  depth = d->depth;
  regexp(1);
  }
  if ((int )tok != -1) {
    {
    tmp___0 = gettext("Unbalanced )");
    dfaerror((char const   *)tmp___0);
    }
  }
  {
  addtok((token )(-1 - d->nregexps));
  addtok((token )268);
  }
  if (d->nregexps) {
    {
    addtok((token )270);
    }
  }
  (d->nregexps) ++;
  return;
}
}
static void copy(position_set *src , position_set *dst ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < src->nelem)) {
      goto while_break;
    }
    *(dst->elems + i) = *(src->elems + i);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  dst->nelem = src->nelem;
  return;
}
}
static void insert(position p , position_set *s ) 
{ 
  int i ;
  position t1 ;
  position t2 ;
  int tmp ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i < s->nelem) {
      if (! (p.strchr < (s->elems + i)->strchr)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    goto __Cont;
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (i < s->nelem) {
    if (p.strchr == (s->elems + i)->strchr) {
      (s->elems + i)->constraint |= p.constraint;
    } else {
      goto _L;
    }
  } else {
    _L: 
    t1 = p;
    (s->nelem) ++;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i < s->nelem)) {
        goto while_break___0;
      }
      t2 = *(s->elems + i);
      tmp = i;
      i ++;
      *(s->elems + tmp) = t1;
      t1 = t2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
static void merge(position_set *s1 , position_set *s2 , position_set *m ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  i = 0;
  j = 0;
  m->nelem = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i < s1->nelem) {
      if (! (j < s2->nelem)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((s1->elems + i)->strchr > (s2->elems + j)->strchr) {
      tmp = m->nelem;
      (m->nelem) ++;
      tmp___0 = i;
      i ++;
      *(m->elems + tmp) = *(s1->elems + tmp___0);
    } else { //Added block
    if ((s1->elems + i)->strchr < (s2->elems + j)->strchr) {
      tmp___1 = m->nelem;
      (m->nelem) ++;
      tmp___2 = j;
      j ++;
      *(m->elems + tmp___1) = *(s2->elems + tmp___2);
    } else {
      tmp___3 = i;
      i ++;
      *(m->elems + m->nelem) = *(s1->elems + tmp___3);
      tmp___4 = m->nelem;
      (m->nelem) ++;
      tmp___5 = j;
      j ++;
      (m->elems + tmp___4)->constraint |= (s2->elems + tmp___5)->constraint;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < s1->nelem)) {
      goto while_break___0;
    }
    tmp___6 = m->nelem;
    (m->nelem) ++;
    tmp___7 = i;
    i ++;
    *(m->elems + tmp___6) = *(s1->elems + tmp___7);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (j < s2->nelem)) {
      goto while_break___1;
    }
    tmp___8 = m->nelem;
    (m->nelem) ++;
    tmp___9 = j;
    j ++;
    *(m->elems + tmp___8) = *(s2->elems + tmp___9);
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
static void delete(position p , position_set *s ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < s->nelem)) {
      goto while_break;
    }
    if (p.strchr == (s->elems + i)->strchr) {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (i < s->nelem) {
    (s->nelem) --;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i < s->nelem)) {
        goto while_break___0;
      }
      *(s->elems + i) = *(s->elems + (i + 1));
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
static int state_index(struct dfa *d , position_set *s , int newline___0 , int letter ) 
{ 
  int hash ;
  int constraint ;
  int i ;
  int j ;
  ptr_t tmp ;
  ptr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  hash = 0;
  if (newline___0) {
    newline___0 = 1;
  } else {
    newline___0 = 0;
  }
  if (letter) {
    letter = 1;
  } else {
    letter = 0;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < s->nelem)) {
      goto while_break;
    }
    hash = (int )((unsigned int )hash ^ ((s->elems + i)->strchr + (s->elems + i)->constraint));
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < d->sindex)) {
      goto while_break___0;
    }
    if (hash != (d->states + i)->hash) {
      goto __Cont;
    } else { //Added block
    if (s->nelem != (d->states + i)->elems.nelem) {
      goto __Cont;
    } else { //Added block
    if (newline___0 != (int )(d->states + i)->newline) {
      goto __Cont;
    } else { //Added block
    if (letter != (int )(d->states + i)->letter) {
      goto __Cont;
    }
    }
    }
    }
    j = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (j < s->nelem)) {
        goto while_break___1;
      }
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
        goto while_break___1;
      } else { //Added block
      if ((s->elems + j)->strchr != ((d->states + i)->elems.elems + j)->strchr) {
        goto while_break___1;
      }
      }
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (j == s->nelem) {
      return (i);
    }
    __Cont: 
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (d->sindex >= d->salloc) {
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (d->sindex >= d->salloc)) {
        goto while_break___2;
      }
      d->salloc *= 2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    tmp = xrealloc_1((ptr_t )d->states, (unsigned long )d->salloc * sizeof(dfa_state ));
    d->states = (dfa_state *)tmp;
    }
  }
  {
  (d->states + i)->hash = hash;
  tmp___0 = xmalloc_1((unsigned long )s->nelem * sizeof(position ));
  (d->states + i)->elems.elems = (position *)tmp___0;
  copy(s, & (d->states + i)->elems);
  (d->states + i)->newline = (char )newline___0;
  (d->states + i)->letter = (char )letter;
  (d->states + i)->backref = (char)0;
  (d->states + i)->constraint = (unsigned char)0;
  (d->states + i)->first_end = 0;
  j = 0;
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (j < s->nelem)) {
      goto while_break___3;
    }
    if ((int )*(d->tokens + (s->elems + j)->strchr) < 0) {
      constraint = (int )(s->elems + j)->constraint;
      if (newline___0) {
        tmp___1 = 2;
      } else {
        tmp___1 = 0;
      }
      if (constraint & (1 << (tmp___1 + 4))) {
        if (letter) {
          tmp___2 = 2;
        } else {
          tmp___2 = 0;
        }
        if (constraint & (1 << tmp___2)) {
          (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        if (newline___0) {
          tmp___3 = 2;
        } else {
          tmp___3 = 0;
        }
        if (constraint & (1 << (tmp___3 + 4))) {
          if (letter) {
            tmp___4 = 2;
          } else {
            tmp___4 = 0;
          }
          if (constraint & (1 << (tmp___4 + 1))) {
            (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          if (newline___0) {
            tmp___5 = 2;
          } else {
            tmp___5 = 0;
          }
          if (constraint & (1 << ((tmp___5 + 1) + 4))) {
            if (letter) {
              tmp___6 = 2;
            } else {
              tmp___6 = 0;
            }
            if (constraint & (1 << tmp___6)) {
              (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
            } else {
              goto _L;
            }
          } else {
            _L: 
            if (newline___0) {
              tmp___7 = 2;
            } else {
              tmp___7 = 0;
            }
            if (constraint & (1 << ((tmp___7 + 1) + 4))) {
              if (letter) {
                tmp___8 = 2;
              } else {
                tmp___8 = 0;
              }
              if (constraint & (1 << (tmp___8 + 1))) {
                (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
              }
            }
          }
        }
      }
      if (! (d->states + i)->first_end) {
        (d->states + i)->first_end = (int )*(d->tokens + (s->elems + j)->strchr);
      }
    } else { //Added block
    if ((int )*(d->tokens + (s->elems + j)->strchr) == 257) {
      (d->states + i)->constraint = (unsigned char)255;
      (d->states + i)->backref = (char)1;
    }
    }
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  (d->sindex) ++;
  return (i);
}
}
static void epsclosure(position_set *s , struct dfa *d ) 
{ 
  int i ;
  int j ;
  int *visited ;
  position p ;
  position old ;
  ptr_t tmp ;

  {
  {
  tmp = xmalloc_1((unsigned long )d->tindex * sizeof(int ));
  visited = (int *)tmp;
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < d->tindex)) {
      goto while_break;
    }
    *(visited + i) = 0;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < s->nelem)) {
      goto while_break___0;
    }
    if ((int )*(d->tokens + (s->elems + i)->strchr) >= 1 << 8) {
      if ((int )*(d->tokens + (s->elems + i)->strchr) != 257) {
        if ((int )*(d->tokens + (s->elems + i)->strchr) < 273) {
          {
          old = *(s->elems + i);
          p.constraint = old.constraint;
          delete(*(s->elems + i), s);
          }
          if (*(visited + old.strchr)) {
            i --;
            goto __Cont;
          }
          *(visited + old.strchr) = 1;
          {
          if ((int )*(d->tokens + old.strchr) == 258) {
            goto case_258;
          }
          if ((int )*(d->tokens + old.strchr) == 259) {
            goto case_259;
          }
          if ((int )*(d->tokens + old.strchr) == 260) {
            goto case_260;
          }
          if ((int )*(d->tokens + old.strchr) == 261) {
            goto case_261;
          }
          if ((int )*(d->tokens + old.strchr) == 262) {
            goto case_262;
          }
          if ((int )*(d->tokens + old.strchr) == 263) {
            goto case_263;
          }
          goto switch_default;
          case_258: /* CIL Label */ 
          p.constraint &= 207U;
          goto switch_break;
          case_259: /* CIL Label */ 
          p.constraint &= 175U;
          goto switch_break;
          case_260: /* CIL Label */ 
          p.constraint &= 242U;
          goto switch_break;
          case_261: /* CIL Label */ 
          p.constraint &= 244U;
          goto switch_break;
          case_262: /* CIL Label */ 
          p.constraint &= 246U;
          goto switch_break;
          case_263: /* CIL Label */ 
          p.constraint &= 249U;
          goto switch_break;
          switch_default: /* CIL Label */ 
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
          j = 0;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (j < (d->follows + old.strchr)->nelem)) {
              goto while_break___1;
            }
            {
            p.strchr = ((d->follows + old.strchr)->elems + j)->strchr;
            insert(p, s);
            j ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          i = -1;
        }
      }
    }
    __Cont: 
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  free((void *)visited);
  }
  return;
}
}
void dfaanalyze(struct dfa *d , int searchflag ) 
{ 
  int *nullable ;
  int *nfirstpos ;
  position *firstpos ;
  int *nlastpos ;
  position *lastpos ;
  int *nalloc ;
  position_set tmp ;
  position_set merged ;
  int wants_newline ;
  int *o_nullable ;
  int *o_nfirst ;
  int *o_nlast ;
  position *o_firstpos ;
  position *o_lastpos ;
  int i ;
  int j ;
  position *pos ;
  ptr_t tmp___0 ;
  ptr_t tmp___1 ;
  ptr_t tmp___2 ;
  ptr_t tmp___3 ;
  ptr_t tmp___4 ;
  ptr_t tmp___5 ;
  ptr_t tmp___6 ;
  ptr_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  ptr_t tmp___12 ;
  ptr_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  ptr_t tmp___22 ;
  ptr_t tmp___23 ;
  ptr_t tmp___24 ;

  {
  {
  d->searchflag = searchflag;
  tmp___0 = xmalloc_1((unsigned long )d->depth * sizeof(int ));
  nullable = (int *)tmp___0;
  o_nullable = nullable;
  tmp___1 = xmalloc_1((unsigned long )d->depth * sizeof(int ));
  nfirstpos = (int *)tmp___1;
  o_nfirst = nfirstpos;
  tmp___2 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  firstpos = (position *)tmp___2;
  o_firstpos = firstpos;
  firstpos += d->nleaves;
  tmp___3 = xmalloc_1((unsigned long )d->depth * sizeof(int ));
  nlastpos = (int *)tmp___3;
  o_nlast = nlastpos;
  tmp___4 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  lastpos = (position *)tmp___4;
  o_lastpos = lastpos;
  lastpos += d->nleaves;
  tmp___5 = xmalloc_1((unsigned long )d->tindex * sizeof(int ));
  nalloc = (int *)tmp___5;
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < d->tindex)) {
      goto while_break;
    }
    *(nalloc + i) = 0;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___6 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  merged.elems = (position *)tmp___6;
  tmp___7 = xcalloc((size_t )d->tindex, sizeof(position_set ));
  d->follows = (position_set *)tmp___7;
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < d->tindex)) {
      goto while_break___0;
    }
    {
    if ((int )*(d->tokens + i) == 256) {
      goto case_256;
    }
    if ((int )*(d->tokens + i) == 265) {
      goto case_265;
    }
    if ((int )*(d->tokens + i) == 266) {
      goto case_265;
    }
    if ((int )*(d->tokens + i) == 264) {
      goto case_264;
    }
    if ((int )*(d->tokens + i) == 268) {
      goto case_268;
    }
    if ((int )*(d->tokens + i) == 269) {
      goto case_269;
    }
    if ((int )*(d->tokens + i) == 270) {
      goto case_269;
    }
    goto switch_default;
    case_256: /* CIL Label */ 
    tmp___8 = nullable;
    nullable ++;
    *tmp___8 = 1;
    tmp___9 = nfirstpos;
    nfirstpos ++;
    tmp___10 = nlastpos;
    nlastpos ++;
    tmp___11 = 0;
    *tmp___10 = tmp___11;
    *tmp___9 = tmp___11;
    goto switch_break;
    case_265: /* CIL Label */ 
    case_266: /* CIL Label */ 
    tmp.nelem = *(nfirstpos + -1);
    tmp.elems = firstpos;
    pos = lastpos;
    j = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (j < *(nlastpos + -1))) {
        goto while_break___1;
      }
      {
      merge(& tmp, d->follows + (pos + j)->strchr, & merged);
      }
      if (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr)) {
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr))) {
            goto while_break___2;
          }
          *(nalloc + (pos + j)->strchr) *= 2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        tmp___12 = xrealloc_1((ptr_t )(d->follows + (pos + j)->strchr)->elems, (unsigned long )*(nalloc + (pos + j)->strchr) * sizeof(position ));
        (d->follows + (pos + j)->strchr)->elems = (position *)tmp___12;
        }
      }
      {
      copy(& merged, d->follows + (pos + j)->strchr);
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
    if ((int )*(d->tokens + i) != 266) {
      *(nullable + -1) = 1;
    }
    goto switch_break;
    case_268: /* CIL Label */ 
    tmp.nelem = *(nfirstpos + -1);
    tmp.elems = firstpos;
    pos = lastpos + *(nlastpos + -1);
    j = 0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! (j < *(nlastpos + -2))) {
        goto while_break___3;
      }
      {
      merge(& tmp, d->follows + (pos + j)->strchr, & merged);
      }
      if (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr)) {
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          if (! (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr))) {
            goto while_break___4;
          }
          *(nalloc + (pos + j)->strchr) *= 2;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
        tmp___13 = xrealloc_1((ptr_t )(d->follows + (pos + j)->strchr)->elems, (unsigned long )*(nalloc + (pos + j)->strchr) * sizeof(position ));
        (d->follows + (pos + j)->strchr)->elems = (position *)tmp___13;
        }
      }
      {
      copy(& merged, d->follows + (pos + j)->strchr);
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    if (*(nullable + -2)) {
      *(nfirstpos + -2) += *(nfirstpos + -1);
    } else {
      firstpos += *(nfirstpos + -1);
    }
    nfirstpos --;
    if (*(nullable + -1)) {
      *(nlastpos + -2) += *(nlastpos + -1);
    } else {
      pos = lastpos + *(nlastpos + -2);
      j = *(nlastpos + -1) - 1;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! (j >= 0)) {
          goto while_break___5;
        }
        *(pos + j) = *(lastpos + j);
        j --;
      }
      while_break___5: /* CIL Label */ ;
      }
      lastpos += *(nlastpos + -2);
      *(nlastpos + -2) = *(nlastpos + -1);
    }
    nlastpos --;
    if (*(nullable + -1)) {
      if (*(nullable + -2)) {
        tmp___14 = 1;
      } else {
        tmp___14 = 0;
      }
    } else {
      tmp___14 = 0;
    }
    *(nullable + -2) = tmp___14;
    nullable --;
    goto switch_break;
    case_269: /* CIL Label */ 
    case_270: /* CIL Label */ 
    *(nfirstpos + -2) += *(nfirstpos + -1);
    nfirstpos --;
    *(nlastpos + -2) += *(nlastpos + -1);
    nlastpos --;
    if (*(nullable + -1)) {
      tmp___15 = 1;
    } else { //Added block
    if (*(nullable + -2)) {
      tmp___15 = 1;
    } else {
      tmp___15 = 0;
    }
    }
    *(nullable + -2) = tmp___15;
    nullable --;
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    tmp___16 = nullable;
    nullable ++;
    *tmp___16 = (int )*(d->tokens + i) == 257;
    tmp___17 = nfirstpos;
    nfirstpos ++;
    tmp___18 = nlastpos;
    nlastpos ++;
    tmp___19 = 1;
    *tmp___18 = tmp___19;
    *tmp___17 = tmp___19;
    firstpos --;
    lastpos --;
    tmp___20 = (unsigned int )i;
    lastpos->strchr = tmp___20;
    firstpos->strchr = tmp___20;
    tmp___21 = 255U;
    lastpos->constraint = tmp___21;
    firstpos->constraint = tmp___21;
    *(nalloc + i) = 1;
    tmp___22 = xmalloc_1((unsigned long )*(nalloc + i) * sizeof(position ));
    (d->follows + i)->elems = (position *)tmp___22;
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_continue___6: /* CIL Label */ ;
    if (! (i < d->tindex)) {
      goto while_break___6;
    }
    if ((int )*(d->tokens + i) < 1 << 8) {
      goto _L;
    } else { //Added block
    if ((int )*(d->tokens + i) == 257) {
      goto _L;
    } else { //Added block
    if ((int )*(d->tokens + i) >= 273) {
      _L: 
      {
      copy(d->follows + i, & merged);
      epsclosure(& merged, d);
      }
      if ((d->follows + i)->nelem < merged.nelem) {
        {
        tmp___23 = xrealloc_1((ptr_t )(d->follows + i)->elems, (unsigned long )merged.nelem * sizeof(position ));
        (d->follows + i)->elems = (position *)tmp___23;
        }
      }
      {
      copy(& merged, d->follows + i);
      }
    }
    }
    }
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  merged.nelem = 0;
  i = 0;
  {
  while (1) {
    while_continue___7: /* CIL Label */ ;
    if (! (i < *(nfirstpos + -1))) {
      goto while_break___7;
    }
    {
    insert(*(firstpos + i), & merged);
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
  epsclosure(& merged, d);
  wants_newline = 0;
  i = 0;
  }
  {
  while (1) {
    while_continue___8: /* CIL Label */ ;
    if (! (i < merged.nelem)) {
      goto while_break___8;
    }
    if (((merged.elems + i)->constraint & 192U) >> 2 != ((merged.elems + i)->constraint & 48U)) {
      wants_newline = 1;
    }
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
  d->salloc = 1;
  d->sindex = 0;
  tmp___24 = xmalloc_1((unsigned long )d->salloc * sizeof(dfa_state ));
  d->states = (dfa_state *)tmp___24;
  state_index(d, & merged, wants_newline, 0);
  free((void *)o_nullable);
  free((void *)o_nfirst);
  free((void *)o_firstpos);
  free((void *)o_nlast);
  free((void *)o_lastpos);
  free((void *)nalloc);
  free((void *)merged.elems);
  }
  return;
}
}
static charclass letters  ;
static charclass newline  ;
static int initialized  ;
void dfastate(int s , struct dfa *d , int *trans___0 ) 
{ 
  position_set grps[1 << 8] ;
  charclass labels[1 << 8] ;
  int ngrps ;
  position pos ;
  charclass matches ;
  int matchesf ;
  charclass intersect ;
  int intersectf ;
  charclass leftovers ;
  int leftoversf ;
  position_set follows ;
  position_set tmp ;
  int state ;
  int wants_newline ;
  int state_newline ;
  int wants_letter ;
  int state_letter ;
  int i ;
  int j ;
  int k ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int match ;
  int label ;
  int tmp___7 ;
  int tmp___8 ;
  ptr_t tmp___9 ;
  int tmp___10 ;
  ptr_t tmp___11 ;
  ptr_t tmp___12 ;
  ptr_t tmp___13 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int c ;
  unsigned short const   **tmp___17 ;

  {
  ngrps = 0;
  if (! initialized) {
    initialized = 1;
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < 1 << 8)) {
        goto while_break;
      }
      {
      tmp___0 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___0 + i) & 8) {
        {
        setbit(i, letters);
        }
      } else { //Added block
      if (i == 95) {
        {
        setbit(i, letters);
        }
      }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    setbit((int )eolbyte_1, newline);
    }
  }
  {
  zeroset(matches);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < (d->states + s)->elems.nelem)) {
      goto while_break___0;
    }
    pos = *((d->states + s)->elems.elems + i);
    if ((int )*(d->tokens + pos.strchr) >= 0) {
      if ((int )*(d->tokens + pos.strchr) < 1 << 8) {
        {
        setbit((int )*(d->tokens + pos.strchr), matches);
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*(d->tokens + pos.strchr) >= 273) {
      {
      copyset(*(d->charclasses + ((int )*(d->tokens + pos.strchr) - 273)), matches);
      }
    } else {
      goto __Cont;
    }
    }
    if (pos.constraint != 255U) {
      if ((d->states + s)->newline) {
        tmp___1 = 2;
      } else {
        tmp___1 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << ((tmp___1 + 1) + 4)))) {
        {
        clrbit((int )eolbyte_1, matches);
        }
      }
      if ((d->states + s)->newline) {
        tmp___2 = 2;
      } else {
        tmp___2 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << (tmp___2 + 4)))) {
        j = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
            goto while_break___1;
          }
          matches[j] &= newline[j];
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      if ((d->states + s)->letter) {
        tmp___3 = 2;
      } else {
        tmp___3 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << (tmp___3 + 1)))) {
        j = 0;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
            goto while_break___2;
          }
          matches[j] &= ~ letters[j];
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      if ((d->states + s)->letter) {
        tmp___4 = 2;
      } else {
        tmp___4 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << tmp___4))) {
        j = 0;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
            goto while_break___3;
          }
          matches[j] &= letters[j];
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      j = 0;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
          if (! (! matches[j])) {
            goto while_break___4;
          }
        } else {
          goto while_break___4;
        }
        goto __Cont___0;
        __Cont___0: 
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      if ((unsigned long )j == (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
        goto __Cont;
      }
    }
    j = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! (j < ngrps)) {
        goto while_break___5;
      }
      if ((int )*(d->tokens + pos.strchr) >= 0) {
        if ((int )*(d->tokens + pos.strchr) < 1 << 8) {
          {
          tmp___5 = tstbit((int )*(d->tokens + pos.strchr), labels[j]);
          }
          if (! tmp___5) {
            goto __Cont___1;
          }
        }
      }
      intersectf = 0;
      k = 0;
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        if (! ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
          goto while_break___6;
        }
        tmp___6 = matches[k] & labels[j][k];
        intersect[k] = tmp___6;
        if (tmp___6) {
          intersectf = 1;
        }
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      if (! intersectf) {
        goto __Cont___1;
      }
      matchesf = 0;
      leftoversf = matchesf;
      k = 0;
      {
      while (1) {
        while_continue___7: /* CIL Label */ ;
        if (! ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
          goto while_break___7;
        }
        match = matches[k];
        label = labels[j][k];
        tmp___7 = ~ match & label;
        leftovers[k] = tmp___7;
        if (tmp___7) {
          leftoversf = 1;
        }
        tmp___8 = match & ~ label;
        matches[k] = tmp___8;
        if (tmp___8) {
          matchesf = 1;
        }
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      if (leftoversf) {
        {
        copyset(leftovers, labels[ngrps]);
        copyset(intersect, labels[j]);
        tmp___9 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
        grps[ngrps].elems = (position *)tmp___9;
        copy(& grps[j], & grps[ngrps]);
        ngrps ++;
        }
      }
      tmp___10 = grps[j].nelem;
      (grps[j].nelem) ++;
      *(grps[j].elems + tmp___10) = pos;
      if (! matchesf) {
        goto while_break___5;
      }
      __Cont___1: 
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    if (j == ngrps) {
      {
      copyset(matches, labels[ngrps]);
      zeroset(matches);
      tmp___11 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
      grps[ngrps].elems = (position *)tmp___11;
      grps[ngrps].nelem = 1;
      *(grps[ngrps].elems + 0) = pos;
      ngrps ++;
      }
    }
    __Cont: 
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp___12 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  follows.elems = (position *)tmp___12;
  tmp___13 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  tmp.elems = (position *)tmp___13;
  }
  if (d->searchflag) {
    wants_newline = 0;
    wants_letter = 0;
    i = 0;
    {
    while (1) {
      while_continue___8: /* CIL Label */ ;
      if (! (i < (d->states + 0)->elems.nelem)) {
        goto while_break___8;
      }
      if ((((d->states + 0)->elems.elems + i)->constraint & 192U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 48U)) {
        wants_newline = 1;
      }
      if ((((d->states + 0)->elems.elems + i)->constraint & 12U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 3U)) {
        wants_letter = 1;
      }
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
    copy(& (d->states + 0)->elems, & follows);
    state = state_index(d, & follows, 0, 0);
    }
    if (wants_newline) {
      {
      state_newline = state_index(d, & follows, 1, 0);
      }
    } else {
      state_newline = state;
    }
    if (wants_letter) {
      {
      state_letter = state_index(d, & follows, 0, 1);
      }
    } else {
      state_letter = state;
    }
    i = 0;
    {
    while (1) {
      while_continue___9: /* CIL Label */ ;
      if (! (i < 1 << 8)) {
        goto while_break___9;
      }
      {
      tmp___15 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___15 + i) & 8) {
        *(trans___0 + i) = state_letter;
      } else { //Added block
      if (i == 95) {
        *(trans___0 + i) = state_letter;
      } else {
        *(trans___0 + i) = state;
      }
      }
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    *(trans___0 + (int )eolbyte_1) = state_newline;
  } else {
    i = 0;
    {
    while (1) {
      while_continue___10: /* CIL Label */ ;
      if (! (i < 1 << 8)) {
        goto while_break___10;
      }
      *(trans___0 + i) = -1;
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  i = 0;
  {
  while (1) {
    while_continue___11: /* CIL Label */ ;
    if (! (i < ngrps)) {
      goto while_break___11;
    }
    follows.nelem = 0;
    j = 0;
    {
    while (1) {
      while_continue___12: /* CIL Label */ ;
      if (! (j < grps[i].nelem)) {
        goto while_break___12;
      }
      k = 0;
      {
      while (1) {
        while_continue___13: /* CIL Label */ ;
        if (! (k < (d->follows + (grps[i].elems + j)->strchr)->nelem)) {
          goto while_break___13;
        }
        {
        insert(*((d->follows + (grps[i].elems + j)->strchr)->elems + k), & follows);
        k ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    if (d->searchflag) {
      j = 0;
      {
      while (1) {
        while_continue___14: /* CIL Label */ ;
        if (! (j < (d->states + 0)->elems.nelem)) {
          goto while_break___14;
        }
        {
        insert(*((d->states + 0)->elems.elems + j), & follows);
        j ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
    {
    wants_newline = 0;
    tmp___16 = tstbit((int )eolbyte_1, labels[i]);
    }
    if (tmp___16) {
      j = 0;
      {
      while (1) {
        while_continue___15: /* CIL Label */ ;
        if (! (j < follows.nelem)) {
          goto while_break___15;
        }
        if (((follows.elems + j)->constraint & 192U) >> 2 != ((follows.elems + j)->constraint & 48U)) {
          wants_newline = 1;
        }
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
    wants_letter = 0;
    j = 0;
    {
    while (1) {
      while_continue___16: /* CIL Label */ ;
      if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
        goto while_break___16;
      }
      if (labels[i][j] & letters[j]) {
        goto while_break___16;
      }
      j ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
      j = 0;
      {
      while (1) {
        while_continue___17: /* CIL Label */ ;
        if (! (j < follows.nelem)) {
          goto while_break___17;
        }
        if (((follows.elems + j)->constraint & 12U) >> 2 != ((follows.elems + j)->constraint & 3U)) {
          wants_letter = 1;
        }
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
    {
    state = state_index(d, & follows, 0, 0);
    }
    if (wants_newline) {
      {
      state_newline = state_index(d, & follows, 1, 0);
      }
    } else {
      state_newline = state;
    }
    if (wants_letter) {
      {
      state_letter = state_index(d, & follows, 0, 1);
      }
    } else {
      state_letter = state;
    }
    j = 0;
    {
    while (1) {
      while_continue___18: /* CIL Label */ ;
      if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
        goto while_break___18;
      }
      k = 0;
      {
      while (1) {
        while_continue___19: /* CIL Label */ ;
        if (! ((unsigned long )k < 8UL * sizeof(int ))) {
          goto while_break___19;
        }
        if (labels[i][j] & (1 << k)) {
          c = (int )((unsigned long )j * (8UL * sizeof(int )) + (unsigned long )k);
          if (c == (int )eolbyte_1) {
            *(trans___0 + c) = state_newline;
          } else {
            {
            tmp___17 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___17 + c) & 8) {
              *(trans___0 + c) = state_letter;
            } else { //Added block
            if (c == 95) {
              *(trans___0 + c) = state_letter;
            } else { //Added block
            if (c < 1 << 8) {
              *(trans___0 + c) = state;
            }
            }
            }
          }
        }
        k ++;
      }
      while_break___19: /* CIL Label */ ;
      }
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_continue___20: /* CIL Label */ ;
    if (! (i < ngrps)) {
      goto while_break___20;
    }
    {
    free((void *)grps[i].elems);
    i ++;
    }
  }
  while_break___20: /* CIL Label */ ;
  }
  {
  free((void *)follows.elems);
  free((void *)tmp.elems);
  }
  return;
}
}
static void build_state(int s , struct dfa *d ) 
{ 
  int *trans___0 ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ptr_t tmp___5 ;
  int oldalloc ;
  ptr_t tmp___6 ;
  ptr_t tmp___7 ;
  ptr_t tmp___8 ;
  ptr_t tmp___9 ;
  int tmp___10 ;

  {
  if (d->trcount >= 1024) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < d->tralloc)) {
        goto while_break;
      }
      if (*(d->trans + i)) {
        {
        free((ptr_t )*(d->trans + i));
        *(d->trans + i) = (int *)((void *)0);
        }
      } else { //Added block
      if (*(d->fails + i)) {
        {
        free((ptr_t )*(d->fails + i));
        *(d->fails + i) = (int *)((void *)0);
        }
      }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    d->trcount = 0;
  }
  (d->trcount) ++;
  *(d->success + s) = 0;
  if ((d->states + s)->newline) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  if ((int )(d->states + s)->constraint & (1 << ((tmp + 1) + 4))) {
    if ((d->states + s)->letter) {
      tmp___0 = 2;
    } else {
      tmp___0 = 0;
    }
    if ((int )(d->states + s)->constraint & (1 << tmp___0)) {
      *(d->success + s) |= 4;
    }
  }
  if ((d->states + s)->newline) {
    tmp___1 = 2;
  } else {
    tmp___1 = 0;
  }
  if ((int )(d->states + s)->constraint & (1 << (tmp___1 + 4))) {
    if ((d->states + s)->letter) {
      tmp___2 = 2;
    } else {
      tmp___2 = 0;
    }
    if ((int )(d->states + s)->constraint & (1 << (tmp___2 + 1))) {
      *(d->success + s) |= 2;
    }
  }
  if ((d->states + s)->newline) {
    tmp___3 = 2;
  } else {
    tmp___3 = 0;
  }
  if ((int )(d->states + s)->constraint & (1 << (tmp___3 + 4))) {
    if ((d->states + s)->letter) {
      tmp___4 = 2;
    } else {
      tmp___4 = 0;
    }
    if ((int )(d->states + s)->constraint & (1 << tmp___4)) {
      *(d->success + s) |= 1;
    }
  }
  {
  tmp___5 = xmalloc_1((unsigned long )(1 << 8) * sizeof(int ));
  trans___0 = (int *)tmp___5;
  dfastate(s, d, trans___0);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < 1 << 8)) {
      goto while_break___0;
    }
    if (*(trans___0 + i) >= d->tralloc) {
      oldalloc = d->tralloc;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (*(trans___0 + i) >= d->tralloc)) {
          goto while_break___1;
        }
        d->tralloc *= 2;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      tmp___6 = xrealloc_1((ptr_t )d->realtrans, (unsigned long )(d->tralloc + 1) * sizeof(int *));
      d->realtrans = (int **)tmp___6;
      d->trans = d->realtrans + 1;
      tmp___7 = xrealloc_1((ptr_t )d->fails, (unsigned long )d->tralloc * sizeof(int *));
      d->fails = (int **)tmp___7;
      tmp___8 = xrealloc_1((ptr_t )d->success, (unsigned long )d->tralloc * sizeof(int ));
      d->success = (int *)tmp___8;
      tmp___9 = xrealloc_1((ptr_t )d->newlines, (unsigned long )d->tralloc * sizeof(int ));
      d->newlines = (int *)tmp___9;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (oldalloc < d->tralloc)) {
          goto while_break___2;
        }
        *(d->trans + oldalloc) = (int *)((void *)0);
        tmp___10 = oldalloc;
        oldalloc ++;
        *(d->fails + tmp___10) = (int *)((void *)0);
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *(d->newlines + s) = *(trans___0 + (int )eolbyte_1);
  *(trans___0 + (int )eolbyte_1) = -1;
  if ((d->states + s)->constraint) {
    *(d->fails + s) = trans___0;
  } else {
    *(d->trans + s) = trans___0;
  }
  return;
}
}
static void build_state_zero(struct dfa *d ) 
{ 
  ptr_t tmp ;
  ptr_t tmp___0 ;
  ptr_t tmp___1 ;
  ptr_t tmp___2 ;

  {
  {
  d->tralloc = 1;
  d->trcount = 0;
  tmp = xcalloc((size_t )(d->tralloc + 1), sizeof(int *));
  d->realtrans = (int **)tmp;
  d->trans = d->realtrans + 1;
  tmp___0 = xcalloc((size_t )d->tralloc, sizeof(int *));
  d->fails = (int **)tmp___0;
  tmp___1 = xmalloc_1((unsigned long )d->tralloc * sizeof(int ));
  d->success = (int *)tmp___1;
  tmp___2 = xmalloc_1((unsigned long )d->tralloc * sizeof(int ));
  d->newlines = (int *)tmp___2;
  build_state(0, d);
  }
  return;
}
}
static int sbit[256]  ;
static int sbit_init  ;
char *dfaexec(struct dfa *d , char *begin , char *end , int newline___0 , int *count ,
              int *backref ) 
{ 
  register int s ;
  register int s1 ;
  register int tmp ;
  register unsigned char *p ;
  register int **trans___0 ;
  register int *t ;
  register unsigned char eol ;
  int i ;
  unsigned short const   **tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;

  {
  eol = eolbyte_1;
  if (! sbit_init) {
    sbit_init = 1;
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < 1 << 8)) {
        goto while_break;
      }
      {
      tmp___1 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___1 + i) & 8) {
        sbit[i] = 2;
      } else { //Added block
      if (i == 95) {
        sbit[i] = 2;
      } else {
        sbit[i] = 1;
      }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    sbit[eol] = 4;
  }
  if (! d->tralloc) {
    {
    build_state_zero(d);
    }
  }
  s1 = 0;
  s = s1;
  p = (unsigned char *)begin;
  trans___0 = d->trans;
  *end = (char )eol;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      t = *(trans___0 + s);
      if (! ((unsigned long )t != (unsigned long )((int *)0))) {
        goto while_break___1;
      }
      tmp___2 = p;
      p ++;
      s1 = *(t + (int )*tmp___2);
      t = *(trans___0 + s1);
      if ((unsigned long )t == (unsigned long )((int *)0)) {
        tmp = s;
        s = s1;
        s1 = tmp;
        goto while_break___1;
      }
      tmp___3 = p;
      p ++;
      s = *(t + (int )*tmp___3);
    }
    while_break___1: /* CIL Label */ ;
    }
    if (s >= 0) {
      if ((unsigned long )p <= (unsigned long )((unsigned char *)end)) {
        if (*(d->fails + s)) {
          if (*(d->success + s) & sbit[*p]) {
            if (backref) {
              *backref = (int )(d->states + s)->backref != 0;
            }
            return ((char *)p);
          }
          s1 = s;
          tmp___4 = p;
          p ++;
          s = *(*(d->fails + s) + (int )*tmp___4);
          goto __Cont;
        }
      }
    }
    if (count) {
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
        if ((int )*(p + -1) == (int )eol) {
          (*count) ++;
        }
      }
    }
    if ((unsigned long )((char *)p) > (unsigned long )end) {
      return ((char *)((void *)0));
    }
    if (s >= 0) {
      {
      build_state(s, d);
      trans___0 = d->trans;
      }
      goto __Cont;
    }
    if ((int )*(p + -1) == (int )eol) {
      if (newline___0) {
        s = *(d->newlines + s1);
        goto __Cont;
      }
    }
    s = 0;
    __Cont: ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
void dfainit(struct dfa *d ) 
{ 
  ptr_t tmp ;
  ptr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  d->calloc = 1;
  tmp = xmalloc_1((unsigned long )d->calloc * sizeof(charclass ));
  d->charclasses = (charclass *)tmp;
  d->cindex = 0;
  d->talloc = 1;
  tmp___0 = xmalloc_1((unsigned long )d->talloc * sizeof(token ));
  d->tokens = (token *)tmp___0;
  tmp___3 = 0;
  d->nregexps = tmp___3;
  tmp___2 = tmp___3;
  d->nleaves = tmp___2;
  tmp___1 = tmp___2;
  d->depth = tmp___1;
  d->tindex = tmp___1;
  d->searchflag = 0;
  d->tralloc = 0;
  d->musts = (struct dfamust *)0;
  }
  return;
}
}
void dfacomp(char *s , size_t len , struct dfa *d , int searchflag ) 
{ 
  char *lcopy ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (case_fold) {
    {
    tmp = malloc(len);
    lcopy = (char *)tmp;
    }
    if (! lcopy) {
      {
      tmp___0 = gettext("out of memory");
      dfaerror((char const   *)tmp___0);
      }
    }
    case_fold = 0;
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((size_t )i < len)) {
        goto while_break;
      }
      {
      tmp___2 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___2 + (int )((unsigned char )*(s + i))) & 256) {
        {
        tmp___1 = tolower((int )((unsigned char )*(s + i)));
        *(lcopy + i) = (char )tmp___1;
        }
      } else {
        *(lcopy + i) = *(s + i);
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    dfainit(d);
    dfaparse(lcopy, len, d);
    free((void *)lcopy);
    dfamust(d);
    tmp___6 = 0;
    d->nregexps = tmp___6;
    tmp___5 = tmp___6;
    d->nleaves = tmp___5;
    tmp___4 = tmp___5;
    d->depth = tmp___4;
    tmp___3 = tmp___4;
    d->tindex = tmp___3;
    d->cindex = tmp___3;
    case_fold = 1;
    dfaparse(s, len, d);
    dfaanalyze(d, searchflag);
    }
  } else {
    {
    dfainit(d);
    dfaparse(s, len, d);
    dfamust(d);
    dfaanalyze(d, searchflag);
    }
  }
  return;
}
}
void dfafree(struct dfa *d ) 
{ 
  int i ;
  struct dfamust *dm ;
  struct dfamust *ndm ;

  {
  {
  free((ptr_t )d->charclasses);
  free((ptr_t )d->tokens);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < d->sindex)) {
      goto while_break;
    }
    {
    free((ptr_t )(d->states + i)->elems.elems);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((ptr_t )d->states);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < d->tindex)) {
      goto while_break___0;
    }
    if ((d->follows + i)->elems) {
      {
      free((ptr_t )(d->follows + i)->elems);
      }
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  free((ptr_t )d->follows);
  i = 0;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (i < d->tralloc)) {
      goto while_break___1;
    }
    if (*(d->trans + i)) {
      {
      free((ptr_t )*(d->trans + i));
      }
    } else { //Added block
    if (*(d->fails + i)) {
      {
      free((ptr_t )*(d->fails + i));
      }
    }
    }
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  if (d->realtrans) {
    {
    free((ptr_t )d->realtrans);
    }
  }
  if (d->fails) {
    {
    free((ptr_t )d->fails);
    }
  }
  if (d->newlines) {
    {
    free((ptr_t )d->newlines);
    }
  }
  if (d->success) {
    {
    free((ptr_t )d->success);
    }
  }
  dm = d->musts;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! dm) {
      goto while_break___2;
    }
    {
    ndm = dm->next;
    free((void *)dm->must);
    free((ptr_t )dm);
    dm = ndm;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
static char *icatalloc(char *old , char *new ) 
{ 
  char *result ;
  size_t oldsize ;
  size_t newsize ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    newsize = (size_t )0;
  } else {
    {
    tmp = strlen((char const   *)new);
    newsize = tmp;
    }
  }
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    oldsize = (size_t )0;
  } else { //Added block
  if (newsize == 0UL) {
    return (old);
  } else {
    {
    oldsize = strlen((char const   *)old);
    }
  }
  }
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    {
    tmp___0 = malloc(newsize + 1UL);
    result = (char *)tmp___0;
    }
  } else {
    {
    tmp___1 = realloc((void *)old, (oldsize + newsize) + 1UL);
    result = (char *)tmp___1;
    }
  }
  if ((unsigned long )result != (unsigned long )((void *)0)) {
    if ((unsigned long )new != (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )(result + oldsize), (char const   * __restrict  )new);
      }
    }
  }
  return (result);
}
}
static char *icpyalloc(char *string ) 
{ 
  char *tmp ;

  {
  {
  tmp = icatalloc((char *)((void *)0), string);
  }
  return (tmp);
}
}
static char *istrstr(char *lookin , char *lookfor ) 
{ 
  char *cp ;
  size_t len ;
  int tmp ;

  {
  {
  len = strlen((char const   *)lookfor);
  cp = lookin;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*cp != 0)) {
      goto while_break;
    }
    {
    tmp = strncmp((char const   *)cp, (char const   *)lookfor, len);
    }
    if (tmp == 0) {
      return (cp);
    }
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char *)((void *)0));
}
}
static void ifree(char *cp ) 
{ 


  {
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
    free((void *)cp);
    }
  }
  return;
}
}
static void freelist(char **cpp ) 
{ 
  int i ;

  {
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    free((void *)*(cpp + i));
    *(cpp + i) = (char *)((void *)0);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  {
  new = icpyalloc(new);
  }
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
    freelist(cpp);
    }
    return ((char **)((void *)0));
  }
  *(new + len) = (char )'\000';
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = istrstr(*(cpp + i), new);
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
      free((void *)new);
      }
      return (cpp);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  j = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    tmp___0 = istrstr(new, *(cpp + j));
    }
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      j ++;
    } else {
      {
      free((void *)*(cpp + j));
      i --;
      }
      if (i == j) {
        goto while_break___0;
      }
      *(cpp + j) = *(cpp + i);
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp___1 = realloc((void *)((char *)cpp), (unsigned long )(i + 2) * sizeof(*cpp));
  cpp = (char **)tmp___1;
  }
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  *(cpp + i) = new;
  *(cpp + (i + 1)) = (char *)((void *)0);
  return (cpp);
}
}
static char **comsubs(char *left , char *right ) 
{ 
  char **cpp ;
  char *lcp ;
  char *rcp ;
  size_t i ;
  size_t len ;
  void *tmp ;

  {
  if ((unsigned long )left == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  } else { //Added block
  if ((unsigned long )right == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  }
  {
  tmp = malloc(sizeof(*cpp));
  cpp = (char **)tmp;
  }
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  *(cpp + 0) = (char *)((void *)0);
  lcp = left;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*lcp != 0)) {
      goto while_break;
    }
    {
    len = (size_t )0;
    rcp = strchr((char const   *)right, (int )*lcp);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      i = (size_t )1;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if ((int )*(lcp + i) != 0) {
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        goto __Cont;
        __Cont: 
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      if (i > len) {
        len = i;
      }
      {
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (len == 0UL) {
      goto __Cont___0;
    }
    {
    cpp = enlist(cpp, lcp, len);
    }
    if ((unsigned long )cpp == (unsigned long )((void *)0)) {
      goto while_break;
    }
    __Cont___0: 
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (cpp);
}
}
static char **addlists(char **old , char **new ) 
{ 
  int i ;
  size_t tmp ;

  {
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  } else { //Added block
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )*(new + i) != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = strlen((char const   *)*(new + i));
    old = enlist(old, *(new + i), tmp);
    }
    if ((unsigned long )old == (unsigned long )((void *)0)) {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (old);
}
}
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  char **temp ;
  int lnum ;
  int rnum ;
  void *tmp ;

  {
  if ((unsigned long )left == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  } else { //Added block
  if ((unsigned long )right == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  }
  {
  tmp = malloc(sizeof(*both));
  both = (char **)tmp;
  }
  if ((unsigned long )both == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  *(both + 0) = (char *)((void *)0);
  lnum = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
      goto while_break;
    }
    rnum = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      temp = comsubs(*(left + lnum), *(right + rnum));
      }
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
        freelist(both);
        }
        return ((char **)((void *)0));
      }
      {
      both = addlists(both, temp);
      freelist(temp);
      free((void *)temp);
      }
      if ((unsigned long )both == (unsigned long )((void *)0)) {
        return ((char **)((void *)0));
      }
      rnum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (both);
}
}
static void resetmust(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
  tmp___0 = (char )'\000';
  *(mp->is + 0) = tmp___0;
  tmp = tmp___0;
  *(mp->right + 0) = tmp;
  *(mp->left + 0) = tmp;
  freelist(mp->in);
  }
  return;
}
}
static must must0  ;
static char empty_string[1]  = {      (char )'\000'};
static void dfamust(struct dfa *dfa___0 ) 
{ 
  must *musts ;
  must *mp ;
  char *result ;
  int ri ;
  int i ;
  int exact ;
  token t ;
  struct dfamust *dm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  char **new ;
  must *lmp ;
  must *rmp ;
  int j ;
  int ln ;
  int rn ;
  int n ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  must *lmp___0 ;
  must *rmp___0 ;
  char *tp ;
  size_t tmp___12 ;
  char tmp___13 ;
  char tmp___14 ;
  char tmp___15 ;
  char tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;

  {
  {
  result = empty_string;
  exact = 0;
  tmp = malloc((unsigned long )(dfa___0->tindex + 1) * sizeof(*musts));
  musts = (must *)tmp;
  }
  if ((unsigned long )musts == (unsigned long )((void *)0)) {
    return;
  }
  mp = musts;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= dfa___0->tindex)) {
      goto while_break;
    }
    *(mp + i) = must0;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i <= dfa___0->tindex)) {
      goto while_break___0;
    }
    {
    tmp___0 = malloc(sizeof(*((mp + i)->in)));
    (mp + i)->in = (char **)tmp___0;
    tmp___1 = malloc((size_t )2);
    (mp + i)->left = (char *)tmp___1;
    tmp___2 = malloc((size_t )2);
    (mp + i)->right = (char *)tmp___2;
    tmp___3 = malloc((size_t )2);
    (mp + i)->is = (char *)tmp___3;
    }
    if ((unsigned long )(mp + i)->in == (unsigned long )((void *)0)) {
      goto done;
    } else { //Added block
    if ((unsigned long )(mp + i)->left == (unsigned long )((void *)0)) {
      goto done;
    } else { //Added block
    if ((unsigned long )(mp + i)->right == (unsigned long )((void *)0)) {
      goto done;
    } else { //Added block
    if ((unsigned long )(mp + i)->is == (unsigned long )((void *)0)) {
      goto done;
    }
    }
    }
    }
    tmp___5 = (char )'\000';
    *((mp + i)->is + 0) = tmp___5;
    tmp___4 = tmp___5;
    *((mp + i)->right + 0) = tmp___4;
    *((mp + i)->left + 0) = tmp___4;
    *((mp + i)->in + 0) = (char *)((void *)0);
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  ri = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (ri < dfa___0->tindex)) {
      goto while_break___1;
    }
    t = *(dfa___0->tokens + ri);
    {
    if ((int )t == 271) {
      goto case_271;
    }
    if ((int )t == 272) {
      goto case_271;
    }
    if ((int )t == 256) {
      goto case_256;
    }
    if ((int )t == 258) {
      goto case_256;
    }
    if ((int )t == 259) {
      goto case_256;
    }
    if ((int )t == 260) {
      goto case_256;
    }
    if ((int )t == 261) {
      goto case_256;
    }
    if ((int )t == 262) {
      goto case_256;
    }
    if ((int )t == 263) {
      goto case_256;
    }
    if ((int )t == 257) {
      goto case_256;
    }
    if ((int )t == 265) {
      goto case_265;
    }
    if ((int )t == 264) {
      goto case_265;
    }
    if ((int )t == 269) {
      goto case_269;
    }
    if ((int )t == 270) {
      goto case_269;
    }
    if ((int )t == 266) {
      goto case_266;
    }
    if ((int )t == -1) {
      goto case_neg_1;
    }
    if ((int )t == 268) {
      goto case_268;
    }
    goto switch_default;
    case_271: /* CIL Label */ 
    case_272: /* CIL Label */ 
    goto done;
    case_256: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_259: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_257: /* CIL Label */ 
    {
    resetmust(mp);
    }
    goto switch_break;
    case_265: /* CIL Label */ 
    case_264: /* CIL Label */ 
    if ((unsigned long )mp <= (unsigned long )musts) {
      goto done;
    }
    {
    mp --;
    resetmust(mp);
    }
    goto switch_break;
    case_269: /* CIL Label */ 
    case_270: /* CIL Label */ 
    if ((unsigned long )mp < (unsigned long )(musts + 2)) {
      goto done;
    }
    {
    mp --;
    rmp = mp;
    mp --;
    lmp = mp;
    tmp___6 = strcmp((char const   *)lmp->is, (char const   *)rmp->is);
    }
    if (tmp___6 != 0) {
      *(lmp->is + 0) = (char )'\000';
    }
    i = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if ((int )*(lmp->left + i) != 0) {
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    *(lmp->left + i) = (char )'\000';
    tmp___7 = strlen((char const   *)lmp->right);
    ln = (int )tmp___7;
    tmp___8 = strlen((char const   *)rmp->right);
    rn = (int )tmp___8;
    n = ln;
    }
    if (n > rn) {
      n = rn;
    }
    i = 0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! (i < n)) {
        goto while_break___3;
      }
      if ((int )*(lmp->right + ((ln - i) - 1)) != (int )*(rmp->right + ((rn - i) - 1))) {
        goto while_break___3;
      }
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    j = 0;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! (j < i)) {
        goto while_break___4;
      }
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    *(lmp->right + j) = (char )'\000';
    new = inboth(lmp->in, rmp->in);
    }
    if ((unsigned long )new == (unsigned long )((void *)0)) {
      goto done;
    }
    {
    freelist(lmp->in);
    free((void *)((char *)lmp->in));
    lmp->in = new;
    }
    goto switch_break;
    case_266: /* CIL Label */ 
    if ((unsigned long )mp <= (unsigned long )musts) {
      goto done;
    }
    mp --;
    *(mp->is + 0) = (char )'\000';
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    if ((unsigned long )mp != (unsigned long )(musts + 1)) {
      goto done;
    }
    i = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! ((unsigned long )*((musts + 0)->in + i) != (unsigned long )((void *)0))) {
        goto while_break___5;
      }
      {
      tmp___9 = strlen((char const   *)*((musts + 0)->in + i));
      tmp___10 = strlen((char const   *)result);
      }
      if (tmp___9 > tmp___10) {
        result = *((musts + 0)->in + i);
      }
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
    tmp___11 = strcmp((char const   *)result, (char const   *)(musts + 0)->is);
    }
    if (tmp___11 == 0) {
      exact = 1;
    }
    goto done;
    case_268: /* CIL Label */ 
    if ((unsigned long )mp < (unsigned long )(musts + 2)) {
      goto done;
    }
    {
    mp --;
    rmp___0 = mp;
    mp --;
    lmp___0 = mp;
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
    if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
      goto done;
    }
    if ((int )*(lmp___0->right + 0) != 0) {
      if ((int )*(rmp___0->left + 0) != 0) {
        {
        tp = icpyalloc(lmp___0->right);
        }
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
          goto done;
        }
        {
        tp = icatalloc(tp, rmp___0->left);
        }
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
          goto done;
        }
        {
        tmp___12 = strlen((char const   *)tp);
        lmp___0->in = enlist(lmp___0->in, tp, tmp___12);
        free((void *)tp);
        }
        if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
          goto done;
        }
      }
    }
    if ((int )*(lmp___0->is + 0) != 0) {
      {
      lmp___0->left = icatalloc(lmp___0->left, rmp___0->left);
      }
      if ((unsigned long )lmp___0->left == (unsigned long )((void *)0)) {
        goto done;
      }
    }
    if ((int )*(rmp___0->is + 0) == 0) {
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
    lmp___0->right = icatalloc(lmp___0->right, rmp___0->right);
    }
    if ((unsigned long )lmp___0->right == (unsigned long )((void *)0)) {
      goto done;
    }
    if ((int )*(lmp___0->is + 0) != 0) {
      if ((int )*(rmp___0->is + 0) != 0) {
        {
        lmp___0->is = icatalloc(lmp___0->is, rmp___0->is);
        }
        if ((unsigned long )lmp___0->is == (unsigned long )((void *)0)) {
          goto done;
        }
      } else {
        *(lmp___0->is + 0) = (char )'\000';
      }
    } else {
      *(lmp___0->is + 0) = (char )'\000';
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    if ((int )t < -1) {
      goto done;
    } else { //Added block
    if ((int )t == 0) {
      goto done;
    } else { //Added block
    if ((int )t >= 273) {
      {
      resetmust(mp);
      }
    } else {
      {
      resetmust(mp);
      tmp___14 = (char )t;
      *(mp->right + 0) = tmp___14;
      tmp___13 = tmp___14;
      *(mp->left + 0) = tmp___13;
      *(mp->is + 0) = tmp___13;
      tmp___16 = (char )'\000';
      *(mp->right + 1) = tmp___16;
      tmp___15 = tmp___16;
      *(mp->left + 1) = tmp___15;
      *(mp->is + 1) = tmp___15;
      mp->in = enlist(mp->in, mp->is, (size_t )1);
      }
      if ((unsigned long )mp->in == (unsigned long )((void *)0)) {
        goto done;
      }
    }
    }
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    mp ++;
    ri ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
  {
  tmp___20 = strlen((char const   *)result);
  }
  if (tmp___20) {
    {
    tmp___17 = malloc(sizeof(struct dfamust ));
    dm = (struct dfamust *)tmp___17;
    dm->exact = exact;
    tmp___18 = strlen((char const   *)result);
    tmp___19 = malloc(tmp___18 + 1UL);
    dm->must = (char *)tmp___19;
    strcpy((char * __restrict  )dm->must, (char const   * __restrict  )result);
    dm->next = dfa___0->musts;
    dfa___0->musts = dm;
    }
  }
  mp = musts;
  i = 0;
  {
  while (1) {
    while_continue___6: /* CIL Label */ ;
    if (! (i <= dfa___0->tindex)) {
      goto while_break___6;
    }
    {
    freelist((mp + i)->in);
    ifree((char *)(mp + i)->in);
    ifree((mp + i)->left);
    ifree((mp + i)->right);
    ifree((mp + i)->is);
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  free((void *)((char *)mp));
  }
  return;
}
}
kwset_t kwsalloc(char *trans___0 ) ;
char *kwsincr(kwset_t kws , char *text , size_t len ) ;
char *kwsprep(kwset_t kws ) ;
char *kwsexec(kwset_t kws , char *text , size_t size , struct kwsmatch *kwsmatch ) ;
void kwsfree(kwset_t kws ) ;
extern void _obstack_newchunk(struct obstack * , int  ) ;
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
extern void obstack_free(struct obstack *obstack , void *block ) ;
static void enqueue(struct tree *tree , struct trie **last ) ;
static void treefails(struct tree *tree , struct trie *fail , struct trie *recourse ) ;
static void treedelta(struct tree *tree , unsigned int depth___0 , unsigned char *delta ) ;
static int hasevery(struct tree *a , struct tree *b ) ;
static void treenext(struct tree *tree , struct trie **next ) ;
static char *bmexec(kwset_t kws , char *text , size_t size ) ;
static char *cwexec(kwset_t kws , char *text , size_t len , struct kwsmatch *kwsmatch ) ;
kwset_t kwsalloc(char *trans___0 ) 
{ 
  struct kwset *kwset___0 ;
  char *tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
  {
  tmp = xmalloc(sizeof(struct kwset ));
  kwset___0 = (struct kwset *)tmp;
  }
  if (! kwset___0) {
    return ((kwset_t )0);
  }
  {
  _obstack_begin(& kwset___0->obstack, 0, 0, (void *(*)(long  ))(& xmalloc), (void (*)(void * ))(& free));
  kwset___0->words = 0;
  __h = & kwset___0->obstack;
  __o = __h;
  __len = (int )sizeof(struct trie );
  }
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
    _obstack_newchunk(__o, __len);
    }
  }
  __o->next_free += __len;
  __o1 = __h;
  value = (void *)__o1->object_base;
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
    __o1->maybe_empty_object = 1U;
  }
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
    __o1->next_free = __o1->chunk_limit;
  }
  __o1->object_base = __o1->next_free;
  kwset___0->trie = (struct trie *)value;
  if (! kwset___0->trie) {
    {
    kwsfree((kwset_t )kwset___0);
    }
    return ((kwset_t )0);
  }
  (kwset___0->trie)->accepting = 0U;
  (kwset___0->trie)->links = (struct tree *)0;
  (kwset___0->trie)->parent = (struct trie *)0;
  (kwset___0->trie)->next = (struct trie *)0;
  (kwset___0->trie)->fail = (struct trie *)0;
  (kwset___0->trie)->depth = 0;
  (kwset___0->trie)->shift = 0;
  kwset___0->mind = 2147483647;
  kwset___0->maxd = -1;
  kwset___0->target = (char *)0;
  kwset___0->trans = trans___0;
  return ((kwset_t )kwset___0);
}
}
char *kwsincr(kwset_t kws , char *text , size_t len ) 
{ 
  struct kwset *kwset___0 ;
  register struct trie *trie ;
  register unsigned char label ;
  register struct tree *link___0 ;
  register int depth___0 ;
  struct tree *links[12] ;
  enum __anonenum_dirs_40 dirs[12] ;
  struct tree *t ;
  struct tree *r ;
  struct tree *l ;
  struct tree *rl ;
  struct tree *lr ;
  int tmp ;
  int tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;
  char *tmp___1 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *value___0 ;
  char *tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  size_t tmp___5 ;

  {
  kwset___0 = (struct kwset *)kws;
  trie = kwset___0->trie;
  text += len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___5 = len;
    len --;
    if (! tmp___5) {
      goto while_break;
    }
    if (kwset___0->trans) {
      text --;
      label = (unsigned char )*(kwset___0->trans + (int )((unsigned char )*text));
    } else {
      text --;
      label = (unsigned char )*text;
    }
    link___0 = trie->links;
    links[0] = (struct tree *)(& trie->links);
    dirs[0] = (enum __anonenum_dirs_40 )0;
    depth___0 = 1;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (link___0) {
        if (! ((int )label != (int )link___0->label)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      links[depth___0] = link___0;
      if ((int )label < (int )link___0->label) {
        tmp = depth___0;
        depth___0 ++;
        dirs[tmp] = (enum __anonenum_dirs_40 )0;
        link___0 = link___0->llink;
      } else {
        tmp___0 = depth___0;
        depth___0 ++;
        dirs[tmp___0] = (enum __anonenum_dirs_40 )1;
        link___0 = link___0->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (! link___0) {
      __h = & kwset___0->obstack;
      __o = __h;
      __len = (int )sizeof(struct tree );
      if (__o->chunk_limit - __o->next_free < (long )__len) {
        {
        _obstack_newchunk(__o, __len);
        }
      }
      __o->next_free += __len;
      __o1 = __h;
      value = (void *)__o1->object_base;
      if ((unsigned long )__o1->next_free == (unsigned long )value) {
        __o1->maybe_empty_object = 1U;
      }
      __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
        __o1->next_free = __o1->chunk_limit;
      }
      __o1->object_base = __o1->next_free;
      link___0 = (struct tree *)value;
      if (! link___0) {
        {
        tmp___1 = gettext("memory exhausted");
        }
        return (tmp___1);
      }
      link___0->llink = (struct tree *)0;
      link___0->rlink = (struct tree *)0;
      __h___0 = & kwset___0->obstack;
      __o___0 = __h___0;
      __len___0 = (int )sizeof(struct trie );
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      __o___0->next_free += __len___0;
      __o1___0 = __h___0;
      value___0 = (void *)__o1___0->object_base;
      if ((unsigned long )__o1___0->next_free == (unsigned long )value___0) {
        __o1___0->maybe_empty_object = 1U;
      }
      __o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
        __o1___0->next_free = __o1___0->chunk_limit;
      }
      __o1___0->object_base = __o1___0->next_free;
      link___0->trie = (struct trie *)value___0;
      if (! link___0->trie) {
        {
        tmp___2 = gettext("memory exhausted");
        }
        return (tmp___2);
      }
      (link___0->trie)->accepting = 0U;
      (link___0->trie)->links = (struct tree *)0;
      (link___0->trie)->parent = trie;
      (link___0->trie)->next = (struct trie *)0;
      (link___0->trie)->fail = (struct trie *)0;
      (link___0->trie)->depth = trie->depth + 1;
      (link___0->trie)->shift = 0;
      link___0->label = label;
      link___0->balance = (char)0;
      depth___0 --;
      if ((unsigned int )dirs[depth___0] == 0U) {
        (links[depth___0])->llink = link___0;
      } else {
        (links[depth___0])->rlink = link___0;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (depth___0) {
          if (! (! (links[depth___0])->balance)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        if ((unsigned int )dirs[depth___0] == 0U) {
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
        } else {
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
        }
        depth___0 --;
      }
      while_break___1: /* CIL Label */ ;
      }
      if (depth___0) {
        if ((unsigned int )dirs[depth___0] == 0U) {
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
          if ((links[depth___0])->balance) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else { //Added block
        _L___0: 
        if ((unsigned int )dirs[depth___0] == 1U) {
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
          if ((links[depth___0])->balance) {
            _L: 
            {
            if ((int )(links[depth___0])->balance == -2) {
              goto case_neg_2;
            }
            if ((int )(links[depth___0])->balance == 2) {
              goto case_2;
            }
            goto switch_default___1;
            case_neg_2: /* CIL Label */ 
            {
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
              goto case_0;
            }
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
              goto case_1;
            }
            goto switch_default;
            case_0: /* CIL Label */ 
            r = links[depth___0];
            t = r->llink;
            rl = t->rlink;
            t->rlink = r;
            r->llink = rl;
            tmp___3 = (char)0;
            r->balance = tmp___3;
            t->balance = tmp___3;
            goto switch_break___0;
            case_1: /* CIL Label */ 
            r = links[depth___0];
            l = r->llink;
            t = l->rlink;
            rl = t->rlink;
            lr = t->llink;
            t->llink = l;
            l->rlink = lr;
            t->rlink = r;
            r->llink = rl;
            if ((int )t->balance != 1) {
              l->balance = (char)0;
            } else {
              l->balance = (char)-1;
            }
            if ((int )t->balance != -1) {
              r->balance = (char)0;
            } else {
              r->balance = (char)1;
            }
            t->balance = (char)0;
            goto switch_break___0;
            switch_default: /* CIL Label */ 
            {
            abort();
            }
            switch_break___0: /* CIL Label */ ;
            }
            goto switch_break;
            case_2: /* CIL Label */ 
            {
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
              goto case_1___0;
            }
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
              goto case_0___0;
            }
            goto switch_default___0;
            case_1___0: /* CIL Label */ 
            l = links[depth___0];
            t = l->rlink;
            lr = t->llink;
            t->llink = l;
            l->rlink = lr;
            tmp___4 = (char)0;
            l->balance = tmp___4;
            t->balance = tmp___4;
            goto switch_break___1;
            case_0___0: /* CIL Label */ 
            l = links[depth___0];
            r = l->rlink;
            t = r->llink;
            lr = t->llink;
            rl = t->rlink;
            t->llink = l;
            l->rlink = lr;
            t->rlink = r;
            r->llink = rl;
            if ((int )t->balance != 1) {
              l->balance = (char)0;
            } else {
              l->balance = (char)-1;
            }
            if ((int )t->balance != -1) {
              r->balance = (char)0;
            } else {
              r->balance = (char)1;
            }
            t->balance = (char)0;
            goto switch_break___1;
            switch_default___0: /* CIL Label */ 
            {
            abort();
            }
            switch_break___1: /* CIL Label */ ;
            }
            goto switch_break;
            switch_default___1: /* CIL Label */ 
            {
            abort();
            }
            switch_break: /* CIL Label */ ;
            }
            if ((unsigned int )dirs[depth___0 - 1] == 0U) {
              (links[depth___0 - 1])->llink = t;
            } else {
              (links[depth___0 - 1])->rlink = t;
            }
          }
        }
        }
      }
    }
    trie = link___0->trie;
  }
  while_break: /* CIL Label */ ;
  }
  if (! trie->accepting) {
    trie->accepting = (unsigned int )(1 + 2 * kwset___0->words);
  }
  (kwset___0->words) ++;
  if (trie->depth < kwset___0->mind) {
    kwset___0->mind = trie->depth;
  }
  if (trie->depth > kwset___0->maxd) {
    kwset___0->maxd = trie->depth;
  }
  return ((char *)0);
}
}
static void enqueue(struct tree *tree , struct trie **last ) 
{ 
  struct trie *tmp ;

  {
  if (! tree) {
    return;
  }
  {
  enqueue(tree->llink, last);
  enqueue(tree->rlink, last);
  tmp = tree->trie;
  (*last)->next = tmp;
  *last = tmp;
  }
  return;
}
}
static void treefails(struct tree *tree , struct trie *fail , struct trie *recourse ) 
{ 
  register struct tree *link___0 ;

  {
  if (! tree) {
    return;
  }
  {
  treefails(tree->llink, fail, recourse);
  treefails(tree->rlink, fail, recourse);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! fail) {
      goto while_break;
    }
    link___0 = fail->links;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (link___0) {
        if (! ((int )tree->label != (int )link___0->label)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      if ((int )tree->label < (int )link___0->label) {
        link___0 = link___0->llink;
      } else {
        link___0 = link___0->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (link___0) {
      (tree->trie)->fail = link___0->trie;
      return;
    }
    fail = fail->fail;
  }
  while_break: /* CIL Label */ ;
  }
  (tree->trie)->fail = recourse;
  return;
}
}
static void treedelta(struct tree *tree , unsigned int depth___0 , unsigned char *delta ) 
{ 


  {
  if (! tree) {
    return;
  }
  {
  treedelta(tree->llink, depth___0, delta);
  treedelta(tree->rlink, depth___0, delta);
  }
  if (depth___0 < (unsigned int )*(delta + (int )tree->label)) {
    *(delta + (int )tree->label) = (unsigned char )depth___0;
  }
  return;
}
}
static int hasevery(struct tree *a , struct tree *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (! b) {
    return (1);
  }
  {
  tmp = hasevery(a, b->llink);
  }
  if (! tmp) {
    return (0);
  }
  {
  tmp___0 = hasevery(a, b->rlink);
  }
  if (! tmp___0) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (a) {
      if (! ((int )b->label != (int )a->label)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )b->label < (int )a->label) {
      a = a->llink;
    } else {
      a = a->rlink;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (! (! a));
}
}
static void treenext(struct tree *tree , struct trie **next ) 
{ 


  {
  if (! tree) {
    return;
  }
  {
  treenext(tree->llink, next);
  treenext(tree->rlink, next);
  *(next + (int )tree->label) = tree->trie;
  }
  return;
}
}
char *kwsprep(kwset_t kws ) 
{ 
  register struct kwset *kwset___0 ;
  register int i ;
  register struct trie *curr ;
  register struct trie *fail ;
  register char *trans___0 ;
  unsigned char delta[256] ;
  struct trie *last ;
  struct trie *next[256] ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;
  int tmp ;

  {
  kwset___0 = (struct kwset *)kws;
  if (kwset___0->mind < 256) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < 256)) {
        goto while_break;
      }
      delta[i] = (unsigned char )kwset___0->mind;
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    i = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i < 256)) {
        goto while_break___0;
      }
      delta[i] = (unsigned char)255;
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  if (kwset___0->words == 1) {
    if ((unsigned long )kwset___0->trans == (unsigned long )((char *)0)) {
      __h = & kwset___0->obstack;
      __o = __h;
      __len = kwset___0->mind;
      if (__o->chunk_limit - __o->next_free < (long )__len) {
        {
        _obstack_newchunk(__o, __len);
        }
      }
      __o->next_free += __len;
      __o1 = __h;
      value = (void *)__o1->object_base;
      if ((unsigned long )__o1->next_free == (unsigned long )value) {
        __o1->maybe_empty_object = 1U;
      }
      __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
        __o1->next_free = __o1->chunk_limit;
      }
      __o1->object_base = __o1->next_free;
      kwset___0->target = (char *)value;
      i = kwset___0->mind - 1;
      curr = kwset___0->trie;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (i >= 0)) {
          goto while_break___1;
        }
        *(kwset___0->target + i) = (char )(curr->links)->label;
        curr = (curr->links)->trie;
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
      i = 0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (i < kwset___0->mind)) {
          goto while_break___2;
        }
        delta[(unsigned char )*(kwset___0->target + i)] = (unsigned char )(kwset___0->mind - (i + 1));
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      kwset___0->mind2 = kwset___0->mind;
      i = 0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! (i < kwset___0->mind - 1)) {
          goto while_break___3;
        }
        if ((int )*(kwset___0->target + i) == (int )*(kwset___0->target + (kwset___0->mind - 1))) {
          kwset___0->mind2 = kwset___0->mind - (i + 1);
        }
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    last = kwset___0->trie;
    curr = last;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! curr) {
        goto while_break___4;
      }
      {
      enqueue(curr->links, & last);
      curr->shift = kwset___0->mind;
      curr->maxshift = kwset___0->mind;
      treedelta(curr->links, (unsigned int )curr->depth, delta);
      treefails(curr->links, curr->fail, kwset___0->trie);
      fail = curr->fail;
      }
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! fail) {
          goto while_break___5;
        }
        {
        tmp = hasevery(fail->links, curr->links);
        }
        if (! tmp) {
          if (curr->depth - fail->depth < fail->shift) {
            fail->shift = curr->depth - fail->depth;
          }
        }
        if (curr->accepting) {
          if (fail->maxshift > curr->depth - fail->depth) {
            fail->maxshift = curr->depth - fail->depth;
          }
        }
        fail = fail->fail;
      }
      while_break___5: /* CIL Label */ ;
      }
      curr = curr->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    curr = (kwset___0->trie)->next;
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (! curr) {
        goto while_break___6;
      }
      if (curr->maxshift > (curr->parent)->maxshift) {
        curr->maxshift = (curr->parent)->maxshift;
      }
      if (curr->shift > curr->maxshift) {
        curr->shift = curr->maxshift;
      }
      curr = curr->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    i = 0;
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      if (! (i < 256)) {
        goto while_break___7;
      }
      next[i] = (struct trie *)0;
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
    treenext((kwset___0->trie)->links, next);
    trans___0 = kwset___0->trans;
    }
    if ((unsigned long )trans___0 != (unsigned long )((char *)0)) {
      i = 0;
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        if (! (i < 256)) {
          goto while_break___8;
        }
        kwset___0->next[i] = next[(unsigned char )*(trans___0 + i)];
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
      i = 0;
      {
      while (1) {
        while_continue___9: /* CIL Label */ ;
        if (! (i < 256)) {
          goto while_break___9;
        }
        kwset___0->next[i] = next[i];
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
  }
  trans___0 = kwset___0->trans;
  if ((unsigned long )trans___0 != (unsigned long )((char *)0)) {
    i = 0;
    {
    while (1) {
      while_continue___10: /* CIL Label */ ;
      if (! (i < 256)) {
        goto while_break___10;
      }
      kwset___0->delta[i] = delta[(unsigned char )*(trans___0 + i)];
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  } else {
    i = 0;
    {
    while (1) {
      while_continue___11: /* CIL Label */ ;
      if (! (i < 256)) {
        goto while_break___11;
      }
      kwset___0->delta[i] = delta[i];
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  return ((char *)0);
}
}
static char *bmexec(kwset_t kws , char *text , size_t size ) 
{ 
  struct kwset *kwset___0 ;
  register unsigned char *d1 ;
  register char *ep ;
  register char *sp ;
  register char *tp ;
  register int d ;
  register int gc ;
  register int i ;
  register int len ;
  register int md2 ;
  void *tmp ;

  {
  kwset___0 = (struct kwset *)kws;
  len = kwset___0->mind;
  if (len == 0) {
    return (text);
  }
  if ((size_t )len > size) {
    return ((char *)0);
  }
  if (len == 1) {
    {
    tmp = memchr((void const   *)text, (int )*(kwset___0->target + 0), size);
    }
    return ((char *)tmp);
  }
  d1 = kwset___0->delta;
  sp = kwset___0->target + len;
  gc = (int )((unsigned char )*(sp + -2));
  md2 = kwset___0->mind2;
  tp = text + len;
  if (size > (size_t )(12 * len)) {
    ep = (text + size) - 11 * len;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )tp <= (unsigned long )ep)) {
          goto while_break___0;
        }
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        if (d == 0) {
          goto found;
        }
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        if (d == 0) {
          goto found;
        }
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        if (d == 0) {
          goto found;
        }
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
        d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
        tp += d;
      }
      while_break___0: /* CIL Label */ ;
      }
      goto while_break;
      found: 
      if ((int )((unsigned char )*(tp + -2)) == gc) {
        i = 3;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (i <= len) {
            if (! ((int )((unsigned char )*(tp + - i)) == (int )((unsigned char )*(sp + - i)))) {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        if (i > len) {
          return (tp - len);
        }
      }
      tp += md2;
    }
    while_break: /* CIL Label */ ;
    }
  }
  ep = text + size;
  d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! ((long )d <= ep - tp)) {
      goto while_break___2;
    }
    tp += d;
    d = (int )*(d1 + (int )((unsigned char )*(tp + -1)));
    if (d != 0) {
      goto while_continue___2;
    }
    if ((int )((unsigned char )*(tp + -2)) == gc) {
      i = 3;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (i <= len) {
          if (! ((int )((unsigned char )*(tp + - i)) == (int )((unsigned char )*(sp + - i)))) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      if (i > len) {
        return (tp - len);
      }
    }
    d = md2;
  }
  while_break___2: /* CIL Label */ ;
  }
  return ((char *)0);
}
}
static char *cwexec(kwset_t kws , char *text , size_t len , struct kwsmatch *kwsmatch ) 
{ 
  struct kwset *kwset___0 ;
  struct trie **next ;
  struct trie *trie ;
  struct trie *accept ;
  char *beg ;
  char *lim ;
  char *mch ;
  char *lmch ;
  register unsigned char c ;
  register unsigned char *delta ;
  register int d ;
  register char *end ;
  register char *qlim ;
  register struct tree *tree ;
  register char *trans___0 ;

  {
  kwset___0 = (struct kwset *)kws;
  if (len < (size_t )kwset___0->mind) {
    return ((char *)0);
  }
  next = kwset___0->next;
  delta = kwset___0->delta;
  trans___0 = kwset___0->trans;
  lim = text + len;
  end = text;
  d = kwset___0->mind;
  if (d != 0) {
    mch = (char *)0;
  } else {
    mch = text;
    accept = kwset___0->trie;
    goto match;
  }
  if (len >= (size_t )(4 * kwset___0->mind)) {
    qlim = lim - 4 * kwset___0->mind;
  } else {
    qlim = (char *)0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lim - end >= (long )d)) {
      goto while_break;
    }
    if (qlim) {
      if ((unsigned long )end <= (unsigned long )qlim) {
        end += d - 1;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          c = (unsigned char )*end;
          d = (int )*(delta + (int )c);
          if (d) {
            if (! ((unsigned long )end < (unsigned long )qlim)) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
          end += d;
          end += (int )*(delta + (int )((unsigned char )*end));
          end += (int )*(delta + (int )((unsigned char )*end));
        }
        while_break___0: /* CIL Label */ ;
        }
        end ++;
      } else {
        end += d;
        c = (unsigned char )*(end + -1);
        d = (int )*(delta + (int )c);
      }
    } else {
      end += d;
      c = (unsigned char )*(end + -1);
      d = (int )*(delta + (int )c);
    }
    if (d) {
      goto while_continue;
    }
    beg = end - 1;
    trie = *(next + (int )c);
    if (trie->accepting) {
      mch = beg;
      accept = trie;
    }
    d = trie->shift;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned long )beg > (unsigned long )text)) {
        goto while_break___1;
      }
      if (trans___0) {
        beg --;
        c = (unsigned char )*(trans___0 + (int )((unsigned char )*beg));
      } else {
        beg --;
        c = (unsigned char )*beg;
      }
      tree = trie->links;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (tree) {
          if (! ((int )c != (int )tree->label)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        if ((int )c < (int )tree->label) {
          tree = tree->llink;
        } else {
          tree = tree->rlink;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      if (tree) {
        trie = tree->trie;
        if (trie->accepting) {
          mch = beg;
          accept = trie;
        }
      } else {
        goto while_break___1;
      }
      d = trie->shift;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (mch) {
      goto match;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((char *)0);
  match: 
  if (lim - mch > (long )kwset___0->maxd) {
    lim = mch + kwset___0->maxd;
  }
  lmch = (char *)0;
  d = 1;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (lim - end >= (long )d)) {
      goto while_break___3;
    }
    end += d;
    c = (unsigned char )*(end + -1);
    d = (int )*(delta + (int )c);
    if (d != 0) {
      goto while_continue___3;
    }
    beg = end - 1;
    trie = *(next + (int )c);
    if (! trie) {
      d = 1;
      goto while_continue___3;
    }
    if (trie->accepting) {
      if ((unsigned long )beg <= (unsigned long )mch) {
        lmch = beg;
        accept = trie;
      }
    }
    d = trie->shift;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ((unsigned long )beg > (unsigned long )text)) {
        goto while_break___4;
      }
      if (trans___0) {
        beg --;
        c = (unsigned char )*(trans___0 + (int )((unsigned char )*beg));
      } else {
        beg --;
        c = (unsigned char )*beg;
      }
      tree = trie->links;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (tree) {
          if (! ((int )c != (int )tree->label)) {
            goto while_break___5;
          }
        } else {
          goto while_break___5;
        }
        if ((int )c < (int )tree->label) {
          tree = tree->llink;
        } else {
          tree = tree->rlink;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      if (tree) {
        trie = tree->trie;
        if (trie->accepting) {
          if ((unsigned long )beg <= (unsigned long )mch) {
            lmch = beg;
            accept = trie;
          }
        }
      } else {
        goto while_break___4;
      }
      d = trie->shift;
    }
    while_break___4: /* CIL Label */ ;
    }
    if (lmch) {
      mch = lmch;
      goto match;
    }
    if (! d) {
      d = 1;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  if (kwsmatch) {
    kwsmatch->strchr = (int )(accept->accepting / 2U);
    kwsmatch->beg[0] = mch;
    kwsmatch->size[0] = (size_t )accept->depth;
  }
  return (mch);
}
}
char *kwsexec(kwset_t kws , char *text , size_t size , struct kwsmatch *kwsmatch ) 
{ 
  struct kwset *kwset___0 ;
  char *ret ;
  char *tmp ;

  {
  kwset___0 = (struct kwset *)kws;
  if (kwset___0->words == 1) {
    if ((unsigned long )kwset___0->trans == (unsigned long )((char *)0)) {
      {
      ret = bmexec(kws, text, size);
      }
      if ((unsigned long )kwsmatch != (unsigned long )((struct kwsmatch *)0)) {
        if ((unsigned long )ret != (unsigned long )((char *)0)) {
          kwsmatch->strchr = 0;
          kwsmatch->beg[0] = ret;
          kwsmatch->size[0] = (size_t )kwset___0->mind;
        }
      }
      return (ret);
    } else {
      {
      tmp = cwexec(kws, text, size, kwsmatch);
      }
      return (tmp);
    }
  } else {
    {
    tmp = cwexec(kws, text, size, kwsmatch);
    }
    return (tmp);
  }
}
}
void kwsfree(kwset_t kws ) 
{ 
  struct kwset *kwset___0 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  kwset___0 = (struct kwset *)kws;
  __o = & kwset___0->obstack;
  __obj = (void *)0;
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
      tmp = (char *)__obj;
      __o->object_base = tmp;
      __o->next_free = tmp;
    } else {
      {
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
    obstack_free(__o, __obj);
    }
  }
  {
  free(kws);
  }
  return;
}
}
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
char *savedir(char const   *dir , off_t name_size ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  char *name_space ;
  char *namep ;
  char *tmp ;
  off_t size_needed ;
  size_t tmp___0 ;
  char *new_name_space ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
  dirp = opendir(dir);
  }
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if (name_size <= 0L) {
    name_size = (off_t )1;
  }
  {
  tmp = xmalloc((size_t )name_size);
  name_space = tmp;
  }
  if ((unsigned long )name_space == (unsigned long )((void *)0)) {
    {
    closedir(dirp);
    }
    return ((char *)((void *)0));
  }
  namep = name_space;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    dp = readdir(dirp);
    }
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((int )dp->d_name[0] != 46) {
      goto _L___0;
    } else { //Added block
    if ((int )dp->d_name[1] != 0) {
      if ((int )dp->d_name[1] != 46) {
        goto _L___0;
      } else { //Added block
      if ((int )dp->d_name[2] != 0) {
        _L___0: 
        {
        tmp___0 = strlen((char const   *)(dp->d_name));
        size_needed = (off_t )(((size_t )(namep - name_space) + tmp___0) + 2UL);
        }
        if (size_needed > name_size) {
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (size_needed > name_size)) {
              goto while_break___0;
            }
            name_size += 1024L;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
          tmp___1 = realloc((void *)name_space, (size_t )name_size);
          new_name_space = (char *)tmp___1;
          }
          if ((unsigned long )new_name_space == (unsigned long )((void *)0)) {
            {
            closedir(dirp);
            }
            return ((char *)((void *)0));
          }
          namep += new_name_space - name_space;
          name_space = new_name_space;
        }
        {
        tmp___2 = stpcpy((char * __restrict  )namep, (char const   * __restrict  )(dp->d_name));
        namep = tmp___2 + 1;
        }
      }
      }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  *namep = (char )'\000';
  tmp___3 = closedir(dirp);
  }
  if (tmp___3) {
    {
    free((void *)name_space);
    }
    return ((char *)((void *)0));
  }
  return (name_space);
}
}
static void Gcompile(char *pattern , size_t size ) ;
static void Ecompile(char *pattern , size_t size ) ;
static char *EGexecute(char *buf , size_t size , char **endp ) ;
static void Fcompile(char *pattern , size_t size ) ;
static char *Fexecute(char *buf , size_t size , char **endp ) ;
static void kwsinit(void) ;
struct matcher matchers[6]  = {      {(char *)"default", & Gcompile, & EGexecute}, 
        {(char *)"grep", & Gcompile, & EGexecute}, 
        {(char *)"egrep", & Ecompile, & EGexecute}, 
        {(char *)"awk", & Ecompile, & EGexecute}, 
        {(char *)"fgrep", & Fcompile, & Fexecute}, 
        {(char *)0, (void (*)(char * , size_t  ))0, (char *(*)(char * , size_t  , char ** ))0}};
static struct dfa dfa_1  ;
static struct re_pattern_buffer regexbuf  ;
static kwset_t kwset  ;
static int lastexact  ;
void dfaerror(char const   *mesg ) 
{ 


  {
  {
  fatal(mesg, 0);
  }
}
}
static char trans[256]  ;
static void kwsinit(void) 
{ 
  int i ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;

  {
  if (match_icase) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < 256)) {
        goto while_break;
      }
      {
      tmp___1 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___1 + i) & 256) {
        {
        tmp___0 = tolower(i);
        trans[i] = (char )tmp___0;
        }
      } else {
        trans[i] = (char )i;
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if (match_icase) {
    tmp___2 = trans;
  } else {
    tmp___2 = (char *)0;
  }
  {
  kwset = kwsalloc(tmp___2);
  }
  if (! kwset) {
    {
    fatal("memory exhausted", 0);
    }
  }
  return;
}
}
static void kwsmusts(void) 
{ 
  struct dfamust *dm ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  if (dfa_1.musts) {
    {
    kwsinit();
    dm = dfa_1.musts;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! dm) {
        goto while_break;
      }
      if (! dm->exact) {
        goto __Cont;
      }
      {
      lastexact ++;
      tmp = strlen((char const   *)dm->must);
      err = kwsincr(kwset, dm->must, tmp);
      }
      if ((unsigned long )err != (unsigned long )((char *)0)) {
        {
        fatal((char const   *)err, 0);
        }
      }
      __Cont: 
      dm = dm->next;
    }
    while_break: /* CIL Label */ ;
    }
    dm = dfa_1.musts;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! dm) {
        goto while_break___0;
      }
      if (dm->exact) {
        goto __Cont___0;
      }
      {
      tmp___0 = strlen((char const   *)dm->must);
      err = kwsincr(kwset, dm->must, tmp___0);
      }
      if ((unsigned long )err != (unsigned long )((char *)0)) {
        {
        fatal((char const   *)err, 0);
        }
      }
      __Cont___0: 
      dm = dm->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    err = kwsprep(kwset);
    }
    if ((unsigned long )err != (unsigned long )((char *)0)) {
      {
      fatal((char const   *)err, 0);
      }
    }
  }
  return;
}
}
static void Gcompile(char *pattern , size_t size ) 
{ 
  char const   *err ;
  char *n ;
  char *tmp ;
  int i ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
  re_set_syntax((((((1UL << 1) | ((1UL << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  dfasyntax((((((1UL << 1) | ((1UL << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
            match_icase, (int )eolbyte);
  err = re_compile_pattern((char const   *)pattern, size, & regexbuf);
  }
  if ((unsigned long )err != (unsigned long )((char const   *)0)) {
    {
    fatal(err, 0);
    }
  }
  if (match_words) {
    goto _L;
  } else { //Added block
  if (match_lines) {
    _L: 
    {
    tmp = xmalloc(size + 50UL);
    n = tmp;
    i = 0;
    strcpy((char * __restrict  )n, (char const   * __restrict  )"");
    }
    if (match_lines) {
      {
      strcpy((char * __restrict  )n, (char const   * __restrict  )"^\\(");
      }
    }
    if (match_words) {
      {
      strcpy((char * __restrict  )n, (char const   * __restrict  )"\\(^\\|[^[:alnum:]_]\\)\\(");
      }
    }
    {
    tmp___0 = strlen((char const   *)n);
    i = (int )tmp___0;
    memcpy((void * __restrict  )(n + i), (void const   * __restrict  )pattern, size);
    i = (int )((size_t )i + size);
    }
    if (match_words) {
      {
      strcpy((char * __restrict  )(n + i), (char const   * __restrict  )"\\)\\([^[:alnum:]_]\\|$\\)");
      }
    }
    if (match_lines) {
      {
      strcpy((char * __restrict  )(n + i), (char const   * __restrict  )"\\)$");
      }
    }
    {
    tmp___1 = strlen((char const   *)(n + i));
    i = (int )((size_t )i + tmp___1);
    dfacomp(n, (size_t )i, & dfa_1, 1);
    }
  } else {
    {
    dfacomp(pattern, size, & dfa_1, 1);
    }
  }
  }
  {
  kwsmusts();
  }
  return;
}
}
static void Ecompile(char *pattern , size_t size ) 
{ 
  char const   *err ;
  int tmp ;
  char *n ;
  char *tmp___0 ;
  int i ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
  tmp = strcmp(matcher, "awk");
  }
  if (tmp == 0) {
    {
    re_set_syntax(((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    dfasyntax(((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
              match_icase, (int )eolbyte);
    }
  } else {
    {
    re_set_syntax((((((((((1UL << 1) << 1) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    dfasyntax((((((((((1UL << 1) << 1) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
              match_icase, (int )eolbyte);
    }
  }
  {
  err = re_compile_pattern((char const   *)pattern, size, & regexbuf);
  }
  if ((unsigned long )err != (unsigned long )((char const   *)0)) {
    {
    fatal(err, 0);
    }
  }
  if (match_words) {
    goto _L;
  } else { //Added block
  if (match_lines) {
    _L: 
    {
    tmp___0 = xmalloc(size + 50UL);
    n = tmp___0;
    i = 0;
    strcpy((char * __restrict  )n, (char const   * __restrict  )"");
    }
    if (match_lines) {
      {
      strcpy((char * __restrict  )n, (char const   * __restrict  )"^(");
      }
    }
    if (match_words) {
      {
      strcpy((char * __restrict  )n, (char const   * __restrict  )"(^|[^[:alnum:]_])(");
      }
    }
    {
    tmp___1 = strlen((char const   *)n);
    i = (int )tmp___1;
    memcpy((void * __restrict  )(n + i), (void const   * __restrict  )pattern, size);
    i = (int )((size_t )i + size);
    }
    if (match_words) {
      {
      strcpy((char * __restrict  )(n + i), (char const   * __restrict  )")([^[:alnum:]_]|$)");
      }
    }
    if (match_lines) {
      {
      strcpy((char * __restrict  )(n + i), (char const   * __restrict  )")$");
      }
    }
    {
    tmp___2 = strlen((char const   *)(n + i));
    i = (int )((size_t )i + tmp___2);
    dfacomp(n, (size_t )i, & dfa_1, 1);
    }
  } else {
    {
    dfacomp(pattern, size, & dfa_1, 1);
    }
  }
  }
  {
  kwsmusts();
  }
  return;
}
}
static struct re_registers regs  ;
static char *EGexecute(char *buf , size_t size , char **endp ) 
{ 
  register char *buflim___0 ;
  register char *beg ;
  register char *end ;
  register char save ;
  char eol ;
  int backref ;
  int start ;
  int len ;
  struct kwsmatch kwsm ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  eol = (char )eolbyte;
  buflim___0 = buf + size;
  end = buf;
  beg = end;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )end < (unsigned long )buflim___0)) {
      goto while_break;
    }
    if (kwset) {
      {
      beg = kwsexec(kwset, beg, (size_t )(buflim___0 - beg), & kwsm);
      }
      if (! beg) {
        goto failure;
      }
      {
      tmp = memchr((void const   *)beg, (int )eol, (size_t )(buflim___0 - beg));
      end = (char *)tmp;
      }
      if (! end) {
        end = buflim___0;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if ((unsigned long )beg > (unsigned long )buf) {
          if (! ((int )*(beg + -1) != (int )eol)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        beg --;
      }
      while_break___0: /* CIL Label */ ;
      }
      save = *end;
      if (kwsm.strchr < lastexact) {
        goto success;
      }
      {
      tmp___0 = dfaexec(& dfa_1, beg, end, 0, (int *)0, & backref);
      }
      if (! tmp___0) {
        *end = save;
        goto __Cont;
      }
      *end = save;
      if (! backref) {
        goto success;
      }
    } else {
      {
      save = *buflim___0;
      beg = dfaexec(& dfa_1, beg, buflim___0, 0, (int *)0, & backref);
      *buflim___0 = save;
      }
      if (! beg) {
        goto failure;
      }
      {
      tmp___1 = memchr((void const   *)beg, (int )eol, (size_t )(buflim___0 - beg));
      end = (char *)tmp___1;
      }
      if (! end) {
        end = buflim___0;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if ((unsigned long )beg > (unsigned long )buf) {
          if (! ((int )*(beg + -1) != (int )eol)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        beg --;
      }
      while_break___1: /* CIL Label */ ;
      }
      if (! backref) {
        goto success;
      }
    }
    {
    regexbuf.not_eol = 0U;
    start = re_search(& regexbuf, (char const   *)beg, (int )(end - beg), 0, (int )(end - beg),
                      & regs);
    }
    if (start >= 0) {
      len = *(regs.end + 0) - start;
      if (! match_lines) {
        if (! match_words) {
          goto success;
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (match_lines) {
        if ((long )len == end - beg) {
          goto success;
        }
      }
      }
      if (match_words) {
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (start >= 0)) {
            goto while_break___2;
          }
          if (start == 0) {
            goto _L___0;
          } else {
            {
            tmp___2 = __ctype_b_loc();
            }
            if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*(beg + (start - 1)))) & 8)) {
              if (! ((int )((unsigned char )*(beg + (start - 1))) == 95)) {
                _L___0: 
                if ((long )len == end - beg) {
                  goto success;
                } else {
                  {
                  tmp___3 = __ctype_b_loc();
                  }
                  if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*(beg + (start + len)))) & 8)) {
                    if (! ((int )((unsigned char )*(beg + (start + len))) == 95)) {
                      goto success;
                    }
                  }
                }
              }
            }
          }
          if (len > 0) {
            {
            len --;
            regexbuf.not_eol = 1U;
            len = re_match(& regexbuf, (char const   *)beg, start + len, start, & regs);
            }
          }
          if (len <= 0) {
            if ((long )start == end - beg) {
              goto while_break___2;
            }
            {
            start ++;
            regexbuf.not_eol = 0U;
            start = re_search(& regexbuf, (char const   *)beg, (int )(end - beg),
                              start, (int )((end - beg) - (long )start), & regs);
            len = *(regs.end + 0) - start;
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    __Cont: 
    beg = end + 1;
  }
  while_break: /* CIL Label */ ;
  }
  failure: 
  return ((char *)0);
  success: 
  if ((unsigned long )end < (unsigned long )buflim___0) {
    *endp = end + 1;
  } else {
    *endp = end;
  }
  return (beg);
}
}
static void Fcompile(char *pattern , size_t size ) 
{ 
  char *beg ;
  char *lim ;
  char *err ;

  {
  {
  kwsinit();
  beg = pattern;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    lim = beg;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )lim < (unsigned long )(pattern + size)) {
        if (! ((int )*lim != 10)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      lim ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    err = kwsincr(kwset, beg, (size_t )(lim - beg));
    }
    if ((unsigned long )err != (unsigned long )((char *)0)) {
      {
      fatal((char const   *)err, 0);
      }
    }
    if ((unsigned long )lim < (unsigned long )(pattern + size)) {
      lim ++;
    }
    beg = lim;
    if (! ((unsigned long )beg < (unsigned long )(pattern + size))) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  err = kwsprep(kwset);
  }
  if ((unsigned long )err != (unsigned long )((char *)0)) {
    {
    fatal((char const   *)err, 0);
    }
  }
  return;
}
}
static char *Fexecute(char *buf , size_t size , char **endp ) 
{ 
  register char *beg ;
  register char *try ;
  register char *end ;
  register size_t len ;
  char eol ;
  struct kwsmatch kwsmatch ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
  eol = (char )eolbyte;
  beg = buf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )beg <= (unsigned long )(buf + size))) {
      goto while_break;
    }
    {
    beg = kwsexec(kwset, beg, (size_t )((buf + size) - beg), & kwsmatch);
    }
    if (! beg) {
      return ((char *)0);
    }
    len = kwsmatch.size[0];
    if (match_lines) {
      if ((unsigned long )beg > (unsigned long )buf) {
        if ((int )*(beg + -1) != (int )eol) {
          goto __Cont;
        }
      }
      if ((unsigned long )(beg + len) < (unsigned long )(buf + size)) {
        if ((int )*(beg + len) != (int )eol) {
          goto __Cont;
        }
      }
      goto success;
    } else { //Added block
    if (match_words) {
      try = beg;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (len) {
          if (! try) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        if ((unsigned long )try > (unsigned long )buf) {
          {
          tmp = __ctype_b_loc();
          }
          if ((int const   )*(*tmp + (int )((unsigned char )*(try + -1))) & 8) {
            goto while_break___0;
          } else { //Added block
          if ((int )((unsigned char )*(try + -1)) == 95) {
            goto while_break___0;
          }
          }
        }
        if ((unsigned long )(try + len) < (unsigned long )(buf + size)) {
          {
          tmp___0 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___0 + (int )((unsigned char )*(try + len))) & 8) {
            {
            len --;
            try = kwsexec(kwset, beg, len, & kwsmatch);
            len = kwsmatch.size[0];
            }
          } else { //Added block
          if ((int )((unsigned char )*(try + len)) == 95) {
            {
            len --;
            try = kwsexec(kwset, beg, len, & kwsmatch);
            len = kwsmatch.size[0];
            }
          } else {
            goto success;
          }
          }
        } else {
          goto success;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      goto success;
    }
    }
    __Cont: 
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char *)0);
  success: 
  {
  tmp___1 = memchr((void const   *)(beg + len), (int )eol, (size_t )((buf + size) - (beg + len)));
  end = (char *)tmp___1;
  }
  if ((unsigned long )end != (unsigned long )((char *)0)) {
    end ++;
  } else {
    end = buf + size;
  }
  *endp = end;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if ((unsigned long )beg > (unsigned long )buf) {
      if (! ((int )*(beg + -1) != 10)) {
        goto while_break___1;
      }
    } else {
      goto while_break___1;
    }
    beg --;
  }
  while_break___1: /* CIL Label */ ;
  }
  return (beg);
}
}
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  dest ,
                                                                                          char const   * __restrict  src ) ;
char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  dest ,
                                                            char const   * __restrict  src ) 
{ 
  register char *d ;
  register char const   *s ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  d = (char *)dest;
  s = (char const   *)src;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = d;
    d ++;
    *tmp = (char )*s;
    tmp___0 = s;
    s ++;
    if (! ((int const   )*tmp___0 != 0)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (d - 1);
}
}
static char re_syntax_table[256]  ;
static void init_syntax_once(void) ;
static int done  =    0;
static void init_syntax_once(void) 
{ 
  register int c ;
  unsigned short const   **tmp ;

  {
  if (done) {
    return;
  }
  {
  memset((void *)(re_syntax_table), '\000', sizeof(re_syntax_table));
  c = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (c < 256)) {
      goto while_break;
    }
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + c) & 8) {
      re_syntax_table[c] = (char)1;
    }
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  re_syntax_table['_'] = (char)1;
  done = 1;
  return;
}
}
static int re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                               int size1 , char const   *string2 , int size2 , int pos ,
                               struct re_registers *regs___0 , int stop ) ;
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
  ret = re_syntax_options;
  re_syntax_options = syntax;
  return (ret);
}
}
static char const   re_error_msgid[369]  = 
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
static size_t const   re_error_msgid_idx[17]  = 
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
int re_max_failures  =    20000;
static char reg_unset_dummy  ;
static reg_errcode_t regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                   struct re_pattern_buffer *bufp ) ;
static void store_op1(re_opcode_t op , unsigned char *loc , int arg ) ;
static void store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) ;
static void insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) ;
static void insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                       unsigned char *end ) ;
static boolean at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) ;
static boolean at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) ;
static reg_errcode_t compile_range(char const   **p_ptr , char const   *pend , char *translate ,
                                   reg_syntax_t syntax , unsigned char *b ) ;
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) ;
static reg_errcode_t regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                   struct re_pattern_buffer *bufp ) 
{ 
  register unsigned char c ;
  register unsigned char c1 ;
  char const   *p1 ;
  register unsigned char *b ;
  compile_stack_type compile_stack ;
  char const   *p ;
  char const   *pend ;
  char *translate ;
  unsigned char *pending_exact ;
  unsigned char *laststart___0 ;
  unsigned char *begalt ;
  char const   *beg_interval ;
  unsigned char *fixup_alt_jump ;
  regnum_t regnum ;
  char *tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *old_buffer ;
  void *tmp___4 ;
  unsigned char *tmp___5 ;
  boolean tmp___6 ;
  unsigned char *old_buffer___0 ;
  void *tmp___7 ;
  unsigned char *tmp___8 ;
  boolean tmp___9 ;
  boolean keep_string_p ;
  char zero_times_ok ;
  char many_times_ok ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  unsigned char *old_buffer___1 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char *old_buffer___2 ;
  void *tmp___17 ;
  int tmp___18 ;
  unsigned char *old_buffer___3 ;
  void *tmp___19 ;
  unsigned char *old_buffer___4 ;
  void *tmp___20 ;
  unsigned char *tmp___21 ;
  boolean had_char_class ;
  unsigned char *old_buffer___5 ;
  void *tmp___22 ;
  unsigned char *old_buffer___6 ;
  void *tmp___23 ;
  unsigned char *tmp___24 ;
  int tmp___25 ;
  unsigned char *old_buffer___7 ;
  void *tmp___26 ;
  unsigned char *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___30 ;
  reg_errcode_t ret___0 ;
  char const   *tmp___31 ;
  char str[7] ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  unsigned char tmp___34 ;
  int ch ;
  boolean is_alnum___0 ;
  int tmp___35 ;
  boolean is_alpha___0 ;
  int tmp___36 ;
  boolean is_blank___0 ;
  int tmp___37 ;
  boolean is_cntrl___0 ;
  int tmp___38 ;
  boolean is_digit___0 ;
  int tmp___39 ;
  boolean is_graph___0 ;
  int tmp___40 ;
  boolean is_lower___0 ;
  int tmp___41 ;
  boolean is_print___0 ;
  int tmp___42 ;
  boolean is_punct___0 ;
  int tmp___43 ;
  boolean is_space___0 ;
  int tmp___44 ;
  boolean is_upper___0 ;
  int tmp___45 ;
  boolean is_xdigit___0 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  char const   *tmp___59 ;
  unsigned short const   **tmp___60 ;
  unsigned short const   **tmp___61 ;
  unsigned short const   **tmp___62 ;
  unsigned short const   **tmp___63 ;
  unsigned short const   **tmp___64 ;
  unsigned short const   **tmp___65 ;
  unsigned short const   **tmp___66 ;
  unsigned short const   **tmp___67 ;
  unsigned short const   **tmp___68 ;
  unsigned short const   **tmp___69 ;
  unsigned short const   **tmp___70 ;
  unsigned short const   **tmp___71 ;
  unsigned short const   **tmp___72 ;
  unsigned short const   **tmp___73 ;
  unsigned char tmp___74 ;
  char const   *tmp___75 ;
  void *tmp___76 ;
  unsigned char *old_buffer___8 ;
  void *tmp___77 ;
  unsigned char *tmp___78 ;
  unsigned char *tmp___79 ;
  unsigned char *tmp___80 ;
  unsigned char *old_buffer___9 ;
  void *tmp___81 ;
  unsigned char *tmp___82 ;
  regnum_t this_group_regnum ;
  unsigned char *inner_group_loc ;
  unsigned char *old_buffer___10 ;
  void *tmp___83 ;
  unsigned char *tmp___84 ;
  unsigned char *tmp___85 ;
  unsigned char *tmp___86 ;
  unsigned char *old_buffer___11 ;
  void *tmp___87 ;
  unsigned char *old_buffer___12 ;
  void *tmp___88 ;
  int lower_bound ;
  int upper_bound ;
  char const   *tmp___89 ;
  char const   *tmp___90 ;
  char const   *tmp___91 ;
  char const   *tmp___92 ;
  char const   *tmp___93 ;
  unsigned char *old_buffer___13 ;
  void *tmp___94 ;
  unsigned int nbytes ;
  unsigned char *old_buffer___14 ;
  void *tmp___95 ;
  char const   *tmp___96 ;
  unsigned char *old_buffer___15 ;
  void *tmp___97 ;
  unsigned char *tmp___98 ;
  unsigned char *old_buffer___16 ;
  void *tmp___99 ;
  unsigned char *tmp___100 ;
  unsigned char *old_buffer___17 ;
  void *tmp___101 ;
  unsigned char *tmp___102 ;
  unsigned char *old_buffer___18 ;
  void *tmp___103 ;
  unsigned char *tmp___104 ;
  unsigned char *old_buffer___19 ;
  void *tmp___105 ;
  unsigned char *tmp___106 ;
  unsigned char *old_buffer___20 ;
  void *tmp___107 ;
  unsigned char *tmp___108 ;
  unsigned char *old_buffer___21 ;
  void *tmp___109 ;
  unsigned char *tmp___110 ;
  unsigned char *old_buffer___22 ;
  void *tmp___111 ;
  unsigned char *tmp___112 ;
  boolean tmp___113 ;
  unsigned char *old_buffer___23 ;
  void *tmp___114 ;
  unsigned char *tmp___115 ;
  unsigned char *tmp___116 ;
  unsigned char *old_buffer___24 ;
  void *tmp___117 ;
  unsigned char *tmp___118 ;
  unsigned char *tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  unsigned char *old_buffer___25 ;
  void *tmp___125 ;
  unsigned char *tmp___126 ;
  unsigned char *old_buffer___26 ;
  void *tmp___127 ;
  unsigned char *tmp___128 ;

  {
  {
  p = pattern;
  pend = pattern + size;
  translate = bufp->translate;
  pending_exact = (unsigned char *)0;
  laststart___0 = (unsigned char *)0;
  fixup_alt_jump = (unsigned char *)0;
  regnum = (regnum_t )0;
  tmp = xmalloc(32UL * sizeof(compile_stack_elt_t ));
  compile_stack.stack = (compile_stack_elt_t *)tmp;
  }
  if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
    return ((reg_errcode_t )12);
  }
  {
  compile_stack.size = 32U;
  compile_stack.avail = 0U;
  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0U;
  tmp___0 = 0U;
  bufp->not_eol = tmp___0;
  bufp->not_bol = tmp___0;
  bufp->used = 0UL;
  bufp->re_nsub = (size_t )0;
  init_syntax_once();
  }
  if (bufp->allocated == 0UL) {
    if (bufp->buffer) {
      {
      tmp___1 = realloc((void *)bufp->buffer, 32UL * sizeof(unsigned char ));
      bufp->buffer = (unsigned char *)tmp___1;
      }
    } else {
      {
      tmp___2 = xmalloc(32UL * sizeof(unsigned char ));
      bufp->buffer = (unsigned char *)tmp___2;
      }
    }
    if (! bufp->buffer) {
      {
      free((void *)compile_stack.stack);
      }
      return ((reg_errcode_t )12);
    }
    bufp->allocated = 32UL;
  }
  b = bufp->buffer;
  begalt = b;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p != (unsigned long )pend)) {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )p == (unsigned long )pend) {
        return ((reg_errcode_t )14);
      }
      tmp___3 = p;
      p ++;
      c = (unsigned char )*tmp___3;
      if (translate) {
        c = (unsigned char )*(translate + (int )c);
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    if ((int )c == 94) {
      goto case_94;
    }
    if ((int )c == 36) {
      goto case_36;
    }
    if ((int )c == 43) {
      goto case_43;
    }
    if ((int )c == 63) {
      goto case_43;
    }
    if ((int )c == 42) {
      goto handle_plus;
    }
    if ((int )c == 46) {
      goto case_46;
    }
    if ((int )c == 91) {
      goto case_91;
    }
    if ((int )c == 40) {
      goto case_40;
    }
    if ((int )c == 41) {
      goto case_41;
    }
    if ((int )c == 10) {
      goto case_10;
    }
    if ((int )c == 124) {
      goto case_124;
    }
    if ((int )c == 123) {
      goto case_123;
    }
    if ((int )c == 92) {
      goto case_92;
    }
    goto normal_char;
    case_94: /* CIL Label */ 
    if ((unsigned long )p == (unsigned long )(pattern + 1)) {
      goto _L;
    } else { //Added block
    if (syntax & (((1UL << 1) << 1) << 1)) {
      goto _L;
    } else {
      {
      tmp___6 = at_begline_loc_p(pattern, p, syntax);
      }
      if (tmp___6) {
        _L: 
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
              goto while_break___2;
            }
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              old_buffer = bufp->buffer;
              if (bufp->allocated == (unsigned long )(1L << 16)) {
                return ((reg_errcode_t )15);
              }
              bufp->allocated <<= 1;
              if (bufp->allocated > (unsigned long )(1L << 16)) {
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
              tmp___4 = realloc((void *)bufp->buffer, bufp->allocated);
              bufp->buffer = (unsigned char *)tmp___4;
              }
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
                return ((reg_errcode_t )12);
              }
              if ((unsigned long )old_buffer != (unsigned long )bufp->buffer) {
                b = bufp->buffer + (b - old_buffer);
                begalt = bufp->buffer + (begalt - old_buffer);
                if (fixup_alt_jump) {
                  fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer);
                }
                if (laststart___0) {
                  laststart___0 = bufp->buffer + (laststart___0 - old_buffer);
                }
                if (pending_exact) {
                  pending_exact = bufp->buffer + (pending_exact - old_buffer);
                }
              }
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          tmp___5 = b;
          b ++;
          *tmp___5 = (unsigned char)9;
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        goto normal_char;
      }
    }
    }
    goto switch_break;
    case_36: /* CIL Label */ 
    if ((unsigned long )p == (unsigned long )pend) {
      goto _L___0;
    } else { //Added block
    if (syntax & (((1UL << 1) << 1) << 1)) {
      goto _L___0;
    } else {
      {
      tmp___9 = at_endline_loc_p(p, pend, syntax);
      }
      if (tmp___9) {
        _L___0: 
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
              goto while_break___5;
            }
            {
            while (1) {
              while_continue___6: /* CIL Label */ ;
              old_buffer___0 = bufp->buffer;
              if (bufp->allocated == (unsigned long )(1L << 16)) {
                return ((reg_errcode_t )15);
              }
              bufp->allocated <<= 1;
              if (bufp->allocated > (unsigned long )(1L << 16)) {
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
              tmp___7 = realloc((void *)bufp->buffer, bufp->allocated);
              bufp->buffer = (unsigned char *)tmp___7;
              }
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
                return ((reg_errcode_t )12);
              }
              if ((unsigned long )old_buffer___0 != (unsigned long )bufp->buffer) {
                b = bufp->buffer + (b - old_buffer___0);
                begalt = bufp->buffer + (begalt - old_buffer___0);
                if (fixup_alt_jump) {
                  fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___0);
                }
                if (laststart___0) {
                  laststart___0 = bufp->buffer + (laststart___0 - old_buffer___0);
                }
                if (pending_exact) {
                  pending_exact = bufp->buffer + (pending_exact - old_buffer___0);
                }
              }
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          tmp___8 = b;
          b ++;
          *tmp___8 = (unsigned char)10;
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        goto normal_char;
      }
    }
    }
    goto switch_break;
    case_43: /* CIL Label */ 
    case_63: /* CIL Label */ 
    if (syntax & (1UL << 1)) {
      goto normal_char;
    } else { //Added block
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    }
    handle_plus: 
    case_42: /* CIL Label */ 
    if (! laststart___0) {
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )13);
      } else { //Added block
      if (! (syntax & ((((1UL << 1) << 1) << 1) << 1))) {
        goto normal_char;
      }
      }
    }
    keep_string_p = (boolean )0;
    zero_times_ok = (char)0;
    many_times_ok = (char)0;
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      zero_times_ok = (char )((int )zero_times_ok | ((int )c != 43));
      many_times_ok = (char )((int )many_times_ok | ((int )c != 63));
      if ((unsigned long )p == (unsigned long )pend) {
        goto while_break___7;
      }
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        if ((unsigned long )p == (unsigned long )pend) {
          return ((reg_errcode_t )14);
        }
        tmp___10 = p;
        p ++;
        c = (unsigned char )*tmp___10;
        if (translate) {
          c = (unsigned char )*(translate + (int )c);
        }
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      if (! ((int )c == 42)) {
        if (! (syntax & (1UL << 1))) {
          if (! ((int )c == 43)) {
            if (! ((int )c == 63)) {
              goto _L___1;
            }
          }
        } else { //Added block
        _L___1: 
        if (syntax & (1UL << 1)) {
          if ((int )c == 92) {
            if ((unsigned long )p == (unsigned long )pend) {
              {
              free((void *)compile_stack.stack);
              }
              return ((reg_errcode_t )5);
            }
            {
            while (1) {
              while_continue___9: /* CIL Label */ ;
              if ((unsigned long )p == (unsigned long )pend) {
                return ((reg_errcode_t )14);
              }
              tmp___11 = p;
              p ++;
              c1 = (unsigned char )*tmp___11;
              if (translate) {
                c1 = (unsigned char )*(translate + (int )c1);
              }
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
            if (! ((int )c1 == 43)) {
              if (! ((int )c1 == 63)) {
                p --;
                p --;
                goto while_break___7;
              }
            }
            c = c1;
          } else {
            p --;
            goto while_break___7;
          }
        } else {
          p --;
          goto while_break___7;
        }
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    if (! laststart___0) {
      goto switch_break;
    }
    if (many_times_ok) {
      {
      while (1) {
        while_continue___10: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
          goto while_break___10;
        }
        {
        while (1) {
          while_continue___11: /* CIL Label */ ;
          old_buffer___1 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___12 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___12;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___1 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___1);
            begalt = bufp->buffer + (begalt - old_buffer___1);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___1);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___1);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___1);
            }
          }
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      if (translate) {
        tmp___13 = (int )*(translate + (int )((unsigned char )*(p - 2)));
      } else {
        tmp___13 = (int )*(p - 2);
      }
      if (translate) {
        tmp___14 = (int )*(translate + 46);
      } else {
        tmp___14 = '.';
      }
      if (tmp___13 == tmp___14) {
        if (zero_times_ok) {
          if ((unsigned long )p < (unsigned long )pend) {
            if (translate) {
              tmp___15 = (int )*(translate + (int )((unsigned char )*p));
            } else {
              tmp___15 = (int )*p;
            }
            if (translate) {
              tmp___16 = (int )*(translate + 10);
            } else {
              tmp___16 = '\n';
            }
            if (tmp___15 == tmp___16) {
              if (! (syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
                {
                store_op1((re_opcode_t )13, b, (int )((laststart___0 - b) - 3L));
                keep_string_p = (boolean )1;
                }
              } else {
                {
                store_op1((re_opcode_t )18, b, (int )(((laststart___0 - 3) - b) - 3L));
                }
              }
            } else {
              {
              store_op1((re_opcode_t )18, b, (int )(((laststart___0 - 3) - b) - 3L));
              }
            }
          } else {
            {
            store_op1((re_opcode_t )18, b, (int )(((laststart___0 - 3) - b) - 3L));
            }
          }
        } else {
          {
          store_op1((re_opcode_t )18, b, (int )(((laststart___0 - 3) - b) - 3L));
          }
        }
      } else {
        {
        store_op1((re_opcode_t )18, b, (int )(((laststart___0 - 3) - b) - 3L));
        }
      }
      b += 3;
    }
    {
    while (1) {
      while_continue___12: /* CIL Label */ ;
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
        goto while_break___12;
      }
      {
      while (1) {
        while_continue___13: /* CIL Label */ ;
        old_buffer___2 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((reg_errcode_t )15);
        }
        bufp->allocated <<= 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
        tmp___17 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)tmp___17;
        }
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((reg_errcode_t )12);
        }
        if ((unsigned long )old_buffer___2 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___2);
          begalt = bufp->buffer + (begalt - old_buffer___2);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___2);
          }
          if (laststart___0) {
            laststart___0 = bufp->buffer + (laststart___0 - old_buffer___2);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___2);
          }
        }
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    if (keep_string_p) {
      tmp___18 = 16;
    } else {
      tmp___18 = 15;
    }
    {
    insert_op1((re_opcode_t )tmp___18, laststart___0, (int )(((b + 3) - laststart___0) - 3L),
               b);
    pending_exact = (unsigned char *)0;
    b += 3;
    }
    if (! zero_times_ok) {
      {
      while (1) {
        while_continue___14: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
          goto while_break___14;
        }
        {
        while (1) {
          while_continue___15: /* CIL Label */ ;
          old_buffer___3 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___19 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___19;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___3 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___3);
            begalt = bufp->buffer + (begalt - old_buffer___3);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___3);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___3);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___3);
            }
          }
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      {
      insert_op1((re_opcode_t )19, laststart___0, (int )(((laststart___0 + 6) - laststart___0) - 3L),
                 b);
      b += 3;
      }
    }
    goto switch_break;
    case_46: /* CIL Label */ 
    laststart___0 = b;
    {
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
      while (1) {
        while_continue___17: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___17;
        }
        {
        while (1) {
          while_continue___18: /* CIL Label */ ;
          old_buffer___4 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___20 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___20;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___4 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___4);
            begalt = bufp->buffer + (begalt - old_buffer___4);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___4);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___4);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___4);
            }
          }
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      tmp___21 = b;
      b ++;
      *tmp___21 = (unsigned char)3;
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    goto switch_break;
    case_91: /* CIL Label */ 
    had_char_class = (boolean )0;
    if ((unsigned long )p == (unsigned long )pend) {
      {
      free((void *)compile_stack.stack);
      }
      return ((reg_errcode_t )7);
    }
    {
    while (1) {
      while_continue___19: /* CIL Label */ ;
      if (! ((unsigned long )((b - bufp->buffer) + 34L) > bufp->allocated)) {
        goto while_break___19;
      }
      {
      while (1) {
        while_continue___20: /* CIL Label */ ;
        old_buffer___5 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((reg_errcode_t )15);
        }
        bufp->allocated <<= 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
        tmp___22 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)tmp___22;
        }
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((reg_errcode_t )12);
        }
        if ((unsigned long )old_buffer___5 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___5);
          begalt = bufp->buffer + (begalt - old_buffer___5);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___5);
          }
          if (laststart___0) {
            laststart___0 = bufp->buffer + (laststart___0 - old_buffer___5);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___5);
          }
        }
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    laststart___0 = b;
    {
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
      while (1) {
        while_continue___22: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___22;
        }
        {
        while (1) {
          while_continue___23: /* CIL Label */ ;
          old_buffer___6 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___23 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___23;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___6 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___6);
            begalt = bufp->buffer + (begalt - old_buffer___6);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___6);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___6);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___6);
            }
          }
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      tmp___24 = b;
      b ++;
      if ((int const   )*p == 94) {
        tmp___25 = 5;
      } else {
        tmp___25 = 4;
      }
      *tmp___24 = (unsigned char )tmp___25;
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    if ((int const   )*p == 94) {
      p ++;
    }
    p1 = p;
    {
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
      while (1) {
        while_continue___25: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___25;
        }
        {
        while (1) {
          while_continue___26: /* CIL Label */ ;
          old_buffer___7 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___26 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___26;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___7 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___7);
            begalt = bufp->buffer + (begalt - old_buffer___7);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___7);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___7);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___7);
            }
          }
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
      tmp___27 = b;
      b ++;
      *tmp___27 = (unsigned char )((1 << 8) / 8);
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
    memset((void *)b, '\000', (size_t )((1 << 8) / 8));
    }
    if ((unsigned int )((re_opcode_t )*(b + -2)) == 5U) {
      if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        *(b + 1) = (unsigned char )((int )*(b + 1) | (1 << 2));
      }
    }
    {
    while (1) {
      while_continue___27: /* CIL Label */ ;
      if ((unsigned long )p == (unsigned long )pend) {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )7);
      }
      {
      while (1) {
        while_continue___28: /* CIL Label */ ;
        if ((unsigned long )p == (unsigned long )pend) {
          return ((reg_errcode_t )14);
        }
        tmp___28 = p;
        p ++;
        c = (unsigned char )*tmp___28;
        if (translate) {
          c = (unsigned char )*(translate + (int )c);
        }
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
      if (syntax & 1UL) {
        if ((int )c == 92) {
          if ((unsigned long )p == (unsigned long )pend) {
            {
            free((void *)compile_stack.stack);
            }
            return ((reg_errcode_t )5);
          }
          {
          while (1) {
            while_continue___29: /* CIL Label */ ;
            if ((unsigned long )p == (unsigned long )pend) {
              return ((reg_errcode_t )14);
            }
            tmp___29 = p;
            p ++;
            c1 = (unsigned char )*tmp___29;
            if (translate) {
              c1 = (unsigned char )*(translate + (int )c1);
            }
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
          *(b + (int )c1 / 8) = (unsigned char )((int )*(b + (int )c1 / 8) | (1 << (int )c1 % 8));
          goto __Cont;
        }
      }
      if ((int )c == 93) {
        if ((unsigned long )p != (unsigned long )(p1 + 1)) {
          goto while_break___27;
        }
      }
      if (had_char_class) {
        if ((int )c == 45) {
          if ((int const   )*p != 93) {
            {
            free((void *)compile_stack.stack);
            }
            return ((reg_errcode_t )11);
          }
        }
      }
      if ((int )c == 45) {
        if ((unsigned long )(p - 2) >= (unsigned long )pattern) {
          if ((int const   )*(p + -2) == 91) {
            goto _L___19;
          } else {
            goto _L___20;
          }
        } else { //Added block
        _L___20: 
        if ((unsigned long )(p - 3) >= (unsigned long )pattern) {
          if ((int const   )*(p + -3) == 91) {
            if ((int const   )*(p + -2) == 94) {
              goto _L___19;
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else { //Added block
        _L___18: 
        if ((int const   )*p != 93) {
          {
          tmp___30 = compile_range(& p, pend, translate, syntax, b);
          ret = tmp___30;
          }
          if ((unsigned int )ret != 0U) {
            {
            free((void *)compile_stack.stack);
            }
            return (ret);
          }
        } else {
          goto _L___19;
        }
        }
        }
      } else { //Added block
      _L___19: 
      if ((int const   )*(p + 0) == 45) {
        if ((int const   )*(p + 1) != 93) {
          {
          while (1) {
            while_continue___30: /* CIL Label */ ;
            if ((unsigned long )p == (unsigned long )pend) {
              return ((reg_errcode_t )14);
            }
            tmp___31 = p;
            p ++;
            c1 = (unsigned char )*tmp___31;
            if (translate) {
              c1 = (unsigned char )*(translate + (int )c1);
            }
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
          ret___0 = compile_range(& p, pend, translate, syntax, b);
          }
          if ((unsigned int )ret___0 != 0U) {
            {
            free((void *)compile_stack.stack);
            }
            return (ret___0);
          }
        } else {
          goto _L___14;
        }
      } else { //Added block
      _L___14: 
      if (syntax & ((1UL << 1) << 1)) {
        if ((int )c == 91) {
          if ((int const   )*p == 58) {
            {
            while (1) {
              while_continue___31: /* CIL Label */ ;
              if ((unsigned long )p == (unsigned long )pend) {
                return ((reg_errcode_t )14);
              }
              tmp___32 = p;
              p ++;
              c = (unsigned char )*tmp___32;
              if (translate) {
                c = (unsigned char )*(translate + (int )c);
              }
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
            c1 = (unsigned char)0;
            if ((unsigned long )p == (unsigned long )pend) {
              {
              free((void *)compile_stack.stack);
              }
              return ((reg_errcode_t )7);
            }
            {
            while (1) {
              while_continue___32: /* CIL Label */ ;
              {
              while (1) {
                while_continue___33: /* CIL Label */ ;
                if ((unsigned long )p == (unsigned long )pend) {
                  return ((reg_errcode_t )14);
                }
                tmp___33 = p;
                p ++;
                c = (unsigned char )*tmp___33;
                if (translate) {
                  c = (unsigned char )*(translate + (int )c);
                }
                goto while_break___33;
              }
              while_break___33: /* CIL Label */ ;
              }
              if ((int )c == 58) {
                if ((int const   )*p == 93) {
                  goto while_break___32;
                } else {
                  goto _L___2;
                }
              } else { //Added block
              _L___2: 
              if ((unsigned long )p == (unsigned long )pend) {
                goto while_break___32;
              }
              }
              if ((int )c1 < 6) {
                tmp___34 = c1;
                c1 = (unsigned char )((int )c1 + 1);
                str[tmp___34] = (char )c;
              } else {
                str[0] = (char )'\000';
              }
            }
            while_break___32: /* CIL Label */ ;
            }
            str[c1] = (char )'\000';
            if ((int )c == 58) {
              if ((int const   )*p == 93) {
                {
                tmp___35 = strcmp((char const   *)(str), "alnum");
                is_alnum___0 = (boolean )(tmp___35 == 0);
                tmp___36 = strcmp((char const   *)(str), "alpha");
                is_alpha___0 = (boolean )(tmp___36 == 0);
                tmp___37 = strcmp((char const   *)(str), "blank");
                is_blank___0 = (boolean )(tmp___37 == 0);
                tmp___38 = strcmp((char const   *)(str), "cntrl");
                is_cntrl___0 = (boolean )(tmp___38 == 0);
                tmp___39 = strcmp((char const   *)(str), "digit");
                is_digit___0 = (boolean )(tmp___39 == 0);
                tmp___40 = strcmp((char const   *)(str), "graph");
                is_graph___0 = (boolean )(tmp___40 == 0);
                tmp___41 = strcmp((char const   *)(str), "lower");
                is_lower___0 = (boolean )(tmp___41 == 0);
                tmp___42 = strcmp((char const   *)(str), "print");
                is_print___0 = (boolean )(tmp___42 == 0);
                tmp___43 = strcmp((char const   *)(str), "punct");
                is_punct___0 = (boolean )(tmp___43 == 0);
                tmp___44 = strcmp((char const   *)(str), "space");
                is_space___0 = (boolean )(tmp___44 == 0);
                tmp___45 = strcmp((char const   *)(str), "upper");
                is_upper___0 = (boolean )(tmp___45 == 0);
                tmp___46 = strcmp((char const   *)(str), "xdigit");
                is_xdigit___0 = (boolean )(tmp___46 == 0);
                tmp___47 = strcmp((char const   *)(str), "alpha");
                }
                if (! (tmp___47 == 0)) {
                  {
                  tmp___48 = strcmp((char const   *)(str), "upper");
                  }
                  if (! (tmp___48 == 0)) {
                    {
                    tmp___49 = strcmp((char const   *)(str), "lower");
                    }
                    if (! (tmp___49 == 0)) {
                      {
                      tmp___50 = strcmp((char const   *)(str), "digit");
                      }
                      if (! (tmp___50 == 0)) {
                        {
                        tmp___51 = strcmp((char const   *)(str), "alnum");
                        }
                        if (! (tmp___51 == 0)) {
                          {
                          tmp___52 = strcmp((char const   *)(str), "xdigit");
                          }
                          if (! (tmp___52 == 0)) {
                            {
                            tmp___53 = strcmp((char const   *)(str), "space");
                            }
                            if (! (tmp___53 == 0)) {
                              {
                              tmp___54 = strcmp((char const   *)(str), "print");
                              }
                              if (! (tmp___54 == 0)) {
                                {
                                tmp___55 = strcmp((char const   *)(str), "punct");
                                }
                                if (! (tmp___55 == 0)) {
                                  {
                                  tmp___56 = strcmp((char const   *)(str), "graph");
                                  }
                                  if (! (tmp___56 == 0)) {
                                    {
                                    tmp___57 = strcmp((char const   *)(str), "cntrl");
                                    }
                                    if (! (tmp___57 == 0)) {
                                      {
                                      tmp___58 = strcmp((char const   *)(str), "blank");
                                      }
                                      if (! (tmp___58 == 0)) {
                                        {
                                        free((void *)compile_stack.stack);
                                        }
                                        return ((reg_errcode_t )4);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                {
                while (1) {
                  while_continue___34: /* CIL Label */ ;
                  if ((unsigned long )p == (unsigned long )pend) {
                    return ((reg_errcode_t )14);
                  }
                  tmp___59 = p;
                  p ++;
                  c = (unsigned char )*tmp___59;
                  if (translate) {
                    c = (unsigned char )*(translate + (int )c);
                  }
                  goto while_break___34;
                }
                while_break___34: /* CIL Label */ ;
                }
                if ((unsigned long )p == (unsigned long )pend) {
                  {
                  free((void *)compile_stack.stack);
                  }
                  return ((reg_errcode_t )7);
                }
                ch = 0;
                {
                while (1) {
                  while_continue___35: /* CIL Label */ ;
                  if (! (ch < 1 << 8)) {
                    goto while_break___35;
                  }
                  if (is_alnum___0) {
                    {
                    tmp___60 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___60 + ch) & 8) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___5;
                    }
                  } else { //Added block
                  _L___5: 
                  if (is_alpha___0) {
                    {
                    tmp___61 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___61 + ch) & 1024) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___4;
                    }
                  } else { //Added block
                  _L___4: 
                  if (is_blank___0) {
                    {
                    tmp___62 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___62 + ch) & 1) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___3;
                    }
                  } else { //Added block
                  _L___3: 
                  if (is_cntrl___0) {
                    {
                    tmp___63 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___63 + ch) & 2) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
                  }
                  }
                  }
                  if (is_digit___0) {
                    {
                    tmp___64 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___64 + ch) & 2048) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___8;
                    }
                  } else { //Added block
                  _L___8: 
                  if (is_graph___0) {
                    {
                    tmp___65 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___65 + ch) & 32768) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___7;
                    }
                  } else { //Added block
                  _L___7: 
                  if (is_lower___0) {
                    {
                    tmp___66 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___66 + ch) & 512) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___6;
                    }
                  } else { //Added block
                  _L___6: 
                  if (is_print___0) {
                    {
                    tmp___67 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___67 + ch) & 16384) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
                  }
                  }
                  }
                  if (is_punct___0) {
                    {
                    tmp___68 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___68 + ch) & 4) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___11;
                    }
                  } else { //Added block
                  _L___11: 
                  if (is_space___0) {
                    {
                    tmp___69 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___69 + ch) & 8192) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___10;
                    }
                  } else { //Added block
                  _L___10: 
                  if (is_upper___0) {
                    {
                    tmp___70 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___70 + ch) & 256) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
                      goto _L___9;
                    }
                  } else { //Added block
                  _L___9: 
                  if (is_xdigit___0) {
                    {
                    tmp___71 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___71 + ch) & 4096) {
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
                  }
                  }
                  }
                  if (translate) {
                    if (is_upper___0) {
                      goto _L___12;
                    } else { //Added block
                    if (is_lower___0) {
                      _L___12: 
                      {
                      tmp___72 = __ctype_b_loc();
                      }
                      if ((int const   )*(*tmp___72 + ch) & 256) {
                        *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                      } else {
                        {
                        tmp___73 = __ctype_b_loc();
                        }
                        if ((int const   )*(*tmp___73 + ch) & 512) {
                          *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                        }
                      }
                    }
                    }
                  }
                  ch ++;
                }
                while_break___35: /* CIL Label */ ;
                }
                had_char_class = (boolean )1;
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
              c1 = (unsigned char )((int )c1 + 1);
              {
              while (1) {
                while_continue___36: /* CIL Label */ ;
                tmp___74 = c1;
                c1 = (unsigned char )((int )c1 - 1);
                if (! tmp___74) {
                  goto while_break___36;
                }
                p --;
              }
              while_break___36: /* CIL Label */ ;
              }
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
              *(b + 7) = (unsigned char )((int )*(b + 7) | (1 << 2));
              had_char_class = (boolean )0;
            }
          } else {
            had_char_class = (boolean )0;
            *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
          }
        } else {
          had_char_class = (boolean )0;
          *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
        }
      } else {
        had_char_class = (boolean )0;
        *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
      }
      }
      }
      __Cont: ;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___37: /* CIL Label */ ;
      if ((int )*(b + -1) > 0) {
        if (! ((int )*(b + ((int )*(b + -1) - 1)) == 0)) {
          goto while_break___37;
        }
      } else {
        goto while_break___37;
      }
      *(b + -1) = (unsigned char )((int )*(b + -1) - 1);
    }
    while_break___37: /* CIL Label */ ;
    }
    b += (int )*(b + -1);
    goto switch_break;
    case_40: /* CIL Label */ 
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_open;
    } else {
      goto normal_char;
    }
    case_41: /* CIL Label */ 
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_close;
    } else {
      goto normal_char;
    }
    case_10: /* CIL Label */ 
    if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_alt;
    } else {
      goto normal_char;
    }
    case_124: /* CIL Label */ 
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_alt;
    } else {
      goto normal_char;
    }
    case_123: /* CIL Label */ 
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto handle_interval;
      } else {
        goto normal_char;
      }
    } else {
      goto normal_char;
    }
    case_92: /* CIL Label */ 
    if ((unsigned long )p == (unsigned long )pend) {
      {
      free((void *)compile_stack.stack);
      }
      return ((reg_errcode_t )5);
    }
    {
    while (1) {
      while_continue___38: /* CIL Label */ ;
      if ((unsigned long )p == (unsigned long )pend) {
        return ((reg_errcode_t )14);
      }
      tmp___75 = p;
      p ++;
      c = (unsigned char )*tmp___75;
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
    if ((int )c == 40) {
      goto case_40___0;
    }
    if ((int )c == 41) {
      goto case_41___0;
    }
    if ((int )c == 124) {
      goto case_124___0;
    }
    if ((int )c == 123) {
      goto case_123___0;
    }
    if ((int )c == 119) {
      goto case_119;
    }
    if ((int )c == 87) {
      goto case_87;
    }
    if ((int )c == 60) {
      goto case_60;
    }
    if ((int )c == 62) {
      goto case_62;
    }
    if ((int )c == 98) {
      goto case_98;
    }
    if ((int )c == 66) {
      goto case_66;
    }
    if ((int )c == 96) {
      goto case_96;
    }
    if ((int )c == 39) {
      goto case_39;
    }
    if ((int )c == 49) {
      goto case_49;
    }
    if ((int )c == 50) {
      goto case_49;
    }
    if ((int )c == 51) {
      goto case_49;
    }
    if ((int )c == 52) {
      goto case_49;
    }
    if ((int )c == 53) {
      goto case_49;
    }
    if ((int )c == 54) {
      goto case_49;
    }
    if ((int )c == 55) {
      goto case_49;
    }
    if ((int )c == 56) {
      goto case_49;
    }
    if ((int )c == 57) {
      goto case_49;
    }
    if ((int )c == 43) {
      goto case_43___0;
    }
    if ((int )c == 63) {
      goto case_43___0;
    }
    goto normal_backslash;
    case_40___0: /* CIL Label */ 
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_backslash;
    }
    handle_open: 
    (bufp->re_nsub) ++;
    regnum ++;
    if (compile_stack.avail == compile_stack.size) {
      {
      tmp___76 = realloc((void *)compile_stack.stack, (unsigned long )(compile_stack.size << 1) * sizeof(compile_stack_elt_t ));
      compile_stack.stack = (compile_stack_elt_t *)tmp___76;
      }
      if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
        return ((reg_errcode_t )12);
      }
      compile_stack.size <<= 1;
    }
    (compile_stack.stack + compile_stack.avail)->begalt_offset = begalt - bufp->buffer;
    if (fixup_alt_jump) {
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (fixup_alt_jump - bufp->buffer) + 1L;
    } else {
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (pattern_offset_t )0;
    }
    (compile_stack.stack + compile_stack.avail)->laststart_offset = b - bufp->buffer;
    (compile_stack.stack + compile_stack.avail)->regnum = regnum;
    if (regnum <= 255U) {
      (compile_stack.stack + compile_stack.avail)->inner_group_offset = (b - bufp->buffer) + 2L;
      {
      while (1) {
        while_continue___39: /* CIL Label */ ;
        {
        while (1) {
          while_continue___40: /* CIL Label */ ;
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
            goto while_break___40;
          }
          {
          while (1) {
            while_continue___41: /* CIL Label */ ;
            old_buffer___8 = bufp->buffer;
            if (bufp->allocated == (unsigned long )(1L << 16)) {
              return ((reg_errcode_t )15);
            }
            bufp->allocated <<= 1;
            if (bufp->allocated > (unsigned long )(1L << 16)) {
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
            tmp___77 = realloc((void *)bufp->buffer, bufp->allocated);
            bufp->buffer = (unsigned char *)tmp___77;
            }
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
              return ((reg_errcode_t )12);
            }
            if ((unsigned long )old_buffer___8 != (unsigned long )bufp->buffer) {
              b = bufp->buffer + (b - old_buffer___8);
              begalt = bufp->buffer + (begalt - old_buffer___8);
              if (fixup_alt_jump) {
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___8);
              }
              if (laststart___0) {
                laststart___0 = bufp->buffer + (laststart___0 - old_buffer___8);
              }
              if (pending_exact) {
                pending_exact = bufp->buffer + (pending_exact - old_buffer___8);
              }
            }
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
        }
        while_break___40: /* CIL Label */ ;
        }
        tmp___78 = b;
        b ++;
        *tmp___78 = (unsigned char)6;
        tmp___79 = b;
        b ++;
        *tmp___79 = (unsigned char )regnum;
        tmp___80 = b;
        b ++;
        *tmp___80 = (unsigned char)0;
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
    }
    (compile_stack.avail) ++;
    fixup_alt_jump = (unsigned char *)0;
    laststart___0 = (unsigned char *)0;
    begalt = b;
    pending_exact = (unsigned char *)0;
    goto switch_break___0;
    case_41___0: /* CIL Label */ 
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_backslash;
    }
    if (compile_stack.avail == 0U) {
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_backslash;
      } else {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )16);
      }
    }
    handle_close: 
    if (fixup_alt_jump) {
      {
      while (1) {
        while_continue___42: /* CIL Label */ ;
        {
        while (1) {
          while_continue___43: /* CIL Label */ ;
          if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
            goto while_break___43;
          }
          {
          while (1) {
            while_continue___44: /* CIL Label */ ;
            old_buffer___9 = bufp->buffer;
            if (bufp->allocated == (unsigned long )(1L << 16)) {
              return ((reg_errcode_t )15);
            }
            bufp->allocated <<= 1;
            if (bufp->allocated > (unsigned long )(1L << 16)) {
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
            tmp___81 = realloc((void *)bufp->buffer, bufp->allocated);
            bufp->buffer = (unsigned char *)tmp___81;
            }
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
              return ((reg_errcode_t )12);
            }
            if ((unsigned long )old_buffer___9 != (unsigned long )bufp->buffer) {
              b = bufp->buffer + (b - old_buffer___9);
              begalt = bufp->buffer + (begalt - old_buffer___9);
              if (fixup_alt_jump) {
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___9);
              }
              if (laststart___0) {
                laststart___0 = bufp->buffer + (laststart___0 - old_buffer___9);
              }
              if (pending_exact) {
                pending_exact = bufp->buffer + (pending_exact - old_buffer___9);
              }
            }
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
        }
        while_break___43: /* CIL Label */ ;
        }
        tmp___82 = b;
        b ++;
        *tmp___82 = (unsigned char)20;
        goto while_break___42;
      }
      while_break___42: /* CIL Label */ ;
      }
      {
      store_op1((re_opcode_t )14, fixup_alt_jump, (int )(((b - 1) - fixup_alt_jump) - 3L));
      }
    }
    if (compile_stack.avail == 0U) {
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      } else {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )16);
      }
    }
    (compile_stack.avail) --;
    begalt = bufp->buffer + (compile_stack.stack + compile_stack.avail)->begalt_offset;
    if ((compile_stack.stack + compile_stack.avail)->fixup_alt_jump) {
      fixup_alt_jump = (bufp->buffer + (compile_stack.stack + compile_stack.avail)->fixup_alt_jump) - 1;
    } else {
      fixup_alt_jump = (unsigned char *)0;
    }
    laststart___0 = bufp->buffer + (compile_stack.stack + compile_stack.avail)->laststart_offset;
    this_group_regnum = (compile_stack.stack + compile_stack.avail)->regnum;
    pending_exact = (unsigned char *)0;
    if (this_group_regnum <= 255U) {
      inner_group_loc = bufp->buffer + (compile_stack.stack + compile_stack.avail)->inner_group_offset;
      *inner_group_loc = (unsigned char )(regnum - this_group_regnum);
      {
      while (1) {
        while_continue___45: /* CIL Label */ ;
        {
        while (1) {
          while_continue___46: /* CIL Label */ ;
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
            goto while_break___46;
          }
          {
          while (1) {
            while_continue___47: /* CIL Label */ ;
            old_buffer___10 = bufp->buffer;
            if (bufp->allocated == (unsigned long )(1L << 16)) {
              return ((reg_errcode_t )15);
            }
            bufp->allocated <<= 1;
            if (bufp->allocated > (unsigned long )(1L << 16)) {
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
            tmp___83 = realloc((void *)bufp->buffer, bufp->allocated);
            bufp->buffer = (unsigned char *)tmp___83;
            }
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
              return ((reg_errcode_t )12);
            }
            if ((unsigned long )old_buffer___10 != (unsigned long )bufp->buffer) {
              b = bufp->buffer + (b - old_buffer___10);
              begalt = bufp->buffer + (begalt - old_buffer___10);
              if (fixup_alt_jump) {
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___10);
              }
              if (laststart___0) {
                laststart___0 = bufp->buffer + (laststart___0 - old_buffer___10);
              }
              if (pending_exact) {
                pending_exact = bufp->buffer + (pending_exact - old_buffer___10);
              }
            }
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
        }
        while_break___46: /* CIL Label */ ;
        }
        tmp___84 = b;
        b ++;
        *tmp___84 = (unsigned char)7;
        tmp___85 = b;
        b ++;
        *tmp___85 = (unsigned char )this_group_regnum;
        tmp___86 = b;
        b ++;
        *tmp___86 = (unsigned char )(regnum - this_group_regnum);
        goto while_break___45;
      }
      while_break___45: /* CIL Label */ ;
      }
    }
    goto switch_break___0;
    case_124___0: /* CIL Label */ 
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_backslash;
    } else { //Added block
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_backslash;
    }
    }
    handle_alt: 
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    {
    while (1) {
      while_continue___48: /* CIL Label */ ;
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
        goto while_break___48;
      }
      {
      while (1) {
        while_continue___49: /* CIL Label */ ;
        old_buffer___11 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((reg_errcode_t )15);
        }
        bufp->allocated <<= 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
        tmp___87 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)tmp___87;
        }
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((reg_errcode_t )12);
        }
        if ((unsigned long )old_buffer___11 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___11);
          begalt = bufp->buffer + (begalt - old_buffer___11);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___11);
          }
          if (laststart___0) {
            laststart___0 = bufp->buffer + (laststart___0 - old_buffer___11);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___11);
          }
        }
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
    }
    while_break___48: /* CIL Label */ ;
    }
    {
    insert_op1((re_opcode_t )15, begalt, (int )(((b + 6) - begalt) - 3L), b);
    pending_exact = (unsigned char *)0;
    b += 3;
    }
    if (fixup_alt_jump) {
      {
      store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
      }
    }
    fixup_alt_jump = b;
    {
    while (1) {
      while_continue___50: /* CIL Label */ ;
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
        goto while_break___50;
      }
      {
      while (1) {
        while_continue___51: /* CIL Label */ ;
        old_buffer___12 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((reg_errcode_t )15);
        }
        bufp->allocated <<= 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
        tmp___88 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)tmp___88;
        }
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((reg_errcode_t )12);
        }
        if ((unsigned long )old_buffer___12 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___12);
          begalt = bufp->buffer + (begalt - old_buffer___12);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___12);
          }
          if (laststart___0) {
            laststart___0 = bufp->buffer + (laststart___0 - old_buffer___12);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___12);
          }
        }
        goto while_break___51;
      }
      while_break___51: /* CIL Label */ ;
      }
    }
    while_break___50: /* CIL Label */ ;
    }
    b += 3;
    laststart___0 = (unsigned char *)0;
    begalt = b;
    goto switch_break___0;
    case_123___0: /* CIL Label */ 
    if (! (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      goto normal_backslash;
    } else { //Added block
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_backslash;
      } else {
        goto _L___21;
      }
    } else { //Added block
    _L___21: 
    if ((unsigned long )(p - 2) == (unsigned long )pattern) {
      if ((unsigned long )p == (unsigned long )pend) {
        goto normal_backslash;
      }
    }
    }
    }
    handle_interval: 
    lower_bound = -1;
    upper_bound = -1;
    beg_interval = p - 1;
    if ((unsigned long )p == (unsigned long )pend) {
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto unfetch_interval;
      } else {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )9);
      }
    }
    if ((unsigned long )p != (unsigned long )pend) {
      {
      while (1) {
        while_continue___52: /* CIL Label */ ;
        if ((unsigned long )p == (unsigned long )pend) {
          return ((reg_errcode_t )14);
        }
        tmp___89 = p;
        p ++;
        c = (unsigned char )*tmp___89;
        if (translate) {
          c = (unsigned char )*(translate + (int )c);
        }
        goto while_break___52;
      }
      while_break___52: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___53: /* CIL Label */ ;
        if (48 <= (int )c) {
          if (! ((int )c <= 57)) {
            goto while_break___53;
          }
        } else {
          goto while_break___53;
        }
        if (lower_bound < 0) {
          lower_bound = 0;
        }
        lower_bound = (lower_bound * 10 + (int )c) - 48;
        if ((unsigned long )p == (unsigned long )pend) {
          goto while_break___53;
        }
        {
        while (1) {
          while_continue___54: /* CIL Label */ ;
          if ((unsigned long )p == (unsigned long )pend) {
            return ((reg_errcode_t )14);
          }
          tmp___90 = p;
          p ++;
          c = (unsigned char )*tmp___90;
          if (translate) {
            c = (unsigned char )*(translate + (int )c);
          }
          goto while_break___54;
        }
        while_break___54: /* CIL Label */ ;
        }
      }
      while_break___53: /* CIL Label */ ;
      }
    }
    if ((int )c == 44) {
      if ((unsigned long )p != (unsigned long )pend) {
        {
        while (1) {
          while_continue___55: /* CIL Label */ ;
          if ((unsigned long )p == (unsigned long )pend) {
            return ((reg_errcode_t )14);
          }
          tmp___91 = p;
          p ++;
          c = (unsigned char )*tmp___91;
          if (translate) {
            c = (unsigned char )*(translate + (int )c);
          }
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
        {
        while (1) {
          while_continue___56: /* CIL Label */ ;
          if (48 <= (int )c) {
            if (! ((int )c <= 57)) {
              goto while_break___56;
            }
          } else {
            goto while_break___56;
          }
          if (upper_bound < 0) {
            upper_bound = 0;
          }
          upper_bound = (upper_bound * 10 + (int )c) - 48;
          if ((unsigned long )p == (unsigned long )pend) {
            goto while_break___56;
          }
          {
          while (1) {
            while_continue___57: /* CIL Label */ ;
            if ((unsigned long )p == (unsigned long )pend) {
              return ((reg_errcode_t )14);
            }
            tmp___92 = p;
            p ++;
            c = (unsigned char )*tmp___92;
            if (translate) {
              c = (unsigned char )*(translate + (int )c);
            }
            goto while_break___57;
          }
          while_break___57: /* CIL Label */ ;
          }
        }
        while_break___56: /* CIL Label */ ;
        }
      }
      if (upper_bound < 0) {
        upper_bound = 32767;
      }
    } else {
      upper_bound = lower_bound;
    }
    if (lower_bound < 0) {
      goto _L___22;
    } else { //Added block
    if (upper_bound > 32767) {
      goto _L___22;
    } else { //Added block
    if (lower_bound > upper_bound) {
      _L___22: 
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto unfetch_interval;
      } else {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )10);
      }
    }
    }
    }
    if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if ((int )c != 92) {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )9);
      }
      {
      while (1) {
        while_continue___58: /* CIL Label */ ;
        if ((unsigned long )p == (unsigned long )pend) {
          return ((reg_errcode_t )14);
        }
        tmp___93 = p;
        p ++;
        c = (unsigned char )*tmp___93;
        if (translate) {
          c = (unsigned char )*(translate + (int )c);
        }
        goto while_break___58;
      }
      while_break___58: /* CIL Label */ ;
      }
    }
    if ((int )c != 125) {
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto unfetch_interval;
      } else {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )10);
      }
    }
    if (! laststart___0) {
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
        {
        free((void *)compile_stack.stack);
        }
        return ((reg_errcode_t )13);
      } else { //Added block
      if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
        laststart___0 = b;
      } else {
        goto unfetch_interval;
      }
      }
    }
    if (upper_bound == 0) {
      {
      while (1) {
        while_continue___59: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
          goto while_break___59;
        }
        {
        while (1) {
          while_continue___60: /* CIL Label */ ;
          old_buffer___13 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___94 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___94;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___13 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___13);
            begalt = bufp->buffer + (begalt - old_buffer___13);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___13);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___13);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___13);
            }
          }
          goto while_break___60;
        }
        while_break___60: /* CIL Label */ ;
        }
      }
      while_break___59: /* CIL Label */ ;
      }
      {
      insert_op1((re_opcode_t )13, laststart___0, (int )(((b + 3) - laststart___0) - 3L),
                 b);
      b += 3;
      }
    } else {
      nbytes = (unsigned int )(10 + (upper_bound > 1) * 10);
      {
      while (1) {
        while_continue___61: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + (long )nbytes) > bufp->allocated)) {
          goto while_break___61;
        }
        {
        while (1) {
          while_continue___62: /* CIL Label */ ;
          old_buffer___14 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___95 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___95;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___14 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___14);
            begalt = bufp->buffer + (begalt - old_buffer___14);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___14);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___14);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___14);
            }
          }
          goto while_break___62;
        }
        while_break___62: /* CIL Label */ ;
        }
      }
      while_break___61: /* CIL Label */ ;
      }
      {
      insert_op2((re_opcode_t )21, laststart___0, (int )((((b + 5) + (upper_bound > 1) * 5) - laststart___0) - 3L),
                 lower_bound, b);
      b += 5;
      insert_op2((re_opcode_t )23, laststart___0, 5, lower_bound, b);
      b += 5;
      }
      if (upper_bound > 1) {
        {
        store_op2((re_opcode_t )22, b, (int )(((laststart___0 + 5) - b) - 3L), upper_bound - 1);
        b += 5;
        insert_op2((re_opcode_t )23, laststart___0, (int )(b - laststart___0), upper_bound - 1,
                   b);
        b += 5;
        }
      }
    }
    pending_exact = (unsigned char *)0;
    beg_interval = (char const   *)((void *)0);
    goto switch_break___0;
    unfetch_interval: 
    p = beg_interval;
    beg_interval = (char const   *)((void *)0);
    {
    while (1) {
      while_continue___63: /* CIL Label */ ;
      if ((unsigned long )p == (unsigned long )pend) {
        return ((reg_errcode_t )14);
      }
      tmp___96 = p;
      p ++;
      c = (unsigned char )*tmp___96;
      if (translate) {
        c = (unsigned char )*(translate + (int )c);
      }
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
    if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if ((unsigned long )p > (unsigned long )pattern) {
        if ((int const   )*(p + -1) == 92) {
          goto normal_backslash;
        }
      }
    }
    goto normal_char;
    case_119: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    laststart___0 = b;
    {
    while (1) {
      while_continue___64: /* CIL Label */ ;
      {
      while (1) {
        while_continue___65: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___65;
        }
        {
        while (1) {
          while_continue___66: /* CIL Label */ ;
          old_buffer___15 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___97 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___97;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___15 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___15);
            begalt = bufp->buffer + (begalt - old_buffer___15);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___15);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___15);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___15);
            }
          }
          goto while_break___66;
        }
        while_break___66: /* CIL Label */ ;
        }
      }
      while_break___65: /* CIL Label */ ;
      }
      tmp___98 = b;
      b ++;
      *tmp___98 = (unsigned char)24;
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_87: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    laststart___0 = b;
    {
    while (1) {
      while_continue___67: /* CIL Label */ ;
      {
      while (1) {
        while_continue___68: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___68;
        }
        {
        while (1) {
          while_continue___69: /* CIL Label */ ;
          old_buffer___16 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___99 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___99;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___16 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___16);
            begalt = bufp->buffer + (begalt - old_buffer___16);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___16);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___16);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___16);
            }
          }
          goto while_break___69;
        }
        while_break___69: /* CIL Label */ ;
        }
      }
      while_break___68: /* CIL Label */ ;
      }
      tmp___100 = b;
      b ++;
      *tmp___100 = (unsigned char)25;
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_60: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    {
    while (1) {
      while_continue___70: /* CIL Label */ ;
      {
      while (1) {
        while_continue___71: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___71;
        }
        {
        while (1) {
          while_continue___72: /* CIL Label */ ;
          old_buffer___17 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___101 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___101;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___17 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___17);
            begalt = bufp->buffer + (begalt - old_buffer___17);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___17);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___17);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___17);
            }
          }
          goto while_break___72;
        }
        while_break___72: /* CIL Label */ ;
        }
      }
      while_break___71: /* CIL Label */ ;
      }
      tmp___102 = b;
      b ++;
      *tmp___102 = (unsigned char)26;
      goto while_break___70;
    }
    while_break___70: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_62: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    {
    while (1) {
      while_continue___73: /* CIL Label */ ;
      {
      while (1) {
        while_continue___74: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___74;
        }
        {
        while (1) {
          while_continue___75: /* CIL Label */ ;
          old_buffer___18 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___103 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___103;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___18 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___18);
            begalt = bufp->buffer + (begalt - old_buffer___18);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___18);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___18);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___18);
            }
          }
          goto while_break___75;
        }
        while_break___75: /* CIL Label */ ;
        }
      }
      while_break___74: /* CIL Label */ ;
      }
      tmp___104 = b;
      b ++;
      *tmp___104 = (unsigned char)27;
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_98: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    {
    while (1) {
      while_continue___76: /* CIL Label */ ;
      {
      while (1) {
        while_continue___77: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___77;
        }
        {
        while (1) {
          while_continue___78: /* CIL Label */ ;
          old_buffer___19 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___105 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___105;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___19 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___19);
            begalt = bufp->buffer + (begalt - old_buffer___19);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___19);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___19);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___19);
            }
          }
          goto while_break___78;
        }
        while_break___78: /* CIL Label */ ;
        }
      }
      while_break___77: /* CIL Label */ ;
      }
      tmp___106 = b;
      b ++;
      *tmp___106 = (unsigned char)28;
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_66: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    {
    while (1) {
      while_continue___79: /* CIL Label */ ;
      {
      while (1) {
        while_continue___80: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___80;
        }
        {
        while (1) {
          while_continue___81: /* CIL Label */ ;
          old_buffer___20 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___107 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___107;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___20 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___20);
            begalt = bufp->buffer + (begalt - old_buffer___20);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___20);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___20);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___20);
            }
          }
          goto while_break___81;
        }
        while_break___81: /* CIL Label */ ;
        }
      }
      while_break___80: /* CIL Label */ ;
      }
      tmp___108 = b;
      b ++;
      *tmp___108 = (unsigned char)29;
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_96: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    {
    while (1) {
      while_continue___82: /* CIL Label */ ;
      {
      while (1) {
        while_continue___83: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___83;
        }
        {
        while (1) {
          while_continue___84: /* CIL Label */ ;
          old_buffer___21 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___109 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___109;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___21 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___21);
            begalt = bufp->buffer + (begalt - old_buffer___21);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___21);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___21);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___21);
            }
          }
          goto while_break___84;
        }
        while_break___84: /* CIL Label */ ;
        }
      }
      while_break___83: /* CIL Label */ ;
      }
      tmp___110 = b;
      b ++;
      *tmp___110 = (unsigned char)11;
      goto while_break___82;
    }
    while_break___82: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_39: /* CIL Label */ 
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    {
    while (1) {
      while_continue___85: /* CIL Label */ ;
      {
      while (1) {
        while_continue___86: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___86;
        }
        {
        while (1) {
          while_continue___87: /* CIL Label */ ;
          old_buffer___22 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___111 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___111;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___22 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___22);
            begalt = bufp->buffer + (begalt - old_buffer___22);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___22);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___22);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___22);
            }
          }
          goto while_break___87;
        }
        while_break___87: /* CIL Label */ ;
        }
      }
      while_break___86: /* CIL Label */ ;
      }
      tmp___112 = b;
      b ++;
      *tmp___112 = (unsigned char)12;
      goto while_break___85;
    }
    while_break___85: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_49: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_57: /* CIL Label */ 
    if (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    c1 = (unsigned char )((int )c - 48);
    if ((regnum_t )c1 > regnum) {
      {
      free((void *)compile_stack.stack);
      }
      return ((reg_errcode_t )6);
    }
    {
    tmp___113 = group_in_compile_stack(compile_stack, (regnum_t )c1);
    }
    if (tmp___113) {
      goto normal_char;
    }
    laststart___0 = b;
    {
    while (1) {
      while_continue___88: /* CIL Label */ ;
      {
      while (1) {
        while_continue___89: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
          goto while_break___89;
        }
        {
        while (1) {
          while_continue___90: /* CIL Label */ ;
          old_buffer___23 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___114 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___114;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___23 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___23);
            begalt = bufp->buffer + (begalt - old_buffer___23);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___23);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___23);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___23);
            }
          }
          goto while_break___90;
        }
        while_break___90: /* CIL Label */ ;
        }
      }
      while_break___89: /* CIL Label */ ;
      }
      tmp___115 = b;
      b ++;
      *tmp___115 = (unsigned char)8;
      tmp___116 = b;
      b ++;
      *tmp___116 = c1;
      goto while_break___88;
    }
    while_break___88: /* CIL Label */ ;
    }
    goto switch_break___0;
    case_43___0: /* CIL Label */ 
    case_63___0: /* CIL Label */ 
    if (syntax & (1UL << 1)) {
      goto handle_plus;
    }
    normal_backslash: 
    switch_default: /* CIL Label */ 
    if (translate) {
      c = (unsigned char )*(translate + (int )c);
    } else {
      c = c;
    }
    goto normal_char;
    switch_break___0: /* CIL Label */ ;
    }
    goto switch_break;
    normal_char: 
    switch_default___0: /* CIL Label */ 
    if (! pending_exact) {
      goto _L___23;
    } else { //Added block
    if ((unsigned long )((pending_exact + (int )*pending_exact) + 1) != (unsigned long )b) {
      goto _L___23;
    } else { //Added block
    if ((int )*pending_exact == (1 << 8) - 1) {
      goto _L___23;
    } else { //Added block
    if ((int const   )*p == 42) {
      goto _L___23;
    } else { //Added block
    if ((int const   )*p == 94) {
      goto _L___23;
    } else {
      if (syntax & (1UL << 1)) {
        if ((int const   )*p == 92) {
          if ((int const   )*(p + 1) == 43) {
            tmp___120 = 1;
          } else { //Added block
          if ((int const   )*(p + 1) == 63) {
            tmp___120 = 1;
          } else {
            tmp___120 = 0;
          }
          }
        } else {
          tmp___120 = 0;
        }
        tmp___122 = tmp___120;
      } else {
        if ((int const   )*p == 43) {
          tmp___121 = 1;
        } else { //Added block
        if ((int const   )*p == 63) {
          tmp___121 = 1;
        } else {
          tmp___121 = 0;
        }
        }
        tmp___122 = tmp___121;
      }
      if (tmp___122) {
        goto _L___23;
      } else { //Added block
      if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          tmp___124 = (int const   )*p == 123;
        } else {
          if ((int const   )*(p + 0) == 92) {
            if ((int const   )*(p + 1) == 123) {
              tmp___123 = 1;
            } else {
              tmp___123 = 0;
            }
          } else {
            tmp___123 = 0;
          }
          tmp___124 = tmp___123;
        }
        if (tmp___124) {
          _L___23: 
          laststart___0 = b;
          {
          while (1) {
            while_continue___91: /* CIL Label */ ;
            {
            while (1) {
              while_continue___92: /* CIL Label */ ;
              if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
                goto while_break___92;
              }
              {
              while (1) {
                while_continue___93: /* CIL Label */ ;
                old_buffer___24 = bufp->buffer;
                if (bufp->allocated == (unsigned long )(1L << 16)) {
                  return ((reg_errcode_t )15);
                }
                bufp->allocated <<= 1;
                if (bufp->allocated > (unsigned long )(1L << 16)) {
                  bufp->allocated = (unsigned long )(1L << 16);
                }
                {
                tmp___117 = realloc((void *)bufp->buffer, bufp->allocated);
                bufp->buffer = (unsigned char *)tmp___117;
                }
                if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
                  return ((reg_errcode_t )12);
                }
                if ((unsigned long )old_buffer___24 != (unsigned long )bufp->buffer) {
                  b = bufp->buffer + (b - old_buffer___24);
                  begalt = bufp->buffer + (begalt - old_buffer___24);
                  if (fixup_alt_jump) {
                    fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___24);
                  }
                  if (laststart___0) {
                    laststart___0 = bufp->buffer + (laststart___0 - old_buffer___24);
                  }
                  if (pending_exact) {
                    pending_exact = bufp->buffer + (pending_exact - old_buffer___24);
                  }
                }
                goto while_break___93;
              }
              while_break___93: /* CIL Label */ ;
              }
            }
            while_break___92: /* CIL Label */ ;
            }
            tmp___118 = b;
            b ++;
            *tmp___118 = (unsigned char)2;
            tmp___119 = b;
            b ++;
            *tmp___119 = (unsigned char)0;
            goto while_break___91;
          }
          while_break___91: /* CIL Label */ ;
          }
          pending_exact = b - 1;
        }
      }
      }
    }
    }
    }
    }
    }
    {
    while (1) {
      while_continue___94: /* CIL Label */ ;
      {
      while (1) {
        while_continue___95: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___95;
        }
        {
        while (1) {
          while_continue___96: /* CIL Label */ ;
          old_buffer___25 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___125 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___125;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___25 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___25);
            begalt = bufp->buffer + (begalt - old_buffer___25);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___25);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___25);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___25);
            }
          }
          goto while_break___96;
        }
        while_break___96: /* CIL Label */ ;
        }
      }
      while_break___95: /* CIL Label */ ;
      }
      tmp___126 = b;
      b ++;
      *tmp___126 = c;
      goto while_break___94;
    }
    while_break___94: /* CIL Label */ ;
    }
    *pending_exact = (unsigned char )((int )*pending_exact + 1);
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (fixup_alt_jump) {
    {
    store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
    }
  }
  if (! (compile_stack.avail == 0U)) {
    {
    free((void *)compile_stack.stack);
    }
    return ((reg_errcode_t )8);
  }
  if (syntax & ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
    while (1) {
      while_continue___97: /* CIL Label */ ;
      {
      while (1) {
        while_continue___98: /* CIL Label */ ;
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
          goto while_break___98;
        }
        {
        while (1) {
          while_continue___99: /* CIL Label */ ;
          old_buffer___26 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((reg_errcode_t )15);
          }
          bufp->allocated <<= 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
          tmp___127 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)tmp___127;
          }
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((reg_errcode_t )12);
          }
          if ((unsigned long )old_buffer___26 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___26);
            begalt = bufp->buffer + (begalt - old_buffer___26);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___26);
            }
            if (laststart___0) {
              laststart___0 = bufp->buffer + (laststart___0 - old_buffer___26);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___26);
            }
          }
          goto while_break___99;
        }
        while_break___99: /* CIL Label */ ;
        }
      }
      while_break___98: /* CIL Label */ ;
      }
      tmp___128 = b;
      b ++;
      *tmp___128 = (unsigned char)1;
      goto while_break___97;
    }
    while_break___97: /* CIL Label */ ;
    }
  }
  {
  free((void *)compile_stack.stack);
  bufp->used = (unsigned long )(b - bufp->buffer);
  }
  return ((reg_errcode_t )0);
}
}
static void store_op1(re_opcode_t op , unsigned char *loc , int arg ) 
{ 


  {
  *loc = (unsigned char )op;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    *((loc + 1) + 0) = (unsigned char )(arg & 255);
    *((loc + 1) + 1) = (unsigned char )(arg >> 8);
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) 
{ 


  {
  *loc = (unsigned char )op;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    *((loc + 1) + 0) = (unsigned char )(arg1 & 255);
    *((loc + 1) + 1) = (unsigned char )(arg1 >> 8);
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    *((loc + 3) + 0) = (unsigned char )(arg2 & 255);
    *((loc + 3) + 1) = (unsigned char )(arg2 >> 8);
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
static void insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
  pfrom = end;
  pto = end + 3;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
      goto while_break;
    }
    pto --;
    pfrom --;
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
  store_op1(op, loc, arg);
  }
  return;
}
}
static void insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                       unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
  pfrom = end;
  pto = end + 5;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
      goto while_break;
    }
    pto --;
    pfrom --;
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
  store_op2(op, loc, arg1, arg2);
  }
  return;
}
}
static boolean at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) 
{ 
  char const   *prev ;
  boolean prev_prev_backslash ;
  int tmp ;
  int tmp___0 ;

  {
  prev = p - 2;
  if ((unsigned long )prev > (unsigned long )pattern) {
    if ((int const   )*(prev + -1) == 92) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  prev_prev_backslash = (boolean )tmp;
  if ((int const   )*prev == 40) {
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      tmp___0 = 1;
    } else { //Added block
    if (prev_prev_backslash) {
      tmp___0 = 1;
    } else {
      goto _L;
    }
    }
  } else { //Added block
  _L: 
  if ((int const   )*prev == 124) {
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      tmp___0 = 1;
    } else { //Added block
    if (prev_prev_backslash) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    }
  } else {
    tmp___0 = 0;
  }
  }
  return ((boolean )tmp___0);
}
}
static boolean at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) 
{ 
  char const   *next ;
  boolean next_backslash ;
  char const   *next_next ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  next = p;
  next_backslash = (boolean )((int const   )*next == 92);
  if ((unsigned long )(p + 1) < (unsigned long )pend) {
    tmp = p + 1;
  } else {
    tmp = (char const   *)0;
  }
  next_next = tmp;
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    tmp___1 = (int const   )*next == 41;
  } else {
    if (next_backslash) {
      if (next_next) {
        if ((int const   )*next_next == 41) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    tmp___1 = tmp___0;
  }
  if (tmp___1) {
    tmp___4 = 1;
  } else {
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      tmp___3 = (int const   )*next == 124;
    } else {
      if (next_backslash) {
        if (next_next) {
          if ((int const   )*next_next == 124) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      tmp___3 = tmp___2;
    }
    if (tmp___3) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
  }
  return ((boolean )tmp___4);
}
}
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) 
{ 
  int this_element ;

  {
  this_element = (int )(compile_stack.avail - 1U);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (this_element >= 0)) {
      goto while_break;
    }
    if ((compile_stack.stack + this_element)->regnum == regnum) {
      return ((boolean )1);
    }
    this_element --;
  }
  while_break: /* CIL Label */ ;
  }
  return ((boolean )0);
}
}
static reg_errcode_t compile_range(char const   **p_ptr , char const   *pend , char *translate ,
                                   reg_syntax_t syntax , unsigned char *b ) 
{ 
  unsigned int this_char ;
  char const   *p ;
  reg_errcode_t ret ;
  char range_start[2] ;
  char range_end[2] ;
  char ch[2] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  p = *p_ptr;
  if ((unsigned long )p == (unsigned long )pend) {
    return ((reg_errcode_t )11);
  }
  range_start[0] = (char )*(p + -2);
  range_start[1] = (char )'\000';
  range_end[0] = (char )*(p + 0);
  range_end[1] = (char )'\000';
  (*p_ptr) ++;
  if (syntax & ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    ret = (reg_errcode_t )11;
  } else {
    ret = (reg_errcode_t )0;
  }
  this_char = 0U;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (this_char <= 255U)) {
      goto while_break;
    }
    {
    ch[0] = (char )this_char;
    ch[1] = (char )'\000';
    tmp___1 = strcoll((char const   *)(range_start), (char const   *)(ch));
    }
    if (tmp___1 <= 0) {
      {
      tmp___2 = strcoll((char const   *)(ch), (char const   *)(range_end));
      }
      if (tmp___2 <= 0) {
        if (translate) {
          tmp = (unsigned int )*(translate + (int )((unsigned char )this_char));
        } else {
          tmp = this_char;
        }
        if (translate) {
          tmp___0 = (unsigned int )*(translate + (int )((unsigned char )this_char));
        } else {
          tmp___0 = this_char;
        }
        *(b + (int )((unsigned char )tmp) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )tmp) / 8) | (1 << (int )((unsigned char )tmp___0) % 8));
        ret = (reg_errcode_t )0;
      }
    }
    this_char ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (ret);
}
}
int re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  int j ;
  int k ;
  fail_stack_type fail_stack ;
  char *destination ;
  register char *fastmap ;
  unsigned char *pattern ;
  unsigned char *p ;
  register unsigned char *pend ;
  boolean path_can_be_null ;
  boolean succeed_n_p ;
  void *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  int fastmap_newline ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  fastmap = bufp->fastmap;
  pattern = bufp->buffer;
  p = pattern;
  pend = pattern + bufp->used;
  path_can_be_null = (boolean )1;
  succeed_n_p = (boolean )0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __builtin_alloca(5UL * sizeof(fail_stack_elt_t ));
    fail_stack.stack = (fail_stack_elt_t *)tmp;
    }
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
      return (-2);
    }
    fail_stack.size = 5U;
    fail_stack.avail = 0U;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  memset((void *)fastmap, '\000', (size_t )(1 << 8));
  bufp->fastmap_accurate = 1U;
  bufp->can_be_null = 0U;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if ((unsigned long )p == (unsigned long )pend) {
      goto _L;
    } else { //Added block
    if ((int )*p == 1) {
      _L: 
      if (! (fail_stack.avail == 0U)) {
        bufp->can_be_null |= (unsigned int )path_can_be_null;
        path_can_be_null = (boolean )1;
        (fail_stack.avail) --;
        p = (fail_stack.stack + fail_stack.avail)->pointer;
        goto while_continue___0;
      } else {
        goto while_break___0;
      }
    }
    }
    tmp___0 = p;
    p ++;
    {
    if ((unsigned int )((re_opcode_t )*tmp___0) == 8U) {
      goto case_8;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 2U) {
      goto case_2;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 4U) {
      goto case_4;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 5U) {
      goto case_5;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 24U) {
      goto case_24;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 25U) {
      goto case_25;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 3U) {
      goto case_3;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 0U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 9U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 10U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 11U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 12U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 28U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 29U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 26U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 27U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 20U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 22U) {
      goto case_22;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 17U) {
      goto case_22;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 18U) {
      goto case_22;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 13U) {
      goto case_22;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 14U) {
      goto case_22;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 19U) {
      goto case_22;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 15U) {
      goto handle_on_failure_jump;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 16U) {
      goto handle_on_failure_jump;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 21U) {
      goto case_21;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 23U) {
      goto case_23;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 6U) {
      goto case_6;
    }
    if ((unsigned int )((re_opcode_t )*tmp___0) == 7U) {
      goto case_6;
    }
    goto switch_default;
    case_8: /* CIL Label */ 
    bufp->can_be_null = 1U;
    goto done;
    case_2: /* CIL Label */ 
    *(fastmap + (int )*(p + 1)) = (char)1;
    goto switch_break;
    case_4: /* CIL Label */ 
    tmp___1 = p;
    p ++;
    j = (int )*tmp___1 * 8 - 1;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (j >= 0)) {
        goto while_break___1;
      }
      if ((int )*(p + j / 8) & (1 << j % 8)) {
        *(fastmap + j) = (char)1;
      }
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
    goto switch_break;
    case_5: /* CIL Label */ 
    j = (int )*p * 8;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (j < 1 << 8)) {
        goto while_break___2;
      }
      *(fastmap + j) = (char)1;
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    tmp___2 = p;
    p ++;
    j = (int )*tmp___2 * 8 - 1;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! (j >= 0)) {
        goto while_break___3;
      }
      if (! ((int )*(p + j / 8) & (1 << j % 8))) {
        *(fastmap + j) = (char)1;
      }
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
    goto switch_break;
    case_24: /* CIL Label */ 
    j = 0;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! (j < 1 << 8)) {
        goto while_break___4;
      }
      if ((int )re_syntax_table[j & 255] == 1) {
        *(fastmap + j) = (char)1;
      }
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    goto switch_break;
    case_25: /* CIL Label */ 
    j = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! (j < 1 << 8)) {
        goto while_break___5;
      }
      if ((int )re_syntax_table[j & 255] != 1) {
        *(fastmap + j) = (char)1;
      }
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    goto switch_break;
    case_3: /* CIL Label */ 
    fastmap_newline = (int )*(fastmap + 10);
    j = 0;
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (! (j < 1 << 8)) {
        goto while_break___6;
      }
      *(fastmap + j) = (char)1;
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      *(fastmap + 10) = (char )fastmap_newline;
    } else { //Added block
    if (bufp->can_be_null) {
      goto done;
    }
    }
    goto switch_break;
    case_0: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_20: /* CIL Label */ 
    goto while_continue___0;
    case_22: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_19: /* CIL Label */ 
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        j = (int )*p & 255;
        j += (int )((signed char )*(p + 1)) << 8;
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    p += j;
    if (j > 0) {
      goto while_continue___0;
    }
    if ((unsigned int )((re_opcode_t )*p) != 15U) {
      if ((unsigned int )((re_opcode_t )*p) != 21U) {
        goto while_continue___0;
      }
    }
    p ++;
    {
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
      while (1) {
        while_continue___10: /* CIL Label */ ;
        j = (int )*p & 255;
        j += (int )((signed char )*(p + 1)) << 8;
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    p += j;
    if (! (fail_stack.avail == 0U)) {
      if ((unsigned long )(fail_stack.stack + (fail_stack.avail - 1U))->pointer == (unsigned long )p) {
        (fail_stack.avail) --;
      }
    }
    goto while_continue___0;
    handle_on_failure_jump: 
    case_15: /* CIL Label */ 
    case_16: /* CIL Label */ 
    {
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
      while (1) {
        while_continue___12: /* CIL Label */ ;
        j = (int )*p & 255;
        j += (int )((signed char )*(p + 1)) << 8;
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    if ((unsigned long )(p + j) < (unsigned long )pend) {
      if (fail_stack.avail == fail_stack.size) {
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
          tmp___12 = 0;
        } else {
          {
          tmp___9 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination = (char *)tmp___9;
          tmp___10 = memcpy((void * __restrict  )destination, (void const   * __restrict  )fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)tmp___10;
          }
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            tmp___11 = 0;
          } else {
            fail_stack.size <<= 1;
            tmp___11 = 1;
          }
          tmp___12 = tmp___11;
        }
        if (tmp___12) {
          tmp___7 = fail_stack.avail;
          (fail_stack.avail) ++;
          (fail_stack.stack + tmp___7)->pointer = p + j;
          tmp___8 = 1;
        } else {
          tmp___8 = 0;
        }
      } else {
        tmp___7 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___7)->pointer = p + j;
        tmp___8 = 1;
      }
      if (! tmp___8) {
        return (-2);
      }
    } else {
      bufp->can_be_null = 1U;
    }
    if (succeed_n_p) {
      {
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
        while (1) {
          while_continue___14: /* CIL Label */ ;
          k = (int )*p & 255;
          k += (int )((signed char )*(p + 1)) << 8;
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
        p += 2;
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      succeed_n_p = (boolean )0;
    }
    goto while_continue___0;
    case_21: /* CIL Label */ 
    p += 2;
    {
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
      while (1) {
        while_continue___16: /* CIL Label */ ;
        k = (int )*p & 255;
        k += (int )((signed char )*(p + 1)) << 8;
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    if (k == 0) {
      p -= 4;
      succeed_n_p = (boolean )1;
      goto handle_on_failure_jump;
    }
    goto while_continue___0;
    case_23: /* CIL Label */ 
    p += 4;
    goto while_continue___0;
    case_6: /* CIL Label */ 
    case_7: /* CIL Label */ 
    p += 2;
    goto while_continue___0;
    switch_default: /* CIL Label */ 
    {
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
    path_can_be_null = (boolean )0;
    p = pend;
  }
  while_break___0: /* CIL Label */ ;
  }
  bufp->can_be_null |= (unsigned int )path_can_be_null;
  done: ;
  return (0);
}
}
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs___0 ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp ;

  {
  if (num_regs) {
    bufp->regs_allocated = 1U;
    regs___0->num_regs = num_regs;
    regs___0->start = starts;
    regs___0->end = ends;
  } else {
    bufp->regs_allocated = 0U;
    regs___0->num_regs = 0U;
    tmp = (regoff_t *)0;
    regs___0->end = tmp;
    regs___0->start = tmp;
  }
  return;
}
}
int re_search(struct re_pattern_buffer *bufp , char const   *string , int size , int startpos ,
              int range , struct re_registers *regs___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = re_search_2(bufp, (char const   *)((void *)0), 0, string, size, startpos,
                    range, regs___0, size);
  }
  return (tmp);
}
}
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs___0 ,
                int stop ) 
{ 
  int val ;
  register char *fastmap ;
  register char *translate ;
  int total_size ;
  int endpos ;
  int tmp ;
  register char const   *d ;
  register int lim ;
  int irange ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  register char c ;
  int tmp___3 ;
  int tmp___4 ;

  {
  fastmap = bufp->fastmap;
  translate = bufp->translate;
  total_size = size1 + size2;
  endpos = startpos + range;
  if (startpos < 0) {
    return (-1);
  } else { //Added block
  if (startpos > total_size) {
    return (-1);
  }
  }
  if (endpos < 0) {
    range = 0 - startpos;
  } else { //Added block
  if (endpos > total_size) {
    range = total_size - startpos;
  }
  }
  if (bufp->used > 0UL) {
    if (range > 0) {
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 11U) {
        goto _L;
      } else { //Added block
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 9U) {
        if (! bufp->newline_anchor) {
          _L: 
          if (startpos > 0) {
            return (-1);
          } else {
            range = 1;
          }
        }
      }
      }
    }
  }
  if (fastmap) {
    if (! bufp->fastmap_accurate) {
      {
      tmp = re_compile_fastmap(bufp);
      }
      if (tmp == -2) {
        return (-2);
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (fastmap) {
      if (startpos < total_size) {
        if (! bufp->can_be_null) {
          if (range > 0) {
            lim = 0;
            irange = range;
            if (startpos < size1) {
              if (startpos + range >= size1) {
                lim = range - (size1 - startpos);
              }
            }
            if (startpos >= size1) {
              tmp___0 = string2 - size1;
            } else {
              tmp___0 = string1;
            }
            d = tmp___0 + startpos;
            if (translate) {
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (range > lim) {
                  tmp___1 = d;
                  d ++;
                  if (*(fastmap + (int )((unsigned char )*(translate + (int )((unsigned char )*tmp___1))))) {
                    goto while_break___0;
                  }
                } else {
                  goto while_break___0;
                }
                range --;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
              {
              while (1) {
                while_continue___1: /* CIL Label */ ;
                if (range > lim) {
                  tmp___2 = d;
                  d ++;
                  if (*(fastmap + (int )((unsigned char )*tmp___2))) {
                    goto while_break___1;
                  }
                } else {
                  goto while_break___1;
                }
                range --;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
            startpos += irange - range;
          } else {
            if (size1 == 0) {
              tmp___3 = (int )((int const   )*(string2 + (startpos - size1)));
            } else { //Added block
            if (startpos >= size1) {
              tmp___3 = (int )((int const   )*(string2 + (startpos - size1)));
            } else {
              tmp___3 = (int )((int const   )*(string1 + startpos));
            }
            }
            c = (char )tmp___3;
            if (translate) {
              tmp___4 = (int )*(translate + (int )((unsigned char )c));
            } else {
              tmp___4 = (int )c;
            }
            if (! *(fastmap + (int )((unsigned char )tmp___4))) {
              goto advance;
            }
          }
        }
      }
    }
    if (range >= 0) {
      if (startpos == total_size) {
        if (fastmap) {
          if (! bufp->can_be_null) {
            return (-1);
          }
        }
      }
    }
    {
    val = re_match_2_internal(bufp, string1, size1, string2, size2, startpos, regs___0,
                              stop);
    }
    if (val >= 0) {
      return (startpos);
    }
    if (val == -2) {
      return (-2);
    }
    advance: 
    if (! range) {
      goto while_break;
    } else { //Added block
    if (range > 0) {
      range --;
      startpos ++;
    } else {
      range ++;
      startpos --;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
int re_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
             struct re_registers *regs___0 ) 
{ 
  int result ;
  int tmp ;

  {
  {
  tmp = re_match_2_internal(bufp, (char const   *)((void *)0), 0, string, size, pos,
                            regs___0, size);
  result = tmp;
  }
  return (result);
}
}
static boolean group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                         register_info_type *reg_info ) ;
static boolean alt_match_null_string_p(unsigned char *p , unsigned char *end , register_info_type *reg_info ) ;
static boolean common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                             register_info_type *reg_info ) ;
static int bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) ;
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
               char const   *string2 , int size2 , int pos , struct re_registers *regs___0 ,
               int stop ) 
{ 
  int result ;
  int tmp ;

  {
  {
  tmp = re_match_2_internal(bufp, string1, size1, string2, size2, pos, regs___0, stop);
  result = tmp;
  }
  return (result);
}
}
static int re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                               int size1 , char const   *string2 , int size2 , int pos ,
                               struct re_registers *regs___0 , int stop ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  char const   *end1 ;
  char const   *end2 ;
  char const   *end_match_1 ;
  char const   *end_match_2 ;
  char const   *d ;
  char const   *dend ;
  unsigned char *p ;
  register unsigned char *pend ;
  unsigned char *just_past_start_mem ;
  char *translate ;
  fail_stack_type fail_stack ;
  size_t num_regs ;
  active_reg_t lowest_active_reg ;
  active_reg_t highest_active_reg ;
  char const   **regstart ;
  char const   **regend ;
  char const   **old_regstart ;
  char const   **old_regend ;
  register_info_type *reg_info ;
  unsigned int best_regs_set ;
  char const   **best_regstart ;
  char const   **best_regend ;
  char const   *match_end ;
  int set_regs_matched_done ;
  char const   **reg_dummy ;
  register_info_type *reg_info_dummy ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  boolean same_str_p ;
  int tmp___12 ;
  boolean best_match_p ;
  char *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  regoff_t tmp___17 ;
  regoff_t tmp___18 ;
  regoff_t tmp___19 ;
  size_t tmp___20 ;
  regoff_t tmp___21 ;
  char const   *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  char const   *tmp___25 ;
  unsigned char *tmp___26 ;
  char const   *tmp___27 ;
  unsigned char *tmp___28 ;
  active_reg_t r ;
  unsigned int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  active_reg_t r___0 ;
  unsigned int tmp___32 ;
  register unsigned char c ;
  boolean not ;
  active_reg_t r___1 ;
  unsigned int tmp___33 ;
  boolean tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  unsigned char r___2 ;
  boolean is_a_jump_n ;
  unsigned char *tmp___37 ;
  unsigned int r___3 ;
  char *destination ;
  active_reg_t this_reg ;
  void *tmp___38 ;
  void *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  register char const   *d2 ;
  register char const   *dend2 ;
  int regno ;
  unsigned char *tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  active_reg_t r___4 ;
  unsigned int tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  char *destination___0 ;
  active_reg_t this_reg___0 ;
  void *tmp___61 ;
  void *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  unsigned int tmp___65 ;
  unsigned int tmp___66 ;
  unsigned int tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  unsigned int tmp___70 ;
  unsigned int tmp___71 ;
  char *destination___1 ;
  active_reg_t this_reg___1 ;
  void *tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  unsigned int tmp___76 ;
  unsigned int tmp___77 ;
  unsigned int tmp___78 ;
  unsigned int tmp___79 ;
  unsigned int tmp___80 ;
  unsigned int tmp___81 ;
  unsigned int tmp___82 ;
  register unsigned char *p2 ;
  register unsigned char c___0 ;
  int tmp___83 ;
  int not___0 ;
  int idx ;
  int idx___0 ;
  active_reg_t dummy_low_reg ;
  active_reg_t dummy_high_reg ;
  unsigned char *pdummy ;
  char const   *sdummy ;
  active_reg_t this_reg___2 ;
  unsigned char const   *string_temp ;
  char *destination___2 ;
  active_reg_t this_reg___3 ;
  void *tmp___84 ;
  void *tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  unsigned int tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  unsigned int tmp___94 ;
  char *destination___3 ;
  active_reg_t this_reg___4 ;
  void *tmp___95 ;
  void *tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  unsigned int tmp___99 ;
  unsigned int tmp___100 ;
  unsigned int tmp___101 ;
  unsigned int tmp___102 ;
  unsigned int tmp___103 ;
  unsigned int tmp___104 ;
  unsigned int tmp___105 ;
  boolean prevchar ;
  boolean thischar ;
  char const   *tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  boolean prevchar___0 ;
  boolean thischar___0 ;
  char const   *tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  char const   *tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  char const   *tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  active_reg_t r___5 ;
  unsigned int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  active_reg_t r___6 ;
  unsigned int tmp___131 ;
  active_reg_t this_reg___5 ;
  unsigned char const   *string_temp___0 ;
  boolean is_a_jump_n___0 ;

  {
  p = bufp->buffer;
  pend = p + bufp->used;
  just_past_start_mem = (unsigned char *)0;
  translate = bufp->translate;
  num_regs = bufp->re_nsub + 1UL;
  lowest_active_reg = (active_reg_t )((1 << 8) + 1);
  highest_active_reg = (active_reg_t )(1 << 8);
  best_regs_set = 0U;
  match_end = (char const   *)((void *)0);
  set_regs_matched_done = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __builtin_alloca(5UL * sizeof(fail_stack_elt_t ));
    fail_stack.stack = (fail_stack_elt_t *)tmp;
    }
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
      return (-2);
    }
    fail_stack.size = 5U;
    fail_stack.avail = 0U;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (bufp->re_nsub) {
    {
    tmp___0 = __builtin_alloca(num_regs * sizeof(char const   *));
    regstart = (char const   **)tmp___0;
    tmp___1 = __builtin_alloca(num_regs * sizeof(char const   *));
    regend = (char const   **)tmp___1;
    tmp___2 = __builtin_alloca(num_regs * sizeof(char const   *));
    old_regstart = (char const   **)tmp___2;
    tmp___3 = __builtin_alloca(num_regs * sizeof(char const   *));
    old_regend = (char const   **)tmp___3;
    tmp___4 = __builtin_alloca(num_regs * sizeof(char const   *));
    best_regstart = (char const   **)tmp___4;
    tmp___5 = __builtin_alloca(num_regs * sizeof(char const   *));
    best_regend = (char const   **)tmp___5;
    tmp___6 = __builtin_alloca(num_regs * sizeof(register_info_type ));
    reg_info = (register_info_type *)tmp___6;
    tmp___7 = __builtin_alloca(num_regs * sizeof(char const   *));
    reg_dummy = (char const   **)tmp___7;
    tmp___8 = __builtin_alloca(num_regs * sizeof(register_info_type ));
    reg_info_dummy = (register_info_type *)tmp___8;
    }
    if (regstart) {
      if (regend) {
        if (old_regstart) {
          if (old_regend) {
            if (reg_info) {
              if (best_regstart) {
                if (best_regend) {
                  if (reg_dummy) {
                    if (! reg_info_dummy) {
                      goto _L___6;
                    }
                  } else {
                    goto _L___6;
                  }
                } else {
                  goto _L___6;
                }
              } else {
                goto _L___6;
              }
            } else {
              goto _L___6;
            }
          } else {
            goto _L___6;
          }
        } else {
          goto _L___6;
        }
      } else {
        goto _L___6;
      }
    } else {
      _L___6: 
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        regstart = (char const   **)((void *)0);
        regend = (char const   **)((void *)0);
        old_regstart = (char const   **)((void *)0);
        old_regend = (char const   **)((void *)0);
        best_regstart = (char const   **)((void *)0);
        best_regend = (char const   **)((void *)0);
        reg_info = (register_info_type *)((void *)0);
        reg_dummy = (char const   **)((void *)0);
        reg_info_dummy = (register_info_type *)((void *)0);
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      return (-2);
    }
  } else {
    reg_dummy = (char const   **)((void *)0);
    best_regend = reg_dummy;
    best_regstart = best_regend;
    old_regend = best_regstart;
    old_regstart = old_regend;
    regend = old_regstart;
    regstart = regend;
    reg_info_dummy = (register_info_type *)((void *)0);
    reg_info = reg_info_dummy;
  }
  if (pos < 0) {
    goto _L___7;
  } else { //Added block
  if (pos > size1 + size2) {
    _L___7: 
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      regstart = (char const   **)((void *)0);
      regend = (char const   **)((void *)0);
      old_regstart = (char const   **)((void *)0);
      old_regend = (char const   **)((void *)0);
      best_regstart = (char const   **)((void *)0);
      best_regend = (char const   **)((void *)0);
      reg_info = (register_info_type *)((void *)0);
      reg_dummy = (char const   **)((void *)0);
      reg_info_dummy = (register_info_type *)((void *)0);
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    return (-1);
  }
  }
  mcnt = 1;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
      goto while_break___2;
    }
    tmp___11 = (char const   *)(& reg_unset_dummy);
    *(old_regend + mcnt) = tmp___11;
    tmp___10 = tmp___11;
    *(old_regstart + mcnt) = tmp___10;
    tmp___9 = tmp___10;
    *(regend + mcnt) = tmp___9;
    *(regstart + mcnt) = tmp___9;
    (reg_info + mcnt)->bits.match_null_string_p = 3U;
    (reg_info + mcnt)->bits.is_active = 0U;
    (reg_info + mcnt)->bits.matched_something = 0U;
    (reg_info + mcnt)->bits.ever_matched_something = 0U;
    mcnt ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  if (size2 == 0) {
    if ((unsigned long )string1 != (unsigned long )((void *)0)) {
      string2 = string1;
      size2 = size1;
      string1 = (char const   *)0;
      size1 = 0;
    }
  }
  end1 = string1 + size1;
  end2 = string2 + size2;
  if (stop <= size1) {
    end_match_1 = string1 + stop;
    end_match_2 = string2;
  } else {
    end_match_1 = end1;
    end_match_2 = (string2 + stop) - size1;
  }
  if (size1 > 0) {
    if (pos <= size1) {
      d = string1 + pos;
      dend = end_match_1;
    } else {
      d = (string2 + pos) - size1;
      dend = end_match_2;
    }
  } else {
    d = (string2 + pos) - size1;
    dend = end_match_2;
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if ((unsigned long )p == (unsigned long )pend) {
      if ((unsigned long )d != (unsigned long )end_match_2) {
        if (size1) {
          if ((unsigned long )string1 <= (unsigned long )match_end) {
            if ((unsigned long )match_end <= (unsigned long )(string1 + size1)) {
              tmp___12 = 1;
            } else {
              tmp___12 = 0;
            }
          } else {
            tmp___12 = 0;
          }
        } else {
          tmp___12 = 0;
        }
        same_str_p = (boolean )(tmp___12 == ((unsigned long )dend == (unsigned long )end_match_1));
        if (same_str_p) {
          best_match_p = (boolean )((unsigned long )d > (unsigned long )match_end);
        } else {
          best_match_p = (boolean )(! ((unsigned long )dend == (unsigned long )end_match_1));
        }
        if (! (fail_stack.avail == 0U)) {
          if (! best_regs_set) {
            goto _L___8;
          } else { //Added block
          if (best_match_p) {
            _L___8: 
            best_regs_set = 1U;
            match_end = d;
            mcnt = 1;
            {
            while (1) {
              while_continue___4: /* CIL Label */ ;
              if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
                goto while_break___4;
              }
              *(best_regstart + mcnt) = *(regstart + mcnt);
              *(best_regend + mcnt) = *(regend + mcnt);
              mcnt ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          }
          goto fail;
        } else { //Added block
        if (best_regs_set) {
          if (! best_match_p) {
            restore_best_regs: 
            d = match_end;
            if ((unsigned long )d >= (unsigned long )string1) {
              if ((unsigned long )d <= (unsigned long )end1) {
                dend = end_match_1;
              } else {
                dend = end_match_2;
              }
            } else {
              dend = end_match_2;
            }
            mcnt = 1;
            {
            while (1) {
              while_continue___5: /* CIL Label */ ;
              if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
                goto while_break___5;
              }
              *(regstart + mcnt) = *(best_regstart + mcnt);
              *(regend + mcnt) = *(best_regend + mcnt);
              mcnt ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
        }
      }
      succeed_label: ;
      if (regs___0) {
        if (! bufp->no_sub) {
          if (bufp->regs_allocated == 0U) {
            if (30UL > num_regs + 1UL) {
              regs___0->num_regs = 30U;
            } else {
              regs___0->num_regs = (unsigned int )(num_regs + 1UL);
            }
            {
            tmp___13 = xmalloc((unsigned long )regs___0->num_regs * sizeof(regoff_t ));
            regs___0->start = (regoff_t *)tmp___13;
            tmp___14 = xmalloc((unsigned long )regs___0->num_regs * sizeof(regoff_t ));
            regs___0->end = (regoff_t *)tmp___14;
            }
            if ((unsigned long )regs___0->start == (unsigned long )((void *)0)) {
              goto _L___9;
            } else { //Added block
            if ((unsigned long )regs___0->end == (unsigned long )((void *)0)) {
              _L___9: 
              {
              while (1) {
                while_continue___6: /* CIL Label */ ;
                regstart = (char const   **)((void *)0);
                regend = (char const   **)((void *)0);
                old_regstart = (char const   **)((void *)0);
                old_regend = (char const   **)((void *)0);
                best_regstart = (char const   **)((void *)0);
                best_regend = (char const   **)((void *)0);
                reg_info = (register_info_type *)((void *)0);
                reg_dummy = (char const   **)((void *)0);
                reg_info_dummy = (register_info_type *)((void *)0);
                goto while_break___6;
              }
              while_break___6: /* CIL Label */ ;
              }
              return (-2);
            }
            }
            bufp->regs_allocated = 1U;
          } else { //Added block
          if (bufp->regs_allocated == 1U) {
            if ((size_t )regs___0->num_regs < num_regs + 1UL) {
              {
              regs___0->num_regs = (unsigned int )(num_regs + 1UL);
              tmp___15 = realloc((void *)regs___0->start, (unsigned long )regs___0->num_regs * sizeof(regoff_t ));
              regs___0->start = (regoff_t *)tmp___15;
              tmp___16 = realloc((void *)regs___0->end, (unsigned long )regs___0->num_regs * sizeof(regoff_t ));
              regs___0->end = (regoff_t *)tmp___16;
              }
              if ((unsigned long )regs___0->start == (unsigned long )((void *)0)) {
                goto _L___10;
              } else { //Added block
              if ((unsigned long )regs___0->end == (unsigned long )((void *)0)) {
                _L___10: 
                {
                while (1) {
                  while_continue___7: /* CIL Label */ ;
                  regstart = (char const   **)((void *)0);
                  regend = (char const   **)((void *)0);
                  old_regstart = (char const   **)((void *)0);
                  old_regend = (char const   **)((void *)0);
                  best_regstart = (char const   **)((void *)0);
                  best_regend = (char const   **)((void *)0);
                  reg_info = (register_info_type *)((void *)0);
                  reg_dummy = (char const   **)((void *)0);
                  reg_info_dummy = (register_info_type *)((void *)0);
                  goto while_break___7;
                }
                while_break___7: /* CIL Label */ ;
                }
                return (-2);
              }
              }
            }
          }
          }
          if (regs___0->num_regs > 0U) {
            *(regs___0->start + 0) = pos;
            if ((unsigned long )dend == (unsigned long )end_match_1) {
              *(regs___0->end + 0) = (regoff_t )(d - string1);
            } else {
              *(regs___0->end + 0) = (regoff_t )((d - string2) + (long )size1);
            }
          }
          mcnt = 1;
          {
          while (1) {
            while_continue___8: /* CIL Label */ ;
            if (num_regs < (size_t )regs___0->num_regs) {
              tmp___20 = num_regs;
            } else {
              tmp___20 = (size_t )regs___0->num_regs;
            }
            if (! ((size_t )((unsigned int )mcnt) < tmp___20)) {
              goto while_break___8;
            }
            if ((unsigned long )*(regstart + mcnt) == (unsigned long )(& reg_unset_dummy)) {
              tmp___17 = -1;
              *(regs___0->end + mcnt) = tmp___17;
              *(regs___0->start + mcnt) = tmp___17;
            } else { //Added block
            if ((unsigned long )*(regend + mcnt) == (unsigned long )(& reg_unset_dummy)) {
              tmp___17 = -1;
              *(regs___0->end + mcnt) = tmp___17;
              *(regs___0->start + mcnt) = tmp___17;
            } else {
              if (size1) {
                if ((unsigned long )string1 <= (unsigned long )*(regstart + mcnt)) {
                  if ((unsigned long )*(regstart + mcnt) <= (unsigned long )(string1 + size1)) {
                    tmp___18 = (regoff_t )(*(regstart + mcnt) - string1);
                  } else {
                    tmp___18 = (regoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                  }
                } else {
                  tmp___18 = (regoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                }
              } else {
                tmp___18 = (regoff_t )((*(regstart + mcnt) - string2) + (long )size1);
              }
              *(regs___0->start + mcnt) = tmp___18;
              if (size1) {
                if ((unsigned long )string1 <= (unsigned long )*(regend + mcnt)) {
                  if ((unsigned long )*(regend + mcnt) <= (unsigned long )(string1 + size1)) {
                    tmp___19 = (regoff_t )(*(regend + mcnt) - string1);
                  } else {
                    tmp___19 = (regoff_t )((*(regend + mcnt) - string2) + (long )size1);
                  }
                } else {
                  tmp___19 = (regoff_t )((*(regend + mcnt) - string2) + (long )size1);
                }
              } else {
                tmp___19 = (regoff_t )((*(regend + mcnt) - string2) + (long )size1);
              }
              *(regs___0->end + mcnt) = tmp___19;
            }
            }
            mcnt ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          mcnt = (int )num_regs;
          {
          while (1) {
            while_continue___9: /* CIL Label */ ;
            if (! ((unsigned int )mcnt < regs___0->num_regs)) {
              goto while_break___9;
            }
            tmp___21 = -1;
            *(regs___0->end + mcnt) = tmp___21;
            *(regs___0->start + mcnt) = tmp___21;
            mcnt ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
      if ((unsigned long )dend == (unsigned long )end_match_1) {
        tmp___22 = string1;
      } else {
        tmp___22 = string2 - size1;
      }
      mcnt = (int )((d - pos) - tmp___22);
      {
      while (1) {
        while_continue___10: /* CIL Label */ ;
        regstart = (char const   **)((void *)0);
        regend = (char const   **)((void *)0);
        old_regstart = (char const   **)((void *)0);
        old_regend = (char const   **)((void *)0);
        best_regstart = (char const   **)((void *)0);
        best_regend = (char const   **)((void *)0);
        reg_info = (register_info_type *)((void *)0);
        reg_dummy = (char const   **)((void *)0);
        reg_info_dummy = (register_info_type *)((void *)0);
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      return (mcnt);
    }
    tmp___23 = p;
    p ++;
    {
    if ((unsigned int )((re_opcode_t )*tmp___23) == 0U) {
      goto case_0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 1U) {
      goto case_1;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 2U) {
      goto case_2;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 3U) {
      goto case_3;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 4U) {
      goto case_4;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 5U) {
      goto case_4;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 6U) {
      goto case_6;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 7U) {
      goto case_7;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 8U) {
      goto case_8;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 9U) {
      goto case_9;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 10U) {
      goto case_10;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 11U) {
      goto case_11;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 12U) {
      goto case_12;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 16U) {
      goto case_16;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 15U) {
      goto on_failure;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 18U) {
      goto case_18___0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 17U) {
      goto case_17___0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 13U) {
      goto case_13___0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 14U) {
      goto case_14;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 19U) {
      goto case_19___0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 20U) {
      goto case_20;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 21U) {
      goto case_21;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 22U) {
      goto case_22___0;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 23U) {
      goto case_23;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 28U) {
      goto case_28;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 29U) {
      goto case_29;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 26U) {
      goto case_26;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 27U) {
      goto case_27;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 24U) {
      goto case_24;
    }
    if ((unsigned int )((re_opcode_t )*tmp___23) == 25U) {
      goto case_25;
    }
    goto switch_default___0;
    case_0: /* CIL Label */ ;
    goto switch_break;
    case_1: /* CIL Label */ ;
    goto succeed_label;
    case_2: /* CIL Label */ 
    tmp___24 = p;
    p ++;
    mcnt = (int )*tmp___24;
    if (translate) {
      {
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
        while (1) {
          while_continue___12: /* CIL Label */ ;
          if (! ((unsigned long )d == (unsigned long )dend)) {
            goto while_break___12;
          }
          if ((unsigned long )dend == (unsigned long )end_match_2) {
            goto fail;
          }
          d = string2;
          dend = end_match_2;
        }
        while_break___12: /* CIL Label */ ;
        }
        tmp___25 = d;
        d ++;
        tmp___26 = p;
        p ++;
        if ((int )((unsigned char )*(translate + (int )((unsigned char )*tmp___25))) != (int )*tmp___26) {
          goto fail;
        }
        mcnt --;
        if (! mcnt) {
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
        while (1) {
          while_continue___14: /* CIL Label */ ;
          if (! ((unsigned long )d == (unsigned long )dend)) {
            goto while_break___14;
          }
          if ((unsigned long )dend == (unsigned long )end_match_2) {
            goto fail;
          }
          d = string2;
          dend = end_match_2;
        }
        while_break___14: /* CIL Label */ ;
        }
        tmp___27 = d;
        d ++;
        tmp___28 = p;
        p ++;
        if ((int const   )*tmp___27 != (int const   )((char )*tmp___28)) {
          goto fail;
        }
        mcnt --;
        if (! mcnt) {
          goto while_break___13;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    {
    while (1) {
      while_continue___15: /* CIL Label */ ;
      if (! set_regs_matched_done) {
        set_regs_matched_done = 1;
        r = lowest_active_reg;
        {
        while (1) {
          while_continue___16: /* CIL Label */ ;
          if (! (r <= highest_active_reg)) {
            goto while_break___16;
          }
          tmp___29 = 1U;
          (reg_info + r)->bits.ever_matched_something = tmp___29;
          (reg_info + r)->bits.matched_something = tmp___29;
          r ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    goto switch_break;
    case_3: /* CIL Label */ ;
    {
    while (1) {
      while_continue___17: /* CIL Label */ ;
      if (! ((unsigned long )d == (unsigned long )dend)) {
        goto while_break___17;
      }
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    while_break___17: /* CIL Label */ ;
    }
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      if (translate) {
        tmp___30 = (int )*(translate + (int )((unsigned char )*d));
      } else {
        tmp___30 = (int )*d;
      }
      if (tmp___30 == 10) {
        goto fail;
      } else {
        goto _L___11;
      }
    } else { //Added block
    _L___11: 
    if (bufp->syntax & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if (translate) {
        tmp___31 = (int )*(translate + (int )((unsigned char )*d));
      } else {
        tmp___31 = (int )*d;
      }
      if (tmp___31 == 0) {
        goto fail;
      }
    }
    }
    {
    while (1) {
      while_continue___18: /* CIL Label */ ;
      if (! set_regs_matched_done) {
        set_regs_matched_done = 1;
        r___0 = lowest_active_reg;
        {
        while (1) {
          while_continue___19: /* CIL Label */ ;
          if (! (r___0 <= highest_active_reg)) {
            goto while_break___19;
          }
          tmp___32 = 1U;
          (reg_info + r___0)->bits.ever_matched_something = tmp___32;
          (reg_info + r___0)->bits.matched_something = tmp___32;
          r___0 ++;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    d ++;
    goto switch_break;
    case_4: /* CIL Label */ 
    case_5: /* CIL Label */ 
    not = (boolean )((unsigned int )((re_opcode_t )*(p - 1)) == 5U);
    {
    while (1) {
      while_continue___20: /* CIL Label */ ;
      if (! ((unsigned long )d == (unsigned long )dend)) {
        goto while_break___20;
      }
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    while_break___20: /* CIL Label */ ;
    }
    if (translate) {
      c = (unsigned char )*(translate + (int )((unsigned char )*d));
    } else {
      c = (unsigned char )*d;
    }
    if ((unsigned int )c < (unsigned int )((int )*p * 8)) {
      if ((int )*(p + (1 + (int )c / 8)) & (1 << (int )c % 8)) {
        not = (boolean )(! not);
      }
    }
    p += 1 + (int )*p;
    if (! not) {
      goto fail;
    }
    {
    while (1) {
      while_continue___21: /* CIL Label */ ;
      if (! set_regs_matched_done) {
        set_regs_matched_done = 1;
        r___1 = lowest_active_reg;
        {
        while (1) {
          while_continue___22: /* CIL Label */ ;
          if (! (r___1 <= highest_active_reg)) {
            goto while_break___22;
          }
          tmp___33 = 1U;
          (reg_info + r___1)->bits.ever_matched_something = tmp___33;
          (reg_info + r___1)->bits.matched_something = tmp___33;
          r___1 ++;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    d ++;
    goto switch_break;
    case_6: /* CIL Label */ 
    p1 = p;
    if ((reg_info + (int )*p)->bits.match_null_string_p == 3U) {
      {
      tmp___34 = group_match_null_string_p(& p1, pend, reg_info);
      (reg_info + (int )*p)->bits.match_null_string_p = (unsigned int )tmp___34;
      }
    }
    if ((reg_info + (int )*p)->bits.match_null_string_p) {
      if ((unsigned long )*(regstart + (int )*p) == (unsigned long )(& reg_unset_dummy)) {
        tmp___35 = d;
      } else {
        tmp___35 = *(regstart + (int )*p);
      }
      *(old_regstart + (int )*p) = tmp___35;
    } else {
      *(old_regstart + (int )*p) = *(regstart + (int )*p);
    }
    *(regstart + (int )*p) = d;
    (reg_info + (int )*p)->bits.is_active = 1U;
    (reg_info + (int )*p)->bits.matched_something = 0U;
    set_regs_matched_done = 0;
    highest_active_reg = (active_reg_t )*p;
    if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
      lowest_active_reg = (active_reg_t )*p;
    }
    p += 2;
    just_past_start_mem = p;
    goto switch_break;
    case_7: /* CIL Label */ ;
    if ((reg_info + (int )*p)->bits.match_null_string_p) {
      if ((unsigned long )*(regend + (int )*p) == (unsigned long )(& reg_unset_dummy)) {
        tmp___36 = d;
      } else {
        tmp___36 = *(regend + (int )*p);
      }
      *(old_regend + (int )*p) = tmp___36;
    } else {
      *(old_regend + (int )*p) = *(regend + (int )*p);
    }
    *(regend + (int )*p) = d;
    (reg_info + (int )*p)->bits.is_active = 0U;
    set_regs_matched_done = 0;
    if (lowest_active_reg == highest_active_reg) {
      lowest_active_reg = (active_reg_t )((1 << 8) + 1);
      highest_active_reg = (active_reg_t )(1 << 8);
    } else {
      r___2 = (unsigned char )((int )*p - 1);
      {
      while (1) {
        while_continue___23: /* CIL Label */ ;
        if ((int )r___2 > 0) {
          if (! (! (reg_info + (int )r___2)->bits.is_active)) {
            goto while_break___23;
          }
        } else {
          goto while_break___23;
        }
        r___2 = (unsigned char )((int )r___2 - 1);
      }
      while_break___23: /* CIL Label */ ;
      }
      if ((int )r___2 == 0) {
        lowest_active_reg = (active_reg_t )((1 << 8) + 1);
        highest_active_reg = (active_reg_t )(1 << 8);
      } else {
        highest_active_reg = (active_reg_t )r___2;
      }
    }
    if (! (reg_info + (int )*p)->bits.matched_something) {
      goto _L___12;
    } else { //Added block
    if ((unsigned long )just_past_start_mem == (unsigned long )(p - 1)) {
      _L___12: 
      if ((unsigned long )(p + 2) < (unsigned long )pend) {
        is_a_jump_n = (boolean )0;
        p1 = p + 2;
        mcnt = 0;
        tmp___37 = p1;
        p1 ++;
        {
        if ((unsigned int )((re_opcode_t )*tmp___37) == 22U) {
          goto case_22;
        }
        if ((unsigned int )((re_opcode_t )*tmp___37) == 17U) {
          goto case_17;
        }
        if ((unsigned int )((re_opcode_t )*tmp___37) == 18U) {
          goto case_17;
        }
        if ((unsigned int )((re_opcode_t )*tmp___37) == 13U) {
          goto case_17;
        }
        if ((unsigned int )((re_opcode_t )*tmp___37) == 19U) {
          goto case_17;
        }
        goto switch_default;
        case_22: /* CIL Label */ 
        is_a_jump_n = (boolean )1;
        case_17: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_19: /* CIL Label */ 
        {
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
          while (1) {
            while_continue___25: /* CIL Label */ ;
            mcnt = (int )*p1 & 255;
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
          p1 += 2;
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
        if (is_a_jump_n) {
          p1 += 2;
        }
        goto switch_break___0;
        switch_default: /* CIL Label */ ;
        switch_break___0: /* CIL Label */ ;
        }
        p1 += mcnt;
        if (mcnt < 0) {
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
            if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 6U) {
              if ((int )*(p1 + 4) == (int )*p) {
                if ((reg_info + (int )*p)->bits.ever_matched_something) {
                  (reg_info + (int )*p)->bits.ever_matched_something = 0U;
                  r___3 = (unsigned int )*p;
                  {
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
                    if (! (r___3 < (unsigned int )*p + (unsigned int )*(p + 1))) {
                      goto while_break___26;
                    }
                    *(regstart + r___3) = *(old_regstart + r___3);
                    if ((unsigned long )*(old_regend + r___3) >= (unsigned long )*(regstart + r___3)) {
                      *(regend + r___3) = *(old_regend + r___3);
                    }
                    r___3 ++;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
                p1 ++;
                {
                while (1) {
                  while_continue___27: /* CIL Label */ ;
                  {
                  while (1) {
                    while_continue___28: /* CIL Label */ ;
                    mcnt = (int )*p1 & 255;
                    mcnt += (int )((signed char )*(p1 + 1)) << 8;
                    goto while_break___28;
                  }
                  while_break___28: /* CIL Label */ ;
                  }
                  p1 += 2;
                  goto while_break___27;
                }
                while_break___27: /* CIL Label */ ;
                }
                {
                while (1) {
                  while_continue___29: /* CIL Label */ ;
                  {
                  while (1) {
                    while_continue___30: /* CIL Label */ ;
                    if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
                      goto while_break___30;
                    }
                    if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
                      tmp___41 = 0;
                    } else {
                      {
                      tmp___38 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
                      destination = (char *)tmp___38;
                      tmp___39 = memcpy((void * __restrict  )destination, (void const   * __restrict  )fail_stack.stack,
                                        (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
                      fail_stack.stack = (fail_stack_elt_t *)tmp___39;
                      }
                      if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
                        tmp___40 = 0;
                      } else {
                        fail_stack.size <<= 1;
                        tmp___40 = 1;
                      }
                      tmp___41 = tmp___40;
                    }
                    if (! tmp___41) {
                      return (-2);
                    }
                  }
                  while_break___30: /* CIL Label */ ;
                  }
                  this_reg = lowest_active_reg;
                  {
                  while (1) {
                    while_continue___31: /* CIL Label */ ;
                    if (! (this_reg <= highest_active_reg)) {
                      goto while_break___31;
                    }
                    tmp___42 = fail_stack.avail;
                    (fail_stack.avail) ++;
                    (fail_stack.stack + tmp___42)->pointer = (unsigned char *)*(regstart + this_reg);
                    tmp___43 = fail_stack.avail;
                    (fail_stack.avail) ++;
                    (fail_stack.stack + tmp___43)->pointer = (unsigned char *)*(regend + this_reg);
                    tmp___44 = fail_stack.avail;
                    (fail_stack.avail) ++;
                    *(fail_stack.stack + tmp___44) = (reg_info + this_reg)->word;
                    this_reg ++;
                  }
                  while_break___31: /* CIL Label */ ;
                  }
                  tmp___45 = fail_stack.avail;
                  (fail_stack.avail) ++;
                  (fail_stack.stack + tmp___45)->integer = (int )lowest_active_reg;
                  tmp___46 = fail_stack.avail;
                  (fail_stack.avail) ++;
                  (fail_stack.stack + tmp___46)->integer = (int )highest_active_reg;
                  tmp___47 = fail_stack.avail;
                  (fail_stack.avail) ++;
                  (fail_stack.stack + tmp___47)->pointer = p1 + mcnt;
                  tmp___48 = fail_stack.avail;
                  (fail_stack.avail) ++;
                  (fail_stack.stack + tmp___48)->pointer = (unsigned char *)d;
                  goto while_break___29;
                }
                while_break___29: /* CIL Label */ ;
                }
                goto fail;
              }
            }
          }
        }
      }
    }
    }
    p += 2;
    goto switch_break;
    case_8: /* CIL Label */ 
    tmp___49 = p;
    p ++;
    regno = (int )*tmp___49;
    if ((unsigned long )*(regstart + regno) == (unsigned long )(& reg_unset_dummy)) {
      goto fail;
    } else { //Added block
    if ((unsigned long )*(regend + regno) == (unsigned long )(& reg_unset_dummy)) {
      goto fail;
    }
    }
    d2 = *(regstart + regno);
    if (size1) {
      if ((unsigned long )string1 <= (unsigned long )*(regstart + regno)) {
        if ((unsigned long )*(regstart + regno) <= (unsigned long )(string1 + size1)) {
          tmp___52 = 1;
        } else {
          tmp___52 = 0;
        }
      } else {
        tmp___52 = 0;
      }
    } else {
      tmp___52 = 0;
    }
    if (size1) {
      if ((unsigned long )string1 <= (unsigned long )*(regend + regno)) {
        if ((unsigned long )*(regend + regno) <= (unsigned long )(string1 + size1)) {
          tmp___53 = 1;
        } else {
          tmp___53 = 0;
        }
      } else {
        tmp___53 = 0;
      }
    } else {
      tmp___53 = 0;
    }
    if (tmp___52 == tmp___53) {
      dend2 = *(regend + regno);
    } else {
      dend2 = end_match_1;
    }
    {
    while (1) {
      while_continue___32: /* CIL Label */ ;
      {
      while (1) {
        while_continue___33: /* CIL Label */ ;
        if (! ((unsigned long )d2 == (unsigned long )dend2)) {
          goto while_break___33;
        }
        if ((unsigned long )dend2 == (unsigned long )end_match_2) {
          goto while_break___33;
        }
        if ((unsigned long )dend2 == (unsigned long )*(regend + regno)) {
          goto while_break___33;
        }
        d2 = string2;
        dend2 = *(regend + regno);
      }
      while_break___33: /* CIL Label */ ;
      }
      if ((unsigned long )d2 == (unsigned long )dend2) {
        goto while_break___32;
      }
      {
      while (1) {
        while_continue___34: /* CIL Label */ ;
        if (! ((unsigned long )d == (unsigned long )dend)) {
          goto while_break___34;
        }
        if ((unsigned long )dend == (unsigned long )end_match_2) {
          goto fail;
        }
        d = string2;
        dend = end_match_2;
      }
      while_break___34: /* CIL Label */ ;
      }
      mcnt = (int )(dend - d);
      if ((long )mcnt > dend2 - d2) {
        mcnt = (int )(dend2 - d2);
      }
      if (translate) {
        {
        tmp___54 = bcmp_translate(d, d2, mcnt, translate);
        tmp___56 = tmp___54;
        }
      } else {
        {
        tmp___55 = memcmp((void const   *)d, (void const   *)d2, (size_t )mcnt);
        tmp___56 = tmp___55;
        }
      }
      if (tmp___56) {
        goto fail;
      }
      d += mcnt;
      d2 += mcnt;
      {
      while (1) {
        while_continue___35: /* CIL Label */ ;
        if (! set_regs_matched_done) {
          set_regs_matched_done = 1;
          r___4 = lowest_active_reg;
          {
          while (1) {
            while_continue___36: /* CIL Label */ ;
            if (! (r___4 <= highest_active_reg)) {
              goto while_break___36;
            }
            tmp___57 = 1U;
            (reg_info + r___4)->bits.ever_matched_something = tmp___57;
            (reg_info + r___4)->bits.matched_something = tmp___57;
            r___4 ++;
          }
          while_break___36: /* CIL Label */ ;
          }
        }
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
    goto switch_break;
    case_9: /* CIL Label */ ;
    if (size1) {
      tmp___58 = string1;
    } else {
      tmp___58 = string2;
    }
    if ((unsigned long )d == (unsigned long )tmp___58) {
      goto _L___13;
    } else { //Added block
    if (! size2) {
      _L___13: 
      if (! bufp->not_bol) {
        goto switch_break;
      }
    } else { //Added block
    if ((int const   )*(d + -1) == 10) {
      if (bufp->newline_anchor) {
        goto switch_break;
      }
    }
    }
    }
    goto fail;
    case_10: /* CIL Label */ ;
    if ((unsigned long )d == (unsigned long )end2) {
      if (! bufp->not_eol) {
        goto switch_break;
      }
    } else {
      if ((unsigned long )d == (unsigned long )end1) {
        tmp___59 = (int )((int const   )*string2);
      } else {
        tmp___59 = (int )((int const   )*d);
      }
      if (tmp___59 == 10) {
        if (bufp->newline_anchor) {
          goto switch_break;
        }
      }
    }
    goto fail;
    case_11: /* CIL Label */ ;
    if (size1) {
      tmp___60 = string1;
    } else {
      tmp___60 = string2;
    }
    if ((unsigned long )d == (unsigned long )tmp___60) {
      goto switch_break;
    } else { //Added block
    if (! size2) {
      goto switch_break;
    }
    }
    goto fail;
    case_12: /* CIL Label */ ;
    if ((unsigned long )d == (unsigned long )end2) {
      goto switch_break;
    }
    goto fail;
    case_16: /* CIL Label */ ;
    {
    while (1) {
      while_continue___37: /* CIL Label */ ;
      {
      while (1) {
        while_continue___38: /* CIL Label */ ;
        mcnt = (int )*p & 255;
        mcnt += (int )((signed char )*(p + 1)) << 8;
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___39: /* CIL Label */ ;
      {
      while (1) {
        while_continue___40: /* CIL Label */ ;
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
          goto while_break___40;
        }
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
          tmp___64 = 0;
        } else {
          {
          tmp___61 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___0 = (char *)tmp___61;
          tmp___62 = memcpy((void * __restrict  )destination___0, (void const   * __restrict  )fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)tmp___62;
          }
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            tmp___63 = 0;
          } else {
            fail_stack.size <<= 1;
            tmp___63 = 1;
          }
          tmp___64 = tmp___63;
        }
        if (! tmp___64) {
          return (-2);
        }
      }
      while_break___40: /* CIL Label */ ;
      }
      this_reg___0 = lowest_active_reg;
      {
      while (1) {
        while_continue___41: /* CIL Label */ ;
        if (! (this_reg___0 <= highest_active_reg)) {
          goto while_break___41;
        }
        tmp___65 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___65)->pointer = (unsigned char *)*(regstart + this_reg___0);
        tmp___66 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___66)->pointer = (unsigned char *)*(regend + this_reg___0);
        tmp___67 = fail_stack.avail;
        (fail_stack.avail) ++;
        *(fail_stack.stack + tmp___67) = (reg_info + this_reg___0)->word;
        this_reg___0 ++;
      }
      while_break___41: /* CIL Label */ ;
      }
      tmp___68 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___68)->integer = (int )lowest_active_reg;
      tmp___69 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___69)->integer = (int )highest_active_reg;
      tmp___70 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___70)->pointer = p + mcnt;
      tmp___71 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___71)->pointer = (unsigned char *)((void *)0);
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    goto switch_break;
    on_failure: 
    case_15: /* CIL Label */ ;
    {
    while (1) {
      while_continue___42: /* CIL Label */ ;
      {
      while (1) {
        while_continue___43: /* CIL Label */ ;
        mcnt = (int )*p & 255;
        mcnt += (int )((signed char )*(p + 1)) << 8;
        goto while_break___43;
      }
      while_break___43: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    p1 = p;
    {
    while (1) {
      while_continue___44: /* CIL Label */ ;
      if ((unsigned long )p1 < (unsigned long )pend) {
        if (! ((unsigned int )((re_opcode_t )*p1) == 0U)) {
          goto while_break___44;
        }
      } else {
        goto while_break___44;
      }
      p1 ++;
    }
    while_break___44: /* CIL Label */ ;
    }
    if ((unsigned long )p1 < (unsigned long )pend) {
      if ((unsigned int )((re_opcode_t )*p1) == 6U) {
        highest_active_reg = (active_reg_t )((int )*(p1 + 1) + (int )*(p1 + 2));
        if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
          lowest_active_reg = (active_reg_t )*(p1 + 1);
        }
      }
    }
    {
    while (1) {
      while_continue___45: /* CIL Label */ ;
      {
      while (1) {
        while_continue___46: /* CIL Label */ ;
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
          goto while_break___46;
        }
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
          tmp___75 = 0;
        } else {
          {
          tmp___72 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___1 = (char *)tmp___72;
          tmp___73 = memcpy((void * __restrict  )destination___1, (void const   * __restrict  )fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)tmp___73;
          }
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            tmp___74 = 0;
          } else {
            fail_stack.size <<= 1;
            tmp___74 = 1;
          }
          tmp___75 = tmp___74;
        }
        if (! tmp___75) {
          return (-2);
        }
      }
      while_break___46: /* CIL Label */ ;
      }
      this_reg___1 = lowest_active_reg;
      {
      while (1) {
        while_continue___47: /* CIL Label */ ;
        if (! (this_reg___1 <= highest_active_reg)) {
          goto while_break___47;
        }
        tmp___76 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___76)->pointer = (unsigned char *)*(regstart + this_reg___1);
        tmp___77 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___77)->pointer = (unsigned char *)*(regend + this_reg___1);
        tmp___78 = fail_stack.avail;
        (fail_stack.avail) ++;
        *(fail_stack.stack + tmp___78) = (reg_info + this_reg___1)->word;
        this_reg___1 ++;
      }
      while_break___47: /* CIL Label */ ;
      }
      tmp___79 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___79)->integer = (int )lowest_active_reg;
      tmp___80 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___80)->integer = (int )highest_active_reg;
      tmp___81 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___81)->pointer = p + mcnt;
      tmp___82 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___82)->pointer = (unsigned char *)d;
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    goto switch_break;
    case_18___0: /* CIL Label */ 
    {
    while (1) {
      while_continue___48: /* CIL Label */ ;
      {
      while (1) {
        while_continue___49: /* CIL Label */ ;
        mcnt = (int )*p & 255;
        mcnt += (int )((signed char )*(p + 1)) << 8;
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    p2 = p;
    {
    while (1) {
      while_continue___50: /* CIL Label */ ;
      if ((unsigned long )(p2 + 2) < (unsigned long )pend) {
        if ((unsigned int )((re_opcode_t )*p2) == 7U) {
          p2 += 3;
        } else { //Added block
        if ((unsigned int )((re_opcode_t )*p2) == 6U) {
          p2 += 3;
        } else {
          goto _L___14;
        }
        }
      } else { //Added block
      _L___14: 
      if ((unsigned long )(p2 + 6) < (unsigned long )pend) {
        if ((unsigned int )((re_opcode_t )*p2) == 19U) {
          p2 += 6;
        } else {
          goto while_break___50;
        }
      } else {
        goto while_break___50;
      }
      }
    }
    while_break___50: /* CIL Label */ ;
    }
    p1 = p + mcnt;
    if ((unsigned long )p2 == (unsigned long )pend) {
      *(p + -3) = (unsigned char)17;
    } else { //Added block
    if ((unsigned int )((re_opcode_t )*p2) == 2U) {
      goto _L___18;
    } else { //Added block
    if (bufp->newline_anchor) {
      if ((unsigned int )((re_opcode_t )*p2) == 10U) {
        _L___18: 
        if ((int )*p2 == 10) {
          tmp___83 = '\n';
        } else {
          tmp___83 = (int )*(p2 + 2);
        }
        c___0 = (unsigned char )tmp___83;
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
          if ((int )*(p1 + 5) != (int )c___0) {
            *(p + -3) = (unsigned char)17;
          } else {
            goto _L___16;
          }
        } else { //Added block
        _L___16: 
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
          goto _L___15;
        } else { //Added block
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
          _L___15: 
          not___0 = (unsigned int )((re_opcode_t )*(p1 + 3)) == 5U;
          if ((int )c___0 < (int )((unsigned char )((int )*(p1 + 4) * 8))) {
            if ((int )*(p1 + (5 + (int )c___0 / 8)) & (1 << (int )c___0 % 8)) {
              not___0 = ! not___0;
            }
          }
          if (! not___0) {
            *(p + -3) = (unsigned char)17;
          }
        }
        }
        }
      } else {
        goto _L___19;
      }
    } else { //Added block
    _L___19: 
    if ((unsigned int )((re_opcode_t )*p2) == 4U) {
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
        if ((int )*(p2 + 1) * 8 > (int )*(p1 + 5)) {
          if ((int )*(p2 + (2 + (int )*(p1 + 5) / 8)) & (1 << (int )*(p1 + 5) % 8)) {
            goto _L___17;
          } else {
            *(p + -3) = (unsigned char)17;
          }
        } else {
          *(p + -3) = (unsigned char)17;
        }
      } else { //Added block
      _L___17: 
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
        idx = 0;
        {
        while (1) {
          while_continue___51: /* CIL Label */ ;
          if (! (idx < (int )*(p2 + 1))) {
            goto while_break___51;
          }
          if (! ((int )*(p2 + (2 + idx)) == 0)) {
            if (idx < (int )*(p1 + 4)) {
              if (! (((int )*(p2 + (2 + idx)) & ~ ((int )*(p1 + (5 + idx)))) == 0)) {
                goto while_break___51;
              }
            } else {
              goto while_break___51;
            }
          }
          idx ++;
        }
        while_break___51: /* CIL Label */ ;
        }
        if (idx == (int )*(p2 + 1)) {
          *(p + -3) = (unsigned char)17;
        }
      } else { //Added block
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
        idx___0 = 0;
        {
        while (1) {
          while_continue___52: /* CIL Label */ ;
          if (idx___0 < (int )*(p2 + 1)) {
            if (! (idx___0 < (int )*(p1 + 4))) {
              goto while_break___52;
            }
          } else {
            goto while_break___52;
          }
          if (((int )*(p2 + (2 + idx___0)) & (int )*(p1 + (5 + idx___0))) != 0) {
            goto while_break___52;
          }
          idx___0 ++;
        }
        while_break___52: /* CIL Label */ ;
        }
        if (idx___0 == (int )*(p2 + 1)) {
          *(p + -3) = (unsigned char)17;
        } else { //Added block
        if (idx___0 == (int )*(p1 + 4)) {
          *(p + -3) = (unsigned char)17;
        }
        }
      }
      }
      }
    }
    }
    }
    }
    p -= 2;
    if ((unsigned int )((re_opcode_t )*(p + -1)) != 17U) {
      *(p + -1) = (unsigned char)13;
      goto unconditional_jump;
    }
    case_17___0: /* CIL Label */ 
    (fail_stack.avail) --;
    string_temp = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
    if ((unsigned long )string_temp != (unsigned long )((void *)0)) {
      sdummy = (char const   *)string_temp;
    }
    (fail_stack.avail) --;
    pdummy = (fail_stack.stack + fail_stack.avail)->pointer;
    (fail_stack.avail) --;
    dummy_high_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
    (fail_stack.avail) --;
    dummy_low_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
    this_reg___2 = dummy_high_reg;
    {
    while (1) {
      while_continue___53: /* CIL Label */ ;
      if (! (this_reg___2 >= dummy_low_reg)) {
        goto while_break___53;
      }
      (fail_stack.avail) --;
      (reg_info_dummy + this_reg___2)->word = *(fail_stack.stack + fail_stack.avail);
      (fail_stack.avail) --;
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
      (fail_stack.avail) --;
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
      this_reg___2 --;
    }
    while_break___53: /* CIL Label */ ;
    }
    set_regs_matched_done = 0;
    unconditional_jump: ;
    case_13___0: /* CIL Label */ 
    {
    while (1) {
      while_continue___54: /* CIL Label */ ;
      {
      while (1) {
        while_continue___55: /* CIL Label */ ;
        mcnt = (int )*p & 255;
        mcnt += (int )((signed char )*(p + 1)) << 8;
        goto while_break___55;
      }
      while_break___55: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    p += mcnt;
    goto switch_break;
    case_14: /* CIL Label */ ;
    goto unconditional_jump;
    case_19___0: /* CIL Label */ ;
    {
    while (1) {
      while_continue___56: /* CIL Label */ ;
      {
      while (1) {
        while_continue___57: /* CIL Label */ ;
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
          goto while_break___57;
        }
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
          tmp___87 = 0;
        } else {
          {
          tmp___84 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___2 = (char *)tmp___84;
          tmp___85 = memcpy((void * __restrict  )destination___2, (void const   * __restrict  )fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)tmp___85;
          }
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            tmp___86 = 0;
          } else {
            fail_stack.size <<= 1;
            tmp___86 = 1;
          }
          tmp___87 = tmp___86;
        }
        if (! tmp___87) {
          return (-2);
        }
      }
      while_break___57: /* CIL Label */ ;
      }
      this_reg___3 = lowest_active_reg;
      {
      while (1) {
        while_continue___58: /* CIL Label */ ;
        if (! (this_reg___3 <= highest_active_reg)) {
          goto while_break___58;
        }
        tmp___88 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___88)->pointer = (unsigned char *)*(regstart + this_reg___3);
        tmp___89 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___89)->pointer = (unsigned char *)*(regend + this_reg___3);
        tmp___90 = fail_stack.avail;
        (fail_stack.avail) ++;
        *(fail_stack.stack + tmp___90) = (reg_info + this_reg___3)->word;
        this_reg___3 ++;
      }
      while_break___58: /* CIL Label */ ;
      }
      tmp___91 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___91)->integer = (int )lowest_active_reg;
      tmp___92 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___92)->integer = (int )highest_active_reg;
      tmp___93 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___93)->pointer = (unsigned char *)((void *)0);
      tmp___94 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___94)->pointer = (unsigned char *)((void *)0);
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    goto unconditional_jump;
    case_20: /* CIL Label */ ;
    {
    while (1) {
      while_continue___59: /* CIL Label */ ;
      {
      while (1) {
        while_continue___60: /* CIL Label */ ;
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
          goto while_break___60;
        }
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
          tmp___98 = 0;
        } else {
          {
          tmp___95 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___3 = (char *)tmp___95;
          tmp___96 = memcpy((void * __restrict  )destination___3, (void const   * __restrict  )fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)tmp___96;
          }
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            tmp___97 = 0;
          } else {
            fail_stack.size <<= 1;
            tmp___97 = 1;
          }
          tmp___98 = tmp___97;
        }
        if (! tmp___98) {
          return (-2);
        }
      }
      while_break___60: /* CIL Label */ ;
      }
      this_reg___4 = lowest_active_reg;
      {
      while (1) {
        while_continue___61: /* CIL Label */ ;
        if (! (this_reg___4 <= highest_active_reg)) {
          goto while_break___61;
        }
        tmp___99 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___99)->pointer = (unsigned char *)*(regstart + this_reg___4);
        tmp___100 = fail_stack.avail;
        (fail_stack.avail) ++;
        (fail_stack.stack + tmp___100)->pointer = (unsigned char *)*(regend + this_reg___4);
        tmp___101 = fail_stack.avail;
        (fail_stack.avail) ++;
        *(fail_stack.stack + tmp___101) = (reg_info + this_reg___4)->word;
        this_reg___4 ++;
      }
      while_break___61: /* CIL Label */ ;
      }
      tmp___102 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___102)->integer = (int )lowest_active_reg;
      tmp___103 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___103)->integer = (int )highest_active_reg;
      tmp___104 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___104)->pointer = (unsigned char *)((void *)0);
      tmp___105 = fail_stack.avail;
      (fail_stack.avail) ++;
      (fail_stack.stack + tmp___105)->pointer = (unsigned char *)((void *)0);
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    goto switch_break;
    case_21: /* CIL Label */ 
    {
    while (1) {
      while_continue___62: /* CIL Label */ ;
      mcnt = (int )*(p + 2) & 255;
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    if (mcnt > 0) {
      mcnt --;
      p += 2;
      {
      while (1) {
        while_continue___63: /* CIL Label */ ;
        {
        while (1) {
          while_continue___64: /* CIL Label */ ;
          *(p + 0) = (unsigned char )(mcnt & 255);
          *(p + 1) = (unsigned char )(mcnt >> 8);
          goto while_break___64;
        }
        while_break___64: /* CIL Label */ ;
        }
        p += 2;
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
    } else { //Added block
    if (mcnt == 0) {
      *(p + 2) = (unsigned char)0;
      *(p + 3) = (unsigned char)0;
      goto on_failure;
    }
    }
    goto switch_break;
    case_22___0: /* CIL Label */ 
    {
    while (1) {
      while_continue___65: /* CIL Label */ ;
      mcnt = (int )*(p + 2) & 255;
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
    if (mcnt) {
      mcnt --;
      {
      while (1) {
        while_continue___66: /* CIL Label */ ;
        *((p + 2) + 0) = (unsigned char )(mcnt & 255);
        *((p + 2) + 1) = (unsigned char )(mcnt >> 8);
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
      goto unconditional_jump;
    } else {
      p += 4;
    }
    goto switch_break;
    case_23: /* CIL Label */ 
    {
    while (1) {
      while_continue___67: /* CIL Label */ ;
      {
      while (1) {
        while_continue___68: /* CIL Label */ ;
        mcnt = (int )*p & 255;
        mcnt += (int )((signed char )*(p + 1)) << 8;
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
    p1 = p + mcnt;
    {
    while (1) {
      while_continue___69: /* CIL Label */ ;
      {
      while (1) {
        while_continue___70: /* CIL Label */ ;
        mcnt = (int )*p & 255;
        mcnt += (int )((signed char )*(p + 1)) << 8;
        goto while_break___70;
      }
      while_break___70: /* CIL Label */ ;
      }
      p += 2;
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___71: /* CIL Label */ ;
      *(p1 + 0) = (unsigned char )(mcnt & 255);
      *(p1 + 1) = (unsigned char )(mcnt >> 8);
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
    goto switch_break;
    case_28: /* CIL Label */ 
    if (size1) {
      tmp___106 = string1;
    } else {
      tmp___106 = string2;
    }
    if ((unsigned long )d == (unsigned long )tmp___106) {
      goto switch_break;
    } else { //Added block
    if (! size2) {
      goto switch_break;
    } else { //Added block
    if ((unsigned long )d == (unsigned long )end2) {
      goto switch_break;
    }
    }
    }
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
      tmp___108 = (int )((int const   )*string2);
    } else {
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
        tmp___107 = (int )((int const   )*(end1 - 1));
      } else {
        tmp___107 = (int )((int const   )*(d - 1));
      }
      tmp___108 = tmp___107;
    }
    prevchar = (boolean )((int )re_syntax_table[tmp___108 & 255] == 1);
    if ((unsigned long )d == (unsigned long )end1) {
      tmp___110 = (int )((int const   )*string2);
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        tmp___109 = (int )((int const   )*(end1 - 1));
      } else {
        tmp___109 = (int )((int const   )*d);
      }
      tmp___110 = tmp___109;
    }
    thischar = (boolean )((int )re_syntax_table[tmp___110 & 255] == 1);
    if ((int )prevchar != (int )thischar) {
      goto switch_break;
    }
    goto fail;
    case_29: /* CIL Label */ 
    if (size1) {
      tmp___111 = string1;
    } else {
      tmp___111 = string2;
    }
    if ((unsigned long )d == (unsigned long )tmp___111) {
      goto fail;
    } else { //Added block
    if (! size2) {
      goto fail;
    } else { //Added block
    if ((unsigned long )d == (unsigned long )end2) {
      goto fail;
    }
    }
    }
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
      tmp___113 = (int )((int const   )*string2);
    } else {
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
        tmp___112 = (int )((int const   )*(end1 - 1));
      } else {
        tmp___112 = (int )((int const   )*(d - 1));
      }
      tmp___113 = tmp___112;
    }
    prevchar___0 = (boolean )((int )re_syntax_table[tmp___113 & 255] == 1);
    if ((unsigned long )d == (unsigned long )end1) {
      tmp___115 = (int )((int const   )*string2);
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        tmp___114 = (int )((int const   )*(end1 - 1));
      } else {
        tmp___114 = (int )((int const   )*d);
      }
      tmp___115 = tmp___114;
    }
    thischar___0 = (boolean )((int )re_syntax_table[tmp___115 & 255] == 1);
    if ((int )prevchar___0 != (int )thischar___0) {
      goto fail;
    }
    goto switch_break;
    case_26: /* CIL Label */ ;
    if ((unsigned long )d == (unsigned long )end1) {
      tmp___117 = (int )((int const   )*string2);
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        tmp___116 = (int )((int const   )*(end1 - 1));
      } else {
        tmp___116 = (int )((int const   )*d);
      }
      tmp___117 = tmp___116;
    }
    if ((int )re_syntax_table[tmp___117 & 255] == 1) {
      if (size1) {
        tmp___118 = string1;
      } else {
        tmp___118 = string2;
      }
      if ((unsigned long )d == (unsigned long )tmp___118) {
        goto switch_break;
      } else { //Added block
      if (! size2) {
        goto switch_break;
      } else {
        if ((unsigned long )(d - 1) == (unsigned long )end1) {
          tmp___120 = (int )((int const   )*string2);
        } else {
          if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
            tmp___119 = (int )((int const   )*(end1 - 1));
          } else {
            tmp___119 = (int )((int const   )*(d - 1));
          }
          tmp___120 = tmp___119;
        }
        if (! ((int )re_syntax_table[tmp___120 & 255] == 1)) {
          goto switch_break;
        }
      }
      }
    }
    goto fail;
    case_27: /* CIL Label */ ;
    if (size1) {
      tmp___121 = string1;
    } else {
      tmp___121 = string2;
    }
    if (! ((unsigned long )d == (unsigned long )tmp___121)) {
      if (! (! size2)) {
        if ((unsigned long )(d - 1) == (unsigned long )end1) {
          tmp___123 = (int )((int const   )*string2);
        } else {
          if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
            tmp___122 = (int )((int const   )*(end1 - 1));
          } else {
            tmp___122 = (int )((int const   )*(d - 1));
          }
          tmp___123 = tmp___122;
        }
        if ((int )re_syntax_table[tmp___123 & 255] == 1) {
          if ((unsigned long )d == (unsigned long )end1) {
            tmp___125 = (int )((int const   )*string2);
          } else {
            if ((unsigned long )d == (unsigned long )(string2 - 1)) {
              tmp___124 = (int )((int const   )*(end1 - 1));
            } else {
              tmp___124 = (int )((int const   )*d);
            }
            tmp___125 = tmp___124;
          }
          if ((int )re_syntax_table[tmp___125 & 255] == 1) {
            if ((unsigned long )d == (unsigned long )end2) {
              goto switch_break;
            }
          } else {
            goto switch_break;
          }
        }
      }
    }
    goto fail;
    case_24: /* CIL Label */ ;
    {
    while (1) {
      while_continue___72: /* CIL Label */ ;
      if (! ((unsigned long )d == (unsigned long )dend)) {
        goto while_break___72;
      }
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    while_break___72: /* CIL Label */ ;
    }
    if ((unsigned long )d == (unsigned long )end1) {
      tmp___127 = (int )((int const   )*string2);
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        tmp___126 = (int )((int const   )*(end1 - 1));
      } else {
        tmp___126 = (int )((int const   )*d);
      }
      tmp___127 = tmp___126;
    }
    if (! ((int )re_syntax_table[tmp___127 & 255] == 1)) {
      goto fail;
    }
    {
    while (1) {
      while_continue___73: /* CIL Label */ ;
      if (! set_regs_matched_done) {
        set_regs_matched_done = 1;
        r___5 = lowest_active_reg;
        {
        while (1) {
          while_continue___74: /* CIL Label */ ;
          if (! (r___5 <= highest_active_reg)) {
            goto while_break___74;
          }
          tmp___128 = 1U;
          (reg_info + r___5)->bits.ever_matched_something = tmp___128;
          (reg_info + r___5)->bits.matched_something = tmp___128;
          r___5 ++;
        }
        while_break___74: /* CIL Label */ ;
        }
      }
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
    d ++;
    goto switch_break;
    case_25: /* CIL Label */ ;
    {
    while (1) {
      while_continue___75: /* CIL Label */ ;
      if (! ((unsigned long )d == (unsigned long )dend)) {
        goto while_break___75;
      }
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    while_break___75: /* CIL Label */ ;
    }
    if ((unsigned long )d == (unsigned long )end1) {
      tmp___130 = (int )((int const   )*string2);
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        tmp___129 = (int )((int const   )*(end1 - 1));
      } else {
        tmp___129 = (int )((int const   )*d);
      }
      tmp___130 = tmp___129;
    }
    if ((int )re_syntax_table[tmp___130 & 255] == 1) {
      goto fail;
    }
    {
    while (1) {
      while_continue___76: /* CIL Label */ ;
      if (! set_regs_matched_done) {
        set_regs_matched_done = 1;
        r___6 = lowest_active_reg;
        {
        while (1) {
          while_continue___77: /* CIL Label */ ;
          if (! (r___6 <= highest_active_reg)) {
            goto while_break___77;
          }
          tmp___131 = 1U;
          (reg_info + r___6)->bits.ever_matched_something = tmp___131;
          (reg_info + r___6)->bits.matched_something = tmp___131;
          r___6 ++;
        }
        while_break___77: /* CIL Label */ ;
        }
      }
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
    d ++;
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
    goto __Cont;
    fail: 
    if (! (fail_stack.avail == 0U)) {
      (fail_stack.avail) --;
      string_temp___0 = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
      if ((unsigned long )string_temp___0 != (unsigned long )((void *)0)) {
        d = (char const   *)string_temp___0;
      }
      (fail_stack.avail) --;
      p = (fail_stack.stack + fail_stack.avail)->pointer;
      (fail_stack.avail) --;
      highest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
      (fail_stack.avail) --;
      lowest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
      this_reg___5 = highest_active_reg;
      {
      while (1) {
        while_continue___78: /* CIL Label */ ;
        if (! (this_reg___5 >= lowest_active_reg)) {
          goto while_break___78;
        }
        (fail_stack.avail) --;
        (reg_info + this_reg___5)->word = *(fail_stack.stack + fail_stack.avail);
        (fail_stack.avail) --;
        *(regend + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
        (fail_stack.avail) --;
        *(regstart + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
        this_reg___5 --;
      }
      while_break___78: /* CIL Label */ ;
      }
      set_regs_matched_done = 0;
      if (! p) {
        goto fail;
      }
      if ((unsigned long )p < (unsigned long )pend) {
        is_a_jump_n___0 = (boolean )0;
        {
        if ((unsigned int )((re_opcode_t )*p) == 22U) {
          goto case_22___1;
        }
        if ((unsigned int )((re_opcode_t )*p) == 18U) {
          goto case_18___1;
        }
        if ((unsigned int )((re_opcode_t )*p) == 17U) {
          goto case_18___1;
        }
        if ((unsigned int )((re_opcode_t )*p) == 13U) {
          goto case_18___1;
        }
        goto switch_default___1;
        case_22___1: /* CIL Label */ 
        is_a_jump_n___0 = (boolean )1;
        case_18___1: /* CIL Label */ 
        case_17___1: /* CIL Label */ 
        case_13___1: /* CIL Label */ 
        p1 = p + 1;
        {
        while (1) {
          while_continue___79: /* CIL Label */ ;
          {
          while (1) {
            while_continue___80: /* CIL Label */ ;
            mcnt = (int )*p1 & 255;
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
          p1 += 2;
          goto while_break___79;
        }
        while_break___79: /* CIL Label */ ;
        }
        p1 += mcnt;
        if (is_a_jump_n___0) {
          if ((unsigned int )((re_opcode_t )*p1) == 21U) {
            goto fail;
          } else {
            goto _L___20;
          }
        } else { //Added block
        _L___20: 
        if (! is_a_jump_n___0) {
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
            goto fail;
          }
        }
        }
        goto switch_break___1;
        switch_default___1: /* CIL Label */ ;
        switch_break___1: /* CIL Label */ ;
        }
      }
      if ((unsigned long )d >= (unsigned long )string1) {
        if ((unsigned long )d <= (unsigned long )end1) {
          dend = end_match_1;
        }
      }
    } else {
      goto while_break___3;
    }
    __Cont: ;
  }
  while_break___3: /* CIL Label */ ;
  }
  if (best_regs_set) {
    goto restore_best_regs;
  }
  {
  while (1) {
    while_continue___81: /* CIL Label */ ;
    regstart = (char const   **)((void *)0);
    regend = (char const   **)((void *)0);
    old_regstart = (char const   **)((void *)0);
    old_regend = (char const   **)((void *)0);
    best_regstart = (char const   **)((void *)0);
    best_regend = (char const   **)((void *)0);
    reg_info = (register_info_type *)((void *)0);
    reg_dummy = (char const   **)((void *)0);
    reg_info_dummy = (register_info_type *)((void *)0);
    goto while_break___81;
  }
  while_break___81: /* CIL Label */ ;
  }
  return (-1);
}
}
static boolean group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                         register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;

  {
  p1 = *p + 2;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p1 < (unsigned long )end)) {
      goto while_break;
    }
    {
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
      goto case_15;
    }
    if ((unsigned int )((re_opcode_t )*p1) == 7U) {
      goto case_7;
    }
    goto switch_default;
    case_15: /* CIL Label */ 
    p1 ++;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        mcnt = (int )*p1 & 255;
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      p1 += 2;
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (mcnt >= 0) {
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) == 14U)) {
          goto while_break___2;
        }
        {
        tmp = alt_match_null_string_p(p1, (p1 + mcnt) - 3, reg_info);
        }
        if (! tmp) {
          return ((boolean )0);
        }
        p1 += mcnt;
        if ((unsigned int )((re_opcode_t )*p1) != 15U) {
          goto while_break___2;
        }
        p1 ++;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            mcnt = (int )*p1 & 255;
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
          p1 += 2;
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        if ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) != 14U) {
          p1 -= 3;
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        mcnt = (int )*(p1 - 2) & 255;
        mcnt += (int )((signed char )*((p1 - 2) + 1)) << 8;
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
      tmp___0 = alt_match_null_string_p(p1, p1 + mcnt, reg_info);
      }
      if (! tmp___0) {
        return ((boolean )0);
      }
      p1 += mcnt;
    }
    goto switch_break;
    case_7: /* CIL Label */ 
    *p = p1 + 2;
    return ((boolean )1);
    switch_default: /* CIL Label */ 
    {
    tmp___1 = common_op_match_null_string_p(& p1, end, reg_info);
    }
    if (! tmp___1) {
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((boolean )0);
}
}
static boolean alt_match_null_string_p(unsigned char *p , unsigned char *end , register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp ;

  {
  p1 = p;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p1 < (unsigned long )end)) {
      goto while_break;
    }
    {
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
      goto case_15;
    }
    goto switch_default;
    case_15: /* CIL Label */ 
    p1 ++;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        mcnt = (int )*p1 & 255;
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      p1 += 2;
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    p1 += mcnt;
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    tmp = common_op_match_null_string_p(& p1, end, reg_info);
    }
    if (! tmp) {
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((boolean )1);
}
}
static boolean common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                             register_info_type *reg_info ) 
{ 
  int mcnt ;
  boolean ret ;
  int reg_no ;
  unsigned char *p1 ;
  unsigned char *tmp ;

  {
  p1 = *p;
  tmp = p1;
  p1 ++;
  {
  if ((unsigned int )((re_opcode_t )*tmp) == 0U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 9U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 10U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 11U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 12U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 26U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 27U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 28U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 29U) {
    goto case_0;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 6U) {
    goto case_6;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 13U) {
    goto case_13;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 21U) {
    goto case_21;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 8U) {
    goto case_8;
  }
  if ((unsigned int )((re_opcode_t )*tmp) == 23U) {
    goto case_23;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_29: /* CIL Label */ 
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  reg_no = (int )*p1;
  ret = group_match_null_string_p(& p1, end, reg_info);
  }
  if ((reg_info + reg_no)->bits.match_null_string_p == 3U) {
    (reg_info + reg_no)->bits.match_null_string_p = (unsigned int )ret;
  }
  if (! ret) {
    return ((boolean )0);
  }
  goto switch_break;
  case_13: /* CIL Label */ 
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      mcnt = (int )*p1 & 255;
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    p1 += 2;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (mcnt >= 0) {
    p1 += mcnt;
  } else {
    return ((boolean )0);
  }
  goto switch_break;
  case_21: /* CIL Label */ 
  p1 += 2;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      mcnt = (int )*p1 & 255;
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    p1 += 2;
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  if (mcnt == 0) {
    p1 -= 4;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        mcnt = (int )*p1 & 255;
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      p1 += 2;
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    p1 += mcnt;
  } else {
    return ((boolean )0);
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  if (! (reg_info + (int )*p1)->bits.match_null_string_p) {
    return ((boolean )0);
  }
  goto switch_break;
  case_23: /* CIL Label */ 
  p1 += 4;
  switch_default: /* CIL Label */ 
  return ((boolean )0);
  switch_break: /* CIL Label */ ;
  }
  *p = p1;
  return ((boolean )1);
}
}
static int bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
  p1 = (unsigned char const   *)s1;
  p2 = (unsigned char const   *)s2;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! len) {
      goto while_break;
    }
    tmp = p1;
    p1 ++;
    tmp___0 = p2;
    p2 ++;
    if ((int )*(translate + (int const   )*tmp) != (int )*(translate + (int const   )*tmp___0)) {
      return (1);
    }
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;
  char *tmp ;

  {
  {
  bufp->regs_allocated = 0U;
  bufp->no_sub = 0U;
  bufp->newline_anchor = 1U;
  ret = regex_compile(pattern, length, re_syntax_options, bufp);
  }
  if (! ret) {
    return ((char const   *)((void *)0));
  }
  {
  tmp = gettext(re_error_msgid + re_error_msgid_idx[(int )ret]);
  }
  return ((char const   *)tmp);
}
}
int regcomp(regex_t *preg , char const   *pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned int i ;
  char *tmp___1 ;
  __int32_t const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  if (cflags & 1) {
    tmp = (((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
    tmp = ((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1);
  }
  {
  syntax = tmp;
  preg->buffer = (unsigned char *)0;
  preg->allocated = 0UL;
  preg->used = 0UL;
  tmp___0 = xmalloc((size_t )(1 << 8));
  preg->fastmap = tmp___0;
  }
  if (cflags & (1 << 1)) {
    {
    tmp___1 = xmalloc(256UL * sizeof(*((char *)0)));
    preg->translate = tmp___1;
    }
    if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
      return (12);
    }
    i = 0U;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < 256U)) {
        goto while_break;
      }
      {
      tmp___4 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___4 + (int )i) & 256) {
        {
        tmp___3 = __ctype_tolower_loc();
        *(preg->translate + i) = (char )((int )*(*tmp___3 + (int )i));
        }
      } else {
        *(preg->translate + i) = (char )i;
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    preg->translate = (char *)((void *)0);
  }
  if (cflags & ((1 << 1) << 1)) {
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
    preg->newline_anchor = 1U;
  } else {
    preg->newline_anchor = 0U;
  }
  {
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
  tmp___5 = strlen(pattern);
  ret = regex_compile(pattern, tmp___5, syntax, preg);
  }
  if ((unsigned int )ret == 16U) {
    ret = (reg_errcode_t )8;
  }
  if ((unsigned int )ret == 0U) {
    if (preg->fastmap) {
      {
      tmp___6 = re_compile_fastmap(preg);
      }
      if (tmp___6 == -2) {
        {
        free((void *)preg->fastmap);
        preg->fastmap = (char *)((void *)0);
        }
      }
    }
  }
  return ((int )ret);
}
}
int regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) 
{ 
  int ret ;
  struct re_registers regs___0 ;
  regex_t private_preg ;
  int len ;
  size_t tmp ;
  boolean want_reg_info ;
  int tmp___0 ;
  char *tmp___1 ;
  struct re_registers *tmp___2 ;
  unsigned int r ;
  int tmp___3 ;

  {
  {
  tmp = strlen(string);
  len = (int )tmp;
  }
  if (! preg->no_sub) {
    if (nmatch > 0UL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  want_reg_info = (boolean )tmp___0;
  private_preg = (regex_t )*preg;
  private_preg.not_bol = (unsigned int )(! (! (eflags & 1)));
  private_preg.not_eol = (unsigned int )(! (! (eflags & (1 << 1))));
  private_preg.regs_allocated = 2U;
  if (want_reg_info) {
    {
    regs___0.num_regs = (unsigned int )nmatch;
    tmp___1 = xmalloc((nmatch * 2UL) * sizeof(regoff_t ));
    regs___0.start = (regoff_t *)tmp___1;
    }
    if ((unsigned long )regs___0.start == (unsigned long )((void *)0)) {
      return (1);
    }
    regs___0.end = regs___0.start + nmatch;
  }
  if (want_reg_info) {
    tmp___2 = & regs___0;
  } else {
    tmp___2 = (struct re_registers *)0;
  }
  {
  ret = re_search(& private_preg, string, len, 0, len, tmp___2);
  }
  if (want_reg_info) {
    if (ret >= 0) {
      r = 0U;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((size_t )r < nmatch)) {
          goto while_break;
        }
        (pmatch + r)->rm_so = *(regs___0.start + r);
        (pmatch + r)->rm_eo = *(regs___0.end + r);
        r ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
    free((void *)regs___0.start);
    }
  }
  if (ret >= 0) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  return (tmp___3);
}
}
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  char *tmp ;
  size_t tmp___0 ;

  {
  if (errcode < 0) {
    {
    abort();
    }
  } else { //Added block
  if (errcode >= (int )(sizeof(re_error_msgid_idx) / sizeof(re_error_msgid_idx[0]))) {
    {
    abort();
    }
  }
  }
  {
  tmp = gettext(re_error_msgid + re_error_msgid_idx[errcode]);
  msg = (char const   *)tmp;
  tmp___0 = strlen(msg);
  msg_size = tmp___0 + 1UL;
  }
  if (errbuf_size != 0UL) {
    if (msg_size > errbuf_size) {
      {
      memcpy((void * __restrict  )errbuf, (void const   * __restrict  )msg, errbuf_size - 1UL);
      *(errbuf + (errbuf_size - 1UL)) = (char)0;
      }
    } else {
      {
      memcpy((void * __restrict  )errbuf, (void const   * __restrict  )msg, msg_size);
      }
    }
  }
  return (msg_size);
}
}
void regfree(regex_t *preg ) 
{ 


  {
  if ((unsigned long )preg->buffer != (unsigned long )((void *)0)) {
    {
    free((void *)preg->buffer);
    }
  }
  preg->buffer = (unsigned char *)((void *)0);
  preg->allocated = 0UL;
  preg->used = 0UL;
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
    {
    free((void *)preg->fastmap);
    }
  }
  preg->fastmap = (char *)((void *)0);
  preg->fastmap_accurate = 0U;
  if ((unsigned long )preg->translate != (unsigned long )((void *)0)) {
    {
    free((void *)preg->translate);
    }
  }
  preg->translate = (char *)((void *)0);
  return;
}
}
