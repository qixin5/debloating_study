/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef int wchar_t;
typedef __builtin_va_list __gnuc_va_list;
union __anonunion___value_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
struct __anonstruct___mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
typedef struct __anonstruct___mbstate_t_1 __mbstate_t;
typedef __mbstate_t mbstate_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef unsigned long countT;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef unsigned long reg_syntax_t;
enum __anonenum_reg_errcode_t_18 {
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
typedef enum __anonenum_reg_errcode_t_18 reg_errcode_t;
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
struct __anonstruct_regmatch_t_19 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_19 regmatch_t;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
typedef __gnuc_va_list va_list;
struct buffer;
struct buffer;
struct sed_cmd;
struct sed_cmd;
struct vector {
   struct sed_cmd *v ;
   size_t v_allocated ;
   size_t v_length ;
};
struct output {
   char *name ;
   _Bool missing_newline ;
   FILE *fp ;
   struct output *link ;
};
struct text_buf {
   char *text ;
   size_t text_length ;
};
struct regex {
   regex_t pattern ;
   int flags ;
   size_t sz ;
   char re[1] ;
};
enum replacement_types {
    REPL_ASIS = 0,
    REPL_UPPERCASE = 1,
    REPL_LOWERCASE = 2,
    REPL_UPPERCASE_FIRST = 4,
    REPL_LOWERCASE_FIRST = 8,
    REPL_MODIFIERS = 12,
    REPL_UPPERCASE_UPPERCASE = 5,
    REPL_UPPERCASE_LOWERCASE = 6,
    REPL_LOWERCASE_UPPERCASE = 9,
    REPL_LOWERCASE_LOWERCASE = 10
} ;
enum text_types {
    TEXT_BUFFER = 0,
    TEXT_REPLACEMENT = 1,
    TEXT_REGEX = 2
} ;
enum posixicity_types {
    POSIXLY_EXTENDED = 0,
    POSIXLY_CORRECT = 1,
    POSIXLY_BASIC = 2
} ;
enum addr_state {
    RANGE_INACTIVE = 0,
    RANGE_ACTIVE = 1,
    RANGE_CLOSED = 2
} ;
enum addr_types {
    ADDR_IS_NULL = 0,
    ADDR_IS_REGEX = 1,
    ADDR_IS_NUM = 2,
    ADDR_IS_NUM_MOD = 3,
    ADDR_IS_STEP = 4,
    ADDR_IS_STEP_MOD = 5,
    ADDR_IS_LAST = 6
} ;
struct addr {
   enum addr_types addr_type ;
   countT addr_number ;
   countT addr_step ;
   struct regex *addr_regex ;
};
struct replacement {
   char *prefix ;
   size_t prefix_length ;
   int subst_id ;
   enum replacement_types repl_type ;
   struct replacement *next ;
};
struct subst {
   struct regex *regx ;
   struct replacement *replacement ;
   countT numb ;
   struct output *outf ;
   unsigned int global : 1 ;
   unsigned int print : 2 ;
   unsigned int eval : 1 ;
   unsigned int max_id : 4 ;
};
union __anonunion_x_22 {
   struct text_buf cmd_txt ;
   int int_arg ;
   countT jump_index ;
   char *fname ;
   struct subst *cmd_subst ;
   struct output *outf ;
   FILE *fp ;
   unsigned char *translate ;
   char **translatemb ;
};
struct sed_cmd {
   struct addr *a1 ;
   struct addr *a2 ;
   enum addr_state range_state ;
   char addr_bang ;
   char cmd ;
   union __anonunion_x_22 x ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   long temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
struct prog_info {
   unsigned char const   *base ;
   unsigned char const   *cur ;
   unsigned char const   *end ;
   FILE *file ;
};
struct error_info {
   char const   *name ;
   countT line ;
   countT string_expr_count ;
};
struct sed_label {
   countT v_index ;
   char *name ;
   struct error_info err_info ;
   struct sed_label *next ;
};
struct special_files {
   struct output outf ;
   FILE **pfp ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct line {
   char *text ;
   char *active ;
   size_t length ;
   size_t alloc ;
   _Bool chomped ;
};
struct append_queue {
   char const   *fname ;
   char *text ;
   size_t textlen ;
   struct append_queue *next ;
   _Bool free ;
};
struct input {
   char **file_list ;
   countT bad_count ;
   countT line_number ;
   _Bool reset_at_next_file ;
   _Bool (*read_fn)(struct input * ) ;
   char *out_file_name ;
   char const   *in_file_name ;
   FILE *fp ;
   _Bool no_buffering ;
};
typedef long COST;
struct Word;
struct Word;
typedef struct Word WORD;
struct Word {
   char const   *text ;
   short length ;
   short space ;
   unsigned int paren : 1 ;
   unsigned int period : 1 ;
   unsigned int punct : 1 ;
   unsigned int final : 1 ;
   short line_length ;
   COST best_cost ;
   WORD *next_break ;
};
struct open_file {
   FILE *fp ;
   char *name ;
   struct open_file *link ;
   unsigned int temp : 1 ;
};
struct buffer {
   size_t allocated ;
   size_t length ;
   char *b ;
};
typedef unsigned long bitset_word_t;
typedef bitset_word_t bitset_t[256UL / (sizeof(bitset_word_t ) * 8UL)];
typedef bitset_word_t *re_bitset_ptr_t;
typedef bitset_word_t const   *re_const_bitset_ptr_t;
enum __anonenum_re_context_type_31 {
    INSIDE_WORD = 5,
    WORD_FIRST = 6,
    WORD_LAST = 9,
    INSIDE_NOTWORD = 10,
    LINE_FIRST = 16,
    LINE_LAST = 32,
    BUF_FIRST = 64,
    BUF_LAST = 128,
    WORD_DELIM = 256,
    NOT_WORD_DELIM = 512
} ;
typedef enum __anonenum_re_context_type_31 re_context_type;
struct __anonstruct_re_node_set_32 {
   int alloc ;
   int nelem ;
   int *elems ;
};
typedef struct __anonstruct_re_node_set_32 re_node_set;
enum __anonenum_re_token_type_t_33 {
    NON_TYPE = 0,
    CHARACTER = 1,
    END_OF_RE = 2,
    SIMPLE_BRACKET = 3,
    OP_BACK_REF = 4,
    OP_PERIOD = 5,
    OP_OPEN_SUBEXP = 8,
    OP_CLOSE_SUBEXP = 9,
    OP_ALT = 10,
    OP_DUP_ASTERISK = 11,
    ANCHOR = 12,
    CONCAT = 16,
    SUBEXP = 17,
    OP_DUP_PLUS = 18,
    OP_DUP_QUESTION = 19,
    OP_OPEN_BRACKET = 20,
    OP_CLOSE_BRACKET = 21,
    OP_CHARSET_RANGE = 22,
    OP_OPEN_DUP_NUM = 23,
    OP_CLOSE_DUP_NUM = 24,
    OP_NON_MATCH_LIST = 25,
    OP_OPEN_COLL_ELEM = 26,
    OP_CLOSE_COLL_ELEM = 27,
    OP_OPEN_EQUIV_CLASS = 28,
    OP_CLOSE_EQUIV_CLASS = 29,
    OP_OPEN_CHAR_CLASS = 30,
    OP_CLOSE_CHAR_CLASS = 31,
    OP_WORD = 32,
    OP_NOTWORD = 33,
    OP_SPACE = 34,
    OP_NOTSPACE = 35,
    BACK_SLASH = 36
} ;
typedef enum __anonenum_re_token_type_t_33 re_token_type_t;
union __anonunion_opr_35 {
   unsigned char c ;
   re_bitset_ptr_t sbcset ;
   int idx ;
   re_context_type ctx_type ;
};
struct __anonstruct_re_token_t_34 {
   union __anonunion_opr_35 opr ;
   re_token_type_t type : 8 ;
   unsigned int constraint : 10 ;
   unsigned int duplicated : 1 ;
   unsigned int opt_subexp : 1 ;
   unsigned int word_char : 1 ;
};
typedef struct __anonstruct_re_token_t_34 re_token_t;
struct re_string_t {
   unsigned char const   *raw_mbs ;
   unsigned char *mbs ;
   int raw_mbs_idx ;
   int valid_len ;
   int valid_raw_len ;
   int bufs_len ;
   int cur_idx ;
   int raw_len ;
   int len ;
   int raw_stop ;
   int stop ;
   unsigned int tip_context ;
   unsigned char *trans ;
   re_const_bitset_ptr_t word_char ;
   unsigned char icase ;
   unsigned char is_utf8 ;
   unsigned char map_notascii ;
   unsigned char mbs_allocated ;
   unsigned char offsets_needed ;
   unsigned char newline_anchor ;
   unsigned char word_ops_used ;
   int mb_cur_max ;
};
typedef struct re_string_t re_string_t;
struct re_dfa_t;
struct re_dfa_t;
typedef struct re_dfa_t re_dfa_t;
struct bin_tree_t {
   struct bin_tree_t *parent ;
   struct bin_tree_t *left ;
   struct bin_tree_t *right ;
   struct bin_tree_t *first ;
   struct bin_tree_t *next ;
   re_token_t token ;
   int node_idx ;
};
typedef struct bin_tree_t bin_tree_t;
struct bin_tree_storage_t {
   struct bin_tree_storage_t *next ;
   bin_tree_t data[(1024UL - sizeof(void *)) / sizeof(bin_tree_t )] ;
};
typedef struct bin_tree_storage_t bin_tree_storage_t;
struct re_dfastate_t {
   unsigned int hash ;
   re_node_set nodes ;
   re_node_set non_eps_nodes ;
   re_node_set inveclosure ;
   re_node_set *entrance_nodes ;
   struct re_dfastate_t **trtable ;
   struct re_dfastate_t **word_trtable ;
   unsigned int context : 4 ;
   unsigned int halt : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int has_backref : 1 ;
   unsigned int has_constraint : 1 ;
};
typedef struct re_dfastate_t re_dfastate_t;
struct re_state_table_entry {
   int num ;
   int alloc ;
   re_dfastate_t **array ;
};
struct __anonstruct_state_array_t_36 {
   int next_idx ;
   int alloc ;
   re_dfastate_t **array ;
};
typedef struct __anonstruct_state_array_t_36 state_array_t;
struct __anonstruct_re_sub_match_last_t_37 {
   int node ;
   int str_idx ;
   state_array_t path ;
};
typedef struct __anonstruct_re_sub_match_last_t_37 re_sub_match_last_t;
struct __anonstruct_re_sub_match_top_t_38 {
   int str_idx ;
   int node ;
   state_array_t *path ;
   int alasts ;
   int nlasts ;
   re_sub_match_last_t **lasts ;
};
typedef struct __anonstruct_re_sub_match_top_t_38 re_sub_match_top_t;
struct re_backref_cache_entry {
   int node ;
   int str_idx ;
   int subexp_from ;
   int subexp_to ;
   char more ;
   char unused ;
   unsigned short eps_reachable_subexps_map ;
};
struct __anonstruct_re_match_context_t_39 {
   re_string_t input ;
   re_dfa_t const   *dfa ;
   int eflags ;
   int match_last ;
   int last_node ;
   re_dfastate_t **state_log ;
   int state_log_top ;
   int nbkref_ents ;
   int abkref_ents ;
   struct re_backref_cache_entry *bkref_ents ;
   int max_mb_elem_len ;
   int nsub_tops ;
   int asub_tops ;
   re_sub_match_top_t **sub_tops ;
};
typedef struct __anonstruct_re_match_context_t_39 re_match_context_t;
struct __anonstruct_re_sift_context_t_40 {
   re_dfastate_t **sifted_states ;
   re_dfastate_t **limited_states ;
   int last_node ;
   int last_str_idx ;
   re_node_set limits ;
};
typedef struct __anonstruct_re_sift_context_t_40 re_sift_context_t;
struct re_fail_stack_ent_t {
   int idx ;
   int node ;
   regmatch_t *regs ;
   re_node_set eps_via_nodes ;
};
struct re_fail_stack_t {
   int num ;
   int alloc ;
   struct re_fail_stack_ent_t *stack ;
};
struct re_dfa_t {
   re_token_t *nodes ;
   size_t nodes_alloc ;
   size_t nodes_len ;
   int *nexts ;
   int *org_indices ;
   re_node_set *edests ;
   re_node_set *eclosures ;
   re_node_set *inveclosures ;
   struct re_state_table_entry *state_table ;
   re_dfastate_t *init_state ;
   re_dfastate_t *init_state_word ;
   re_dfastate_t *init_state_nl ;
   re_dfastate_t *init_state_begbuf ;
   bin_tree_t *str_tree ;
   bin_tree_storage_t *str_tree_storage ;
   re_bitset_ptr_t sb_char ;
   int str_tree_storage_idx ;
   unsigned int state_hash_mask ;
   int init_node ;
   int nbackref ;
   bitset_word_t used_bkref_map ;
   bitset_word_t completed_bkref_map ;
   unsigned int has_plural_match : 1 ;
   unsigned int has_mb_node : 1 ;
   unsigned int is_utf8 : 1 ;
   unsigned int map_notascii : 1 ;
   unsigned int word_ops_used : 1 ;
   int mb_cur_max ;
   bitset_t word_char ;
   reg_syntax_t syntax ;
   int *subexp_map ;
};
enum __anonenum_bracket_elem_type_41 {
    SB_CHAR = 0,
    MB_CHAR = 1,
    EQUIV_CLASS = 2,
    COLL_SYM = 3,
    CHAR_CLASS = 4
} ;
typedef enum __anonenum_bracket_elem_type_41 bracket_elem_type;
union __anonunion_opr_43 {
   unsigned char ch ;
   unsigned char *name ;
   wchar_t wch ;
};
struct __anonstruct_bracket_elem_t_42 {
   bracket_elem_type type ;
   union __anonunion_opr_43 opr ;
};
typedef struct __anonstruct_bracket_elem_t_42 bracket_elem_t;
struct dests_alloc {
   re_node_set dests_node[256] ;
   bitset_t dests_ch[256] ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-i3e4OvXU.i","")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
reg_syntax_t re_syntax_options  ;
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) ;
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
int re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
int re_search(struct re_pattern_buffer *bufp , char const   *string , int length ,
              int start , int range , struct re_registers *regs___0 ) ;
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
                char const   *string2 , int length2 , int start , int range , struct re_registers *regs___0 ,
                int stop ) ;
int re_match(struct re_pattern_buffer *bufp , char const   *string , int length ,
             int start , struct re_registers *regs___0 ) ;
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
               char const   *string2 , int length2 , int start , struct re_registers *regs___0 ,
               int stop ) ;
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs___0 ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) ;
int regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) ;
int regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
            size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
size_t regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                size_t errbuf_size ) ;
void regfree(regex_t *preg ) ;
extern int _IO_getc(_IO_FILE *__fp ) ;
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
extern int ungetc(int __c , FILE *__stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern long ftell(FILE *__stream ) ;
extern void rewind(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
void panic(char const   *str  , ...) ;
FILE *ck_fopen(char const   *name , char const   *mode , _Bool fail ) ;
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) ;
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) ;
void ck_fflush(FILE *stream ) ;
void ck_fclose(FILE *stream ) ;
size_t ck_getline(char **text , size_t *buflen , FILE *stream ) ;
FILE *ck_mkstemp(char **p_filename , char *tmpdir , char *base ) ;
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) ;
void *ck_malloc(size_t size ) ;
void *xmalloc(size_t size ) ;
void *ck_realloc(void *ptr , size_t size ) ;
char *ck_strdup(char const   *str ) ;
void *ck_memdup(void const   *buf , size_t len ) ;
void ck_free(void *ptr ) ;
struct buffer *init_buffer(void) ;
char *get_buffer(struct buffer *b___0 ) ;
size_t size_buffer(struct buffer *b___0 ) ;
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) ;
char *add1_buffer(struct buffer *b___0 , int c ) ;
void free_buffer(struct buffer *b___0 ) ;
char const   *myname  ;
void bad_prog(char const   *why ) ;
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) ;
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) ;
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) ;
void check_final_program(struct vector *program ) ;
void rewind_read_files(void) ;
void finish_program(struct vector *program ) ;
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) ;
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) ;
int process_files(struct vector *the_program___0 , char **argv ) ;
int main(int argc , char **argv ) ;
void fmt(char const   *line___0 , char const   *line_end , int max_length , FILE *output_file___0 ) ;
int extended_regexp_flags ;
_Bool unbuffered_output ;
_Bool no_default_output ;
_Bool separate_files ;
enum posixicity_types posixicity  ;
countT lcmd_out_line_len ;
char *in_place_extension ;
int mb_cur_max  ;
void initialize_mbcs(void) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
extern char *optarg ;
extern int optind ;
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
int extended_regexp_flags  =    0;
_Bool unbuffered_output  =    (_Bool)0;
_Bool no_default_output  =    (_Bool)0;
_Bool separate_files  =    (_Bool)0;
char *in_place_extension  =    (char *)((void *)0);
countT lcmd_out_line_len  =    (countT )70;
static struct vector *the_program  =    (struct vector *)((void *)0);
static void usage(int status ) ;
static void usage(int status ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;

  {
  if (status) {
    tmp = stdout;
  } else {
    tmp = stdout;
  }
  {
  out = tmp;
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\n",
          myname);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -n, --quiet, --silent\n                 suppress automatic printing of pattern space\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -e script, --expression=script\n                 add the script to the commands to be executed\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -f script-file, --file=script-file\n                 add the contents of script-file to the commands to be executed\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if extension supplied)\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -l N, --line-length=N\n                 specify the desired line-wrap length for the `l\' command\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  --posix\n                 disable all GNU extensions.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -r, --regexp-extended\n                 use extended regular expressions in the script.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -s, --separate\n                 consider files as separate rather than as a single continuous\n                 long stream.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -u, --unbuffered\n                 load minimal amounts of data from the input files and flush\n                 the output buffers more often\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --help     display this help and exit\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --version  output version information and exit\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\nIf no -e, --expression, -f, or --file option is given, then the first\nnon-option argument is taken as the sed script to interpret.  All\nremaining arguments are names of input files; if no input files are\nspecified, then the standard input is read.\n\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"E-mail bug reports to: %s .\nBe sure to include the word ``%s\'\' somewhere in the ``Subject:\'\' field.\n",
          "bonzini@gnu.org", "sed");
  ck_fclose((FILE *)((void *)0));
  exit(status);
  }
}
}
static struct option longopts[13]  = 
  {      {"regexp-extended", 0, (int *)((void *)0), 'r'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"in-place", 2, (int *)((void *)0), 'i'}, 
        {"line-length", 1, (int *)((void *)0), 'l'}, 
        {"quiet", 0, (int *)((void *)0), 'n'}, 
        {"posix", 0, (int *)((void *)0), 'p'}, 
        {"silent", 0, (int *)((void *)0), 'n'}, 
        {"separate", 0, (int *)((void *)0), 's'}, 
        {"unbuffered", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
int main(int argc , char **argv ) 
{ 
  int opt ;
  int return_code ;
  char const   *cols ;
  char *tmp ;
  char *tmp___0 ;
  countT t ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *arg ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
  {
  tmp = getenv("COLS");
  cols = (char const   *)tmp;
  initialize_mbcs();
  tmp___0 = getenv("POSIXLY_CORRECT");
  }
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    posixicity = (enum posixicity_types )1;
  } else {
    posixicity = (enum posixicity_types )0;
  }
  if (cols) {
    {
    tmp___1 = atoi(cols);
    t = (countT )tmp___1;
    }
    if (t > 1UL) {
      lcmd_out_line_len = t - 1UL;
    }
  }
  myname = "Executable";
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    opt = getopt_long(argc, (char * const  *)argv, "snrue:f:l:i::V:", (struct option  const  *)(longopts),
                      (int *)((void *)0));
    }
    if (! (opt != -1)) {
      goto while_break;
    }
    {
    if (opt == 110) {
      goto case_110;
    }
    if (opt == 101) {
      goto case_101;
    }
    if (opt == 102) {
      goto case_102;
    }
    if (opt == 105) {
      goto case_105;
    }
    if (opt == 108) {
      goto case_108;
    }
    if (opt == 112) {
      goto case_112;
    }
    if (opt == 114) {
      goto case_114;
    }
    if (opt == 115) {
      goto case_115;
    }
    if (opt == 117) {
      goto case_117;
    }
    if (opt == 118) {
      goto case_118;
    }
    if (opt == 104) {
      goto case_104;
    }
    goto switch_default;
    case_110: /* CIL Label */ 
    no_default_output = (_Bool)1;
    goto switch_break;
    case_101: /* CIL Label */ 
    {
    tmp___2 = strlen((char const   *)optarg);
    the_program = compile_string(the_program, optarg, tmp___2);
    }
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    the_program = compile_file(the_program, (char const   *)optarg);
    }
    goto switch_break;
    case_105: /* CIL Label */ 
    separate_files = (_Bool)1;
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      {
      in_place_extension = ck_strdup("*");
      }
    } else {
      {
      tmp___5 = index((char const   *)optarg, '*');
      }
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
        in_place_extension = ck_strdup((char const   *)optarg);
        }
      } else {
        {
        tmp___3 = strlen((char const   *)optarg);
        tmp___4 = ck_malloc((tmp___3 + 2UL) * sizeof(char ));
        in_place_extension = (char *)tmp___4;
        *(in_place_extension + 0) = (char )'*';
        strcpy((char * __restrict  )(in_place_extension + 1), (char const   * __restrict  )optarg);
        }
      }
    }
    goto switch_break;
    case_108: /* CIL Label */ 
    {
    tmp___6 = atoi((char const   *)optarg);
    lcmd_out_line_len = (countT )tmp___6;
    }
    goto switch_break;
    case_112: /* CIL Label */ 
    posixicity = (enum posixicity_types )2;
    goto switch_break;
    case_114: /* CIL Label */ 
    if (extended_regexp_flags) {
      {
      usage(4);
      }
    }
    extended_regexp_flags = 1;
    goto switch_break;
    case_115: /* CIL Label */ 
    separate_files = (_Bool)1;
    goto switch_break;
    case_117: /* CIL Label */ 
    unbuffered_output = (_Bool)1;
    goto switch_break;
    case_118: /* CIL Label */ 
    {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"GNU sed version %s\n",
            "sir-default");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,\nto the extent permitted by law.\n",
            "Copyright (C) 2003 Free Software Foundation, Inc.");
    ck_fclose((FILE *)((void *)0));
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
    usage(0);
    }
    switch_default: /* CIL Label */ 
    {
    usage(4);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (! the_program) {
    if (optind < argc) {
      {
      tmp___7 = optind;
      optind ++;
      arg = *(argv + tmp___7);
      tmp___8 = strlen((char const   *)arg);
      the_program = compile_string(the_program, arg, tmp___8);
      }
    } else {
      {
      usage(4);
      }
    }
  }
  {
  check_final_program(the_program);
  return_code = process_files(the_program, argv + optind);
  finish_program(the_program);
  ck_fclose((FILE *)((void *)0));
  }
  return (return_code);
}
}
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
extern void _obstack_newchunk(struct obstack * , int  ) ;
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
FILE *my_stdin  ;
FILE *my_stdout  ;
FILE *my_stderr  ;
struct special_files special_files[4]  = {      {{(char *)"/dev/stdin", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdin}, 
        {{(char *)"/dev/stdout", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdout}, 
        {{(char *)"/dev/stdout", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stderr}, 
        {{(char *)((void *)0), (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      (FILE **)((void *)0)}};
static struct prog_info prog  ;
static struct error_info cur_input  ;
static struct sed_label *jumps  =    (struct sed_label *)((void *)0);
static struct sed_label *labels  =    (struct sed_label *)((void *)0);
static _Bool first_script  =    (_Bool)1;
static struct buffer *pending_text  =    (struct buffer *)((void *)0);
static struct text_buf *old_text_buf  =    (struct text_buf *)((void *)0);
static struct sed_label *blocks  =    (struct sed_label *)((void *)0);
static struct obstack obs  ;
static char const   errors[743]  = 
  {      (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'!',      (char const   )'\'', 
        (char const   )'s',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )',',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'+',      (char const   )'N', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'~',      (char const   )'N',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'r',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'`',      (char const   )'{', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )' ',      (char const   )'c', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'f', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )' ',      (char const   )'a', 
        (char const   )'f',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'a',      (char const   )'\'', 
        (char const   )',',      (char const   )' ',      (char const   )'`',      (char const   )'c', 
        (char const   )'\'',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'i',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )' ',      (char const   )'d',      (char const   )'o',      (char const   )'e', 
        (char const   )'s',      (char const   )'n',      (char const   )'\'',      (char const   )'t', 
        (char const   )' ',      (char const   )'w',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'e',      (char const   )'s',      (char const   )'\000', 
        (char const   )':',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'e',      (char const   )'s',      (char const   )'n',      (char const   )'\'', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'n',      (char const   )'\'',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'c',      (char const   )'c',      (char const   )'e', 
        (char const   )'p',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'m',      (char const   )'i',      (char const   )'s', 
        (char const   )'s',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'`', 
        (char const   )'s',      (char const   )'\'',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'`',      (char const   )'y',      (char const   )'\'',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'p',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'g',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'`',      (char const   )'s',      (char const   )'\'', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )' ',      (char const   )'z',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )'\000',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'`',      (char const   )'y', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'l',      (char const   )'e',      (char const   )'n',      (char const   )'g', 
        (char const   )'t',      (char const   )'h',      (char const   )'s',      (char const   )'\000', 
        (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'i', 
        (char const   )'m',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'l',      (char const   )'e',      (char const   )'-', 
        (char const   )'b',      (char const   )'y',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'a',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000',      (char const   )'e', 
        (char const   )'x',      (char const   )'p',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'w',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )' ',      (char const   )'0', 
        (char const   )'\000',      (char const   )'u',      (char const   )'n',      (char const   )'k', 
        (char const   )'n',      (char const   )'o',      (char const   )'w',      (char const   )'n', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )':',      (char const   )' ',      (char const   )'`',      (char const   )'%', 
        (char const   )'c',      (char const   )'\'',      (char const   )'\000'};
static struct output *file_read  =    (struct output *)((void *)0);
static struct output *file_write  =    (struct output *)((void *)0);
void bad_command(char ch ) 
{ 
  char const   *msg ;
  char *unknown_cmd ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
  msg = (((((((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0");
  tmp = strlen(msg);
  tmp___0 = xmalloc(tmp);
  unknown_cmd = (char *)tmp___0;
  sprintf((char * __restrict  )unknown_cmd, (char const   * __restrict  )msg, (int )ch);
  bad_prog((char const   *)unknown_cmd);
  }
  return;
}
}
void bad_prog(char const   *why ) 
{ 


  {
  if (cur_input.name) {
    {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: file %s line %lu: %s\n",
            myname, cur_input.name, cur_input.line, why);
    }
  } else {
    {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: -e expression #%lu, char %lu: %s\n",
            myname, cur_input.string_expr_count, (unsigned long )(prog.cur - prog.base),
            why);
    }
  }
  {
  exit(1);
  }
}
}
static int inchar(void) ;
static int inchar(void) 
{ 
  int ch ;
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
  ch = -1;
  if (prog.cur) {
    if ((unsigned long )prog.cur < (unsigned long )prog.end) {
      tmp = prog.cur;
      (prog.cur) ++;
      ch = (int )*tmp;
    }
  } else { //Added block
  if (prog.file) {
    {
    tmp___0 = feof(prog.file);
    }
    if (! tmp___0) {
      {
      ch = _IO_getc(prog.file);
      }
    }
  }
  }
  if (ch == 10) {
    (cur_input.line) ++;
  }
  return (ch);
}
}
static void savchar(int ch ) ;
static void savchar(int ch ) 
{ 


  {
  if (ch == -1) {
    return;
  }
  if (ch == 10) {
    if (cur_input.line > 0UL) {
      (cur_input.line) --;
    }
  }
  if (prog.cur) {
    if ((unsigned long )prog.cur <= (unsigned long )prog.base) {
      {
      panic("Called savchar() with unexpected pushback (%x)", (int )((unsigned char )ch));
      }
    } else {
      (prog.cur) --;
      if ((int const   )*(prog.cur) != (int const   )ch) {
        {
        panic("Called savchar() with unexpected pushback (%x)", (int )((unsigned char )ch));
        }
      }
    }
  } else {
    {
    ungetc(ch, prog.file);
    }
  }
  return;
}
}
static int in_nonblank(void) ;
static int in_nonblank(void) 
{ 
  int ch ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    ch = inchar();
    }
    if (! (ch == 32)) {
      if (! (ch == 9)) {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (ch);
}
}
static countT in_integer(int ch ) ;
static countT in_integer(int ch ) 
{ 
  countT num ;
  unsigned short const   **tmp ;

  {
  num = (countT )0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp + ch) & 2048)) {
      goto while_break;
    }
    {
    num = (num * 10UL + (countT )ch) - 48UL;
    ch = inchar();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  savchar(ch);
  }
  return (num);
}
}
static int add_then_next(struct buffer *b___0 , int ch ) ;
static int add_then_next(struct buffer *b___0 , int ch ) 
{ 
  int tmp ;

  {
  {
  add1_buffer(b___0, ch);
  tmp = inchar();
  }
  return (tmp);
}
}
static char *convert_number(char *result , char *buf , char const   *bufend , int base ,
                            int maxdigits , int default_char ) ;
static char *convert_number(char *result , char *buf , char const   *bufend , int base ,
                            int maxdigits , int default_char ) 
{ 
  int n ;
  char *p ;
  int d ;
  int tmp ;

  {
  n = 0;
  p = buf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )p < (unsigned long )bufend) {
      tmp = maxdigits;
      maxdigits --;
      if (! (tmp > 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    d = -1;
    {
    if ((int )*p == 48) {
      goto case_48;
    }
    if ((int )*p == 49) {
      goto case_49;
    }
    if ((int )*p == 50) {
      goto case_50;
    }
    if ((int )*p == 51) {
      goto case_51;
    }
    if ((int )*p == 52) {
      goto case_52;
    }
    if ((int )*p == 53) {
      goto case_53;
    }
    if ((int )*p == 54) {
      goto case_54;
    }
    if ((int )*p == 55) {
      goto case_55;
    }
    if ((int )*p == 56) {
      goto case_56;
    }
    if ((int )*p == 57) {
      goto case_57;
    }
    if ((int )*p == 65) {
      goto case_65;
    }
    if ((int )*p == 97) {
      goto case_65;
    }
    if ((int )*p == 66) {
      goto case_66;
    }
    if ((int )*p == 98) {
      goto case_66;
    }
    if ((int )*p == 67) {
      goto case_67;
    }
    if ((int )*p == 99) {
      goto case_67;
    }
    if ((int )*p == 68) {
      goto case_68;
    }
    if ((int )*p == 100) {
      goto case_68;
    }
    if ((int )*p == 69) {
      goto case_69;
    }
    if ((int )*p == 101) {
      goto case_69;
    }
    if ((int )*p == 70) {
      goto case_70;
    }
    if ((int )*p == 102) {
      goto case_70;
    }
    goto switch_break;
    case_48: /* CIL Label */ 
    d = 0;
    goto switch_break;
    case_49: /* CIL Label */ 
    d = 1;
    goto switch_break;
    case_50: /* CIL Label */ 
    d = 2;
    goto switch_break;
    case_51: /* CIL Label */ 
    d = 3;
    goto switch_break;
    case_52: /* CIL Label */ 
    d = 4;
    goto switch_break;
    case_53: /* CIL Label */ 
    d = 5;
    goto switch_break;
    case_54: /* CIL Label */ 
    d = 6;
    goto switch_break;
    case_55: /* CIL Label */ 
    d = 7;
    goto switch_break;
    case_56: /* CIL Label */ 
    d = 8;
    goto switch_break;
    case_57: /* CIL Label */ 
    d = 9;
    goto switch_break;
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
    d = 10;
    goto switch_break;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
    d = 11;
    goto switch_break;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
    d = 12;
    goto switch_break;
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    d = 13;
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
    d = 14;
    goto switch_break;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
    d = 15;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    if (d < 0) {
      goto while_break;
    } else { //Added block
    if (base <= d) {
      goto while_break;
    }
    }
    n = n * base + d;
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )p == (unsigned long )buf) {
    *result = (char )default_char;
  } else {
    *result = (char )n;
  }
  return (p);
}
}
static struct buffer *read_filename(void) ;
static struct buffer *read_filename(void) 
{ 
  struct buffer *b___0 ;
  int ch ;

  {
  {
  b___0 = init_buffer();
  ch = in_nonblank();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (ch != -1) {
      if (! (ch != 10)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  add1_buffer(b___0, '\000');
  }
  return (b___0);
}
}
static struct output *get_openfile(struct output **file_ptrs , char *mode , _Bool fail ) ;
static struct output *get_openfile(struct output **file_ptrs , char *mode , _Bool fail ) 
{ 
  struct buffer *b___0 ;
  char *file_name ;
  struct output *p ;
  int tmp ;
  struct special_files *special ;
  int tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
  {
  b___0 = read_filename();
  file_name = get_buffer(b___0);
  p = *file_ptrs;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    {
    tmp = strcmp((char const   *)p->name, (char const   *)file_name);
    }
    if (tmp == 0) {
      goto while_break;
    }
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned int )posixicity == 0U) {
    special = special_files;
    my_stdin = stdin;
    my_stdout = stdout;
    my_stderr = stdout;
    special = special_files;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! special->outf.name) {
        goto while_break___0;
      }
      {
      tmp___0 = strcmp((char const   *)special->outf.name, (char const   *)file_name);
      }
      if (tmp___0 == 0) {
        {
        special->outf.fp = *(special->pfp);
        free_buffer(b___0);
        }
        return (& special->outf);
      }
      special ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  if (! p) {
    __h = & obs;
    __o = __h;
    __len = (int )sizeof(struct output );
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
      _obstack_newchunk(__o, __len);
      }
    }
    __o->next_free += __len;
    __o1 = __h;
    value = (void *)__o1->object_base;
    if ((unsigned long )__o1->next_free == (unsigned long )value) {
      __o1->maybe_empty_object = 1U;
    }
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
      __o1->next_free = __o1->chunk_limit;
    }
    {
    __o1->object_base = __o1->next_free;
    p = (struct output *)value;
    p->name = ck_strdup((char const   *)file_name);
    p->fp = ck_fopen((char const   *)p->name, (char const   *)mode, fail);
    p->missing_newline = (_Bool)0;
    p->link = *file_ptrs;
    *file_ptrs = p;
    }
  }
  {
  free_buffer(b___0);
  }
  return (p);
}
}
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) ;
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) 
{ 
  struct sed_cmd *cmd ;
  struct vector *v ;
  void *tmp ;

  {
  v = *vectorp;
  if (v->v_length == v->v_allocated) {
    {
    v->v_allocated += 40UL;
    tmp = ck_realloc((void *)v->v, v->v_allocated * sizeof(struct sed_cmd ));
    v->v = (struct sed_cmd *)tmp;
    }
  }
  cmd = v->v + v->v_length;
  cmd->a1 = (struct addr *)((void *)0);
  cmd->a2 = (struct addr *)((void *)0);
  cmd->range_state = (enum addr_state )0;
  cmd->addr_bang = (char)0;
  cmd->cmd = (char )'\000';
  *vectorp = v;
  return (cmd);
}
}
static int snarf_char_class(struct buffer *b___0 , mbstate_t *cur_stat ) ;
static int snarf_char_class(struct buffer *b___0 , mbstate_t *cur_stat ) 
{ 
  int ch ;
  int state ;
  int delim ;
  _Bool pending_mb ;

  {
  {
  state = 0;
  pending_mb = (_Bool)0;
  ch = inchar();
  }
  if (ch == 94) {
    {
    ch = add_then_next(b___0, ch);
    }
  }
  if (ch == 93) {
    {
    ch = add_then_next(b___0, ch);
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    pending_mb = (_Bool)0;
    {
    if (ch == -1) {
      goto case_neg_1;
    }
    if (ch == 10) {
      goto case_neg_1;
    }
    if (ch == 46) {
      goto case_46;
    }
    if (ch == 58) {
      goto case_46;
    }
    if (ch == 61) {
      goto case_46;
    }
    if (ch == 91) {
      goto case_91;
    }
    if (ch == 93) {
      goto case_93;
    }
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    case_10: /* CIL Label */ 
    return (ch);
    case_46: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_61: /* CIL Label */ 
    if (pending_mb) {
      goto __Cont;
    }
    if (state == 1) {
      delim = ch;
      state ++;
    } else { //Added block
    if (ch == delim) {
      if (state == 2) {
        state ++;
      } else {
        goto switch_break;
      }
    } else {
      goto switch_break;
    }
    }
    goto __Cont;
    case_91: /* CIL Label */ 
    if (pending_mb) {
      goto __Cont;
    }
    state ++;
    goto __Cont;
    case_93: /* CIL Label */ 
    if (pending_mb) {
      goto __Cont;
    }
    if (state == 0) {
      return (ch);
    } else { //Added block
    if (state == 1) {
      return (ch);
    } else { //Added block
    if (state == 3) {
      state = 0;
    }
    }
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    state &= -2;
    __Cont: 
    {
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
static struct buffer *match_slash(int slash , _Bool regex ) ;
static struct buffer *match_slash(int slash , _Bool regex ) 
{ 
  struct buffer *b___0 ;
  int ch ;
  _Bool pending_mb ;
  mbstate_t cur_stat ;

  {
  {
  pending_mb = (_Bool)0;
  memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
  memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
  b___0 = init_buffer();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    ch = inchar();
    }
    if (ch != -1) {
      if (! (ch != 10)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    pending_mb = (_Bool)0;
    pending_mb = (_Bool)0;
    if (! pending_mb) {
      if (ch == slash) {
        return (b___0);
      } else { //Added block
      if (ch == 92) {
        {
        ch = inchar();
        }
        if (ch == -1) {
          goto while_break;
        } else { //Added block
        if (ch == 110) {
          if (regex) {
            ch = '\n';
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if (ch != 10) {
          if (ch != slash) {
            {
            add1_buffer(b___0, '\\');
            }
          }
        }
        }
        }
      } else { //Added block
      if (ch == 91) {
        if (regex) {
          {
          add1_buffer(b___0, ch);
          ch = snarf_char_class(b___0, & cur_stat);
          }
          if (ch != 93) {
            goto while_break;
          }
        }
      }
      }
      }
    }
    {
    add1_buffer(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (ch == 10) {
    {
    savchar(ch);
    }
  }
  {
  free_buffer(b___0);
  }
  return ((struct buffer *)((void *)0));
}
}
static int mark_subst_opts(struct subst *cmd ) ;
static int mark_subst_opts(struct subst *cmd ) 
{ 
  int flags ;
  int ch ;
  int tmp ;

  {
  flags = 0;
  cmd->global = 0U;
  cmd->print = 0U;
  cmd->eval = 0U;
  cmd->numb = (countT )0;
  cmd->outf = (struct output *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    ch = in_nonblank();
    }
    {
    if (ch == 105) {
      goto case_105;
    }
    if (ch == 73) {
      goto case_105;
    }
    if (ch == 109) {
      goto case_109;
    }
    if (ch == 77) {
      goto case_109;
    }
    if (ch == 101) {
      goto case_101;
    }
    if (ch == 112) {
      goto case_112;
    }
    if (ch == 103) {
      goto case_103;
    }
    if (ch == 119) {
      goto case_119;
    }
    if (ch == 48) {
      goto case_48;
    }
    if (ch == 49) {
      goto case_48;
    }
    if (ch == 50) {
      goto case_48;
    }
    if (ch == 51) {
      goto case_48;
    }
    if (ch == 52) {
      goto case_48;
    }
    if (ch == 53) {
      goto case_48;
    }
    if (ch == 54) {
      goto case_48;
    }
    if (ch == 55) {
      goto case_48;
    }
    if (ch == 56) {
      goto case_48;
    }
    if (ch == 57) {
      goto case_48;
    }
    if (ch == 125) {
      goto case_125;
    }
    if (ch == 35) {
      goto case_125;
    }
    if (ch == -1) {
      goto case_neg_1;
    }
    if (ch == 10) {
      goto case_neg_1;
    }
    if (ch == 59) {
      goto case_neg_1;
    }
    if (ch == 13) {
      goto case_13;
    }
    goto switch_default;
    case_105: /* CIL Label */ 
    case_73: /* CIL Label */ 
    flags |= 1 << 1;
    goto switch_break;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    flags |= (1 << 1) << 1;
    goto switch_break;
    case_101: /* CIL Label */ 
    cmd->eval = 1U;
    goto switch_break;
    case_112: /* CIL Label */ 
    if (cmd->print) {
      {
      bad_prog((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'"));
      }
    }
    cmd->print |= (unsigned int )(1 << cmd->eval);
    goto switch_break;
    case_103: /* CIL Label */ 
    if (cmd->global) {
      {
      bad_prog(((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command"));
      }
    }
    cmd->global = 1U;
    goto switch_break;
    case_119: /* CIL Label */ 
    {
    cmd->outf = get_openfile(& file_write, (char *)"w", (_Bool)1);
    }
    return (flags);
    case_48: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_57: /* CIL Label */ 
    if (cmd->numb) {
      {
      bad_prog((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command"));
      }
    }
    {
    cmd->numb = in_integer(ch);
    }
    if (! cmd->numb) {
      {
      bad_prog(((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command"));
      }
    }
    goto switch_break;
    case_125: /* CIL Label */ 
    case_35: /* CIL Label */ 
    {
    savchar(ch);
    }
    case_neg_1: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_59: /* CIL Label */ 
    return (flags);
    case_13: /* CIL Label */ 
    {
    tmp = inchar();
    }
    if (tmp == 10) {
      return (flags);
    }
    switch_default: /* CIL Label */ 
    {
    bad_prog(((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
static char *read_label(void) ;
static char *read_label(void) 
{ 
  struct buffer *b___0 ;
  int ch ;
  char *ret ;
  char *tmp ;

  {
  {
  b___0 = init_buffer();
  ch = in_nonblank();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (ch != -1) {
      if (ch != 10) {
        if (ch == 32) {
          goto while_break;
        } else { //Added block
        if (ch == 9) {
          goto while_break;
        } else { //Added block
        if (ch != 59) {
          if (ch != 125) {
            if (! (ch != 35)) {
              goto while_break;
            }
          } else {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  savchar(ch);
  add1_buffer(b___0, '\000');
  tmp = get_buffer(b___0);
  ret = ck_strdup((char const   *)tmp);
  free_buffer(b___0);
  }
  return (ret);
}
}
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) ;
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) 
{ 
  struct sed_label *ret ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
  __h = & obs;
  __o = __h;
  __len = (int )sizeof(struct sed_label );
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
    _obstack_newchunk(__o, __len);
    }
  }
  __o->next_free += __len;
  __o1 = __h;
  value = (void *)__o1->object_base;
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
    __o1->maybe_empty_object = 1U;
  }
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
    __o1->next_free = __o1->chunk_limit;
  }
  __o1->object_base = __o1->next_free;
  ret = (struct sed_label *)value;
  ret->v_index = idx;
  ret->name = name;
  if (err_info) {
    {
    memmove((void * __restrict  )(& ret->err_info), (void const   * __restrict  )err_info,
            sizeof(ret->err_info));
    }
  }
  ret->next = list;
  return (ret);
}
}
static struct sed_label *release_label(struct sed_label *list_head ) ;
static struct sed_label *release_label(struct sed_label *list_head ) 
{ 
  struct sed_label *ret ;

  {
  if (! list_head) {
    return ((struct sed_label *)((void *)0));
  }
  {
  ret = list_head->next;
  ck_free((void *)list_head->name);
  }
  return (ret);
}
}
static struct replacement *new_replacement(char *text , size_t length , enum replacement_types type ) ;
static struct replacement *new_replacement(char *text , size_t length , enum replacement_types type ) 
{ 
  struct replacement *r ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
  __h = & obs;
  __o = __h;
  __len = (int )sizeof(struct replacement );
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
    _obstack_newchunk(__o, __len);
    }
  }
  __o->next_free += __len;
  __o1 = __h;
  value = (void *)__o1->object_base;
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
    __o1->maybe_empty_object = 1U;
  }
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
    __o1->next_free = __o1->chunk_limit;
  }
  __o1->object_base = __o1->next_free;
  r = (struct replacement *)value;
  r->prefix = text;
  r->prefix_length = length;
  r->subst_id = -1;
  r->repl_type = type;
  return (r);
}
}
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) ;
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) 
{ 
  char *base ;
  char *p ;
  char *text_end ;
  enum replacement_types repl_type ;
  enum replacement_types save_type ;
  struct replacement root ;
  struct replacement *tail ;
  void *tmp ;
  struct replacement *tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct replacement *tmp___2 ;
  struct replacement *tmp___3 ;

  {
  {
  repl_type = (enum replacement_types )0;
  save_type = (enum replacement_types )0;
  sub->max_id = 0U;
  tmp = ck_memdup((void const   *)text, length * sizeof(char ));
  base = (char *)tmp;
  length = normalize_text(base, length, (enum text_types )1);
  text_end = base + length;
  tail = & root;
  p = base;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p < (unsigned long )text_end)) {
      goto while_break;
    }
    if ((int )*p == 92) {
      {
      tmp___0 = new_replacement(base, (size_t )(p - base), repl_type);
      tail->next = tmp___0;
      tail = tmp___0;
      repl_type = save_type;
      p ++;
      }
      if ((unsigned long )p < (unsigned long )text_end) {
        if ((unsigned int )posixicity != 2U) {
          goto _L;
        } else {
          {
          tmp___1 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___1 + (int )*p) & 2048) {
            _L: 
            {
            if ((int )*p == 48) {
              goto case_48;
            }
            if ((int )*p == 49) {
              goto case_48;
            }
            if ((int )*p == 50) {
              goto case_48;
            }
            if ((int )*p == 51) {
              goto case_48;
            }
            if ((int )*p == 52) {
              goto case_48;
            }
            if ((int )*p == 53) {
              goto case_48;
            }
            if ((int )*p == 54) {
              goto case_48;
            }
            if ((int )*p == 55) {
              goto case_48;
            }
            if ((int )*p == 56) {
              goto case_48;
            }
            if ((int )*p == 57) {
              goto case_48;
            }
            if ((int )*p == 76) {
              goto case_76;
            }
            if ((int )*p == 85) {
              goto case_85;
            }
            if ((int )*p == 69) {
              goto case_69;
            }
            if ((int )*p == 108) {
              goto case_108;
            }
            if ((int )*p == 117) {
              goto case_117;
            }
            goto switch_default;
            case_48: /* CIL Label */ 
            case_49: /* CIL Label */ 
            case_50: /* CIL Label */ 
            case_51: /* CIL Label */ 
            case_52: /* CIL Label */ 
            case_53: /* CIL Label */ 
            case_54: /* CIL Label */ 
            case_55: /* CIL Label */ 
            case_56: /* CIL Label */ 
            case_57: /* CIL Label */ 
            tail->subst_id = (int )*p - 48;
            if (sub->max_id < (unsigned int )tail->subst_id) {
              sub->max_id = (unsigned int )tail->subst_id;
            }
            goto switch_break;
            case_76: /* CIL Label */ 
            repl_type = (enum replacement_types )2;
            save_type = (enum replacement_types )2;
            goto switch_break;
            case_85: /* CIL Label */ 
            repl_type = (enum replacement_types )1;
            save_type = (enum replacement_types )1;
            goto switch_break;
            case_69: /* CIL Label */ 
            repl_type = (enum replacement_types )0;
            save_type = (enum replacement_types )0;
            goto switch_break;
            case_108: /* CIL Label */ 
            save_type = repl_type;
            repl_type = (enum replacement_types )((unsigned int )repl_type | 8U);
            goto switch_break;
            case_117: /* CIL Label */ 
            save_type = repl_type;
            repl_type = (enum replacement_types )((unsigned int )repl_type | 4U);
            goto switch_break;
            switch_default: /* CIL Label */ 
            *(p + -1) = *p;
            (tail->prefix_length) ++;
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
      base = p + 1;
    } else { //Added block
    if ((int )*p == 38) {
      {
      tmp___2 = new_replacement(base, (size_t )(p - base), repl_type);
      tail->next = tmp___2;
      tail = tmp___2;
      repl_type = save_type;
      tail->subst_id = 0;
      base = p + 1;
      }
    }
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )base < (unsigned long )text_end) {
    {
    tmp___3 = new_replacement(base, (size_t )(text_end - base), repl_type);
    tail->next = tmp___3;
    tail = tmp___3;
    }
  }
  tail->next = (struct replacement *)((void *)0);
  sub->replacement = root.next;
  return;
}
}
static void read_text(struct text_buf *buf , int leadin_ch ) ;
static void read_text(struct text_buf *buf , int leadin_ch ) 
{ 
  int ch ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  if (buf) {
    if (pending_text) {
      {
      free_buffer(pending_text);
      }
    }
    {
    pending_text = init_buffer();
    buf->text = (char *)((void *)0);
    buf->text_length = (size_t )0;
    old_text_buf = buf;
    }
  }
  if (leadin_ch == -1) {
    return;
  }
  if (leadin_ch != 10) {
    {
    add1_buffer(pending_text, leadin_ch);
    }
  }
  {
  ch = inchar();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (ch != -1) {
      if (! (ch != 10)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (ch == 92) {
      {
      ch = inchar();
      }
      if (ch != -1) {
        {
        add1_buffer(pending_text, '\\');
        }
      }
    }
    if (ch == -1) {
      {
      add1_buffer(pending_text, '\n');
      }
      return;
    }
    {
    ch = add_then_next(pending_text, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  add1_buffer(pending_text, '\n');
  }
  if (! buf) {
    buf = old_text_buf;
  }
  {
  tmp = size_buffer(pending_text);
  tmp___0 = get_buffer(pending_text);
  buf->text_length = normalize_text(tmp___0, tmp, (enum text_types )0);
  tmp___1 = get_buffer(pending_text);
  tmp___2 = ck_memdup((void const   *)tmp___1, buf->text_length * sizeof(char ));
  buf->text = (char *)tmp___2;
  free_buffer(pending_text);
  pending_text = (struct buffer *)((void *)0);
  }
  return;
}
}
static _Bool compile_address(struct addr *addr , int ch ) ;
static _Bool compile_address(struct addr *addr , int ch ) 
{ 
  int flags ;
  struct buffer *b___0 ;
  countT step ;
  int tmp ;
  countT tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  addr->addr_type = (enum addr_types )0;
  addr->addr_step = (countT )0;
  addr->addr_number = ~ ((countT )0);
  addr->addr_regex = (struct regex *)((void *)0);
  if (ch == 47) {
    goto _L___0;
  } else { //Added block
  if (ch == 92) {
    _L___0: 
    flags = 0;
    addr->addr_type = (enum addr_types )1;
    if (ch == 92) {
      {
      ch = inchar();
      }
    }
    {
    b___0 = match_slash(ch, (_Bool)1);
    }
    if (! b___0) {
      {
      bad_prog((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address"));
      }
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      ch = in_nonblank();
      }
      {
      if (ch == 73) {
        goto case_73;
      }
      if (ch == 77) {
        goto case_77;
      }
      goto switch_default;
      case_73: /* CIL Label */ 
      flags |= 1 << 1;
      goto switch_break;
      case_77: /* CIL Label */ 
      flags |= (1 << 1) << 1;
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      savchar(ch);
      addr->addr_regex = compile_regex(b___0, flags, 0);
      free_buffer(b___0);
      }
      return ((_Bool)1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    tmp___2 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___2 + ch) & 2048) {
      {
      addr->addr_number = in_integer(ch);
      addr->addr_type = (enum addr_types )2;
      ch = in_nonblank();
      }
      if (ch != 126) {
        {
        savchar(ch);
        }
      } else {
        {
        tmp = in_nonblank();
        tmp___0 = in_integer(tmp);
        step = tmp___0;
        }
        if (step > 0UL) {
          addr->addr_step = step;
          addr->addr_type = (enum addr_types )3;
        }
      }
    } else { //Added block
    if (ch == 43) {
      goto _L;
    } else { //Added block
    if (ch == 126) {
      _L: 
      {
      tmp___1 = in_nonblank();
      addr->addr_step = in_integer(tmp___1);
      }
      if (! (addr->addr_step == 0UL)) {
        if (ch == 43) {
          addr->addr_type = (enum addr_types )4;
        } else {
          addr->addr_type = (enum addr_types )5;
        }
      }
    } else { //Added block
    if (ch == 36) {
      addr->addr_type = (enum addr_types )6;
    } else {
      return ((_Bool)0);
    }
    }
    }
    }
  }
  }
  return ((_Bool)1);
}
}
static struct vector *compile_program(struct vector *vector ) ;
static struct vector *compile_program(struct vector *vector ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct buffer *b___0 ;
  int ch ;
  void *tmp ;
  struct addr a ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  void *tmp___4 ;
  _Bool tmp___5 ;
  long tmp___6 ;
  char *version ;
  char *tmp___7 ;
  char *compared_version ;
  char *tmp___8 ;
  char *tmp___9 ;
  countT tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  struct output *tmp___13 ;
  struct buffer *b2 ;
  int flags ;
  int slash ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;
  size_t tmp___14 ;
  char *tmp___15 ;
  size_t len ;
  size_t dest_len ;
  int slash___0 ;
  struct buffer *b2___0 ;
  char *src_buf ;
  char *dest_buf ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  int i ;
  int j ;
  int idx ;
  int src_char_num ;
  size_t *src_lens ;
  void *tmp___18 ;
  char **trans_pairs ;
  size_t mbclen ;
  mbstate_t cur_stat ;
  int tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  char *translate ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *value___0 ;
  unsigned char *ustring ;
  unsigned char *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;

  {
  if (! vector) {
    {
    tmp = ck_malloc(sizeof(struct vector ));
    vector = (struct vector *)tmp;
    vector->v = (struct sed_cmd *)((void *)0);
    vector->v_allocated = (size_t )0;
    vector->v_length = (size_t )0;
    _obstack_begin(& obs, 0, 0, (void *(*)(long  ))(& ck_malloc), & ck_free);
    }
  }
  if (pending_text) {
    {
    read_text((struct text_buf *)((void *)0), '\n');
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      ch = inchar();
      }
      if (! (ch == 59)) {
        {
        tmp___0 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___0 + ch) & 8192)) {
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (ch == -1) {
      goto while_break;
    }
    {
    cur_cmd = next_cmd_entry(& vector);
    tmp___5 = compile_address(& a, ch);
    }
    if (tmp___5) {
      if ((unsigned int )a.addr_type == 4U) {
        {
        bad_prog((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
        }
      } else { //Added block
      if ((unsigned int )a.addr_type == 5U) {
        {
        bad_prog((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
        }
      }
      }
      {
      tmp___1 = ck_memdup((void const   *)(& a), sizeof(struct addr ));
      cur_cmd->a1 = (struct addr *)tmp___1;
      ch = in_nonblank();
      }
      if (ch == 44) {
        {
        tmp___2 = in_nonblank();
        tmp___3 = compile_address(& a, tmp___2);
        }
        if (! tmp___3) {
          {
          bad_prog(errors + sizeof("multiple `!\'s"));
          }
        }
        {
        tmp___4 = ck_memdup((void const   *)(& a), sizeof(struct addr ));
        cur_cmd->a2 = (struct addr *)tmp___4;
        ch = in_nonblank();
        }
      }
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
        if ((cur_cmd->a1)->addr_number == 0UL) {
          if (! cur_cmd->a2) {
            {
            bad_prog(((((((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
            }
          } else { //Added block
          if ((unsigned int )(cur_cmd->a2)->addr_type != 1U) {
            {
            bad_prog(((((((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
            }
          }
          }
        }
      }
    }
    if (ch == 33) {
      {
      cur_cmd->addr_bang = (char)1;
      ch = in_nonblank();
      }
      if (ch == 33) {
        {
        bad_prog(errors);
        }
      }
    }
    if ((unsigned int )posixicity == 2U) {
      {
      if (ch == 118) {
        goto case_118;
      }
      if (ch == 76) {
        goto case_118;
      }
      if (ch == 81) {
        goto case_118;
      }
      if (ch == 84) {
        goto case_118;
      }
      if (ch == 82) {
        goto case_118;
      }
      if (ch == 87) {
        goto case_118;
      }
      if (ch == 97) {
        goto case_97;
      }
      if (ch == 105) {
        goto case_97;
      }
      if (ch == 108) {
        goto case_97;
      }
      if (ch == 61) {
        goto case_97;
      }
      if (ch == 114) {
        goto case_97;
      }
      goto switch_break;
      case_118: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_87: /* CIL Label */ 
      {
      bad_command((char )ch);
      }
      case_97: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_61: /* CIL Label */ 
      case_114: /* CIL Label */ 
      if (cur_cmd->a2) {
        {
        bad_prog(((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
    cur_cmd->cmd = (char )ch;
    {
    if (ch == 35) {
      goto case_35;
    }
    if (ch == 118) {
      goto case_118___0;
    }
    if (ch == 123) {
      goto case_123;
    }
    if (ch == 125) {
      goto case_125;
    }
    if (ch == 101) {
      goto case_101;
    }
    if (ch == 97) {
      goto case_97___0;
    }
    if (ch == 105) {
      goto case_97___0;
    }
    if (ch == 99) {
      goto case_97___0;
    }
    if (ch == 58) {
      goto case_58;
    }
    if (ch == 84) {
      goto case_84___0;
    }
    if (ch == 98) {
      goto case_84___0;
    }
    if (ch == 116) {
      goto case_84___0;
    }
    if (ch == 81) {
      goto case_81___0;
    }
    if (ch == 113) {
      goto case_81___0;
    }
    if (ch == 76) {
      goto case_76___0;
    }
    if (ch == 108) {
      goto case_76___0;
    }
    if (ch == 61) {
      goto case_61___0;
    }
    if (ch == 100) {
      goto case_61___0;
    }
    if (ch == 68) {
      goto case_61___0;
    }
    if (ch == 103) {
      goto case_61___0;
    }
    if (ch == 71) {
      goto case_61___0;
    }
    if (ch == 104) {
      goto case_61___0;
    }
    if (ch == 72) {
      goto case_61___0;
    }
    if (ch == 110) {
      goto case_61___0;
    }
    if (ch == 78) {
      goto case_61___0;
    }
    if (ch == 112) {
      goto case_61___0;
    }
    if (ch == 80) {
      goto case_61___0;
    }
    if (ch == 120) {
      goto case_61___0;
    }
    if (ch == 114) {
      goto case_114___0;
    }
    if (ch == 82) {
      goto case_82___0;
    }
    if (ch == 87) {
      goto case_87___0;
    }
    if (ch == 119) {
      goto case_87___0;
    }
    if (ch == 115) {
      goto case_115;
    }
    if (ch == 121) {
      goto case_121;
    }
    if (ch == -1) {
      goto case_neg_1;
    }
    goto switch_default;
    case_35: /* CIL Label */ 
    if (cur_cmd->a1) {
      {
      bad_prog(((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses"));
      }
    }
    {
    ch = inchar();
    }
    if (ch == 110) {
      if (first_script) {
        if (cur_input.line < 2UL) {
          if (prog.base) {
            if ((unsigned long )prog.cur == (unsigned long )(prog.base + 2)) {
              no_default_output = (_Bool)1;
            } else {
              goto _L;
            }
          } else { //Added block
          _L: 
          if (prog.file) {
            if (! prog.base) {
              {
              tmp___6 = ftell(prog.file);
              }
              if (2L == tmp___6) {
                no_default_output = (_Bool)1;
              }
            }
          }
          }
        }
      }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (ch != -1) {
        if (! (ch != 10)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      {
      ch = inchar();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    goto __Cont;
    case_118___0: /* CIL Label */ 
    {
    tmp___7 = read_label();
    version = tmp___7;
    }
    if ((int )*version == 0) {
      compared_version = (char *)"4.0";
    } else {
      compared_version = version;
    }
    {
    free((void *)version);
    posixicity = (enum posixicity_types )0;
    }
    goto __Cont;
    case_123: /* CIL Label */ 
    {
    blocks = setup_label(blocks, vector->v_length, (char *)((void *)0), (struct error_info  const  *)(& cur_input));
    cur_cmd->addr_bang = (char )(! cur_cmd->addr_bang);
    }
    goto switch_break___0;
    case_125: /* CIL Label */ 
    if (! blocks) {
      {
      bad_prog((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'"));
      }
    }
    if (cur_cmd->a1) {
      {
      bad_prog(((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'"));
      }
    }
    {
    ch = in_nonblank();
    }
    if (ch == 125) {
      {
      savchar(ch);
      }
    } else { //Added block
    if (ch == 35) {
      {
      savchar(ch);
      }
    } else { //Added block
    if (ch != -1) {
      if (ch != 10) {
        if (ch != 59) {
          {
          bad_prog(((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
          }
        }
      }
    }
    }
    }
    {
    (vector->v + blocks->v_index)->x.jump_index = vector->v_length;
    blocks = release_label(blocks);
    }
    goto switch_break___0;
    case_101: /* CIL Label */ 
    {
    ch = in_nonblank();
    }
    if (ch == -1) {
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
      goto switch_break___0;
    } else { //Added block
    if (ch == 10) {
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
      goto switch_break___0;
    } else {
      goto read_text_to_slash;
    }
    }
    case_97___0: /* CIL Label */ 
    case_105___0: /* CIL Label */ 
    case_99: /* CIL Label */ 
    {
    ch = in_nonblank();
    }
    read_text_to_slash: 
    if (ch == -1) {
      {
      bad_prog((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command"));
      }
    }
    if (ch == 92) {
      {
      ch = inchar();
      }
    } else {
      {
      savchar(ch);
      ch = '\n';
      }
    }
    {
    read_text(& cur_cmd->x.cmd_txt, ch);
    }
    goto switch_break___0;
    case_58: /* CIL Label */ 
    if (cur_cmd->a1) {
      {
      bad_prog((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses"));
      }
    }
    {
    tmp___8 = read_label();
    labels = setup_label(labels, vector->v_length, tmp___8, (struct error_info  const  *)((void *)0));
    }
    goto switch_break___0;
    case_84___0: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_116: /* CIL Label */ 
    {
    tmp___9 = read_label();
    jumps = setup_label(jumps, vector->v_length, tmp___9, (struct error_info  const  *)((void *)0));
    }
    goto switch_break___0;
    case_81___0: /* CIL Label */ 
    case_113: /* CIL Label */ 
    if (cur_cmd->a2) {
      {
      bad_prog(((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
      }
    }
    case_76___0: /* CIL Label */ 
    case_108___0: /* CIL Label */ 
    {
    ch = in_nonblank();
    tmp___11 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___11 + ch) & 2048) {
      {
      tmp___10 = in_integer(ch);
      cur_cmd->x.int_arg = (int )tmp___10;
      ch = in_nonblank();
      }
    } else {
      cur_cmd->x.int_arg = -1;
    }
    if (ch == 125) {
      {
      savchar(ch);
      }
    } else { //Added block
    if (ch == 35) {
      {
      savchar(ch);
      }
    } else { //Added block
    if (ch != -1) {
      if (ch != 10) {
        if (ch != 59) {
          {
          bad_prog(((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
          }
        }
      }
    }
    }
    }
    goto switch_break___0;
    case_61___0: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_120: /* CIL Label */ 
    {
    ch = in_nonblank();
    }
    if (ch == 125) {
      {
      savchar(ch);
      }
    } else { //Added block
    if (ch == 35) {
      {
      savchar(ch);
      }
    } else { //Added block
    if (ch != -1) {
      if (ch != 10) {
        if (ch != 59) {
          {
          bad_prog(((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
          }
        }
      }
    }
    }
    }
    goto switch_break___0;
    case_114___0: /* CIL Label */ 
    {
    b___0 = read_filename();
    tmp___12 = get_buffer(b___0);
    cur_cmd->x.fname = ck_strdup((char const   *)tmp___12);
    free_buffer(b___0);
    }
    goto switch_break___0;
    case_82___0: /* CIL Label */ 
    {
    tmp___13 = get_openfile(& file_read, (char *)"r", (_Bool)0);
    cur_cmd->x.fp = tmp___13->fp;
    }
    goto switch_break___0;
    case_87___0: /* CIL Label */ 
    case_119: /* CIL Label */ 
    {
    cur_cmd->x.outf = get_openfile(& file_write, (char *)"w", (_Bool)1);
    }
    goto switch_break___0;
    case_115: /* CIL Label */ 
    {
    slash = inchar();
    b___0 = match_slash(slash, (_Bool)1);
    }
    if (! b___0) {
      {
      bad_prog(((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
      }
    }
    {
    b2 = match_slash(slash, (_Bool)0);
    }
    if (! b2) {
      {
      bad_prog(((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
      }
    }
    __h = & obs;
    __o = __h;
    __len = (int )sizeof(struct subst );
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
      _obstack_newchunk(__o, __len);
      }
    }
    __o->next_free += __len;
    __o1 = __h;
    value = (void *)__o1->object_base;
    if ((unsigned long )__o1->next_free == (unsigned long )value) {
      __o1->maybe_empty_object = 1U;
    }
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
      __o1->next_free = __o1->chunk_limit;
    }
    {
    __o1->object_base = __o1->next_free;
    cur_cmd->x.cmd_subst = (struct subst *)value;
    tmp___14 = size_buffer(b2);
    tmp___15 = get_buffer(b2);
    setup_replacement(cur_cmd->x.cmd_subst, (char const   *)tmp___15, tmp___14);
    free_buffer(b2);
    flags = mark_subst_opts(cur_cmd->x.cmd_subst);
    (cur_cmd->x.cmd_subst)->regx = compile_regex(b___0, flags, (int )((cur_cmd->x.cmd_subst)->max_id + 1U));
    free_buffer(b___0);
    }
    goto switch_break___0;
    case_121: /* CIL Label */ 
    {
    slash___0 = inchar();
    b___0 = match_slash(slash___0, (_Bool)0);
    }
    if (! b___0) {
      {
      bad_prog((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
      }
    }
    {
    src_buf = get_buffer(b___0);
    tmp___16 = size_buffer(b___0);
    len = normalize_text(src_buf, tmp___16, (enum text_types )0);
    b2___0 = match_slash(slash___0, (_Bool)0);
    }
    if (! b2___0) {
      {
      bad_prog((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
      }
    }
    {
    dest_buf = get_buffer(b2___0);
    tmp___17 = size_buffer(b2___0);
    dest_len = normalize_text(dest_buf, tmp___17, (enum text_types )0);
    }
    if (mb_cur_max > 1) {
      {
      tmp___18 = ck_malloc(len * sizeof(size_t ));
      src_lens = (size_t *)tmp___18;
      memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
      i = 0;
      j = 0;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! ((size_t )i < len)) {
          goto while_break___2;
        }
        mbclen = (size_t )1;
        if (mbclen == 0xffffffffffffffffUL) {
          mbclen = (size_t )1;
        } else { //Added block
        if (mbclen == 0xfffffffffffffffeUL) {
          mbclen = (size_t )1;
        } else { //Added block
        if (mbclen == 0UL) {
          mbclen = (size_t )1;
        }
        }
        }
        tmp___19 = j;
        j ++;
        *(src_lens + tmp___19) = mbclen;
        i = (int )((size_t )i + mbclen);
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      src_char_num = j;
      memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
      idx = 0;
      tmp___20 = ck_malloc((unsigned long )(2 * src_char_num + 1) * sizeof(char *));
      trans_pairs = (char **)tmp___20;
      cur_cmd->x.translatemb = trans_pairs;
      i = 0;
      }
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! (i < src_char_num)) {
          goto while_break___3;
        }
        if ((size_t )idx >= dest_len) {
          {
          bad_prog((((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
          }
        }
        {
        tmp___21 = ck_malloc((*(src_lens + i) + 1UL) * sizeof(char ));
        *(trans_pairs + 2 * i) = (char *)tmp___21;
        strncpy((char * __restrict  )*(trans_pairs + 2 * i), (char const   * __restrict  )src_buf,
                *(src_lens + i));
        *(*(trans_pairs + 2 * i) + *(src_lens + i)) = (char )'\000';
        src_buf += *(src_lens + i);
        mbclen = (size_t )1;
        }
        if (mbclen == 0xffffffffffffffffUL) {
          mbclen = (size_t )1;
        } else { //Added block
        if (mbclen == 0xfffffffffffffffeUL) {
          mbclen = (size_t )1;
        } else { //Added block
        if (mbclen == 0UL) {
          mbclen = (size_t )1;
        }
        }
        }
        {
        tmp___22 = ck_malloc((mbclen + 1UL) * sizeof(char ));
        *(trans_pairs + (2 * i + 1)) = (char *)tmp___22;
        strncpy((char * __restrict  )*(trans_pairs + (2 * i + 1)), (char const   * __restrict  )(dest_buf + idx),
                mbclen);
        *(*(trans_pairs + (2 * i + 1)) + mbclen) = (char )'\000';
        idx = (int )((size_t )idx + mbclen);
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      *(trans_pairs + 2 * i) = (char *)((void *)0);
      if ((size_t )idx != dest_len) {
        {
        bad_prog((((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
        }
      }
    } else {
      __h___0 = & obs;
      __o___0 = __h___0;
      __len___0 = (int )(256UL * sizeof(char ));
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      __o___0->next_free += __len___0;
      __o1___0 = __h___0;
      value___0 = (void *)__o1___0->object_base;
      if ((unsigned long )__o1___0->next_free == (unsigned long )value___0) {
        __o1___0->maybe_empty_object = 1U;
      }
      __o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
        __o1___0->next_free = __o1___0->chunk_limit;
      }
      __o1___0->object_base = __o1___0->next_free;
      translate = (char *)value___0;
      ustring = (unsigned char *)src_buf;
      if (len != dest_len) {
        {
        bad_prog((((((((((((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
        }
      }
      len = (size_t )0;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! (len < 256UL)) {
          goto while_break___4;
        }
        *(translate + len) = (char )len;
        len ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        tmp___25 = dest_len;
        dest_len --;
        if (! tmp___25) {
          goto while_break___5;
        }
        tmp___23 = ustring;
        ustring ++;
        tmp___24 = dest_buf;
        dest_buf ++;
        *(translate + (int )*tmp___23) = *tmp___24;
      }
      while_break___5: /* CIL Label */ ;
      }
      cur_cmd->x.translate = (unsigned char *)translate;
    }
    {
    ch = in_nonblank();
    }
    if (ch != -1) {
      if (ch != 10) {
        if (ch != 59) {
          {
          bad_prog(((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
          }
        }
      }
    }
    {
    free_buffer(b___0);
    free_buffer(b2___0);
    }
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
    {
    bad_prog((((((((((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses"));
    }
    switch_default: /* CIL Label */ 
    {
    bad_command((char )ch);
    }
    switch_break___0: /* CIL Label */ ;
    }
    (vector->v_length) ++;
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  return (vector);
}
}
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) 
{ 
  char const   *bufend ;
  char *p ;
  char *q ;
  int bracket_state ;
  int mbclen ;
  mbstate_t cur_stat ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
  bufend = (char const   *)(buf + len);
  p = buf;
  q = buf;
  bracket_state = 0;
  memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p < (unsigned long )bufend)) {
      goto while_break;
    }
    mbclen = 1;
    if (mbclen != 1) {
      if ((size_t )mbclen == 0xffffffffffffffffUL) {
        mbclen = 1;
      } else { //Added block
      if ((size_t )mbclen == 0xfffffffffffffffeUL) {
        mbclen = 1;
      } else { //Added block
      if (mbclen == 0) {
        mbclen = 1;
      }
      }
      }
      {
      memmove((void * __restrict  )q, (void const   * __restrict  )p, (size_t )mbclen);
      q += mbclen;
      p += mbclen;
      }
      goto while_continue;
    }
    if ((int )*p == 92) {
      if ((unsigned long )(p + 1) < (unsigned long )bufend) {
        if (bracket_state == 0) {
          p ++;
          c = (int )*p;
          {
          if (c == 97) {
            goto case_97;
          }
          if (c == 102) {
            goto case_102;
          }
          if (c == 10) {
            goto case_10;
          }
          if (c == 110) {
            goto case_10;
          }
          if (c == 114) {
            goto case_114;
          }
          if (c == 116) {
            goto case_116;
          }
          if (c == 118) {
            goto case_118;
          }
          if (c == 100) {
            goto case_100;
          }
          if (c == 120) {
            goto case_120;
          }
          if (c == 111) {
            goto case_111;
          }
          if (c == 99) {
            goto case_99;
          }
          goto switch_default;
          case_97: /* CIL Label */ 
          tmp = q;
          q ++;
          *tmp = (char )'\a';
          p ++;
          goto while_continue;
          case_102: /* CIL Label */ 
          tmp___0 = q;
          q ++;
          *tmp___0 = (char )'\f';
          p ++;
          goto while_continue;
          case_10: /* CIL Label */ 
          case_110: /* CIL Label */ 
          tmp___1 = q;
          q ++;
          *tmp___1 = (char )'\n';
          p ++;
          goto while_continue;
          case_114: /* CIL Label */ 
          tmp___2 = q;
          q ++;
          *tmp___2 = (char )'\r';
          p ++;
          goto while_continue;
          case_116: /* CIL Label */ 
          tmp___3 = q;
          q ++;
          *tmp___3 = (char )'\t';
          p ++;
          goto while_continue;
          case_118: /* CIL Label */ 
          tmp___4 = q;
          q ++;
          *tmp___4 = (char )'\v';
          p ++;
          goto while_continue;
          case_100: /* CIL Label */ 
          {
          p = convert_number(q, p + 1, bufend, 10, 3, 'd');
          q ++;
          }
          goto while_continue;
          case_120: /* CIL Label */ 
          {
          p = convert_number(q, p + 1, bufend, 16, 2, 'x');
          q ++;
          }
          goto while_continue;
          case_111: /* CIL Label */ 
          {
          p = convert_number(q, p + 1, bufend, 8, 3, 'o');
          q ++;
          }
          goto while_continue;
          case_99: /* CIL Label */ 
          p ++;
          if ((unsigned long )p < (unsigned long )bufend) {
            {
            tmp___5 = q;
            q ++;
            tmp___6 = toupper((int )*p);
            *tmp___5 = (char )(tmp___6 ^ 64);
            p ++;
            }
            goto while_continue;
          } else {
            if ((unsigned int )buftype != 0U) {
              tmp___7 = q;
              q ++;
              *tmp___7 = (char )'\\';
            }
            goto while_continue;
          }
          switch_default: /* CIL Label */ 
          if ((unsigned int )buftype != 0U) {
            tmp___8 = q;
            q ++;
            *tmp___8 = (char )'\\';
          }
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((unsigned int )buftype == 2U) {
      if ((unsigned int )posixicity != 0U) {
        {
        if ((int )*p == 91) {
          goto case_91;
        }
        if ((int )*p == 58) {
          goto case_58;
        }
        if ((int )*p == 46) {
          goto case_58;
        }
        if ((int )*p == 61) {
          goto case_58;
        }
        if ((int )*p == 93) {
          goto case_93;
        }
        goto switch_break___0;
        case_91: /* CIL Label */ 
        if (! bracket_state) {
          bracket_state = -1;
        }
        goto switch_break___0;
        case_58: /* CIL Label */ 
        case_46: /* CIL Label */ 
        case_61: /* CIL Label */ 
        if (bracket_state == -1) {
          if ((int )*(p + -1) == 91) {
            bracket_state = (int )*p;
          }
        }
        goto switch_break___0;
        case_93: /* CIL Label */ 
        if (! (bracket_state == 0)) {
          if (bracket_state == -1) {
            bracket_state = 0;
          } else { //Added block
          if ((int )*(p + -2) != bracket_state) {
            if ((int )*(p + -1) == bracket_state) {
              bracket_state = -1;
            }
          }
          }
        }
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
    }
    tmp___9 = q;
    q ++;
    tmp___10 = p;
    p ++;
    *tmp___9 = *tmp___10;
  }
  while_break: /* CIL Label */ ;
  }
  return ((size_t )(q - buf));
}
}
static countT string_expr_count  =    (countT )0;
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) 
{ 
  struct vector *ret ;

  {
  {
  prog.file = (FILE *)((void *)0);
  prog.base = (unsigned char const   *)((unsigned char *)str);
  prog.cur = prog.base;
  prog.end = prog.cur + len;
  cur_input.line = (countT )0;
  cur_input.name = (char const   *)((void *)0);
  string_expr_count ++;
  cur_input.string_expr_count = string_expr_count;
  ret = compile_program(cur_program);
  prog.base = (unsigned char const   *)((void *)0);
  prog.cur = (unsigned char const   *)((void *)0);
  prog.end = (unsigned char const   *)((void *)0);
  first_script = (_Bool)0;
  }
  return (ret);
}
}
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) 
{ 
  struct vector *ret ;

  {
  prog.file = stdin;
  if ((int const   )*(cmdfile + 0) != 45) {
    {
    prog.file = ck_fopen(cmdfile, "rt", (_Bool)1);
    }
  } else { //Added block
  if ((int const   )*(cmdfile + 1) != 0) {
    {
    prog.file = ck_fopen(cmdfile, "rt", (_Bool)1);
    }
  }
  }
  {
  cur_input.line = (countT )1;
  cur_input.name = cmdfile;
  cur_input.string_expr_count = (countT )0;
  ret = compile_program(cur_program);
  }
  if ((unsigned long )prog.file != (unsigned long )stdin) {
    {
    ck_fclose(prog.file);
    }
  }
  prog.file = (FILE *)((void *)0);
  first_script = (_Bool)0;
  return (ret);
}
}
void check_final_program(struct vector *program ) 
{ 
  struct sed_label *go ;
  struct sed_label *lbl ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct output *p ;

  {
  if (blocks) {
    {
    memmove((void * __restrict  )(& cur_input), (void const   * __restrict  )(& blocks->err_info),
            sizeof(cur_input));
    bad_prog(((errors + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address"));
    }
  }
  if (pending_text) {
    {
    old_text_buf->text_length = size_buffer(pending_text);
    tmp = get_buffer(pending_text);
    tmp___0 = ck_memdup((void const   *)tmp, old_text_buf->text_length * sizeof(char ));
    old_text_buf->text = (char *)tmp___0;
    free_buffer(pending_text);
    pending_text = (struct buffer *)((void *)0);
    }
  }
  go = jumps;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! go) {
      goto while_break;
    }
    lbl = labels;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! lbl) {
        goto while_break___0;
      }
      {
      tmp___1 = strcmp((char const   *)lbl->name, (char const   *)go->name);
      }
      if (tmp___1 == 0) {
        goto while_break___0;
      }
      lbl = lbl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (lbl) {
      (program->v + go->v_index)->x.jump_index = lbl->v_index;
    } else {
      if (*(go->name)) {
        {
        panic("can\'t find label for jump to `%s\'", go->name);
        }
      }
      (program->v + go->v_index)->x.jump_index = program->v_length;
    }
    {
    go = release_label(go);
    }
  }
  while_break: /* CIL Label */ ;
  }
  jumps = (struct sed_label *)((void *)0);
  lbl = labels;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! lbl) {
      goto while_break___1;
    }
    {
    lbl = release_label(lbl);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  labels = (struct sed_label *)((void *)0);
  p = file_read;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! p) {
      goto while_break___2;
    }
    if (p->name) {
      {
      ck_free((void *)p->name);
      p->name = (char *)((void *)0);
      }
    }
    p = p->link;
  }
  while_break___2: /* CIL Label */ ;
  }
  p = file_write;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! p) {
      goto while_break___3;
    }
    if (p->name) {
      {
      ck_free((void *)p->name);
      p->name = (char *)((void *)0);
      }
    }
    p = p->link;
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
void rewind_read_files(void) 
{ 
  struct output *p ;

  {
  p = file_read;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    if (p->fp) {
      {
      rewind(p->fp);
      }
    }
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void finish_program(struct vector *program ) 
{ 
  struct output *p ;
  struct output *q ;

  {
  p = file_read;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    if (p->fp) {
      {
      ck_fclose(p->fp);
      }
    }
    q = p->link;
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
  p = file_write;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! p) {
      goto while_break___0;
    }
    if (p->fp) {
      {
      ck_fclose(p->fp);
      }
    }
    q = p->link;
    p = q;
  }
  while_break___0: /* CIL Label */ ;
  }
  file_write = (struct output *)((void *)0);
  file_read = file_write;
  return;
}
}
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
static _Bool replaced  =    (_Bool)0;
static struct output output_file  ;
static struct line line  ;
static struct line s_accum  ;
static struct line hold  ;
static struct line buffer  ;
static struct append_queue *append_head  =    (struct append_queue *)((void *)0);
static struct append_queue *append_tail  =    (struct append_queue *)((void *)0);
static void resize_line(struct line *lb , size_t len ) ;
static void resize_line(struct line *lb , size_t len ) 
{ 
  int inactive ;
  void *tmp ;

  {
  inactive = (int )(lb->active - lb->text);
  if ((size_t )inactive > lb->alloc * 2UL) {
    {
    memmove((void * __restrict  )lb->text, (void const   * __restrict  )lb->active,
            lb->length);
    lb->alloc += (size_t )(lb->active - lb->text);
    lb->active = lb->text;
    inactive = 0;
    }
    if (lb->alloc > len) {
      return;
    }
  }
  lb->alloc *= 2UL;
  if (lb->alloc < len) {
    lb->alloc = len;
  }
  if (lb->alloc < 50UL) {
    lb->alloc = (size_t )50;
  }
  {
  tmp = ck_realloc((void *)lb->text, ((size_t )inactive + lb->alloc) * sizeof(char ));
  lb->text = (char *)tmp;
  lb->active = lb->text + inactive;
  }
  return;
}
}
static void str_append(struct line *to , char const   *string , size_t length ) ;
static void str_append(struct line *to , char const   *string , size_t length ) 
{ 
  size_t new_length ;

  {
  new_length = to->length + length;
  if (to->alloc < new_length) {
    {
    resize_line(to, new_length);
    }
  }
  {
  memmove((void * __restrict  )(to->active + to->length), (void const   * __restrict  )string,
          length);
  to->length = new_length;
  }
  return;
}
}
static void str_append_modified(struct line *to , char const   *string , size_t length ,
                                enum replacement_types type ) ;
static void str_append_modified(struct line *to , char const   *string , size_t length ,
                                enum replacement_types type ) 
{ 
  size_t old_length ;
  char *start ;
  char *end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  old_length = to->length;
  if (length == 0UL) {
    return;
  }
  {
  str_append(to, string, length);
  start = to->active + old_length;
  end = start + length;
  }
  if ((unsigned int )type & 4U) {
    {
    tmp = toupper((int )*start);
    *start = (char )tmp;
    start ++;
    type = (enum replacement_types )((unsigned int )type & 4294967291U);
    }
  } else { //Added block
  if ((unsigned int )type & 8U) {
    {
    tmp___0 = tolower((int )*start);
    *start = (char )tmp___0;
    start ++;
    type = (enum replacement_types )((unsigned int )type & 4294967287U);
    }
  }
  }
  if ((unsigned int )type == 0U) {
    return;
  }
  if ((unsigned int )type == 1U) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )start != (unsigned long )end)) {
        goto while_break;
      }
      {
      tmp___1 = toupper((int )*start);
      *start = (char )tmp___1;
      start ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )start != (unsigned long )end)) {
        goto while_break___0;
      }
      {
      tmp___2 = tolower((int )*start);
      *start = (char )tmp___2;
      start ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
static void line_init(struct line *buf , size_t initial_size ) ;
static void line_init(struct line *buf , size_t initial_size ) 
{ 
  void *tmp ;

  {
  {
  tmp = ck_malloc(initial_size * sizeof(char ));
  buf->text = (char *)tmp;
  buf->active = buf->text;
  buf->alloc = initial_size;
  buf->length = (size_t )0;
  buf->chomped = (_Bool)1;
  }
  return;
}
}
static void line_copy(struct line *from , struct line *to ) ;
static void line_copy(struct line *from , struct line *to ) 
{ 
  void *tmp ;

  {
  to->alloc += (size_t )(to->active - to->text);
  if (to->alloc < from->length) {
    to->alloc *= 2UL;
    if (to->alloc < from->length) {
      to->alloc = from->length;
    }
    if (to->alloc < 50UL) {
      to->alloc = (size_t )50;
    }
    {
    ck_free((void *)to->text);
    tmp = ck_malloc(to->alloc * sizeof(char ));
    to->text = (char *)tmp;
    }
  }
  {
  to->active = to->text;
  to->length = from->length;
  to->chomped = from->chomped;
  memmove((void * __restrict  )to->active, (void const   * __restrict  )from->active,
          from->length);
  }
  return;
}
}
static void line_append(struct line *from , struct line *to ) ;
static void line_append(struct line *from , struct line *to ) 
{ 


  {
  {
  str_append(to, "\n", (size_t )1);
  str_append(to, (char const   *)from->active, from->length);
  to->chomped = from->chomped;
  }
  return;
}
}
static void line_exchange(struct line *a , struct line *b___0 ) ;
static void line_exchange(struct line *a , struct line *b___0 ) 
{ 
  struct line t ;

  {
  {
  memmove((void * __restrict  )(& t), (void const   * __restrict  )a, sizeof(struct line ));
  memmove((void * __restrict  )a, (void const   * __restrict  )b___0, sizeof(struct line ));
  memmove((void * __restrict  )b___0, (void const   * __restrict  )(& t), sizeof(struct line ));
  }
  return;
}
}
static _Bool read_always_fail(struct input *input  __attribute__((__unused__)) ) ;
static _Bool read_always_fail(struct input *input  __attribute__((__unused__)) ) 
{ 


  {
  return ((_Bool)0);
}
}
static _Bool read_file_line(struct input *input ) ;
static char *b  ;
static size_t blen  ;
static _Bool read_file_line(struct input *input ) 
{ 
  long result ;
  size_t tmp ;

  {
  {
  tmp = ck_getline(& b, & blen, input->fp);
  result = (long )tmp;
  }
  if (result <= 0L) {
    return ((_Bool)0);
  }
  if ((int )*(b + (result - 1L)) == 10) {
    result --;
  } else {
    line.chomped = (_Bool)0;
  }
  {
  str_append(& line, (char const   *)b, (size_t )result);
  }
  return ((_Bool)1);
}
}
__inline static void output_missing_newline(struct output *outf ) ;
__inline static void output_missing_newline(struct output *outf ) 
{ 


  {
  if (outf->missing_newline) {
    {
    ck_fwrite((void const   *)"\n", (size_t )1, (size_t )1, outf->fp);
    outf->missing_newline = (_Bool)0;
    }
  }
  return;
}
}
__inline static void flush_output(FILE *fp ) ;
__inline static void flush_output(FILE *fp ) 
{ 


  {
  if ((unsigned long )fp != (unsigned long )stdout) {
    {
    ck_fflush(fp);
    }
  } else { //Added block
  if (unbuffered_output) {
    {
    ck_fflush(fp);
    }
  }
  }
  return;
}
}
static void output_line(char const   *text , size_t length , _Bool nl , struct output *outf ) ;
static void output_line(char const   *text , size_t length , _Bool nl , struct output *outf ) 
{ 


  {
  {
  output_missing_newline(outf);
  }
  if (length) {
    {
    ck_fwrite((void const   *)text, (size_t )1, length, outf->fp);
    }
  }
  if (nl) {
    {
    ck_fwrite((void const   *)"\n", (size_t )1, (size_t )1, outf->fp);
    }
  } else {
    outf->missing_newline = (_Bool)1;
  }
  {
  flush_output(outf->fp);
  }
  return;
}
}
static struct append_queue *next_append_slot(void) ;
static struct append_queue *next_append_slot(void) 
{ 
  struct append_queue *n ;
  void *tmp ;

  {
  {
  tmp = ck_malloc(sizeof(struct append_queue ));
  n = (struct append_queue *)tmp;
  n->fname = (char const   *)((void *)0);
  n->text = (char *)((void *)0);
  n->textlen = (size_t )0;
  n->next = (struct append_queue *)((void *)0);
  n->free = (_Bool)0;
  }
  if (append_tail) {
    append_tail->next = n;
  } else {
    append_head = n;
  }
  append_tail = n;
  return (append_tail);
}
}
static void release_append_queue(void) ;
static void release_append_queue(void) 
{ 
  struct append_queue *p ;
  struct append_queue *q ;

  {
  p = append_head;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    if (p->free) {
      {
      ck_free((void *)p->text);
      }
    }
    {
    q = p->next;
    ck_free((void *)p);
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
  append_tail = (struct append_queue *)((void *)0);
  append_head = append_tail;
  return;
}
}
static void dump_append_queue(void) ;
static void dump_append_queue(void) 
{ 
  struct append_queue *p ;
  char buf[8192] ;
  size_t cnt ;
  FILE *fp ;

  {
  {
  output_missing_newline(& output_file);
  p = append_head;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    if (p->text) {
      {
      ck_fwrite((void const   *)p->text, (size_t )1, p->textlen, output_file.fp);
      }
    }
    if (p->fname) {
      {
      fp = ck_fopen(p->fname, "r", (_Bool)0);
      }
      if (fp) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
          cnt = ck_fread((void *)(buf), (size_t )1, sizeof(buf), fp);
          }
          if (! (cnt > 0UL)) {
            goto while_break___0;
          }
          {
          ck_fwrite((void const   *)(buf), (size_t )1, cnt, output_file.fp);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        ck_fclose(fp);
        }
      }
    }
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  flush_output(output_file.fp);
  release_append_queue();
  }
  return;
}
}
static char *get_backup_file_name(char const   *name ) ;
static char *get_backup_file_name(char const   *name ) 
{ 
  char *old_asterisk ;
  char *asterisk ;
  char *backup ;
  char *p ;
  int name_length ;
  size_t tmp ;
  int backup_length ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
  tmp = strlen(name);
  name_length = (int )tmp;
  tmp___0 = strlen((char const   *)in_place_extension);
  backup_length = (int )tmp___0;
  asterisk = in_place_extension - 1;
  old_asterisk = asterisk + 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    asterisk = index((char const   *)old_asterisk, '*');
    }
    if (! asterisk) {
      goto while_break;
    }
    backup_length += name_length - 1;
    old_asterisk = asterisk + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___1 = xmalloc((size_t )(backup_length + 1));
  backup = (char *)tmp___1;
  p = backup;
  asterisk = in_place_extension - 1;
  old_asterisk = asterisk + 1;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    asterisk = index((char const   *)old_asterisk, '*');
    }
    if (! asterisk) {
      goto while_break___0;
    }
    {
    memmove((void * __restrict  )p, (void const   * __restrict  )old_asterisk, (size_t )(asterisk - old_asterisk));
    p += asterisk - old_asterisk;
    strcpy((char * __restrict  )p, (char const   * __restrict  )name);
    p += name_length;
    old_asterisk = asterisk + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  strcpy((char * __restrict  )p, (char const   * __restrict  )old_asterisk);
  }
  return (backup);
}
}
static void open_next_file(char const   *name , struct input *input ) ;
static void open_next_file(char const   *name , struct input *input ) 
{ 
  char const   *ptr ;
  int *tmp ;
  char *tmp___0 ;
  FILE *tmp___1 ;
  int output_fd ;
  char *tmpdir ;
  char *tmp___2 ;
  char *p ;
  struct stat st ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
  buffer.length = (size_t )0;
  if ((int const   )*(name + 0) == 45) {
    if ((int const   )*(name + 1) == 0) {
      if (! in_place_extension) {
        {
        clearerr(stdin);
        input->fp = stdin;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    {
    tmp___1 = ck_fopen(name, "r", (_Bool)0);
    input->fp = tmp___1;
    }
    if (! tmp___1) {
      {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      ptr = (char const   *)tmp___0;
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: can\'t read %s: %s\n",
              myname, name, ptr);
      input->read_fn = & read_always_fail;
      (input->bad_count) ++;
      }
      return;
    }
  }
  input->read_fn = & read_file_line;
  if (in_place_extension) {
    {
    tmp___2 = ck_strdup(name);
    tmpdir = tmp___2;
    p = rindex((char const   *)tmpdir, '/');
    }
    if (p) {
      *(p + 1) = (char)0;
    } else {
      {
      strcpy((char * __restrict  )tmpdir, (char const   * __restrict  )".");
      }
    }
    {
    input->in_file_name = name;
    tmp___3 = fileno(input->fp);
    tmp___4 = isatty(tmp___3);
    }
    if (tmp___4) {
      {
      panic("couldn\'t edit %s: is a terminal", input->in_file_name);
      }
    }
    {
    tmp___5 = fileno(input->fp);
    fstat(tmp___5, & st);
    }
    if (! ((st.st_mode & 61440U) == 32768U)) {
      {
      panic("couldn\'t edit %s: not a regular file", input->in_file_name);
      }
    }
    {
    output_file.fp = ck_mkstemp(& input->out_file_name, tmpdir, (char *)"sed");
    output_file.missing_newline = (_Bool)0;
    free((void *)tmpdir);
    }
    if (! output_file.fp) {
      {
      tmp___6 = __errno_location();
      tmp___7 = strerror(*tmp___6);
      panic("couldn\'t open temporary file %s: %s", input->out_file_name, tmp___7);
      }
    }
    {
    output_fd = fileno(output_file.fp);
    }
  } else {
    output_file.fp = stdout;
  }
  return;
}
}
static void closedown(struct input *input ) ;
static void closedown(struct input *input ) 
{ 
  char *backup_file_name ;
  char *tmp ;
  int tmp___0 ;

  {
  input->read_fn = & read_always_fail;
  if (! input->fp) {
    return;
  }
  if ((unsigned long )input->fp != (unsigned long )stdin) {
    {
    ck_fclose(input->fp);
    }
  }
  if (in_place_extension) {
    if ((unsigned long )output_file.fp != (unsigned long )((void *)0)) {
      {
      ck_fclose(output_file.fp);
      tmp___0 = strcmp((char const   *)in_place_extension, "*");
      }
      if (tmp___0 != 0) {
        {
        tmp = get_backup_file_name(input->in_file_name);
        backup_file_name = tmp;
        ck_rename(input->in_file_name, (char const   *)backup_file_name, (char const   *)input->out_file_name);
        free((void *)backup_file_name);
        }
      }
      {
      ck_rename((char const   *)input->out_file_name, input->in_file_name, (char const   *)input->out_file_name);
      free((void *)input->out_file_name);
      }
    }
  }
  input->fp = (FILE *)((void *)0);
  return;
}
}
static void reset_addresses(struct vector *vec ) ;
static void reset_addresses(struct vector *vec ) 
{ 
  struct sed_cmd *cur_cmd ;
  int n ;
  int tmp ;

  {
  cur_cmd = vec->v;
  n = (int )vec->v_length;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = n;
    n --;
    if (! tmp) {
      goto while_break;
    }
    if (cur_cmd->a1) {
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
        if ((cur_cmd->a1)->addr_number == 0UL) {
          cur_cmd->range_state = (enum addr_state )1;
        } else {
          cur_cmd->range_state = (enum addr_state )0;
        }
      } else {
        cur_cmd->range_state = (enum addr_state )0;
      }
    } else {
      cur_cmd->range_state = (enum addr_state )0;
    }
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static _Bool read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                _Bool append ) ;
static _Bool read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                _Bool append ) 
{ 
  char **tmp ;
  _Bool tmp___0 ;

  {
  if (append_head) {
    {
    dump_append_queue();
    }
  }
  replaced = (_Bool)0;
  if (! append) {
    line.length = (size_t )0;
  }
  line.chomped = (_Bool)1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = (*(input->read_fn))(input);
    }
    if (tmp___0) {
      goto while_break;
    }
    {
    closedown(input);
    }
    if (! *(input->file_list)) {
      return ((_Bool)0);
    }
    if (input->reset_at_next_file) {
      {
      input->line_number = (countT )0;
      reset_addresses(the_program___0);
      rewind_read_files();
      }
      if (in_place_extension) {
        output_file.missing_newline = (_Bool)0;
      }
      input->reset_at_next_file = separate_files;
    }
    {
    tmp = input->file_list;
    (input->file_list) ++;
    open_next_file((char const   *)*tmp, input);
    }
  }
  while_break: /* CIL Label */ ;
  }
  (input->line_number) ++;
  return ((_Bool)1);
}
}
static _Bool last_file_with_data_p(struct input *input ) ;
static _Bool last_file_with_data_p(struct input *input ) 
{ 
  int ch ;
  char **tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    closedown(input);
    }
    if (! *(input->file_list)) {
      return ((_Bool)1);
    }
    {
    tmp = input->file_list;
    (input->file_list) ++;
    open_next_file((char const   *)*tmp, input);
    }
    if (input->fp) {
      {
      ch = _IO_getc(input->fp);
      }
      if (ch != -1) {
        {
        ungetc(ch, input->fp);
        }
        return ((_Bool)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
static _Bool test_eof(struct input *input ) ;
static _Bool test_eof(struct input *input ) 
{ 
  int ch ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  if (buffer.length) {
    return ((_Bool)0);
  }
  if (! input->fp) {
    if (separate_files) {
      tmp___0 = 1;
    } else {
      {
      tmp = last_file_with_data_p(input);
      }
      if (tmp) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    }
    return ((_Bool )tmp___0);
  }
  {
  tmp___3 = feof(input->fp);
  }
  if (tmp___3) {
    if (separate_files) {
      tmp___2 = 1;
    } else {
      {
      tmp___1 = last_file_with_data_p(input);
      }
      if (tmp___1) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    }
    return ((_Bool )tmp___2);
  }
  {
  ch = _IO_getc(input->fp);
  }
  if (ch == -1) {
    if (separate_files) {
      tmp___5 = 1;
    } else {
      {
      tmp___4 = last_file_with_data_p(input);
      }
      if (tmp___4) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    }
    return ((_Bool )tmp___5);
  }
  {
  ungetc(ch, input->fp);
  }
  return ((_Bool)0);
}
}
static _Bool match_an_address_p(struct addr *addr , struct input *input ) ;
static _Bool match_an_address_p(struct addr *addr , struct input *input ) 
{ 
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
  if ((unsigned int )addr->addr_type == 0U) {
    goto case_0;
  }
  if ((unsigned int )addr->addr_type == 1U) {
    goto case_1;
  }
  if ((unsigned int )addr->addr_type == 3U) {
    goto case_3;
  }
  if ((unsigned int )addr->addr_type == 4U) {
    goto case_4;
  }
  if ((unsigned int )addr->addr_type == 5U) {
    goto case_4;
  }
  if ((unsigned int )addr->addr_type == 6U) {
    goto case_6;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  return ((_Bool)1);
  case_1: /* CIL Label */ 
  {
  tmp = match_regex(addr->addr_regex, line.active, line.length, (size_t )0, (struct re_registers *)((void *)0),
                    0);
  }
  return ((_Bool )tmp);
  case_3: /* CIL Label */ 
  if (input->line_number >= addr->addr_number) {
    if ((input->line_number - addr->addr_number) % addr->addr_step == 0UL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return ((_Bool )tmp___0);
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  return ((_Bool )(addr->addr_number <= input->line_number));
  case_6: /* CIL Label */ 
  {
  tmp___1 = test_eof(input);
  }
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
  panic("INTERNAL ERROR: bad address type");
  }
  switch_break: /* CIL Label */ ;
  }
  return ((_Bool)0);
}
}
static _Bool match_address_p(struct sed_cmd *cmd , struct input *input ) ;
static _Bool match_address_p(struct sed_cmd *cmd , struct input *input ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  if (! cmd->a1) {
    return ((_Bool)1);
  }
  if ((unsigned int )cmd->range_state != 1U) {
    if ((unsigned int )(cmd->a1)->addr_type == 2U) {
      if (! cmd->a2) {
        return ((_Bool )(input->line_number == (cmd->a1)->addr_number));
      }
      if ((unsigned int )cmd->range_state == 2U) {
        return ((_Bool)0);
      } else { //Added block
      if (input->line_number < (cmd->a1)->addr_number) {
        return ((_Bool)0);
      }
      }
    } else {
      if (! cmd->a2) {
        {
        tmp = match_an_address_p(cmd->a1, input);
        }
        return (tmp);
      }
      {
      tmp___0 = match_an_address_p(cmd->a1, input);
      }
      if (! tmp___0) {
        return ((_Bool)0);
      }
    }
    cmd->range_state = (enum addr_state )1;
    {
    if ((unsigned int )(cmd->a2)->addr_type == 1U) {
      goto case_1;
    }
    if ((unsigned int )(cmd->a2)->addr_type == 2U) {
      goto case_2;
    }
    if ((unsigned int )(cmd->a2)->addr_type == 4U) {
      goto case_4;
    }
    if ((unsigned int )(cmd->a2)->addr_type == 5U) {
      goto case_5;
    }
    goto switch_default;
    case_1: /* CIL Label */ 
    return ((_Bool)1);
    case_2: /* CIL Label */ 
    if (input->line_number >= (cmd->a2)->addr_number) {
      cmd->range_state = (enum addr_state )2;
    }
    return ((_Bool)1);
    case_4: /* CIL Label */ 
    (cmd->a2)->addr_number = input->line_number + (cmd->a2)->addr_step;
    return ((_Bool)1);
    case_5: /* CIL Label */ 
    (cmd->a2)->addr_number = (input->line_number + (cmd->a2)->addr_step) - input->line_number % (cmd->a2)->addr_step;
    return ((_Bool)1);
    switch_default: /* CIL Label */ 
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  if ((unsigned int )(cmd->a2)->addr_type == 2U) {
    if (input->line_number >= (cmd->a2)->addr_number) {
      cmd->range_state = (enum addr_state )2;
    }
    return ((_Bool )(input->line_number <= (cmd->a2)->addr_number));
  }
  {
  tmp___1 = match_an_address_p(cmd->a2, input);
  }
  if (tmp___1) {
    cmd->range_state = (enum addr_state )2;
  }
  return ((_Bool)1);
}
}
static void do_list(int line_len ) ;
static void do_list(int line_len ) 
{ 
  unsigned char *p ;
  countT len ;
  countT width ;
  char obuf[180] ;
  char *o ;
  size_t olen ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  countT tmp___11 ;

  {
  {
  p = (unsigned char *)line.active;
  len = line.length;
  width = (countT )0;
  fp = output_file.fp;
  output_missing_newline(& output_file);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___11 = len;
    len --;
    if (! tmp___11) {
      goto while_break;
    }
    o = obuf;
    if (((int )*p & -128) == 0) {
      {
      tmp___10 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___10 + (int )*p) & 16384) {
        tmp = o;
        o ++;
        *tmp = (char )*p;
        if ((int )*p == 92) {
          tmp___0 = o;
          o ++;
          *tmp___0 = (char )'\\';
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      tmp___1 = o;
      o ++;
      *tmp___1 = (char )'\\';
      {
      if ((int )*p == 7) {
        goto case_7;
      }
      if ((int )*p == 8) {
        goto case_8;
      }
      if ((int )*p == 12) {
        goto case_12;
      }
      if ((int )*p == 10) {
        goto case_10;
      }
      if ((int )*p == 13) {
        goto case_13;
      }
      if ((int )*p == 9) {
        goto case_9;
      }
      if ((int )*p == 11) {
        goto case_11;
      }
      goto switch_default;
      case_7: /* CIL Label */ 
      tmp___2 = o;
      o ++;
      *tmp___2 = (char )'a';
      goto switch_break;
      case_8: /* CIL Label */ 
      tmp___3 = o;
      o ++;
      *tmp___3 = (char )'b';
      goto switch_break;
      case_12: /* CIL Label */ 
      tmp___4 = o;
      o ++;
      *tmp___4 = (char )'f';
      goto switch_break;
      case_10: /* CIL Label */ 
      tmp___5 = o;
      o ++;
      *tmp___5 = (char )'n';
      goto switch_break;
      case_13: /* CIL Label */ 
      tmp___6 = o;
      o ++;
      *tmp___6 = (char )'r';
      goto switch_break;
      case_9: /* CIL Label */ 
      tmp___7 = o;
      o ++;
      *tmp___7 = (char )'t';
      goto switch_break;
      case_11: /* CIL Label */ 
      tmp___8 = o;
      o ++;
      *tmp___8 = (char )'v';
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      sprintf((char * __restrict  )o, (char const   * __restrict  )"%03o", (int )*p);
      tmp___9 = strlen((char const   *)o);
      o += tmp___9;
      }
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    olen = (size_t )(o - obuf);
    if (width + olen >= (countT )line_len) {
      if (line_len > 0) {
        {
        ck_fwrite((void const   *)"\\\n", (size_t )1, (size_t )2, fp);
        width = (countT )0;
        }
      }
    }
    {
    ck_fwrite((void const   *)(obuf), (size_t )1, olen, fp);
    width += olen;
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  ck_fwrite((void const   *)"$\n", (size_t )1, (size_t )2, fp);
  flush_output(fp);
  }
  return;
}
}
static enum replacement_types append_replacement(struct line *buf , struct replacement *p ,
                                                 struct re_registers *regs___0 , enum replacement_types repl_mod ) ;
static enum replacement_types append_replacement(struct line *buf , struct replacement *p ,
                                                 struct re_registers *regs___0 , enum replacement_types repl_mod ) 
{ 
  int i ;
  enum replacement_types curr_type ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    i = p->subst_id;
    if ((unsigned int )p->repl_type & 12U) {
      curr_type = p->repl_type;
    } else {
      curr_type = (enum replacement_types )((unsigned int )p->repl_type | (unsigned int )repl_mod);
    }
    repl_mod = (enum replacement_types )0;
    if (p->prefix_length) {
      {
      str_append_modified(buf, (char const   *)p->prefix, p->prefix_length, curr_type);
      curr_type = (enum replacement_types )((unsigned int )curr_type & 4294967283U);
      }
    }
    if (0 <= i) {
      if (*(regs___0->end + i) == *(regs___0->start + i)) {
        if ((unsigned int )p->repl_type & 12U) {
          repl_mod = (enum replacement_types )((unsigned int )curr_type & 12U);
        } else {
          {
          str_append_modified(buf, (char const   *)(line.active + *(regs___0->start + i)),
                              (size_t )(*(regs___0->end + i) - *(regs___0->start + i)),
                              curr_type);
          }
        }
      } else {
        {
        str_append_modified(buf, (char const   *)(line.active + *(regs___0->start + i)),
                            (size_t )(*(regs___0->end + i) - *(regs___0->start + i)),
                            curr_type);
        }
      }
    }
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (repl_mod);
}
}
static void do_subst(struct subst *sub ) ;
static struct re_registers regs  ;
static void do_subst(struct subst *sub ) 
{ 
  size_t start ;
  size_t last_end ;
  countT count ;
  _Bool again ;
  int tmp ;
  enum replacement_types repl_mod ;
  size_t offset ;
  size_t matched ;
  int tmp___0 ;

  {
  start = (size_t )0;
  last_end = (size_t )0;
  count = (countT )0;
  again = (_Bool)1;
  if (s_accum.alloc == 0UL) {
    {
    line_init(& s_accum, (size_t )50);
    }
  }
  {
  s_accum.length = (size_t )0;
  tmp = match_regex(sub->regx, line.active, line.length, start, & regs, (int )(sub->max_id + 1U));
  }
  if (! tmp) {
    return;
  }
  if (! sub->replacement) {
    if (sub->numb <= 1UL) {
      if (*(regs.start + 0) == 0) {
        if (! sub->global) {
          replaced = (_Bool)1;
          line.active += *(regs.end + 0);
          line.length -= (size_t )*(regs.end + 0);
          line.alloc -= (size_t )*(regs.end + 0);
          goto post_subst;
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if ((size_t )*(regs.end + 0) == line.length) {
        replaced = (_Bool)1;
        line.length = (size_t )*(regs.start + 0);
        goto post_subst;
      }
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    repl_mod = (enum replacement_types )0;
    offset = (size_t )*(regs.start + 0);
    matched = (size_t )(*(regs.end + 0) - *(regs.start + 0));
    if (start < offset) {
      {
      str_append(& s_accum, (char const   *)(line.active + start), offset - start);
      }
    }
    if (matched > 0UL) {
      goto _L___1;
    } else { //Added block
    if (count == 0UL) {
      goto _L___1;
    } else { //Added block
    if (offset > last_end) {
      _L___1: 
      count ++;
      if (count >= sub->numb) {
        {
        replaced = (_Bool)1;
        repl_mod = append_replacement(& s_accum, sub->replacement, & regs, repl_mod);
        again = (_Bool )sub->global;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (matched == 0UL) {
        if (start < line.length) {
          matched = (size_t )1;
        } else {
          goto while_break;
        }
      }
      {
      str_append(& s_accum, (char const   *)(line.active + offset), matched);
      }
    }
    }
    }
    start = offset + matched;
    last_end = (size_t )*(regs.end + 0);
    if (again) {
      if (start <= line.length) {
        {
        tmp___0 = match_regex(sub->regx, line.active, line.length, start, & regs,
                              (int )(sub->max_id + 1U));
        }
        if (! tmp___0) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (start < line.length) {
    {
    str_append(& s_accum, (char const   *)(line.active + start), line.length - start);
    }
  }
  {
  s_accum.chomped = line.chomped;
  line_exchange(& line, & s_accum);
  }
  if (count < sub->numb) {
    return;
  }
  post_subst: 
  if (sub->print & 1U) {
    {
    output_line((char const   *)line.active, line.length, line.chomped, & output_file);
    }
  }
  if (sub->eval) {
    {
    panic("option `e\' not supported");
    }
  }
  if (sub->print & 2U) {
    {
    output_line((char const   *)line.active, line.length, line.chomped, & output_file);
    }
  }
  if (sub->outf) {
    {
    output_line((char const   *)line.active, line.length, line.chomped, sub->outf);
    }
  }
  return;
}
}
static int execute_program(struct vector *vec , struct input *input ) ;
static int execute_program(struct vector *vec , struct input *input ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct sed_cmd *end_cmd ;
  struct append_queue *aq ;
  struct append_queue *tmp ;
  char *p ;
  void *tmp___0 ;
  countT tmp___1 ;
  countT tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  char *p___0 ;
  void *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  struct append_queue *aq___0 ;
  struct append_queue *tmp___11 ;
  struct append_queue *aq___1 ;
  size_t buflen ;
  char *text ;
  int result ;
  size_t tmp___12 ;
  int tmp___13 ;
  char *p___1 ;
  void *tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  unsigned char *p___2 ;
  unsigned char *e ;
  _Bool tmp___17 ;

  {
  cur_cmd = vec->v;
  end_cmd = vec->v + vec->v_length;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )cur_cmd < (unsigned long )end_cmd)) {
      goto while_break;
    }
    {
    tmp___17 = match_address_p(cur_cmd, input);
    }
    if ((int )tmp___17 != (int )cur_cmd->addr_bang) {
      {
      if ((int )cur_cmd->cmd == 97) {
        goto case_97;
      }
      if ((int )cur_cmd->cmd == 123) {
        goto case_123;
      }
      if ((int )cur_cmd->cmd == 98) {
        goto case_123;
      }
      if ((int )cur_cmd->cmd == 125) {
        goto case_125;
      }
      if ((int )cur_cmd->cmd == 35) {
        goto case_125;
      }
      if ((int )cur_cmd->cmd == 58) {
        goto case_125;
      }
      if ((int )cur_cmd->cmd == 99) {
        goto case_99;
      }
      if ((int )cur_cmd->cmd == 100) {
        goto case_100;
      }
      if ((int )cur_cmd->cmd == 68) {
        goto case_68;
      }
      if ((int )cur_cmd->cmd == 101) {
        goto case_101;
      }
      if ((int )cur_cmd->cmd == 103) {
        goto case_103;
      }
      if ((int )cur_cmd->cmd == 71) {
        goto case_71;
      }
      if ((int )cur_cmd->cmd == 104) {
        goto case_104;
      }
      if ((int )cur_cmd->cmd == 72) {
        goto case_72;
      }
      if ((int )cur_cmd->cmd == 105) {
        goto case_105;
      }
      if ((int )cur_cmd->cmd == 108) {
        goto case_108;
      }
      if ((int )cur_cmd->cmd == 76) {
        goto case_76;
      }
      if ((int )cur_cmd->cmd == 110) {
        goto case_110;
      }
      if ((int )cur_cmd->cmd == 78) {
        goto case_78;
      }
      if ((int )cur_cmd->cmd == 112) {
        goto case_112;
      }
      if ((int )cur_cmd->cmd == 80) {
        goto case_80;
      }
      if ((int )cur_cmd->cmd == 113) {
        goto case_113;
      }
      if ((int )cur_cmd->cmd == 81) {
        goto case_81;
      }
      if ((int )cur_cmd->cmd == 114) {
        goto case_114;
      }
      if ((int )cur_cmd->cmd == 82) {
        goto case_82;
      }
      if ((int )cur_cmd->cmd == 115) {
        goto case_115;
      }
      if ((int )cur_cmd->cmd == 116) {
        goto case_116;
      }
      if ((int )cur_cmd->cmd == 84) {
        goto case_84;
      }
      if ((int )cur_cmd->cmd == 119) {
        goto case_119;
      }
      if ((int )cur_cmd->cmd == 87) {
        goto case_87;
      }
      if ((int )cur_cmd->cmd == 120) {
        goto case_120;
      }
      if ((int )cur_cmd->cmd == 121) {
        goto case_121;
      }
      if ((int )cur_cmd->cmd == 61) {
        goto case_61;
      }
      goto switch_default;
      case_97: /* CIL Label */ 
      {
      tmp = next_append_slot();
      aq = tmp;
      aq->text = cur_cmd->x.cmd_txt.text;
      aq->textlen = cur_cmd->x.cmd_txt.text_length;
      }
      goto switch_break;
      case_123: /* CIL Label */ 
      case_98: /* CIL Label */ 
      cur_cmd = vec->v + cur_cmd->x.jump_index;
      goto while_continue;
      case_125: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_58: /* CIL Label */ 
      goto switch_break;
      case_99: /* CIL Label */ 
      if ((unsigned int )cur_cmd->range_state != 1U) {
        {
        output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                    (_Bool)1, & output_file);
        }
      }
      case_100: /* CIL Label */ 
      return (-1);
      case_68: /* CIL Label */ 
      {
      tmp___0 = memchr((void const   *)line.active, '\n', line.length);
      p = (char *)tmp___0;
      }
      if (! p) {
        return (-1);
      }
      p ++;
      line.alloc -= (size_t )(p - line.active);
      line.length -= (size_t )(p - line.active);
      line.active += p - line.active;
      cur_cmd = vec->v;
      goto while_continue;
      case_101: /* CIL Label */ 
      {
      panic("`e\' command not supported");
      }
      goto switch_break;
      case_103: /* CIL Label */ 
      {
      line_copy(& hold, & line);
      }
      goto switch_break;
      case_71: /* CIL Label */ 
      {
      line_append(& hold, & line);
      }
      goto switch_break;
      case_104: /* CIL Label */ 
      {
      line_copy(& line, & hold);
      }
      goto switch_break;
      case_72: /* CIL Label */ 
      {
      line_append(& line, & hold);
      }
      goto switch_break;
      case_105: /* CIL Label */ 
      {
      output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                  (_Bool)1, & output_file);
      }
      goto switch_break;
      case_108: /* CIL Label */ 
      if (cur_cmd->x.int_arg == -1) {
        tmp___1 = lcmd_out_line_len;
      } else {
        tmp___1 = (countT )cur_cmd->x.int_arg;
      }
      {
      do_list((int )tmp___1);
      }
      goto switch_break;
      case_76: /* CIL Label */ 
      {
      output_missing_newline(& output_file);
      }
      if (cur_cmd->x.int_arg == -1) {
        tmp___2 = lcmd_out_line_len;
      } else {
        tmp___2 = (countT )cur_cmd->x.int_arg;
      }
      {
      fmt((char const   *)line.active, (char const   *)(line.active + line.length),
          (int )tmp___2, output_file.fp);
      flush_output(output_file.fp);
      }
      goto switch_break;
      case_110: /* CIL Label */ 
      if (! no_default_output) {
        {
        output_line((char const   *)line.active, line.length, line.chomped, & output_file);
        }
      }
      {
      tmp___3 = test_eof(input);
      }
      if (tmp___3) {
        return (-1);
      } else {
        {
        tmp___4 = read_pattern_space(input, vec, (_Bool)0);
        }
        if (! tmp___4) {
          return (-1);
        }
      }
      goto switch_break;
      case_78: /* CIL Label */ 
      {
      str_append(& line, "\n", (size_t )1);
      tmp___5 = test_eof(input);
      }
      if (tmp___5) {
        goto _L;
      } else {
        {
        tmp___6 = read_pattern_space(input, vec, (_Bool)1);
        }
        if (! tmp___6) {
          _L: 
          (line.length) --;
          if ((unsigned int )posixicity == 0U) {
            if (! no_default_output) {
              {
              output_line((char const   *)line.active, line.length, line.chomped,
                          & output_file);
              }
            }
          }
          return (-1);
        }
      }
      goto switch_break;
      case_112: /* CIL Label */ 
      {
      output_line((char const   *)line.active, line.length, line.chomped, & output_file);
      }
      goto switch_break;
      case_80: /* CIL Label */ 
      {
      tmp___7 = memchr((void const   *)line.active, '\n', line.length);
      p___0 = (char *)tmp___7;
      }
      if (p___0) {
        tmp___8 = 1;
      } else {
        tmp___8 = (int )line.chomped;
      }
      if (p___0) {
        tmp___9 = (size_t )(p___0 - line.active);
      } else {
        tmp___9 = line.length;
      }
      {
      output_line((char const   *)line.active, tmp___9, (_Bool )tmp___8, & output_file);
      }
      goto switch_break;
      case_113: /* CIL Label */ 
      if (! no_default_output) {
        {
        output_line((char const   *)line.active, line.length, line.chomped, & output_file);
        }
      }
      {
      dump_append_queue();
      }
      case_81: /* CIL Label */ 
      if (cur_cmd->x.int_arg == -1) {
        tmp___10 = 0;
      } else {
        tmp___10 = cur_cmd->x.int_arg;
      }
      return (tmp___10);
      case_114: /* CIL Label */ 
      if (cur_cmd->x.fname) {
        {
        tmp___11 = next_append_slot();
        aq___0 = tmp___11;
        aq___0->fname = (char const   *)cur_cmd->x.fname;
        }
      }
      goto switch_break;
      case_82: /* CIL Label */ 
      if (cur_cmd->x.fp) {
        {
        tmp___13 = feof(cur_cmd->x.fp);
        }
        if (! tmp___13) {
          {
          text = (char *)((void *)0);
          tmp___12 = ck_getline(& text, & buflen, cur_cmd->x.fp);
          result = (int )tmp___12;
          }
          if (result != -1) {
            {
            aq___1 = next_append_slot();
            aq___1->free = (_Bool)1;
            aq___1->text = text;
            aq___1->textlen = (size_t )result;
            }
          }
        }
      }
      goto switch_break;
      case_115: /* CIL Label */ 
      {
      do_subst(cur_cmd->x.cmd_subst);
      }
      goto switch_break;
      case_116: /* CIL Label */ 
      if (replaced) {
        replaced = (_Bool)0;
        cur_cmd = vec->v + cur_cmd->x.jump_index;
        goto while_continue;
      }
      goto switch_break;
      case_84: /* CIL Label */ 
      if (! replaced) {
        cur_cmd = vec->v + cur_cmd->x.jump_index;
        goto while_continue;
      } else {
        replaced = (_Bool)0;
      }
      goto switch_break;
      case_119: /* CIL Label */ 
      if (cur_cmd->x.fp) {
        {
        output_line((char const   *)line.active, line.length, line.chomped, cur_cmd->x.outf);
        }
      }
      goto switch_break;
      case_87: /* CIL Label */ 
      if (cur_cmd->x.fp) {
        {
        tmp___14 = memchr((void const   *)line.active, '\n', line.length);
        p___1 = (char *)tmp___14;
        }
        if (p___1) {
          tmp___15 = 1;
        } else {
          tmp___15 = (int )line.chomped;
        }
        if (p___1) {
          tmp___16 = (size_t )(p___1 - line.active);
        } else {
          tmp___16 = line.length;
        }
        {
        output_line((char const   *)line.active, tmp___16, (_Bool )tmp___15, cur_cmd->x.outf);
        }
      }
      goto switch_break;
      case_120: /* CIL Label */ 
      {
      line_exchange(& line, & hold);
      }
      goto switch_break;
      case_121: /* CIL Label */ 
      p___2 = (unsigned char *)line.active;
      e = p___2 + line.length;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )p___2 < (unsigned long )e)) {
          goto while_break___0;
        }
        *p___2 = *(cur_cmd->x.translate + (int )*p___2);
        p___2 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      goto switch_break;
      case_61: /* CIL Label */ 
      {
      output_missing_newline(& output_file);
      fprintf((FILE * __restrict  )output_file.fp, (char const   * __restrict  )"%lu\n",
              input->line_number);
      flush_output(output_file.fp);
      }
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      panic("INTERNAL ERROR: Bad cmd %c", (int )cur_cmd->cmd);
      }
      switch_break: /* CIL Label */ ;
      }
    }
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (! no_default_output) {
    {
    output_line((char const   *)line.active, line.length, line.chomped, & output_file);
    }
  }
  return (-1);
}
}
static char dash[2]  = {      (char )'-',      (char )'\000'};
static char *stdin_argv[2]  = {      dash,      (char *)((void *)0)};
int process_files(struct vector *the_program___0 , char **argv ) 
{ 
  struct input input ;
  int status ;
  _Bool tmp ;

  {
  {
  line_init(& line, (size_t )50);
  line_init(& hold, (size_t )0);
  line_init(& buffer, (size_t )0);
  input.reset_at_next_file = (_Bool)1;
  }
  if (argv) {
    if (*argv) {
      input.file_list = argv;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (in_place_extension) {
    {
    panic("no input files");
    }
  } else {
    input.file_list = stdin_argv;
  }
  }
  input.bad_count = (countT )0;
  input.line_number = (countT )0;
  input.read_fn = & read_always_fail;
  input.fp = (FILE *)((void *)0);
  status = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = read_pattern_space(& input, the_program___0, (_Bool)0);
    }
    if (! tmp) {
      goto while_break;
    }
    {
    status = execute_program(the_program___0, & input);
    }
    if (status == -1) {
      status = 0;
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  closedown(& input);
  }
  if (input.bad_count) {
    status = 2;
  }
  return (status);
}
}
static _Bool get_paragraph(void) ;
static int get_line(int c ) ;
static int get_space(int c ) ;
static int copy_rest(int c ) ;
static _Bool same_para(int c ) ;
static void flush_paragraph(void) ;
static void fmt_paragraph(void) ;
static void check_punctuation(WORD *w ) ;
static COST base_cost(WORD *this ) ;
static COST line_cost(WORD *next , int len ) ;
static void put_paragraph(WORD *finish ) ;
static void put_line(WORD *w , int indent ) ;
static void put_word(WORD *w ) ;
static void put_space(int space ) ;
static int max_width  ;
static char const   *parabuf  ;
static char const   *end_of_parabuf  ;
static FILE *outfile  ;
static int best_width  ;
static int in_column  ;
static int out_column  ;
static WORD words[1000]  ;
static WORD *word_limit  ;
static int first_indent  ;
static int other_indent  ;
static int next_char  ;
static int last_line_length  ;
void fmt(char const   *line___0 , char const   *line_end , int max_length , FILE *output_file___0 ) 
{ 
  char const   *tmp ;
  _Bool tmp___0 ;

  {
  parabuf = line___0;
  end_of_parabuf = line_end;
  outfile = output_file___0;
  max_width = max_length;
  best_width = (max_width * 187) / 200;
  in_column = 0;
  other_indent = 0;
  if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
    next_char = -1;
  } else {
    tmp = parabuf;
    parabuf ++;
    next_char = (int )*tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = get_paragraph();
    }
    if (! tmp___0) {
      goto while_break;
    }
    {
    fmt_paragraph();
    put_paragraph(word_limit);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static _Bool get_paragraph(void) 
{ 
  register int c ;
  char const   *tmp ;
  _Bool tmp___0 ;
  unsigned int tmp___1 ;

  {
  last_line_length = 0;
  c = next_char;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (c == 10)) {
      if (! (c == -1)) {
        goto while_break;
      }
    }
    {
    c = copy_rest(c);
    }
    if (c == -1) {
      next_char = -1;
      return ((_Bool)0);
    }
    {
    _IO_putc('\n', outfile);
    }
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
      c = -1;
    } else {
      tmp = parabuf;
      parabuf ++;
      c = (int )*tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  first_indent = in_column;
  word_limit = words;
  c = get_line(c);
  other_indent = in_column;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    tmp___0 = same_para(c);
    }
    if (tmp___0) {
      if (! (in_column == other_indent)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    c = get_line(c);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  tmp___1 = 1U;
  (word_limit - 1)->final = tmp___1;
  (word_limit - 1)->period = tmp___1;
  next_char = c;
  return ((_Bool)1);
}
}
static int copy_rest(int c ) 
{ 
  char const   *tmp ;

  {
  out_column = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (c != 10) {
      if (! (c != -1)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    _IO_putc(c, outfile);
    }
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
      c = -1;
    } else {
      tmp = parabuf;
      parabuf ++;
      c = (int )*tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (c);
}
}
static _Bool same_para(int c ) 
{ 
  int tmp ;

  {
  if (c != 10) {
    if (c != -1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
static int get_line(int c ) 
{ 
  int start ;
  register WORD *end_of_word ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  end_of_word = & words[998];
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    word_limit->text = parabuf - 1;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
        c = -1;
      } else {
        tmp = parabuf;
        parabuf ++;
        c = (int )*tmp;
      }
      if (c != -1) {
        {
        tmp___0 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___0 + c) & 8192) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    word_limit->length = (short )((parabuf - word_limit->text) - (long )(c != -1));
    in_column += (int )word_limit->length;
    check_punctuation(word_limit);
    start = in_column;
    c = get_space(c);
    word_limit->space = (short )(in_column - start);
    }
    if (c == -1) {
      tmp___1 = 1;
    } else { //Added block
    if (word_limit->period) {
      if (c == 10) {
        tmp___1 = 1;
      } else { //Added block
      if ((int )word_limit->space > 1) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
      }
    } else {
      tmp___1 = 0;
    }
    }
    word_limit->final = (unsigned int )tmp___1;
    if (c == 10) {
      goto _L;
    } else { //Added block
    if (c == -1) {
      _L: 
      if (word_limit->final) {
        word_limit->space = (short)2;
      } else {
        word_limit->space = (short)1;
      }
    }
    }
    if ((unsigned long )word_limit == (unsigned long )end_of_word) {
      {
      flush_paragraph();
      }
    }
    word_limit ++;
    if (c == -1) {
      in_column = first_indent;
      return (-1);
    }
    if (! (c != 10)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  in_column = 0;
  if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
    c = -1;
  } else {
    tmp___2 = parabuf;
    parabuf ++;
    c = (int )*tmp___2;
  }
  {
  tmp___3 = get_space(c);
  }
  return (tmp___3);
}
}
static int get_space(int c ) 
{ 
  char const   *tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (c == 32) {
      in_column ++;
    } else { //Added block
    if (c == 9) {
      in_column = (in_column / 8 + 1) * 8;
    } else {
      return (c);
    }
    }
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
      c = -1;
    } else {
      tmp = parabuf;
      parabuf ++;
      c = (int )*tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
static void check_punctuation(WORD *w ) 
{ 
  register char const   *start ;
  register char const   *finish ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  start = w->text;
  finish = start + ((int )w->length - 1);
  tmp = index("([`\'\"", (int )*start);
  w->paren = (unsigned int )((unsigned long )tmp != (unsigned long )((void *)0));
  tmp___0 = __ctype_b_loc();
  w->punct = (unsigned int )(((int const   )*(*tmp___0 + (int )*finish) & 4) != 0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___1 = index(")]\'\"", (int )*finish);
    }
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      if (! ((unsigned long )finish > (unsigned long )start)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    finish --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___2 = index(".?!", (int )*finish);
  w->period = (unsigned int )((unsigned long )tmp___2 != (unsigned long )((void *)0));
  }
  return;
}
}
static void flush_paragraph(void) 
{ 
  WORD *split_point ;
  register WORD *w ;
  COST best_break ;

  {
  {
  fmt_paragraph();
  split_point = word_limit;
  best_break = (COST )(~ (1UL << (8UL * sizeof(COST ) - 1UL)));
  w = words[0].next_break;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )w != (unsigned long )word_limit)) {
      goto while_break;
    }
    if (w->best_cost - (w->next_break)->best_cost < best_break) {
      split_point = w;
      best_break = w->best_cost - (w->next_break)->best_cost;
    }
    if ((unsigned long )best_break <= ~ (1UL << (8UL * sizeof(COST ) - 1UL)) - 9UL) {
      best_break += 9L;
    }
    w = w->next_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  put_paragraph(split_point);
  memmove((void * __restrict  )((char *)(words)), (void const   * __restrict  )((char *)split_point),
          (unsigned long )((word_limit - split_point) + 1L) * sizeof(WORD ));
  word_limit -= split_point - words;
  }
  return;
}
}
static void fmt_paragraph(void) 
{ 
  register WORD *start ;
  register WORD *w ;
  register int len ;
  register COST wcost ;
  register COST best ;
  int saved_length ;
  COST tmp ;
  COST tmp___0 ;

  {
  word_limit->best_cost = (COST )0;
  saved_length = (int )word_limit->length;
  word_limit->length = (short )max_width;
  start = word_limit - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )start >= (unsigned long )(words))) {
      goto while_break;
    }
    best = (COST )(~ (1UL << (8UL * sizeof(COST ) - 1UL)));
    if ((unsigned long )start == (unsigned long )(words)) {
      len = first_indent;
    } else {
      len = other_indent;
    }
    w = start;
    len += (int )w->length;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      w ++;
      tmp = line_cost(w, len);
      wcost = tmp + w->best_cost;
      }
      if ((unsigned long )start == (unsigned long )(words)) {
        if (last_line_length > 0) {
          wcost += ((COST )((len - last_line_length) * 10) * (COST )((len - last_line_length) * 10)) / 2L;
        }
      }
      if (wcost < best) {
        best = wcost;
        start->next_break = w;
        start->line_length = (short )len;
      }
      len += (int )(w - 1)->space + (int )w->length;
      if (! (len < max_width)) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    tmp___0 = base_cost(start);
    start->best_cost = best + tmp___0;
    start --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  word_limit->length = (short )saved_length;
  return;
}
}
static COST base_cost(WORD *this ) 
{ 
  register COST cost ;

  {
  cost = 4900L;
  if ((unsigned long )this > (unsigned long )(words)) {
    if ((this - 1)->period) {
      if ((this - 1)->final) {
        cost -= 2500L;
      } else {
        cost += 360000L;
      }
    } else { //Added block
    if ((this - 1)->punct) {
      cost -= 1600L;
    } else { //Added block
    if ((unsigned long )this > (unsigned long )(words + 1)) {
      if ((this - 2)->final) {
        cost += 40000L / (COST )((int )(this - 1)->length + 2);
      }
    }
    }
    }
  }
  if (this->paren) {
    cost -= 1600L;
  } else { //Added block
  if (this->final) {
    cost += 22500L / (COST )((int )this->length + 2);
  }
  }
  return (cost);
}
}
static COST line_cost(WORD *next , int len ) 
{ 
  register int n ;
  register COST cost ;

  {
  if ((unsigned long )next == (unsigned long )word_limit) {
    return ((COST )0);
  }
  n = best_width - len;
  cost = (COST )(n * 10) * (COST )(n * 10);
  if ((unsigned long )next->next_break != (unsigned long )word_limit) {
    n = len - (int )next->line_length;
    cost += ((COST )(n * 10) * (COST )(n * 10)) / 2L;
  }
  return (cost);
}
}
static void put_paragraph(WORD *finish ) 
{ 
  register WORD *w ;

  {
  {
  put_line(words, first_indent);
  w = words[0].next_break;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )w != (unsigned long )finish)) {
      goto while_break;
    }
    {
    put_line(w, other_indent);
    w = w->next_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void put_line(WORD *w , int indent ) 
{ 
  register WORD *endline ;

  {
  {
  out_column = 0;
  put_space(indent);
  endline = w->next_break - 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )w != (unsigned long )endline)) {
      goto while_break;
    }
    {
    put_word(w);
    put_space((int )w->space);
    w ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  put_word(w);
  last_line_length = out_column;
  _IO_putc('\n', outfile);
  }
  return;
}
}
static void put_word(WORD *w ) 
{ 
  register char const   *s ;
  register int n ;
  char const   *tmp ;

  {
  s = w->text;
  n = (int )w->length;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (n != 0)) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    _IO_putc((int )*tmp, outfile);
    n --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  out_column += (int )w->length;
  return;
}
}
static void put_space(int space ) 
{ 
  int tmp ;

  {
  out_column += space;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = space;
    space --;
    if (! tmp) {
      goto while_break;
    }
    {
    _IO_putc(' ', outfile);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static struct open_file *open_files  =    (struct open_file *)((void *)0);
static void do_ck_fclose(FILE *fp ) ;
void panic(char const   *str  , ...) 
{ 
  va_list iggy ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: ", myname);
  __builtin_va_start(iggy, str);
  vfprintf((FILE * __restrict  )stdout, (char const   * __restrict  )str, iggy);
  __builtin_va_end(iggy);
  _IO_putc('\n', stdout);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! open_files) {
      goto while_break;
    }
    if (open_files->temp) {
      {
      tmp = fileno(open_files->fp);
      fd = tmp;
      fclose(open_files->fp);
      tmp___0 = __errno_location();
      *tmp___0 = 0;
      unlink((char const   *)open_files->name);
      tmp___3 = __errno_location();
      }
      if (*tmp___3 != 0) {
        {
        tmp___1 = __errno_location();
        tmp___2 = strerror(*tmp___1);
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"cannot remove %s: %s",
                open_files->name, tmp___2);
        }
      }
    }
    open_files = open_files->link;
  }
  while_break: /* CIL Label */ ;
  }
  {
  exit(4);
  }
}
}
static char const   *utils_fp_name(FILE *fp ) ;
static char const   *utils_fp_name(FILE *fp ) 
{ 
  struct open_file *p ;

  {
  p = open_files;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    if ((unsigned long )p->fp == (unsigned long )fp) {
      return ((char const   *)p->name);
    }
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )fp == (unsigned long )stdin) {
    return ("stdin");
  } else { //Added block
  if ((unsigned long )fp == (unsigned long )stdout) {
    return ("stdout");
  } else { //Added block
  if ((unsigned long )fp == (unsigned long )stdout) {
    return ("stderr");
  }
  }
  }
  return ("<unknown>");
}
}
FILE *ck_fopen(char const   *name , char const   *mode , _Bool fail ) 
{ 
  FILE *fp ;
  struct open_file *p ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
  fp = fopen((char const   * __restrict  )name, (char const   * __restrict  )mode);
  }
  if (! fp) {
    if (fail) {
      {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      panic("couldn\'t open file %s: %s", name, tmp___0);
      }
    }
    return ((FILE *)((void *)0));
  }
  p = open_files;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    if ((unsigned long )fp == (unsigned long )p->fp) {
      {
      ck_free((void *)p->name);
      }
      goto while_break;
    }
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
  if (! p) {
    {
    tmp___1 = ck_malloc(sizeof(struct open_file ));
    p = (struct open_file *)tmp___1;
    p->link = open_files;
    open_files = p;
    }
  }
  {
  p->name = ck_strdup(name);
  p->fp = fp;
  p->temp = 0U;
  }
  return (fp);
}
}
FILE *ck_mkstemp(char **p_filename , char *tmpdir , char *base ) 
{ 
  char *template ;
  FILE *fp ;
  int fd ;
  struct open_file *p ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
    {
    tmpdir = getenv("TMPDIR");
    }
  }
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
    {
    tmpdir = getenv("TMP");
    }
    if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
      tmpdir = (char *)"/tmp";
    }
  }
  {
  tmp = strlen((char const   *)tmpdir);
  tmp___0 = strlen((char const   *)base);
  tmp___1 = xmalloc((tmp + tmp___0) + 8UL);
  template = (char *)tmp___1;
  sprintf((char * __restrict  )template, (char const   * __restrict  )"%s/%sXXXXXX",
          tmpdir, base);
  fd = mkstemp(template);
  }
  if (fd == -1) {
    {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    panic("couldn\'t open temporary file %s: %s", template, tmp___3);
    }
  }
  {
  *p_filename = template;
  fp = fdopen(fd, "w");
  tmp___4 = ck_malloc(sizeof(struct open_file ));
  p = (struct open_file *)tmp___4;
  p->name = ck_strdup((char const   *)template);
  p->fp = fp;
  p->temp = 1U;
  p->link = open_files;
  open_files = p;
  }
  return (fp);
}
}
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;

  {
  {
  clearerr(stream);
  }
  if (size) {
    {
    tmp___3 = fwrite((void const   * __restrict  )ptr, size, nmemb, (FILE * __restrict  )stream);
    }
    if (tmp___3 != nmemb) {
      {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      tmp___1 = utils_fp_name(stream);
      }
      if (nmemb == 1UL) {
        tmp___2 = "couldn\'t write %d item to %s: %s";
      } else {
        tmp___2 = "couldn\'t write %d items to %s: %s";
      }
      {
      panic(tmp___2, nmemb, tmp___1, tmp___0);
      }
    }
  }
  return;
}
}
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
  clearerr(stream);
  }
  if (size) {
    {
    nmemb = fread((void * __restrict  )ptr, size, nmemb, (FILE * __restrict  )stream);
    }
    if (nmemb <= 0UL) {
      {
      tmp___2 = ferror(stream);
      }
      if (tmp___2) {
        {
        tmp = __errno_location();
        tmp___0 = strerror(*tmp);
        tmp___1 = utils_fp_name(stream);
        panic("read error on %s: %s", tmp___1, tmp___0);
        }
      }
    }
  }
  return (nmemb);
}
}
size_t getline_local(char **lineptr , size_t *n , FILE *stream ) 
{ 
  char *line___0 ;
  char *p ;
  long size ;
  long copy ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long len ;
  register int c ;
  int tmp___3 ;
  char *tmp___4 ;
  char tmp___5 ;
  void *tmp___6 ;

  {
  if ((unsigned long )lineptr == (unsigned long )((void *)0)) {
    {
    tmp = __errno_location();
    *tmp = 22;
    }
    return ((size_t )-1);
  } else { //Added block
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
    tmp = __errno_location();
    *tmp = 22;
    }
    return ((size_t )-1);
  }
  }
  {
  tmp___0 = ferror(stream);
  }
  if (tmp___0) {
    return ((size_t )-1);
  }
  if ((unsigned long )*lineptr == (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if (*n < 2UL) {
    _L: 
    if (! *lineptr) {
      {
      tmp___1 = malloc((size_t )255);
      line___0 = (char *)tmp___1;
      }
    } else {
      {
      tmp___2 = realloc((void *)*lineptr, (size_t )255);
      line___0 = (char *)tmp___2;
      }
    }
    if ((unsigned long )line___0 == (unsigned long )((void *)0)) {
      return ((size_t )-1);
    }
    *lineptr = line___0;
    *n = (size_t )255;
  }
  }
  line___0 = *lineptr;
  size = (long )*n;
  copy = size;
  p = line___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      copy --;
      if (! (copy > 0L)) {
        goto while_break___0;
      }
      {
      tmp___3 = _IO_getc(stream);
      c = tmp___3;
      }
      if (c == -1) {
        goto lose;
      } else {
        tmp___4 = p;
        p ++;
        tmp___5 = (char )c;
        *tmp___4 = tmp___5;
        if ((int )tmp___5 == 10) {
          goto win;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    len = p - line___0;
    size *= 2L;
    tmp___6 = realloc((void *)line___0, (size_t )size);
    line___0 = (char *)tmp___6;
    }
    if ((unsigned long )line___0 == (unsigned long )((void *)0)) {
      goto lose;
    }
    *lineptr = line___0;
    *n = (size_t )size;
    p = line___0 + len;
    copy = size - len;
  }
  while_break: /* CIL Label */ ;
  }
  lose: 
  if ((unsigned long )p == (unsigned long )*lineptr) {
    return ((size_t )-1);
  }
  win: 
  *p = (char )'\000';
  return ((size_t )(p - *lineptr));
}
}
size_t ck_getline(char **text , size_t *buflen , FILE *stream ) 
{ 
  int result ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp___0 = ferror(stream);
  }
  if (! tmp___0) {
    {
    tmp = getline_local(text, buflen, stream);
    result = (int )tmp;
    }
  }
  {
  tmp___4 = ferror(stream);
  }
  if (tmp___4) {
    {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    tmp___3 = utils_fp_name(stream);
    panic("read error on %s: %s", tmp___3, tmp___2);
    }
  }
  return ((size_t )result);
}
}
void ck_fflush(FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
  clearerr(stream);
  tmp___2 = fflush(stream);
  }
  if (tmp___2 == -1) {
    {
    tmp___3 = __errno_location();
    }
    if (*tmp___3 != 9) {
      {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      tmp___1 = utils_fp_name(stream);
      panic("couldn\'t flush %s: %s", tmp___1, tmp___0);
      }
    }
  }
  return;
}
}
void ck_fclose(FILE *stream ) 
{ 
  struct open_file r ;
  struct open_file *prev ;
  struct open_file *cur ;

  {
  r.link = open_files;
  prev = & r;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    cur = prev->link;
    if (! cur) {
      goto while_break;
    }
    if (! stream) {
      {
      do_ck_fclose(cur->fp);
      prev->link = cur->link;
      ck_free((void *)cur->name);
      ck_free((void *)cur);
      }
    } else { //Added block
    if ((unsigned long )stream == (unsigned long )cur->fp) {
      {
      do_ck_fclose(cur->fp);
      prev->link = cur->link;
      ck_free((void *)cur->name);
      ck_free((void *)cur);
      }
    } else {
      prev = cur;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  open_files = r.link;
  if (! stream) {
    {
    do_ck_fclose(stdout);
    do_ck_fclose(stdout);
    }
  }
  return;
}
}
static void do_ck_fclose(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
  ck_fflush(fp);
  clearerr(fp);
  tmp___2 = fclose(fp);
  }
  if (tmp___2 == -1) {
    {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    tmp___1 = utils_fp_name(fp);
    panic("couldn\'t close %s: %s", tmp___1, tmp___0);
    }
  }
  return;
}
}
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) 
{ 
  int rd ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
  {
  tmp = rename(from, to);
  rd = tmp;
  }
  if (rd != -1) {
    return;
  }
  if (unlink_if_fail) {
    {
    tmp___0 = __errno_location();
    save_errno = *tmp___0;
    tmp___1 = __errno_location();
    *tmp___1 = 0;
    unlink(unlink_if_fail);
    tmp___4 = __errno_location();
    }
    if (*tmp___4 != 0) {
      {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      panic("cannot remove %s: %s", unlink_if_fail, tmp___3);
      }
    }
    {
    tmp___5 = __errno_location();
    *tmp___5 = save_errno;
    }
  }
  {
  tmp___6 = __errno_location();
  tmp___7 = strerror(*tmp___6);
  panic("cannot rename %s: %s", from, tmp___7);
  }
  return;
}
}
void *ck_malloc(size_t size ) 
{ 
  void *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
  if (size) {
    tmp = size;
  } else {
    tmp = (size_t )1;
  }
  {
  tmp___0 = calloc((size_t )1, tmp);
  ret = tmp___0;
  }
  if (! ret) {
    {
    panic("couldn\'t allocate memory");
    }
  }
  return (ret);
}
}
void *xmalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
  tmp = ck_malloc(size);
  }
  return (tmp);
}
}
void *ck_realloc(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  if (size == 0UL) {
    {
    ck_free(ptr);
    }
    return ((void *)0);
  }
  if (! ptr) {
    {
    tmp = ck_malloc(size);
    }
    return (tmp);
  }
  {
  ret = realloc(ptr, size);
  }
  if (! ret) {
    {
    panic("couldn\'t re-allocate memory");
    }
  }
  return (ret);
}
}
char *ck_strdup(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp = strlen(str);
  tmp___0 = ck_malloc((tmp + 1UL) * sizeof(char ));
  ret = (char *)tmp___0;
  tmp___1 = strcpy((char * __restrict  )ret, (char const   * __restrict  )str);
  }
  return (tmp___1);
}
}
void *ck_memdup(void const   *buf , size_t len ) 
{ 
  void *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  tmp = ck_malloc(len);
  ret = tmp;
  tmp___0 = memmove((void * __restrict  )ret, (void const   * __restrict  )buf, len);
  }
  return (tmp___0);
}
}
void ck_free(void *ptr ) 
{ 


  {
  if (ptr) {
    {
    free(ptr);
    }
  }
  return;
}
}
struct buffer *init_buffer(void) 
{ 
  struct buffer *b___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  tmp = ck_malloc(sizeof(struct buffer ));
  b___0 = (struct buffer *)tmp;
  tmp___0 = ck_malloc(50UL * sizeof(char ));
  b___0->b = (char *)tmp___0;
  b___0->allocated = (size_t )50;
  b___0->length = (size_t )0;
  }
  return (b___0);
}
}
char *get_buffer(struct buffer *b___0 ) 
{ 


  {
  return (b___0->b);
}
}
size_t size_buffer(struct buffer *b___0 ) 
{ 


  {
  return (b___0->length);
}
}
static void resize_buffer(struct buffer *b___0 , size_t newlen ) ;
static void resize_buffer(struct buffer *b___0 , size_t newlen ) 
{ 
  char *try ;
  size_t alen ;
  void *tmp ;
  void *tmp___0 ;

  {
  try = (char *)((void *)0);
  alen = b___0->allocated;
  if (newlen <= alen) {
    return;
  }
  alen *= 2UL;
  if (newlen < alen) {
    {
    tmp = realloc((void *)b___0->b, alen);
    try = (char *)tmp;
    }
  }
  if (! try) {
    {
    alen = newlen;
    tmp___0 = ck_realloc((void *)b___0->b, alen * sizeof(char ));
    try = (char *)tmp___0;
    }
  }
  b___0->allocated = alen;
  b___0->b = try;
  return;
}
}
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) 
{ 
  char *result ;
  void *tmp ;

  {
  if (b___0->allocated - b___0->length < n) {
    {
    resize_buffer(b___0, b___0->length + n);
    }
  }
  {
  tmp = memmove((void * __restrict  )(b___0->b + b___0->length), (void const   * __restrict  )p,
                n);
  result = (char *)tmp;
  b___0->length += n;
  }
  return (result);
}
}
char *add1_buffer(struct buffer *b___0 , int c ) 
{ 
  char *result ;
  size_t tmp ;

  {
  if (c != -1) {
    if (b___0->allocated - b___0->length < 1UL) {
      {
      resize_buffer(b___0, b___0->length + 1UL);
      }
    }
    tmp = b___0->length;
    (b___0->length) ++;
    result = b___0->b + tmp;
    *result = (char )c;
    return (result);
  }
  return ((char *)((void *)0));
}
}
void free_buffer(struct buffer *b___0 ) 
{ 


  {
  if (b___0) {
    {
    ck_free((void *)b___0->b);
    }
  }
  {
  ck_free((void *)b___0);
  }
  return;
}
}
void initialize_mbcs(void) 
{ 


  {
  mb_cur_max = 1;
  return;
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
char const   __re_error_msgid[369] ;
size_t const   __re_error_msgid_idx[17] ;
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , int new_buf_len ) ;
static void build_upper_buffer(re_string_t *pstr ) ;
static void re_string_translate_buffer(re_string_t *pstr ) ;
static unsigned int re_string_context_at(re_string_t const   *input , int idx , int eflags )  __attribute__((__pure__)) ;
__inline static void bitset_not(bitset_word_t *set ) 
{ 
  int bitset_i ;

  {
  bitset_i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )bitset_i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
      goto while_break;
    }
    *(set + bitset_i) = ~ *(set + bitset_i);
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void bitset_merge(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
  bitset_i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )bitset_i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
      goto while_break;
    }
    *(dest + bitset_i) |= *(src + bitset_i);
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void re_string_construct_common(char const   *str , int len , re_string_t *pstr ,
                                       unsigned char *trans , int icase , re_dfa_t const   *dfa ) ;
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int hash ) ;
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , unsigned int hash ) ;
static reg_errcode_t re_string_allocate(re_string_t *pstr , char const   *str , int len ,
                                        int init_len , unsigned char *trans , int icase ,
                                        re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  int init_buf_len ;
  long tmp ;

  {
  if (init_len < (int )dfa->mb_cur_max) {
    init_len = (int )dfa->mb_cur_max;
  }
  if (len + 1 < init_len) {
    init_buf_len = len + 1;
  } else {
    init_buf_len = init_len;
  }
  {
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
  ret = re_string_realloc_buffers(pstr, init_buf_len);
  tmp = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  if (tmp) {
    return (ret);
  }
  pstr->word_char = (re_const_bitset_ptr_t )(dfa->word_char);
  pstr->word_ops_used = (unsigned char )dfa->word_ops_used;
  if (pstr->mbs_allocated) {
    pstr->mbs = pstr->mbs;
  } else {
    pstr->mbs = (unsigned char *)str;
  }
  if (pstr->mbs_allocated) {
    pstr->valid_len = 0;
  } else { //Added block
  if (dfa->mb_cur_max > 1) {
    pstr->valid_len = 0;
  } else {
    pstr->valid_len = len;
  }
  }
  pstr->valid_raw_len = pstr->valid_len;
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_string_construct(re_string_t *pstr , char const   *str , int len ,
                                         unsigned char *trans , int icase , re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  long tmp ;

  {
  {
  memset((void *)pstr, '\000', sizeof(re_string_t ));
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
  }
  if (len > 0) {
    {
    ret = re_string_realloc_buffers(pstr, len + 1);
    tmp = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    if (tmp) {
      return (ret);
    }
  }
  if (pstr->mbs_allocated) {
    pstr->mbs = pstr->mbs;
  } else {
    pstr->mbs = (unsigned char *)str;
  }
  if (icase) {
    {
    build_upper_buffer(pstr);
    }
  } else { //Added block
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
    {
    re_string_translate_buffer(pstr);
    }
  } else {
    pstr->valid_len = pstr->bufs_len;
    pstr->valid_raw_len = pstr->bufs_len;
  }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , int new_buf_len ) 
{ 
  unsigned char *new_mbs ;
  void *tmp ;
  long tmp___0 ;

  {
  if (pstr->mbs_allocated) {
    {
    tmp = realloc((void *)pstr->mbs, (unsigned long )new_buf_len * sizeof(unsigned char ));
    new_mbs = (unsigned char *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_mbs == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      return ((reg_errcode_t )12);
    }
    pstr->mbs = new_mbs;
  }
  pstr->bufs_len = new_buf_len;
  return ((reg_errcode_t )0);
}
}
static void re_string_construct_common(char const   *str , int len , re_string_t *pstr ,
                                       unsigned char *trans , int icase , re_dfa_t const   *dfa ) 
{ 
  int tmp ;

  {
  pstr->raw_mbs = (unsigned char const   *)str;
  pstr->len = len;
  pstr->raw_len = len;
  pstr->trans = trans;
  if (icase) {
    pstr->icase = (unsigned char)1;
  } else {
    pstr->icase = (unsigned char)0;
  }
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
    tmp = 1;
  } else { //Added block
  if (icase) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  pstr->mbs_allocated = (unsigned char )tmp;
  pstr->mb_cur_max = (int )dfa->mb_cur_max;
  pstr->is_utf8 = (unsigned char )dfa->is_utf8;
  pstr->map_notascii = (unsigned char )dfa->map_notascii;
  pstr->stop = pstr->len;
  pstr->raw_stop = pstr->stop;
  return;
}
}
static void build_upper_buffer(re_string_t *pstr ) 
{ 
  int char_idx ;
  int end_idx ;
  int ch ;
  long tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  if (pstr->bufs_len > pstr->len) {
    end_idx = pstr->len;
  } else {
    end_idx = pstr->bufs_len;
  }
  char_idx = pstr->valid_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (char_idx < end_idx)) {
      goto while_break;
    }
    {
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + char_idx));
    tmp = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                           0L);
    }
    if (tmp) {
      ch = (int )*(pstr->trans + ch);
    }
    {
    tmp___1 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___1 + ch) & 512) {
      {
      tmp___0 = toupper(ch);
      *(pstr->mbs + char_idx) = (unsigned char )tmp___0;
      }
    } else {
      *(pstr->mbs + char_idx) = (unsigned char )ch;
    }
    char_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  pstr->valid_len = char_idx;
  pstr->valid_raw_len = char_idx;
  return;
}
}
static void re_string_translate_buffer(re_string_t *pstr ) 
{ 
  int buf_idx ;
  int end_idx ;
  int ch ;

  {
  if (pstr->bufs_len > pstr->len) {
    end_idx = pstr->len;
  } else {
    end_idx = pstr->bufs_len;
  }
  buf_idx = pstr->valid_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (buf_idx < end_idx)) {
      goto while_break;
    }
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + buf_idx));
    *(pstr->mbs + buf_idx) = *(pstr->trans + ch);
    buf_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  pstr->valid_len = buf_idx;
  pstr->valid_raw_len = buf_idx;
  return;
}
}
static reg_errcode_t re_string_reconstruct(re_string_t *pstr , int idx , int eflags ) 
{ 
  int offset ;
  long tmp ;
  long tmp___0 ;
  int c ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
  offset = idx - pstr->raw_mbs_idx;
  tmp = __builtin_expect((long )(offset < 0), 0L);
  }
  if (tmp) {
    pstr->len = pstr->raw_len;
    pstr->stop = pstr->raw_stop;
    pstr->valid_len = 0;
    pstr->raw_mbs_idx = 0;
    pstr->valid_raw_len = 0;
    pstr->offsets_needed = (unsigned char)0;
    if (eflags & 1) {
      pstr->tip_context = (unsigned int )((1 << 1) << 1);
    } else {
      pstr->tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
    }
    if (! pstr->mbs_allocated) {
      pstr->mbs = (unsigned char *)pstr->raw_mbs;
    }
    offset = idx;
  }
  {
  tmp___4 = __builtin_expect((long )(offset != 0), 1L);
  }
  if (tmp___4) {
    {
    tmp___2 = __builtin_expect((long )(offset < pstr->valid_raw_len), 1L);
    }
    if (tmp___2) {
      {
      pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, offset - 1,
                                               eflags);
      tmp___0 = __builtin_expect((long )pstr->mbs_allocated, 0L);
      }
      if (tmp___0) {
        {
        memmove((void * __restrict  )pstr->mbs, (void const   * __restrict  )(pstr->mbs + offset),
                (size_t )(pstr->valid_len - offset));
        }
      }
      pstr->valid_len -= offset;
      pstr->valid_raw_len -= offset;
    } else {
      pstr->valid_len = 0;
      pstr->valid_raw_len = 0;
      c = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + offset) - 1));
      if (pstr->trans) {
        c = (int )*(pstr->trans + c);
      }
      if (*(pstr->word_char + (unsigned long )c / (sizeof(bitset_word_t ) * 8UL)) & (unsigned long const   )(1UL << (unsigned long )c % (sizeof(bitset_word_t ) * 8UL))) {
        pstr->tip_context = 1U;
      } else {
        if (c == 10) {
          if (pstr->newline_anchor) {
            tmp___1 = 1 << 1;
          } else {
            tmp___1 = 0;
          }
        } else {
          tmp___1 = 0;
        }
        pstr->tip_context = (unsigned int )tmp___1;
      }
    }
    {
    tmp___3 = __builtin_expect((long )pstr->mbs_allocated, 0L);
    }
    if (! tmp___3) {
      pstr->mbs += offset;
    }
  }
  {
  pstr->raw_mbs_idx = idx;
  pstr->len -= offset;
  pstr->stop -= offset;
  tmp___5 = __builtin_expect((long )pstr->mbs_allocated, 0L);
  }
  if (tmp___5) {
    if (pstr->icase) {
      {
      build_upper_buffer(pstr);
      }
    } else { //Added block
    if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
      {
      re_string_translate_buffer(pstr);
      }
    }
    }
  } else {
    pstr->valid_len = pstr->len;
  }
  pstr->cur_idx = 0;
  return ((reg_errcode_t )0);
}
}
static unsigned char __attribute__((__pure__))  re_string_peek_byte_case(re_string_t const   *pstr ,
                                                                         int idx ) 
{ 
  int ch ;
  int off ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
  if (tmp) {
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (int const   )idx)));
  }
  off = (int )(pstr->cur_idx + (int const   )idx);
  ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + (int const   )off));
  return ((unsigned char __attribute__((__pure__))  )ch);
}
}
static unsigned char __attribute__((__pure__))  re_string_fetch_byte_case(re_string_t *pstr ) 
{ 
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___0 = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
  if (tmp___0) {
    tmp = pstr->cur_idx;
    (pstr->cur_idx) ++;
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp));
  }
  tmp___1 = pstr->cur_idx;
  (pstr->cur_idx) ++;
  return ((unsigned char __attribute__((__pure__))  )*(pstr->raw_mbs + (pstr->raw_mbs_idx + tmp___1)));
}
}
static void re_string_destruct(re_string_t *pstr ) 
{ 


  {
  if (pstr->mbs_allocated) {
    {
    free((void *)pstr->mbs);
    }
  }
  return;
}
}
static unsigned int re_string_context_at(re_string_t const   *input , int idx , int eflags )  __attribute__((__pure__)) ;
static unsigned int re_string_context_at(re_string_t const   *input , int idx , int eflags ) 
{ 
  int c ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = __builtin_expect((long )(idx < 0), 0L);
  }
  if (tmp) {
    return ((unsigned int )input->tip_context);
  }
  {
  tmp___1 = __builtin_expect((long )(idx == (int )input->len), 0L);
  }
  if (tmp___1) {
    if (eflags & (1 << 1)) {
      tmp___0 = ((1 << 1) << 1) << 1;
    } else {
      tmp___0 = (1 << 1) | (((1 << 1) << 1) << 1);
    }
    return ((unsigned int )tmp___0);
  }
  c = (int )*(input->mbs + idx);
  if (*(input->word_char + (unsigned long )c / (sizeof(bitset_word_t ) * 8UL)) & (unsigned long const   )(1UL << (unsigned long )c % (sizeof(bitset_word_t ) * 8UL))) {
    return (1U);
  }
  if (c == 10) {
    if (input->newline_anchor) {
      tmp___2 = 1 << 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return ((unsigned int )tmp___2);
}
}
static reg_errcode_t re_node_set_alloc(re_node_set *set , int size ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
  set->alloc = size;
  set->nelem = 0;
  tmp = malloc((unsigned long )size * sizeof(int ));
  set->elems = (int *)tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    return ((reg_errcode_t )12);
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_node_set_init_1(re_node_set *set , int elem ) 
{ 
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  set->alloc = 1;
  set->nelem = 1;
  tmp = malloc(sizeof(int ));
  set->elems = (int *)tmp;
  tmp___1 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___1) {
    tmp___0 = 0;
    set->nelem = tmp___0;
    set->alloc = tmp___0;
    return ((reg_errcode_t )12);
  }
  *(set->elems + 0) = elem;
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_node_set_init_2(re_node_set *set , int elem1 , int elem2 ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
  set->alloc = 2;
  tmp = malloc(2UL * sizeof(int ));
  set->elems = (int *)tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    return ((reg_errcode_t )12);
  }
  if (elem1 == elem2) {
    set->nelem = 1;
    *(set->elems + 0) = elem1;
  } else {
    set->nelem = 2;
    if (elem1 < elem2) {
      *(set->elems + 0) = elem1;
      *(set->elems + 1) = elem2;
    } else {
      *(set->elems + 0) = elem2;
      *(set->elems + 1) = elem1;
    }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_node_set_init_copy(re_node_set *dest , re_node_set const   *src ) 
{ 
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  dest->nelem = (int )src->nelem;
  if (src->nelem > 0) {
    {
    dest->alloc = dest->nelem;
    tmp = malloc((unsigned long )dest->alloc * sizeof(int ));
    dest->elems = (int *)tmp;
    tmp___1 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___1) {
      tmp___0 = 0;
      dest->nelem = tmp___0;
      dest->alloc = tmp___0;
      return ((reg_errcode_t )12);
    }
    {
    memmove((void * __restrict  )dest->elems, (void const   * __restrict  )src->elems,
            (unsigned long )src->nelem * sizeof(int ));
    }
  } else {
    {
    memset((void *)dest, '\000', sizeof(re_node_set ));
    }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_node_set_add_intersect(re_node_set *dest , re_node_set const   *src1 ,
                                               re_node_set const   *src2 ) 
{ 
  int i1 ;
  int i2 ;
  int is ;
  int id ;
  int delta ;
  int sbase ;
  int new_alloc ;
  int *new_elems ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (src1->nelem == 0) {
    return ((reg_errcode_t )0);
  } else { //Added block
  if (src2->nelem == 0) {
    return ((reg_errcode_t )0);
  }
  }
  if ((src1->nelem + src2->nelem) + (int const   )dest->nelem > (int const   )dest->alloc) {
    {
    new_alloc = (int )((src1->nelem + src2->nelem) + (int const   )dest->alloc);
    tmp = realloc((void *)dest->elems, (unsigned long )new_alloc * sizeof(int ));
    new_elems = (int *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      return ((reg_errcode_t )12);
    }
    dest->elems = new_elems;
    dest->alloc = new_alloc;
  }
  sbase = (dest->nelem + (int )src1->nelem) + (int )src2->nelem;
  i1 = (int )(src1->nelem - 1);
  i2 = (int )(src2->nelem - 1);
  id = dest->nelem - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (id >= 0) {
          if (! (*(dest->elems + id) > *(src1->elems + i1))) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        id --;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (id < 0) {
        sbase --;
        *(dest->elems + sbase) = *(src1->elems + i1);
      } else { //Added block
      if (*(dest->elems + id) != *(src1->elems + i1)) {
        sbase --;
        *(dest->elems + sbase) = *(src1->elems + i1);
      }
      }
      i1 --;
      if (i1 < 0) {
        goto while_break;
      } else {
        i2 --;
        if (i2 < 0) {
          goto while_break;
        }
      }
    } else { //Added block
    if (*(src1->elems + i1) < *(src2->elems + i2)) {
      i2 --;
      if (i2 < 0) {
        goto while_break;
      }
    } else {
      i1 --;
      if (i1 < 0) {
        goto while_break;
      }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  id = dest->nelem - 1;
  is = ((dest->nelem + (int )src1->nelem) + (int )src2->nelem) - 1;
  delta = (is - sbase) + 1;
  dest->nelem += delta;
  if (delta > 0) {
    if (id >= 0) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (*(dest->elems + is) > *(dest->elems + id)) {
          tmp___1 = delta;
          delta --;
          tmp___2 = is;
          is --;
          *(dest->elems + (id + tmp___1)) = *(dest->elems + tmp___2);
          if (delta == 0) {
            goto while_break___1;
          }
        } else {
          *(dest->elems + (id + delta)) = *(dest->elems + id);
          id --;
          if (id < 0) {
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
  memmove((void * __restrict  )dest->elems, (void const   * __restrict  )(dest->elems + sbase),
          (unsigned long )delta * sizeof(int ));
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_node_set_init_union(re_node_set *dest , re_node_set const   *src1 ,
                                            re_node_set const   *src2 ) 
{ 
  int i1 ;
  int i2 ;
  int id ;
  void *tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  reg_errcode_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned long )src1 != (unsigned long )((void *)0)) {
    if (src1->nelem > 0) {
      if ((unsigned long )src2 != (unsigned long )((void *)0)) {
        if (src2->nelem > 0) {
          {
          dest->alloc = (int )(src1->nelem + src2->nelem);
          tmp = malloc((unsigned long )dest->alloc * sizeof(int ));
          dest->elems = (int *)tmp;
          tmp___0 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                     0L);
          }
          if (tmp___0) {
            return ((reg_errcode_t )12);
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
    if ((unsigned long )src1 != (unsigned long )((void *)0)) {
      if (src1->nelem > 0) {
        {
        tmp___1 = re_node_set_init_copy(dest, src1);
        }
        return (tmp___1);
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((unsigned long )src2 != (unsigned long )((void *)0)) {
      if (src2->nelem > 0) {
        {
        tmp___2 = re_node_set_init_copy(dest, src2);
        }
        return (tmp___2);
      } else {
        {
        memset((void *)dest, '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
      memset((void *)dest, '\000', sizeof(re_node_set ));
      }
    }
    }
    return ((reg_errcode_t )0);
  }
  id = 0;
  i2 = id;
  i1 = i2;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i1 < (int )src1->nelem) {
      if (! (i2 < (int )src2->nelem)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
      tmp___3 = id;
      id ++;
      tmp___4 = i2;
      i2 ++;
      *(dest->elems + tmp___3) = *(src2->elems + tmp___4);
      goto __Cont;
    }
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
      i2 ++;
    }
    tmp___5 = id;
    id ++;
    tmp___6 = i1;
    i1 ++;
    *(dest->elems + tmp___5) = *(src1->elems + tmp___6);
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  if (i1 < (int )src1->nelem) {
    {
    memmove((void * __restrict  )(dest->elems + id), (void const   * __restrict  )(src1->elems + i1),
            (unsigned long )(src1->nelem - (int const   )i1) * sizeof(int ));
    id += (int )(src1->nelem - (int const   )i1);
    }
  } else { //Added block
  if (i2 < (int )src2->nelem) {
    {
    memmove((void * __restrict  )(dest->elems + id), (void const   * __restrict  )(src2->elems + i2),
            (unsigned long )(src2->nelem - (int const   )i2) * sizeof(int ));
    id += (int )(src2->nelem - (int const   )i2);
    }
  }
  }
  dest->nelem = id;
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t re_node_set_merge(re_node_set *dest , re_node_set const   *src ) 
{ 
  int is ;
  int id ;
  int sbase ;
  int delta ;
  int new_alloc ;
  int *new_buffer ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    return ((reg_errcode_t )0);
  } else { //Added block
  if (src->nelem == 0) {
    return ((reg_errcode_t )0);
  }
  }
  if (dest->alloc < 2 * (int )src->nelem + dest->nelem) {
    {
    new_alloc = 2 * (int )(src->nelem + (int const   )dest->alloc);
    tmp = realloc((void *)dest->elems, (unsigned long )new_alloc * sizeof(int ));
    new_buffer = (int *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_buffer == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      return ((reg_errcode_t )12);
    }
    dest->elems = new_buffer;
    dest->alloc = new_alloc;
  }
  {
  tmp___1 = __builtin_expect((long )(dest->nelem == 0), 0L);
  }
  if (tmp___1) {
    {
    dest->nelem = (int )src->nelem;
    memmove((void * __restrict  )dest->elems, (void const   * __restrict  )src->elems,
            (unsigned long )src->nelem * sizeof(int ));
    }
    return ((reg_errcode_t )0);
  }
  sbase = dest->nelem + 2 * (int )src->nelem;
  is = (int )(src->nelem - 1);
  id = dest->nelem - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (is >= 0) {
      if (! (id >= 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (*(dest->elems + id) == *(src->elems + is)) {
      is --;
      id --;
    } else { //Added block
    if (*(dest->elems + id) < *(src->elems + is)) {
      sbase --;
      tmp___2 = is;
      is --;
      *(dest->elems + sbase) = *(src->elems + tmp___2);
    } else {
      id --;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (is >= 0) {
    {
    sbase -= is + 1;
    memmove((void * __restrict  )(dest->elems + sbase), (void const   * __restrict  )src->elems,
            (unsigned long )(is + 1) * sizeof(int ));
    }
  }
  id = dest->nelem - 1;
  is = (dest->nelem + 2 * (int )src->nelem) - 1;
  delta = (is - sbase) + 1;
  if (delta == 0) {
    return ((reg_errcode_t )0);
  }
  dest->nelem += delta;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (*(dest->elems + is) > *(dest->elems + id)) {
      tmp___3 = delta;
      delta --;
      tmp___4 = is;
      is --;
      *(dest->elems + (id + tmp___3)) = *(dest->elems + tmp___4);
      if (delta == 0) {
        goto while_break___0;
      }
    } else {
      *(dest->elems + (id + delta)) = *(dest->elems + id);
      id --;
      if (id < 0) {
        {
        memmove((void * __restrict  )dest->elems, (void const   * __restrict  )(dest->elems + sbase),
                (unsigned long )delta * sizeof(int ));
        }
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static int re_node_set_insert(re_node_set *set , int elem ) 
{ 
  int idx ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int *new_elems ;
  void *tmp___2 ;
  long tmp___3 ;

  {
  if (set->alloc == 0) {
    {
    tmp = re_node_set_init_1(set, elem);
    tmp___0 = __builtin_expect((long )((unsigned int )tmp == 0U), 1L);
    }
    if (tmp___0) {
      return (1);
    } else {
      return (-1);
    }
  }
  {
  tmp___1 = __builtin_expect((long )set->nelem, 0L);
  }
  if (tmp___1 == 0L) {
    *(set->elems + 0) = elem;
    (set->nelem) ++;
    return (1);
  }
  if (set->alloc == set->nelem) {
    {
    set->alloc *= 2;
    tmp___2 = realloc((void *)set->elems, (unsigned long )set->alloc * sizeof(int ));
    new_elems = (int *)tmp___2;
    tmp___3 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___3) {
      return (-1);
    }
    set->elems = new_elems;
  }
  if (elem < *(set->elems + 0)) {
    idx = 0;
    idx = set->nelem;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (idx > 0)) {
        goto while_break;
      }
      *(set->elems + idx) = *(set->elems + (idx - 1));
      idx --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    idx = set->nelem;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (*(set->elems + (idx - 1)) > elem)) {
        goto while_break___0;
      }
      *(set->elems + idx) = *(set->elems + (idx - 1));
      idx --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  *(set->elems + idx) = elem;
  (set->nelem) ++;
  return (1);
}
}
static int re_node_set_insert_last(re_node_set *set , int elem ) 
{ 
  int *new_elems ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  if (set->alloc == set->nelem) {
    {
    set->alloc = (set->alloc + 1) * 2;
    tmp = realloc((void *)set->elems, (unsigned long )set->alloc * sizeof(int ));
    new_elems = (int *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      return (-1);
    }
    set->elems = new_elems;
  }
  tmp___1 = set->nelem;
  (set->nelem) ++;
  *(set->elems + tmp___1) = elem;
  return (1);
}
}
static int __attribute__((__pure__))  re_node_set_compare(re_node_set const   *set1 ,
                                                          re_node_set const   *set2 ) 
{ 
  int i ;

  {
  if ((unsigned long )set1 == (unsigned long )((void *)0)) {
    return ((int __attribute__((__pure__))  )0);
  } else { //Added block
  if ((unsigned long )set2 == (unsigned long )((void *)0)) {
    return ((int __attribute__((__pure__))  )0);
  } else { //Added block
  if (set1->nelem != set2->nelem) {
    return ((int __attribute__((__pure__))  )0);
  }
  }
  }
  i = (int )set1->nelem;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i --;
    if (! (i >= 0)) {
      goto while_break;
    }
    if (*(set1->elems + i) != *(set2->elems + i)) {
      return ((int __attribute__((__pure__))  )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((int __attribute__((__pure__))  )1);
}
}
static int __attribute__((__pure__))  re_node_set_contains(re_node_set const   *set ,
                                                           int elem ) 
{ 
  unsigned int idx ;
  unsigned int right ;
  unsigned int mid ;
  unsigned int tmp ;

  {
  if (set->nelem <= 0) {
    return ((int __attribute__((__pure__))  )0);
  }
  idx = 0U;
  right = (unsigned int )(set->nelem - 1);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (idx < right)) {
      goto while_break;
    }
    mid = (idx + right) / 2U;
    if (*(set->elems + mid) < elem) {
      idx = mid + 1U;
    } else {
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (*(set->elems + idx) == elem) {
    tmp = idx + 1U;
  } else {
    tmp = 0U;
  }
  return ((int __attribute__((__pure__))  )tmp);
}
}
static void re_node_set_remove_at(re_node_set *set , int idx ) 
{ 


  {
  if (idx < 0) {
    return;
  } else { //Added block
  if (idx >= set->nelem) {
    return;
  }
  }
  (set->nelem) --;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (idx < set->nelem)) {
      goto while_break;
    }
    *(set->elems + idx) = *(set->elems + (idx + 1));
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int re_dfa_add_node(re_dfa_t *dfa , re_token_t token ) 
{ 
  int type ;
  size_t new_nodes_alloc ;
  int *new_nexts ;
  int *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_token_t *new_nodes ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  size_t tmp___9 ;

  {
  {
  type = (int )token.type;
  tmp___8 = __builtin_expect((long )(dfa->nodes_len >= dfa->nodes_alloc), 0L);
  }
  if (tmp___8) {
    {
    new_nodes_alloc = dfa->nodes_alloc * 2UL;
    tmp = __builtin_expect((long )(new_nodes_alloc < dfa->nodes_alloc), 0L);
    }
    if (tmp) {
      return (-1);
    }
    {
    tmp___0 = realloc((void *)dfa->nodes, new_nodes_alloc * sizeof(re_token_t ));
    new_nodes = (re_token_t *)tmp___0;
    tmp___1 = __builtin_expect((long )((unsigned long )new_nodes == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___1) {
      return (-1);
    }
    {
    dfa->nodes = new_nodes;
    tmp___2 = realloc((void *)dfa->nexts, new_nodes_alloc * sizeof(int ));
    new_nexts = (int *)tmp___2;
    tmp___3 = realloc((void *)dfa->org_indices, new_nodes_alloc * sizeof(int ));
    new_indices = (int *)tmp___3;
    tmp___4 = realloc((void *)dfa->edests, new_nodes_alloc * sizeof(re_node_set ));
    new_edests = (re_node_set *)tmp___4;
    tmp___5 = realloc((void *)dfa->eclosures, new_nodes_alloc * sizeof(re_node_set ));
    new_eclosures = (re_node_set *)tmp___5;
    }
    if ((unsigned long )new_nexts == (unsigned long )((void *)0)) {
      tmp___6 = 1;
    } else { //Added block
    if ((unsigned long )new_indices == (unsigned long )((void *)0)) {
      tmp___6 = 1;
    } else { //Added block
    if ((unsigned long )new_edests == (unsigned long )((void *)0)) {
      tmp___6 = 1;
    } else { //Added block
    if ((unsigned long )new_eclosures == (unsigned long )((void *)0)) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
    }
    }
    }
    {
    tmp___7 = __builtin_expect((long )tmp___6, 0L);
    }
    if (tmp___7) {
      return (-1);
    }
    dfa->nexts = new_nexts;
    dfa->org_indices = new_indices;
    dfa->edests = new_edests;
    dfa->eclosures = new_eclosures;
    dfa->nodes_alloc = new_nodes_alloc;
  }
  {
  *(dfa->nodes + dfa->nodes_len) = token;
  (dfa->nodes + dfa->nodes_len)->constraint = 0U;
  *(dfa->nexts + dfa->nodes_len) = -1;
  memset((void *)(dfa->edests + dfa->nodes_len), '\000', sizeof(re_node_set ));
  memset((void *)(dfa->eclosures + dfa->nodes_len), '\000', sizeof(re_node_set ));
  tmp___9 = dfa->nodes_len;
  (dfa->nodes_len) ++;
  }
  return ((int )tmp___9);
}
}
__inline static unsigned int calc_state_hash(re_node_set const   *nodes , unsigned int context ) 
{ 
  unsigned int hash ;
  int i ;

  {
  hash = (unsigned int )nodes->nelem + context;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < (int )nodes->nelem)) {
      goto while_break;
    }
    hash += (unsigned int )*(nodes->elems + i);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (hash);
}
}
static re_dfastate_t *re_acquire_state(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                       re_node_set const   *nodes ) 
{ 
  unsigned int hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  int i ;
  long tmp ;
  re_dfastate_t *state ;
  int __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = __builtin_expect((long )(nodes->nelem == 0), 0L);
  }
  if (tmp) {
    *err = (reg_errcode_t )0;
    return ((re_dfastate_t *)((void *)0));
  }
  {
  hash = calc_state_hash(nodes, 0U);
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned int )dfa->state_hash_mask));
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < spot->num)) {
      goto while_break;
    }
    state = *(spot->array + i);
    if (hash != state->hash) {
      goto __Cont;
    }
    {
    tmp___0 = re_node_set_compare((re_node_set const   *)(& state->nodes), nodes);
    }
    if (tmp___0) {
      return (state);
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  new_state = create_ci_newstate(dfa, nodes, hash);
  tmp___1 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___1) {
    *err = (reg_errcode_t )12;
  }
  return (new_state);
}
}
static re_dfastate_t *re_acquire_state_context(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                               re_node_set const   *nodes , unsigned int context ) 
{ 
  unsigned int hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  int i ;
  re_dfastate_t *state ;
  int __attribute__((__pure__))  tmp ;
  long tmp___0 ;

  {
  if (nodes->nelem == 0) {
    *err = (reg_errcode_t )0;
    return ((re_dfastate_t *)((void *)0));
  }
  {
  hash = calc_state_hash(nodes, context);
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned int )dfa->state_hash_mask));
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < spot->num)) {
      goto while_break;
    }
    state = *(spot->array + i);
    if (state->hash == hash) {
      if (state->context == context) {
        {
        tmp = re_node_set_compare((re_node_set const   *)state->entrance_nodes, nodes);
        }
        if (tmp) {
          return (state);
        }
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  new_state = create_cd_newstate(dfa, nodes, context, hash);
  tmp___0 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    *err = (reg_errcode_t )12;
  }
  return (new_state);
}
}
static reg_errcode_t register_state(re_dfa_t const   *dfa , re_dfastate_t *newstate ,
                                    unsigned int hash ) 
{ 
  struct re_state_table_entry *spot ;
  reg_errcode_t err ;
  int i ;
  long tmp ;
  int elem ;
  int new_alloc ;
  re_dfastate_t **new_array ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
  newstate->hash = hash;
  err = re_node_set_alloc(& newstate->non_eps_nodes, newstate->nodes.nelem);
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp) {
    return ((reg_errcode_t )12);
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < newstate->nodes.nelem)) {
      goto while_break;
    }
    elem = *(newstate->nodes.elems + i);
    if (! ((unsigned int )(dfa->nodes + elem)->type & 8U)) {
      {
      re_node_set_insert_last(& newstate->non_eps_nodes, elem);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned int )dfa->state_hash_mask));
  tmp___2 = __builtin_expect((long )(spot->alloc <= spot->num), 0L);
  }
  if (tmp___2) {
    {
    new_alloc = 2 * spot->num + 2;
    tmp___0 = realloc((void *)spot->array, (unsigned long )new_alloc * sizeof(re_dfastate_t *));
    new_array = (re_dfastate_t **)tmp___0;
    tmp___1 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___1) {
      return ((reg_errcode_t )12);
    }
    spot->array = new_array;
    spot->alloc = new_alloc;
  }
  tmp___3 = spot->num;
  (spot->num) ++;
  *(spot->array + tmp___3) = newstate;
  return ((reg_errcode_t )0);
}
}
static void free_state(re_dfastate_t *state ) 
{ 


  {
  {
  free((void *)state->non_eps_nodes.elems);
  free((void *)state->inveclosure.elems);
  }
  if ((unsigned long )state->entrance_nodes != (unsigned long )(& state->nodes)) {
    {
    free((void *)(state->entrance_nodes)->elems);
    free((void *)state->entrance_nodes);
    }
  }
  {
  free((void *)state->nodes.elems);
  free((void *)state->word_trtable);
  free((void *)state->trtable);
  free((void *)state);
  }
  return;
}
}
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int hash ) 
{ 
  int i ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  long tmp___2 ;

  {
  {
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
  newstate = (re_dfastate_t *)tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    return ((re_dfastate_t *)((void *)0));
  }
  {
  err = re_node_set_init_copy(& newstate->nodes, nodes);
  tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___1) {
    {
    free((void *)newstate);
    }
    return ((re_dfastate_t *)((void *)0));
  }
  newstate->entrance_nodes = & newstate->nodes;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < (int )nodes->nelem)) {
      goto while_break;
    }
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
    type = node->type;
    if ((unsigned int )type == 1U) {
      if (! node->constraint) {
        goto __Cont;
      }
    }
    if ((unsigned int )type == 2U) {
      newstate->halt = 1U;
    } else { //Added block
    if ((unsigned int )type == 4U) {
      newstate->has_backref = 1U;
    } else { //Added block
    if ((unsigned int )type == 12U) {
      newstate->has_constraint = 1U;
    } else { //Added block
    if (node->constraint) {
      newstate->has_constraint = 1U;
    }
    }
    }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  err = register_state(dfa, newstate, hash);
  tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___2) {
    {
    free_state(newstate);
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
  return (newstate);
}
}
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , unsigned int hash ) 
{ 
  int i ;
  int nctx_nodes ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int constraint ;
  re_token_t *node ;
  re_token_type_t type ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
  nctx_nodes = 0;
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
  newstate = (re_dfastate_t *)tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    return ((re_dfastate_t *)((void *)0));
  }
  {
  err = re_node_set_init_copy(& newstate->nodes, nodes);
  tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___1) {
    {
    free((void *)newstate);
    }
    return ((re_dfastate_t *)((void *)0));
  }
  newstate->context = context;
  newstate->entrance_nodes = & newstate->nodes;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < (int )nodes->nelem)) {
      goto while_break;
    }
    constraint = 0U;
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
    type = node->type;
    if (node->constraint) {
      constraint = node->constraint;
    }
    if ((unsigned int )type == 1U) {
      if (! constraint) {
        goto __Cont;
      }
    }
    if ((unsigned int )type == 2U) {
      newstate->halt = 1U;
    } else { //Added block
    if ((unsigned int )type == 4U) {
      newstate->has_backref = 1U;
    } else { //Added block
    if ((unsigned int )type == 12U) {
      constraint = (unsigned int )node->opr.ctx_type;
    }
    }
    }
    if (constraint) {
      if ((unsigned long )newstate->entrance_nodes == (unsigned long )(& newstate->nodes)) {
        {
        tmp___2 = malloc(sizeof(re_node_set ));
        newstate->entrance_nodes = (re_node_set *)tmp___2;
        tmp___3 = __builtin_expect((long )((unsigned long )newstate->entrance_nodes == (unsigned long )((void *)0)),
                                   0L);
        }
        if (tmp___3) {
          {
          free_state(newstate);
          }
          return ((re_dfastate_t *)((void *)0));
        }
        {
        re_node_set_init_copy(newstate->entrance_nodes, nodes);
        nctx_nodes = 0;
        newstate->has_constraint = 1U;
        }
      }
      if (constraint & 1U) {
        if (! (context & 1U)) {
          {
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          nctx_nodes ++;
          }
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (constraint & 2U) {
        if (context & 1U) {
          {
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          nctx_nodes ++;
          }
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if (constraint & 16U) {
        if (! (context & (unsigned int )(1 << 1))) {
          {
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          nctx_nodes ++;
          }
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (constraint & 64U) {
        if (! (context & (unsigned int )((1 << 1) << 1))) {
          {
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
          nctx_nodes ++;
          }
        }
      }
      }
      }
      }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  err = register_state(dfa, newstate, hash);
  tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___4) {
    {
    free_state(newstate);
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
  return (newstate);
}
}
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) ;
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) ;
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) ;
static void free_workarea_compile(regex_t *preg ) ;
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) ;
static reg_errcode_t analyze(regex_t *preg ) ;
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) ;
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) ;
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) ;
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) ;
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) ;
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) ;
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) ;
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) ;
static int duplicate_node(re_dfa_t *dfa , int org_idx , unsigned int constraint ) ;
static int search_duplicated_node(re_dfa_t const   *dfa , int org_node , unsigned int constraint ) ;
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) ;
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , int node ,
                                        int root ) ;
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) ;
static int fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) ;
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) ;
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) ;
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) ;
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , int accept_hyphen ) ;
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) ;
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , unsigned char const   *name ) ;
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) ;
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , int non_match ,
                                      reg_errcode_t *err ) ;
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) ;
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) ;
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) ;
static void free_token(re_token_t *node ) ;
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) ;
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) ;
char const   __re_error_msgid[369]  = 
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
size_t const   __re_error_msgid_idx[17]  = 
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;

  {
  {
  bufp->no_sub = (unsigned int )(! (! (re_syntax_options & (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))));
  bufp->newline_anchor = 1U;
  ret = re_compile_internal(bufp, pattern, length, re_syntax_options);
  }
  if (! ret) {
    return ((char const   *)((void *)0));
  }
  return (__re_error_msgid + __re_error_msgid_idx[(int )ret]);
}
}
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
  ret = re_syntax_options;
  re_syntax_options = syntax;
  return (ret);
}
}
int re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  re_dfa_t *dfa ;
  char *fastmap ;

  {
  {
  dfa = (re_dfa_t *)bufp->buffer;
  fastmap = bufp->fastmap;
  memset((void *)fastmap, '\000', sizeof(char ) * 256UL);
  re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state, fastmap);
  }
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_word) {
    {
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_word, fastmap);
    }
  }
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_nl) {
    {
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_nl, fastmap);
    }
  }
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_begbuf) {
    {
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_begbuf,
                            fastmap);
    }
  }
  bufp->fastmap_accurate = 1U;
  return (0);
}
}
__inline static void ( __attribute__((__always_inline__)) re_set_fastmap)(char *fastmap ,
                                                                          int icase ,
                                                                          int ch ) 
{ 
  int tmp ;

  {
  *(fastmap + ch) = (char)1;
  if (icase) {
    {
    tmp = tolower(ch);
    *(fastmap + tmp) = (char)1;
    }
  }
  return;
}
}
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) 
{ 
  re_dfa_t *dfa ;
  int node_cnt ;
  int icase ;
  int tmp ;
  int node ;
  re_token_type_t type ;
  int i ;
  int ch ;
  int j ;
  bitset_word_t w ;

  {
  dfa = (re_dfa_t *)bufp->buffer;
  if (dfa->mb_cur_max == 1) {
    if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  icase = tmp;
  node_cnt = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (node_cnt < (int )init_state->nodes.nelem)) {
      goto while_break;
    }
    node = *(init_state->nodes.elems + node_cnt);
    type = (dfa->nodes + node)->type;
    if ((unsigned int )type == 1U) {
      {
      re_set_fastmap(fastmap, icase, (int )(dfa->nodes + node)->opr.c);
      }
    } else { //Added block
    if ((unsigned int )type == 3U) {
      i = 0;
      ch = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
          goto while_break___0;
        }
        w = *((dfa->nodes + node)->opr.sbcset + i);
        j = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((unsigned long )j < sizeof(bitset_word_t ) * 8UL)) {
            goto while_break___1;
          }
          if (w & (1UL << j)) {
            {
            re_set_fastmap(fastmap, icase, ch);
            }
          }
          j ++;
          ch ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else { //Added block
    if ((unsigned int )type == 5U) {
      goto _L;
    } else { //Added block
    if ((unsigned int )type == 2U) {
      _L: 
      {
      memset((void *)fastmap, '\001', sizeof(char ) * 256UL);
      }
      if ((unsigned int )type == 2U) {
        bufp->can_be_null = 1U;
      }
      return;
    }
    }
    }
    }
    node_cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
  if (cflags & 1) {
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  {
  syntax = tmp;
  preg->buffer = (unsigned char *)((void *)0);
  preg->allocated = 0UL;
  preg->used = 0UL;
  tmp___0 = malloc(256UL * sizeof(char ));
  preg->fastmap = (char *)tmp___0;
  tmp___1 = __builtin_expect((long )((unsigned long )preg->fastmap == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___1) {
    return (12);
  }
  if (cflags & (1 << 1)) {
    tmp___2 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
    tmp___2 = 0UL;
  }
  syntax |= tmp___2;
  if (cflags & ((1 << 1) << 1)) {
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
    preg->newline_anchor = 1U;
  } else {
    preg->newline_anchor = 0U;
  }
  {
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
  preg->translate = (unsigned char *)((void *)0);
  tmp___3 = strlen((char const   *)pattern);
  ret = re_compile_internal((regex_t *)preg, (char const   *)pattern, tmp___3, syntax);
  }
  if ((unsigned int )ret == 16U) {
    ret = (reg_errcode_t )8;
  }
  {
  tmp___4 = __builtin_expect((long )((unsigned int )ret == 0U), 1L);
  }
  if (tmp___4) {
    {
    re_compile_fastmap((struct re_pattern_buffer *)preg);
    }
  } else {
    {
    free((void *)preg->fastmap);
    preg->fastmap = (char *)((void *)0);
    }
  }
  return ((int )ret);
}
}
size_t regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  if (errcode < 0) {
    tmp = 1;
  } else { //Added block
  if (errcode >= (int )(sizeof(__re_error_msgid_idx) / sizeof(__re_error_msgid_idx[0]))) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  {
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  if (tmp___0) {
    {
    abort();
    }
  }
  {
  msg = __re_error_msgid + __re_error_msgid_idx[errcode];
  tmp___1 = strlen(msg);
  msg_size = tmp___1 + 1UL;
  tmp___3 = __builtin_expect((long )(errbuf_size != 0UL), 1L);
  }
  if (tmp___3) {
    {
    tmp___2 = __builtin_expect((long )(msg_size > errbuf_size), 0L);
    }
    if (tmp___2) {
      {
      memmove((void * __restrict  )errbuf, (void const   * __restrict  )msg, errbuf_size - 1UL);
      *(errbuf + (errbuf_size - 1UL)) = (char)0;
      }
    } else {
      {
      memmove((void * __restrict  )errbuf, (void const   * __restrict  )msg, msg_size);
      }
    }
  }
  return (msg_size);
}
}
static void free_dfa_content(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state ;

  {
  if (dfa->nodes) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((size_t )i < dfa->nodes_len)) {
        goto while_break;
      }
      {
      free_token(dfa->nodes + i);
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  free((void *)dfa->nexts);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((size_t )i < dfa->nodes_len)) {
      goto while_break___0;
    }
    if ((unsigned long )dfa->eclosures != (unsigned long )((void *)0)) {
      {
      free((void *)(dfa->eclosures + i)->elems);
      }
    }
    if ((unsigned long )dfa->inveclosures != (unsigned long )((void *)0)) {
      {
      free((void *)(dfa->inveclosures + i)->elems);
      }
    }
    if ((unsigned long )dfa->edests != (unsigned long )((void *)0)) {
      {
      free((void *)(dfa->edests + i)->elems);
      }
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  free((void *)dfa->edests);
  free((void *)dfa->eclosures);
  free((void *)dfa->inveclosures);
  free((void *)dfa->nodes);
  }
  if (dfa->state_table) {
    i = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned int )i <= dfa->state_hash_mask)) {
        goto while_break___1;
      }
      entry = dfa->state_table + i;
      j = 0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (j < entry->num)) {
          goto while_break___2;
        }
        {
        state = *(entry->array + j);
        free_state(state);
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      free((void *)entry->array);
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  free((void *)dfa->state_table);
  free((void *)dfa->subexp_map);
  free((void *)dfa);
  }
  return;
}
}
void regfree(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
  {
  dfa = (re_dfa_t *)preg->buffer;
  tmp = __builtin_expect((long )((unsigned long )dfa != (unsigned long )((void *)0)),
                         1L);
  }
  if (tmp) {
    {
    free_dfa_content(dfa);
    }
  }
  {
  preg->buffer = (unsigned char *)((void *)0);
  preg->allocated = 0UL;
  free((void *)preg->fastmap);
  preg->fastmap = (char *)((void *)0);
  free((void *)preg->translate);
  preg->translate = (unsigned char *)((void *)0);
  }
  return;
}
}
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t regexp ;
  unsigned int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
  err = (reg_errcode_t )0;
  preg->fastmap_accurate = 0U;
  preg->syntax = syntax;
  tmp = 0U;
  preg->not_eol = tmp;
  preg->not_bol = tmp;
  preg->used = 0UL;
  preg->re_nsub = (size_t )0;
  preg->can_be_null = 0U;
  preg->regs_allocated = 0U;
  dfa = (re_dfa_t *)preg->buffer;
  tmp___1 = __builtin_expect((long )(preg->allocated < sizeof(re_dfa_t )), 0L);
  }
  if (tmp___1) {
    {
    tmp___0 = realloc((void *)preg->buffer, sizeof(re_dfa_t ));
    dfa = (re_dfa_t *)tmp___0;
    }
    if ((unsigned long )dfa == (unsigned long )((void *)0)) {
      return ((reg_errcode_t )12);
    }
    preg->allocated = sizeof(re_dfa_t );
    preg->buffer = (unsigned char *)dfa;
  }
  {
  preg->used = sizeof(re_dfa_t );
  err = init_dfa(dfa, length);
  tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___2) {
    {
    free_dfa_content(dfa);
    preg->buffer = (unsigned char *)((void *)0);
    preg->allocated = 0UL;
    }
    return (err);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  err = re_string_construct(& regexp, pattern, (int )length, preg->translate, (int )(syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
                            (re_dfa_t const   *)dfa);
  tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___3) {
    re_compile_internal_free_return: 
    {
    free_workarea_compile(preg);
    re_string_destruct(& regexp);
    free_dfa_content(dfa);
    preg->buffer = (unsigned char *)((void *)0);
    preg->allocated = 0UL;
    }
    return (err);
  }
  {
  preg->re_nsub = (size_t )0;
  dfa->str_tree = parse(& regexp, preg, syntax, & err);
  tmp___4 = __builtin_expect((long )((unsigned long )dfa->str_tree == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___4) {
    goto re_compile_internal_free_return;
  }
  {
  err = analyze(preg);
  tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___5) {
    goto re_compile_internal_free_return;
  }
  {
  err = create_initial_state(dfa);
  free_workarea_compile(preg);
  re_string_destruct(& regexp);
  tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___6) {
    {
    free_dfa_content(dfa);
    preg->buffer = (unsigned char *)((void *)0);
    preg->allocated = 0UL;
    }
  }
  return (err);
}
}
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) 
{ 
  unsigned int table_size ;
  char *codeset_name ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;

  {
  {
  memset((void *)dfa, '\000', sizeof(re_dfa_t ));
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
  }
  if (pat_len == 0xffffffffffffffffUL) {
    return ((reg_errcode_t )12);
  }
  {
  dfa->nodes_alloc = pat_len + 1UL;
  tmp = malloc(dfa->nodes_alloc * sizeof(re_token_t ));
  dfa->nodes = (re_token_t *)tmp;
  table_size = 1U;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! ((size_t )table_size > pat_len))) {
      goto while_break;
    }
    table_size <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___0 = calloc(sizeof(struct re_state_table_entry ), (size_t )table_size);
  dfa->state_table = (struct re_state_table_entry *)tmp___0;
  dfa->state_hash_mask = table_size - 1U;
  tmp___1 = __ctype_get_mb_cur_max();
  dfa->mb_cur_max = (int )tmp___1;
  codeset_name = getenv("LC_ALL");
  }
  if ((unsigned long )codeset_name == (unsigned long )((void *)0)) {
    {
    codeset_name = getenv("LC_CTYPE");
    }
  } else { //Added block
  if ((int )*(codeset_name + 0) == 0) {
    {
    codeset_name = getenv("LC_CTYPE");
    }
  }
  }
  if ((unsigned long )codeset_name == (unsigned long )((void *)0)) {
    {
    codeset_name = getenv("LANG");
    }
  } else { //Added block
  if ((int )*(codeset_name + 0) == 0) {
    {
    codeset_name = getenv("LANG");
    }
  }
  }
  if ((unsigned long )codeset_name == (unsigned long )((void *)0)) {
    codeset_name = (char *)"";
  } else {
    {
    tmp___3 = index((char const   *)codeset_name, '.');
    }
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
      tmp___2 = index((char const   *)codeset_name, '.');
      codeset_name = tmp___2 + 1;
      }
    }
  }
  {
  tmp___4 = strcasecmp((char const   *)codeset_name, "UTF-8");
  }
  if (tmp___4 == 0) {
    dfa->is_utf8 = 1U;
  } else {
    {
    tmp___5 = strcasecmp((char const   *)codeset_name, "UTF8");
    }
    if (tmp___5 == 0) {
      dfa->is_utf8 = 1U;
    }
  }
  dfa->map_notascii = 0U;
  if ((unsigned long )dfa->nodes == (unsigned long )((void *)0)) {
    tmp___6 = 1;
  } else { //Added block
  if ((unsigned long )dfa->state_table == (unsigned long )((void *)0)) {
    tmp___6 = 1;
  } else {
    tmp___6 = 0;
  }
  }
  {
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
  if (tmp___7) {
    return ((reg_errcode_t )12);
  }
  return ((reg_errcode_t )0);
}
}
static void init_word_char(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  int ch ;
  unsigned short const   **tmp ;

  {
  dfa->word_ops_used = 1U;
  i = 0;
  ch = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
      goto while_break;
    }
    j = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )j < sizeof(bitset_word_t ) * 8UL)) {
        goto while_break___0;
      }
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + ch) & 8) {
        dfa->word_char[i] |= 1UL << j;
      } else { //Added block
      if (ch == 95) {
        dfa->word_char[i] |= 1UL << j;
      }
      }
      j ++;
      ch ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void free_workarea_compile(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_storage_t *storage ;
  bin_tree_storage_t *next ;

  {
  dfa = (re_dfa_t *)preg->buffer;
  storage = dfa->str_tree_storage;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! storage) {
      goto while_break;
    }
    {
    next = storage->next;
    free((void *)storage);
    storage = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  dfa->str_tree_storage = (bin_tree_storage_t *)((void *)0);
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
  dfa->str_tree = (bin_tree_t *)((void *)0);
  free((void *)dfa->org_indices);
  dfa->org_indices = (int *)((void *)0);
  }
  return;
}
}
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) 
{ 
  int first ;
  int i ;
  reg_errcode_t err ;
  re_node_set init_nodes ;
  long tmp ;
  int node_idx ;
  re_token_type_t type ;
  int clexp_idx ;
  re_token_t *clexp_node ;
  int dest_idx ;
  int __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  re_dfastate_t *tmp___4 ;
  re_dfastate_t *tmp___5 ;

  {
  {
  first = ((dfa->str_tree)->first)->node_idx;
  dfa->init_node = first;
  err = re_node_set_init_copy(& init_nodes, (re_node_set const   *)(dfa->eclosures + first));
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp) {
    return (err);
  }
  if (dfa->nbackref > 0) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < init_nodes.nelem)) {
        goto while_break;
      }
      node_idx = *(init_nodes.elems + i);
      type = (dfa->nodes + node_idx)->type;
      if ((unsigned int )type != 4U) {
        goto __Cont;
      }
      clexp_idx = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (clexp_idx < init_nodes.nelem)) {
          goto while_break___0;
        }
        clexp_node = dfa->nodes + *(init_nodes.elems + clexp_idx);
        if ((unsigned int )clexp_node->type == 9U) {
          if (clexp_node->opr.idx == (dfa->nodes + node_idx)->opr.idx) {
            goto while_break___0;
          }
        }
        clexp_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (clexp_idx == init_nodes.nelem) {
        goto __Cont;
      }
      if ((unsigned int )type == 4U) {
        {
        dest_idx = *((dfa->edests + node_idx)->elems + 0);
        tmp___0 = re_node_set_contains((re_node_set const   *)(& init_nodes), dest_idx);
        }
        if (! tmp___0) {
          {
          re_node_set_merge(& init_nodes, (re_node_set const   *)(dfa->eclosures + dest_idx));
          i = 0;
          }
        }
      }
      __Cont: 
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  dfa->init_state = re_acquire_state_context(& err, (re_dfa_t const   *)dfa, (re_node_set const   *)(& init_nodes),
                                             0U);
  tmp___1 = __builtin_expect((long )((unsigned long )dfa->init_state == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___1) {
    return (err);
  }
  if ((dfa->init_state)->has_constraint) {
    {
    dfa->init_state_word = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                    (re_node_set const   *)(& init_nodes),
                                                    1U);
    dfa->init_state_nl = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                  (re_node_set const   *)(& init_nodes),
                                                  (unsigned int )(1 << 1));
    dfa->init_state_begbuf = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                      (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )((1 << 1) | ((1 << 1) << 1)));
    }
    if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
      tmp___2 = 1;
    } else { //Added block
    if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
      tmp___2 = 1;
    } else { //Added block
    if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    }
    }
    {
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    }
    if (tmp___3) {
      return (err);
    }
  } else {
    tmp___5 = dfa->init_state;
    dfa->init_state_begbuf = tmp___5;
    tmp___4 = tmp___5;
    dfa->init_state_nl = tmp___4;
    dfa->init_state_word = tmp___4;
  }
  {
  free((void *)init_nodes.elems);
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t analyze(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  reg_errcode_t ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  int i ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;

  {
  {
  dfa = (re_dfa_t *)preg->buffer;
  tmp = malloc(dfa->nodes_alloc * sizeof(int ));
  dfa->nexts = (int *)tmp;
  tmp___0 = malloc(dfa->nodes_alloc * sizeof(int ));
  dfa->org_indices = (int *)tmp___0;
  tmp___1 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
  dfa->edests = (re_node_set *)tmp___1;
  tmp___2 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
  dfa->eclosures = (re_node_set *)tmp___2;
  }
  if ((unsigned long )dfa->nexts == (unsigned long )((void *)0)) {
    tmp___3 = 1;
  } else { //Added block
  if ((unsigned long )dfa->org_indices == (unsigned long )((void *)0)) {
    tmp___3 = 1;
  } else { //Added block
  if ((unsigned long )dfa->edests == (unsigned long )((void *)0)) {
    tmp___3 = 1;
  } else { //Added block
  if ((unsigned long )dfa->eclosures == (unsigned long )((void *)0)) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  }
  }
  }
  {
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
  if (tmp___4) {
    return ((reg_errcode_t )12);
  }
  {
  tmp___5 = malloc(preg->re_nsub * sizeof(int ));
  dfa->subexp_map = (int *)tmp___5;
  }
  if ((unsigned long )dfa->subexp_map != (unsigned long )((void *)0)) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((size_t )i < preg->re_nsub)) {
        goto while_break;
      }
      *(dfa->subexp_map + i) = i;
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    preorder(dfa->str_tree, & optimize_subexps, (void *)dfa);
    i = 0;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((size_t )i < preg->re_nsub)) {
        goto while_break___0;
      }
      if (*(dfa->subexp_map + i) != i) {
        goto while_break___0;
      }
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((size_t )i == preg->re_nsub) {
      {
      free((void *)dfa->subexp_map);
      dfa->subexp_map = (int *)((void *)0);
      }
    }
  }
  {
  ret = postorder(dfa->str_tree, & lower_subexps, (void *)preg);
  tmp___6 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  if (tmp___6) {
    return (ret);
  }
  {
  ret = postorder(dfa->str_tree, & calc_first, (void *)dfa);
  tmp___7 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  if (tmp___7) {
    return (ret);
  }
  {
  preorder(dfa->str_tree, & calc_next, (void *)dfa);
  ret = preorder(dfa->str_tree, & link_nfa_nodes, (void *)dfa);
  tmp___8 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  if (tmp___8) {
    return (ret);
  }
  {
  ret = calc_eclosure(dfa);
  tmp___9 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  if (tmp___9) {
    return (ret);
  }
  if (! preg->no_sub) {
    if (preg->re_nsub > 0UL) {
      if (dfa->has_plural_match) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (dfa->nbackref) {
    _L: 
    {
    tmp___10 = malloc(dfa->nodes_len * sizeof(re_node_set ));
    dfa->inveclosures = (re_node_set *)tmp___10;
    tmp___11 = __builtin_expect((long )((unsigned long )dfa->inveclosures == (unsigned long )((void *)0)),
                                0L);
    }
    if (tmp___11) {
      return ((reg_errcode_t )12);
    }
    {
    ret = calc_inveclosure(dfa);
    }
  }
  }
  return (ret);
}
}
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) 
{ 
  bin_tree_t *node ;
  bin_tree_t *prev ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;

  {
  node = root;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! node->left) {
        if (! node->right) {
          goto while_break___0;
        }
      }
      if (node->left) {
        node = node->left;
      } else {
        node = node->right;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp = (*fn)(extra, node);
      err = tmp;
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___0) {
        return (err);
      }
      if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
        return ((reg_errcode_t )0);
      }
      prev = node;
      node = node->parent;
      if (! ((unsigned long )node->right == (unsigned long )prev)) {
        if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    node = node->right;
  }
  while_break: /* CIL Label */ ;
  }
}
}
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) 
{ 
  bin_tree_t *node ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  bin_tree_t *prev ;

  {
  node = root;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = (*fn)(extra, node);
    err = tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp___0) {
      return (err);
    }
    if (node->left) {
      node = node->left;
    } else {
      prev = (bin_tree_t *)((void *)0);
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
            goto while_break___0;
          }
        }
        prev = node;
        node = node->parent;
        if (! node) {
          return ((reg_errcode_t )0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  int idx ;
  int other_idx ;

  {
  dfa = (re_dfa_t *)extra;
  if ((unsigned int )node->token.type == 4U) {
    if (dfa->subexp_map) {
      idx = node->token.opr.idx;
      node->token.opr.idx = *(dfa->subexp_map + idx);
      dfa->used_bkref_map |= (unsigned long )(1 << node->token.opr.idx);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((unsigned int )node->token.type == 17U) {
    if (node->left) {
      if ((unsigned int )(node->left)->token.type == 17U) {
        other_idx = (node->left)->token.opr.idx;
        node->left = (node->left)->left;
        if (node->left) {
          (node->left)->parent = node;
        }
        *(dfa->subexp_map + other_idx) = *(dfa->subexp_map + node->token.opr.idx);
        if ((unsigned long )other_idx < sizeof(bitset_word_t ) * 8UL) {
          dfa->used_bkref_map &= ~ (1UL << other_idx);
        }
      }
    }
  }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) 
{ 
  regex_t *preg ;
  reg_errcode_t err ;

  {
  preg = (regex_t *)extra;
  err = (reg_errcode_t )0;
  if (node->left) {
    if ((unsigned int )(node->left)->token.type == 17U) {
      {
      node->left = lower_subexp(& err, preg, node->left);
      }
      if (node->left) {
        (node->left)->parent = node;
      }
    }
  }
  if (node->right) {
    if ((unsigned int )(node->right)->token.type == 17U) {
      {
      node->right = lower_subexp(& err, preg, node->right);
      }
      if (node->right) {
        (node->right)->parent = node;
      }
    }
  }
  return (err);
}
}
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *body ;
  bin_tree_t *op ;
  bin_tree_t *cls ;
  bin_tree_t *tree1 ;
  bin_tree_t *tree ;
  bin_tree_t *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  dfa = (re_dfa_t *)preg->buffer;
  body = node->left;
  if (preg->no_sub) {
    if ((unsigned long )node->left != (unsigned long )((void *)0)) {
      if ((unsigned long )node->token.opr.idx >= sizeof(bitset_word_t ) * 8UL) {
        return (node->left);
      } else { //Added block
      if (! (dfa->used_bkref_map & (1UL << node->token.opr.idx))) {
        return (node->left);
      }
      }
    }
  }
  {
  op = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )8);
  cls = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )9);
  }
  if (body) {
    {
    tmp = create_tree(dfa, body, cls, (re_token_type_t )16);
    tree1 = tmp;
    }
  } else {
    tree1 = cls;
  }
  {
  tree = create_tree(dfa, op, tree1, (re_token_type_t )16);
  }
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else { //Added block
  if ((unsigned long )tree1 == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else { //Added block
  if ((unsigned long )op == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else { //Added block
  if ((unsigned long )cls == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  }
  }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  tmp___2 = node->token.opr.idx;
  cls->token.opr.idx = tmp___2;
  op->token.opr.idx = tmp___2;
  tmp___3 = node->token.opt_subexp;
  cls->token.opt_subexp = tmp___3;
  op->token.opt_subexp = tmp___3;
  return (tree);
}
}
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
  dfa = (re_dfa_t *)extra;
  if ((unsigned int )node->token.type == 16U) {
    node->first = (node->left)->first;
    node->node_idx = (node->left)->node_idx;
  } else {
    {
    node->first = node;
    node->node_idx = re_dfa_add_node(dfa, node->token);
    tmp = __builtin_expect((long )(node->node_idx == -1), 0L);
    }
    if (tmp) {
      return ((reg_errcode_t )12);
    }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) 
{ 


  {
  {
  if ((unsigned int )node->token.type == 11U) {
    goto case_11;
  }
  if ((unsigned int )node->token.type == 16U) {
    goto case_16;
  }
  goto switch_default;
  case_11: /* CIL Label */ 
  (node->left)->next = node;
  goto switch_break;
  case_16: /* CIL Label */ 
  (node->left)->next = (node->right)->first;
  (node->right)->next = node->next;
  goto switch_break;
  switch_default: /* CIL Label */ 
  if (node->left) {
    (node->left)->next = node->next;
  }
  if (node->right) {
    (node->right)->next = node->next;
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  int idx ;
  reg_errcode_t err ;
  int left ;
  int right ;

  {
  dfa = (re_dfa_t *)extra;
  idx = node->node_idx;
  err = (reg_errcode_t )0;
  {
  if ((unsigned int )node->token.type == 16U) {
    goto case_16;
  }
  if ((unsigned int )node->token.type == 2U) {
    goto case_2;
  }
  if ((unsigned int )node->token.type == 11U) {
    goto case_11;
  }
  if ((unsigned int )node->token.type == 10U) {
    goto case_11;
  }
  if ((unsigned int )node->token.type == 12U) {
    goto case_12;
  }
  if ((unsigned int )node->token.type == 8U) {
    goto case_12;
  }
  if ((unsigned int )node->token.type == 9U) {
    goto case_12;
  }
  if ((unsigned int )node->token.type == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_16: /* CIL Label */ 
  goto switch_break;
  case_2: /* CIL Label */ 
  if (! ((unsigned long )node->next == (unsigned long )((void *)0))) {
    {
    __assert_fail("node->next == NULL", "regcomp.c", 1362U, "link_nfa_nodes");
    }
  }
  goto switch_break;
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  dfa->has_plural_match = 1U;
  if ((unsigned long )node->left != (unsigned long )((void *)0)) {
    left = ((node->left)->first)->node_idx;
  } else {
    left = (node->next)->node_idx;
  }
  if ((unsigned long )node->right != (unsigned long )((void *)0)) {
    right = ((node->right)->first)->node_idx;
  } else {
    right = (node->next)->node_idx;
  }
  if (! (left > -1)) {
    {
    __assert_fail("left > -1", "regcomp.c", 1378U, "link_nfa_nodes");
    }
  }
  if (! (right > -1)) {
    {
    __assert_fail("right > -1", "regcomp.c", 1379U, "link_nfa_nodes");
    }
  }
  {
  err = re_node_set_init_2(dfa->edests + idx, left, right);
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  {
  err = re_node_set_init_1(dfa->edests + idx, (node->next)->node_idx);
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  *(dfa->nexts + idx) = (node->next)->node_idx;
  if ((unsigned int )node->token.type == 4U) {
    {
    re_node_set_init_1(dfa->edests + idx, *(dfa->nexts + idx));
    }
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  if (! (! ((unsigned int )node->token.type & 8U))) {
    {
    __assert_fail("!IS_EPSILON_NODE (node->token.type)", "regcomp.c", 1397U, "link_nfa_nodes");
    }
  }
  *(dfa->nexts + idx) = (node->next)->node_idx;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (err);
}
}
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa , int top_org_node , int top_clone_node ,
                                            int root_node , unsigned int init_constraint ) 
{ 
  int org_node ;
  int clone_node ;
  int ret ;
  unsigned int constraint ;
  int org_dest ;
  int clone_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  reg_errcode_t err ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  constraint = init_constraint;
  org_node = top_org_node;
  clone_node = top_clone_node;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned int )(dfa->nodes + org_node)->type == 4U) {
      {
      org_dest = *(dfa->nexts + org_node);
      (dfa->edests + clone_node)->nelem = 0;
      clone_dest = duplicate_node(dfa, org_dest, constraint);
      tmp = __builtin_expect((long )(clone_dest == -1), 0L);
      }
      if (tmp) {
        return ((reg_errcode_t )12);
      }
      {
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
      ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
      tmp___0 = __builtin_expect((long )(ret < 0), 0L);
      }
      if (tmp___0) {
        return ((reg_errcode_t )12);
      }
    } else { //Added block
    if ((dfa->edests + org_node)->nelem == 0) {
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
      goto while_break;
    } else { //Added block
    if ((dfa->edests + org_node)->nelem == 1) {
      org_dest = *((dfa->edests + org_node)->elems + 0);
      (dfa->edests + clone_node)->nelem = 0;
      if ((unsigned int )(dfa->nodes + org_node)->type == 12U) {
        if (org_node == root_node) {
          if (clone_node != org_node) {
            {
            ret = re_node_set_insert(dfa->edests + clone_node, org_dest);
            tmp___1 = __builtin_expect((long )(ret < 0), 0L);
            }
            if (tmp___1) {
              return ((reg_errcode_t )12);
            }
            goto while_break;
          }
        }
        constraint |= (unsigned int )(dfa->nodes + org_node)->opr.ctx_type;
      }
      {
      clone_dest = duplicate_node(dfa, org_dest, constraint);
      tmp___2 = __builtin_expect((long )(clone_dest == -1), 0L);
      }
      if (tmp___2) {
        return ((reg_errcode_t )12);
      }
      {
      ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
      tmp___3 = __builtin_expect((long )(ret < 0), 0L);
      }
      if (tmp___3) {
        return ((reg_errcode_t )12);
      }
    } else {
      {
      org_dest = *((dfa->edests + org_node)->elems + 0);
      (dfa->edests + clone_node)->nelem = 0;
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa, org_dest, constraint);
      }
      if (clone_dest == -1) {
        {
        clone_dest = duplicate_node(dfa, org_dest, constraint);
        tmp___4 = __builtin_expect((long )(clone_dest == -1), 0L);
        }
        if (tmp___4) {
          return ((reg_errcode_t )12);
        }
        {
        ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
        tmp___5 = __builtin_expect((long )(ret < 0), 0L);
        }
        if (tmp___5) {
          return ((reg_errcode_t )12);
        }
        {
        err = duplicate_node_closure(dfa, org_dest, clone_dest, root_node, constraint);
        tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___6) {
          return (err);
        }
      } else {
        {
        ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
        tmp___7 = __builtin_expect((long )(ret < 0), 0L);
        }
        if (tmp___7) {
          return ((reg_errcode_t )12);
        }
      }
      {
      org_dest = *((dfa->edests + org_node)->elems + 1);
      clone_dest = duplicate_node(dfa, org_dest, constraint);
      tmp___8 = __builtin_expect((long )(clone_dest == -1), 0L);
      }
      if (tmp___8) {
        return ((reg_errcode_t )12);
      }
      {
      ret = re_node_set_insert(dfa->edests + clone_node, clone_dest);
      tmp___9 = __builtin_expect((long )(ret < 0), 0L);
      }
      if (tmp___9) {
        return ((reg_errcode_t )12);
      }
    }
    }
    }
    org_node = org_dest;
    clone_node = clone_dest;
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static int search_duplicated_node(re_dfa_t const   *dfa , int org_node , unsigned int constraint ) 
{ 
  int idx ;

  {
  idx = (int )(dfa->nodes_len - 1UL);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((dfa->nodes + idx)->duplicated) {
      if (! (idx > 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (org_node == *(dfa->org_indices + idx)) {
      if (constraint == (dfa->nodes + idx)->constraint) {
        return (idx);
      }
    }
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static int duplicate_node(re_dfa_t *dfa , int org_idx , unsigned int constraint ) 
{ 
  int dup_idx ;
  int tmp ;
  long tmp___0 ;

  {
  {
  tmp = re_dfa_add_node(dfa, *(dfa->nodes + org_idx));
  dup_idx = tmp;
  tmp___0 = __builtin_expect((long )(dup_idx != -1), 1L);
  }
  if (tmp___0) {
    (dfa->nodes + dup_idx)->constraint = constraint;
    if ((unsigned int )(dfa->nodes + org_idx)->type == 12U) {
      (dfa->nodes + dup_idx)->constraint |= (unsigned int )(dfa->nodes + org_idx)->opr.ctx_type;
    }
    (dfa->nodes + dup_idx)->duplicated = 1U;
    *(dfa->org_indices + dup_idx) = org_idx;
  }
  return (dup_idx);
}
}
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) 
{ 
  int src ;
  int idx ;
  int ret ;
  int *elems ;
  long tmp ;

  {
  idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((size_t )idx < dfa->nodes_len)) {
      goto while_break;
    }
    {
    memset((void *)(dfa->inveclosures + idx), '\000', sizeof(re_node_set ));
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  src = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((size_t )src < dfa->nodes_len)) {
      goto while_break___0;
    }
    elems = (dfa->eclosures + src)->elems;
    idx = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (idx < (dfa->eclosures + src)->nelem)) {
        goto while_break___1;
      }
      {
      ret = re_node_set_insert_last(dfa->inveclosures + *(elems + idx), src);
      tmp = __builtin_expect((long )(ret == -1), 0L);
      }
      if (tmp) {
        return ((reg_errcode_t )12);
      }
      idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) 
{ 
  int node_idx ;
  int incomplete ;
  reg_errcode_t err ;
  re_node_set eclosure_elem ;
  long tmp ;

  {
  incomplete = 0;
  node_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((size_t )node_idx == dfa->nodes_len) {
      if (! incomplete) {
        goto while_break;
      }
      incomplete = 0;
      node_idx = 0;
    }
    if ((dfa->eclosures + node_idx)->nelem != 0) {
      goto __Cont;
    }
    {
    err = calc_eclosure_iter(& eclosure_elem, dfa, node_idx, 1);
    tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp) {
      return (err);
    }
    if ((dfa->eclosures + node_idx)->nelem == 0) {
      {
      incomplete = 1;
      free((void *)eclosure_elem.elems);
      }
    }
    __Cont: 
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , int node ,
                                        int root ) 
{ 
  reg_errcode_t err ;
  unsigned int constraint ;
  int i ;
  int incomplete ;
  re_node_set eclosure ;
  long tmp ;
  int org_node ;
  int cur_node ;
  long tmp___0 ;
  re_node_set eclosure_elem ;
  int edest ;
  long tmp___1 ;

  {
  {
  incomplete = 0;
  err = re_node_set_alloc(& eclosure, (dfa->edests + node)->nelem + 1);
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp) {
    return (err);
  }
  (dfa->eclosures + node)->nelem = -1;
  if ((unsigned int )(dfa->nodes + node)->type == 12U) {
    constraint = (unsigned int )(dfa->nodes + node)->opr.ctx_type;
  } else {
    constraint = 0U;
  }
  if (constraint) {
    if ((dfa->edests + node)->nelem) {
      if (! (dfa->nodes + *((dfa->edests + node)->elems + 0))->duplicated) {
        {
        cur_node = node;
        org_node = cur_node;
        err = duplicate_node_closure(dfa, node, node, node, constraint);
        tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___0) {
          return (err);
        }
      }
    }
  }
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < (dfa->edests + node)->nelem)) {
        goto while_break;
      }
      edest = *((dfa->edests + node)->elems + i);
      if ((dfa->eclosures + edest)->nelem == -1) {
        incomplete = 1;
        goto __Cont;
      }
      if ((dfa->eclosures + edest)->nelem == 0) {
        {
        err = calc_eclosure_iter(& eclosure_elem, dfa, edest, 0);
        tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___1) {
          return (err);
        }
      } else {
        eclosure_elem = *(dfa->eclosures + edest);
      }
      {
      re_node_set_merge(& eclosure, (re_node_set const   *)(& eclosure_elem));
      }
      if ((dfa->eclosures + edest)->nelem == 0) {
        {
        incomplete = 1;
        free((void *)eclosure_elem.elems);
        }
      }
      __Cont: 
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  re_node_set_insert(& eclosure, node);
  }
  if (incomplete) {
    if (! root) {
      (dfa->eclosures + node)->nelem = 0;
    } else {
      *(dfa->eclosures + node) = eclosure;
    }
  } else {
    *(dfa->eclosures + node) = eclosure;
  }
  *new_set = eclosure;
  return ((reg_errcode_t )0);
}
}
static void fetch_token(re_token_t *result , re_string_t *input , reg_syntax_t syntax ) 
{ 
  int tmp ;

  {
  {
  tmp = peek_token(result, input, syntax);
  input->cur_idx += tmp;
  }
  return;
}
}
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char __attribute__((__pure__))  tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char prev ;
  re_token_t next ;

  {
  if (input->stop <= input->cur_idx) {
    token->type = (re_token_type_t )2;
    return (0);
  }
  c = *(input->mbs + input->cur_idx);
  token->opr.c = c;
  token->word_char = 0U;
  if ((int )c == 92) {
    if (input->cur_idx + 1 >= input->len) {
      token->type = (re_token_type_t )36;
      return (1);
    }
    {
    tmp = re_string_peek_byte_case((re_string_t const   *)input, 1);
    c2 = (unsigned char )tmp;
    token->opr.c = c2;
    token->type = (re_token_type_t )1;
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + (int )c2) & 8) {
      tmp___1 = 1;
    } else { //Added block
    if ((int )c2 == 95) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    }
    token->word_char = (unsigned int )(tmp___1 != 0);
    {
    if ((int )c2 == 124) {
      goto case_124;
    }
    if ((int )c2 == 49) {
      goto case_49;
    }
    if ((int )c2 == 50) {
      goto case_49;
    }
    if ((int )c2 == 51) {
      goto case_49;
    }
    if ((int )c2 == 52) {
      goto case_49;
    }
    if ((int )c2 == 53) {
      goto case_49;
    }
    if ((int )c2 == 54) {
      goto case_49;
    }
    if ((int )c2 == 55) {
      goto case_49;
    }
    if ((int )c2 == 56) {
      goto case_49;
    }
    if ((int )c2 == 57) {
      goto case_49;
    }
    if ((int )c2 == 60) {
      goto case_60;
    }
    if ((int )c2 == 62) {
      goto case_62;
    }
    if ((int )c2 == 98) {
      goto case_98;
    }
    if ((int )c2 == 66) {
      goto case_66;
    }
    if ((int )c2 == 119) {
      goto case_119;
    }
    if ((int )c2 == 87) {
      goto case_87;
    }
    if ((int )c2 == 115) {
      goto case_115;
    }
    if ((int )c2 == 83) {
      goto case_83;
    }
    if ((int )c2 == 96) {
      goto case_96;
    }
    if ((int )c2 == 39) {
      goto case_39;
    }
    if ((int )c2 == 40) {
      goto case_40;
    }
    if ((int )c2 == 41) {
      goto case_41;
    }
    if ((int )c2 == 43) {
      goto case_43;
    }
    if ((int )c2 == 63) {
      goto case_63;
    }
    if ((int )c2 == 123) {
      goto case_123;
    }
    if ((int )c2 == 125) {
      goto case_125;
    }
    goto switch_default;
    case_124: /* CIL Label */ 
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if (! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        token->type = (re_token_type_t )10;
      }
    }
    goto switch_break;
    case_49: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_57: /* CIL Label */ 
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )4;
      token->opr.idx = (int )c2 - 49;
    }
    goto switch_break;
    case_60: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )12;
      token->opr.ctx_type = (re_context_type )6;
    }
    goto switch_break;
    case_62: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )12;
      token->opr.ctx_type = (re_context_type )9;
    }
    goto switch_break;
    case_98: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )12;
      token->opr.ctx_type = (re_context_type )256;
    }
    goto switch_break;
    case_66: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )12;
      token->opr.ctx_type = (re_context_type )512;
    }
    goto switch_break;
    case_119: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )32;
    }
    goto switch_break;
    case_87: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )33;
    }
    goto switch_break;
    case_115: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )34;
    }
    goto switch_break;
    case_83: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )35;
    }
    goto switch_break;
    case_96: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )12;
      token->opr.ctx_type = (re_context_type )64;
    }
    goto switch_break;
    case_39: /* CIL Label */ 
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )12;
      token->opr.ctx_type = (re_context_type )128;
    }
    goto switch_break;
    case_40: /* CIL Label */ 
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )8;
    }
    goto switch_break;
    case_41: /* CIL Label */ 
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      token->type = (re_token_type_t )9;
    }
    goto switch_break;
    case_43: /* CIL Label */ 
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if (syntax & (1UL << 1)) {
        token->type = (re_token_type_t )18;
      }
    }
    goto switch_break;
    case_63: /* CIL Label */ 
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if (syntax & (1UL << 1)) {
        token->type = (re_token_type_t )19;
      }
    }
    goto switch_break;
    case_123: /* CIL Label */ 
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        token->type = (re_token_type_t )23;
      }
    }
    goto switch_break;
    case_125: /* CIL Label */ 
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        token->type = (re_token_type_t )24;
      }
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    return (2);
  }
  {
  token->type = (re_token_type_t )1;
  tmp___2 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___2 + (int )token->opr.c) & 8) {
    tmp___3 = 1;
  } else { //Added block
  if ((int )token->opr.c == 95) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  }
  token->word_char = (unsigned int )tmp___3;
  {
  if ((int )c == 10) {
    goto case_10;
  }
  if ((int )c == 124) {
    goto case_124___0;
  }
  if ((int )c == 42) {
    goto case_42;
  }
  if ((int )c == 43) {
    goto case_43___0;
  }
  if ((int )c == 63) {
    goto case_63___0;
  }
  if ((int )c == 123) {
    goto case_123___0;
  }
  if ((int )c == 125) {
    goto case_125___0;
  }
  if ((int )c == 40) {
    goto case_40___0;
  }
  if ((int )c == 41) {
    goto case_41___0;
  }
  if ((int )c == 91) {
    goto case_91;
  }
  if ((int )c == 46) {
    goto case_46;
  }
  if ((int )c == 94) {
    goto case_94;
  }
  if ((int )c == 36) {
    goto case_36;
  }
  goto switch_default___0;
  case_10: /* CIL Label */ 
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    token->type = (re_token_type_t )10;
  }
  goto switch_break___0;
  case_124___0: /* CIL Label */ 
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      token->type = (re_token_type_t )10;
    }
  }
  goto switch_break___0;
  case_42: /* CIL Label */ 
  token->type = (re_token_type_t )11;
  goto switch_break___0;
  case_43___0: /* CIL Label */ 
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    if (! (syntax & (1UL << 1))) {
      token->type = (re_token_type_t )18;
    }
  }
  goto switch_break___0;
  case_63___0: /* CIL Label */ 
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    if (! (syntax & (1UL << 1))) {
      token->type = (re_token_type_t )19;
    }
  }
  goto switch_break___0;
  case_123___0: /* CIL Label */ 
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      token->type = (re_token_type_t )23;
    }
  }
  goto switch_break___0;
  case_125___0: /* CIL Label */ 
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      token->type = (re_token_type_t )24;
    }
  }
  goto switch_break___0;
  case_40___0: /* CIL Label */ 
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    token->type = (re_token_type_t )8;
  }
  goto switch_break___0;
  case_41___0: /* CIL Label */ 
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    token->type = (re_token_type_t )9;
  }
  goto switch_break___0;
  case_91: /* CIL Label */ 
  token->type = (re_token_type_t )20;
  goto switch_break___0;
  case_46: /* CIL Label */ 
  token->type = (re_token_type_t )5;
  goto switch_break___0;
  case_94: /* CIL Label */ 
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
    if (input->cur_idx != 0) {
      prev = (char )*(input->mbs + (input->cur_idx + -1));
      if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        goto switch_break___0;
      } else { //Added block
      if ((int )prev != 10) {
        goto switch_break___0;
      }
      }
    }
  }
  token->type = (re_token_type_t )12;
  token->opr.ctx_type = (re_context_type )16;
  goto switch_break___0;
  case_36: /* CIL Label */ 
  if (! (syntax & (((1UL << 1) << 1) << 1))) {
    if (input->cur_idx + 1 != input->len) {
      {
      (input->cur_idx) ++;
      peek_token(& next, input, syntax);
      (input->cur_idx) --;
      }
      if ((unsigned int )next.type != 10U) {
        if ((unsigned int )next.type != 9U) {
          goto switch_break___0;
        }
      }
    }
  }
  token->type = (re_token_type_t )12;
  token->opr.ctx_type = (re_context_type )32;
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  return (1);
}
}
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
  if (input->stop <= input->cur_idx) {
    token->type = (re_token_type_t )2;
    return (0);
  }
  c = *(input->mbs + input->cur_idx);
  token->opr.c = c;
  if ((int )c == 92) {
    if (syntax & 1UL) {
      if (input->cur_idx + 1 < input->len) {
        (input->cur_idx) ++;
        c2 = *(input->mbs + input->cur_idx);
        token->opr.c = c2;
        token->type = (re_token_type_t )1;
        return (1);
      }
    }
  }
  if ((int )c == 91) {
    if (input->cur_idx + 1 < input->len) {
      c2___0 = *(input->mbs + (input->cur_idx + 1));
    } else {
      c2___0 = (unsigned char)0;
    }
    token->opr.c = c2___0;
    token_len = 2;
    {
    if ((int )c2___0 == 46) {
      goto case_46;
    }
    if ((int )c2___0 == 61) {
      goto case_61;
    }
    if ((int )c2___0 == 58) {
      goto case_58;
    }
    goto switch_default;
    case_46: /* CIL Label */ 
    token->type = (re_token_type_t )26;
    goto switch_break;
    case_61: /* CIL Label */ 
    token->type = (re_token_type_t )28;
    goto switch_break;
    case_58: /* CIL Label */ 
    if (syntax & ((1UL << 1) << 1)) {
      token->type = (re_token_type_t )30;
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    token->type = (re_token_type_t )1;
    token->opr.c = c;
    token_len = 1;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    return (token_len);
  }
  {
  if ((int )c == 45) {
    goto case_45;
  }
  if ((int )c == 93) {
    goto case_93;
  }
  if ((int )c == 94) {
    goto case_94;
  }
  goto switch_default___0;
  case_45: /* CIL Label */ 
  token->type = (re_token_type_t )22;
  goto switch_break___0;
  case_93: /* CIL Label */ 
  token->type = (re_token_type_t )21;
  goto switch_break___0;
  case_94: /* CIL Label */ 
  token->type = (re_token_type_t )25;
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  token->type = (re_token_type_t )1;
  switch_break___0: /* CIL Label */ ;
  }
  return (1);
}
}
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  dfa = (re_dfa_t *)preg->buffer;
  dfa->syntax = syntax;
  fetch_token(& current_token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  tree = parse_reg_exp(regexp, preg, & current_token, syntax, 0, err);
  }
  if ((unsigned int )*err != 0U) {
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  {
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  if (tmp___0) {
    return ((bin_tree_t *)((void *)0));
  }
  {
  eor = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )2);
  }
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
    {
    root = create_tree(dfa, tree, eor, (re_token_type_t )16);
    }
  } else {
    root = eor;
  }
  if ((unsigned long )eor == (unsigned long )((void *)0)) {
    tmp___1 = 1;
  } else { //Added block
  if ((unsigned long )root == (unsigned long )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  return (root);
}
}
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *branch ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
  dfa = (re_dfa_t *)preg->buffer;
  branch = (bin_tree_t *)((void *)0);
  tree = parse_branch(regexp, preg, token, syntax, nest, err);
  }
  if ((unsigned int )*err != 0U) {
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  {
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  if (tmp___0) {
    return ((bin_tree_t *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned int )token->type == 10U)) {
      goto while_break;
    }
    {
    fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
    if ((unsigned int )token->type != 10U) {
      if ((unsigned int )token->type != 2U) {
        if (nest == 0) {
          goto _L;
        } else { //Added block
        if ((unsigned int )token->type != 9U) {
          _L: 
          {
          branch = parse_branch(regexp, preg, token, syntax, nest, err);
          }
          if ((unsigned int )*err != 0U) {
            if ((unsigned long )branch == (unsigned long )((void *)0)) {
              tmp___1 = 1;
            } else {
              tmp___1 = 0;
            }
          } else {
            tmp___1 = 0;
          }
          {
          tmp___2 = __builtin_expect((long )tmp___1, 0L);
          }
          if (tmp___2) {
            return ((bin_tree_t *)((void *)0));
          }
        } else {
          branch = (bin_tree_t *)((void *)0);
        }
        }
      } else {
        branch = (bin_tree_t *)((void *)0);
      }
    } else {
      branch = (bin_tree_t *)((void *)0);
    }
    {
    tree = create_tree(dfa, tree, branch, (re_token_type_t )10);
    tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___3) {
      *err = (reg_errcode_t )12;
      return ((bin_tree_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (tree);
}
}
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *exp ;
  re_dfa_t *dfa ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  dfa = (re_dfa_t *)preg->buffer;
  tree = parse_expression(regexp, preg, token, syntax, nest, err);
  }
  if ((unsigned int )*err != 0U) {
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  {
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  if (tmp___0) {
    return ((bin_tree_t *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned int )token->type != 10U) {
      if ((unsigned int )token->type != 2U) {
        if (! (nest == 0)) {
          if (! ((unsigned int )token->type != 9U)) {
            goto while_break;
          }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    exp = parse_expression(regexp, preg, token, syntax, nest, err);
    }
    if ((unsigned int )*err != 0U) {
      if ((unsigned long )exp == (unsigned long )((void *)0)) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      return ((bin_tree_t *)((void *)0));
    }
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
      if ((unsigned long )exp != (unsigned long )((void *)0)) {
        {
        tree = create_tree(dfa, tree, exp, (re_token_type_t )16);
        }
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
          *err = (reg_errcode_t )12;
          return ((bin_tree_t *)((void *)0));
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tree = exp;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (tree);
}
}
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  bin_tree_t *tmp___6 ;
  long tmp___7 ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;

  {
  dfa = (re_dfa_t *)preg->buffer;
  {
  if ((unsigned int )token->type == 1U) {
    goto case_1;
  }
  if ((unsigned int )token->type == 8U) {
    goto case_8;
  }
  if ((unsigned int )token->type == 20U) {
    goto case_20;
  }
  if ((unsigned int )token->type == 4U) {
    goto case_4;
  }
  if ((unsigned int )token->type == 23U) {
    goto case_23;
  }
  if ((unsigned int )token->type == 11U) {
    goto case_11;
  }
  if ((unsigned int )token->type == 18U) {
    goto case_11;
  }
  if ((unsigned int )token->type == 19U) {
    goto case_11;
  }
  if ((unsigned int )token->type == 9U) {
    goto case_9;
  }
  if ((unsigned int )token->type == 24U) {
    goto case_24;
  }
  if ((unsigned int )token->type == 12U) {
    goto case_12;
  }
  if ((unsigned int )token->type == 5U) {
    goto case_5;
  }
  if ((unsigned int )token->type == 32U) {
    goto case_32;
  }
  if ((unsigned int )token->type == 33U) {
    goto case_32;
  }
  if ((unsigned int )token->type == 34U) {
    goto case_34;
  }
  if ((unsigned int )token->type == 35U) {
    goto case_34;
  }
  if ((unsigned int )token->type == 10U) {
    goto case_10;
  }
  if ((unsigned int )token->type == 2U) {
    goto case_10;
  }
  if ((unsigned int )token->type == 36U) {
    goto case_36;
  }
  goto switch_default;
  case_1: /* CIL Label */ 
  {
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
  tmp = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                         0L);
  }
  if (tmp) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  {
  tree = parse_sub_exp(regexp, preg, token, syntax, nest + 1, err);
  }
  if ((unsigned int )*err != 0U) {
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return ((bin_tree_t *)((void *)0));
  }
  goto switch_break;
  case_20: /* CIL Label */ 
  {
  tree = parse_bracket_exp(regexp, dfa, token, syntax, err);
  }
  if ((unsigned int )*err != 0U) {
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  {
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
  if (tmp___3) {
    return ((bin_tree_t *)((void *)0));
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  tmp___4 = __builtin_expect((long )(dfa->completed_bkref_map & (unsigned long )(1 << token->opr.idx)),
                             1L);
  }
  if (! tmp___4) {
    *err = (reg_errcode_t )6;
    return ((bin_tree_t *)((void *)0));
  }
  {
  dfa->used_bkref_map |= (unsigned long )(1 << token->opr.idx);
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
  tmp___5 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___5) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  (dfa->nbackref) ++;
  dfa->has_mb_node = 1U;
  goto switch_break;
  case_23: /* CIL Label */ 
  if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    *err = (reg_errcode_t )13;
    return ((bin_tree_t *)((void *)0));
  }
  case_11: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_19: /* CIL Label */ 
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
    *err = (reg_errcode_t )13;
    return ((bin_tree_t *)((void *)0));
  } else { //Added block
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
    {
    fetch_token(token, regexp, syntax);
    tmp___6 = parse_expression(regexp, preg, token, syntax, nest, err);
    }
    return (tmp___6);
  }
  }
  case_9: /* CIL Label */ 
  if ((unsigned int )token->type == 9U) {
    if (! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      *err = (reg_errcode_t )16;
      return ((bin_tree_t *)((void *)0));
    }
  }
  case_24: /* CIL Label */ 
  {
  token->type = (re_token_type_t )1;
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
  tmp___7 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___7) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  if ((unsigned int )token->opr.ctx_type & 783U) {
    if (dfa->word_ops_used == 0U) {
      {
      init_word_char(dfa);
      }
    }
  }
  if ((unsigned int )token->opr.ctx_type == 256U) {
    goto _L;
  } else { //Added block
  if ((unsigned int )token->opr.ctx_type == 512U) {
    _L: 
    if ((unsigned int )token->opr.ctx_type == 256U) {
      {
      token->opr.ctx_type = (re_context_type )6;
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
      token->opr.ctx_type = (re_context_type )9;
      }
    } else {
      {
      token->opr.ctx_type = (re_context_type )5;
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
      token->opr.ctx_type = (re_context_type )10;
      }
    }
    {
    tree_last = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)token);
    tree = create_tree(dfa, tree_first, tree_last, (re_token_type_t )10);
    }
    if ((unsigned long )tree_first == (unsigned long )((void *)0)) {
      tmp___8 = 1;
    } else { //Added block
    if ((unsigned long )tree_last == (unsigned long )((void *)0)) {
      tmp___8 = 1;
    } else { //Added block
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp___8 = 1;
    } else {
      tmp___8 = 0;
    }
    }
    }
    {
    tmp___9 = __builtin_expect((long )tmp___8, 0L);
    }
    if (tmp___9) {
      *err = (reg_errcode_t )12;
      return ((bin_tree_t *)((void *)0));
    }
  } else {
    {
    tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                             (re_token_t const   *)token);
    tmp___10 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
    if (tmp___10) {
      *err = (reg_errcode_t )12;
      return ((bin_tree_t *)((void *)0));
    }
  }
  }
  {
  fetch_token(token, regexp, syntax);
  }
  return (tree);
  case_5: /* CIL Label */ 
  {
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
  tmp___11 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
  if (tmp___11) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  if (dfa->mb_cur_max > 1) {
    dfa->has_mb_node = 1U;
  }
  goto switch_break;
  case_32: /* CIL Label */ 
  case_33: /* CIL Label */ 
  {
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"alnum",
                            (unsigned char const   *)"_", (unsigned int )token->type == 33U,
                            err);
  }
  if ((unsigned int )*err != 0U) {
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp___12 = 1;
    } else {
      tmp___12 = 0;
    }
  } else {
    tmp___12 = 0;
  }
  {
  tmp___13 = __builtin_expect((long )tmp___12, 0L);
  }
  if (tmp___13) {
    return ((bin_tree_t *)((void *)0));
  }
  goto switch_break;
  case_34: /* CIL Label */ 
  case_35: /* CIL Label */ 
  {
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"space",
                            (unsigned char const   *)"", (unsigned int )token->type == 35U,
                            err);
  }
  if ((unsigned int )*err != 0U) {
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp___14 = 1;
    } else {
      tmp___14 = 0;
    }
  } else {
    tmp___14 = 0;
  }
  {
  tmp___15 = __builtin_expect((long )tmp___14, 0L);
  }
  if (tmp___15) {
    return ((bin_tree_t *)((void *)0));
  }
  goto switch_break;
  case_10: /* CIL Label */ 
  case_2: /* CIL Label */ 
  return ((bin_tree_t *)((void *)0));
  case_36: /* CIL Label */ 
  *err = (reg_errcode_t )5;
  return ((bin_tree_t *)((void *)0));
  switch_default: /* CIL Label */ 
  return ((bin_tree_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  fetch_token(token, regexp, syntax);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned int )token->type == 11U)) {
      if (! ((unsigned int )token->type == 18U)) {
        if (! ((unsigned int )token->type == 19U)) {
          if (! ((unsigned int )token->type == 23U)) {
            goto while_break;
          }
        }
      }
    }
    {
    tree = parse_dup_op(tree, regexp, dfa, token, syntax, err);
    }
    if ((unsigned int )*err != 0U) {
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
        tmp___16 = 1;
      } else {
        tmp___16 = 0;
      }
    } else {
      tmp___16 = 0;
    }
    {
    tmp___17 = __builtin_expect((long )tmp___16, 0L);
    }
    if (tmp___17) {
      return ((bin_tree_t *)((void *)0));
    }
    if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if ((unsigned int )token->type == 11U) {
        *err = (reg_errcode_t )13;
        return ((bin_tree_t *)((void *)0));
      } else { //Added block
      if ((unsigned int )token->type == 23U) {
        *err = (reg_errcode_t )13;
        return ((bin_tree_t *)((void *)0));
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (tree);
}
}
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  size_t cur_nsub ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
  dfa = (re_dfa_t *)preg->buffer;
  tmp = preg->re_nsub;
  (preg->re_nsub) ++;
  cur_nsub = tmp;
  fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  if ((unsigned int )token->type == 9U) {
    tree = (bin_tree_t *)((void *)0);
  } else {
    {
    tree = parse_reg_exp(regexp, preg, token, syntax, nest, err);
    }
    if ((unsigned int )*err == 0U) {
      if ((unsigned int )token->type != 9U) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    {
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
    if (tmp___1) {
      *err = (reg_errcode_t )8;
    }
    {
    tmp___2 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
    }
    if (tmp___2) {
      return ((bin_tree_t *)((void *)0));
    }
  }
  if (cur_nsub <= 8UL) {
    dfa->completed_bkref_map |= (unsigned long )(1 << cur_nsub);
  }
  {
  tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )17);
  tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___3) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  tree->token.opr.idx = (int )cur_nsub;
  return (tree);
}
}
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *old_tree ;
  int i ;
  int start ;
  int end ;
  int start_idx ;
  re_token_t start_token ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;

  {
  tree = (bin_tree_t *)((void *)0);
  old_tree = (bin_tree_t *)((void *)0);
  start_idx = regexp->cur_idx;
  start_token = *token;
  if ((unsigned int )token->type == 23U) {
    {
    end = 0;
    start = fetch_number(regexp, token, syntax);
    }
    if (start == -1) {
      if ((unsigned int )token->type == 1U) {
        if ((int )token->opr.c == 44) {
          start = 0;
        } else {
          *err = (reg_errcode_t )10;
          return ((bin_tree_t *)((void *)0));
        }
      } else {
        *err = (reg_errcode_t )10;
        return ((bin_tree_t *)((void *)0));
      }
    }
    {
    tmp___1 = __builtin_expect((long )(start != -2), 1L);
    }
    if (tmp___1) {
      if ((unsigned int )token->type == 24U) {
        end = start;
      } else {
        if ((unsigned int )token->type == 1U) {
          if ((int )token->opr.c == 44) {
            {
            tmp = fetch_number(regexp, token, syntax);
            tmp___0 = tmp;
            }
          } else {
            tmp___0 = -2;
          }
        } else {
          tmp___0 = -2;
        }
        end = tmp___0;
      }
    }
    if (start == -2) {
      tmp___3 = 1;
    } else { //Added block
    if (end == -2) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
    }
    {
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
    if (tmp___4) {
      {
      tmp___2 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                                 0L);
      }
      if (tmp___2) {
        if ((unsigned int )token->type == 2U) {
          *err = (reg_errcode_t )9;
        } else {
          *err = (reg_errcode_t )10;
        }
        return ((bin_tree_t *)((void *)0));
      }
      regexp->cur_idx = start_idx;
      *token = start_token;
      token->type = (re_token_type_t )1;
      return (elem);
    }
    if (end != -1) {
      if (start > end) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    } else {
      tmp___5 = 0;
    }
    {
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
    if (tmp___6) {
      *err = (reg_errcode_t )10;
      return ((bin_tree_t *)((void *)0));
    }
  } else {
    if ((unsigned int )token->type == 18U) {
      start = 1;
    } else {
      start = 0;
    }
    if ((unsigned int )token->type == 19U) {
      end = 1;
    } else {
      end = -1;
    }
  }
  {
  fetch_token(token, regexp, syntax);
  tmp___7 = __builtin_expect((long )((unsigned long )elem == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___7) {
    return ((bin_tree_t *)((void *)0));
  }
  if (start == 0) {
    if (end == 0) {
      tmp___8 = 1;
    } else {
      tmp___8 = 0;
    }
  } else {
    tmp___8 = 0;
  }
  {
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
  if (tmp___9) {
    {
    postorder(elem, & free_tree, (void *)0);
    }
    return ((bin_tree_t *)((void *)0));
  }
  {
  tmp___12 = __builtin_expect((long )(start > 0), 0L);
  }
  if (tmp___12) {
    tree = elem;
    i = 2;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i <= start)) {
        goto while_break;
      }
      {
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
      tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
      }
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
        tmp___10 = 1;
      } else { //Added block
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
        tmp___10 = 1;
      } else {
        tmp___10 = 0;
      }
      }
      {
      tmp___11 = __builtin_expect((long )tmp___10, 0L);
      }
      if (tmp___11) {
        goto parse_dup_op_espace;
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (start == end) {
      return (tree);
    }
    {
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
    old_tree = tree;
    }
  } else {
    old_tree = (bin_tree_t *)((void *)0);
  }
  if ((unsigned int )elem->token.type == 17U) {
    {
    postorder(elem, & mark_opt_subexp, (void *)((long )elem->token.opr.idx));
    }
  }
  if (end == -1) {
    tmp___13 = 11;
  } else {
    tmp___13 = 10;
  }
  {
  tree = create_tree(dfa, elem, (bin_tree_t *)((void *)0), (re_token_type_t )tmp___13);
  tmp___14 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
  if (tmp___14) {
    goto parse_dup_op_espace;
  }
  i = start + 2;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i <= end)) {
      goto while_break___0;
    }
    {
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
    tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
    }
    if ((unsigned long )elem == (unsigned long )((void *)0)) {
      tmp___15 = 1;
    } else { //Added block
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
      tmp___15 = 1;
    } else {
      tmp___15 = 0;
    }
    }
    {
    tmp___16 = __builtin_expect((long )tmp___15, 0L);
    }
    if (tmp___16) {
      goto parse_dup_op_espace;
    }
    {
    tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )10);
    tmp___17 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
    if (tmp___17) {
      goto parse_dup_op_espace;
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (old_tree) {
    {
    tree = create_tree(dfa, old_tree, tree, (re_token_type_t )16);
    }
  }
  return (tree);
  parse_dup_op_espace: 
  *err = (reg_errcode_t )12;
  return ((bin_tree_t *)((void *)0));
}
}
static reg_errcode_t build_range_exp(bitset_word_t *sbcset , bracket_elem_t *start_elem ,
                                     bracket_elem_t *end_elem ) 
{ 
  unsigned int start_ch ;
  unsigned int end_ch ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned int ch ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned int )start_elem->type == 2U) {
    tmp = 1;
  } else { //Added block
  if ((unsigned int )start_elem->type == 4U) {
    tmp = 1;
  } else { //Added block
  if ((unsigned int )end_elem->type == 2U) {
    tmp = 1;
  } else { //Added block
  if ((unsigned int )end_elem->type == 4U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  }
  {
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  if (tmp___0) {
    return ((reg_errcode_t )11);
  }
  if ((unsigned int )start_elem->type == 3U) {
    {
    tmp___1 = strlen((char const   *)((char *)start_elem->opr.name));
    }
    if (tmp___1 > 1UL) {
      tmp___3 = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((unsigned int )end_elem->type == 3U) {
    {
    tmp___2 = strlen((char const   *)((char *)end_elem->opr.name));
    }
    if (tmp___2 > 1UL) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  }
  {
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
  if (tmp___4) {
    return ((reg_errcode_t )3);
  }
  if ((unsigned int )start_elem->type == 0U) {
    start_ch = (unsigned int )start_elem->opr.ch;
  } else {
    if ((unsigned int )start_elem->type == 3U) {
      tmp___5 = (int )*(start_elem->opr.name + 0);
    } else {
      tmp___5 = 0;
    }
    start_ch = (unsigned int )tmp___5;
  }
  if ((unsigned int )end_elem->type == 0U) {
    end_ch = (unsigned int )end_elem->opr.ch;
  } else {
    if ((unsigned int )end_elem->type == 3U) {
      tmp___6 = (int )*(end_elem->opr.name + 0);
    } else {
      tmp___6 = 0;
    }
    end_ch = (unsigned int )tmp___6;
  }
  if (start_ch > end_ch) {
    return ((reg_errcode_t )11);
  }
  ch = 0U;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (ch < 256U)) {
      goto while_break;
    }
    if (start_ch <= ch) {
      if (ch <= end_ch) {
        *(sbcset + (unsigned long )ch / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )ch % (sizeof(bitset_word_t ) * 8UL);
      }
    }
    ch ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t build_collating_symbol(bitset_word_t *sbcset , unsigned char const   *name ) 
{ 
  size_t name_len ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
  tmp = strlen((char const   *)name);
  name_len = tmp;
  tmp___0 = __builtin_expect((long )(name_len != 1UL), 0L);
  }
  if (tmp___0) {
    return ((reg_errcode_t )3);
  } else {
    *(sbcset + (unsigned long )*(name + 0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(name + 0) % (sizeof(bitset_word_t ) * 8UL);
    return ((reg_errcode_t )0);
  }
}
}
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  int non_match ;
  bin_tree_t *work_tree ;
  int token_len ;
  int first_round ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  int is_range_exp ;
  re_token_t token2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
  {
  non_match = 0;
  first_round = 1;
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
  sbcset = (re_bitset_ptr_t )tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )sbcset == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  {
  token_len = peek_token_bracket(token, regexp, syntax);
  tmp___1 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
  }
  if (tmp___1) {
    *err = (reg_errcode_t )2;
    goto parse_bracket_exp_free_return;
  }
  if ((unsigned int )token->type == 25U) {
    non_match = 1;
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      *(sbcset + 0UL / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << 0UL % (sizeof(bitset_word_t ) * 8UL);
    }
    {
    regexp->cur_idx += token_len;
    token_len = peek_token_bracket(token, regexp, syntax);
    tmp___2 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
    if (tmp___2) {
      *err = (reg_errcode_t )2;
      goto parse_bracket_exp_free_return;
    }
  }
  if ((unsigned int )token->type == 21U) {
    token->type = (re_token_type_t )1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    token_len2 = 0;
    is_range_exp = 0;
    start_elem.opr.name = start_name_buf;
    ret = parse_bracket_element(& start_elem, regexp, token, token_len, dfa, syntax,
                                first_round);
    tmp___3 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    if (tmp___3) {
      *err = ret;
      goto parse_bracket_exp_free_return;
    }
    {
    first_round = 0;
    token_len = peek_token_bracket(token, regexp, syntax);
    }
    if ((unsigned int )start_elem.type != 4U) {
      if ((unsigned int )start_elem.type != 2U) {
        {
        tmp___4 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
        }
        if (tmp___4) {
          *err = (reg_errcode_t )7;
          goto parse_bracket_exp_free_return;
        }
        if ((unsigned int )token->type == 22U) {
          {
          regexp->cur_idx += token_len;
          token_len2 = peek_token_bracket(& token2, regexp, syntax);
          tmp___5 = __builtin_expect((long )((unsigned int )token2.type == 2U), 0L);
          }
          if (tmp___5) {
            *err = (reg_errcode_t )7;
            goto parse_bracket_exp_free_return;
          }
          if ((unsigned int )token2.type == 21U) {
            regexp->cur_idx += - token_len;
            token->type = (re_token_type_t )1;
          } else {
            is_range_exp = 1;
          }
        }
      }
    }
    if (is_range_exp == 1) {
      {
      end_elem.opr.name = end_name_buf;
      ret = parse_bracket_element(& end_elem, regexp, & token2, token_len2, dfa, syntax,
                                  1);
      tmp___6 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
      }
      if (tmp___6) {
        *err = ret;
        goto parse_bracket_exp_free_return;
      }
      {
      token_len = peek_token_bracket(token, regexp, syntax);
      *err = build_range_exp(sbcset, & start_elem, & end_elem);
      tmp___7 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      if (tmp___7) {
        goto parse_bracket_exp_free_return;
      }
    } else {
      {
      if ((unsigned int )start_elem.type == 0U) {
        goto case_0;
      }
      if ((unsigned int )start_elem.type == 2U) {
        goto case_2;
      }
      if ((unsigned int )start_elem.type == 3U) {
        goto case_3;
      }
      if ((unsigned int )start_elem.type == 4U) {
        goto case_4;
      }
      goto switch_default;
      case_0: /* CIL Label */ 
      *(sbcset + (unsigned long )start_elem.opr.ch / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )start_elem.opr.ch % (sizeof(bitset_word_t ) * 8UL);
      goto switch_break;
      case_2: /* CIL Label */ 
      {
      *err = build_equiv_class(sbcset, (unsigned char const   *)start_elem.opr.name);
      tmp___8 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      if (tmp___8) {
        goto parse_bracket_exp_free_return;
      }
      goto switch_break;
      case_3: /* CIL Label */ 
      {
      *err = build_collating_symbol(sbcset, (unsigned char const   *)start_elem.opr.name);
      tmp___9 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      if (tmp___9) {
        goto parse_bracket_exp_free_return;
      }
      goto switch_break;
      case_4: /* CIL Label */ 
      {
      *err = build_charclass(regexp->trans, sbcset, (unsigned char const   *)start_elem.opr.name,
                             syntax);
      tmp___10 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      if (tmp___10) {
        goto parse_bracket_exp_free_return;
      }
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      __assert_fail("0", "regcomp.c", 3170U, "parse_bracket_exp");
      }
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
    tmp___11 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
    if (tmp___11) {
      *err = (reg_errcode_t )7;
      goto parse_bracket_exp_free_return;
    }
    if ((unsigned int )token->type == 21U) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  regexp->cur_idx += token_len;
  if (non_match) {
    {
    bitset_not(sbcset);
    }
  }
  {
  br_token.type = (re_token_type_t )3;
  br_token.opr.sbcset = sbcset;
  work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                (re_token_t const   *)(& br_token));
  tmp___12 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                              0L);
  }
  if (tmp___12) {
    goto parse_bracket_exp_espace;
  }
  return (work_tree);
  parse_bracket_exp_espace: 
  *err = (reg_errcode_t )12;
  parse_bracket_exp_free_return: 
  {
  free((void *)sbcset);
  }
  return ((bin_tree_t *)((void *)0));
}
}
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , int accept_hyphen ) 
{ 
  reg_errcode_t tmp ;
  re_token_t token2 ;
  long tmp___0 ;

  {
  regexp->cur_idx += token_len;
  if ((unsigned int )token->type == 26U) {
    {
    tmp = parse_bracket_symbol(elem, regexp, token);
    }
    return (tmp);
  } else { //Added block
  if ((unsigned int )token->type == 30U) {
    {
    tmp = parse_bracket_symbol(elem, regexp, token);
    }
    return (tmp);
  } else { //Added block
  if ((unsigned int )token->type == 28U) {
    {
    tmp = parse_bracket_symbol(elem, regexp, token);
    }
    return (tmp);
  }
  }
  }
  {
  tmp___0 = __builtin_expect((long )((unsigned int )token->type == 22U), 0L);
  }
  if (tmp___0) {
    if (! accept_hyphen) {
      {
      peek_token_bracket(& token2, regexp, syntax);
      }
      if ((unsigned int )token2.type != 21U) {
        return ((reg_errcode_t )11);
      }
    }
  }
  elem->type = (bracket_elem_type )0;
  elem->opr.ch = token->opr.c;
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) 
{ 
  unsigned char ch ;
  unsigned char delim ;
  int i ;
  unsigned char __attribute__((__pure__))  tmp ;
  int tmp___0 ;

  {
  delim = token->opr.c;
  i = 0;
  if (regexp->stop <= regexp->cur_idx) {
    return ((reg_errcode_t )7);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i >= 32) {
      return ((reg_errcode_t )7);
    }
    if ((unsigned int )token->type == 30U) {
      {
      tmp = re_string_fetch_byte_case(regexp);
      ch = (unsigned char )tmp;
      }
    } else {
      tmp___0 = regexp->cur_idx;
      (regexp->cur_idx) ++;
      ch = *(regexp->mbs + tmp___0);
    }
    if (regexp->stop <= regexp->cur_idx) {
      return ((reg_errcode_t )7);
    }
    if ((int )ch == (int )delim) {
      if ((int )*(regexp->mbs + regexp->cur_idx) == 93) {
        goto while_break;
      }
    }
    *(elem->opr.name + i) = ch;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  (regexp->cur_idx) ++;
  *(elem->opr.name + i) = (unsigned char )'\000';
  {
  if ((unsigned int )token->type == 26U) {
    goto case_26;
  }
  if ((unsigned int )token->type == 28U) {
    goto case_28;
  }
  if ((unsigned int )token->type == 30U) {
    goto case_30;
  }
  goto switch_default;
  case_26: /* CIL Label */ 
  elem->type = (bracket_elem_type )3;
  goto switch_break;
  case_28: /* CIL Label */ 
  elem->type = (bracket_elem_type )2;
  goto switch_break;
  case_30: /* CIL Label */ 
  elem->type = (bracket_elem_type )4;
  goto switch_break;
  switch_default: /* CIL Label */ 
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , unsigned char const   *name ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  {
  tmp = strlen((char const   *)name);
  tmp___0 = __builtin_expect((long )(tmp != 1UL), 0L);
  }
  if (tmp___0) {
    return ((reg_errcode_t )3);
  }
  *(sbcset + (unsigned long )*name / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*name % (sizeof(bitset_word_t ) * 8UL);
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) 
{ 
  int i ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  long tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  long tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  long tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  long tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  long tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  long tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  long tmp___21 ;
  unsigned short const   **tmp___22 ;
  unsigned short const   **tmp___23 ;
  long tmp___24 ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  long tmp___27 ;
  unsigned short const   **tmp___28 ;
  unsigned short const   **tmp___29 ;
  long tmp___30 ;
  unsigned short const   **tmp___31 ;
  unsigned short const   **tmp___32 ;
  long tmp___33 ;
  unsigned short const   **tmp___34 ;
  unsigned short const   **tmp___35 ;
  long tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;

  {
  name = (char const   *)class_name;
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
    tmp = strcmp(name, "upper");
    }
    if (tmp == 0) {
      name = "alpha";
    } else {
      {
      tmp___0 = strcmp(name, "lower");
      }
      if (tmp___0 == 0) {
        name = "alpha";
      }
    }
  }
  {
  tmp___48 = strcmp(name, "alnum");
  }
  if (tmp___48 == 0) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp___3 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                 0L);
      }
      if (tmp___3) {
        i = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (i < 256)) {
            goto while_break___0;
          }
          {
          tmp___1 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___1 + i) & 8) {
            *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
          }
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        i = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (i < 256)) {
            goto while_break___1;
          }
          {
          tmp___2 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___2 + i) & 8) {
            *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
          }
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    tmp___47 = strcmp(name, "cntrl");
    }
    if (tmp___47 == 0) {
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
        tmp___6 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                   0L);
        }
        if (tmp___6) {
          i = 0;
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if (! (i < 256)) {
              goto while_break___3;
            }
            {
            tmp___4 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___4 + i) & 2) {
              *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
            }
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
          i = 0;
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (! (i < 256)) {
              goto while_break___4;
            }
            {
            tmp___5 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___5 + i) & 2) {
              *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
            }
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
      tmp___46 = strcmp(name, "lower");
      }
      if (tmp___46 == 0) {
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
          tmp___9 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                     0L);
          }
          if (tmp___9) {
            i = 0;
            {
            while (1) {
              while_continue___6: /* CIL Label */ ;
              if (! (i < 256)) {
                goto while_break___6;
              }
              {
              tmp___7 = __ctype_b_loc();
              }
              if ((int const   )*(*tmp___7 + i) & 512) {
                *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
              }
              i ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
            i = 0;
            {
            while (1) {
              while_continue___7: /* CIL Label */ ;
              if (! (i < 256)) {
                goto while_break___7;
              }
              {
              tmp___8 = __ctype_b_loc();
              }
              if ((int const   )*(*tmp___8 + i) & 512) {
                *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
              }
              i ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
        tmp___45 = strcmp(name, "space");
        }
        if (tmp___45 == 0) {
          {
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
            tmp___12 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                        0L);
            }
            if (tmp___12) {
              i = 0;
              {
              while (1) {
                while_continue___9: /* CIL Label */ ;
                if (! (i < 256)) {
                  goto while_break___9;
                }
                {
                tmp___10 = __ctype_b_loc();
                }
                if ((int const   )*(*tmp___10 + i) & 8192) {
                  *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                }
                i ++;
              }
              while_break___9: /* CIL Label */ ;
              }
            } else {
              i = 0;
              {
              while (1) {
                while_continue___10: /* CIL Label */ ;
                if (! (i < 256)) {
                  goto while_break___10;
                }
                {
                tmp___11 = __ctype_b_loc();
                }
                if ((int const   )*(*tmp___11 + i) & 8192) {
                  *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                }
                i ++;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
          {
          tmp___44 = strcmp(name, "alpha");
          }
          if (tmp___44 == 0) {
            {
            while (1) {
              while_continue___11: /* CIL Label */ ;
              {
              tmp___15 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                          0L);
              }
              if (tmp___15) {
                i = 0;
                {
                while (1) {
                  while_continue___12: /* CIL Label */ ;
                  if (! (i < 256)) {
                    goto while_break___12;
                  }
                  {
                  tmp___13 = __ctype_b_loc();
                  }
                  if ((int const   )*(*tmp___13 + i) & 1024) {
                    *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                  }
                  i ++;
                }
                while_break___12: /* CIL Label */ ;
                }
              } else {
                i = 0;
                {
                while (1) {
                  while_continue___13: /* CIL Label */ ;
                  if (! (i < 256)) {
                    goto while_break___13;
                  }
                  {
                  tmp___14 = __ctype_b_loc();
                  }
                  if ((int const   )*(*tmp___14 + i) & 1024) {
                    *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                  }
                  i ++;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          } else {
            {
            tmp___43 = strcmp(name, "digit");
            }
            if (tmp___43 == 0) {
              {
              while (1) {
                while_continue___14: /* CIL Label */ ;
                {
                tmp___18 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                            0L);
                }
                if (tmp___18) {
                  i = 0;
                  {
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
                    if (! (i < 256)) {
                      goto while_break___15;
                    }
                    {
                    tmp___16 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___16 + i) & 2048) {
                      *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                    }
                    i ++;
                  }
                  while_break___15: /* CIL Label */ ;
                  }
                } else {
                  i = 0;
                  {
                  while (1) {
                    while_continue___16: /* CIL Label */ ;
                    if (! (i < 256)) {
                      goto while_break___16;
                    }
                    {
                    tmp___17 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___17 + i) & 2048) {
                      *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                    }
                    i ++;
                  }
                  while_break___16: /* CIL Label */ ;
                  }
                }
                goto while_break___14;
              }
              while_break___14: /* CIL Label */ ;
              }
            } else {
              {
              tmp___42 = strcmp(name, "print");
              }
              if (tmp___42 == 0) {
                {
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  {
                  tmp___21 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                              0L);
                  }
                  if (tmp___21) {
                    i = 0;
                    {
                    while (1) {
                      while_continue___18: /* CIL Label */ ;
                      if (! (i < 256)) {
                        goto while_break___18;
                      }
                      {
                      tmp___19 = __ctype_b_loc();
                      }
                      if ((int const   )*(*tmp___19 + i) & 16384) {
                        *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                      }
                      i ++;
                    }
                    while_break___18: /* CIL Label */ ;
                    }
                  } else {
                    i = 0;
                    {
                    while (1) {
                      while_continue___19: /* CIL Label */ ;
                      if (! (i < 256)) {
                        goto while_break___19;
                      }
                      {
                      tmp___20 = __ctype_b_loc();
                      }
                      if ((int const   )*(*tmp___20 + i) & 16384) {
                        *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                      }
                      i ++;
                    }
                    while_break___19: /* CIL Label */ ;
                    }
                  }
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
              } else {
                {
                tmp___41 = strcmp(name, "upper");
                }
                if (tmp___41 == 0) {
                  {
                  while (1) {
                    while_continue___20: /* CIL Label */ ;
                    {
                    tmp___24 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                0L);
                    }
                    if (tmp___24) {
                      i = 0;
                      {
                      while (1) {
                        while_continue___21: /* CIL Label */ ;
                        if (! (i < 256)) {
                          goto while_break___21;
                        }
                        {
                        tmp___22 = __ctype_b_loc();
                        }
                        if ((int const   )*(*tmp___22 + i) & 256) {
                          *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                        }
                        i ++;
                      }
                      while_break___21: /* CIL Label */ ;
                      }
                    } else {
                      i = 0;
                      {
                      while (1) {
                        while_continue___22: /* CIL Label */ ;
                        if (! (i < 256)) {
                          goto while_break___22;
                        }
                        {
                        tmp___23 = __ctype_b_loc();
                        }
                        if ((int const   )*(*tmp___23 + i) & 256) {
                          *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                        }
                        i ++;
                      }
                      while_break___22: /* CIL Label */ ;
                      }
                    }
                    goto while_break___20;
                  }
                  while_break___20: /* CIL Label */ ;
                  }
                } else {
                  {
                  tmp___40 = strcmp(name, "blank");
                  }
                  if (tmp___40 == 0) {
                    {
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
                      {
                      tmp___27 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                  0L);
                      }
                      if (tmp___27) {
                        i = 0;
                        {
                        while (1) {
                          while_continue___24: /* CIL Label */ ;
                          if (! (i < 256)) {
                            goto while_break___24;
                          }
                          {
                          tmp___25 = __ctype_b_loc();
                          }
                          if ((int const   )*(*tmp___25 + i) & 1) {
                            *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                          }
                          i ++;
                        }
                        while_break___24: /* CIL Label */ ;
                        }
                      } else {
                        i = 0;
                        {
                        while (1) {
                          while_continue___25: /* CIL Label */ ;
                          if (! (i < 256)) {
                            goto while_break___25;
                          }
                          {
                          tmp___26 = __ctype_b_loc();
                          }
                          if ((int const   )*(*tmp___26 + i) & 1) {
                            *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                          }
                          i ++;
                        }
                        while_break___25: /* CIL Label */ ;
                        }
                      }
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                  } else {
                    {
                    tmp___39 = strcmp(name, "graph");
                    }
                    if (tmp___39 == 0) {
                      {
                      while (1) {
                        while_continue___26: /* CIL Label */ ;
                        {
                        tmp___30 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                    0L);
                        }
                        if (tmp___30) {
                          i = 0;
                          {
                          while (1) {
                            while_continue___27: /* CIL Label */ ;
                            if (! (i < 256)) {
                              goto while_break___27;
                            }
                            {
                            tmp___28 = __ctype_b_loc();
                            }
                            if ((int const   )*(*tmp___28 + i) & 32768) {
                              *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                            }
                            i ++;
                          }
                          while_break___27: /* CIL Label */ ;
                          }
                        } else {
                          i = 0;
                          {
                          while (1) {
                            while_continue___28: /* CIL Label */ ;
                            if (! (i < 256)) {
                              goto while_break___28;
                            }
                            {
                            tmp___29 = __ctype_b_loc();
                            }
                            if ((int const   )*(*tmp___29 + i) & 32768) {
                              *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                            }
                            i ++;
                          }
                          while_break___28: /* CIL Label */ ;
                          }
                        }
                        goto while_break___26;
                      }
                      while_break___26: /* CIL Label */ ;
                      }
                    } else {
                      {
                      tmp___38 = strcmp(name, "punct");
                      }
                      if (tmp___38 == 0) {
                        {
                        while (1) {
                          while_continue___29: /* CIL Label */ ;
                          {
                          tmp___33 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                      0L);
                          }
                          if (tmp___33) {
                            i = 0;
                            {
                            while (1) {
                              while_continue___30: /* CIL Label */ ;
                              if (! (i < 256)) {
                                goto while_break___30;
                              }
                              {
                              tmp___31 = __ctype_b_loc();
                              }
                              if ((int const   )*(*tmp___31 + i) & 4) {
                                *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                              }
                              i ++;
                            }
                            while_break___30: /* CIL Label */ ;
                            }
                          } else {
                            i = 0;
                            {
                            while (1) {
                              while_continue___31: /* CIL Label */ ;
                              if (! (i < 256)) {
                                goto while_break___31;
                              }
                              {
                              tmp___32 = __ctype_b_loc();
                              }
                              if ((int const   )*(*tmp___32 + i) & 4) {
                                *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                              }
                              i ++;
                            }
                            while_break___31: /* CIL Label */ ;
                            }
                          }
                          goto while_break___29;
                        }
                        while_break___29: /* CIL Label */ ;
                        }
                      } else {
                        {
                        tmp___37 = strcmp(name, "xdigit");
                        }
                        if (tmp___37 == 0) {
                          {
                          while (1) {
                            while_continue___32: /* CIL Label */ ;
                            {
                            tmp___36 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                        0L);
                            }
                            if (tmp___36) {
                              i = 0;
                              {
                              while (1) {
                                while_continue___33: /* CIL Label */ ;
                                if (! (i < 256)) {
                                  goto while_break___33;
                                }
                                {
                                tmp___34 = __ctype_b_loc();
                                }
                                if ((int const   )*(*tmp___34 + i) & 4096) {
                                  *(sbcset + (unsigned long )*(trans + i) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i) % (sizeof(bitset_word_t ) * 8UL);
                                }
                                i ++;
                              }
                              while_break___33: /* CIL Label */ ;
                              }
                            } else {
                              i = 0;
                              {
                              while (1) {
                                while_continue___34: /* CIL Label */ ;
                                if (! (i < 256)) {
                                  goto while_break___34;
                                }
                                {
                                tmp___35 = __ctype_b_loc();
                                }
                                if ((int const   )*(*tmp___35 + i) & 4096) {
                                  *(sbcset + (unsigned long )i / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i % (sizeof(bitset_word_t ) * 8UL);
                                }
                                i ++;
                              }
                              while_break___34: /* CIL Label */ ;
                              }
                            }
                            goto while_break___32;
                          }
                          while_break___32: /* CIL Label */ ;
                          }
                        } else {
                          return ((reg_errcode_t )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return ((reg_errcode_t )0);
}
}
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , int non_match ,
                                      reg_errcode_t *err ) 
{ 
  re_bitset_ptr_t sbcset ;
  reg_errcode_t ret ;
  re_token_t br_token ;
  bin_tree_t *tree ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
  sbcset = (re_bitset_ptr_t )tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )sbcset == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    *err = (reg_errcode_t )12;
    return ((bin_tree_t *)((void *)0));
  }
  {
  ret = build_charclass(trans, sbcset, class_name, (reg_syntax_t )0);
  tmp___1 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  if (tmp___1) {
    {
    free((void *)sbcset);
    *err = ret;
    }
    return ((bin_tree_t *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *extra) {
      goto while_break;
    }
    *(sbcset + (unsigned long )*extra / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*extra % (sizeof(bitset_word_t ) * 8UL);
    extra ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (non_match) {
    {
    bitset_not(sbcset);
    }
  }
  {
  br_token.type = (re_token_type_t )3;
  br_token.opr.sbcset = sbcset;
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)(& br_token));
  tmp___2 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___2) {
    goto build_word_op_espace;
  }
  return (tree);
  build_word_op_espace: 
  {
  free((void *)sbcset);
  *err = (reg_errcode_t )12;
  }
  return ((bin_tree_t *)((void *)0));
}
}
static int fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ 
  int num ;
  unsigned char c ;
  long tmp ;
  int tmp___0 ;

  {
  num = -1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    fetch_token(token, input, syntax);
    c = token->opr.c;
    tmp = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
    if (tmp) {
      return (-2);
    }
    if ((unsigned int )token->type == 24U) {
      goto while_break;
    } else { //Added block
    if ((int )c == 44) {
      goto while_break;
    }
    }
    if ((unsigned int )token->type != 1U) {
      num = -2;
    } else { //Added block
    if ((int )c < 48) {
      num = -2;
    } else { //Added block
    if (57 < (int )c) {
      num = -2;
    } else { //Added block
    if (num == -2) {
      num = -2;
    } else {
      if (num == -1) {
        tmp___0 = (int )c - 48;
      } else {
        tmp___0 = (num * 10 + (int )c) - 48;
      }
      num = tmp___0;
    }
    }
    }
    }
    if (num > 32767) {
      num = -2;
    } else {
      num = num;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (num);
}
}
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) 
{ 
  re_token_t t ;
  bin_tree_t *tmp ;

  {
  {
  t.type = type;
  tmp = create_token_tree(dfa, left, right, (re_token_t const   *)(& t));
  }
  return (tmp);
}
}
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) 
{ 
  bin_tree_t *tree ;
  bin_tree_storage_t *storage ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___0 = __builtin_expect((long )((unsigned long )dfa->str_tree_storage_idx == (1024UL - sizeof(void *)) / sizeof(bin_tree_t )),
                             0L);
  }
  if (tmp___0) {
    {
    tmp = malloc(sizeof(bin_tree_storage_t ));
    storage = (bin_tree_storage_t *)tmp;
    }
    if ((unsigned long )storage == (unsigned long )((void *)0)) {
      return ((bin_tree_t *)((void *)0));
    }
    storage->next = dfa->str_tree_storage;
    dfa->str_tree_storage = storage;
    dfa->str_tree_storage_idx = 0;
  }
  tmp___1 = dfa->str_tree_storage_idx;
  (dfa->str_tree_storage_idx) ++;
  tree = & (dfa->str_tree_storage)->data[tmp___1];
  tree->parent = (struct bin_tree_t *)((void *)0);
  tree->left = left;
  tree->right = right;
  tree->token = (re_token_t )*token;
  tree->token.duplicated = 0U;
  tree->token.opt_subexp = 0U;
  tree->first = (struct bin_tree_t *)((void *)0);
  tree->next = (struct bin_tree_t *)((void *)0);
  tree->node_idx = -1;
  if ((unsigned long )left != (unsigned long )((void *)0)) {
    left->parent = tree;
  }
  if ((unsigned long )right != (unsigned long )((void *)0)) {
    right->parent = tree;
  }
  return (tree);
}
}
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) 
{ 
  int idx ;

  {
  idx = (int )((long )extra);
  if ((unsigned int )node->token.type == 17U) {
    if (node->token.opr.idx == idx) {
      node->token.opt_subexp = 1U;
    }
  }
  return ((reg_errcode_t )0);
}
}
static void free_token(re_token_t *node ) 
{ 


  {
  if ((unsigned int )node->type == 3U) {
    if (node->duplicated == 0U) {
      {
      free((void *)node->opr.sbcset);
      }
    }
  }
  return;
}
}
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) 
{ 


  {
  {
  free_token(& node->token);
  }
  return ((reg_errcode_t )0);
}
}
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) 
{ 
  bin_tree_t const   *node ;
  bin_tree_t *dup_root ;
  bin_tree_t **p_new ;
  bin_tree_t *dup_node ;
  bin_tree_t const   *prev ;

  {
  p_new = & dup_root;
  dup_node = (bin_tree_t *)root->parent;
  node = root;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    *p_new = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               & node->token);
    }
    if ((unsigned long )*p_new == (unsigned long )((void *)0)) {
      return ((bin_tree_t *)((void *)0));
    }
    (*p_new)->parent = dup_node;
    (*p_new)->token.duplicated = 1U;
    dup_node = *p_new;
    if (node->left) {
      node = (bin_tree_t const   *)node->left;
      p_new = & dup_node->left;
    } else {
      prev = (bin_tree_t const   *)((void *)0);
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
            goto while_break___0;
          }
        }
        prev = node;
        node = (bin_tree_t const   *)node->parent;
        dup_node = dup_node->parent;
        if (! node) {
          return (dup_root);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      node = (bin_tree_t const   *)node->right;
      p_new = & dup_node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , int n ) ;
static void match_ctx_clean(re_match_context_t *mctx ) ;
static void match_ctx_free(re_match_context_t *mctx ) ;
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , int node , int str_idx ,
                                         int from , int to ) ;
static int search_cur_bkref_entry(re_match_context_t const   *mctx , int str_idx ) ;
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , int node , int str_idx ) ;
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , int node ,
                                                  int str_idx ) ;
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          int last_node , int last_str_idx ) ;
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        int length , int start , int range , int stop ,
                                        size_t nmatch , regmatch_t *pmatch , int eflags ) ;
static int re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int length1 , char const   *string2 , int length2 , int start ,
                            int range , struct re_registers *regs___0 , int stop ,
                            int ret_len ) ;
static int re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                          int length , int start , int range , int stop , struct re_registers *regs___0 ,
                          int ret_len ) ;
static unsigned int re_copy_regs(struct re_registers *regs___0 , regmatch_t *pmatch ,
                                 int nregs , int regs_allocated ) ;
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) ;
static int check_matching(re_match_context_t *mctx , int fl_longest_match , int *p_match_first ) ;
static int check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    int idx ) ;
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        int cur_node , int cur_idx , int nmatch ) ;
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , int str_idx , int dest_node ,
                                     int nregs , regmatch_t *regs___0 , re_node_set *eps_via_nodes ) ;
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , int fl_backtrack ) ;
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) ;
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) ;
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         int str_idx , re_node_set *cur_dest ) ;
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             int str_idx , re_node_set *dest_nodes ) ;
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) ;
static int check_dst_limits(re_match_context_t const   *mctx , re_node_set *limits ,
                            int dst_node , int dst_idx , int src_node , int src_idx ) ;
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       int subexp_idx , int from_node , int bkref_idx ) ;
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , int limit ,
                                     int subexp_idx , int from_node , int str_idx ,
                                     int bkref_idx ) ;
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         int str_idx ) ;
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       int str_idx , re_node_set const   *candidates ) ;
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , int num ) ;
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) ;
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state ) ;
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) ;
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               int str_idx ) ;
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) ;
static reg_errcode_t get_subexp(re_match_context_t *mctx , int bkref_node , int bkref_str_idx ) ;
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , int bkref_node ,
                                    int bkref_str ) ;
static int find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , int subexp_idx ,
                            int type ) ;
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   int top_node , int top_str , int last_node , int last_str ,
                                   int type ) ;
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , int str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) ;
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              int ex_subexp , int type ) ;
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  int target , int ex_subexp , int type ) ;
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        int cur_str , int subexp_num , int type ) ;
static int build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) ;
static int group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) ;
static int check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                             int idx ) ;
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) ;
int regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
            size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  reg_errcode_t err ;
  int start ;
  int length ;
  re_dfa_t *dfa ;
  size_t tmp ;

  {
  dfa = (re_dfa_t *)preg->buffer;
  if (eflags & ~ ((1 | (1 << 1)) | (1 << 2))) {
    return (2);
  }
  if (eflags & (1 << 2)) {
    start = (pmatch + 0)->rm_so;
    length = (pmatch + 0)->rm_eo;
  } else {
    {
    start = 0;
    tmp = strlen((char const   *)string);
    length = (int )tmp;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (preg->no_sub) {
    {
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length - start, length, (size_t )0, (regmatch_t *)((void *)0),
                             eflags);
    }
  } else {
    {
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length - start, length, nmatch, (regmatch_t *)pmatch,
                             eflags);
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((unsigned int )err != 0U);
}
}
int re_match(struct re_pattern_buffer *bufp , char const   *string , int length ,
             int start , struct re_registers *regs___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = re_search_stub(bufp, string, length, start, 0, length, regs___0, 1);
  }
  return (tmp);
}
}
int re_search(struct re_pattern_buffer *bufp , char const   *string , int length ,
              int start , int range , struct re_registers *regs___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = re_search_stub(bufp, string, length, start, range, length, regs___0, 0);
  }
  return (tmp);
}
}
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
               char const   *string2 , int length2 , int start , struct re_registers *regs___0 ,
               int stop ) 
{ 
  int tmp ;

  {
  {
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, 0, regs___0,
                         stop, 1);
  }
  return (tmp);
}
}
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
                char const   *string2 , int length2 , int start , int range , struct re_registers *regs___0 ,
                int stop ) 
{ 
  int tmp ;

  {
  {
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, range, regs___0,
                         stop, 0);
  }
  return (tmp);
}
}
static int re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int length1 , char const   *string2 , int length2 , int start ,
                            int range , struct re_registers *regs___0 , int stop ,
                            int ret_len ) 
{ 
  char const   *str ;
  int rval ;
  int len ;
  int free_str ;
  int tmp ;
  long tmp___0 ;
  char *s ;
  void *tmp___1 ;
  long tmp___2 ;

  {
  len = length1 + length2;
  free_str = 0;
  if (length1 < 0) {
    tmp = 1;
  } else { //Added block
  if (length2 < 0) {
    tmp = 1;
  } else { //Added block
  if (stop < 0) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  {
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  if (tmp___0) {
    return (-2);
  }
  if (length2 > 0) {
    if (length1 > 0) {
      {
      tmp___1 = malloc((unsigned long )len * sizeof(char ));
      s = (char *)tmp___1;
      tmp___2 = __builtin_expect((long )((unsigned long )s == (unsigned long )((void *)0)),
                                 0L);
      }
      if (tmp___2) {
        return (-2);
      }
      {
      memmove((void * __restrict  )s, (void const   * __restrict  )string1, (size_t )length1);
      memmove((void * __restrict  )(s + length1), (void const   * __restrict  )string2,
              (size_t )length2);
      str = (char const   *)s;
      free_str = 1;
      }
    } else {
      str = string2;
    }
  } else {
    str = string1;
  }
  {
  rval = re_search_stub(bufp, str, len, start, range, stop, regs___0, ret_len);
  }
  if (free_str) {
    {
    free((void *)((char *)str));
    }
  }
  return (rval);
}
}
static int re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                          int length , int start , int range , int stop , struct re_registers *regs___0 ,
                          int ret_len ) 
{ 
  reg_errcode_t result ;
  regmatch_t *pmatch ;
  int nregs ;
  int rval ;
  int eflags ;
  re_dfa_t *dfa ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___13 ;

  {
  eflags = 0;
  dfa = (re_dfa_t *)bufp->buffer;
  if (start < 0) {
    tmp = 1;
  } else { //Added block
  if (start > length) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  {
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
  if (tmp___0) {
    return (-1);
  }
  {
  tmp___2 = __builtin_expect((long )(start + range > length), 0L);
  }
  if (tmp___2) {
    range = length - start;
  } else {
    {
    tmp___1 = __builtin_expect((long )(start + range < 0), 0L);
    }
    if (tmp___1) {
      range = - start;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (bufp->not_bol) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  eflags |= tmp___3;
  if (bufp->not_eol) {
    tmp___4 = 1 << 1;
  } else {
    tmp___4 = 0;
  }
  eflags |= tmp___4;
  if (range > 0) {
    if ((unsigned long )bufp->fastmap != (unsigned long )((void *)0)) {
      if (! bufp->fastmap_accurate) {
        {
        re_compile_fastmap(bufp);
        }
      }
    }
  }
  {
  tmp___5 = __builtin_expect((long )bufp->no_sub, 0L);
  }
  if (tmp___5) {
    regs___0 = (struct re_registers *)((void *)0);
  }
  if ((unsigned long )regs___0 == (unsigned long )((void *)0)) {
    nregs = 1;
  } else {
    if (bufp->regs_allocated == 2U) {
      if ((size_t )regs___0->num_regs < bufp->re_nsub + 1UL) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    {
    tmp___8 = __builtin_expect((long )tmp___7, 0L);
    }
    if (tmp___8) {
      {
      nregs = (int )regs___0->num_regs;
      tmp___6 = __builtin_expect((long )(nregs < 1), 0L);
      }
      if (tmp___6) {
        regs___0 = (struct re_registers *)((void *)0);
        nregs = 1;
      }
    } else {
      nregs = (int )(bufp->re_nsub + 1UL);
    }
  }
  {
  tmp___9 = malloc((unsigned long )nregs * sizeof(regmatch_t ));
  pmatch = (regmatch_t *)tmp___9;
  tmp___10 = __builtin_expect((long )((unsigned long )pmatch == (unsigned long )((void *)0)),
                              0L);
  }
  if (tmp___10) {
    rval = -2;
    goto out;
  }
  {
  result = re_search_internal((regex_t const   *)bufp, string, length, start, range,
                              stop, (size_t )nregs, pmatch, eflags);
  rval = 0;
  }
  if ((unsigned int )result != 0U) {
    rval = -1;
  } else { //Added block
  if ((unsigned long )regs___0 != (unsigned long )((void *)0)) {
    {
    bufp->regs_allocated = re_copy_regs(regs___0, pmatch, nregs, (int )bufp->regs_allocated);
    tmp___11 = __builtin_expect((long )(bufp->regs_allocated == 0U), 0L);
    }
    if (tmp___11) {
      rval = -2;
    }
  }
  }
  {
  tmp___13 = __builtin_expect((long )(rval == 0), 1L);
  }
  if (tmp___13) {
    if (ret_len) {
      if (! ((pmatch + 0)->rm_so == start)) {
        {
        __assert_fail("pmatch[0].rm_so == start", "regexec.c", 487U, "re_search_stub");
        }
      }
      rval = (pmatch + 0)->rm_eo - start;
    } else {
      rval = (pmatch + 0)->rm_so;
    }
  }
  {
  free((void *)pmatch);
  }
  out: 
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (rval);
}
}
static unsigned int re_copy_regs(struct re_registers *regs___0 , regmatch_t *pmatch ,
                                 int nregs , int regs_allocated ) 
{ 
  int rval ;
  int i ;
  int need_regs ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  regoff_t *new_start ;
  void *tmp___3 ;
  regoff_t *new_end ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  regoff_t tmp___10 ;

  {
  rval = 1;
  need_regs = nregs + 1;
  if (regs_allocated == 0) {
    {
    tmp = malloc((unsigned long )need_regs * sizeof(regoff_t ));
    regs___0->start = (regoff_t *)tmp;
    tmp___0 = malloc((unsigned long )need_regs * sizeof(regoff_t ));
    regs___0->end = (regoff_t *)tmp___0;
    tmp___1 = __builtin_expect((long )((unsigned long )regs___0->start == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___1) {
      return (0U);
    } else {
      {
      tmp___2 = __builtin_expect((long )((unsigned long )regs___0->end == (unsigned long )((void *)0)),
                                 0L);
      }
      if (tmp___2) {
        return (0U);
      }
    }
    regs___0->num_regs = (unsigned int )need_regs;
  } else { //Added block
  if (regs_allocated == 1) {
    {
    tmp___7 = __builtin_expect((long )((unsigned int )need_regs > regs___0->num_regs),
                               0L);
    }
    if (tmp___7) {
      {
      tmp___3 = realloc((void *)regs___0->start, (unsigned long )need_regs * sizeof(regoff_t ));
      new_start = (regoff_t *)tmp___3;
      tmp___4 = realloc((void *)regs___0->end, (unsigned long )need_regs * sizeof(regoff_t ));
      new_end = (regoff_t *)tmp___4;
      tmp___5 = __builtin_expect((long )((unsigned long )new_start == (unsigned long )((void *)0)),
                                 0L);
      }
      if (tmp___5) {
        return (0U);
      } else {
        {
        tmp___6 = __builtin_expect((long )((unsigned long )new_end == (unsigned long )((void *)0)),
                                   0L);
        }
        if (tmp___6) {
          return (0U);
        }
      }
      regs___0->start = new_start;
      regs___0->end = new_end;
      regs___0->num_regs = (unsigned int )need_regs;
    }
  } else {
    if (! (regs_allocated == 2)) {
      {
      __assert_fail("regs_allocated == REGS_FIXED", "regexec.c", 537U, "re_copy_regs");
      }
    }
    if (! (regs___0->num_regs >= (unsigned int )nregs)) {
      {
      __assert_fail("regs->num_regs >= nregs", "regexec.c", 539U, "re_copy_regs");
      }
    }
    rval = 2;
  }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < nregs)) {
      goto while_break;
    }
    *(regs___0->start + i) = (pmatch + i)->rm_so;
    *(regs___0->end + i) = (pmatch + i)->rm_eo;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned int )i < regs___0->num_regs)) {
      goto while_break___0;
    }
    tmp___10 = -1;
    *(regs___0->end + i) = tmp___10;
    *(regs___0->start + i) = tmp___10;
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((unsigned int )rval);
}
}
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs___0 ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp ;

  {
  if (num_regs) {
    bufp->regs_allocated = 1U;
    regs___0->num_regs = num_regs;
    regs___0->start = starts;
    regs___0->end = ends;
  } else {
    bufp->regs_allocated = 0U;
    regs___0->num_regs = 0U;
    tmp = (regoff_t *)0;
    regs___0->end = tmp;
    regs___0->start = tmp;
  }
  return;
}
}
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        int length , int start , int range , int stop ,
                                        size_t nmatch , regmatch_t *pmatch , int eflags ) 
{ 
  reg_errcode_t err ;
  re_dfa_t const   *dfa ;
  int left_lim ;
  int right_lim ;
  int incr ;
  int fl_longest_match ;
  int match_first ;
  int match_kind ;
  int match_last ;
  int extra_nmatch ;
  int sb ;
  int ch ;
  re_match_context_t mctx ;
  char *fastmap ;
  char *tmp ;
  unsigned char *t ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  unsigned int offset ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  int *tmp___18 ;
  re_dfastate_t *pstate ;
  long tmp___19 ;
  long tmp___20 ;
  int reg_idx ;
  regoff_t tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;

  {
  dfa = (re_dfa_t const   *)preg->buffer;
  match_last = -1;
  mctx.input.raw_mbs = (unsigned char const   *)0;
  mctx.input.mbs = (unsigned char *)0;
  mctx.input.raw_mbs_idx = 0;
  mctx.input.valid_len = 0;
  mctx.input.valid_raw_len = 0;
  mctx.input.bufs_len = 0;
  mctx.input.cur_idx = 0;
  mctx.input.raw_len = 0;
  mctx.input.len = 0;
  mctx.input.raw_stop = 0;
  mctx.input.stop = 0;
  mctx.input.tip_context = 0U;
  mctx.input.trans = (unsigned char *)0;
  mctx.input.word_char = (bitset_word_t const   *)0;
  mctx.input.icase = (unsigned char)0;
  mctx.input.is_utf8 = (unsigned char)0;
  mctx.input.map_notascii = (unsigned char)0;
  mctx.input.mbs_allocated = (unsigned char)0;
  mctx.input.offsets_needed = (unsigned char)0;
  mctx.input.newline_anchor = (unsigned char)0;
  mctx.input.word_ops_used = (unsigned char)0;
  mctx.input.mb_cur_max = 0;
  mctx.dfa = dfa;
  mctx.eflags = 0;
  mctx.match_last = 0;
  mctx.last_node = 0;
  mctx.state_log = (re_dfastate_t **)0;
  mctx.state_log_top = 0;
  mctx.nbkref_ents = 0;
  mctx.abkref_ents = 0;
  mctx.bkref_ents = (struct re_backref_cache_entry *)0;
  mctx.max_mb_elem_len = 0;
  mctx.nsub_tops = 0;
  mctx.asub_tops = 0;
  mctx.sub_tops = (re_sub_match_top_t **)0;
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
    if (preg->fastmap_accurate) {
      if (range) {
        if (! preg->can_be_null) {
          tmp = (char *)preg->fastmap;
        } else {
          tmp = (char *)((char * const  )((void *)0));
        }
      } else {
        tmp = (char *)((char * const  )((void *)0));
      }
    } else {
      tmp = (char *)((char * const  )((void *)0));
    }
  } else {
    tmp = (char *)((char * const  )((void *)0));
  }
  fastmap = tmp;
  t = (unsigned char *)preg->translate;
  if (nmatch > (size_t )preg->re_nsub) {
    extra_nmatch = (int )(nmatch - (size_t )(preg->re_nsub + 1UL));
  } else {
    extra_nmatch = 0;
  }
  nmatch -= (size_t )extra_nmatch;
  if (preg->used == 0UL) {
    tmp___0 = 1;
  } else { //Added block
  if ((unsigned long )dfa->init_state == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else { //Added block
  if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else { //Added block
  if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else { //Added block
  if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  }
  }
  }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return ((reg_errcode_t )1);
  }
  if ((dfa->init_state)->nodes.nelem == 0) {
    if ((dfa->init_state_word)->nodes.nelem == 0) {
      if ((dfa->init_state_nl)->nodes.nelem == 0) {
        goto _L;
      } else { //Added block
      if (! preg->newline_anchor) {
        _L: 
        if (start != 0) {
          if (start + range != 0) {
            return ((reg_errcode_t )1);
          }
        }
        range = 0;
        start = range;
      }
      }
    }
  }
  if (nmatch != 0UL) {
    tmp___2 = 1;
  } else { //Added block
  if (dfa->nbackref) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  }
  {
  fl_longest_match = tmp___2;
  err = re_string_allocate(& mctx.input, string, length, (int )(dfa->nodes_len + 1UL),
                           (unsigned char *)preg->translate, (int )(preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
                           dfa);
  tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___3) {
    goto free_return;
  }
  {
  mctx.input.stop = stop;
  mctx.input.raw_stop = stop;
  mctx.input.newline_anchor = (unsigned char )preg->newline_anchor;
  err = match_ctx_init(& mctx, eflags, (int )(dfa->nbackref * 2));
  tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___4) {
    goto free_return;
  }
  if (nmatch > 1UL) {
    goto _L___0;
  } else { //Added block
  if (dfa->has_mb_node) {
    _L___0: 
    {
    tmp___5 = malloc((unsigned long )(mctx.input.bufs_len + 1) * sizeof(re_dfastate_t *));
    mctx.state_log = (re_dfastate_t **)tmp___5;
    tmp___6 = __builtin_expect((long )((unsigned long )mctx.state_log == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___6) {
      err = (reg_errcode_t )12;
      goto free_return;
    }
  } else {
    mctx.state_log = (re_dfastate_t **)((void *)0);
  }
  }
  match_first = start;
  if (eflags & 1) {
    mctx.input.tip_context = (unsigned int )((1 << 1) << 1);
  } else {
    mctx.input.tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
  }
  if (range < 0) {
    incr = -1;
  } else {
    incr = 1;
  }
  if (range < 0) {
    left_lim = start + range;
  } else {
    left_lim = start;
  }
  if (range < 0) {
    right_lim = start;
  } else {
    right_lim = start + range;
  }
  sb = dfa->mb_cur_max == 1;
  if (fastmap) {
    if (sb) {
      tmp___7 = 4;
    } else { //Added block
    if (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      tmp___7 = 0;
    } else { //Added block
    if (t) {
      tmp___7 = 0;
    } else {
      tmp___7 = 4;
    }
    }
    }
    if (range >= 0) {
      tmp___8 = 2;
    } else {
      tmp___8 = 0;
    }
    if ((unsigned long )t != (unsigned long )((void *)0)) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
    match_kind = (tmp___7 | tmp___8) | tmp___9;
  } else {
    match_kind = 8;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    err = (reg_errcode_t )1;
    if (match_first < left_lim) {
      goto free_return;
    } else { //Added block
    if (right_lim < match_first) {
      goto free_return;
    }
    }
    {
    if (match_kind == 8) {
      goto case_8;
    }
    if (match_kind == 7) {
      goto case_7;
    }
    if (match_kind == 6) {
      goto case_6;
    }
    if (match_kind == 4) {
      goto case_4;
    }
    if (match_kind == 5) {
      goto case_4;
    }
    goto switch_default;
    case_8: /* CIL Label */ 
    goto switch_break;
    case_7: /* CIL Label */ 
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___10 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
      if (tmp___10) {
        if (! (! *(fastmap + (int )*(t + (int )((unsigned char )*(string + match_first)))))) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      match_first ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    goto forward_match_found_start_or_reached_end;
    case_6: /* CIL Label */ 
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___11 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
      if (tmp___11) {
        if (! (! *(fastmap + (int )((unsigned char )*(string + match_first))))) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      match_first ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    forward_match_found_start_or_reached_end: 
    {
    tmp___13 = __builtin_expect((long )(match_first == right_lim), 0L);
    }
    if (tmp___13) {
      if (match_first >= length) {
        ch = 0;
      } else {
        ch = (int )((unsigned char )*(string + match_first));
      }
      if (t) {
        tmp___12 = (int )*(t + ch);
      } else {
        tmp___12 = ch;
      }
      if (! *(fastmap + tmp___12)) {
        goto free_return;
      }
    }
    goto switch_break;
    case_4: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (match_first >= left_lim)) {
        goto while_break___2;
      }
      if (match_first >= length) {
        ch = 0;
      } else {
        ch = (int )((unsigned char )*(string + match_first));
      }
      if (t) {
        tmp___14 = (int )*(t + ch);
      } else {
        tmp___14 = ch;
      }
      if (*(fastmap + tmp___14)) {
        goto while_break___2;
      }
      match_first --;
    }
    while_break___2: /* CIL Label */ ;
    }
    if (match_first < left_lim) {
      goto free_return;
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
      offset = (unsigned int )(match_first - mctx.input.raw_mbs_idx);
      tmp___16 = __builtin_expect((long )(offset >= (unsigned int )mctx.input.valid_raw_len),
                                  0L);
      }
      if (tmp___16) {
        {
        err = re_string_reconstruct(& mctx.input, match_first, eflags);
        tmp___15 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___15) {
          goto free_return;
        }
        offset = (unsigned int )(match_first - mctx.input.raw_mbs_idx);
      }
      if (match_first >= length) {
        ch = 0;
      } else {
        ch = (int )*(mctx.input.mbs + offset);
      }
      if (*(fastmap + ch)) {
        goto while_break___3;
      }
      match_first += incr;
      if (match_first < left_lim) {
        err = (reg_errcode_t )1;
        goto free_return;
      } else { //Added block
      if (match_first > right_lim) {
        err = (reg_errcode_t )1;
        goto free_return;
      }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    err = re_string_reconstruct(& mctx.input, match_first, eflags);
    tmp___17 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp___17) {
      goto free_return;
    }
    mctx.max_mb_elem_len = 0;
    mctx.nbkref_ents = mctx.max_mb_elem_len;
    mctx.state_log_top = mctx.nbkref_ents;
    if (range >= 0) {
      tmp___18 = & match_first;
    } else {
      tmp___18 = (int *)((void *)0);
    }
    {
    match_last = check_matching(& mctx, fl_longest_match, tmp___18);
    }
    if (match_last != -1) {
      {
      tmp___20 = __builtin_expect((long )(match_last == -2), 0L);
      }
      if (tmp___20) {
        err = (reg_errcode_t )12;
        goto free_return;
      } else {
        mctx.match_last = match_last;
        if (! preg->no_sub) {
          if (nmatch > 1UL) {
            {
            pstate = *(mctx.state_log + match_last);
            mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                      (re_dfastate_t const   *)pstate,
                                                      match_last);
            }
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if (dfa->nbackref) {
          {
          pstate = *(mctx.state_log + match_last);
          mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                    (re_dfastate_t const   *)pstate,
                                                    match_last);
          }
        }
        }
        if (! preg->no_sub) {
          if (nmatch > 1UL) {
            if (dfa->has_plural_match) {
              goto _L___2;
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else { //Added block
        _L___4: 
        if (dfa->nbackref) {
          _L___2: 
          {
          err = prune_impossible_nodes(& mctx);
          }
          if ((unsigned int )err == 0U) {
            goto while_break;
          }
          {
          tmp___19 = __builtin_expect((long )((unsigned int )err != 1U), 0L);
          }
          if (tmp___19) {
            goto free_return;
          }
          match_last = -1;
        } else {
          goto while_break;
        }
        }
      }
    }
    {
    match_ctx_clean(& mctx);
    match_first += incr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (nmatch > 0UL) {
    reg_idx = 1;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ((size_t )reg_idx < nmatch)) {
        goto while_break___4;
      }
      tmp___21 = -1;
      (pmatch + reg_idx)->rm_eo = tmp___21;
      (pmatch + reg_idx)->rm_so = tmp___21;
      reg_idx ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    (pmatch + 0)->rm_so = 0;
    (pmatch + 0)->rm_eo = mctx.match_last;
    if (! preg->no_sub) {
      if (nmatch > 1UL) {
        if (dfa->has_plural_match) {
          if (dfa->nbackref > 0) {
            tmp___22 = 1;
          } else {
            tmp___22 = 0;
          }
        } else {
          tmp___22 = 0;
        }
        {
        err = set_regs(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                       tmp___22);
        tmp___23 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___23) {
          goto free_return;
        }
      }
    }
    reg_idx = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! ((size_t )reg_idx < nmatch)) {
        goto while_break___5;
      }
      if ((pmatch + reg_idx)->rm_so != -1) {
        if (! ((int )mctx.input.offsets_needed == 0)) {
          {
          __assert_fail("mctx.input.offsets_needed == 0", "regexec.c", 908U, "re_search_internal");
          }
        }
        (pmatch + reg_idx)->rm_so += match_first;
        (pmatch + reg_idx)->rm_eo += match_first;
      }
      reg_idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    reg_idx = 0;
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (! (reg_idx < extra_nmatch)) {
        goto while_break___6;
      }
      (pmatch + (nmatch + (size_t )reg_idx))->rm_so = -1;
      (pmatch + (nmatch + (size_t )reg_idx))->rm_eo = -1;
      reg_idx ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    if (dfa->subexp_map) {
      reg_idx = 0;
      {
      while (1) {
        while_continue___7: /* CIL Label */ ;
        if (! ((size_t )(reg_idx + 1) < nmatch)) {
          goto while_break___7;
        }
        if (*(dfa->subexp_map + reg_idx) != reg_idx) {
          (pmatch + (reg_idx + 1))->rm_so = (pmatch + (*(dfa->subexp_map + reg_idx) + 1))->rm_so;
          (pmatch + (reg_idx + 1))->rm_eo = (pmatch + (*(dfa->subexp_map + reg_idx) + 1))->rm_eo;
        }
        reg_idx ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  free_return: 
  {
  free((void *)mctx.state_log);
  }
  if (dfa->nbackref) {
    {
    match_ctx_free(& mctx);
    }
  }
  {
  re_string_destruct(& mctx.input);
  }
  return (err);
}
}
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) 
{ 
  re_dfa_t const   *dfa ;
  int halt_node ;
  int match_last ;
  reg_errcode_t ret ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
  dfa = mctx->dfa;
  lim_states = (re_dfastate_t **)((void *)0);
  match_last = mctx->match_last;
  halt_node = mctx->last_node;
  tmp = malloc((unsigned long )(match_last + 1) * sizeof(re_dfastate_t *));
  sifted_states = (re_dfastate_t **)tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )sifted_states == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    ret = (reg_errcode_t )12;
    goto free_return;
  }
  if (dfa->nbackref) {
    {
    tmp___1 = malloc((unsigned long )(match_last + 1) * sizeof(re_dfastate_t *));
    lim_states = (re_dfastate_t **)tmp___1;
    tmp___2 = __builtin_expect((long )((unsigned long )lim_states == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___2) {
      ret = (reg_errcode_t )12;
      goto free_return;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      memset((void *)lim_states, '\000', sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1));
      sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
      ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
      free((void *)sctx.limits.elems);
      tmp___3 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
      }
      if (tmp___3) {
        goto free_return;
      }
      if ((unsigned long )*(sifted_states + 0) != (unsigned long )((void *)0)) {
        goto while_break;
      } else { //Added block
      if ((unsigned long )*(lim_states + 0) != (unsigned long )((void *)0)) {
        goto while_break;
      }
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        match_last --;
        if (match_last < 0) {
          ret = (reg_errcode_t )1;
          goto free_return;
        }
        if (! ((unsigned long )*(mctx->state_log + match_last) == (unsigned long )((void *)0))) {
          if (! (! (*(mctx->state_log + match_last))->halt)) {
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      halt_node = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                           match_last);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    ret = merge_state_array(dfa, sifted_states, lim_states, match_last + 1);
    free((void *)lim_states);
    lim_states = (re_dfastate_t **)((void *)0);
    tmp___4 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    if (tmp___4) {
      goto free_return;
    }
  } else {
    {
    sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
    ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
    free((void *)sctx.limits.elems);
    tmp___5 = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
    }
    if (tmp___5) {
      goto free_return;
    }
  }
  {
  free((void *)mctx->state_log);
  mctx->state_log = sifted_states;
  sifted_states = (re_dfastate_t **)((void *)0);
  mctx->last_node = halt_node;
  mctx->match_last = match_last;
  ret = (reg_errcode_t )0;
  }
  free_return: 
  {
  free((void *)sifted_states);
  free((void *)lim_states);
  }
  return (ret);
}
}
__inline static re_dfastate_t *( __attribute__((__always_inline__)) acquire_init_state_context)(reg_errcode_t *err ,
                                                                                                re_match_context_t const   *mctx ,
                                                                                                int idx ) 
{ 
  re_dfa_t const   *dfa ;
  unsigned int context ;
  re_dfastate_t *tmp ;

  {
  dfa = (re_dfa_t const   *)mctx->dfa;
  if ((dfa->init_state)->has_constraint) {
    {
    context = re_string_context_at(& mctx->input, idx - 1, (int )mctx->eflags);
    }
    if (context & 1U) {
      return ((re_dfastate_t *)dfa->init_state_word);
    } else { //Added block
    if (context == 0U) {
      return ((re_dfastate_t *)dfa->init_state);
    } else { //Added block
    if (context & (unsigned int )((1 << 1) << 1)) {
      if (context & (unsigned int )(1 << 1)) {
        return ((re_dfastate_t *)dfa->init_state_begbuf);
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (context & (unsigned int )(1 << 1)) {
      return ((re_dfastate_t *)dfa->init_state_nl);
    } else { //Added block
    if (context & (unsigned int )((1 << 1) << 1)) {
      {
      tmp = re_acquire_state_context(err, dfa, (re_node_set const   *)(dfa->init_state)->entrance_nodes,
                                     context);
      }
      return (tmp);
    } else {
      return ((re_dfastate_t *)dfa->init_state);
    }
    }
    }
    }
    }
  } else {
    return ((re_dfastate_t *)dfa->init_state);
  }
}
}
static int check_matching(re_match_context_t *mctx , int fl_longest_match , int *p_match_first ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  int match ;
  int match_last ;
  int cur_str_idx ;
  re_dfastate_t *cur_state ;
  int at_init_state ;
  int next_start_idx ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  re_dfastate_t *old_state ;
  int next_char_idx ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;

  {
  {
  dfa = mctx->dfa;
  match = 0;
  match_last = -1;
  cur_str_idx = mctx->input.cur_idx;
  at_init_state = (unsigned long )p_match_first != (unsigned long )((void *)0);
  next_start_idx = cur_str_idx;
  err = (reg_errcode_t )0;
  cur_state = acquire_init_state_context(& err, (re_match_context_t const   *)mctx,
                                         cur_str_idx);
  tmp___0 = __builtin_expect((long )((unsigned long )cur_state == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___0) {
    if (! ((unsigned int )err == 12U)) {
      {
      __assert_fail("err == REG_ESPACE", "regexec.c", 1085U, "check_matching");
      }
    }
    return (-2);
  }
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
    *(mctx->state_log + cur_str_idx) = cur_state;
    tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
    }
    if (tmp___3) {
      {
      at_init_state = 0;
      err = check_subexp_matching_top(mctx, & cur_state->nodes, 0);
      tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___1) {
        return ((int )err);
      }
      if (cur_state->has_backref) {
        {
        err = transit_state_bkref(mctx, (re_node_set const   *)(& cur_state->nodes));
        tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___2) {
          return ((int )err);
        }
      }
    }
  }
  {
  tmp___5 = __builtin_expect((long )cur_state->halt, 0L);
  }
  if (tmp___5) {
    if (! cur_state->has_constraint) {
      goto _L;
    } else {
      {
      tmp___4 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                         cur_str_idx);
      }
      if (tmp___4) {
        _L: 
        if (! fl_longest_match) {
          return (cur_str_idx);
        } else {
          match_last = cur_str_idx;
          match = 1;
        }
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! (mctx->input.stop <= mctx->input.cur_idx))) {
      goto while_break;
    }
    {
    old_state = cur_state;
    next_char_idx = mctx->input.cur_idx + 1;
    tmp___8 = __builtin_expect((long )(next_char_idx >= mctx->input.bufs_len), 0L);
    }
    if (tmp___8) {
      goto _L___0;
    } else {
      {
      tmp___9 = __builtin_expect((long )(next_char_idx >= mctx->input.valid_len),
                                 0L);
      }
      if (tmp___9) {
        if (mctx->input.valid_len < mctx->input.len) {
          _L___0: 
          {
          err = extend_buffers(mctx);
          tmp___7 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          if (tmp___7) {
            if (! ((unsigned int )err == 12U)) {
              {
              __assert_fail("err == REG_ESPACE", "regexec.c", 1139U, "check_matching");
              }
            }
            return (-2);
          }
        }
      }
    }
    {
    cur_state = transit_state(& err, mctx, cur_state);
    }
    if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
      {
      cur_state = merge_state_with_log(& err, mctx, cur_state);
      }
    }
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      {
      tmp___10 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___10) {
        return (-2);
      }
      if ((unsigned long )mctx->state_log == (unsigned long )((void *)0)) {
        goto while_break;
      } else { //Added block
      if (match) {
        if (! fl_longest_match) {
          goto while_break;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        {
        cur_state = find_recover_state(& err, mctx);
        }
        if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
          goto while_break;
        }
      }
      }
    }
    {
    tmp___11 = __builtin_expect((long )at_init_state, 0L);
    }
    if (tmp___11) {
      if ((unsigned long )old_state == (unsigned long )cur_state) {
        next_start_idx = next_char_idx;
      } else {
        at_init_state = 0;
      }
    }
    if (cur_state->halt) {
      if (! cur_state->has_constraint) {
        goto _L___2;
      } else {
        {
        tmp___12 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                            mctx->input.cur_idx);
        }
        if (tmp___12) {
          _L___2: 
          match_last = mctx->input.cur_idx;
          match = 1;
          p_match_first = (int *)((void *)0);
          if (! fl_longest_match) {
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (p_match_first) {
    *p_match_first += next_start_idx;
  }
  return (match_last);
}
}
static int check_halt_node_context(re_dfa_t const   *dfa , int node , unsigned int context ) 
{ 
  re_token_type_t type ;
  unsigned int constraint ;

  {
  type = (dfa->nodes + node)->type;
  constraint = (dfa->nodes + node)->constraint;
  if ((unsigned int )type != 2U) {
    return (0);
  }
  if (! constraint) {
    return (1);
  }
  if (constraint & 4U) {
    if (! (context & 1U)) {
      return (0);
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (constraint & 8U) {
    if (context & 1U) {
      return (0);
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (constraint & 32U) {
    if (! (context & (unsigned int )(1 << 1))) {
      return (0);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (constraint & 128U) {
    if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
      return (0);
    }
  }
  }
  }
  }
  return (1);
}
}
static int check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    int idx ) 
{ 
  int i ;
  unsigned int context ;
  int tmp ;

  {
  {
  context = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < (int )state->nodes.nelem)) {
      goto while_break;
    }
    {
    tmp = check_halt_node_context((re_dfa_t const   *)mctx->dfa, *(state->nodes.elems + i),
                                  context);
    }
    if (tmp) {
      return (*(state->nodes.elems + i));
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int proceed_next_node(re_match_context_t const   *mctx , int nregs , regmatch_t *regs___0 ,
                             int *pidx , int node , re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) 
{ 
  re_dfa_t const   *dfa ;
  int i ;
  int err ;
  re_node_set *cur_nodes ;
  re_node_set *edests ;
  int dest_node ;
  long tmp ;
  int candidate ;
  int __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int naccepted ;
  re_token_type_t type ;
  int subexp_idx ;
  char *buf ;
  int tmp___3 ;
  int dest_node___0 ;
  long tmp___4 ;
  int __attribute__((__pure__))  tmp___5 ;
  int dest_node___1 ;
  int __attribute__((__pure__))  tmp___6 ;
  int tmp___7 ;

  {
  dfa = (re_dfa_t const   *)mctx->dfa;
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
    {
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
    edests = (re_node_set *)(dfa->edests + node);
    err = re_node_set_insert(eps_via_nodes, node);
    tmp = __builtin_expect((long )(err < 0), 0L);
    }
    if (tmp) {
      return (-2);
    }
    dest_node = -1;
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < edests->nelem)) {
        goto while_break;
      }
      {
      candidate = *(edests->elems + i);
      tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, candidate);
      }
      if (! tmp___0) {
        goto __Cont;
      }
      if (dest_node == -1) {
        dest_node = candidate;
      } else {
        {
        tmp___2 = re_node_set_contains((re_node_set const   *)eps_via_nodes, dest_node);
        }
        if (tmp___2) {
          return (candidate);
        } else { //Added block
        if ((unsigned long )fs != (unsigned long )((void *)0)) {
          {
          tmp___1 = push_fail_stack(fs, *pidx, candidate, nregs, regs___0, eps_via_nodes);
          }
          if (tmp___1) {
            return (-2);
          }
        }
        }
        goto while_break;
      }
      __Cont: 
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    return (dest_node);
  } else {
    naccepted = 0;
    type = (dfa->nodes + node)->type;
    if ((unsigned int )type == 4U) {
      subexp_idx = (dfa->nodes + node)->opr.idx + 1;
      naccepted = (regs___0 + subexp_idx)->rm_eo - (regs___0 + subexp_idx)->rm_so;
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
        if ((regs___0 + subexp_idx)->rm_so == -1) {
          return (-1);
        } else { //Added block
        if ((regs___0 + subexp_idx)->rm_eo == -1) {
          return (-1);
        } else { //Added block
        if (naccepted) {
          {
          buf = (char *)mctx->input.mbs;
          tmp___3 = memcmp((void const   *)(buf + (regs___0 + subexp_idx)->rm_so),
                           (void const   *)(buf + *pidx), (size_t )naccepted);
          }
          if (tmp___3 != 0) {
            return (-1);
          }
        }
        }
        }
      }
      if (naccepted == 0) {
        {
        err = re_node_set_insert(eps_via_nodes, node);
        tmp___4 = __builtin_expect((long )(err < 0), 0L);
        }
        if (tmp___4) {
          return (-2);
        }
        {
        dest_node___0 = *((dfa->edests + node)->elems + 0);
        tmp___5 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                       dest_node___0);
        }
        if (tmp___5) {
          return (dest_node___0);
        }
      }
    }
    if (naccepted != 0) {
      goto _L;
    } else {
      {
      tmp___7 = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + node),
                                  *pidx);
      }
      if (tmp___7) {
        _L: 
        dest_node___1 = *(dfa->nexts + node);
        if (naccepted == 0) {
          (*pidx) ++;
        } else {
          *pidx += naccepted;
        }
        if (fs) {
          if (*pidx > (int )mctx->match_last) {
            return (-1);
          } else { //Added block
          if ((unsigned long )*(mctx->state_log + *pidx) == (unsigned long )((void *)0)) {
            return (-1);
          } else {
            {
            tmp___6 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                           dest_node___1);
            }
            if (! tmp___6) {
              return (-1);
            }
          }
          }
        }
        eps_via_nodes->nelem = 0;
        return (dest_node___1);
      }
    }
  }
  return (-1);
}
}
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , int str_idx , int dest_node ,
                                     int nregs , regmatch_t *regs___0 , re_node_set *eps_via_nodes ) 
{ 
  reg_errcode_t err ;
  int num ;
  int tmp ;
  struct re_fail_stack_ent_t *new_array ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = fs->num;
  (fs->num) ++;
  num = tmp;
  if (fs->num == fs->alloc) {
    {
    tmp___0 = realloc((void *)fs->stack, (sizeof(struct re_fail_stack_ent_t ) * (unsigned long )fs->alloc) * 2UL);
    new_array = (struct re_fail_stack_ent_t *)tmp___0;
    }
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
      return ((reg_errcode_t )12);
    }
    fs->alloc *= 2;
    fs->stack = new_array;
  }
  {
  (fs->stack + num)->idx = str_idx;
  (fs->stack + num)->node = dest_node;
  tmp___1 = malloc((unsigned long )nregs * sizeof(regmatch_t ));
  (fs->stack + num)->regs = (regmatch_t *)tmp___1;
  }
  if ((unsigned long )(fs->stack + num)->regs == (unsigned long )((void *)0)) {
    return ((reg_errcode_t )12);
  }
  {
  memmove((void * __restrict  )(fs->stack + num)->regs, (void const   * __restrict  )regs___0,
          sizeof(regmatch_t ) * (unsigned long )nregs);
  err = re_node_set_init_copy(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
  }
  return (err);
}
}
static int pop_fail_stack(struct re_fail_stack_t *fs , int *pidx , int nregs , regmatch_t *regs___0 ,
                          re_node_set *eps_via_nodes ) 
{ 
  int num ;

  {
  (fs->num) --;
  num = fs->num;
  if (! (num >= 0)) {
    {
    __assert_fail("num >= 0", "regexec.c", 1372U, "pop_fail_stack");
    }
  }
  {
  *pidx = (fs->stack + num)->idx;
  memmove((void * __restrict  )regs___0, (void const   * __restrict  )(fs->stack + num)->regs,
          sizeof(regmatch_t ) * (unsigned long )nregs);
  free((void *)eps_via_nodes->elems);
  free((void *)(fs->stack + num)->regs);
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
  }
  return ((fs->stack + num)->node);
}
}
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , int fl_backtrack ) 
{ 
  re_dfa_t const   *dfa ;
  int idx ;
  int cur_node ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  regmatch_t *prev_idx_match ;
  int prev_idx_match_malloced ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int reg_idx ;
  reg_errcode_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  reg_errcode_t tmp___5 ;

  {
  dfa = (re_dfa_t const   *)preg->buffer;
  fs_body.num = 0;
  fs_body.alloc = 2;
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
  prev_idx_match_malloced = 0;
  if (fl_backtrack) {
    {
    fs = & fs_body;
    tmp = malloc((unsigned long )fs->alloc * sizeof(struct re_fail_stack_ent_t ));
    fs->stack = (struct re_fail_stack_ent_t *)tmp;
    }
    if ((unsigned long )fs->stack == (unsigned long )((void *)0)) {
      return ((reg_errcode_t )12);
    }
  } else {
    fs = (struct re_fail_stack_t *)((void *)0);
  }
  {
  cur_node = (int )dfa->init_node;
  memset((void *)(& eps_via_nodes), '\000', sizeof(re_node_set ));
  }
  if (nmatch * sizeof(regmatch_t ) < 4032UL) {
    {
    tmp___0 = __builtin_alloca(nmatch * sizeof(regmatch_t ));
    prev_idx_match = (regmatch_t *)tmp___0;
    }
  } else {
    {
    tmp___1 = malloc(nmatch * sizeof(regmatch_t ));
    prev_idx_match = (regmatch_t *)tmp___1;
    }
    if ((unsigned long )prev_idx_match == (unsigned long )((void *)0)) {
      {
      free_fail_stack_return(fs);
      }
      return ((reg_errcode_t )12);
    }
    prev_idx_match_malloced = 1;
  }
  {
  memmove((void * __restrict  )prev_idx_match, (void const   * __restrict  )pmatch,
          sizeof(regmatch_t ) * nmatch);
  idx = (pmatch + 0)->rm_so;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (idx <= (pmatch + 0)->rm_eo)) {
      goto while_break;
    }
    {
    update_regs(dfa, pmatch, prev_idx_match, cur_node, idx, (int )nmatch);
    }
    if (idx == (pmatch + 0)->rm_eo) {
      if (cur_node == (int )mctx->last_node) {
        if (fs) {
          reg_idx = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! ((size_t )reg_idx < nmatch)) {
              goto while_break___0;
            }
            if ((pmatch + reg_idx)->rm_so > -1) {
              if ((pmatch + reg_idx)->rm_eo == -1) {
                goto while_break___0;
              }
            }
            reg_idx ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          if ((size_t )reg_idx == nmatch) {
            {
            free((void *)eps_via_nodes.elems);
            }
            if (prev_idx_match_malloced) {
              {
              free((void *)prev_idx_match);
              }
            }
            {
            tmp___2 = free_fail_stack_return(fs);
            }
            return (tmp___2);
          }
          {
          cur_node = pop_fail_stack(fs, & idx, (int )nmatch, pmatch, & eps_via_nodes);
          }
        } else {
          {
          free((void *)eps_via_nodes.elems);
          }
          if (prev_idx_match_malloced) {
            {
            free((void *)prev_idx_match);
            }
          }
          return ((reg_errcode_t )0);
        }
      }
    }
    {
    cur_node = proceed_next_node(mctx, (int )nmatch, pmatch, & idx, cur_node, & eps_via_nodes,
                                 fs);
    tmp___4 = __builtin_expect((long )(cur_node < 0), 0L);
    }
    if (tmp___4) {
      {
      tmp___3 = __builtin_expect((long )(cur_node == -2), 0L);
      }
      if (tmp___3) {
        {
        free((void *)eps_via_nodes.elems);
        }
        if (prev_idx_match_malloced) {
          {
          free((void *)prev_idx_match);
          }
        }
        {
        free_fail_stack_return(fs);
        }
        return ((reg_errcode_t )12);
      }
      if (fs) {
        {
        cur_node = pop_fail_stack(fs, & idx, (int )nmatch, pmatch, & eps_via_nodes);
        }
      } else {
        {
        free((void *)eps_via_nodes.elems);
        }
        if (prev_idx_match_malloced) {
          {
          free((void *)prev_idx_match);
          }
        }
        return ((reg_errcode_t )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)eps_via_nodes.elems);
  }
  if (prev_idx_match_malloced) {
    {
    free((void *)prev_idx_match);
    }
  }
  {
  tmp___5 = free_fail_stack_return(fs);
  }
  return (tmp___5);
}
}
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) 
{ 
  int fs_idx ;

  {
  if (fs) {
    fs_idx = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (fs_idx < fs->num)) {
        goto while_break;
      }
      {
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
      free((void *)(fs->stack + fs_idx)->regs);
      fs_idx ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    free((void *)fs->stack);
    }
  }
  return ((reg_errcode_t )0);
}
}
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        int cur_node , int cur_idx , int nmatch ) 
{ 
  int type ;
  int reg_num ;
  int reg_num___0 ;

  {
  type = (int )(dfa->nodes + cur_node)->type;
  if (type == 8) {
    reg_num = (dfa->nodes + cur_node)->opr.idx + 1;
    if (reg_num < nmatch) {
      (pmatch + reg_num)->rm_so = cur_idx;
      (pmatch + reg_num)->rm_eo = -1;
    }
  } else { //Added block
  if (type == 9) {
    reg_num___0 = (dfa->nodes + cur_node)->opr.idx + 1;
    if (reg_num___0 < nmatch) {
      if ((pmatch + reg_num___0)->rm_so < cur_idx) {
        {
        (pmatch + reg_num___0)->rm_eo = cur_idx;
        memmove((void * __restrict  )prev_idx_match, (void const   * __restrict  )pmatch,
                sizeof(regmatch_t ) * (unsigned long )nmatch);
        }
      } else { //Added block
      if ((dfa->nodes + cur_node)->opt_subexp) {
        if ((prev_idx_match + reg_num___0)->rm_so != -1) {
          {
          memmove((void * __restrict  )pmatch, (void const   * __restrict  )prev_idx_match,
                  sizeof(regmatch_t ) * (unsigned long )nmatch);
          }
        } else {
          (pmatch + reg_num___0)->rm_eo = cur_idx;
        }
      } else {
        (pmatch + reg_num___0)->rm_eo = cur_idx;
      }
      }
    }
  }
  }
  return;
}
}
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) 
{ 
  reg_errcode_t err ;
  int null_cnt ;
  int str_idx ;
  re_node_set cur_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
  null_cnt = 0;
  str_idx = sctx->last_str_idx;
  err = re_node_set_init_1(& cur_dest, sctx->last_node);
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp) {
    return (err);
  }
  {
  err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
  tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___0) {
    goto free_return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (str_idx > 0)) {
      goto while_break;
    }
    if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
      null_cnt ++;
    } else {
      null_cnt = 0;
    }
    if (null_cnt > (int )mctx->max_mb_elem_len) {
      {
      memset((void *)sctx->sifted_states, '\000', sizeof(re_dfastate_t *) * (unsigned long )str_idx);
      free((void *)cur_dest.elems);
      }
      return ((reg_errcode_t )0);
    }
    cur_dest.nelem = 0;
    str_idx --;
    if (*(mctx->state_log + str_idx)) {
      {
      err = build_sifted_states(mctx, sctx, str_idx, & cur_dest);
      tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___1) {
        goto free_return;
      }
    }
    {
    err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
    tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp___2) {
      goto free_return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  err = (reg_errcode_t )0;
  free_return: 
  {
  free((void *)cur_dest.elems);
  }
  return (err);
}
}
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         int str_idx , re_node_set *cur_dest ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *cur_src ;
  int i ;
  int prev_node ;
  int naccepted ;
  int ret ;
  int tmp ;
  int __attribute__((__pure__))  tmp___0 ;
  int to_idx ;
  int tmp___1 ;
  long tmp___2 ;

  {
  dfa = (re_dfa_t const   *)mctx->dfa;
  cur_src = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->non_eps_nodes);
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < (int )cur_src->nelem)) {
      goto while_break;
    }
    prev_node = *(cur_src->elems + i);
    naccepted = 0;
    if (! naccepted) {
      {
      tmp = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + prev_node),
                              str_idx);
      }
      if (tmp) {
        if ((unsigned long )*(sctx->sifted_states + (str_idx + 1)) != (unsigned long )((void *)0)) {
          {
          tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1)))->nodes),
                                         *(dfa->nexts + prev_node));
          }
          if (tmp___0) {
            naccepted = 1;
          }
        }
      }
    }
    if (naccepted == 0) {
      goto __Cont;
    }
    if (sctx->limits.nelem) {
      {
      to_idx = str_idx + naccepted;
      tmp___1 = check_dst_limits(mctx, & sctx->limits, *(dfa->nexts + prev_node),
                                 to_idx, prev_node, str_idx);
      }
      if (tmp___1) {
        goto __Cont;
      }
    }
    {
    ret = re_node_set_insert(cur_dest, prev_node);
    tmp___2 = __builtin_expect((long )(ret == -1), 0L);
    }
    if (tmp___2) {
      return ((reg_errcode_t )12);
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t clean_state_log_if_needed(re_match_context_t *mctx , int next_state_log_idx ) 
{ 
  int top ;
  reg_errcode_t err ;
  long tmp ;

  {
  top = mctx->state_log_top;
  if (next_state_log_idx >= mctx->input.bufs_len) {
    goto _L;
  } else { //Added block
  if (next_state_log_idx >= mctx->input.valid_len) {
    if (mctx->input.valid_len < mctx->input.len) {
      _L: 
      {
      err = extend_buffers(mctx);
      tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp) {
        return (err);
      }
    }
  }
  }
  if (top < next_state_log_idx) {
    {
    memset((void *)((mctx->state_log + top) + 1), '\000', sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top));
    mctx->state_log_top = next_state_log_idx;
    }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , int num ) 
{ 
  int st_idx ;
  reg_errcode_t err ;
  re_node_set merged_set ;
  long tmp ;
  long tmp___0 ;

  {
  st_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (st_idx < num)) {
      goto while_break;
    }
    if ((unsigned long )*(dst + st_idx) == (unsigned long )((void *)0)) {
      *(dst + st_idx) = *(src + st_idx);
    } else { //Added block
    if ((unsigned long )*(src + st_idx) != (unsigned long )((void *)0)) {
      {
      err = re_node_set_init_union(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                   (re_node_set const   *)(& (*(src + st_idx))->nodes));
      tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp) {
        return (err);
      }
      {
      *(dst + st_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& merged_set));
      free((void *)merged_set.elems);
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___0) {
        return (err);
      }
    }
    }
    st_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             int str_idx , re_node_set *dest_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  re_node_set const   *candidates ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  dfa = (re_dfa_t const   *)mctx->dfa;
  err = (reg_errcode_t )0;
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
    candidates = (re_node_set const   *)((void *)0);
  } else {
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
  if (dest_nodes->nelem == 0) {
    *(sctx->sifted_states + str_idx) = (re_dfastate_t *)((void *)0);
  } else {
    if (candidates) {
      {
      err = add_epsilon_src_nodes(dfa, dest_nodes, candidates);
      tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp) {
        return (err);
      }
      if (sctx->limits.nelem) {
        {
        err = check_subexp_limits(dfa, dest_nodes, candidates, & sctx->limits, (struct re_backref_cache_entry *)mctx->bkref_ents,
                                  str_idx);
        tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___0) {
          return (err);
        }
      }
    }
    {
    *(sctx->sifted_states + str_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
    tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp___1) {
      return (err);
    }
  }
  if (candidates) {
    if ((*(mctx->state_log + str_idx))->has_backref) {
      {
      err = sift_states_bkref(mctx, sctx, str_idx, candidates);
      tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___2) {
        return (err);
      }
    }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  reg_errcode_t err ;
  int i ;
  re_dfastate_t *state ;
  re_dfastate_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  reg_errcode_t tmp___2 ;

  {
  {
  err = (reg_errcode_t )0;
  tmp = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
  state = tmp;
  tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___0) {
    return (err);
  }
  if (! state->inveclosure.alloc) {
    {
    err = re_node_set_alloc(& state->inveclosure, dest_nodes->nelem);
    tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp___1) {
      return ((reg_errcode_t )12);
    }
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < dest_nodes->nelem)) {
        goto while_break;
      }
      {
      re_node_set_merge(& state->inveclosure, (re_node_set const   *)(dfa->inveclosures + *(dest_nodes->elems + i)));
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  tmp___2 = re_node_set_add_intersect(dest_nodes, candidates, (re_node_set const   *)(& state->inveclosure));
  }
  return (tmp___2);
}
}
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t const   *dfa , int node , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  int ecl_idx ;
  reg_errcode_t err ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  int cur_node ;
  int edst1 ;
  int edst2 ;
  int tmp ;
  long tmp___0 ;
  int __attribute__((__pure__))  tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  int __attribute__((__pure__))  tmp___4 ;
  int cur_node___0 ;
  int idx ;
  int __attribute__((__pure__))  tmp___5 ;
  int __attribute__((__pure__))  tmp___6 ;

  {
  {
  inv_eclosure = (re_node_set *)(dfa->inveclosures + node);
  memset((void *)(& except_nodes), '\000', sizeof(re_node_set ));
  ecl_idx = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (ecl_idx < inv_eclosure->nelem)) {
      goto while_break;
    }
    cur_node = *(inv_eclosure->elems + ecl_idx);
    if (cur_node == node) {
      goto __Cont;
    }
    if ((unsigned int )(dfa->nodes + cur_node)->type & 8U) {
      edst1 = *((dfa->edests + cur_node)->elems + 0);
      if ((dfa->edests + cur_node)->nelem > 1) {
        tmp = *((dfa->edests + cur_node)->elems + 1);
      } else {
        tmp = -1;
      }
      {
      edst2 = tmp;
      tmp___1 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst1);
      }
      if (tmp___1) {
        _L___0: 
        if (edst2 > 0) {
          {
          tmp___3 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst2);
          }
          if (! tmp___3) {
            {
            tmp___4 = re_node_set_contains((re_node_set const   *)dest_nodes, edst2);
            }
            if (tmp___4) {
              _L: 
              {
              err = re_node_set_add_intersect(& except_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + cur_node));
              tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
              }
              if (tmp___0) {
                {
                free((void *)except_nodes.elems);
                }
                return (err);
              }
            }
          }
        }
      } else {
        {
        tmp___2 = re_node_set_contains((re_node_set const   *)dest_nodes, edst1);
        }
        if (tmp___2) {
          goto _L;
        } else {
          goto _L___0;
        }
      }
    }
    __Cont: 
    ecl_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  ecl_idx = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (ecl_idx < inv_eclosure->nelem)) {
      goto while_break___0;
    }
    {
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
    tmp___6 = re_node_set_contains((re_node_set const   *)(& except_nodes), cur_node___0);
    }
    if (! tmp___6) {
      {
      tmp___5 = re_node_set_contains((re_node_set const   *)dest_nodes, cur_node___0);
      idx = (int )(tmp___5 - (int __attribute__((__pure__))  )1);
      re_node_set_remove_at(dest_nodes, idx);
      }
    }
    ecl_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  free((void *)except_nodes.elems);
  }
  return ((reg_errcode_t )0);
}
}
static int check_dst_limits(re_match_context_t const   *mctx , re_node_set *limits ,
                            int dst_node , int dst_idx , int src_node , int src_idx ) 
{ 
  re_dfa_t const   *dfa ;
  int lim_idx ;
  int src_pos ;
  int dst_pos ;
  int dst_bkref_idx ;
  int tmp ;
  int src_bkref_idx ;
  int tmp___0 ;
  int subexp_idx ;
  struct re_backref_cache_entry *ent ;

  {
  {
  dfa = (re_dfa_t const   *)mctx->dfa;
  tmp = search_cur_bkref_entry(mctx, dst_idx);
  dst_bkref_idx = tmp;
  tmp___0 = search_cur_bkref_entry(mctx, src_idx);
  src_bkref_idx = tmp___0;
  lim_idx = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lim_idx < limits->nelem)) {
      goto while_break;
    }
    {
    ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + *(limits->elems + lim_idx));
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
    dst_pos = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        dst_node, dst_idx, dst_bkref_idx);
    src_pos = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        src_node, src_idx, src_bkref_idx);
    }
    if (! (src_pos == dst_pos)) {
      return (1);
    }
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       int subexp_idx , int from_node , int bkref_idx ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *eclosures ;
  int node_idx ;
  int node ;
  struct re_backref_cache_entry *ent ;
  int dst ;
  int cpos ;
  struct re_backref_cache_entry *tmp ;
  int tmp___0 ;

  {
  dfa = (re_dfa_t const   *)mctx->dfa;
  eclosures = (re_node_set const   *)(dfa->eclosures + from_node);
  node_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (node_idx < (int )eclosures->nelem)) {
      goto while_break;
    }
    node = *(eclosures->elems + node_idx);
    {
    if ((unsigned int )(dfa->nodes + node)->type == 4U) {
      goto case_4;
    }
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
      goto case_8;
    }
    if ((unsigned int )(dfa->nodes + node)->type == 9U) {
      goto case_9;
    }
    goto switch_default;
    case_4: /* CIL Label */ 
    if (bkref_idx != -1) {
      ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + bkref_idx);
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (ent->node != node) {
          goto __Cont;
        }
        if ((unsigned long )subexp_idx < sizeof(bitset_word_t ) * 8UL) {
          if (! ((unsigned long )ent->eps_reachable_subexps_map & (1UL << subexp_idx))) {
            goto __Cont;
          }
        }
        dst = *((dfa->edests + node)->elems + 0);
        if (dst == from_node) {
          if (boundaries & 1) {
            return (-1);
          } else {
            return (0);
          }
        }
        {
        cpos = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, dst, bkref_idx);
        }
        if (cpos == -1) {
          return (-1);
        }
        if (cpos == 0) {
          if (boundaries & 2) {
            return (0);
          }
        }
        if ((unsigned long )subexp_idx < sizeof(bitset_word_t ) * 8UL) {
          ent->eps_reachable_subexps_map = (unsigned short )((unsigned long )ent->eps_reachable_subexps_map & ~ (1UL << subexp_idx));
        }
        __Cont: 
        tmp = ent;
        ent ++;
        if (! tmp->more) {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    goto switch_break;
    case_8: /* CIL Label */ 
    if (boundaries & 1) {
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
        return (-1);
      }
    }
    goto switch_break;
    case_9: /* CIL Label */ 
    if (boundaries & 2) {
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
        return (0);
      }
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (boundaries & 2) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , int limit ,
                                     int subexp_idx , int from_node , int str_idx ,
                                     int bkref_idx ) 
{ 
  struct re_backref_cache_entry *lim ;
  int boundaries ;
  int tmp ;

  {
  lim = (struct re_backref_cache_entry *)(mctx->bkref_ents + limit);
  if (str_idx < lim->subexp_from) {
    return (-1);
  }
  if (lim->subexp_to < str_idx) {
    return (1);
  }
  boundaries = str_idx == lim->subexp_from;
  boundaries |= (str_idx == lim->subexp_to) << 1;
  if (boundaries == 0) {
    return (0);
  }
  {
  tmp = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, from_node, bkref_idx);
  }
  return (tmp);
}
}
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         int str_idx ) 
{ 
  reg_errcode_t err ;
  int node_idx ;
  int lim_idx ;
  int subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int ops_node ;
  int cls_node ;
  int node ;
  re_token_type_t type ;
  long tmp ;
  int node___0 ;
  long tmp___0 ;
  int __attribute__((__pure__))  tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int node___1 ;
  re_token_type_t type___0 ;
  long tmp___3 ;

  {
  lim_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lim_idx < limits->nelem)) {
      goto while_break;
    }
    ent = bkref_ents + *(limits->elems + lim_idx);
    if (str_idx <= ent->subexp_from) {
      goto __Cont;
    } else { //Added block
    if (ent->str_idx < str_idx) {
      goto __Cont;
    }
    }
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
    if (ent->subexp_to == str_idx) {
      ops_node = -1;
      cls_node = -1;
      node_idx = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (node_idx < dest_nodes->nelem)) {
          goto while_break___0;
        }
        node = *(dest_nodes->elems + node_idx);
        type = (dfa->nodes + node)->type;
        if ((unsigned int )type == 8U) {
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
            ops_node = node;
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if ((unsigned int )type == 9U) {
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
            cls_node = node;
          }
        }
        }
        node_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (ops_node >= 0) {
        {
        err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes, candidates);
        tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp) {
          return (err);
        }
      }
      if (cls_node >= 0) {
        node_idx = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (node_idx < dest_nodes->nelem)) {
            goto while_break___1;
          }
          {
          node___0 = *(dest_nodes->elems + node_idx);
          tmp___1 = re_node_set_contains((re_node_set const   *)(dfa->inveclosures + node___0),
                                         cls_node);
          }
          if (! tmp___1) {
            {
            tmp___2 = re_node_set_contains((re_node_set const   *)(dfa->eclosures + node___0),
                                           cls_node);
            }
            if (! tmp___2) {
              {
              err = sub_epsilon_src_nodes(dfa, node___0, dest_nodes, candidates);
              tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
              }
              if (tmp___0) {
                return (err);
              }
              node_idx --;
            }
          }
          node_idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
      node_idx = 0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (node_idx < dest_nodes->nelem)) {
          goto while_break___2;
        }
        node___1 = *(dest_nodes->elems + node_idx);
        type___0 = (dfa->nodes + node___1)->type;
        if ((unsigned int )type___0 == 9U) {
          goto _L___0;
        } else { //Added block
        if ((unsigned int )type___0 == 8U) {
          _L___0: 
          if (subexp_idx != (dfa->nodes + node___1)->opr.idx) {
            goto __Cont___0;
          }
          {
          err = sub_epsilon_src_nodes(dfa, node___1, dest_nodes, candidates);
          tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          if (tmp___3) {
            return (err);
          }
        }
        }
        __Cont___0: 
        node_idx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: 
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       int str_idx , re_node_set const   *candidates ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  int node_idx ;
  int node ;
  re_sift_context_t local_sctx ;
  int first_idx ;
  int tmp ;
  int enabled_idx ;
  re_token_type_t type ;
  struct re_backref_cache_entry *entry ;
  int subexp_len ;
  int to_idx ;
  int dst_node ;
  int ret ;
  re_dfastate_t *cur_state ;
  int __attribute__((__pure__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int __attribute__((__pure__))  tmp___6 ;
  struct re_backref_cache_entry *tmp___7 ;

  {
  {
  dfa = (re_dfa_t const   *)mctx->dfa;
  tmp = search_cur_bkref_entry(mctx, str_idx);
  first_idx = tmp;
  }
  if (first_idx == -1) {
    return ((reg_errcode_t )0);
  }
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
  node_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (node_idx < (int )candidates->nelem)) {
      goto while_break;
    }
    node = *(candidates->elems + node_idx);
    type = (dfa->nodes + node)->type;
    if (node == sctx->last_node) {
      if (str_idx == sctx->last_str_idx) {
        goto __Cont;
      }
    }
    if ((unsigned int )type != 4U) {
      goto __Cont;
    }
    entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + first_idx);
    enabled_idx = first_idx;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (entry->node != node) {
        goto __Cont___0;
      }
      subexp_len = entry->subexp_to - entry->subexp_from;
      to_idx = str_idx + subexp_len;
      if (subexp_len) {
        dst_node = *(dfa->nexts + node);
      } else {
        dst_node = *((dfa->edests + node)->elems + 0);
      }
      if (to_idx > sctx->last_str_idx) {
        goto __Cont___0;
      } else { //Added block
      if ((unsigned long )*(sctx->sifted_states + to_idx) == (unsigned long )((void *)0)) {
        goto __Cont___0;
      } else { //Added block
      if ((unsigned long )*(sctx->sifted_states + to_idx) != (unsigned long )((void *)0)) {
        {
        tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                       dst_node);
        }
        if (tmp___0) {
          {
          tmp___1 = check_dst_limits(mctx, & sctx->limits, node, str_idx, dst_node,
                                     to_idx);
          }
          if (tmp___1) {
            goto __Cont___0;
          }
        } else {
          goto __Cont___0;
        }
      } else {
        goto __Cont___0;
      }
      }
      }
      if ((unsigned long )local_sctx.sifted_states == (unsigned long )((void *)0)) {
        {
        local_sctx = *sctx;
        err = re_node_set_init_copy(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
        tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___2) {
          goto free_return;
        }
      }
      {
      local_sctx.last_node = node;
      local_sctx.last_str_idx = str_idx;
      ret = re_node_set_insert(& local_sctx.limits, enabled_idx);
      tmp___3 = __builtin_expect((long )(ret < 0), 0L);
      }
      if (tmp___3) {
        err = (reg_errcode_t )12;
        goto free_return;
      }
      {
      cur_state = *(local_sctx.sifted_states + str_idx);
      err = sift_states_backward(mctx, & local_sctx);
      tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___4) {
        goto free_return;
      }
      if ((unsigned long )sctx->limited_states != (unsigned long )((void *)0)) {
        {
        err = merge_state_array(dfa, sctx->limited_states, local_sctx.sifted_states,
                                str_idx + 1);
        tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___5) {
          goto free_return;
        }
      }
      {
      *(local_sctx.sifted_states + str_idx) = cur_state;
      tmp___6 = re_node_set_contains((re_node_set const   *)(& local_sctx.limits),
                                     enabled_idx);
      re_node_set_remove_at(& local_sctx.limits, (int )(tmp___6 - (int __attribute__((__pure__))  )1));
      entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + enabled_idx);
      }
      __Cont___0: 
      enabled_idx ++;
      tmp___7 = entry;
      entry ++;
      if (! tmp___7->more) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: 
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  err = (reg_errcode_t )0;
  free_return: 
  if ((unsigned long )local_sctx.sifted_states != (unsigned long )((void *)0)) {
    {
    free((void *)local_sctx.limits.elems);
    }
  }
  return (err);
}
}
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state ) 
{ 
  re_dfastate_t **trtable ;
  unsigned char ch ;
  int tmp ;
  long tmp___0 ;
  unsigned int context ;
  long tmp___1 ;
  int tmp___2 ;

  {
  tmp = mctx->input.cur_idx;
  (mctx->input.cur_idx) ++;
  ch = *(mctx->input.mbs + tmp);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    trtable = state->trtable;
    tmp___0 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
    if (tmp___0) {
      return (*(trtable + (int )ch));
    }
    {
    trtable = state->word_trtable;
    tmp___1 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
    if (tmp___1) {
      {
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1,
                                     mctx->eflags);
      }
      if (context & 1U) {
        return (*(trtable + ((int )ch + 256)));
      } else {
        return (*(trtable + (int )ch));
      }
    }
    {
    tmp___2 = build_trtable(mctx->dfa, state);
    }
    if (! tmp___2) {
      *err = (reg_errcode_t )12;
      return ((re_dfastate_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) 
{ 
  re_dfa_t const   *dfa ;
  int cur_idx ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  long tmp ;
  re_dfastate_t *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  dfa = mctx->dfa;
  cur_idx = mctx->input.cur_idx;
  if (cur_idx > mctx->state_log_top) {
    *(mctx->state_log + cur_idx) = next_state;
    mctx->state_log_top = cur_idx;
  } else { //Added block
  if ((unsigned long )*(mctx->state_log + cur_idx) == (unsigned long )((re_dfastate_t *)0)) {
    *(mctx->state_log + cur_idx) = next_state;
  } else {
    table_nodes = (re_node_set *)((void *)0);
    pstate = *(mctx->state_log + cur_idx);
    log_nodes = pstate->entrance_nodes;
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
      table_nodes = next_state->entrance_nodes;
      *err = re_node_set_init_union(& next_nodes, (re_node_set const   *)table_nodes,
                                    (re_node_set const   *)log_nodes);
      tmp = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      if (tmp) {
        return ((re_dfastate_t *)((void *)0));
      }
    } else {
      next_nodes = *log_nodes;
    }
    {
    context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1,
                                   mctx->eflags);
    tmp___0 = re_acquire_state_context(err, dfa, (re_node_set const   *)(& next_nodes),
                                       context);
    *(mctx->state_log + cur_idx) = tmp___0;
    next_state = tmp___0;
    }
    if ((unsigned long )table_nodes != (unsigned long )((void *)0)) {
      {
      free((void *)next_nodes.elems);
      }
    }
  }
  }
  {
  tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
  }
  if (tmp___3) {
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
      *err = check_subexp_matching_top(mctx, & next_state->nodes, cur_idx);
      tmp___1 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
      }
      if (tmp___1) {
        return ((re_dfastate_t *)((void *)0));
      }
      if (next_state->has_backref) {
        {
        *err = transit_state_bkref(mctx, (re_node_set const   *)(& next_state->nodes));
        tmp___2 = __builtin_expect((long )((unsigned int )*err != 0U), 0L);
        }
        if (tmp___2) {
          return ((re_dfastate_t *)((void *)0));
        }
        next_state = *(mctx->state_log + cur_idx);
      }
    }
  }
  return (next_state);
}
}
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) 
{ 
  re_dfastate_t *cur_state ;
  int max ;
  int cur_str_idx ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    max = mctx->state_log_top;
    cur_str_idx = mctx->input.cur_idx;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      cur_str_idx ++;
      if (cur_str_idx > max) {
        return ((re_dfastate_t *)((void *)0));
      }
      (mctx->input.cur_idx) ++;
      if (! ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0))) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    cur_state = merge_state_with_log(err, mctx, (re_dfastate_t *)((void *)0));
    }
    if ((unsigned int )*err == 0U) {
      if (! ((unsigned long )cur_state == (unsigned long )((void *)0))) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (cur_state);
}
}
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               int str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  int node_idx ;
  reg_errcode_t err ;
  int node ;
  long tmp ;

  {
  dfa = mctx->dfa;
  node_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (node_idx < cur_nodes->nelem)) {
      goto while_break;
    }
    node = *(cur_nodes->elems + node_idx);
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
      if ((unsigned long )(dfa->nodes + node)->opr.idx < sizeof(bitset_word_t ) * 8UL) {
        if (dfa->used_bkref_map & (unsigned long const   )(1UL << (dfa->nodes + node)->opr.idx)) {
          {
          err = match_ctx_add_subtop(mctx, node, str_idx);
          tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          if (tmp) {
            return (err);
          }
        }
      }
    }
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  int i ;
  int cur_str_idx ;
  int dest_str_idx ;
  int prev_nelem ;
  int bkc_idx ;
  int node_idx ;
  unsigned int context ;
  re_token_t const   *node ;
  re_node_set *new_dest_nodes ;
  long tmp ;
  int subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  int tmp___0 ;
  long tmp___1 ;
  re_node_set dest_nodes ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  dfa = mctx->dfa;
  cur_str_idx = mctx->input.cur_idx;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < (int )nodes->nelem)) {
      goto while_break;
    }
    node_idx = *(nodes->elems + i);
    node = (re_token_t const   *)(dfa->nodes + node_idx);
    if ((unsigned int const   )node->type != 4U) {
      goto __Cont;
    }
    if (node->constraint) {
      {
      context = re_string_context_at((re_string_t const   *)(& mctx->input), cur_str_idx,
                                     mctx->eflags);
      }
      if (node->constraint & 4U) {
        if (! (context & 1U)) {
          goto __Cont;
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (node->constraint & 8U) {
        if (context & 1U) {
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if (node->constraint & 32U) {
        if (! (context & (unsigned int )(1 << 1))) {
          goto __Cont;
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (node->constraint & 128U) {
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
          goto __Cont;
        }
      }
      }
      }
      }
    }
    {
    bkc_idx = mctx->nbkref_ents;
    err = get_subexp(mctx, node_idx, cur_str_idx);
    tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp) {
      goto free_return;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (bkc_idx < mctx->nbkref_ents)) {
        goto while_break___0;
      }
      bkref_ent = mctx->bkref_ents + bkc_idx;
      if (bkref_ent->node != node_idx) {
        goto __Cont___0;
      } else { //Added block
      if (bkref_ent->str_idx != cur_str_idx) {
        goto __Cont___0;
      }
      }
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
      if (subexp_len == 0) {
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *((dfa->edests + node_idx)->elems + 0));
      } else {
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + node_idx));
      }
      {
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
      context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_str_idx - 1,
                                     mctx->eflags);
      dest_state = *(mctx->state_log + dest_str_idx);
      }
      if ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0)) {
        prev_nelem = 0;
      } else {
        prev_nelem = (*(mctx->state_log + cur_str_idx))->nodes.nelem;
      }
      if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
        {
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)new_dest_nodes,
                                                                     context);
        }
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
          if ((unsigned int )err != 0U) {
            tmp___0 = 1;
          } else {
            tmp___0 = 0;
          }
        } else {
          tmp___0 = 0;
        }
        {
        tmp___1 = __builtin_expect((long )tmp___0, 0L);
        }
        if (tmp___1) {
          goto free_return;
        }
      } else {
        {
        err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                     (re_node_set const   *)new_dest_nodes);
        tmp___2 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___2) {
          {
          free((void *)dest_nodes.elems);
          }
          goto free_return;
        }
        {
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                                     context);
        free((void *)dest_nodes.elems);
        }
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
          if ((unsigned int )err != 0U) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
        {
        tmp___4 = __builtin_expect((long )tmp___3, 0L);
        }
        if (tmp___4) {
          goto free_return;
        }
      }
      if (subexp_len == 0) {
        if ((*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
          {
          err = check_subexp_matching_top(mctx, new_dest_nodes, cur_str_idx);
          tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          if (tmp___5) {
            goto free_return;
          }
          {
          err = transit_state_bkref(mctx, (re_node_set const   *)new_dest_nodes);
          tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          if (tmp___6) {
            goto free_return;
          }
        }
      }
      __Cont___0: 
      bkc_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  err = (reg_errcode_t )0;
  free_return: 
  return (err);
}
}
static reg_errcode_t get_subexp(re_match_context_t *mctx , int bkref_node , int bkref_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  int subexp_num ;
  int sub_top_idx ;
  char const   *buf ;
  int cache_idx ;
  int tmp ;
  struct re_backref_cache_entry  const  *entry ;
  struct re_backref_cache_entry  const  *tmp___0 ;
  reg_errcode_t err ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  int sub_last_idx ;
  int sl_str ;
  int bkref_str_off ;
  int sl_str_diff ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int cls_node ;
  int sl_str_off ;
  re_node_set const   *nodes ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
  dfa = mctx->dfa;
  buf = (char const   *)mctx->input.mbs;
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, bkref_str_idx);
  cache_idx = tmp;
  }
  if (cache_idx != -1) {
    entry = (struct re_backref_cache_entry  const  *)(mctx->bkref_ents + cache_idx);
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (entry->node == (int const   )bkref_node) {
        return ((reg_errcode_t )0);
      }
      tmp___0 = entry;
      entry ++;
      if (! tmp___0->more) {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  subexp_num = (dfa->nodes + bkref_node)->opr.idx;
  sub_top_idx = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (sub_top_idx < mctx->nsub_tops)) {
      goto while_break___0;
    }
    sub_top = *(mctx->sub_tops + sub_top_idx);
    if ((dfa->nodes + sub_top->node)->opr.idx != subexp_num) {
      goto __Cont;
    }
    sl_str = sub_top->str_idx;
    bkref_str_off = bkref_str_idx;
    sub_last_idx = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (sub_last_idx < sub_top->nlasts)) {
        goto while_break___1;
      }
      sub_last = *(sub_top->lasts + sub_last_idx);
      sl_str_diff = sub_last->str_idx - sl_str;
      if (sl_str_diff > 0) {
        {
        tmp___2 = __builtin_expect((long )(bkref_str_off + sl_str_diff > mctx->input.valid_len),
                                   0L);
        }
        if (tmp___2) {
          if (bkref_str_off + sl_str_diff > mctx->input.len) {
            goto while_break___1;
          }
          {
          err = clean_state_log_if_needed(mctx, bkref_str_off + sl_str_diff);
          tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          if (tmp___1) {
            return (err);
          }
          buf = (char const   *)mctx->input.mbs;
        }
        {
        tmp___3 = memcmp((void const   *)(buf + bkref_str_off), (void const   *)(buf + sl_str),
                         (size_t )sl_str_diff);
        }
        if (tmp___3 != 0) {
          goto while_break___1;
        }
      }
      {
      bkref_str_off += sl_str_diff;
      sl_str += sl_str_diff;
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
      buf = (char const   *)mctx->input.mbs;
      }
      if ((unsigned int )err == 1U) {
        goto __Cont___0;
      }
      {
      tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___4) {
        return (err);
      }
      __Cont___0: 
      sub_last_idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (sub_last_idx < sub_top->nlasts) {
      goto __Cont;
    }
    if (sub_last_idx > 0) {
      sl_str ++;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (sl_str <= bkref_str_idx)) {
        goto while_break___2;
      }
      sl_str_off = sl_str - sub_top->str_idx;
      if (sl_str_off > 0) {
        {
        tmp___6 = __builtin_expect((long )(bkref_str_off >= mctx->input.valid_len),
                                   0L);
        }
        if (tmp___6) {
          if (bkref_str_off >= mctx->input.len) {
            goto while_break___2;
          }
          {
          err = extend_buffers(mctx);
          tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
          }
          if (tmp___5) {
            return (err);
          }
          buf = (char const   *)mctx->input.mbs;
        }
        tmp___7 = bkref_str_off;
        bkref_str_off ++;
        if ((int const   )*(buf + tmp___7) != (int const   )*(buf + (sl_str - 1))) {
          goto while_break___2;
        }
      }
      if ((unsigned long )*(mctx->state_log + sl_str) == (unsigned long )((void *)0)) {
        goto __Cont___1;
      }
      {
      nodes = (re_node_set const   *)(& (*(mctx->state_log + sl_str))->nodes);
      cls_node = find_subexp_node(dfa, nodes, subexp_num, 9);
      }
      if (cls_node == -1) {
        goto __Cont___1;
      }
      if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
        {
        tmp___8 = calloc(sizeof(state_array_t ), (size_t )((sl_str - sub_top->str_idx) + 1));
        sub_top->path = (state_array_t *)tmp___8;
        }
        if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
          return ((reg_errcode_t )12);
        }
      }
      {
      err = check_arrival(mctx, sub_top->path, sub_top->node, sub_top->str_idx, cls_node,
                          sl_str, 9);
      }
      if ((unsigned int )err == 1U) {
        goto __Cont___1;
      }
      {
      tmp___9 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___9) {
        return (err);
      }
      {
      sub_last = match_ctx_add_sublast(sub_top, cls_node, sl_str);
      tmp___10 = __builtin_expect((long )((unsigned long )sub_last == (unsigned long )((void *)0)),
                                  0L);
      }
      if (tmp___10) {
        return ((reg_errcode_t )12);
      }
      {
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
      }
      __Cont___1: 
      sl_str ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: 
    sub_top_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , int bkref_node ,
                                    int bkref_str ) 
{ 
  reg_errcode_t err ;
  int to_idx ;
  long tmp ;
  reg_errcode_t tmp___0 ;

  {
  {
  err = check_arrival(mctx, & sub_last->path, sub_last->node, sub_last->str_idx, bkref_node,
                      bkref_str, 8);
  }
  if ((unsigned int )err != 0U) {
    return (err);
  }
  {
  err = match_ctx_add_entry(mctx, bkref_node, bkref_str, (int )sub_top->str_idx, sub_last->str_idx);
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp) {
    return (err);
  }
  {
  to_idx = (bkref_str + sub_last->str_idx) - (int )sub_top->str_idx;
  tmp___0 = clean_state_log_if_needed(mctx, to_idx);
  }
  return (tmp___0);
}
}
static int find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , int subexp_idx ,
                            int type ) 
{ 
  int cls_idx ;
  int cls_node ;
  re_token_t const   *node ;

  {
  cls_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (cls_idx < (int )nodes->nelem)) {
      goto while_break;
    }
    cls_node = *(nodes->elems + cls_idx);
    node = (re_token_t const   *)(dfa->nodes + cls_node);
    if ((unsigned int const   )node->type == (unsigned int const   )type) {
      if (node->opr.idx == (int const   )subexp_idx) {
        return (cls_node);
      }
    }
    cls_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   int top_node , int top_str , int last_node , int last_str ,
                                   int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  int subexp_num ;
  int backup_cur_idx ;
  int str_idx ;
  int null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  int old_alloc ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int __attribute__((__pure__))  tmp___15 ;

  {
  {
  dfa = mctx->dfa;
  err = (reg_errcode_t )0;
  cur_state = (re_dfastate_t *)((void *)0);
  subexp_num = (dfa->nodes + top_node)->opr.idx;
  tmp___1 = __builtin_expect((long )(path->alloc < (last_str + mctx->max_mb_elem_len) + 1),
                             0L);
  }
  if (tmp___1) {
    {
    old_alloc = path->alloc;
    path->alloc += (last_str + mctx->max_mb_elem_len) + 1;
    tmp = realloc((void *)path->array, (unsigned long )path->alloc * sizeof(re_dfastate_t *));
    new_array = (re_dfastate_t **)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      path->alloc = old_alloc;
      return ((reg_errcode_t )12);
    }
    {
    path->array = new_array;
    memset((void *)(new_array + old_alloc), '\000', sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc));
    }
  }
  tmp___2 = path->next_idx;
  if (! tmp___2) {
    tmp___2 = top_str;
  }
  {
  str_idx = tmp___2;
  backup_state_log = mctx->state_log;
  backup_cur_idx = mctx->input.cur_idx;
  mctx->state_log = path->array;
  mctx->input.cur_idx = str_idx;
  context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1,
                                 mctx->eflags);
  }
  if (str_idx == top_str) {
    {
    err = re_node_set_init_1(& next_nodes, top_node);
    tmp___3 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp___3) {
      return (err);
    }
    {
    err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
    tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
    }
    if (tmp___4) {
      {
      free((void *)next_nodes.elems);
      }
      return (err);
    }
  } else {
    cur_state = *(mctx->state_log + str_idx);
    if (cur_state) {
      if (cur_state->has_backref) {
        {
        err = re_node_set_init_copy(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
        tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___5) {
          return (err);
        }
      } else {
        {
        memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
      memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
      }
    }
  }
  if (str_idx == top_str) {
    goto _L;
  } else { //Added block
  if (cur_state) {
    if (cur_state->has_backref) {
      _L: 
      if (next_nodes.nelem) {
        {
        err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
        tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___6) {
          {
          free((void *)next_nodes.elems);
          }
          return (err);
        }
      }
      {
      cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                           context);
      }
      if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
        if ((unsigned int )err != 0U) {
          tmp___7 = 1;
        } else {
          tmp___7 = 0;
        }
      } else {
        tmp___7 = 0;
      }
      {
      tmp___8 = __builtin_expect((long )tmp___7, 0L);
      }
      if (tmp___8) {
        {
        free((void *)next_nodes.elems);
        }
        return (err);
      }
      *(mctx->state_log + str_idx) = cur_state;
    }
  }
  }
  null_cnt = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (str_idx < last_str) {
      if (! (null_cnt <= mctx->max_mb_elem_len)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    next_nodes.nelem = 0;
    if (*(mctx->state_log + (str_idx + 1))) {
      {
      err = re_node_set_merge(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1)))->nodes));
      tmp___9 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___9) {
        {
        free((void *)next_nodes.elems);
        }
        return (err);
      }
    }
    if (cur_state) {
      {
      err = check_arrival_add_next_nodes(mctx, str_idx, & cur_state->non_eps_nodes,
                                         & next_nodes);
      tmp___10 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___10) {
        {
        free((void *)next_nodes.elems);
        }
        return (err);
      }
    }
    str_idx ++;
    if (next_nodes.nelem) {
      {
      err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
      tmp___11 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___11) {
        {
        free((void *)next_nodes.elems);
        }
        return (err);
      }
      {
      err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
      tmp___12 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___12) {
        {
        free((void *)next_nodes.elems);
        }
        return (err);
      }
    }
    {
    context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1,
                                   mctx->eflags);
    cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
    }
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      if ((unsigned int )err != 0U) {
        tmp___13 = 1;
      } else {
        tmp___13 = 0;
      }
    } else {
      tmp___13 = 0;
    }
    {
    tmp___14 = __builtin_expect((long )tmp___13, 0L);
    }
    if (tmp___14) {
      {
      free((void *)next_nodes.elems);
      }
      return (err);
    }
    *(mctx->state_log + str_idx) = cur_state;
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      null_cnt ++;
    } else {
      null_cnt = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)next_nodes.elems);
  }
  if ((unsigned long )*(mctx->state_log + last_str) == (unsigned long )((void *)0)) {
    cur_nodes = (re_node_set *)((void *)0);
  } else {
    cur_nodes = & (*(mctx->state_log + last_str))->nodes;
  }
  path->next_idx = str_idx;
  mctx->state_log = backup_state_log;
  mctx->input.cur_idx = backup_cur_idx;
  if ((unsigned long )cur_nodes != (unsigned long )((void *)0)) {
    {
    tmp___15 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
    }
    if (tmp___15) {
      return ((reg_errcode_t )0);
    }
  }
  return ((reg_errcode_t )1);
}
}
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , int str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  int result ;
  int cur_idx ;
  reg_errcode_t err ;
  re_node_set union_set ;
  int naccepted ;
  int cur_node ;
  long tmp ;
  int tmp___0 ;

  {
  {
  dfa = mctx->dfa;
  err = (reg_errcode_t )0;
  memset((void *)(& union_set), '\000', sizeof(re_node_set ));
  cur_idx = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (cur_idx < cur_nodes->nelem)) {
      goto while_break;
    }
    naccepted = 0;
    cur_node = *(cur_nodes->elems + cur_idx);
    if (naccepted) {
      goto _L;
    } else {
      {
      tmp___0 = check_node_accept((re_match_context_t const   *)mctx, (re_token_t const   *)(dfa->nodes + cur_node),
                                  str_idx);
      }
      if (tmp___0) {
        _L: 
        {
        result = re_node_set_insert(next_nodes, *(dfa->nexts + cur_node));
        tmp = __builtin_expect((long )(result < 0), 0L);
        }
        if (tmp) {
          {
          free((void *)union_set.elems);
          }
          return ((reg_errcode_t )12);
        }
      }
    }
    cur_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)union_set.elems);
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              int ex_subexp , int type ) 
{ 
  reg_errcode_t err ;
  int idx ;
  int outside_node ;
  re_node_set new_nodes ;
  long tmp ;
  int cur_node ;
  re_node_set const   *eclosure ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  err = re_node_set_alloc(& new_nodes, cur_nodes->nelem);
  tmp = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp) {
    return (err);
  }
  idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (idx < cur_nodes->nelem)) {
      goto while_break;
    }
    {
    cur_node = *(cur_nodes->elems + idx);
    eclosure = (re_node_set const   *)(dfa->eclosures + cur_node);
    outside_node = find_subexp_node(dfa, eclosure, ex_subexp, type);
    }
    if (outside_node == -1) {
      {
      err = re_node_set_merge(& new_nodes, eclosure);
      tmp___0 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___0) {
        {
        free((void *)new_nodes.elems);
        }
        return (err);
      }
    } else {
      {
      err = check_arrival_expand_ecl_sub(dfa, & new_nodes, cur_node, ex_subexp, type);
      tmp___1 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___1) {
        {
        free((void *)new_nodes.elems);
        }
        return (err);
      }
    }
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)cur_nodes->elems);
  *cur_nodes = new_nodes;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  int target , int ex_subexp , int type ) 
{ 
  int cur_node ;
  int err ;
  long tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  long tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;

  {
  cur_node = target;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___3 = re_node_set_contains((re_node_set const   *)dst_nodes, cur_node);
    }
    if (tmp___3) {
      goto while_break;
    }
    if ((unsigned int )(dfa->nodes + cur_node)->type == (unsigned int )type) {
      if ((dfa->nodes + cur_node)->opr.idx == ex_subexp) {
        if (type == 9) {
          {
          err = re_node_set_insert(dst_nodes, cur_node);
          tmp = __builtin_expect((long )(err == -1), 0L);
          }
          if (tmp) {
            return ((reg_errcode_t )12);
          }
        }
        goto while_break;
      }
    }
    {
    err = re_node_set_insert(dst_nodes, cur_node);
    tmp___0 = __builtin_expect((long )(err == -1), 0L);
    }
    if (tmp___0) {
      return ((reg_errcode_t )12);
    }
    if ((dfa->edests + cur_node)->nelem == 0) {
      goto while_break;
    }
    if ((dfa->edests + cur_node)->nelem == 2) {
      {
      tmp___1 = check_arrival_expand_ecl_sub(dfa, dst_nodes, *((dfa->edests + cur_node)->elems + 1),
                                             ex_subexp, type);
      err = (int )tmp___1;
      tmp___2 = __builtin_expect((long )(err != 0), 0L);
      }
      if (tmp___2) {
        return ((reg_errcode_t )err);
      }
    }
    cur_node = *((dfa->edests + cur_node)->elems + 0);
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        int cur_str , int subexp_num , int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  int cache_idx_start ;
  int tmp ;
  struct re_backref_cache_entry *ent ;
  int to_idx ;
  int next_node ;
  int __attribute__((__pure__))  tmp___0 ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  int __attribute__((__pure__))  tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  re_node_set union_set ;
  int ret ;
  int __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  struct re_backref_cache_entry *tmp___11 ;

  {
  {
  dfa = mctx->dfa;
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, cur_str);
  cache_idx_start = tmp;
  }
  if (cache_idx_start == -1) {
    return ((reg_errcode_t )0);
  }
  restart: 
  ent = mctx->bkref_ents + cache_idx_start;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, ent->node);
    }
    if (! tmp___0) {
      goto __Cont;
    }
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
    if (to_idx == cur_str) {
      {
      next_node = *((dfa->edests + ent->node)->elems + 0);
      tmp___1 = re_node_set_contains((re_node_set const   *)cur_nodes, next_node);
      }
      if (tmp___1) {
        goto __Cont;
      }
      {
      err = re_node_set_init_1(& new_dests, next_node);
      err2 = check_arrival_expand_ecl(dfa, & new_dests, subexp_num, type);
      err3 = re_node_set_merge(cur_nodes, (re_node_set const   *)(& new_dests));
      free((void *)new_dests.elems);
      }
      if ((unsigned int )err != 0U) {
        tmp___3 = 1;
      } else { //Added block
      if ((unsigned int )err2 != 0U) {
        tmp___3 = 1;
      } else { //Added block
      if ((unsigned int )err3 != 0U) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      }
      }
      {
      tmp___4 = __builtin_expect((long )tmp___3, 0L);
      }
      if (tmp___4) {
        if ((unsigned int )err != 0U) {
          err = err;
        } else {
          if ((unsigned int )err2 != 0U) {
            tmp___2 = (unsigned int )err2;
          } else {
            tmp___2 = (unsigned int )err3;
          }
          err = (reg_errcode_t )tmp___2;
        }
        return (err);
      }
      goto restart;
    } else {
      next_node = *(dfa->nexts + ent->node);
      if (*(mctx->state_log + to_idx)) {
        {
        tmp___5 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                       next_node);
        }
        if (tmp___5) {
          goto __Cont;
        }
        {
        err = re_node_set_init_copy(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
        ret = re_node_set_insert(& union_set, next_node);
        }
        if ((unsigned int )err != 0U) {
          tmp___6 = 1;
        } else { //Added block
        if (ret < 0) {
          tmp___6 = 1;
        } else {
          tmp___6 = 0;
        }
        }
        {
        tmp___7 = __builtin_expect((long )tmp___6, 0L);
        }
        if (tmp___7) {
          {
          free((void *)union_set.elems);
          }
          if ((unsigned int )err != 0U) {
            err = err;
          } else {
            err = (reg_errcode_t )12;
          }
          return (err);
        }
      } else {
        {
        err = re_node_set_init_1(& union_set, next_node);
        tmp___8 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___8) {
          return (err);
        }
      }
      {
      *(mctx->state_log + to_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
      free((void *)union_set.elems);
      }
      if ((unsigned long )*(mctx->state_log + to_idx) == (unsigned long )((void *)0)) {
        if ((unsigned int )err != 0U) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      {
      tmp___10 = __builtin_expect((long )tmp___9, 0L);
      }
      if (tmp___10) {
        return (err);
      }
    }
    __Cont: 
    tmp___11 = ent;
    ent ++;
    if (! tmp___11->more) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((reg_errcode_t )0);
}
}
static int build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) 
{ 
  reg_errcode_t err ;
  int i ;
  int j ;
  int ch ;
  int need_word_trtable ;
  bitset_word_t elem ;
  bitset_word_t mask ;
  _Bool dests_node_malloced ;
  _Bool dest_states_malloced ;
  int ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset_t *dests_ch ;
  bitset_t acceptable ;
  struct dests_alloc *dests_alloc ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct re_dfastate_t **tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  long tmp___8 ;
  int next_node ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  struct re_dfastate_t **tmp___16 ;
  void *tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  struct re_dfastate_t **tmp___20 ;
  void *tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;

  {
  need_word_trtable = 0;
  dests_node_malloced = (_Bool)0;
  dest_states_malloced = (_Bool)0;
  dest_states = (re_dfastate_t **)((void *)0);
  if (sizeof(struct dests_alloc ) < 4032UL) {
    {
    tmp = __builtin_alloca(sizeof(struct dests_alloc ));
    dests_alloc = (struct dests_alloc *)tmp;
    }
  } else {
    {
    tmp___0 = malloc(sizeof(struct dests_alloc ));
    dests_alloc = (struct dests_alloc *)tmp___0;
    tmp___1 = __builtin_expect((long )((unsigned long )dests_alloc == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___1) {
      return (0);
    }
    dests_node_malloced = (_Bool)1;
  }
  {
  dests_node = dests_alloc->dests_node;
  dests_ch = dests_alloc->dests_ch;
  tmp___2 = (struct re_dfastate_t **)((void *)0);
  state->trtable = tmp___2;
  state->word_trtable = tmp___2;
  ndests = group_nodes_into_DFAstates(dfa, (re_dfastate_t const   *)state, dests_node,
                                      dests_ch);
  tmp___4 = __builtin_expect((long )(ndests <= 0), 0L);
  }
  if (tmp___4) {
    if (dests_node_malloced) {
      {
      free((void *)dests_alloc);
      }
    }
    if (ndests == 0) {
      {
      tmp___3 = calloc(sizeof(re_dfastate_t *), (size_t )256);
      state->trtable = (re_dfastate_t **)tmp___3;
      }
      return (1);
    }
    return (0);
  }
  {
  err = re_node_set_alloc(& follows, ndests + 1);
  tmp___5 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
  }
  if (tmp___5) {
    goto out_free;
  }
  if ((sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL + (unsigned long )(ndests * 3) * sizeof(re_dfastate_t *) < 4032UL) {
    {
    tmp___6 = __builtin_alloca((unsigned long )(ndests * 3) * sizeof(re_dfastate_t *));
    dest_states = (re_dfastate_t **)tmp___6;
    }
  } else {
    {
    tmp___7 = malloc((unsigned long )(ndests * 3) * sizeof(re_dfastate_t *));
    dest_states = (re_dfastate_t **)tmp___7;
    tmp___8 = __builtin_expect((long )((unsigned long )dest_states == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___8) {
      out_free: 
      if (dest_states_malloced) {
        {
        free((void *)dest_states);
        }
      }
      {
      free((void *)follows.elems);
      i = 0;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i < ndests)) {
          goto while_break;
        }
        {
        free((void *)(dests_node + i)->elems);
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      if (dests_node_malloced) {
        {
        free((void *)dests_alloc);
        }
      }
      return (0);
    }
    dest_states_malloced = (_Bool)1;
  }
  {
  dest_states_word = dest_states + ndests;
  dest_states_nl = dest_states_word + ndests;
  memset((void *)(acceptable), '\000', sizeof(bitset_t ));
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < ndests)) {
      goto while_break___0;
    }
    follows.nelem = 0;
    j = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (j < (dests_node + i)->nelem)) {
        goto while_break___1;
      }
      next_node = *(dfa->nexts + *((dests_node + i)->elems + j));
      if (next_node != -1) {
        {
        err = re_node_set_merge(& follows, (re_node_set const   *)(dfa->eclosures + next_node));
        tmp___9 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___9) {
          goto out_free;
        }
      }
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    *(dest_states + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                  0U);
    }
    if ((unsigned long )*(dest_states + i) == (unsigned long )((void *)0)) {
      if ((unsigned int )err != 0U) {
        tmp___10 = 1;
      } else {
        tmp___10 = 0;
      }
    } else {
      tmp___10 = 0;
    }
    {
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
    if (tmp___11) {
      goto out_free;
    }
    if ((*(dest_states + i))->has_constraint) {
      {
      *(dest_states_word + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                         1U);
      }
      if ((unsigned long )*(dest_states_word + i) == (unsigned long )((void *)0)) {
        if ((unsigned int )err != 0U) {
          tmp___12 = 1;
        } else {
          tmp___12 = 0;
        }
      } else {
        tmp___12 = 0;
      }
      {
      tmp___13 = __builtin_expect((long )tmp___12, 0L);
      }
      if (tmp___13) {
        goto out_free;
      }
      if ((unsigned long )*(dest_states + i) != (unsigned long )*(dest_states_word + i)) {
        if (dfa->mb_cur_max > 1) {
          need_word_trtable = 1;
        }
      }
      {
      *(dest_states_nl + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                       (unsigned int )(1 << 1));
      }
      if ((unsigned long )*(dest_states_nl + i) == (unsigned long )((void *)0)) {
        if ((unsigned int )err != 0U) {
          tmp___14 = 1;
        } else {
          tmp___14 = 0;
        }
      } else {
        tmp___14 = 0;
      }
      {
      tmp___15 = __builtin_expect((long )tmp___14, 0L);
      }
      if (tmp___15) {
        goto out_free;
      }
    } else {
      *(dest_states_word + i) = *(dest_states + i);
      *(dest_states_nl + i) = *(dest_states + i);
    }
    {
    bitset_merge(acceptable, (bitset_word_t * const  )(*(dests_ch + i)));
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp___24 = __builtin_expect((long )need_word_trtable, 0L);
  }
  if (tmp___24) {
    {
    tmp___21 = calloc(sizeof(re_dfastate_t *), (size_t )512);
    tmp___20 = (re_dfastate_t **)tmp___21;
    state->word_trtable = tmp___20;
    trtable = tmp___20;
    tmp___22 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
    if (tmp___22) {
      goto out_free;
    }
    i = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! ((unsigned long )i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
        goto while_break___2;
      }
      ch = (int )((unsigned long )i * (sizeof(bitset_word_t ) * 8UL));
      elem = acceptable[i];
      mask = (bitset_word_t )1;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! elem) {
          goto while_break___3;
        }
        {
        tmp___23 = __builtin_expect((long )(elem & 1UL), 0L);
        }
        if (tmp___23) {
          j = 0;
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
              goto while_break___4;
            }
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          *(trtable + ch) = *(dest_states + j);
          *(trtable + (ch + 256)) = *(dest_states_word + j);
        }
        mask <<= 1;
        elem >>= 1;
        ch ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
    tmp___17 = calloc(sizeof(re_dfastate_t *), (size_t )256);
    tmp___16 = (re_dfastate_t **)tmp___17;
    state->trtable = tmp___16;
    trtable = tmp___16;
    tmp___18 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
    if (tmp___18) {
      goto out_free;
    }
    i = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! ((unsigned long )i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
        goto while_break___5;
      }
      ch = (int )((unsigned long )i * (sizeof(bitset_word_t ) * 8UL));
      elem = acceptable[i];
      mask = (bitset_word_t )1;
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        if (! elem) {
          goto while_break___6;
        }
        {
        tmp___19 = __builtin_expect((long )(elem & 1UL), 0L);
        }
        if (tmp___19) {
          j = 0;
          {
          while (1) {
            while_continue___7: /* CIL Label */ ;
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
              goto while_break___7;
            }
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          if (dfa->word_char[i] & mask) {
            *(trtable + ch) = *(dest_states_word + j);
          } else {
            *(trtable + ch) = *(dest_states + j);
          }
        }
        mask <<= 1;
        elem >>= 1;
        ch ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  if (acceptable[10UL / (sizeof(bitset_word_t ) * 8UL)] & (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL))) {
    j = 0;
    {
    while (1) {
      while_continue___8: /* CIL Label */ ;
      if (! (j < ndests)) {
        goto while_break___8;
      }
      if ((*(dests_ch + j))[10UL / (sizeof(bitset_word_t ) * 8UL)] & (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL))) {
        *(trtable + 10) = *(dest_states_nl + j);
        if (need_word_trtable) {
          *(trtable + 266) = *(dest_states_nl + j);
        }
        goto while_break___8;
      }
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  if (dest_states_malloced) {
    {
    free((void *)dest_states);
    }
  }
  {
  free((void *)follows.elems);
  i = 0;
  }
  {
  while (1) {
    while_continue___9: /* CIL Label */ ;
    if (! (i < ndests)) {
      goto while_break___9;
    }
    {
    free((void *)(dests_node + i)->elems);
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  if (dests_node_malloced) {
    {
    free((void *)dests_alloc);
    }
  }
  return (1);
}
}
static int group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) 
{ 
  reg_errcode_t err ;
  int result ;
  int i ;
  int j ;
  int k ;
  int ndests ;
  bitset_t accepts ;
  re_node_set const   *cur_nodes ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  _Bool accepts_newline ;
  bitset_word_t any_set ;
  unsigned long tmp ;
  bitset_word_t any_set___0 ;
  unsigned long tmp___0 ;
  bitset_t intersec ;
  bitset_t remains ;
  bitset_word_t has_intersec ;
  bitset_word_t not_subset ;
  bitset_word_t not_consumed ;
  bitset_word_t tmp___1 ;
  bitset_word_t tmp___2 ;
  bitset_word_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
  cur_nodes = & state->nodes;
  memset((void *)(accepts), '\000', sizeof(bitset_t ));
  ndests = 0;
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < (int )cur_nodes->nelem)) {
      goto while_break;
    }
    node = (re_token_t *)(dfa->nodes + *(cur_nodes->elems + i));
    type = node->type;
    constraint = node->constraint;
    if ((unsigned int )type == 1U) {
      accepts[(unsigned long )node->opr.c / (sizeof(bitset_word_t ) * 8UL)] |= 1UL << (unsigned long )node->opr.c % (sizeof(bitset_word_t ) * 8UL);
    } else { //Added block
    if ((unsigned int )type == 3U) {
      {
      bitset_merge(accepts, (bitset_word_t * const  )node->opr.sbcset);
      }
    } else { //Added block
    if ((unsigned int )type == 5U) {
      {
      memset((void *)(accepts), '\377', sizeof(bitset_t ));
      }
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        accepts[10UL / (sizeof(bitset_word_t ) * 8UL)] &= ~ (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL));
      }
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        accepts[0UL / (sizeof(bitset_word_t ) * 8UL)] &= ~ (1UL << 0UL % (sizeof(bitset_word_t ) * 8UL));
      }
    } else {
      goto __Cont;
    }
    }
    }
    if (constraint) {
      if (constraint & 32U) {
        {
        accepts_newline = (_Bool )(accepts[10UL / (sizeof(bitset_word_t ) * 8UL)] & (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL)));
        memset((void *)(accepts), '\000', sizeof(bitset_t ));
        }
        if (accepts_newline) {
          accepts[10UL / (sizeof(bitset_word_t ) * 8UL)] |= 1UL << 10UL % (sizeof(bitset_word_t ) * 8UL);
        } else {
          goto __Cont;
        }
      }
      if (constraint & 128U) {
        {
        memset((void *)(accepts), '\000', sizeof(bitset_t ));
        }
        goto __Cont;
      }
      if (constraint & 4U) {
        any_set = (bitset_word_t )0;
        if ((unsigned int )type == 1U) {
          if (! node->word_char) {
            {
            memset((void *)(accepts), '\000', sizeof(bitset_t ));
            }
            goto __Cont;
          }
        }
        j = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((unsigned long )j < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
            goto while_break___0;
          }
          tmp = accepts[j] & dfa->word_char[j];
          accepts[j] = tmp;
          any_set |= tmp;
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        if (! any_set) {
          goto __Cont;
        }
      }
      if (constraint & 8U) {
        any_set___0 = (bitset_word_t )0;
        if ((unsigned int )type == 1U) {
          if (node->word_char) {
            {
            memset((void *)(accepts), '\000', sizeof(bitset_t ));
            }
            goto __Cont;
          }
        }
        j = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((unsigned long )j < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
            goto while_break___1;
          }
          tmp___0 = accepts[j] & ~ dfa->word_char[j];
          accepts[j] = tmp___0;
          any_set___0 |= tmp___0;
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        if (! any_set___0) {
          goto __Cont;
        }
      }
    }
    j = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (j < ndests)) {
        goto while_break___2;
      }
      if ((unsigned int )type == 1U) {
        if (! ((*(dests_ch + j))[(unsigned long )node->opr.c / (sizeof(bitset_word_t ) * 8UL)] & (1UL << (unsigned long )node->opr.c % (sizeof(bitset_word_t ) * 8UL)))) {
          goto __Cont___0;
        }
      }
      has_intersec = (bitset_word_t )0;
      k = 0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! ((unsigned long )k < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
          goto while_break___3;
        }
        tmp___1 = accepts[k] & (*(dests_ch + j))[k];
        intersec[k] = tmp___1;
        has_intersec |= tmp___1;
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      if (! has_intersec) {
        goto __Cont___0;
      }
      not_consumed = (bitset_word_t )0;
      not_subset = not_consumed;
      k = 0;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! ((unsigned long )k < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
          goto while_break___4;
        }
        tmp___2 = ~ accepts[k] & (*(dests_ch + j))[k];
        remains[k] = tmp___2;
        not_subset |= tmp___2;
        tmp___3 = accepts[k] & ~ (*(dests_ch + j))[k];
        accepts[k] = tmp___3;
        not_consumed |= tmp___3;
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      if (not_subset) {
        {
        memmove((void * __restrict  )(*(dests_ch + ndests)), (void const   * __restrict  )(remains),
                sizeof(bitset_t ));
        memmove((void * __restrict  )(*(dests_ch + j)), (void const   * __restrict  )(intersec),
                sizeof(bitset_t ));
        err = re_node_set_init_copy(dests_node + ndests, (re_node_set const   *)(dests_node + j));
        tmp___4 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
        }
        if (tmp___4) {
          goto error_return;
        }
        ndests ++;
      }
      {
      result = re_node_set_insert(dests_node + j, *(cur_nodes->elems + i));
      tmp___5 = __builtin_expect((long )(result < 0), 0L);
      }
      if (tmp___5) {
        goto error_return;
      }
      if (! not_consumed) {
        goto while_break___2;
      }
      __Cont___0: 
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    if (j == ndests) {
      {
      memmove((void * __restrict  )(*(dests_ch + ndests)), (void const   * __restrict  )(accepts),
              sizeof(bitset_t ));
      err = re_node_set_init_1(dests_node + ndests, *(cur_nodes->elems + i));
      tmp___6 = __builtin_expect((long )((unsigned int )err != 0U), 0L);
      }
      if (tmp___6) {
        goto error_return;
      }
      {
      ndests ++;
      memset((void *)(accepts), '\000', sizeof(bitset_t ));
      }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (ndests);
  error_return: 
  j = 0;
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    if (! (j < ndests)) {
      goto while_break___5;
    }
    {
    free((void *)(dests_node + j)->elems);
    j ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  return (-1);
}
}
static int check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                             int idx ) 
{ 
  unsigned char ch ;
  unsigned int context ;
  unsigned int tmp ;

  {
  ch = *(mctx->input.mbs + idx);
  {
  if ((unsigned int const   )node->type == 1U) {
    goto case_1;
  }
  if ((unsigned int const   )node->type == 3U) {
    goto case_3;
  }
  if ((unsigned int const   )node->type == 5U) {
    goto case_5;
  }
  goto switch_default;
  case_1: /* CIL Label */ 
  if ((int const   )node->opr.c != (int const   )ch) {
    return (0);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  if (! (*(node->opr.sbcset + (unsigned long )ch / (sizeof(bitset_word_t ) * 8UL)) & (1UL << (unsigned long )ch % (sizeof(bitset_word_t ) * 8UL)))) {
    return (0);
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  if ((int )ch == 10) {
    if (! ((mctx->dfa)->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      return (0);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )ch == 0) {
    if ((mctx->dfa)->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      return (0);
    }
  }
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  return (0);
  switch_break: /* CIL Label */ ;
  }
  if (node->constraint) {
    {
    tmp = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
    context = tmp;
    }
    if (node->constraint & 4U) {
      if (! (context & 1U)) {
        return (0);
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if (node->constraint & 8U) {
      if (context & 1U) {
        return (0);
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (node->constraint & 32U) {
      if (! (context & (unsigned int )(1 << 1))) {
        return (0);
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (node->constraint & 128U) {
      if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
        return (0);
      }
    }
    }
    }
    }
  }
  return (1);
}
}
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) 
{ 
  reg_errcode_t ret ;
  re_string_t *pstr ;
  long tmp ;
  re_dfastate_t **new_array ;
  void *tmp___0 ;
  long tmp___1 ;

  {
  {
  pstr = & mctx->input;
  ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2);
  tmp = __builtin_expect((long )((unsigned int )ret != 0U), 0L);
  }
  if (tmp) {
    return (ret);
  }
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
    tmp___0 = realloc((void *)mctx->state_log, (unsigned long )(pstr->bufs_len + 1) * sizeof(re_dfastate_t *));
    new_array = (re_dfastate_t **)tmp___0;
    tmp___1 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___1) {
      return ((reg_errcode_t )12);
    }
    mctx->state_log = new_array;
  }
  if (pstr->icase) {
    {
    build_upper_buffer(pstr);
    }
  } else { //Added block
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
    {
    re_string_translate_buffer(pstr);
    }
  }
  }
  return ((reg_errcode_t )0);
}
}
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , int n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  mctx->eflags = eflags;
  mctx->match_last = -1;
  if (n > 0) {
    {
    tmp = malloc((unsigned long )n * sizeof(struct re_backref_cache_entry ));
    mctx->bkref_ents = (struct re_backref_cache_entry *)tmp;
    tmp___0 = malloc((unsigned long )n * sizeof(re_sub_match_top_t *));
    mctx->sub_tops = (re_sub_match_top_t **)tmp___0;
    }
    if ((unsigned long )mctx->bkref_ents == (unsigned long )((void *)0)) {
      tmp___1 = 1;
    } else { //Added block
    if ((unsigned long )mctx->sub_tops == (unsigned long )((void *)0)) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      return ((reg_errcode_t )12);
    }
  }
  mctx->abkref_ents = n;
  mctx->max_mb_elem_len = 1;
  mctx->asub_tops = n;
  return ((reg_errcode_t )0);
}
}
static void match_ctx_clean(re_match_context_t *mctx ) 
{ 
  int st_idx ;
  int sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
  st_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (st_idx < mctx->nsub_tops)) {
      goto while_break;
    }
    top = *(mctx->sub_tops + st_idx);
    sl_idx = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (sl_idx < top->nlasts)) {
        goto while_break___0;
      }
      {
      last = *(top->lasts + sl_idx);
      free((void *)last->path.array);
      free((void *)last);
      sl_idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    free((void *)top->lasts);
    }
    if (top->path) {
      {
      free((void *)(top->path)->array);
      free((void *)top->path);
      }
    }
    {
    free((void *)top);
    st_idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  mctx->nsub_tops = 0;
  mctx->nbkref_ents = 0;
  return;
}
}
static void match_ctx_free(re_match_context_t *mctx ) 
{ 


  {
  {
  match_ctx_clean(mctx);
  free((void *)mctx->sub_tops);
  free((void *)mctx->bkref_ents);
  }
  return;
}
}
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , int node , int str_idx ,
                                         int from , int to ) 
{ 
  struct re_backref_cache_entry *new_entry ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
    {
    tmp = realloc((void *)mctx->bkref_ents, (unsigned long )(mctx->abkref_ents * 2) * sizeof(struct re_backref_cache_entry ));
    new_entry = (struct re_backref_cache_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      {
      free((void *)mctx->bkref_ents);
      }
      return ((reg_errcode_t )12);
    }
    {
    mctx->bkref_ents = new_entry;
    memset((void *)(mctx->bkref_ents + mctx->nbkref_ents), '\000', sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents);
    mctx->abkref_ents *= 2;
    }
  }
  if (mctx->nbkref_ents > 0) {
    if ((mctx->bkref_ents + (mctx->nbkref_ents - 1))->str_idx == str_idx) {
      (mctx->bkref_ents + (mctx->nbkref_ents - 1))->more = (char)1;
    }
  }
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
  if (from == to) {
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short )(~ 0);
  } else {
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)0;
  }
  tmp___1 = mctx->nbkref_ents;
  (mctx->nbkref_ents) ++;
  (mctx->bkref_ents + tmp___1)->more = (char)0;
  if (mctx->max_mb_elem_len < to - from) {
    mctx->max_mb_elem_len = to - from;
  }
  return ((reg_errcode_t )0);
}
}
static int search_cur_bkref_entry(re_match_context_t const   *mctx , int str_idx ) 
{ 
  int left ;
  int right ;
  int mid ;
  int last ;

  {
  right = (int )mctx->nbkref_ents;
  last = right;
  left = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (left < right)) {
      goto while_break;
    }
    mid = (left + right) / 2;
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (left < last) {
    if ((mctx->bkref_ents + left)->str_idx == str_idx) {
      return (left);
    } else {
      return (-1);
    }
  } else {
    return (-1);
  }
}
}
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , int node , int str_idx ) 
{ 
  int new_asub_tops ;
  re_sub_match_top_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp___1 = __builtin_expect((long )(mctx->nsub_tops == mctx->asub_tops), 0L);
  }
  if (tmp___1) {
    {
    new_asub_tops = mctx->asub_tops * 2;
    tmp = realloc((void *)mctx->sub_tops, (unsigned long )new_asub_tops * sizeof(re_sub_match_top_t *));
    new_array = (re_sub_match_top_t **)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      return ((reg_errcode_t )12);
    }
    mctx->sub_tops = new_array;
    mctx->asub_tops = new_asub_tops;
  }
  {
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_top_t ));
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)tmp___2;
  tmp___3 = __builtin_expect((long )((unsigned long )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned long )((void *)0)),
                             0L);
  }
  if (tmp___3) {
    return ((reg_errcode_t )12);
  }
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
  tmp___4 = mctx->nsub_tops;
  (mctx->nsub_tops) ++;
  (*(mctx->sub_tops + tmp___4))->str_idx = str_idx;
  return ((reg_errcode_t )0);
}
}
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , int node ,
                                                  int str_idx ) 
{ 
  re_sub_match_last_t *new_entry ;
  int new_alasts ;
  re_sub_match_last_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
  {
  tmp___1 = __builtin_expect((long )(subtop->nlasts == subtop->alasts), 0L);
  }
  if (tmp___1) {
    {
    new_alasts = 2 * subtop->alasts + 1;
    tmp = realloc((void *)subtop->lasts, (unsigned long )new_alasts * sizeof(re_sub_match_last_t *));
    new_array = (re_sub_match_last_t **)tmp;
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
    if (tmp___0) {
      return ((re_sub_match_last_t *)((void *)0));
    }
    subtop->lasts = new_array;
    subtop->alasts = new_alasts;
  }
  {
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_last_t ));
  new_entry = (re_sub_match_last_t *)tmp___2;
  tmp___3 = __builtin_expect((long )((unsigned long )new_entry != (unsigned long )((void *)0)),
                             1L);
  }
  if (tmp___3) {
    *(subtop->lasts + subtop->nlasts) = new_entry;
    new_entry->node = node;
    new_entry->str_idx = str_idx;
    (subtop->nlasts) ++;
  }
  return (new_entry);
}
}
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          int last_node , int last_str_idx ) 
{ 


  {
  {
  sctx->sifted_states = sifted_sts;
  sctx->limited_states = limited_sts;
  sctx->last_node = last_node;
  sctx->last_str_idx = last_str_idx;
  memset((void *)(& sctx->limits), '\000', sizeof(re_node_set ));
  }
  return;
}
}
static char const   reg_errors[72]  = 
  {      (char const   )'n',      (char const   )'o',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'o',      (char const   )'u',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )'y', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'\000'};
static void compile_regex_1(struct regex *new_regex , int needed_sub ) 
{ 
  char const   *error ;
  int syntax ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  char buf[200] ;

  {
  if (extended_regexp_flags & 1) {
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  syntax = (int )(tmp & ~ (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  syntax = (int )((unsigned long )syntax | ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  if (new_regex->flags & (1 << 1)) {
    tmp___0 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
    tmp___0 = 0UL;
  }
  syntax = (int )((unsigned long )syntax | tmp___0);
  if (needed_sub) {
    tmp___1 = 0UL;
  } else {
    tmp___1 = ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
  {
  syntax = (int )((unsigned long )syntax | tmp___1);
  tmp___2 = malloc((size_t )(1 << sizeof(char ) * 8UL));
  new_regex->pattern.fastmap = (char *)tmp___2;
  }
  if (new_regex->flags & ((1 << 1) << 1)) {
    syntax = (int )((unsigned long )syntax & ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1));
    syntax = (int )((unsigned long )syntax | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  {
  re_set_syntax((reg_syntax_t )syntax);
  error = re_compile_pattern((char const   *)(new_regex->re), new_regex->sz, & new_regex->pattern);
  new_regex->pattern.newline_anchor = (unsigned int )((new_regex->flags & ((1 << 1) << 1)) != 0);
  new_regex->pattern.translate = (unsigned char *)((void *)0);
  }
  if (error) {
    {
    bad_prog(error);
    }
  }
  if (needed_sub) {
    if (new_regex->pattern.re_nsub < (size_t )(needed_sub - 1)) {
      if ((unsigned int )posixicity == 0U) {
        {
        sprintf((char * __restrict  )(buf), (char const   * __restrict  )"invalid reference \\%d on `s\' command\'s RHS",
                needed_sub - 1);
        bad_prog((char const   *)(buf));
        }
      }
    }
  }
  return;
}
}
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) 
{ 
  struct regex *new_regex ;
  size_t re_len ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp = size_buffer(b___0);
  }
  if (tmp == 0UL) {
    if (flags > 0) {
      {
      bad_prog(reg_errors + sizeof("no previous regular expression"));
      }
    }
    return ((struct regex *)((void *)0));
  }
  {
  re_len = size_buffer(b___0);
  tmp___0 = ck_malloc((sizeof(struct regex ) + re_len) - 1UL);
  new_regex = (struct regex *)tmp___0;
  new_regex->flags = flags;
  tmp___1 = get_buffer(b___0);
  memmove((void * __restrict  )(new_regex->re), (void const   * __restrict  )tmp___1,
          re_len);
  new_regex->sz = normalize_text(new_regex->re, re_len, (enum text_types )2);
  compile_regex_1(new_regex, needed_sub);
  }
  return (new_regex);
}
}
static struct regex *regex_last  ;
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) 
{ 
  int ret ;
  struct re_registers *tmp ;

  {
  if (! regex) {
    regex = regex_last;
    if (! regex_last) {
      {
      bad_prog(reg_errors);
      }
    }
  } else {
    regex_last = regex;
  }
  if (regex->pattern.no_sub) {
    if (regsize) {
      {
      compile_regex_1(regex, regsize);
      }
    }
  }
  regex->pattern.regs_allocated = 1U;
  if (regsize) {
    tmp = regarray;
  } else {
    tmp = (struct re_registers *)((void *)0);
  }
  {
  ret = re_search(& regex->pattern, (char const   *)buf, (int )buflen, (int )buf_start_offset,
                  (int )(buflen - buf_start_offset), tmp);
  }
  return (ret > -1);
}
}
#pragma merger("0","/tmp/cil-ZXSgGw8m.i","")
