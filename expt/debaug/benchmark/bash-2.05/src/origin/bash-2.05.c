/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
typedef __gid_t gid_t;
typedef __uid_t uid_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef unsigned long size_t;
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_2 __sigset_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
typedef __socklen_t socklen_t;
typedef long __jmp_buf[8];
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef struct __jmp_buf_tag sigjmp_buf[1];
enum r_instruction {
    r_output_direction = 0,
    r_input_direction = 1,
    r_inputa_direction = 2,
    r_appending_to = 3,
    r_reading_until = 4,
    r_duplicating_input = 5,
    r_duplicating_output = 6,
    r_deblank_reading_until = 7,
    r_close_this = 8,
    r_err_and_out = 9,
    r_input_output = 10,
    r_output_force = 11,
    r_duplicating_input_word = 12,
    r_duplicating_output_word = 13
} ;
enum command_type {
    cm_for = 0,
    cm_case = 1,
    cm_while = 2,
    cm_if = 3,
    cm_simple = 4,
    cm_select = 5,
    cm_connection = 6,
    cm_function_def = 7,
    cm_until = 8,
    cm_group = 9,
    cm_arith = 10,
    cm_cond = 11,
    cm_arith_for = 12,
    cm_subshell = 13
} ;
struct word_desc {
   char *word ;
   int flags ;
};
typedef struct word_desc WORD_DESC;
struct word_list {
   struct word_list *next ;
   WORD_DESC *word ;
};
typedef struct word_list WORD_LIST;
union __anonunion_REDIRECTEE_53 {
   long dest ;
   WORD_DESC *filename ;
};
typedef union __anonunion_REDIRECTEE_53 REDIRECTEE;
struct redirect {
   struct redirect *next ;
   int redirector ;
   int flags ;
   enum r_instruction instruction ;
   REDIRECTEE redirectee ;
   char *here_doc_eof ;
};
typedef struct redirect REDIRECT;
struct for_com;
struct for_com;
struct case_com;
struct case_com;
struct while_com;
struct while_com;
struct if_com;
struct if_com;
struct connection;
struct connection;
struct simple_com;
struct simple_com;
struct function_def;
struct function_def;
struct group_com;
struct group_com;
struct select_com;
struct select_com;
struct arith_com;
struct arith_com;
struct cond_com;
struct cond_com;
struct arith_for_com;
struct arith_for_com;
struct subshell_com;
struct subshell_com;
union __anonunion_value_54 {
   struct for_com *For ;
   struct case_com *Case ;
   struct while_com *While ;
   struct if_com *If ;
   struct connection *Connection ;
   struct simple_com *Simple ;
   struct function_def *Function_def ;
   struct group_com *Group ;
   struct select_com *Select ;
   struct arith_com *Arith ;
   struct cond_com *Cond ;
   struct arith_for_com *ArithFor ;
   struct subshell_com *Subshell ;
};
struct command {
   enum command_type type ;
   int flags ;
   int line ;
   REDIRECT *redirects ;
   union __anonunion_value_54 value ;
};
typedef struct command COMMAND;
struct connection {
   int ignore ;
   COMMAND *first ;
   COMMAND *second ;
   int connector ;
};
struct pattern_list {
   struct pattern_list *next ;
   WORD_LIST *patterns ;
   COMMAND *action ;
};
typedef struct pattern_list PATTERN_LIST;
struct case_com {
   int flags ;
   WORD_DESC *word ;
   PATTERN_LIST *clauses ;
};
struct for_com {
   int flags ;
   WORD_DESC *name ;
   WORD_LIST *map_list ;
   COMMAND *action ;
};
struct arith_for_com {
   int flags ;
   int line ;
   WORD_LIST *init ;
   WORD_LIST *test ;
   WORD_LIST *step ;
   COMMAND *action ;
};
struct select_com {
   int flags ;
   WORD_DESC *name ;
   WORD_LIST *map_list ;
   COMMAND *action ;
};
struct if_com {
   int flags ;
   COMMAND *test ;
   COMMAND *true_case ;
   COMMAND *false_case ;
};
struct while_com {
   int flags ;
   COMMAND *test ;
   COMMAND *action ;
};
struct arith_com {
   int flags ;
   WORD_LIST *exp ;
   int line ;
};
struct cond_com {
   int flags ;
   int line ;
   int type ;
   WORD_DESC *op ;
   struct cond_com *left ;
   struct cond_com *right ;
};
struct simple_com {
   int flags ;
   WORD_LIST *words ;
   REDIRECT *redirects ;
   int line ;
};
struct function_def {
   int flags ;
   WORD_DESC *name ;
   COMMAND *command ;
   int line ;
};
struct group_com {
   int ignore ;
   COMMAND *command ;
};
struct subshell_com {
   int flags ;
   COMMAND *command ;
};
struct g_list {
   struct g_list *next ;
};
typedef struct g_list GENERIC_LIST;
typedef int Function();
struct bucket_contents {
   struct bucket_contents *next ;
   char *key ;
   char *data ;
   int times_found ;
};
typedef struct bucket_contents BUCKET_CONTENTS;
struct hash_table {
   BUCKET_CONTENTS **bucket_array ;
   int nbuckets ;
   int nentries ;
};
typedef struct hash_table HASH_TABLE;
struct variable;
struct variable;
typedef struct variable *DYNAMIC_FUNC();
struct variable {
   char *name ;
   char *value ;
   char *exportstr ;
   DYNAMIC_FUNC *dynamic_value ;
   DYNAMIC_FUNC *assign_func ;
   int attributes ;
   int context ;
   struct variable *prev_context ;
};
typedef struct variable SHELL_VAR;
struct user_info {
   uid_t uid ;
   uid_t euid ;
   gid_t gid ;
   gid_t egid ;
   char *user_name ;
   char *shell ;
   char *home_dir ;
};
struct builtin {
   char *name ;
   Function *function ;
   int flags ;
   char **long_doc ;
   char *short_doc ;
   char *handle ;
};
enum stream_type {
    st_none = 0,
    st_stdin = 1,
    st_stream = 2,
    st_string = 3,
    st_bstream = 4
} ;
union __anonunion_INPUT_STREAM_72 {
   FILE *file ;
   char *string ;
   int buffered_fd ;
};
typedef union __anonunion_INPUT_STREAM_72 INPUT_STREAM;
struct __anonstruct_BASH_INPUT_73 {
   enum stream_type type ;
   char *name ;
   INPUT_STREAM location ;
   Function *getter ;
   Function *ungetter ;
};
typedef struct __anonstruct_BASH_INPUT_73 BASH_INPUT;
struct __anonstruct_long_args_74 {
   char *name ;
   int type ;
   int *int_value ;
   char **char_value ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef void SigHandler();
typedef int __pid_t;
typedef __pid_t pid_t;
struct element {
   WORD_DESC *word ;
   REDIRECT *redirect ;
};
typedef struct element ELEMENT;
typedef struct cond_com COND_COM;
struct __anonstruct_STRING_INT_ALIST_69 {
   char *word ;
   int token ;
};
typedef struct __anonstruct_STRING_INT_ALIST_69 STRING_INT_ALIST;
struct BSTREAM {
   int b_fd ;
   char *b_buffer ;
   size_t b_size ;
   int b_used ;
   int b_flag ;
   int b_inputp ;
};
typedef struct BSTREAM BUFFERED_STREAM;
struct dstack {
   char *delimiters ;
   int delimiter_depth ;
   int delimiter_space ;
};
struct alias {
   char *name ;
   char *value ;
   char flags ;
};
typedef struct alias alias_t;
union __anonunion_YYSTYPE_75 {
   WORD_DESC *word ;
   int number ;
   WORD_LIST *word_list ;
   COMMAND *command ;
   REDIRECT *redirect ;
   ELEMENT element ;
   PATTERN_LIST *pattern ;
};
typedef union __anonunion_YYSTYPE_75 YYSTYPE;
struct stream_saver {
   struct stream_saver *next ;
   BASH_INPUT bash_input ;
   int line ;
   BUFFERED_STREAM *bstream ;
};
typedef struct stream_saver STREAM_SAVER;
struct string_saver {
   struct string_saver *next ;
   int expand_alias ;
   char *saved_line ;
   alias_t *expander ;
   int saved_line_size ;
   int saved_line_index ;
   int saved_line_terminator ;
};
typedef struct string_saver STRING_SAVER;
typedef unsigned long __rlim_t;
typedef __rlim_t rlim_t;
typedef char *CPFunction();
typedef char *tilde_hook_func_t(char * );
typedef struct connection CONNECTION;
typedef struct case_com CASE_COM;
typedef struct for_com FOR_COM;
typedef struct arith_for_com ARITH_FOR_COM;
typedef struct if_com IF_COM;
typedef struct while_com WHILE_COM;
typedef struct arith_com ARITH_COM;
typedef struct simple_com SIMPLE_COM;
typedef struct function_def FUNCTION_DEF;
typedef struct group_com GROUP_COM;
typedef struct subshell_com SUBSHELL_COM;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef struct select_com SELECT_COM;
typedef void VFunction();
typedef long __suseconds_t;
typedef struct _IO_FILE _IO_FILE;
typedef __sigset_t sigset_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
union __anonunion____missing_field_name_56 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
union __anonunion____missing_field_name_57 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
union __anonunion____missing_field_name_58 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
union __anonunion____missing_field_name_59 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
union __anonunion____missing_field_name_60 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
union __anonunion____missing_field_name_61 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
union __anonunion____missing_field_name_62 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
union __anonunion____missing_field_name_63 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
union __anonunion____missing_field_name_64 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
union __anonunion____missing_field_name_65 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
union __anonunion____missing_field_name_66 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
union __anonunion____missing_field_name_67 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
union __anonunion____missing_field_name_68 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
union __anonunion____missing_field_name_69 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_56 __annonCompField4 ;
   union __anonunion____missing_field_name_57 __annonCompField5 ;
   union __anonunion____missing_field_name_58 __annonCompField6 ;
   union __anonunion____missing_field_name_59 __annonCompField7 ;
   union __anonunion____missing_field_name_60 __annonCompField8 ;
   union __anonunion____missing_field_name_61 __annonCompField9 ;
   union __anonunion____missing_field_name_62 __annonCompField10 ;
   union __anonunion____missing_field_name_63 __annonCompField11 ;
   union __anonunion____missing_field_name_64 __annonCompField12 ;
   union __anonunion____missing_field_name_65 __annonCompField13 ;
   union __anonunion____missing_field_name_66 __annonCompField14 ;
   union __anonunion____missing_field_name_67 __annonCompField15 ;
   union __anonunion____missing_field_name_68 __annonCompField16 ;
   union __anonunion____missing_field_name_69 __annonCompField17 ;
};
typedef int __rusage_who_t;
union __anonunion_UWP_71 {
   char *s ;
   int i ;
};
typedef union __anonunion_UWP_71 UWP;
struct fd_bitmap {
   long size ;
   char *bitmap ;
};
typedef int WAIT;
struct process {
   struct process *next ;
   pid_t pid ;
   WAIT status ;
   int running ;
   char *command ;
};
typedef struct process PROCESS;
enum __anonenum_JOB_STATE_73 {
    JRUNNING = 0,
    JSTOPPED = 1,
    JDEAD = 2,
    JMIXED = 3
} ;
typedef enum __anonenum_JOB_STATE_73 JOB_STATE;
struct job {
   char *wd ;
   PROCESS *pipe ;
   pid_t pgrp ;
   JOB_STATE state ;
   int flags ;
   COMMAND *deferred ;
   VFunction *j_cleanup ;
   void *cleanarg ;
};
typedef struct job JOB;
typedef int arrayind_t;
enum atype {
    array_indexed = 0,
    array_assoc = 1
} ;
struct array_element;
struct array_element;
struct array {
   enum atype type ;
   arrayind_t max_index ;
   arrayind_t num_elements ;
   arrayind_t max_size ;
   struct array_element *head ;
};
typedef struct array ARRAY;
struct array_element {
   arrayind_t ind ;
   char *value ;
   struct array_element *next ;
   struct array_element *prev ;
};
typedef struct array_element ARRAY_ELEMENT;
struct _list_of_strings {
   char **list ;
   int list_size ;
   int list_len ;
};
typedef struct _list_of_strings STRINGLIST;
struct _list_of_items {
   int flags ;
   Function *list_getter ;
   STRINGLIST *slist ;
   STRINGLIST *genlist ;
   int genindex ;
};
typedef struct _list_of_items ITEMLIST;
struct name_and_function {
   char *name ;
   VFunction *function ;
};
struct __anonstruct_EXPR_CONTEXT_46 {
   int curtok ;
   int lasttok ;
   char *expression ;
   char *tp ;
   char *lasttp ;
   int tokval ;
   char *tokstr ;
   int noeval ;
};
typedef struct __anonstruct_EXPR_CONTEXT_46 EXPR_CONTEXT;
struct flags_alist {
   char name ;
   int *value ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct __anonstruct_PATH_DATA_41 {
   char *path ;
   int flags ;
};
typedef struct __anonstruct_PATH_DATA_41 PATH_DATA;
typedef __off_t off_t;
struct __anonstruct_FILEINFO_71 {
   char *name ;
   char *msg ;
   time_t access_time ;
   time_t mod_time ;
   off_t file_size ;
};
typedef struct __anonstruct_FILEINFO_71 FILEINFO;
struct _uwp {
   struct _uwp *next ;
   Function *cleanup ;
   char *arg ;
};
typedef struct _uwp UNWIND_ELT;
struct __anonstruct_SAVED_VAR_41 {
   int *variable ;
   char *desired_setting ;
   int size ;
};
typedef struct __anonstruct_SAVED_VAR_41 SAVED_VAR;
struct ign {
   char *val ;
   int len ;
   int flags ;
};
struct ignorevar {
   char *varname ;
   struct ign *ignores ;
   int num_ignores ;
   char *last_ignoreval ;
   Function *item_func ;
};
typedef unsigned int __uint32_t;
typedef long __clock_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_26 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_31 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_30 {
   struct __anonstruct__addr_bnd_31 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_29 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_30 _bounds ;
};
struct __anonstruct__sigpoll_32 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_33 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_24 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_25 _kill ;
   struct __anonstruct__timer_26 _timer ;
   struct __anonstruct__rt_27 _rt ;
   struct __anonstruct__sigchld_28 _sigchld ;
   struct __anonstruct__sigfault_29 _sigfault ;
   struct __anonstruct__sigpoll_32 _sigpoll ;
   struct __anonstruct__sigsys_33 _sigsys ;
};
struct __anonstruct_siginfo_t_23 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_24 _sifields ;
};
typedef struct __anonstruct_siginfo_t_23 siginfo_t;
union __anonunion___sigaction_handler_44 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_44 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct termsig {
   int signum ;
   SigHandler *orig_handler ;
};
typedef char *rl_compentry_func_t(char const   * , int  );
typedef char **rl_completion_func_t(char const   * , int  , int  );
typedef char *rl_quote_func_t(char * , int  , char * );
typedef int rl_compignore_func_t(char ** );
typedef int rl_linebuf_func_t(char * , int  );
typedef void *histdata_t;
struct _hist_entry {
   char *line ;
   histdata_t data ;
};
typedef struct _hist_entry HIST_ENTRY;
typedef int rl_command_func_t(int  , int  );
typedef char *rl_dequote_func_t(char * , int  );
typedef int rl_hook_func_t(void);
typedef int rl_icppfunc_t(char ** );
struct _keymap_entry {
   char type ;
   rl_command_func_t *function ;
};
typedef struct _keymap_entry KEYMAP_ENTRY;
typedef KEYMAP_ENTRY KEYMAP_ENTRY_ARRAY[256];
typedef KEYMAP_ENTRY *Keymap;
enum undo_code {
    UNDO_DELETE = 0,
    UNDO_INSERT = 1,
    UNDO_BEGIN = 2,
    UNDO_END = 3
} ;
struct compspec {
   int refcount ;
   unsigned long actions ;
   unsigned long options ;
   char *globpat ;
   char *words ;
   char *prefix ;
   char *suffix ;
   char *funcname ;
   char *command ;
   char *filterpat ;
};
typedef struct compspec COMPSPEC;
typedef SHELL_VAR **SVFUNC();
typedef long __intptr_t;
typedef __intptr_t intptr_t;
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-TEQ7WvMa.i","-g")
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
extern void endpwent(void) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
sigjmp_buf top_level  ;
sigjmp_buf subshell_top_level  ;
COMMAND *global_command ;
char *xmalloc(size_t bytes ) ;
int sh_unset_nodelay_mode(int fd ) ;
void check_dev_tty(void) ;
int move_to_high_fd(int fd , int check_new , int maxfd ) ;
int check_binary_file(unsigned char *sample , int sample_len ) ;
int absolute_program(char *string ) ;
char *base_pathname(char *string ) ;
void tilde_initialize(void) ;
void file_error(char *filename ) ;
void report_error(char const   *format  , ...) ;
void internal_error(char const   *format  , ...) ;
void command_error(char const   *func , int code , int e , int flags ) ;
HASH_TABLE *shell_variables ;
HASH_TABLE *shell_functions ;
char *dollar_vars[10]  ;
void initialize_shell_variables(char **env , int privmode ) ;
SHELL_VAR *find_variable(char *name ) ;
SHELL_VAR *bind_variable(char *name , char *value ) ;
char *get_string_value(char const   *var_name ) ;
int makunbound(char *name , HASH_TABLE *hash_list ) ;
void delete_all_variables(HASH_TABLE *hashed_vars ) ;
void set_var_read_only(char *name ) ;
void sv_strict_posix(char *name ) ;
void dispose_words(WORD_LIST *list___0 ) ;
WORD_LIST *make_word_list(WORD_DESC *word , WORD_LIST *link___0 ) ;
WORD_DESC *make_word(char *string ) ;
char *string_list(WORD_LIST *list___0 ) ;
WORD_LIST *expand_string_unsplit(char *string , int quoted ) ;
WORD_LIST *expand_words_no_vars(WORD_LIST *list___0 ) ;
void unlink_fifo_list(void) ;
void initialize_signals(void) ;
void exit_shell(int s ) ;
void disable_priv_mode(void) ;
void unbind_args(void) ;
int shell_is_restricted(char *name ) ;
int maybe_make_restricted(char *name ) ;
void unset_bash_input(int check_zero ) ;
void get_current_user_info(void) ;
int reader_loop(void) ;
int parse_command(void) ;
char *shell_version_string(void) ;
void show_shell_version(int extended ) ;
void set_default_locale(void) ;
void set_default_locale_vars(void) ;
GENERIC_LIST *reverse_list(GENERIC_LIST *list___0 ) ;
char **shell_environment  ;
int executing ;
int login_shell ;
struct user_info current_user ;
int exit_immediately_on_error ;
int read_but_dont_execute ;
int echo_input_at_read ;
int forced_interactive ;
int privileged_mode ;
int restricted ;
int restricted_shell ;
int change_flag(int flag , int on_or_off ) ;
void initialize_traps(void) ;
int run_exit_trap(void) ;
int signal_is_trapped(int sig ) ;
void reset_mail_timer(void) ;
void remember_mail_dates(void) ;
extern struct builtin *shell_builtins ;
extern void remember_args(WORD_LIST * , int  ) ;
extern void initialize_shell_builtins(void) ;
extern void initialize_shell_options(int  ) ;
extern void list_minus_o_opts(int  , int  ) ;
extern int set_minus_o_option(int  , char * ) ;
extern int parse_and_execute(char * , char * , int  ) ;
extern int maybe_execute_file(char * , int  ) ;
void hangup_all_jobs(void) ;
int get_tty_state(void) ;
int initialize_job_control(int force ) ;
int set_job_control(int arg ) ;
void end_job_control(void) ;
int default_buffered_input ;
BASH_INPUT bash_input  ;
void initialize_bash_input(void) ;
void with_input_from_stdin(void) ;
void with_input_from_string(char *string , char *name ) ;
void with_input_from_stream(FILE *stream , char *name ) ;
int close_buffered_fd(int fd ) ;
void with_input_from_buffered_stream(int bfd , char *name ) ;
char *find_path_file(char *name ) ;
void bash_initialize_history(void) ;
void bash_history_reinit(int interact ) ;
void load_history(void) ;
int maybe_save_shell_history(void) ;
extern int fnmatch(char * , char * , int  ) ;
int shell_level ;
int subshell_environment  ;
int last_command_exit_value  ;
int line_number ;
char *primary_prompt ;
char *secondary_prompt ;
int expand_aliases ;
char *this_command_name  ;
int shell_initialized  =    0;
COMMAND *global_command  =    (COMMAND *)((void *)0);
struct user_info current_user  =    {(uid_t )-1, (uid_t )-1, (gid_t )-1, (gid_t )-1, (char *)((void *)0), (char *)((void *)0),
    (char *)((void *)0)};
char *current_host_name  =    (char *)((void *)0);
int login_shell  =    0;
int interactive  =    0;
int interactive_shell  =    0;
int hup_on_exit  =    0;
int startup_state  =    0;
int debugging_login_shell  =    0;
int executing  =    0;
int current_command_number  =    1;
int indirection_level  =    0;
char *shell_name  =    (char *)((void *)0);
time_t shell_start_time  ;
int running_under_emacs  ;
static char *bashrc_file  =    (char *)"~/.bashrc";
static int act_like_sh  ;
static int su_shell  ;
static int sourced_env  ;
static int running_setuid  ;
static int debugging  ;
static int no_rc  ;
static int no_profile  ;
static int do_version  ;
static int make_login_shell  ;
static int want_initial_help  ;
int no_line_editing  =    0;
int posixly_correct  =    0;
int dump_translatable_strings  ;
int dump_po_strings  ;
int wordexp_only  =    0;
struct __anonstruct_long_args_74 long_args[16]  = 
  {      {(char *)"debug", 1, & debugging, (char **)0}, 
        {(char *)"dump-po-strings", 1, & dump_po_strings, (char **)0}, 
        {(char *)"dump-strings", 1, & dump_translatable_strings, (char **)0}, 
        {(char *)"help", 1, & want_initial_help, (char **)0}, 
        {(char *)"init-file", 2, (int *)0, & bashrc_file}, 
        {(char *)"login", 1, & make_login_shell, (char **)0}, 
        {(char *)"noediting", 1, & no_line_editing, (char **)0}, 
        {(char *)"noprofile", 1, & no_profile, (char **)0}, 
        {(char *)"norc", 1, & no_rc, (char **)0}, 
        {(char *)"posix", 1, & posixly_correct, (char **)0}, 
        {(char *)"rcfile", 2, (int *)0, & bashrc_file}, 
        {(char *)"restricted", 1, & restricted, (char **)0}, 
        {(char *)"verbose", 1, & echo_input_at_read, (char **)0}, 
        {(char *)"version", 1, & do_version, (char **)0}, 
        {(char *)"wordexp", 1, & wordexp_only, (char **)0}, 
        {(char *)0, 1, (int *)0, (char **)0}};
int subshell_argc  ;
char **subshell_argv  ;
char **subshell_envp  ;
int default_buffered_input  =    -1;
int read_from_stdin  ;
int want_pending_command  ;
static int shell_reinitialized  =    0;
static char *local_pending_command  ;
static FILE *default_input  ;
static int parse_long_options(char **argv___0 , int arg_start , int arg_end ) ;
static int parse_shell_options(char **argv___0 , int arg_start , int arg_end ) ;
static void run_startup_files(void) ;
static int bind_args(char **argv___0 , int arg_start , int arg_end , int start_index ) ;
static int open_shell_script(char *script_name ) ;
static void set_bash_input(void) ;
static int run_one_command(char *command ) ;
static int run_wordexp(char *words ) ;
static int uidget(void) ;
static int isnetconn(int fd ) ;
static void init_interactive(void) ;
static void init_noninteractive(void) ;
static void set_shell_name(char *argv0 ) ;
static void shell_initialize(void) ;
static void shell_reinitialize(void) ;
static void show_shell_usage(FILE *fp , int extra ) ;
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
int main(int argc___0 , char **argv___0 , char **env ) 
{ 
  register int i ;
  int code ;
  int saverst ;
  int old_errexit_flag ;
  int volatile   locally_skip_execution ;
  int volatile   arg_index ;
  int volatile   top_level_arg_index ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *term___0 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  time_t tmp___18 ;

  {
  {
  code = __sigsetjmp(top_level, 1);
  }
  if (code) {
    {
    exit(2);
    }
  }
  {
  check_dev_tty();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! debugging_login_shell) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  set_default_locale();
  running_setuid = uidget();
  tmp = getenv("POSIXLY_CORRECT");
  }
  if (tmp) {
    posixly_correct = 1;
  } else {
    {
    tmp___0 = getenv("POSIX_PEDANTIC");
    }
    if (tmp___0) {
      posixly_correct = 1;
    }
  }
  {
  tmp___1 = __sigsetjmp(subshell_top_level, 1);
  }
  if (tmp___1) {
    argc___0 = subshell_argc;
    argv___0 = subshell_argv;
    env = subshell_envp;
    sourced_env = 0;
  }
  shell_reinitialized = 0;
  arg_index = (int volatile   )1;
  local_pending_command = (char *)((void *)0);
  read_from_stdin = 0;
  locally_skip_execution = (int volatile   )read_from_stdin;
  want_pending_command = (int )locally_skip_execution;
  default_input = stdin;
  default_buffered_input = -1;
  make_login_shell = 0;
  login_shell = make_login_shell;
  if (shell_initialized) {
    goto _L;
  } else { //Added block
  if (shell_name) {
    _L: 
    if ((int )*shell_name == 45) {
      shell_name ++;
    }
    {
    shell_reinitialize();
    tmp___2 = __sigsetjmp(top_level, 1);
    }
    if (tmp___2) {
      {
      exit(2);
      }
    }
  }
  }
  {
  shell_environment = env;
  set_shell_name(*(argv___0 + 0));
  tmp___18 = time((time_t *)0);
  tmp___3 = (int )tmp___18;
  shell_start_time = (time_t )tmp___3;
  tmp___4 = parse_long_options(argv___0, (int )arg_index, argc___0);
  arg_index = (int volatile   )tmp___4;
  }
  if (want_initial_help) {
    {
    show_shell_usage(stdout, 1);
    exit(0);
    }
  }
  if (do_version) {
    {
    show_shell_version(1);
    exit(0);
    }
  }
  if (make_login_shell) {
    login_shell ++;
    login_shell = - login_shell;
  }
  {
  this_command_name = shell_name;
  tmp___5 = parse_shell_options(argv___0, (int )arg_index, argc___0);
  arg_index = (int volatile   )tmp___5;
  }
  if (dump_po_strings) {
    dump_translatable_strings = 1;
  }
  if (dump_translatable_strings) {
    read_but_dont_execute = 1;
  }
  if (running_setuid) {
    if (privileged_mode == 0) {
      {
      disable_priv_mode();
      }
    }
  }
  if (want_pending_command) {
    local_pending_command = *(argv___0 + arg_index);
    if ((unsigned long )local_pending_command == (unsigned long )((char *)0)) {
      {
      report_error("option `-c\' requires an argument");
      exit(258);
      }
    }
    arg_index += (int volatile   )1;
  }
  this_command_name = (char *)((void *)0);
  if (forced_interactive) {
    {
    init_interactive();
    }
  } else { //Added block
  if (! local_pending_command) {
    if (wordexp_only == 0) {
      if (arg_index == (int volatile   )argc___0) {
        goto _L___0;
      } else { //Added block
      if (read_from_stdin) {
        _L___0: 
        {
        tmp___6 = fileno(stdin);
        tmp___7 = isatty(tmp___6);
        }
        if (tmp___7) {
          {
          tmp___8 = fileno(stdout);
          tmp___9 = isatty(tmp___8);
          }
          if (tmp___9) {
            {
            init_interactive();
            }
          } else {
            {
            init_noninteractive();
            }
          }
        } else {
          {
          init_noninteractive();
          }
        }
      } else {
        {
        init_noninteractive();
        }
      }
      }
    } else {
      {
      init_noninteractive();
      }
    }
  } else {
    {
    init_noninteractive();
    }
  }
  }
  if (login_shell) {
    if (interactive_shell) {
      i = 3;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i < 20)) {
          goto while_break___0;
        }
        {
        close(i);
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  if (posixly_correct) {
    {
    bind_variable((char *)"POSIXLY_CORRECT", (char *)"y");
    sv_strict_posix((char *)"POSIXLY_CORRECT");
    }
  }
  {
  shell_initialize();
  set_default_locale_vars();
  }
  if (interactive_shell) {
    {
    term___0 = getenv("TERM");
    }
    if (term___0) {
      if ((int )*(term___0 + 0) == (int )*("emacs" + 0)) {
        {
        tmp___10 = strcmp((char const   *)term___0, "emacs");
        }
        if (tmp___10 == 0) {
          tmp___11 = 1;
        } else {
          tmp___11 = 0;
        }
      } else {
        tmp___11 = 0;
      }
    } else {
      tmp___11 = 0;
    }
    {
    no_line_editing |= tmp___11;
    term___0 = getenv("EMACS");
    }
    if (term___0) {
      {
      tmp___14 = fnmatch((char *)"*term*", term___0, 0);
      }
      if (tmp___14 == 0) {
        tmp___13 = 2;
      } else {
        tmp___13 = 1;
      }
      running_under_emacs = tmp___13;
    } else {
      running_under_emacs = 0;
    }
  }
  {
  top_level_arg_index = arg_index;
  old_errexit_flag = exit_immediately_on_error;
  code = __sigsetjmp(top_level, 1);
  }
  if (code) {
    if (code == 3) {
      {
      exit_shell(last_command_exit_value);
      }
    } else {
      {
      set_job_control(interactive_shell);
      exit_immediately_on_error += old_errexit_flag;
      locally_skip_execution += (int volatile   )1;
      }
    }
  }
  arg_index = top_level_arg_index;
  if (interactive_shell == 0) {
    {
    makunbound((char *)"PS1", shell_variables);
    makunbound((char *)"PS2", shell_variables);
    interactive = 0;
    expand_aliases = posixly_correct;
    }
  } else {
    {
    change_flag('i', '-');
    interactive = 1;
    }
  }
  {
  restricted_shell = shell_is_restricted(shell_name);
  saverst = restricted;
  restricted = 0;
  }
  if (locally_skip_execution == (int volatile   )0) {
    if (running_setuid == 0) {
      {
      old_errexit_flag = exit_immediately_on_error;
      exit_immediately_on_error = 0;
      run_startup_files();
      exit_immediately_on_error += old_errexit_flag;
      }
    }
  }
  if (act_like_sh) {
    {
    bind_variable((char *)"POSIXLY_CORRECT", (char *)"y");
    sv_strict_posix((char *)"POSIXLY_CORRECT");
    }
  }
  if (saverst) {
    tmp___15 = 1;
  } else { //Added block
  if (restricted) {
    tmp___15 = 1;
  } else {
    tmp___15 = 0;
  }
  }
  restricted = tmp___15;
  if (shell_reinitialized == 0) {
    {
    maybe_make_restricted(shell_name);
    }
  }
  if (wordexp_only) {
    {
    startup_state = 3;
    last_command_exit_value = run_wordexp(*(argv___0 + arg_index));
    exit_shell(last_command_exit_value);
    }
  }
  if (local_pending_command) {
    {
    tmp___16 = bind_args(argv___0, (int )arg_index, argc___0, 0);
    arg_index = (int volatile   )tmp___16;
    startup_state = 2;
    run_one_command(local_pending_command);
    exit_shell(last_command_exit_value);
    }
  }
  if (arg_index != (int volatile   )argc___0) {
    if (read_from_stdin == 0) {
      {
      open_shell_script(*(argv___0 + arg_index));
      arg_index += (int volatile   )1;
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (interactive == 0) {
    {
    default_buffered_input = fileno(stdin);
    }
  }
  }
  {
  set_bash_input();
  tmp___17 = bind_args(argv___0, (int )arg_index, argc___0, 1);
  arg_index = (int volatile   )tmp___17;
  }
  if (interactive_shell) {
    {
    remember_mail_dates();
    reset_mail_timer();
    bash_initialize_history();
    }
    if (shell_initialized == 0) {
      {
      load_history();
      }
    }
    {
    get_tty_state();
    }
  }
  {
  shell_initialized = 1;
  reader_loop();
  exit_shell(last_command_exit_value);
  }
  return (0);
}
}
static int parse_long_options(char **argv___0 , int arg_start , int arg_end ) 
{ 
  int arg_index ;
  int longarg ;
  int i ;
  char *arg_string ;
  int tmp ;

  {
  arg_index = arg_start;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (arg_index != arg_end) {
      arg_string = *(argv___0 + arg_index);
      if (arg_string) {
        if (! ((int )*arg_string == 45)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    longarg = 0;
    if ((int )*(arg_string + 1) == 45) {
      if (*(arg_string + 2)) {
        longarg = 1;
        arg_string ++;
      }
    }
    i = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! long_args[i].name) {
        goto while_break___0;
      }
      if ((int )*((arg_string + 1) + 0) == (int )*(long_args[i].name + 0)) {
        {
        tmp = strcmp((char const   *)(arg_string + 1), (char const   *)long_args[i].name);
        }
        if (tmp == 0) {
          if (long_args[i].type == 1) {
            *(long_args[i].int_value) = 1;
          } else {
            arg_index ++;
            if ((unsigned long )*(argv___0 + arg_index) == (unsigned long )((char *)0)) {
              {
              report_error("option `%s\' requires an argument", long_args[i].name);
              exit(258);
              }
            } else {
              *(long_args[i].char_value) = *(argv___0 + arg_index);
            }
          }
          goto while_break___0;
        }
      }
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )long_args[i].name == (unsigned long )((char *)0)) {
      if (longarg) {
        {
        report_error("%s: unrecognized option", *(argv___0 + arg_index));
        show_shell_usage(stderr, 0);
        exit(258);
        }
      }
      goto while_break;
    }
    arg_index ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (arg_index);
}
}
static int parse_shell_options(char **argv___0 , int arg_start , int arg_end ) 
{ 
  int arg_index ;
  int arg_character ;
  int on_or_off ;
  int next_arg ;
  int i ;
  char *o_option ;
  char *arg_string ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  arg_index = arg_start;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (arg_index != arg_end) {
      arg_string = *(argv___0 + arg_index);
      if (arg_string) {
        if (! ((int )*arg_string == 45)) {
          if (! ((int )*arg_string == 43)) {
            goto while_break;
          }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    next_arg = arg_index + 1;
    if ((int )*(arg_string + 0) == 45) {
      if ((int )*(arg_string + 1) == 0) {
        return (next_arg);
      } else { //Added block
      if ((int )*(arg_string + 1) == 45) {
        if ((int )*(arg_string + 2) == 0) {
          return (next_arg);
        }
      }
      }
    }
    i = 1;
    on_or_off = (int )*(arg_string + 0);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      tmp___2 = i;
      i ++;
      arg_character = (int )*(arg_string + tmp___2);
      if (! arg_character) {
        goto while_break___0;
      }
      {
      if (arg_character == 99) {
        goto case_99;
      }
      if (arg_character == 115) {
        goto case_115;
      }
      if (arg_character == 111) {
        goto case_111;
      }
      if (arg_character == 68) {
        goto case_68;
      }
      goto switch_default;
      case_99: /* CIL Label */ 
      want_pending_command = 1;
      goto switch_break;
      case_115: /* CIL Label */ 
      read_from_stdin = 1;
      goto switch_break;
      case_111: /* CIL Label */ 
      o_option = *(argv___0 + next_arg);
      if ((unsigned long )o_option == (unsigned long )((char *)0)) {
        if (on_or_off == 45) {
          tmp = 0;
        } else {
          tmp = 1;
        }
        {
        list_minus_o_opts(-1, tmp);
        }
        goto switch_break;
      }
      {
      tmp___0 = set_minus_o_option(on_or_off, o_option);
      }
      if (tmp___0 != 0) {
        {
        exit(258);
        }
      }
      next_arg ++;
      goto switch_break;
      case_68: /* CIL Label */ 
      dump_translatable_strings = 1;
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      tmp___1 = change_flag(arg_character, on_or_off);
      }
      if (tmp___1 == -1) {
        {
        report_error("%c%c: unrecognized option", on_or_off, arg_character);
        show_shell_usage(stderr, 0);
        exit(258);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    arg_index = next_arg;
  }
  while_break: /* CIL Label */ ;
  }
  return (arg_index);
}
}
void exit_shell(int s ) 
{ 
  int tmp ;

  {
  {
  tmp = signal_is_trapped(0);
  }
  if (tmp) {
    {
    s = run_exit_trap();
    }
  }
  {
  unlink_fifo_list();
  }
  if (interactive_shell) {
    {
    maybe_save_shell_history();
    }
  }
  if (interactive_shell) {
    if (login_shell) {
      if (hup_on_exit) {
        {
        hangup_all_jobs();
        }
      }
    }
  }
  if (subshell_environment == 0) {
    {
    end_job_control();
    }
  }
  {
  exit(s);
  }
}
}
void sh_exit(int s ) 
{ 


  {
  {
  exit(s);
  }
}
}
static void execute_env_file(char *env_file ) 
{ 
  char *fn ;
  WORD_LIST *list___0 ;

  {
  if (env_file) {
    if (*env_file) {
      {
      list___0 = expand_string_unsplit(env_file, 1);
      }
      if (list___0) {
        {
        fn = string_list(list___0);
        dispose_words(list___0);
        }
        if (fn) {
          if (*fn) {
            {
            maybe_execute_file(fn, 1);
            }
          }
        }
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (fn) {
            {
            free((void *)fn);
            }
          }
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  return;
}
}
static void run_startup_files(void) 
{ 
  int old_job_control ;
  int sourced_login ;
  int run_by_ssh ;
  SHELL_VAR *tmp ;
  SHELL_VAR *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
  if (interactive_shell == 0) {
    if (no_rc == 0) {
      if (login_shell == 0) {
        if (act_like_sh == 0) {
          if (local_pending_command) {
            {
            tmp = find_variable((char *)"SSH_CLIENT");
            run_by_ssh = (unsigned long )tmp != (unsigned long )((SHELL_VAR *)0);
            tmp___0 = find_variable((char *)"SSH2_CLIENT");
            run_by_ssh |= (unsigned long )tmp___0 != (unsigned long )((SHELL_VAR *)0);
            }
            if (run_by_ssh) {
              goto _L;
            } else {
              {
              tmp___1 = fileno(stdin);
              tmp___2 = isnetconn(tmp___1);
              }
              if (tmp___2) {
                _L: 
                if (shell_level < 2) {
                  {
                  maybe_execute_file(bashrc_file, 1);
                  }
                  return;
                }
              }
            }
          }
        }
      }
    }
  }
  if (interactive_shell) {
    {
    tmp___3 = set_job_control(0);
    old_job_control = tmp___3;
    }
  } else {
    old_job_control = 0;
  }
  sourced_login = 0;
  if (login_shell < 0) {
    if (posixly_correct == 0) {
      no_rc ++;
      if (no_profile == 0) {
        {
        maybe_execute_file((char *)"/etc/profile", 1);
        }
        if (act_like_sh) {
          {
          maybe_execute_file((char *)"~/.profile", 1);
          }
        } else {
          {
          tmp___4 = maybe_execute_file((char *)"~/.bash_profile", 1);
          }
          if (tmp___4 == 0) {
            {
            tmp___5 = maybe_execute_file((char *)"~/.bash_login", 1);
            }
            if (tmp___5 == 0) {
              {
              maybe_execute_file((char *)"~/.profile", 1);
              }
            }
          }
        }
      }
      sourced_login = 1;
    }
  }
  if (interactive_shell == 0) {
    if (su_shell) {
      if (! login_shell) {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (posixly_correct == 0) {
        if (act_like_sh == 0) {
          if (privileged_mode == 0) {
            tmp___7 = sourced_env;
            sourced_env ++;
            if (tmp___7 == 0) {
              {
              tmp___6 = get_string_value("BASH_ENV");
              execute_env_file(tmp___6);
              }
            }
          }
        }
      }
      return;
    }
  }
  if (posixly_correct == 0) {
    if (login_shell) {
      tmp___10 = sourced_login;
      sourced_login ++;
      if (tmp___10 == 0) {
        no_rc ++;
        if (no_profile == 0) {
          {
          maybe_execute_file((char *)"/etc/profile", 1);
          }
          if (act_like_sh) {
            {
            maybe_execute_file((char *)"~/.profile", 1);
            }
          } else {
            {
            tmp___8 = maybe_execute_file((char *)"~/.bash_profile", 1);
            }
            if (tmp___8 == 0) {
              {
              tmp___9 = maybe_execute_file((char *)"~/.bash_login", 1);
              }
              if (tmp___9 == 0) {
                {
                maybe_execute_file((char *)"~/.profile", 1);
                }
              }
            }
          }
        }
      }
    }
    if (act_like_sh == 0) {
      if (no_rc == 0) {
        {
        maybe_execute_file(bashrc_file, 1);
        }
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (act_like_sh) {
      if (privileged_mode == 0) {
        tmp___12 = sourced_env;
        sourced_env ++;
        if (tmp___12 == 0) {
          {
          tmp___11 = get_string_value("ENV");
          execute_env_file(tmp___11);
          }
        }
      }
    }
    }
  } else { //Added block
  if (interactive_shell) {
    if (privileged_mode == 0) {
      tmp___14 = sourced_env;
      sourced_env ++;
      if (tmp___14 == 0) {
        {
        tmp___13 = get_string_value("ENV");
        execute_env_file(tmp___13);
        }
      }
    }
  }
  }
  {
  set_job_control(old_job_control);
  }
  return;
}
}
int shell_is_restricted(char *name ) 
{ 
  char *temp___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if (restricted) {
    return (1);
  }
  {
  temp___0 = base_pathname(name);
  }
  if ((int )*(temp___0 + 0) == (int )*("rbash" + 0)) {
    {
    tmp = strcmp((char const   *)temp___0, "rbash");
    }
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int maybe_make_restricted(char *name ) 
{ 
  char *temp___0 ;
  int tmp ;

  {
  {
  temp___0 = base_pathname(shell_name);
  }
  if (restricted) {
    {
    set_var_read_only((char *)"PATH");
    set_var_read_only((char *)"SHELL");
    set_var_read_only((char *)"ENV");
    set_var_read_only((char *)"BASH_ENV");
    restricted = 1;
    }
  } else { //Added block
  if ((int )*(temp___0 + 0) == (int )*("rbash" + 0)) {
    {
    tmp = strcmp((char const   *)temp___0, "rbash");
    }
    if (tmp == 0) {
      {
      set_var_read_only((char *)"PATH");
      set_var_read_only((char *)"SHELL");
      set_var_read_only((char *)"ENV");
      set_var_read_only((char *)"BASH_ENV");
      restricted = 1;
      }
    }
  }
  }
  return (restricted);
}
}
static int uidget(void) 
{ 
  uid_t u ;
  int tmp ;

  {
  {
  u = getuid();
  }
  if (current_user.uid != u) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (current_user.user_name) {
        {
        free((void *)current_user.user_name);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (current_user.shell) {
        {
        free((void *)current_user.shell);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (current_user.home_dir) {
        {
        free((void *)current_user.home_dir);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    current_user.home_dir = (char *)((void *)0);
    current_user.shell = current_user.home_dir;
    current_user.user_name = current_user.shell;
  }
  {
  current_user.uid = u;
  current_user.gid = getgid();
  current_user.euid = geteuid();
  current_user.egid = getegid();
  }
  if (current_user.uid != current_user.euid) {
    tmp = 1;
  } else { //Added block
  if (current_user.gid != current_user.egid) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
void disable_priv_mode(void) 
{ 


  {
  {
  setuid(current_user.uid);
  setgid(current_user.gid);
  current_user.euid = current_user.uid;
  current_user.egid = current_user.gid;
  }
  return;
}
}
static int run_wordexp(char *words ) 
{ 
  int code ;
  int nw ;
  int nb ;
  WORD_LIST *wl ;
  WORD_LIST *result ;
  int tmp ;
  WORD_LIST *tmp___0 ;
  size_t tmp___1 ;

  {
  {
  code = __sigsetjmp(top_level, 1);
  }
  if (code != 0) {
    {
    if (code == 1) {
      goto case_1;
    }
    if (code == 3) {
      goto case_3;
    }
    if (code == 2) {
      goto case_2;
    }
    goto switch_default;
    case_1: /* CIL Label */ 
    last_command_exit_value = 127;
    return (last_command_exit_value);
    case_3: /* CIL Label */ 
    return (last_command_exit_value);
    case_2: /* CIL Label */ 
    last_command_exit_value = 1;
    return (last_command_exit_value);
    switch_default: /* CIL Label */ 
    {
    command_error("run_wordexp", 3, code, 0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  if (words) {
    if (*words) {
      {
      with_input_from_string(words, (char *)"--wordexp");
      tmp = parse_command();
      }
      if (tmp != 0) {
        return (126);
      }
      if ((unsigned long )global_command == (unsigned long )((COMMAND *)0)) {
        {
        printf((char const   * __restrict  )"0\n0\n");
        }
        return (0);
      }
      if ((unsigned int )global_command->type != 4U) {
        return (126);
      }
      wl = (global_command->value.Simple)->words;
      if (wl) {
        {
        tmp___0 = expand_words_no_vars(wl);
        result = tmp___0;
        }
      } else {
        result = (WORD_LIST *)0;
      }
    } else {
      result = (WORD_LIST *)0;
    }
  } else {
    result = (WORD_LIST *)0;
  }
  last_command_exit_value = 0;
  if ((unsigned long )result == (unsigned long )((WORD_LIST *)0)) {
    {
    printf((char const   * __restrict  )"0\n0\n");
    }
    return (0);
  }
  nb = 0;
  nw = nb;
  wl = result;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wl) {
      goto while_break;
    }
    {
    nw ++;
    tmp___1 = strlen((char const   *)(wl->word)->word);
    nb = (int )((size_t )nb + tmp___1);
    wl = wl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  printf((char const   * __restrict  )"%u\n%u\n", nw, nb);
  wl = result;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! wl) {
      goto while_break___0;
    }
    {
    printf((char const   * __restrict  )"%s\n", (wl->word)->word);
    wl = wl->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return (0);
}
}
static int run_one_command(char *command ) 
{ 
  int code ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
  code = __sigsetjmp(top_level, 1);
  }
  if (code != 0) {
    {
    unlink_fifo_list();
    }
    {
    if (code == 1) {
      goto case_1;
    }
    if (code == 3) {
      goto case_3;
    }
    if (code == 2) {
      goto case_2;
    }
    goto switch_default;
    case_1: /* CIL Label */ 
    last_command_exit_value = 127;
    return (last_command_exit_value);
    case_3: /* CIL Label */ 
    return (last_command_exit_value);
    case_2: /* CIL Label */ 
    last_command_exit_value = 1;
    return (last_command_exit_value);
    switch_default: /* CIL Label */ 
    {
    command_error("run_one_command", 3, code, 0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
  tmp = strlen((char const   *)command);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )command);
  tmp___2 = parse_and_execute(tmp___1, (char *)"-c", 4);
  }
  return (tmp___2);
}
}
static int bind_args(char **argv___0 , int arg_start , int arg_end , int start_index ) 
{ 
  register int i ;
  WORD_LIST *args ;
  WORD_DESC *tmp ;
  GENERIC_LIST *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  i = arg_start;
  args = (WORD_LIST *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i != arg_end)) {
      goto while_break;
    }
    {
    tmp = make_word(*(argv___0 + i));
    args = make_word_list(tmp, args);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (args) {
    if (args) {
      if (args->next) {
        {
        tmp___0 = reverse_list((GENERIC_LIST *)args);
        args = (WORD_LIST *)tmp___0;
        }
      } else {
        args = args;
      }
    } else {
      args = args;
    }
    if (start_index == 0) {
      {
      tmp___1 = strlen((char const   *)(args->word)->word);
      tmp___2 = xmalloc(1UL + tmp___1);
      tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )(args->word)->word);
      shell_name = tmp___3;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (dollar_vars[0]) {
          {
          free((void *)dollar_vars[0]);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      tmp___4 = strlen((char const   *)(args->word)->word);
      tmp___5 = xmalloc(1UL + tmp___4);
      tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )(args->word)->word);
      dollar_vars[0] = tmp___6;
      remember_args(args->next, 1);
      }
    } else {
      {
      remember_args(args, 1);
      }
    }
    {
    dispose_words(args);
    }
  }
  return (i);
}
}
void unbind_args(void) 
{ 


  {
  {
  remember_args((WORD_LIST *)((void *)0), 1);
  }
  return;
}
}
static int open_shell_script(char *script_name ) 
{ 
  int fd ;
  int e ;
  int fd_is_tty ;
  char *filename ;
  char *path_filename ;
  unsigned char sample[80] ;
  int sample_len ;
  struct stat sb ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  ssize_t tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  __off_t tmp___16 ;

  {
  {
  free((void *)dollar_vars[0]);
  tmp = strlen((char const   *)script_name);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )script_name);
  dollar_vars[0] = tmp___1;
  tmp___2 = strlen((char const   *)script_name);
  tmp___3 = xmalloc(1UL + tmp___2);
  tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )script_name);
  filename = tmp___4;
  fd = open((char const   *)filename, 0);
  }
  if (fd < 0) {
    {
    tmp___7 = __errno_location();
    }
    if (*tmp___7 == 2) {
      {
      tmp___8 = absolute_program(filename);
      }
      if (tmp___8 == 0) {
        {
        tmp___5 = __errno_location();
        e = *tmp___5;
        path_filename = find_path_file(script_name);
        }
        if (path_filename) {
          {
          free((void *)filename);
          filename = path_filename;
          fd = open((char const   *)filename, 0);
          }
        } else {
          {
          tmp___6 = __errno_location();
          *tmp___6 = e;
          }
        }
      }
    }
  }
  if (fd < 0) {
    {
    tmp___9 = __errno_location();
    e = *tmp___9;
    file_error(filename);
    }
    if (e == 2) {
      tmp___10 = 127;
    } else {
      tmp___10 = 126;
    }
    {
    exit(tmp___10);
    }
  }
  {
  fd_is_tty = isatty(fd);
  }
  if (fd_is_tty == 0) {
    {
    tmp___16 = lseek(fd, 0L, 1);
    }
    if (tmp___16 != -1L) {
      {
      tmp___11 = read(fd, (void *)(sample), sizeof(sample));
      sample_len = (int )tmp___11;
      }
      if (sample_len < 0) {
        {
        tmp___12 = __errno_location();
        e = *tmp___12;
        tmp___14 = fstat(fd, & sb);
        }
        if (tmp___14 == 0) {
          if ((sb.st_mode & 61440U) == 16384U) {
            {
            internal_error("%s: is a directory", filename);
            }
          } else {
            {
            tmp___13 = __errno_location();
            *tmp___13 = e;
            file_error(filename);
            }
          }
        } else {
          {
          tmp___13 = __errno_location();
          *tmp___13 = e;
          file_error(filename);
          }
        }
        {
        exit(126);
        }
      } else { //Added block
      if (sample_len > 0) {
        {
        tmp___15 = check_binary_file(sample, sample_len);
        }
        if (tmp___15) {
          {
          internal_error("%s: cannot execute binary file", filename);
          exit(126);
          }
        }
      }
      }
      {
      lseek(fd, 0L, 0);
      }
    }
  }
  {
  fd = move_to_high_fd(fd, 0, -1);
  default_buffered_input = fd;
  fcntl(default_buffered_input, 2, 1);
  }
  if (interactive_shell) {
    if (fd_is_tty) {
      {
      dup2(fd, 0);
      close(fd);
      fd = 0;
      default_buffered_input = 0;
      }
    }
  }
  {
  free((void *)filename);
  }
  return (fd);
}
}
static void set_bash_input(void) 
{ 
  int tmp ;

  {
  if (interactive == 0) {
    {
    sh_unset_nodelay_mode(default_buffered_input);
    }
  } else {
    {
    tmp = fileno(stdin);
    sh_unset_nodelay_mode(tmp);
    }
  }
  if (interactive) {
    if (no_line_editing == 0) {
      {
      with_input_from_stdin();
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (interactive == 0) {
    {
    with_input_from_buffered_stream(default_buffered_input, dollar_vars[0]);
    }
  } else {
    {
    with_input_from_stream(default_input, dollar_vars[0]);
    }
  }
  }
  return;
}
}
void unset_bash_input(int check_zero ) 
{ 


  {
  if (check_zero) {
    if (default_buffered_input >= 0) {
      {
      close_buffered_fd(default_buffered_input);
      bash_input.location.buffered_fd = -1;
      default_buffered_input = bash_input.location.buffered_fd;
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (check_zero == 0) {
    if (default_buffered_input > 0) {
      {
      close_buffered_fd(default_buffered_input);
      bash_input.location.buffered_fd = -1;
      default_buffered_input = bash_input.location.buffered_fd;
      }
    }
  }
  }
  return;
}
}
static void set_shell_name(char *argv0 ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  shell_name = base_pathname(argv0);
  }
  if ((int )*shell_name == 45) {
    shell_name ++;
  }
  if ((int )*(shell_name + 0) == 115) {
    if ((int )*(shell_name + 1) == 104) {
      if ((int )*(shell_name + 2) == 0) {
        act_like_sh ++;
      }
    }
  }
  if ((int )*(shell_name + 0) == 115) {
    if ((int )*(shell_name + 1) == 117) {
      if ((int )*(shell_name + 2) == 0) {
        su_shell ++;
      }
    }
  }
  shell_name = argv0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (dollar_vars[0]) {
      {
      free((void *)dollar_vars[0]);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp = strlen((char const   *)shell_name);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )shell_name);
  dollar_vars[0] = tmp___1;
  }
  if ((int )*shell_name == 45) {
    shell_name ++;
    login_shell ++;
  }
  if (! shell_name) {
    shell_name = (char *)"bash";
  } else { //Added block
  if (! *shell_name) {
    shell_name = (char *)"bash";
  } else { //Added block
  if ((int )*(shell_name + 0) == 45) {
    if (! *(shell_name + 1)) {
      shell_name = (char *)"bash";
    }
  }
  }
  }
  return;
}
}
static void init_interactive(void) 
{ 


  {
  interactive = 1;
  startup_state = interactive;
  interactive_shell = startup_state;
  expand_aliases = 1;
  return;
}
}
static void init_noninteractive(void) 
{ 


  {
  {
  bash_history_reinit(0);
  interactive = 0;
  startup_state = interactive;
  interactive_shell = startup_state;
  expand_aliases = 0;
  no_line_editing = 1;
  set_job_control(0);
  }
  return;
}
}
void get_current_user_info(void) 
{ 
  struct passwd *entry ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
  if ((unsigned long )current_user.user_name == (unsigned long )((char *)0)) {
    {
    entry = getpwuid(current_user.uid);
    }
    if (entry) {
      {
      tmp = strlen((char const   *)entry->pw_name);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )entry->pw_name);
      current_user.user_name = tmp___1;
      }
      if (entry->pw_shell) {
        if (*(entry->pw_shell + 0)) {
          {
          tmp___2 = strlen((char const   *)entry->pw_shell);
          tmp___3 = xmalloc(1UL + tmp___2);
          tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )entry->pw_shell);
          current_user.shell = tmp___4;
          }
        } else {
          {
          tmp___5 = strlen("/bin/sh");
          tmp___6 = xmalloc(1UL + tmp___5);
          tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )"/bin/sh");
          current_user.shell = tmp___7;
          }
        }
      } else {
        {
        tmp___5 = strlen("/bin/sh");
        tmp___6 = xmalloc(1UL + tmp___5);
        tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )"/bin/sh");
        current_user.shell = tmp___7;
        }
      }
      {
      tmp___8 = strlen((char const   *)entry->pw_dir);
      tmp___9 = xmalloc(1UL + tmp___8);
      tmp___10 = strcpy((char * __restrict  )tmp___9, (char const   * __restrict  )entry->pw_dir);
      current_user.home_dir = tmp___10;
      }
    } else {
      {
      tmp___11 = strlen("I have no name!");
      tmp___12 = xmalloc(1UL + tmp___11);
      tmp___13 = strcpy((char * __restrict  )tmp___12, (char const   * __restrict  )"I have no name!");
      current_user.user_name = tmp___13;
      tmp___14 = strlen("/bin/sh");
      tmp___15 = xmalloc(1UL + tmp___14);
      tmp___16 = strcpy((char * __restrict  )tmp___15, (char const   * __restrict  )"/bin/sh");
      current_user.shell = tmp___16;
      tmp___17 = strlen("/");
      tmp___18 = xmalloc(1UL + tmp___17);
      tmp___19 = strcpy((char * __restrict  )tmp___18, (char const   * __restrict  )"/");
      current_user.home_dir = tmp___19;
      }
    }
    {
    endpwent();
    }
  }
  return;
}
}
extern int sh_setlinebuf() ;
static void shell_initialize(void) 
{ 
  char hostname[256] ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (shell_initialized == 0) {
    {
    sh_setlinebuf(stderr);
    sh_setlinebuf(stdout);
    }
  }
  {
  initialize_shell_builtins();
  initialize_traps();
  initialize_signals();
  }
  if ((unsigned long )current_host_name == (unsigned long )((char *)0)) {
    {
    tmp___2 = gethostname(hostname, (size_t )255);
    }
    if (tmp___2 < 0) {
      current_host_name = (char *)"??host??";
    } else {
      {
      tmp = strlen((char const   *)(hostname));
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )(hostname));
      current_host_name = tmp___1;
      }
    }
  }
  if (interactive_shell) {
    {
    get_current_user_info();
    }
  }
  {
  tilde_initialize();
  }
  if (privileged_mode) {
    tmp___3 = 1;
  } else { //Added block
  if (restricted) {
    tmp___3 = 1;
  } else { //Added block
  if (running_setuid) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  }
  }
  {
  initialize_shell_variables(shell_environment, tmp___3);
  initialize_job_control(0);
  initialize_bash_input();
  }
  if (privileged_mode) {
    tmp___4 = 1;
  } else { //Added block
  if (restricted) {
    tmp___4 = 1;
  } else { //Added block
  if (running_setuid) {
    tmp___4 = 1;
  } else {
    tmp___4 = 0;
  }
  }
  }
  {
  initialize_shell_options(tmp___4);
  }
  return;
}
}
static void shell_reinitialize(void) 
{ 


  {
  {
  primary_prompt = (char *)"\\s-\\v\\$ ";
  secondary_prompt = (char *)"> ";
  current_command_number = 1;
  no_profile = 1;
  no_rc = no_profile;
  executing = 0;
  interactive = executing;
  make_login_shell = interactive;
  login_shell = make_login_shell;
  last_command_exit_value = 0;
  line_number = last_command_exit_value;
  do_version = line_number;
  debugging = do_version;
  subshell_environment = 0;
  interactive_shell = subshell_environment;
  forced_interactive = interactive_shell;
  expand_aliases = 0;
  bash_history_reinit(0);
  restricted = 0;
  bashrc_file = (char *)"~/.bashrc";
  delete_all_variables(shell_variables);
  delete_all_variables(shell_functions);
  shell_reinitialized = 1;
  }
  return;
}
}
static void show_shell_usage(FILE *fp , int extra ) 
{ 
  int i ;
  char *set_opts ;
  char *s ;
  char *t ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  if (extra) {
    {
    tmp = shell_version_string();
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"GNU bash, version %s-(%s)\n",
            tmp, "");
    }
  }
  {
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Usage:\t%s [GNU long option] [option] ...\n\t%s [GNU long option] [option] script-file ...\n",
          shell_name, shell_name);
  fputs((char const   * __restrict  )"GNU long options:\n", (FILE * __restrict  )fp);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! long_args[i].name) {
      goto while_break;
    }
    {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t--%s\n", long_args[i].name);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  fputs((char const   * __restrict  )"Shell options:\n", (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"\t-irsD or -c command\t\t(invocation only)\n",
        (FILE * __restrict  )fp);
  i = 0;
  set_opts = (char *)0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (shell_builtins + i)->name) {
      goto while_break___0;
    }
    if ((int )*((shell_builtins + i)->name + 0) == (int )*("set" + 0)) {
      {
      tmp___3 = strcmp((char const   *)(shell_builtins + i)->name, "set");
      }
      if (tmp___3 == 0) {
        {
        tmp___0 = strlen((char const   *)(shell_builtins + i)->short_doc);
        tmp___1 = xmalloc(1UL + tmp___0);
        tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )(shell_builtins + i)->short_doc);
        set_opts = tmp___2;
        }
      }
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (set_opts) {
    {
    s = strchr((char const   *)set_opts, '[');
    }
    if ((unsigned long )s == (unsigned long )((char *)0)) {
      s = set_opts;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      s ++;
      if (! ((int )*s == 45)) {
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    t = strchr((char const   *)s, ']');
    }
    if (t) {
      *t = (char )'\000';
    }
    {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t-%s or -o option\n",
            s);
    free((void *)set_opts);
    }
  }
  if (extra) {
    {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Type `%s -c \"help set\"\' for more information about shell options.\n",
            shell_name);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Type `%s -c help\' for more information about shell builtin commands.\n",
            shell_name);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Use the `bashbug\' command to report bugs.\n");
    }
  }
  return;
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
static int isnetconn(int fd ) 
{ 
  int rv ;
  int l ;
  struct sockaddr sa ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
  l = (int )sizeof(sa);
  rv = getpeername(fd, (struct sockaddr * __restrict  )(& sa), (socklen_t * __restrict  )(& l));
  }
  if (rv < 0) {
    {
    tmp___2 = __errno_location();
    }
    if (*tmp___2 == 88) {
      tmp___1 = 0;
    } else {
      {
      tmp___3 = __errno_location();
      }
      if (*tmp___3 == 22) {
        tmp___1 = 0;
      } else {
        tmp___1 = 1;
      }
    }
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
#pragma merger("0","/tmp/cil-N1lPnGqV.i","-g")
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
int variable_context ;
void dispose_used_env_vars(void) ;
int interrupt_state  ;
void throw_to_top_level(void) ;
void dispose_command(COMMAND *command ) ;
SigHandler *set_signal_handler(int sig , SigHandler *handler ) ;
void sigint_sighandler(int sig ) ;
void jump_to_top_level(int value ) ;
int read_command(void) ;
int yyparse(void) ;
void set_current_prompt_level(int x ) ;
int EOF_Reached ;
int just_one_command ;
void run_pending_traps(void) ;
int signal_is_ignored(int sig ) ;
extern char *get_working_directory(char * ) ;
void gather_here_documents(void) ;
void execute_prompt_command(char *command ) ;
int execute_command(COMMAND *command ) ;
int stdin_redir  ;
int need_here_doc  ;
int current_command_line_count  ;
int reader_loop(void) 
{ 
  int our_indirection_level ;
  COMMAND *current_command ;
  int code ;
  int tmp ;
  int tmp___0 ;

  {
  current_command = (COMMAND *)((void *)0);
  indirection_level ++;
  our_indirection_level = indirection_level;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (EOF_Reached == 0)) {
      goto while_break;
    }
    {
    code = __sigsetjmp(top_level, 1);
    unlink_fifo_list();
    }
    if (interactive_shell) {
      {
      tmp = signal_is_ignored(2);
      }
      if (tmp == 0) {
        {
        set_signal_handler(2, (SigHandler *)(& sigint_sighandler));
        }
      }
    }
    if (code != 0) {
      indirection_level = our_indirection_level;
      {
      if (code == 1) {
        goto case_1;
      }
      if (code == 3) {
        goto case_1;
      }
      if (code == 2) {
        goto case_2;
      }
      goto switch_default;
      case_1: /* CIL Label */ 
      case_3: /* CIL Label */ 
      current_command = (COMMAND *)((void *)0);
      if (exit_immediately_on_error) {
        variable_context = 0;
      }
      EOF_Reached = -1;
      goto exec_done;
      case_2: /* CIL Label */ 
      last_command_exit_value = 1;
      if (subshell_environment) {
        current_command = (COMMAND *)((void *)0);
        EOF_Reached = -1;
        goto exec_done;
      }
      if (current_command) {
        {
        dispose_command(current_command);
        current_command = (COMMAND *)((void *)0);
        }
      }
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      command_error("reader_loop", 3, code, 0);
      }
      switch_break: /* CIL Label */ ;
      }
    }
    {
    executing = 0;
    dispose_used_env_vars();
    tmp___0 = read_command();
    }
    if (tmp___0 == 0) {
      if (interactive_shell == 0) {
        if (read_but_dont_execute) {
          {
          last_command_exit_value = 0;
          dispose_command(global_command);
          global_command = (COMMAND *)((void *)0);
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
        current_command = global_command;
        if (current_command) {
          {
          global_command = (COMMAND *)((void *)0);
          current_command_number ++;
          executing = 1;
          stdin_redir = 0;
          execute_command(current_command);
          }
          exec_done: 
          if (current_command) {
            {
            dispose_command(current_command);
            current_command = (COMMAND *)((void *)0);
            }
          }
          if (interrupt_state) {
            {
            throw_to_top_level();
            }
          }
        }
      }
    } else { //Added block
    if (interactive == 0) {
      EOF_Reached = -1;
    }
    }
    if (just_one_command) {
      EOF_Reached = -1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  indirection_level --;
  return (last_command_exit_value);
}
}
static void alrm_catcher(int i ) 
{ 


  {
  {
  printf((char const   * __restrict  )"\atimed out waiting for input: auto-logout\n");
  jump_to_top_level(3);
  }
  return;
}
}
static void send_pwd_to_eterm(void) 
{ 
  char *pwd ;

  {
  {
  pwd = get_string_value("PWD");
  }
  if ((unsigned long )pwd == (unsigned long )((char *)0)) {
    {
    pwd = get_working_directory((char *)"eterm");
    }
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\032/%s\n", pwd);
  }
  return;
}
}
int parse_command(void) 
{ 
  int r ;
  char *command_to_execute ;

  {
  {
  need_here_doc = 0;
  run_pending_traps();
  }
  if (interactive) {
    if ((unsigned int )bash_input.type != 3U) {
      {
      command_to_execute = get_string_value("PROMPT_COMMAND");
      }
      if (command_to_execute) {
        {
        execute_prompt_command(command_to_execute);
        }
      }
      if (running_under_emacs == 2) {
        {
        send_pwd_to_eterm();
        }
      }
    }
  }
  {
  current_command_line_count = 0;
  r = yyparse();
  }
  if (need_here_doc) {
    {
    gather_here_documents();
    }
  }
  return (r);
}
}
int read_command(void) 
{ 
  SHELL_VAR *tmout_var ;
  int tmout_len ;
  int result ;
  SigHandler *old_alrm ;

  {
  {
  set_current_prompt_level(1);
  global_command = (COMMAND *)((void *)0);
  tmout_var = (SHELL_VAR *)((void *)0);
  tmout_len = 0;
  }
  if (interactive) {
    {
    tmout_var = find_variable((char *)"TMOUT");
    old_alrm = (SigHandler *)((void *)0);
    }
    if (tmout_var) {
      if (tmout_var->value) {
        {
        tmout_len = atoi((char const   *)tmout_var->value);
        }
        if (tmout_len > 0) {
          {
          old_alrm = set_signal_handler(14, (SigHandler *)(& alrm_catcher));
          alarm((unsigned int )tmout_len);
          }
        }
      }
    }
  }
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  {
  current_command_line_count = 0;
  result = parse_command();
  }
  if (interactive) {
    if (tmout_var) {
      if (tmout_len > 0) {
        {
        alarm(0U);
        set_signal_handler(14, old_alrm);
        }
      }
    }
  }
  return (result);
}
}
#pragma merger("0","/tmp/cil-Phs4O5AU.i","-g")
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
static int yygrowstack(void) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
int const   sh_syntaxtab[256] ;
char *xrealloc(void *pointer , size_t bytes ) ;
char *polite_directory_format(char *name ) ;
void parser_error(int lineno , char const   *format  , ...) ;
int assignment(char *string ) ;
void dispose_word(WORD_DESC *w ) ;
void dispose_cond_node(COND_COM *cond ) ;
WORD_LIST *add_string_to_list(char *string , WORD_LIST *list___0 ) ;
WORD_DESC *make_word_from_token(int token___0 ) ;
COMMAND *command_connect(COMMAND *com1 , COMMAND *com2 , int connector ) ;
COMMAND *make_for_command(WORD_DESC *name , WORD_LIST *map_list , COMMAND *action ) ;
COMMAND *make_group_command(COMMAND *command ) ;
COMMAND *make_case_command(WORD_DESC *word , PATTERN_LIST *clauses ) ;
PATTERN_LIST *make_pattern_list(WORD_LIST *patterns , COMMAND *action ) ;
COMMAND *make_if_command(COMMAND *test , COMMAND *true_case , COMMAND *false_case ) ;
COMMAND *make_while_command(COMMAND *test , COMMAND *action ) ;
COMMAND *make_until_command(COMMAND *test , COMMAND *action ) ;
COMMAND *make_simple_command(ELEMENT element , COMMAND *command ) ;
void make_here_document(REDIRECT *temp___0 ) ;
REDIRECT *make_redirection(int source , enum r_instruction instruction , REDIRECTEE dest_and_filename ) ;
COMMAND *make_function_def(WORD_DESC *name , COMMAND *command , int lineno , int lstart ) ;
COMMAND *clean_simple_command(COMMAND *command ) ;
COMMAND *make_arith_command(WORD_LIST *exp ) ;
COMMAND *make_select_command(WORD_DESC *name , WORD_LIST *map_list , COMMAND *action ) ;
struct cond_com *make_cond_node(int type , WORD_DESC *op , struct cond_com *left ,
                                struct cond_com *right ) ;
COMMAND *make_cond_command(COND_COM *cond_node ) ;
COMMAND *make_arith_for_command(WORD_LIST *exprs , COMMAND *action , int lineno ) ;
COMMAND *make_subshell_command(COMMAND *command ) ;
COMMAND *connect_async_list(COMMAND *command , COMMAND *command2 , int connector ) ;
char *substring(char *string , int start , int end ) ;
char *sub_append_string(char *source , char *target , int *indx , int *size ) ;
WORD_LIST *expand_prompt_string(char *string , int quoted ) ;
char *dequote_string(char *string ) ;
void reset_parser(void) ;
WORD_LIST *parse_string_to_word_list(char *s , char *whom ) ;
int get_current_prompt_level(void) ;
char *localetrans(char *string , int len___0 , int *lenp ) ;
void xbcopy(char *s , char *d___0 , int n ) ;
extern char *itos(int  ) ;
extern char *sh_single_quote(char * ) ;
extern char *sh_backslash_quote_for_double_quotes(char * ) ;
extern char *ansicstr(char * , int  , int  , int * , int * ) ;
int interactive_comments ;
void init_yy_io(Function *get , Function *unget , enum stream_type type , char *name ,
                INPUT_STREAM location ) ;
void push_stream(int reset_lineno ) ;
void pop_stream(void) ;
int stream_on_stack(enum stream_type type ) ;
char *read_secondary_line(int remove_quoted_newline ) ;
int find_reserved_word(char *token___0 ) ;
char *decode_prompt_string(char *string ) ;
int *save_token_state(void) ;
void restore_token_state(int *ts ) ;
int getc_with_restart(FILE *stream ) ;
int ungetc_with_restart(int c , FILE *stream ) ;
BUFFERED_STREAM *set_buffered_stream(int fd , BUFFERED_STREAM *bp ) ;
int time_to_check_mail(void) ;
void check_mail(void) ;
extern int read_octal(char * ) ;
extern int exit_builtin() ;
int bash_readline_initialized ;
void initialize_readline(void) ;
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern char *readline(char const   * ) ;
int remember_on_history ;
int history_expansion_inhibited  ;
void bash_history_disable(void) ;
char *pre_process_line(char *line , int print_changes , int addit ) ;
int history_number(void) ;
void maybe_add_history(char *line ) ;
pid_t shell_pgrp ;
int count_all_jobs(void) ;
void notify_and_cleanup(void) ;
int give_terminal_to(pid_t pgrp , int force ) ;
int job_control ;
alias_t *find_alias(char *name ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
int extended_glob ;
int eof_encountered ;
int interrupt_immediately ;
char *dist_version ;
int patch_level ;
extern Function *last_shell_builtin ;
extern Function *this_shell_builtin ;
int bash_input_fd_changed  ;
static char *ansiexpand(char *string , int start , int end , int *lenp ) ;
static char *localeexpand(char *string , int start , int end , int lineno , int *lenp ) ;
static int reserved_word_acceptable(int token___0 ) ;
static int read_token(int command ) ;
static int yylex(void) ;
static int parse_arith_cmd(char **ep ) ;
static COMMAND *parse_cond_command(void) ;
static int read_token_word(int character ) ;
static void discard_parser_constructs(int error_p ) ;
static void report_syntax_error(char *message ) ;
static void handle_eof_input_unit(void) ;
static void prompt_again(void) ;
static void print_prompt(void) ;
char *history_delimiting_chars(void) ;
int yyerror() ;
char *primary_prompt  =    (char *)"\\s-\\v\\$ ";
char *secondary_prompt  =    (char *)"> ";
char *ps1_prompt  ;
char *ps2_prompt  ;
char **prompt_string_pointer  =    (char **)((void *)0);
char *current_prompt_string  ;
int expand_aliases  =    0;
int promptvars  =    1;
static char *current_decoded_prompt  ;
static REDIRECT *redir_stack[10]  ;
static char *shell_input_line  =    (char *)((void *)0);
static int shell_input_line_index  ;
static int shell_input_line_size  ;
static int shell_input_line_len  ;
static int shell_input_line_terminator  ;
static int function_dstart  ;
static int function_bstart  ;
static int arith_for_lineno  ;
static REDIRECTEE redir  ;
short const   yylhs[134]  = 
  {      (short const   )-1,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )27,      (short const   )27,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )26,      (short const   )26, 
        (short const   )26,      (short const   )25,      (short const   )25,      (short const   )10, 
        (short const   )10,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )11,      (short const   )11,      (short const   )11, 
        (short const   )11,      (short const   )11,      (short const   )11,      (short const   )11, 
        (short const   )11,      (short const   )11,      (short const   )11,      (short const   )11, 
        (short const   )12,      (short const   )12,      (short const   )12,      (short const   )12, 
        (short const   )12,      (short const   )12,      (short const   )18,      (short const   )18, 
        (short const   )18,      (short const   )18,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )13, 
        (short const   )14,      (short const   )14,      (short const   )14,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )20,      (short const   )20, 
        (short const   )23,      (short const   )21,      (short const   )21,      (short const   )21, 
        (short const   )15,      (short const   )16,      (short const   )17,      (short const   )22, 
        (short const   )22,      (short const   )22,      (short const   )31,      (short const   )31, 
        (short const   )29,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )30,      (short const   )30,      (short const   )28,      (short const   )28, 
        (short const   )4,      (short const   )7,      (short const   )7,      (short const   )5, 
        (short const   )5,      (short const   )5,      (short const   )6,      (short const   )6, 
        (short const   )6,      (short const   )6,      (short const   )6,      (short const   )6, 
        (short const   )34,      (short const   )34,      (short const   )34,      (short const   )33, 
        (short const   )33,      (short const   )8,      (short const   )8,      (short const   )8, 
        (short const   )9,      (short const   )9,      (short const   )9,      (short const   )9, 
        (short const   )9,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )2,      (short const   )2, 
        (short const   )32,      (short const   )32};
short const   yylen[134]  = 
  {      (short const   )2,      (short const   )2,      (short const   )1,      (short const   )2, 
        (short const   )1,      (short const   )1,      (short const   )2,      (short const   )2, 
        (short const   )2,      (short const   )3,      (short const   )3,      (short const   )2, 
        (short const   )3,      (short const   )2,      (short const   )3,      (short const   )2, 
        (short const   )3,      (short const   )2,      (short const   )3,      (short const   )2, 
        (short const   )3,      (short const   )2,      (short const   )3,      (short const   )2, 
        (short const   )3,      (short const   )2,      (short const   )3,      (short const   )2, 
        (short const   )3,      (short const   )2,      (short const   )3,      (short const   )2, 
        (short const   )2,      (short const   )3,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )1,      (short const   )2, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )5, 
        (short const   )5,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )6,      (short const   )6,      (short const   )7,      (short const   )7, 
        (short const   )10,      (short const   )10,      (short const   )7,      (short const   )7, 
        (short const   )5,      (short const   )5,      (short const   )6,      (short const   )6, 
        (short const   )7,      (short const   )7,      (short const   )10,      (short const   )10, 
        (short const   )6,      (short const   )7,      (short const   )6,      (short const   )5, 
        (short const   )6,      (short const   )4,      (short const   )1,      (short const   )2, 
        (short const   )3,      (short const   )5,      (short const   )7,      (short const   )6, 
        (short const   )3,      (short const   )1,      (short const   )3,      (short const   )4, 
        (short const   )6,      (short const   )5,      (short const   )1,      (short const   )2, 
        (short const   )4,      (short const   )4,      (short const   )5,      (short const   )5, 
        (short const   )2,      (short const   )3,      (short const   )1,      (short const   )3, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )4,      (short const   )4, 
        (short const   )4,      (short const   )4,      (short const   )4,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )0, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )2, 
        (short const   )4,      (short const   )4,      (short const   )3,      (short const   )3, 
        (short const   )1,      (short const   )1,      (short const   )2,      (short const   )2, 
        (short const   )3,      (short const   )3,      (short const   )4,      (short const   )1, 
        (short const   )1,      (short const   )2};
short const   yydefred[286]  = 
  {      (short const   )0,      (short const   )0,      (short const   )115,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )115,      (short const   )115, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )35,      (short const   )0,      (short const   )85, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )2,      (short const   )4,      (short const   )0,      (short const   )0, 
        (short const   )115,      (short const   )115,      (short const   )0,      (short const   )131, 
        (short const   )0,      (short const   )124,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )45,      (short const   )49, 
        (short const   )46,      (short const   )52,      (short const   )53,      (short const   )54, 
        (short const   )55,      (short const   )44,      (short const   )50,      (short const   )51, 
        (short const   )36,      (short const   )39,      (short const   )0,      (short const   )3, 
        (short const   )101,      (short const   )0,      (short const   )0,      (short const   )115, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )133,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )11,      (short const   )13,      (short const   )19,      (short const   )15, 
        (short const   )27,      (short const   )21,      (short const   )17,      (short const   )25, 
        (short const   )23,      (short const   )29,      (short const   )31,      (short const   )32, 
        (short const   )7,      (short const   )8,      (short const   )0,      (short const   )0, 
        (short const   )115,      (short const   )1,      (short const   )115,      (short const   )115, 
        (short const   )0,      (short const   )0,      (short const   )34,      (short const   )40, 
        (short const   )37,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )115,      (short const   )116,      (short const   )111,      (short const   )100, 
        (short const   )0,      (short const   )0,      (short const   )115,      (short const   )0, 
        (short const   )115,      (short const   )113,      (short const   )112,      (short const   )114, 
        (short const   )115,      (short const   )115,      (short const   )115,      (short const   )0, 
        (short const   )115,      (short const   )115,      (short const   )0,      (short const   )0, 
        (short const   )86,      (short const   )0,      (short const   )115,      (short const   )12, 
        (short const   )14,      (short const   )20,      (short const   )16,      (short const   )28, 
        (short const   )22,      (short const   )18,      (short const   )26,      (short const   )24, 
        (short const   )30,      (short const   )33,      (short const   )9,      (short const   )10, 
        (short const   )84,      (short const   )80,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )38, 
        (short const   )0,      (short const   )0,      (short const   )115,      (short const   )115, 
        (short const   )115,      (short const   )115,      (short const   )115,      (short const   )115, 
        (short const   )0,      (short const   )115,      (short const   )0,      (short const   )115, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )115,      (short const   )0,      (short const   )115,      (short const   )0, 
        (short const   )0,      (short const   )115,      (short const   )0,      (short const   )77, 
        (short const   )0,      (short const   )0,      (short const   )120,      (short const   )121, 
        (short const   )0,      (short const   )0,      (short const   )115,      (short const   )115, 
        (short const   )81,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )115,      (short const   )0,      (short const   )0,      (short const   )115, 
        (short const   )115,      (short const   )0,      (short const   )5,      (short const   )0, 
        (short const   )0,      (short const   )64,      (short const   )65,      (short const   )115, 
        (short const   )115,      (short const   )115,      (short const   )115,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )47, 
        (short const   )48,      (short const   )0,      (short const   )0,      (short const   )75, 
        (short const   )0,      (short const   )0,      (short const   )83,      (short const   )106, 
        (short const   )107,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )96,      (short const   )0,      (short const   )0,      (short const   )74, 
        (short const   )72,      (short const   )98,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )56,      (short const   )6, 
        (short const   )115,      (short const   )57,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )66,      (short const   )0, 
        (short const   )115,      (short const   )67,      (short const   )76,      (short const   )82, 
        (short const   )115,      (short const   )115,      (short const   )115,      (short const   )115, 
        (short const   )97,      (short const   )73,      (short const   )0,      (short const   )0, 
        (short const   )115,      (short const   )58,      (short const   )59,      (short const   )0, 
        (short const   )62,      (short const   )63,      (short const   )68,      (short const   )69, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )115,      (short const   )99,      (short const   )92, 
        (short const   )0,      (short const   )115,      (short const   )115,      (short const   )115, 
        (short const   )115,      (short const   )115,      (short const   )89,      (short const   )94, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )88,      (short const   )60,      (short const   )61, 
        (short const   )70,      (short const   )71};
short const   yydgoto[35]  = 
  {      (short const   )30,      (short const   )31,      (short const   )32,      (short const   )106, 
        (short const   )52,      (short const   )107,      (short const   )108,      (short const   )53, 
        (short const   )34,      (short const   )145,      (short const   )36,      (short const   )37, 
        (short const   )38,      (short const   )39,      (short const   )40,      (short const   )41, 
        (short const   )42,      (short const   )43,      (short const   )44,      (short const   )45, 
        (short const   )171,      (short const   )46,      (short const   )181,      (short const   )47, 
        (short const   )48,      (short const   )101,      (short const   )49,      (short const   )195, 
        (short const   )227,      (short const   )187,      (short const   )188,      (short const   )189, 
        (short const   )50,      (short const   )54,      (short const   )117};
short const   yysindex[286]  = 
  {      (short const   )-10,      (short const   )2,      (short const   )0,      (short const   )-258, 
        (short const   )-255,      (short const   )-246,      (short const   )0,      (short const   )0, 
        (short const   )-237,      (short const   )-249,      (short const   )846,      (short const   )-226, 
        (short const   )15,      (short const   )0,      (short const   )123,      (short const   )0, 
        (short const   )-211,      (short const   )-203,      (short const   )-44,      (short const   )-43, 
        (short const   )-199,      (short const   )-198,      (short const   )-194,      (short const   )-193, 
        (short const   )0,      (short const   )0,      (short const   )-192,      (short const   )-191, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-41,      (short const   )0,      (short const   )78,      (short const   )23, 
        (short const   )956,      (short const   )975,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )721,      (short const   )0, 
        (short const   )0,      (short const   )-169,      (short const   )71,      (short const   )0, 
        (short const   )35,      (short const   )-6,      (short const   )39,      (short const   )-177, 
        (short const   )-172,      (short const   )61,      (short const   )-168,      (short const   )-41, 
        (short const   )933,      (short const   )0,      (short const   )62,      (short const   )-176, 
        (short const   )-173,      (short const   )-30,      (short const   )-27,      (short const   )-166, 
        (short const   )-163,      (short const   )-162,      (short const   )-160,      (short const   )-159, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-17,      (short const   )69, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )813,      (short const   )813,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )975,      (short const   )933,      (short const   )-41, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )19,      (short const   )-7,      (short const   )0,      (short const   )66, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )99, 
        (short const   )0,      (short const   )0,      (short const   )79,      (short const   )305, 
        (short const   )0,      (short const   )-41,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )104,      (short const   )71, 
        (short const   )71,      (short const   )-247,      (short const   )-247,      (short const   )0, 
        (short const   )-41,      (short const   )-195,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )4,      (short const   )0,      (short const   )-156,      (short const   )0, 
        (short const   )-145,      (short const   )1,      (short const   )7,      (short const   )12, 
        (short const   )0,      (short const   )-156,      (short const   )0,      (short const   )-144, 
        (short const   )-140,      (short const   )0,      (short const   )975,      (short const   )0, 
        (short const   )305,      (short const   )-41,      (short const   )0,      (short const   )0, 
        (short const   )813,      (short const   )813,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )-138,      (short const   )71,      (short const   )71, 
        (short const   )71,      (short const   )71,      (short const   )71,      (short const   )-158, 
        (short const   )0,      (short const   )-129,      (short const   )-4,      (short const   )0, 
        (short const   )0,      (short const   )-132,      (short const   )0,      (short const   )-5, 
        (short const   )16,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )-126, 
        (short const   )71,      (short const   )-5,      (short const   )20,      (short const   )0, 
        (short const   )0,      (short const   )305,      (short const   )975,      (short const   )0, 
        (short const   )-115,      (short const   )-111,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )-240,      (short const   )-240,      (short const   )-240, 
        (short const   )0,      (short const   )-142,      (short const   )32,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-128,      (short const   )-34, 
        (short const   )-120,      (short const   )26,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-114,      (short const   )36, 
        (short const   )-107,      (short const   )38,      (short const   )0,      (short const   )19, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-25,      (short const   )-113, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )29, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )37,      (short const   )-201,      (short const   )71,      (short const   )71, 
        (short const   )71,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )71,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )71,      (short const   )-100,      (short const   )45,      (short const   )-98, 
        (short const   )48,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0};
short const   yyrindex[286]  = 
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )888, 
        (short const   )33,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )450,      (short const   )0,      (short const   )0,      (short const   )164, 
        (short const   )118,      (short const   )162,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )126,      (short const   )0,      (short const   )126,      (short const   )0, 
        (short const   )0,      (short const   )216,      (short const   )0,      (short const   )462, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )165,      (short const   )166,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )174,      (short const   )0,      (short const   )495, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )436,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )507,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )11,      (short const   )18,      (short const   )0, 
        (short const   )540,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )403,      (short const   )0, 
        (short const   )0,      (short const   )553,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )573,      (short const   )662,      (short const   )765,      (short const   )-85, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )416,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )587,      (short const   )599,      (short const   )611, 
        (short const   )0,      (short const   )-84,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )-81,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-250,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-244,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0};
short const   yygindex[35]  = 
  {      (short const   )0,      (short const   )0,      (short const   )-2,      (short const   )10, 
        (short const   )-133,      (short const   )0,      (short const   )340,      (short const   )798, 
        (short const   )0,      (short const   )24,      (short const   )0,      (short const   )-112, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-146,      (short const   )0,      (short const   )-80,      (short const   )0, 
        (short const   )-28,      (short const   )21,      (short const   )152,      (short const   )25, 
        (short const   )-33,      (short const   )8,      (short const   )0,      (short const   )0, 
        (short const   )182,      (short const   )1196,      (short const   )-170};
short const   yytable[1469]  = 
  {      (short const   )24,      (short const   )80,      (short const   )83,      (short const   )105, 
        (short const   )114,      (short const   )114,      (short const   )105,      (short const   )252, 
        (short const   )63,      (short const   )100,      (short const   )33,      (short const   )170, 
        (short const   )51,      (short const   )93,      (short const   )105,      (short const   )131, 
        (short const   )265,      (short const   )105,      (short const   )134,      (short const   )95, 
        (short const   )55,      (short const   )122,      (short const   )105,      (short const   )56, 
        (short const   )35,      (short const   )232,      (short const   )211,      (short const   )57, 
        (short const   )123,      (short const   )154,      (short const   )29,      (short const   )203, 
        (short const   )58,      (short const   )206,      (short const   )62,      (short const   )240, 
        (short const   )226,      (short const   )94,      (short const   )95,      (short const   )105, 
        (short const   )93,      (short const   )61,      (short const   )105,      (short const   )34, 
        (short const   )150,      (short const   )151,      (short const   )95,      (short const   )105, 
        (short const   )103,      (short const   )122,      (short const   )27,      (short const   )65, 
        (short const   )26,      (short const   )113,      (short const   )113,      (short const   )66, 
        (short const   )123,      (short const   )152,      (short const   )273,      (short const   )179, 
        (short const   )170,      (short const   )96,      (short const   )125,      (short const   )242, 
        (short const   )178,      (short const   )179,      (short const   )180,      (short const   )76, 
        (short const   )236,      (short const   )237,      (short const   )122,      (short const   )34, 
        (short const   )226,      (short const   )147,      (short const   )34,      (short const   )77, 
        (short const   )105,      (short const   )123,      (short const   )153,      (short const   )84, 
        (short const   )85,      (short const   )105,      (short const   )97,      (short const   )92, 
        (short const   )86,      (short const   )87,      (short const   )88,      (short const   )89, 
        (short const   )93,      (short const   )104,      (short const   )251,      (short const   )120, 
        (short const   )34,      (short const   )34,      (short const   )110,      (short const   )34, 
        (short const   )121,      (short const   )170,      (short const   )118,      (short const   )251, 
        (short const   )148,      (short const   )122,      (short const   )127,      (short const   )126, 
        (short const   )124,      (short const   )128,      (short const   )33,      (short const   )33, 
        (short const   )140,      (short const   )105,      (short const   )141,      (short const   )29, 
        (short const   )135,      (short const   )28,      (short const   )105,      (short const   )136, 
        (short const   )137,      (short const   )116,      (short const   )138,      (short const   )139, 
        (short const   )169,      (short const   )146,      (short const   )194,      (short const   )214, 
        (short const   )197,      (short const   )207,      (short const   )198,      (short const   )192, 
        (short const   )41,      (short const   )208,      (short const   )200,      (short const   )27, 
        (short const   )220,      (short const   )26,      (short const   )223,      (short const   )202, 
        (short const   )115,      (short const   )230,      (short const   )279,      (short const   )280, 
        (short const   )173,      (short const   )233,      (short const   )100,      (short const   )238, 
        (short const   )29,      (short const   )241,      (short const   )243,      (short const   )244, 
        (short const   )248,      (short const   )253,      (short const   )225,      (short const   )254, 
        (short const   )270,      (short const   )33,      (short const   )33,      (short const   )256, 
        (short const   )41,      (short const   )34,      (short const   )34,      (short const   )41, 
        (short const   )272,      (short const   )257,      (short const   )258,      (short const   )259, 
        (short const   )27,      (short const   )266,      (short const   )26,      (short const   )174, 
        (short const   )175,      (short const   )282,      (short const   )283,      (short const   )284, 
        (short const   )42,      (short const   )285,      (short const   )117,      (short const   )118, 
        (short const   )119,      (short const   )41,      (short const   )90,      (short const   )91, 
        (short const   )87,      (short const   )274,      (short const   )147,      (short const   )75, 
        (short const   )43,      (short const   )74,      (short const   )33,      (short const   )33, 
        (short const   )99,      (short const   )159,      (short const   )205,      (short const   )210, 
        (short const   )64,      (short const   )250,      (short const   )28,      (short const   )0, 
        (short const   )221,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )146,      (short const   )0,      (short const   )42, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )43,      (short const   )0,      (short const   )0,      (short const   )43, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )42,      (short const   )166,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )115,      (short const   )28, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )43,      (short const   )78,      (short const   )81, 
        (short const   )79,      (short const   )82,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )41,      (short const   )41, 
        (short const   )0,      (short const   )0,      (short const   )1,      (short const   )2, 
        (short const   )129,      (short const   )115,      (short const   )130,      (short const   )132, 
        (short const   )3,      (short const   )133,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )0,      (short const   )224, 
        (short const   )8,      (short const   )9,      (short const   )112,      (short const   )0, 
        (short const   )0,      (short const   )10,      (short const   )11,      (short const   )155, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )191,      (short const   )231,      (short const   )225,      (short const   )199, 
        (short const   )16,      (short const   )17,      (short const   )18,      (short const   )19, 
        (short const   )201,      (short const   )20,      (short const   )21,      (short const   )22, 
        (short const   )23,      (short const   )25,      (short const   )42,      (short const   )42, 
        (short const   )0,      (short const   )115,      (short const   )115,      (short const   )34, 
        (short const   )34,      (short const   )34,      (short const   )34,      (short const   )249, 
        (short const   )34,      (short const   )269,      (short const   )43,      (short const   )43, 
        (short const   )0,      (short const   )34,      (short const   )34,      (short const   )150, 
        (short const   )151,      (short const   )271,      (short const   )0,      (short const   )94, 
        (short const   )95,      (short const   )0,      (short const   )225,      (short const   )34, 
        (short const   )34,      (short const   )34,      (short const   )0,      (short const   )105, 
        (short const   )0,      (short const   )34,      (short const   )34,      (short const   )34, 
        (short const   )34,      (short const   )34,      (short const   )34,      (short const   )34, 
        (short const   )34,      (short const   )34,      (short const   )34,      (short const   )34, 
        (short const   )2,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )3,      (short const   )157,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )115, 
        (short const   )158,      (short const   )8,      (short const   )9,      (short const   )0, 
        (short const   )0,      (short const   )29,      (short const   )10,      (short const   )11, 
        (short const   )0,      (short const   )12,      (short const   )13,      (short const   )14, 
        (short const   )15,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )16,      (short const   )17,      (short const   )18, 
        (short const   )19,      (short const   )2,      (short const   )20,      (short const   )21, 
        (short const   )22,      (short const   )23,      (short const   )3,      (short const   )164, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )0,      (short const   )165,      (short const   )8,      (short const   )9, 
        (short const   )41,      (short const   )41,      (short const   )41,      (short const   )41, 
        (short const   )0,      (short const   )41,      (short const   )12,      (short const   )13, 
        (short const   )14,      (short const   )15,      (short const   )41,      (short const   )41, 
        (short const   )0,      (short const   )0,      (short const   )16,      (short const   )17, 
        (short const   )18,      (short const   )19,      (short const   )115,      (short const   )20, 
        (short const   )21,      (short const   )22,      (short const   )23,      (short const   )0, 
        (short const   )115,      (short const   )0,      (short const   )41,      (short const   )41, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )41,      (short const   )67,      (short const   )68,      (short const   )69, 
        (short const   )70,      (short const   )78,      (short const   )71,      (short const   )0, 
        (short const   )72,      (short const   )73,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )42,      (short const   )42,      (short const   )42, 
        (short const   )0,      (short const   )42,      (short const   )79,      (short const   )0, 
        (short const   )28,      (short const   )0,      (short const   )42,      (short const   )42, 
        (short const   )43,      (short const   )43,      (short const   )43,      (short const   )43, 
        (short const   )0,      (short const   )43,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )78,      (short const   )43,      (short const   )43, 
        (short const   )78,      (short const   )0,      (short const   )42,      (short const   )42, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )0,      (short const   )79,      (short const   )0, 
        (short const   )0,      (short const   )79,      (short const   )43,      (short const   )43, 
        (short const   )125,      (short const   )0,      (short const   )78,      (short const   )0, 
        (short const   )43,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )126,      (short const   )115,      (short const   )0,      (short const   )79, 
        (short const   )0,      (short const   )102,      (short const   )115,      (short const   )0, 
        (short const   )115,      (short const   )115,      (short const   )115,      (short const   )115, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )115, 
        (short const   )125,      (short const   )0,      (short const   )0,      (short const   )125, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )115,      (short const   )0,      (short const   )0, 
        (short const   )126,      (short const   )0,      (short const   )0,      (short const   )126, 
        (short const   )0,      (short const   )127,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )125,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )129,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )126,      (short const   )215,      (short const   )216, 
        (short const   )217,      (short const   )218,      (short const   )219,      (short const   )78, 
        (short const   )78,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )127,      (short const   )0,      (short const   )0, 
        (short const   )127,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )79,      (short const   )79,      (short const   )0,      (short const   )0, 
        (short const   )239,      (short const   )129,      (short const   )0,      (short const   )0, 
        (short const   )129,      (short const   )0,      (short const   )128,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )127,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )102,      (short const   )2,      (short const   )130, 
        (short const   )0,      (short const   )0,      (short const   )129,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )0,      (short const   )0,      (short const   )125, 
        (short const   )9,      (short const   )0,      (short const   )128,      (short const   )0, 
        (short const   )0,      (short const   )128,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )15,      (short const   )126, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )130, 
        (short const   )0,      (short const   )0,      (short const   )130,      (short const   )0, 
        (short const   )0,      (short const   )108,      (short const   )0,      (short const   )128, 
        (short const   )0,      (short const   )0,      (short const   )217,      (short const   )218, 
        (short const   )219,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )109,      (short const   )0,      (short const   )0, 
        (short const   )130,      (short const   )0,      (short const   )104,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )127,      (short const   )110,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )108,      (short const   )0,      (short const   )0, 
        (short const   )108,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )129,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )109,      (short const   )0,      (short const   )0, 
        (short const   )109,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )108,      (short const   )0, 
        (short const   )0,      (short const   )110,      (short const   )0,      (short const   )0, 
        (short const   )110,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )109,      (short const   )0, 
        (short const   )0,      (short const   )78,      (short const   )78,      (short const   )78, 
        (short const   )78,      (short const   )128,      (short const   )78,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )110,      (short const   )78, 
        (short const   )78,      (short const   )0,      (short const   )79,      (short const   )79, 
        (short const   )79,      (short const   )79,      (short const   )130,      (short const   )79, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )79,      (short const   )79,      (short const   )0,      (short const   )78, 
        (short const   )78,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )78,      (short const   )102,      (short const   )102, 
        (short const   )102,      (short const   )102,      (short const   )104,      (short const   )102, 
        (short const   )79,      (short const   )79,      (short const   )0,      (short const   )105, 
        (short const   )102,      (short const   )102,      (short const   )79,      (short const   )0, 
        (short const   )125,      (short const   )125,      (short const   )125,      (short const   )125, 
        (short const   )108,      (short const   )125,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )125,      (short const   )125, 
        (short const   )126,      (short const   )126,      (short const   )126,      (short const   )126, 
        (short const   )109,      (short const   )126,      (short const   )102,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )126,      (short const   )126, 
        (short const   )0,      (short const   )0,      (short const   )125,      (short const   )125, 
        (short const   )110,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )125,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )126,      (short const   )126, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )126,      (short const   )127,      (short const   )127,      (short const   )127, 
        (short const   )127,      (short const   )0,      (short const   )127,      (short const   )0, 
        (short const   )0,      (short const   )29,      (short const   )0,      (short const   )127, 
        (short const   )127,      (short const   )129,      (short const   )129,      (short const   )129, 
        (short const   )129,      (short const   )0,      (short const   )129,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )129, 
        (short const   )129,      (short const   )0,      (short const   )0,      (short const   )127, 
        (short const   )127,      (short const   )27,      (short const   )0,      (short const   )26, 
        (short const   )0,      (short const   )127,      (short const   )0,      (short const   )105, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )129, 
        (short const   )129,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )129,      (short const   )128,      (short const   )128, 
        (short const   )128,      (short const   )128,      (short const   )0,      (short const   )128, 
        (short const   )59,      (short const   )60,      (short const   )103,      (short const   )0, 
        (short const   )128,      (short const   )128,      (short const   )0,      (short const   )130, 
        (short const   )130,      (short const   )130,      (short const   )130,      (short const   )0, 
        (short const   )130,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )130,      (short const   )130,      (short const   )0, 
        (short const   )128,      (short const   )128,      (short const   )90,      (short const   )91, 
        (short const   )0,      (short const   )0,      (short const   )128,      (short const   )104, 
        (short const   )104,      (short const   )104,      (short const   )104,      (short const   )0, 
        (short const   )104,      (short const   )130,      (short const   )130,      (short const   )0, 
        (short const   )0,      (short const   )104,      (short const   )104,      (short const   )130, 
        (short const   )28,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )0,      (short const   )108,      (short const   )0, 
        (short const   )0,      (short const   )29,      (short const   )0,      (short const   )108, 
        (short const   )108,      (short const   )109,      (short const   )109,      (short const   )109, 
        (short const   )109,      (short const   )0,      (short const   )109,      (short const   )104, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )109, 
        (short const   )109,      (short const   )110,      (short const   )110,      (short const   )110, 
        (short const   )110,      (short const   )27,      (short const   )110,      (short const   )26, 
        (short const   )0,      (short const   )108,      (short const   )0,      (short const   )110, 
        (short const   )110,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )29,      (short const   )0, 
        (short const   )0,      (short const   )109,      (short const   )103,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )110,      (short const   )149,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )27,      (short const   )0, 
        (short const   )26,      (short const   )0,      (short const   )160,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )161,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )167,      (short const   )168, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )0,      (short const   )105,      (short const   )0,      (short const   )0, 
        (short const   )132,      (short const   )0,      (short const   )105,      (short const   )105, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )28,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )132,      (short const   )0,      (short const   )132,      (short const   )0, 
        (short const   )105,      (short const   )0,      (short const   )0,      (short const   )193, 
        (short const   )0,      (short const   )196,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )29,      (short const   )0,      (short const   )0, 
        (short const   )212,      (short const   )213,      (short const   )2,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )228,      (short const   )229,      (short const   )8, 
        (short const   )9,      (short const   )27,      (short const   )0,      (short const   )26, 
        (short const   )102,      (short const   )234,      (short const   )235,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )19,      (short const   )132, 
        (short const   )20,      (short const   )21,      (short const   )22,      (short const   )23, 
        (short const   )27,      (short const   )0,      (short const   )26,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )103, 
        (short const   )103,      (short const   )103,      (short const   )103,      (short const   )0, 
        (short const   )103,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )103,      (short const   )103,      (short const   )27, 
        (short const   )0,      (short const   )26,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )261,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )267,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )103, 
        (short const   )28,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )275, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )277, 
        (short const   )278,      (short const   )0,      (short const   )2,      (short const   )281, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )0,      (short const   )0,      (short const   )8, 
        (short const   )9,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )10,      (short const   )11,      (short const   )0,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )19,      (short const   )2, 
        (short const   )20,      (short const   )21,      (short const   )22,      (short const   )23, 
        (short const   )3,      (short const   )0,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )0,      (short const   )0, 
        (short const   )8,      (short const   )9,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )11,      (short const   )0, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )16,      (short const   )17,      (short const   )18,      (short const   )19, 
        (short const   )0,      (short const   )20,      (short const   )21,      (short const   )22, 
        (short const   )23,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )132,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )132,      (short const   )0, 
        (short const   )132,      (short const   )132,      (short const   )132,      (short const   )132, 
        (short const   )0,      (short const   )0,      (short const   )132,      (short const   )132, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )132, 
        (short const   )0,      (short const   )0,      (short const   )132,      (short const   )132, 
        (short const   )132,      (short const   )132,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )132,      (short const   )132, 
        (short const   )132,      (short const   )132,      (short const   )0,      (short const   )132, 
        (short const   )132,      (short const   )132,      (short const   )132,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )2,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )0,      (short const   )0,      (short const   )8, 
        (short const   )9,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )19,      (short const   )0, 
        (short const   )20,      (short const   )21,      (short const   )22,      (short const   )23, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )98,      (short const   )13, 
        (short const   )14,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )16,      (short const   )17, 
        (short const   )18,      (short const   )19,      (short const   )0,      (short const   )20, 
        (short const   )21,      (short const   )22,      (short const   )23,      (short const   )109, 
        (short const   )111,      (short const   )0,      (short const   )119,      (short const   )14, 
        (short const   )0,      (short const   )123,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )16,      (short const   )17,      (short const   )18, 
        (short const   )19,      (short const   )0,      (short const   )20,      (short const   )21, 
        (short const   )22,      (short const   )23,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )142,      (short const   )0,      (short const   )143,      (short const   )144, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )156,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )162,      (short const   )163,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )172,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )182,      (short const   )183, 
        (short const   )184,      (short const   )185,      (short const   )186,      (short const   )190, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )204,      (short const   )0,      (short const   )204,      (short const   )0, 
        (short const   )0,      (short const   )209,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )222,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )204,      (short const   )204,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )255,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )260,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )262,      (short const   )263,      (short const   )264, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )268,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )276,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )204, 
        (short const   )204};
short const   yycheck[1469]  = 
  {      (short const   )10,      (short const   )45,      (short const   )45,      (short const   )10, 
        (short const   )10,      (short const   )10,      (short const   )10,      (short const   )41, 
        (short const   )10,      (short const   )37,      (short const   )0,      (short const   )123, 
        (short const   )10,      (short const   )263,      (short const   )10,      (short const   )45, 
        (short const   )41,      (short const   )10,      (short const   )45,      (short const   )263, 
        (short const   )278,      (short const   )10,      (short const   )10,      (short const   )278, 
        (short const   )0,      (short const   )195,      (short const   )172,      (short const   )282, 
        (short const   )10,      (short const   )10,      (short const   )40,      (short const   )164, 
        (short const   )278,      (short const   )166,      (short const   )283,      (short const   )205, 
        (short const   )40,      (short const   )284,      (short const   )285,      (short const   )10, 
        (short const   )290,      (short const   )278,      (short const   )10,      (short const   )10, 
        (short const   )284,      (short const   )285,      (short const   )290,      (short const   )10, 
        (short const   )50,      (short const   )38,      (short const   )60,      (short const   )277, 
        (short const   )62,      (short const   )59,      (short const   )59,      (short const   )40, 
        (short const   )38,      (short const   )38,      (short const   )259,      (short const   )260, 
        (short const   )172,      (short const   )38,      (short const   )64,      (short const   )209, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )278, 
        (short const   )201,      (short const   )202,      (short const   )59,      (short const   )38, 
        (short const   )40,      (short const   )101,      (short const   )41,      (short const   )278, 
        (short const   )10,      (short const   )59,      (short const   )59,      (short const   )278, 
        (short const   )278,      (short const   )10,      (short const   )59,      (short const   )124, 
        (short const   )278,      (short const   )278,      (short const   )278,      (short const   )278, 
        (short const   )10,      (short const   )258,      (short const   )124,      (short const   )268, 
        (short const   )59,      (short const   )60,      (short const   )59,      (short const   )62, 
        (short const   )268,      (short const   )209,      (short const   )59,      (short const   )124, 
        (short const   )102,      (short const   )40,      (short const   )278,      (short const   )41, 
        (short const   )272,      (short const   )278,      (short const   )96,      (short const   )97, 
        (short const   )125,      (short const   )10,      (short const   )41,      (short const   )40, 
        (short const   )278,      (short const   )123,      (short const   )10,      (short const   )278, 
        (short const   )278,      (short const   )123,      (short const   )278,      (short const   )278, 
        (short const   )41,      (short const   )97,      (short const   )278,      (short const   )261, 
        (short const   )269,      (short const   )269,      (short const   )125,      (short const   )123, 
        (short const   )10,      (short const   )269,      (short const   )123,      (short const   )60, 
        (short const   )290,      (short const   )62,      (short const   )263,      (short const   )123, 
        (short const   )10,      (short const   )269,      (short const   )271,      (short const   )272, 
        (short const   )142,      (short const   )125,      (short const   )170,      (short const   )269, 
        (short const   )40,      (short const   )125,      (short const   )261,      (short const   )258, 
        (short const   )290,      (short const   )269,      (short const   )278,      (short const   )125, 
        (short const   )123,      (short const   )143,      (short const   )144,      (short const   )269, 
        (short const   )38,      (short const   )124,      (short const   )125,      (short const   )41, 
        (short const   )123,      (short const   )125,      (short const   )269,      (short const   )125, 
        (short const   )60,      (short const   )278,      (short const   )62,      (short const   )143, 
        (short const   )144,      (short const   )269,      (short const   )125,      (short const   )269, 
        (short const   )10,      (short const   )125,      (short const   )10,      (short const   )10, 
        (short const   )10,      (short const   )59,      (short const   )263,      (short const   )263, 
        (short const   )261,      (short const   )261,      (short const   )210,      (short const   )60, 
        (short const   )10,      (short const   )62,      (short const   )176,      (short const   )177, 
        (short const   )36,      (short const   )123,      (short const   )165,      (short const   )170, 
        (short const   )10,      (short const   )226,      (short const   )123,      (short const   )-1, 
        (short const   )188,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )38,      (short const   )177,      (short const   )-1,      (short const   )41, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )38,      (short const   )-1,      (short const   )-1,      (short const   )41, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )59,      (short const   )123,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )10,      (short const   )123, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )59,      (short const   )278,      (short const   )278, 
        (short const   )280,      (short const   )280,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )124,      (short const   )125, 
        (short const   )-1,      (short const   )-1,      (short const   )256,      (short const   )257, 
        (short const   )278,      (short const   )123,      (short const   )280,      (short const   )278, 
        (short const   )262,      (short const   )280,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )-1,      (short const   )263, 
        (short const   )270,      (short const   )271,      (short const   )268,      (short const   )-1, 
        (short const   )-1,      (short const   )275,      (short const   )276,      (short const   )274, 
        (short const   )278,      (short const   )279,      (short const   )280,      (short const   )281, 
        (short const   )268,      (short const   )278,      (short const   )278,      (short const   )268, 
        (short const   )286,      (short const   )287,      (short const   )288,      (short const   )289, 
        (short const   )268,      (short const   )291,      (short const   )292,      (short const   )293, 
        (short const   )294,      (short const   )295,      (short const   )124,      (short const   )125, 
        (short const   )-1,      (short const   )295,      (short const   )295,      (short const   )258, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )263, 
        (short const   )263,      (short const   )268,      (short const   )124,      (short const   )125, 
        (short const   )-1,      (short const   )268,      (short const   )269,      (short const   )284, 
        (short const   )285,      (short const   )268,      (short const   )-1,      (short const   )284, 
        (short const   )285,      (short const   )-1,      (short const   )278,      (short const   )278, 
        (short const   )279,      (short const   )280,      (short const   )-1,      (short const   )10, 
        (short const   )-1,      (short const   )284,      (short const   )285,      (short const   )286, 
        (short const   )287,      (short const   )288,      (short const   )289,      (short const   )290, 
        (short const   )291,      (short const   )292,      (short const   )293,      (short const   )294, 
        (short const   )257,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )262,      (short const   )268,      (short const   )264, 
        (short const   )265,      (short const   )266,      (short const   )267,      (short const   )123, 
        (short const   )274,      (short const   )270,      (short const   )271,      (short const   )-1, 
        (short const   )-1,      (short const   )40,      (short const   )275,      (short const   )276, 
        (short const   )-1,      (short const   )278,      (short const   )279,      (short const   )280, 
        (short const   )281,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )286,      (short const   )287,      (short const   )288, 
        (short const   )289,      (short const   )257,      (short const   )291,      (short const   )292, 
        (short const   )293,      (short const   )294,      (short const   )262,      (short const   )268, 
        (short const   )264,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )-1,      (short const   )274,      (short const   )270,      (short const   )271, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )278,      (short const   )279, 
        (short const   )280,      (short const   )281,      (short const   )268,      (short const   )269, 
        (short const   )-1,      (short const   )-1,      (short const   )286,      (short const   )287, 
        (short const   )288,      (short const   )289,      (short const   )268,      (short const   )291, 
        (short const   )292,      (short const   )293,      (short const   )294,      (short const   )-1, 
        (short const   )274,      (short const   )-1,      (short const   )284,      (short const   )285, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )290,      (short const   )286,      (short const   )287,      (short const   )288, 
        (short const   )289,      (short const   )10,      (short const   )291,      (short const   )-1, 
        (short const   )293,      (short const   )294,      (short const   )-1,      (short const   )-1, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )10,      (short const   )-1, 
        (short const   )123,      (short const   )-1,      (short const   )268,      (short const   )269, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )38,      (short const   )268,      (short const   )269, 
        (short const   )41,      (short const   )-1,      (short const   )284,      (short const   )285, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )290,      (short const   )-1,      (short const   )38,      (short const   )-1, 
        (short const   )-1,      (short const   )41,      (short const   )284,      (short const   )285, 
        (short const   )10,      (short const   )-1,      (short const   )59,      (short const   )-1, 
        (short const   )290,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )10,      (short const   )257,      (short const   )-1,      (short const   )59, 
        (short const   )-1,      (short const   )41,      (short const   )262,      (short const   )-1, 
        (short const   )264,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )271, 
        (short const   )38,      (short const   )-1,      (short const   )-1,      (short const   )41, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )281,      (short const   )-1,      (short const   )-1, 
        (short const   )38,      (short const   )-1,      (short const   )-1,      (short const   )41, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )59,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )59,      (short const   )182,      (short const   )183, 
        (short const   )184,      (short const   )185,      (short const   )186,      (short const   )124, 
        (short const   )125,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )38,      (short const   )-1,      (short const   )-1, 
        (short const   )41,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )124,      (short const   )125,      (short const   )-1,      (short const   )-1, 
        (short const   )204,      (short const   )38,      (short const   )-1,      (short const   )-1, 
        (short const   )41,      (short const   )-1,      (short const   )10,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )59,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )125,      (short const   )257,      (short const   )10, 
        (short const   )-1,      (short const   )-1,      (short const   )59,      (short const   )262, 
        (short const   )-1,      (short const   )264,      (short const   )265,      (short const   )266, 
        (short const   )267,      (short const   )-1,      (short const   )-1,      (short const   )125, 
        (short const   )271,      (short const   )-1,      (short const   )38,      (short const   )-1, 
        (short const   )-1,      (short const   )41,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )281,      (short const   )125, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )38, 
        (short const   )-1,      (short const   )-1,      (short const   )41,      (short const   )-1, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )59, 
        (short const   )-1,      (short const   )-1,      (short const   )262,      (short const   )263, 
        (short const   )264,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )10,      (short const   )-1,      (short const   )-1, 
        (short const   )59,      (short const   )-1,      (short const   )41,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )125,      (short const   )10,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )38,      (short const   )-1,      (short const   )-1, 
        (short const   )41,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )125,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )38,      (short const   )-1,      (short const   )-1, 
        (short const   )41,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )59,      (short const   )-1, 
        (short const   )-1,      (short const   )38,      (short const   )-1,      (short const   )-1, 
        (short const   )41,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )59,      (short const   )-1, 
        (short const   )-1,      (short const   )258,      (short const   )259,      (short const   )260, 
        (short const   )261,      (short const   )125,      (short const   )263,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )59,      (short const   )268, 
        (short const   )269,      (short const   )-1,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )125,      (short const   )263, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )268,      (short const   )269,      (short const   )-1,      (short const   )284, 
        (short const   )285,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )290,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )125,      (short const   )263, 
        (short const   )284,      (short const   )285,      (short const   )-1,      (short const   )41, 
        (short const   )268,      (short const   )269,      (short const   )290,      (short const   )-1, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )125,      (short const   )263,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )268,      (short const   )269, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )125,      (short const   )263,      (short const   )290,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )268,      (short const   )269, 
        (short const   )-1,      (short const   )-1,      (short const   )284,      (short const   )285, 
        (short const   )125,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )290,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )284,      (short const   )285, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )290,      (short const   )258,      (short const   )259,      (short const   )260, 
        (short const   )261,      (short const   )-1,      (short const   )263,      (short const   )-1, 
        (short const   )-1,      (short const   )40,      (short const   )-1,      (short const   )268, 
        (short const   )269,      (short const   )258,      (short const   )259,      (short const   )260, 
        (short const   )261,      (short const   )-1,      (short const   )263,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )268, 
        (short const   )269,      (short const   )-1,      (short const   )-1,      (short const   )284, 
        (short const   )285,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )-1,      (short const   )290,      (short const   )-1,      (short const   )125, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )284, 
        (short const   )285,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )290,      (short const   )258,      (short const   )259, 
        (short const   )260,      (short const   )261,      (short const   )-1,      (short const   )263, 
        (short const   )6,      (short const   )7,      (short const   )41,      (short const   )-1, 
        (short const   )268,      (short const   )269,      (short const   )-1,      (short const   )258, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )-1, 
        (short const   )263,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )268,      (short const   )269,      (short const   )-1, 
        (short const   )284,      (short const   )285,      (short const   )28,      (short const   )29, 
        (short const   )-1,      (short const   )-1,      (short const   )290,      (short const   )258, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )-1, 
        (short const   )263,      (short const   )284,      (short const   )285,      (short const   )-1, 
        (short const   )-1,      (short const   )268,      (short const   )269,      (short const   )290, 
        (short const   )123,      (short const   )258,      (short const   )259,      (short const   )260, 
        (short const   )261,      (short const   )-1,      (short const   )263,      (short const   )-1, 
        (short const   )-1,      (short const   )40,      (short const   )-1,      (short const   )268, 
        (short const   )269,      (short const   )258,      (short const   )259,      (short const   )260, 
        (short const   )261,      (short const   )-1,      (short const   )263,      (short const   )290, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )268, 
        (short const   )269,      (short const   )258,      (short const   )259,      (short const   )260, 
        (short const   )261,      (short const   )60,      (short const   )263,      (short const   )62, 
        (short const   )-1,      (short const   )290,      (short const   )-1,      (short const   )268, 
        (short const   )269,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )40,      (short const   )-1, 
        (short const   )-1,      (short const   )290,      (short const   )125,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )290,      (short const   )104,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )60,      (short const   )-1, 
        (short const   )62,      (short const   )-1,      (short const   )112,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )116,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )120,      (short const   )121, 
        (short const   )258,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )-1,      (short const   )263,      (short const   )-1,      (short const   )-1, 
        (short const   )40,      (short const   )-1,      (short const   )268,      (short const   )269, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )123,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )60,      (short const   )-1,      (short const   )62,      (short const   )-1, 
        (short const   )290,      (short const   )-1,      (short const   )-1,      (short const   )157, 
        (short const   )-1,      (short const   )159,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )123,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )40,      (short const   )-1,      (short const   )-1, 
        (short const   )178,      (short const   )179,      (short const   )257,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )262, 
        (short const   )-1,      (short const   )264,      (short const   )265,      (short const   )266, 
        (short const   )267,      (short const   )191,      (short const   )192,      (short const   )270, 
        (short const   )271,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )275,      (short const   )199,      (short const   )200,      (short const   )278, 
        (short const   )279,      (short const   )280,      (short const   )281,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )286, 
        (short const   )287,      (short const   )288,      (short const   )289,      (short const   )123, 
        (short const   )291,      (short const   )292,      (short const   )293,      (short const   )294, 
        (short const   )60,      (short const   )-1,      (short const   )62,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )258, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )-1, 
        (short const   )263,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )268,      (short const   )269,      (short const   )60, 
        (short const   )-1,      (short const   )62,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )244,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )252,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )290, 
        (short const   )123,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )265, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )269, 
        (short const   )270,      (short const   )-1,      (short const   )257,      (short const   )273, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )262, 
        (short const   )-1,      (short const   )264,      (short const   )265,      (short const   )266, 
        (short const   )267,      (short const   )-1,      (short const   )-1,      (short const   )270, 
        (short const   )271,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )275,      (short const   )276,      (short const   )-1,      (short const   )278, 
        (short const   )279,      (short const   )280,      (short const   )281,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )286, 
        (short const   )287,      (short const   )288,      (short const   )289,      (short const   )257, 
        (short const   )291,      (short const   )292,      (short const   )293,      (short const   )294, 
        (short const   )262,      (short const   )-1,      (short const   )264,      (short const   )265, 
        (short const   )266,      (short const   )267,      (short const   )-1,      (short const   )-1, 
        (short const   )270,      (short const   )271,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )276,      (short const   )-1, 
        (short const   )278,      (short const   )279,      (short const   )280,      (short const   )281, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )286,      (short const   )287,      (short const   )288,      (short const   )289, 
        (short const   )-1,      (short const   )291,      (short const   )292,      (short const   )293, 
        (short const   )294,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )257,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )262,      (short const   )-1, 
        (short const   )264,      (short const   )265,      (short const   )266,      (short const   )267, 
        (short const   )-1,      (short const   )-1,      (short const   )270,      (short const   )271, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )275, 
        (short const   )-1,      (short const   )-1,      (short const   )278,      (short const   )279, 
        (short const   )280,      (short const   )281,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )286,      (short const   )287, 
        (short const   )288,      (short const   )289,      (short const   )-1,      (short const   )291, 
        (short const   )292,      (short const   )293,      (short const   )294,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )257,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )262, 
        (short const   )-1,      (short const   )264,      (short const   )265,      (short const   )266, 
        (short const   )267,      (short const   )-1,      (short const   )-1,      (short const   )270, 
        (short const   )271,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )278, 
        (short const   )279,      (short const   )280,      (short const   )281,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )286, 
        (short const   )287,      (short const   )288,      (short const   )289,      (short const   )-1, 
        (short const   )291,      (short const   )292,      (short const   )293,      (short const   )294, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )278,      (short const   )279, 
        (short const   )280,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )286,      (short const   )287, 
        (short const   )288,      (short const   )289,      (short const   )-1,      (short const   )291, 
        (short const   )292,      (short const   )293,      (short const   )294,      (short const   )55, 
        (short const   )56,      (short const   )-1,      (short const   )58,      (short const   )280, 
        (short const   )-1,      (short const   )61,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )286,      (short const   )287,      (short const   )288, 
        (short const   )289,      (short const   )-1,      (short const   )291,      (short const   )292, 
        (short const   )293,      (short const   )294,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )92,      (short const   )-1,      (short const   )94,      (short const   )95, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )110,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )117,      (short const   )118,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )126,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )150,      (short const   )151, 
        (short const   )152,      (short const   )153,      (short const   )154,      (short const   )155, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )164,      (short const   )-1,      (short const   )166,      (short const   )-1, 
        (short const   )-1,      (short const   )169,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )188,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )201,      (short const   )202,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )232,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )240,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )245,      (short const   )246,      (short const   )247, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )252,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )265,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )271, 
        (short const   )272};
int yydebug  ;
int yynerrs  ;
int yyerrflag  ;
int yychar  ;
short *yyssp  ;
YYSTYPE *yyvsp  ;
YYSTYPE yyval  ;
YYSTYPE yylval  ;
short *yyss  ;
short *yysslim  ;
YYSTYPE *yyvs  ;
int yystacksize  ;
static int current_token  ;
static int last_read_token  ;
static int token_before_that  ;
static int two_tokens_ago  ;
static int token_to_read  ;
static WORD_DESC *word_desc_to_read  ;
static int parser_state  ;
int EOF_Reached  =    0;
void debug_parser(int i ) 
{ 


  {
  return;
}
}
int return_EOF(void) 
{ 


  {
  return (-1);
}
}
void initialize_bash_input(void) 
{ 


  {
  bash_input.type = (enum stream_type )0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (bash_input.name) {
      {
      free((void *)bash_input.name);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  bash_input.name = (char *)((void *)0);
  bash_input.location.file = (FILE *)((void *)0);
  bash_input.location.string = (char *)((void *)0);
  bash_input.getter = (Function *)((void *)0);
  bash_input.ungetter = (Function *)((void *)0);
  return;
}
}
void init_yy_io(Function *get , Function *unget , enum stream_type type , char *name ,
                INPUT_STREAM location ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  bash_input.type = type;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (bash_input.name) {
      {
      free((void *)bash_input.name);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (name) {
    {
    tmp = strlen((char const   *)name);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )name);
    bash_input.name = tmp___1;
    }
  } else {
    bash_input.name = (char *)((void *)0);
  }
  bash_input.location = location;
  bash_input.getter = get;
  bash_input.ungetter = unget;
  return;
}
}
int yy_getc(void) 
{ 
  int tmp ;

  {
  {
  tmp = (*(bash_input.getter))();
  }
  return (tmp);
}
}
int yy_ungetc(int c ) 
{ 
  int tmp ;

  {
  {
  tmp = (*(bash_input.ungetter))(c);
  }
  return (tmp);
}
}
int input_file_descriptor(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  if ((unsigned int )bash_input.type == 2U) {
    goto case_2;
  }
  if ((unsigned int )bash_input.type == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_2: /* CIL Label */ 
  {
  tmp = fileno(bash_input.location.file);
  }
  return (tmp);
  case_4: /* CIL Label */ 
  return (bash_input.location.buffered_fd);
  switch_default: /* CIL Label */ 
  {
  tmp___0 = fileno(stdin);
  }
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
}
}
char *current_readline_prompt  =    (char *)((void *)0);
char *current_readline_line  =    (char *)((void *)0);
int current_readline_line_index  =    0;
static int yy_readline_get(void) 
{ 
  SigHandler *old_sigint ;
  int line_len ;
  int c ;
  SigHandler *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (! current_readline_line) {
    if (! bash_readline_initialized) {
      {
      initialize_readline();
      }
    }
    if (job_control) {
      {
      give_terminal_to(shell_pgrp, 0);
      }
    }
    {
    tmp___0 = signal_is_ignored(2);
    }
    if (tmp___0 == 0) {
      {
      tmp = set_signal_handler(2, (SigHandler *)(& sigint_sighandler));
      old_sigint = tmp;
      interrupt_immediately ++;
      }
    }
    if (current_readline_prompt) {
      tmp___1 = (char const   *)current_readline_prompt;
    } else {
      tmp___1 = "";
    }
    {
    current_readline_line = readline(tmp___1);
    tmp___2 = signal_is_ignored(2);
    }
    if (tmp___2 == 0) {
      {
      interrupt_immediately --;
      set_signal_handler(2, old_sigint);
      }
    }
    if ((unsigned long )current_readline_line == (unsigned long )((char *)0)) {
      return (-1);
    }
    {
    current_readline_line_index = 0;
    tmp___3 = strlen((char const   *)current_readline_line);
    line_len = (int )tmp___3;
    current_readline_line = xrealloc((void *)current_readline_line, (size_t )(2 + line_len));
    tmp___4 = line_len;
    line_len ++;
    *(current_readline_line + tmp___4) = (char )'\n';
    *(current_readline_line + line_len) = (char )'\000';
    }
  }
  if ((int )*(current_readline_line + current_readline_line_index) == 0) {
    {
    free((void *)current_readline_line);
    current_readline_line = (char *)((void *)0);
    tmp___5 = yy_readline_get();
    }
    return (tmp___5);
  } else {
    tmp___6 = current_readline_line_index;
    current_readline_line_index ++;
    c = (int )((unsigned char )*(current_readline_line + tmp___6));
    return (c);
  }
}
}
static int yy_readline_unget(int c ) 
{ 


  {
  if (current_readline_line_index) {
    if (current_readline_line) {
      current_readline_line_index --;
      *(current_readline_line + current_readline_line_index) = (char )c;
    }
  }
  return (c);
}
}
void with_input_from_stdin(void) 
{ 
  INPUT_STREAM location ;
  int tmp ;

  {
  if ((unsigned int )bash_input.type != 1U) {
    {
    tmp = stream_on_stack((enum stream_type )1);
    }
    if (tmp == 0) {
      {
      location.string = current_readline_line;
      init_yy_io(& yy_readline_get, (Function *)(& yy_readline_unget), (enum stream_type )1,
                 (char *)"readline stdin", location);
      }
    }
  }
  return;
}
}
static int yy_string_get(void) 
{ 
  register char *string ;
  register int c ;
  char *tmp ;

  {
  string = bash_input.location.string;
  c = -1;
  if (string) {
    if (*string) {
      tmp = string;
      string ++;
      c = (int )*((unsigned char *)tmp);
      bash_input.location.string = string;
    }
  }
  return (c);
}
}
static int yy_string_unget(int c ) 
{ 


  {
  (bash_input.location.string) --;
  *(bash_input.location.string) = (char )c;
  return (c);
}
}
void with_input_from_string(char *string , char *name ) 
{ 
  INPUT_STREAM location ;

  {
  {
  location.string = string;
  init_yy_io(& yy_string_get, (Function *)(& yy_string_unget), (enum stream_type )3,
             name, location);
  }
  return;
}
}
static int yy_stream_get(void) 
{ 
  int result ;

  {
  result = -1;
  if (bash_input.location.file) {
    {
    result = getc_with_restart(bash_input.location.file);
    }
  }
  return (result);
}
}
static int yy_stream_unget(int c ) 
{ 
  int tmp ;

  {
  {
  tmp = ungetc_with_restart(c, bash_input.location.file);
  }
  return (tmp);
}
}
void with_input_from_stream(FILE *stream , char *name ) 
{ 
  INPUT_STREAM location ;

  {
  {
  location.file = stream;
  init_yy_io(& yy_stream_get, (Function *)(& yy_stream_unget), (enum stream_type )2,
             name, location);
  }
  return;
}
}
int line_number  =    0;
static int cond_lineno  ;
static int cond_token  ;
STREAM_SAVER *stream_list  =    (STREAM_SAVER *)((void *)0);
void push_stream(int reset_lineno ) 
{ 
  STREAM_SAVER *saver ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(STREAM_SAVER ));
  saver = (STREAM_SAVER *)tmp;
  xbcopy((char *)(& bash_input), (char *)(& saver->bash_input), (int )sizeof(BASH_INPUT ));
  saver->bstream = (BUFFERED_STREAM *)((void *)0);
  }
  if ((unsigned int )bash_input.type == 4U) {
    if (bash_input.location.buffered_fd >= 0) {
      {
      saver->bstream = set_buffered_stream(bash_input.location.buffered_fd, (BUFFERED_STREAM *)((void *)0));
      }
    }
  }
  saver->line = line_number;
  bash_input.name = (char *)((void *)0);
  saver->next = stream_list;
  stream_list = saver;
  EOF_Reached = 0;
  if (reset_lineno) {
    line_number = 0;
  }
  return;
}
}
void pop_stream(void) 
{ 
  STREAM_SAVER *saver ;

  {
  if (! stream_list) {
    EOF_Reached = 1;
  } else {
    {
    saver = stream_list;
    EOF_Reached = 0;
    stream_list = stream_list->next;
    init_yy_io(saver->bash_input.getter, saver->bash_input.ungetter, saver->bash_input.type,
               saver->bash_input.name, saver->bash_input.location);
    }
    if ((unsigned int )bash_input.type == 4U) {
      if (bash_input.location.buffered_fd >= 0) {
        if (bash_input_fd_changed) {
          bash_input_fd_changed = 0;
          if (default_buffered_input >= 0) {
            {
            bash_input.location.buffered_fd = default_buffered_input;
            (saver->bstream)->b_fd = default_buffered_input;
            fcntl(default_buffered_input, 2, 1);
            }
          }
        }
        {
        set_buffered_stream(bash_input.location.buffered_fd, saver->bstream);
        }
      }
    }
    line_number = saver->line;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (saver->bash_input.name) {
        {
        free((void *)saver->bash_input.name);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    free((void *)saver);
    }
  }
  return;
}
}
int stream_on_stack(enum stream_type type ) 
{ 
  register STREAM_SAVER *s ;

  {
  s = stream_list;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! s) {
      goto while_break;
    }
    if ((unsigned int )s->bash_input.type == (unsigned int )type) {
      return (1);
    }
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int *save_token_state(void) 
{ 
  int *ret ;
  char *tmp ;

  {
  {
  tmp = xmalloc(3UL * sizeof(int ));
  ret = (int *)tmp;
  *(ret + 0) = last_read_token;
  *(ret + 1) = token_before_that;
  *(ret + 2) = two_tokens_ago;
  }
  return (ret);
}
}
void restore_token_state(int *ts ) 
{ 


  {
  if ((unsigned long )ts == (unsigned long )((int *)0)) {
    return;
  }
  last_read_token = *(ts + 0);
  token_before_that = *(ts + 1);
  two_tokens_ago = *(ts + 2);
  return;
}
}
STRING_SAVER *pushed_string_list  =    (STRING_SAVER *)((void *)0);
static void push_string(char *s , int expand , alias_t *ap ) 
{ 
  STRING_SAVER *temp___0 ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(STRING_SAVER ));
  temp___0 = (STRING_SAVER *)tmp;
  temp___0->expand_alias = expand;
  temp___0->saved_line = shell_input_line;
  temp___0->saved_line_size = shell_input_line_size;
  temp___0->saved_line_index = shell_input_line_index;
  temp___0->saved_line_terminator = shell_input_line_terminator;
  temp___0->expander = ap;
  temp___0->next = pushed_string_list;
  pushed_string_list = temp___0;
  }
  if (ap) {
    ap->flags = (char )((int )ap->flags | 2);
  }
  {
  shell_input_line = s;
  tmp___0 = strlen((char const   *)s);
  shell_input_line_size = (int )tmp___0;
  shell_input_line_index = 0;
  shell_input_line_terminator = '\000';
  parser_state &= -3;
  }
  return;
}
}
static void pop_string(void) 
{ 
  STRING_SAVER *t ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (shell_input_line) {
      {
      free((void *)shell_input_line);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  shell_input_line = pushed_string_list->saved_line;
  shell_input_line_index = pushed_string_list->saved_line_index;
  shell_input_line_size = pushed_string_list->saved_line_size;
  shell_input_line_terminator = pushed_string_list->saved_line_terminator;
  if (pushed_string_list->expand_alias) {
    parser_state |= 2;
  } else {
    parser_state &= -3;
  }
  t = pushed_string_list;
  pushed_string_list = pushed_string_list->next;
  if (t->expander) {
    (t->expander)->flags = (char )((int )(t->expander)->flags & -3);
  }
  {
  free((void *)((char *)t));
  }
  return;
}
}
static void free_string_list(void) 
{ 
  register STRING_SAVER *t ;
  register STRING_SAVER *t1 ;

  {
  t = pushed_string_list;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! t) {
      goto while_break;
    }
    t1 = t->next;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (t->saved_line) {
        {
        free((void *)t->saved_line);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (t->expander) {
      (t->expander)->flags = (char )((int )(t->expander)->flags & -3);
    }
    {
    free((void *)((char *)t));
    t = t1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  pushed_string_list = (STRING_SAVER *)((void *)0);
  return;
}
}
static char *read_a_line(int remove_quoted_newline ) ;
static char *line_buffer  =    (char *)((void *)0);
static int buffer_size  =    0;
static char *read_a_line(int remove_quoted_newline ) 
{ 
  int indx ;
  int c ;
  int peekc ;
  int pass_next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  indx = 0;
  if (interactive) {
    if ((unsigned int )bash_input.type != 3U) {
      if (no_line_editing) {
        {
        print_prompt();
        }
      }
    }
  }
  pass_next = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    c = yy_getc();
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if (c == 0) {
      goto while_continue;
    }
    if (c == -1) {
      if (interactive) {
        if ((unsigned int )bash_input.type == 2U) {
          {
          clearerr(stdin);
          }
        }
      }
      if (indx == 0) {
        return ((char *)((void *)0));
      }
      c = '\n';
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (indx + 2 >= buffer_size) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (indx + 2 >= buffer_size)) {
            goto while_break___1;
          }
          buffer_size += 128;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        line_buffer = xrealloc((void *)line_buffer, (size_t )buffer_size);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (pass_next) {
      tmp = indx;
      indx ++;
      *(line_buffer + tmp) = (char )c;
      pass_next = 0;
    } else { //Added block
    if (c == 92) {
      if (remove_quoted_newline) {
        {
        peekc = yy_getc();
        }
        if (peekc == 10) {
          goto while_continue;
        } else {
          {
          yy_ungetc(peekc);
          pass_next = 1;
          tmp___0 = indx;
          indx ++;
          *(line_buffer + tmp___0) = (char )c;
          }
        }
      } else {
        tmp___1 = indx;
        indx ++;
        *(line_buffer + tmp___1) = (char )c;
      }
    } else {
      tmp___1 = indx;
      indx ++;
      *(line_buffer + tmp___1) = (char )c;
    }
    }
    if (c == 10) {
      *(line_buffer + indx) = (char )'\000';
      return (line_buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
char *read_secondary_line(int remove_quoted_newline ) 
{ 
  char *tmp ;

  {
  {
  prompt_string_pointer = & ps2_prompt;
  prompt_again();
  tmp = read_a_line(remove_quoted_newline);
  }
  return (tmp);
}
}
STRING_INT_ALIST word_token_alist[22]  = 
  {      {(char *)"if", 257}, 
        {(char *)"then", 258}, 
        {(char *)"else", 259}, 
        {(char *)"elif", 260}, 
        {(char *)"fi", 261}, 
        {(char *)"case", 262}, 
        {(char *)"esac", 263}, 
        {(char *)"for", 264}, 
        {(char *)"select", 265}, 
        {(char *)"while", 266}, 
        {(char *)"until", 267}, 
        {(char *)"do", 268}, 
        {(char *)"done", 269}, 
        {(char *)"in", 274}, 
        {(char *)"function", 270}, 
        {(char *)"time", 276}, 
        {(char *)"{", '{'}, 
        {(char *)"}", '}'}, 
        {(char *)"!", 275}, 
        {(char *)"[[", 271}, 
        {(char *)"]]", 272}, 
        {(char *)((void *)0), 0}};
struct dstack dstack  =    {(char *)((void *)0), 0, 0};
static struct dstack temp_dstack  =    {(char *)((void *)0), 0, 0};
static int eol_ungetc_lookahead  =    0;
static int shell_getc(int remove_quoted_newline ) ;
static int mustpop  =    0;
static int shell_getc(int remove_quoted_newline ) 
{ 
  register int i ;
  int c ;
  int tmp ;
  char *expansions ;
  int old_hist ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *hdcs ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  if (eol_ungetc_lookahead) {
    c = eol_ungetc_lookahead;
    eol_ungetc_lookahead = 0;
    return (c);
  }
  if (! shell_input_line) {
    goto _L___1;
  } else { //Added block
  if (! *(shell_input_line + shell_input_line_index)) {
    if ((unsigned long )pushed_string_list == (unsigned long )((STRING_SAVER *)((void *)0))) {
      _L___1: 
      line_number ++;
      restart_read: 
      if (interrupt_state) {
        {
        throw_to_top_level();
        }
      }
      {
      i = 0;
      shell_input_line_terminator = 0;
      notify_and_cleanup();
      }
      if (interactive) {
        if ((unsigned int )bash_input.type != 3U) {
          if (no_line_editing) {
            {
            print_prompt();
            }
          }
        }
      }
      if ((unsigned int )bash_input.type == 2U) {
        {
        clearerr(stdin);
        }
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        c = yy_getc();
        }
        if (interrupt_state) {
          {
          throw_to_top_level();
          }
        }
        if (c == 0) {
          goto while_continue;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (i + 2 >= shell_input_line_size) {
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (! (i + 2 >= shell_input_line_size)) {
                goto while_break___1;
              }
              shell_input_line_size += 256;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
            shell_input_line = xrealloc((void *)shell_input_line, (size_t )shell_input_line_size);
            }
          }
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        if (c == -1) {
          if ((unsigned int )bash_input.type == 2U) {
            {
            clearerr(stdin);
            }
          }
          if (i == 0) {
            shell_input_line_terminator = -1;
          }
          *(shell_input_line + i) = (char )'\000';
          goto while_break;
        }
        tmp = i;
        i ++;
        *(shell_input_line + tmp) = (char )c;
        if (c == 10) {
          i --;
          *(shell_input_line + i) = (char )'\000';
          current_command_line_count ++;
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      shell_input_line_index = 0;
      shell_input_line_len = i;
      if (remember_on_history) {
        if (shell_input_line) {
          if (*(shell_input_line + 0)) {
            old_hist = history_expansion_inhibited;
            if (dstack.delimiter_depth) {
              tmp___0 = (int )*(dstack.delimiters + (dstack.delimiter_depth - 1));
            } else {
              tmp___0 = 0;
            }
            if (tmp___0 == 39) {
              history_expansion_inhibited = 1;
            }
            {
            expansions = pre_process_line(shell_input_line, 1, 1);
            history_expansion_inhibited = old_hist;
            }
            if ((unsigned long )expansions != (unsigned long )shell_input_line) {
              {
              free((void *)shell_input_line);
              shell_input_line = expansions;
              }
              if (shell_input_line) {
                {
                tmp___1 = strlen((char const   *)shell_input_line);
                shell_input_line_len = (int )tmp___1;
                }
              } else {
                shell_input_line_len = 0;
              }
              if (! shell_input_line_len) {
                current_command_line_count --;
              }
              shell_input_line_size = shell_input_line_len;
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if (remember_on_history) {
        if (shell_input_line) {
          if ((int )*(shell_input_line + 0) == 0) {
            if (current_command_line_count > 1) {
              if (dstack.delimiter_depth) {
                tmp___2 = (int )*(dstack.delimiters + (dstack.delimiter_depth - 1));
              } else {
                tmp___2 = 0;
              }
              if (tmp___2) {
                {
                maybe_add_history(shell_input_line);
                }
              } else {
                {
                hdcs = history_delimiting_chars();
                }
                if (hdcs) {
                  if ((int )*(hdcs + 0) == 59) {
                    {
                    maybe_add_history(shell_input_line);
                    }
                  }
                }
              }
            }
          }
        }
      }
      }
      if (shell_input_line) {
        if (echo_input_at_read) {
          if (*(shell_input_line + 0)) {
            {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                    shell_input_line);
            }
          } else { //Added block
          if (shell_input_line_terminator != -1) {
            {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                    shell_input_line);
            }
          }
          }
        }
      } else {
        {
        shell_input_line_size = 0;
        prompt_string_pointer = & current_prompt_string;
        prompt_again();
        }
        goto restart_read;
      }
      if (shell_input_line_terminator != -1) {
        if (shell_input_line_len + 3 > shell_input_line_size) {
          {
          shell_input_line_size += 2;
          shell_input_line = xrealloc((void *)shell_input_line, (size_t )(1 + shell_input_line_size));
          }
        }
        *(shell_input_line + shell_input_line_len) = (char )'\n';
        *(shell_input_line + (shell_input_line_len + 1)) = (char )'\000';
      }
    }
  }
  }
  c = (int )*(shell_input_line + shell_input_line_index);
  if (c) {
    shell_input_line_index ++;
  }
  if (c == 92) {
    if (remove_quoted_newline) {
      if ((int )*(shell_input_line + shell_input_line_index) == 10) {
        {
        prompt_again();
        line_number ++;
        }
        goto restart_read;
      }
    }
  }
  if (! c) {
    if ((unsigned long )pushed_string_list != (unsigned long )((STRING_SAVER *)((void *)0))) {
      if (mustpop) {
        {
        pop_string();
        c = (int )*(shell_input_line + shell_input_line_index);
        }
        if (c) {
          shell_input_line_index ++;
        }
        mustpop --;
      } else {
        mustpop ++;
        c = ' ';
      }
    }
  }
  if (! c) {
    if (shell_input_line_terminator == -1) {
      if (shell_input_line_index != 0) {
        tmp___3 = '\n';
      } else {
        tmp___3 = -1;
      }
      return (tmp___3);
    }
  }
  return ((int )((unsigned char )c));
}
}
static void shell_ungetc(int c ) 
{ 


  {
  if (shell_input_line) {
    if (shell_input_line_index) {
      shell_input_line_index --;
      *(shell_input_line + shell_input_line_index) = (char )c;
    } else {
      eol_ungetc_lookahead = c;
    }
  } else {
    eol_ungetc_lookahead = c;
  }
  return;
}
}
static void discard_until(int character ) 
{ 
  int c ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    c = shell_getc(0);
    }
    if (c != -1) {
      if (! (c != character)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (c != -1) {
    {
    shell_ungetc(c);
    }
  }
  return;
}
}
void execute_prompt_command(char *command ) 
{ 
  Function *temp_last ;
  Function *temp_this ;
  char *last_lastarg ;
  int temp_exit_value ;
  int temp_eof_encountered ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
  temp_last = last_shell_builtin;
  temp_this = this_shell_builtin;
  temp_exit_value = last_command_exit_value;
  temp_eof_encountered = eof_encountered;
  last_lastarg = get_string_value("_");
  }
  if (last_lastarg) {
    {
    tmp = strlen((char const   *)last_lastarg);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )last_lastarg);
    last_lastarg = tmp___1;
    }
  }
  {
  tmp___2 = strlen((char const   *)command);
  tmp___3 = xmalloc(1UL + tmp___2);
  tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )command);
  parse_and_execute(tmp___4, (char *)"PROMPT_COMMAND", 5);
  last_shell_builtin = temp_last;
  this_shell_builtin = temp_this;
  last_command_exit_value = temp_exit_value;
  eof_encountered = temp_eof_encountered;
  bind_variable((char *)"_", last_lastarg);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (last_lastarg) {
      {
      free((void *)last_lastarg);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (token_to_read == 10) {
    token_to_read = 0;
  }
  return;
}
}
static char *token  =    (char *)((void *)0);
static int token_buffer_size  ;
static int yylex(void) 
{ 
  int tmp ;

  {
  if (interactive) {
    if (current_token == 0) {
      goto _L___0;
    } else { //Added block
    if (current_token == 10) {
      _L___0: 
      if (! prompt_string_pointer) {
        goto _L;
      } else { //Added block
      if ((unsigned long )prompt_string_pointer == (unsigned long )(& ps1_prompt)) {
        _L: 
        {
        tmp = time_to_check_mail();
        }
        if (tmp) {
          {
          check_mail();
          reset_mail_timer();
          }
        }
      }
      }
      if (token_to_read == 0) {
        if (interactive) {
          {
          prompt_again();
          }
        }
      }
    }
    }
  }
  {
  two_tokens_ago = token_before_that;
  token_before_that = last_read_token;
  last_read_token = current_token;
  current_token = read_token(0);
  }
  return (current_token);
}
}
static int esacs_needed_count  ;
void gather_here_documents(void) 
{ 
  int r ;
  int tmp ;

  {
  r = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! need_here_doc) {
      goto while_break;
    }
    {
    tmp = r;
    r ++;
    make_here_document(redir_stack[tmp]);
    need_here_doc --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int open_brace_count  ;
static int alias_expand_token(char *token___0 ) 
{ 
  char *expanded ;
  alias_t *ap ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  if (parser_state & 2) {
    goto _L___0;
  } else { //Added block
  if (last_read_token == 279) {
    goto _L___0;
  } else { //Added block
  if (last_read_token != 290) {
    {
    tmp___2 = reserved_word_acceptable(last_read_token);
    }
    if (tmp___2) {
      _L___0: 
      if ((parser_state & 1) == 0) {
        {
        ap = find_alias(token___0);
        }
        if (ap) {
          if ((int )ap->flags & 2) {
            return (-100);
          }
        }
        if (ap) {
          {
          tmp = strlen((char const   *)ap->value);
          tmp___0 = xmalloc(1UL + tmp);
          tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )ap->value);
          expanded = tmp___1;
          }
        } else {
          expanded = (char *)((void *)0);
        }
        if (expanded) {
          {
          push_string(expanded, (int )ap->flags & 1, ap);
          }
          return (-99);
        } else {
          return (-100);
        }
      }
    }
  }
  }
  }
  return (-100);
}
}
static int time_command_acceptable(void) 
{ 


  {
  {
  if (last_read_token == 0) {
    goto case_0;
  }
  if (last_read_token == 59) {
    goto case_0;
  }
  if (last_read_token == 10) {
    goto case_0;
  }
  if (last_read_token == 284) {
    goto case_0;
  }
  if (last_read_token == 285) {
    goto case_0;
  }
  if (last_read_token == 38) {
    goto case_0;
  }
  if (last_read_token == 268) {
    goto case_0;
  }
  if (last_read_token == 258) {
    goto case_0;
  }
  if (last_read_token == 259) {
    goto case_0;
  }
  if (last_read_token == 123) {
    goto case_0;
  }
  if (last_read_token == 40) {
    goto case_0;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_284: /* CIL Label */ 
  case_285: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_268: /* CIL Label */ 
  case_258: /* CIL Label */ 
  case_259: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_40: /* CIL Label */ 
  return (1);
  switch_default: /* CIL Label */ 
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
static int special_case_tokens(char *token___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (last_read_token == 278) {
    if (token_before_that == 264) {
      goto _L;
    } else { //Added block
    if (token_before_that == 262) {
      goto _L;
    } else { //Added block
    if (token_before_that == 265) {
      _L: 
      if ((int )*(token___0 + 0) == 105) {
        if ((int )*(token___0 + 1) == 110) {
          if ((int )*(token___0 + 2) == 0) {
            if (token_before_that == 262) {
              parser_state |= 1;
              esacs_needed_count ++;
            }
            return (274);
          }
        }
      }
    }
    }
    }
  }
  if (last_read_token == 278) {
    if (token_before_that == 264) {
      goto _L___0;
    } else { //Added block
    if (token_before_that == 265) {
      _L___0: 
      if ((int )*(token___0 + 0) == 100) {
        if ((int )*(token___0 + 1) == 111) {
          if ((int )*(token___0 + 2) == 0) {
            return (268);
          }
        }
      }
    }
    }
  }
  if (esacs_needed_count) {
    esacs_needed_count --;
    if ((int )*(token___0 + 0) == (int )*("esac" + 0)) {
      {
      tmp = strcmp((char const   *)token___0, "esac");
      }
      if (tmp == 0) {
        parser_state &= -2;
        return (263);
      }
    }
  }
  if (parser_state & 4) {
    parser_state &= -5;
    if ((int )*(token___0 + 0) == 123) {
      if ((int )*(token___0 + 1) == 0) {
        open_brace_count ++;
        function_bstart = line_number;
        return ('{');
      }
    }
  }
  if (last_read_token == 282) {
    if ((int )*(token___0 + 0) == 100) {
      if ((int )*(token___0 + 1) == 111) {
        if (! *(token___0 + 2)) {
          return (268);
        }
      }
    }
  }
  if (last_read_token == 282) {
    if ((int )*(token___0 + 0) == 123) {
      if ((int )*(token___0 + 1) == 0) {
        open_brace_count ++;
        return ('{');
      }
    }
  }
  if (open_brace_count) {
    {
    tmp___0 = reserved_word_acceptable(last_read_token);
    }
    if (tmp___0) {
      if ((int )*(token___0 + 0) == 125) {
        if (! *(token___0 + 1)) {
          open_brace_count --;
          return ('}');
        }
      }
    }
  }
  if (last_read_token == 276) {
    if ((int )*(token___0 + 0) == 45) {
      if ((int )*(token___0 + 1) == 112) {
        if (! *(token___0 + 2)) {
          return (277);
        }
      }
    }
  }
  if ((int )*(token___0 + 0) == (int )*("time" + 0)) {
    {
    tmp___1 = strcmp((char const   *)token___0, "time");
    }
    if (tmp___1 == 0) {
      if ((parser_state & 1) == 0) {
        {
        tmp___2 = time_command_acceptable();
        }
        if (tmp___2) {
          return (276);
        }
      }
    }
  }
  if (parser_state & 512) {
    if ((int )*(token___0 + 0) == 93) {
      if ((int )*(token___0 + 1) == 93) {
        if ((int )*(token___0 + 2) == 0) {
          return (272);
        }
      }
    }
  }
  return (-1);
}
}
void reset_parser(void) 
{ 


  {
  dstack.delimiter_depth = 0;
  open_brace_count = 0;
  parser_state = 0;
  if (pushed_string_list) {
    {
    free_string_list();
    }
  }
  if (shell_input_line) {
    {
    free((void *)shell_input_line);
    shell_input_line = (char *)((void *)0);
    shell_input_line_index = 0;
    shell_input_line_size = shell_input_line_index;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (word_desc_to_read) {
      {
      free((void *)word_desc_to_read);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  word_desc_to_read = (WORD_DESC *)((void *)0);
  last_read_token = '\n';
  token_to_read = '\n';
  return;
}
}
static int read_token(int command ) 
{ 
  int character ;
  int peek_char ;
  int result ;
  int cmdtyp ;
  int len___0 ;
  char *wval ;
  char *wv2 ;
  WORD_DESC *wd ;
  size_t tmp ;
  int cmdtyp___0 ;
  int sline ;
  char *wval___0 ;
  WORD_DESC *wd___0 ;
  int tmp___0 ;

  {
  if (command == 1) {
    {
    reset_parser();
    }
    return ('\n');
  }
  if (token_to_read) {
    result = token_to_read;
    if (token_to_read == 278) {
      yylval.word = word_desc_to_read;
      word_desc_to_read = (WORD_DESC *)((void *)0);
    } else { //Added block
    if (token_to_read == 279) {
      yylval.word = word_desc_to_read;
      word_desc_to_read = (WORD_DESC *)((void *)0);
    }
    }
    token_to_read = 0;
    return (result);
  }
  if ((parser_state & 768) == 256) {
    {
    cond_lineno = line_number;
    parser_state |= 512;
    yylval.command = parse_cond_command();
    }
    if (cond_token != 272) {
      if (EOF_Reached) {
        if (cond_token != 273) {
          {
          parser_error(cond_lineno, "unexpected EOF while looking for `]]\'");
          }
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (cond_token != 273) {
        {
        parser_error(cond_lineno, "syntax error in conditional expression");
        }
      }
      }
      return (-1);
    }
    token_to_read = 272;
    parser_state &= -769;
    return (283);
  }
  re_read_token: 
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    character = shell_getc(1);
    }
    if (character != -1) {
      if (! (character == 32)) {
        if (! (character == 9)) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (character == -1) {
    EOF_Reached = 1;
    return (295);
  }
  if (character == 35) {
    if (! interactive) {
      {
      discard_until('\n');
      shell_getc(0);
      character = '\n';
      }
    } else { //Added block
    if (interactive_comments) {
      {
      discard_until('\n');
      shell_getc(0);
      character = '\n';
      }
    }
    }
  }
  if (character == 10) {
    if (need_here_doc) {
      {
      gather_here_documents();
      }
    }
    parser_state &= -3;
    return (character);
  }
  if (sh_syntaxtab[character] & 1) {
    if ((parser_state & 16) == 0) {
      if (character == 60) {
        parser_state &= -3;
      } else { //Added block
      if (character == 62) {
        parser_state &= -3;
      }
      }
      {
      peek_char = shell_getc(1);
      }
      if (character == peek_char) {
        {
        if (character == 60) {
          goto case_60;
        }
        if (character == 62) {
          goto case_62;
        }
        if (character == 59) {
          goto case_59;
        }
        if (character == 38) {
          goto case_38;
        }
        if (character == 124) {
          goto case_124;
        }
        if (character == 40) {
          goto case_40;
        }
        goto switch_break;
        case_60: /* CIL Label */ 
        {
        peek_char = shell_getc(1);
        }
        if (peek_char == 45) {
          return (291);
        } else {
          {
          shell_ungetc(peek_char);
          }
          return (287);
        }
        case_62: /* CIL Label */ 
        return (286);
        case_59: /* CIL Label */ 
        parser_state |= 1;
        parser_state &= -3;
        return (290);
        case_38: /* CIL Label */ 
        return (284);
        case_124: /* CIL Label */ 
        return (285);
        case_40: /* CIL Label */ 
        if (last_read_token == 264) {
          {
          arith_for_lineno = line_number;
          cmdtyp = parse_arith_cmd(& wval);
          }
          if (cmdtyp == 1) {
            {
            tmp = strlen((char const   *)wval);
            len___0 = (int )tmp;
            wv2 = xmalloc((size_t )len___0);
            strncpy((char * __restrict  )wv2, (char const   * __restrict  )(wval + 1),
                    (size_t )(len___0 - 2));
            *(wv2 + (len___0 - 2)) = (char )'\000';
            wd = make_word(wv2);
            yylval.word_list = make_word_list(wd, (WORD_LIST *)((void *)0));
            free((void *)wval);
            free((void *)wv2);
            }
            return (282);
          } else {
            return (-1);
          }
        }
        {
        tmp___0 = reserved_word_acceptable(last_read_token);
        }
        if (tmp___0) {
          {
          sline = line_number;
          cmdtyp___0 = parse_arith_cmd(& wval___0);
          }
          if (cmdtyp___0 == 1) {
            {
            wd___0 = make_word(wval___0);
            wd___0->flags = 2;
            yylval.word_list = make_word_list(wd___0, (WORD_LIST *)((void *)0));
            free((void *)wval___0);
            }
            return (281);
          } else { //Added block
          if (cmdtyp___0 == 0) {
            {
            push_string(wval___0, 0, (alias_t *)((void *)0));
            }
            if ((parser_state & 1) == 0) {
              parser_state |= 32;
            }
            return (character);
          } else {
            return (-1);
          }
          }
        }
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else { //Added block
      if (character == 60) {
        if (peek_char == 38) {
          return (288);
        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: 
      if (character == 62) {
        if (peek_char == 38) {
          return (289);
        } else {
          goto _L___2;
        }
      } else { //Added block
      _L___2: 
      if (character == 60) {
        if (peek_char == 62) {
          return (293);
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (character == 62) {
        if (peek_char == 124) {
          return (294);
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if (peek_char == 62) {
        if (character == 38) {
          return (292);
        }
      }
      }
      }
      }
      }
      }
      {
      shell_ungetc(peek_char);
      }
      if (character == 41) {
        if (last_read_token == 40) {
          if (token_before_that == 278) {
            parser_state |= 4;
            parser_state &= -3;
            function_dstart = line_number;
          }
        }
      }
      if (character == 40) {
        if ((parser_state & 1) == 0) {
          parser_state |= 32;
        } else {
          goto _L___5;
        }
      } else { //Added block
      _L___5: 
      if (parser_state & 1) {
        if (character == 41) {
          parser_state &= -2;
        } else {
          goto _L___4;
        }
      } else { //Added block
      _L___4: 
      if (parser_state & 32) {
        if (character == 41) {
          parser_state &= -33;
        }
      }
      }
      }
      if (posixly_correct) {
        return (character);
      } else { //Added block
      if (character != 62) {
        if (character != 60) {
          return (character);
        } else {
          goto _L___6;
        }
      } else { //Added block
      _L___6: 
      if (peek_char != 40) {
        return (character);
      }
      }
      }
    }
  }
  if (character == 45) {
    if (last_read_token == 288) {
      return (character);
    } else { //Added block
    if (last_read_token == 289) {
      return (character);
    }
    }
  }
  {
  result = read_token_word(character);
  }
  if (result == -99) {
    goto re_read_token;
  }
  return (result);
}
}
static char matched_pair_error  ;
static char *parse_matched_pair(int qc , int open___0 , int close___0 , int *lenp ,
                                int flags ) 
{ 
  int count ;
  int ch ;
  int was_dollar ;
  int pass_next_character ;
  int nestlen ;
  int ttranslen ;
  int start_lineno ;
  char *ret ;
  char *nestret ;
  char *ttrans ;
  int retind ;
  int retsize ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
  count = 1;
  was_dollar = 0;
  pass_next_character = was_dollar;
  retsize = 64;
  ret = xmalloc((size_t )retsize);
  retind = 0;
  start_lineno = line_number;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! count) {
      goto while_break;
    }
    if (qc != 39) {
      goto _L;
    } else { //Added block
    if (flags & 2) {
      _L: 
      if (pass_next_character == 0) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    }
    {
    ch = shell_getc(tmp);
    }
    if (ch == -1) {
      {
      free((void *)ret);
      parser_error(start_lineno, "unexpected EOF while looking for matching `%c\'",
                   close___0);
      EOF_Reached = 1;
      }
      return (& matched_pair_error);
    }
    if (ch == 10) {
      if (interactive) {
        if ((unsigned int )bash_input.type == 1U) {
          {
          prompt_again();
          }
        } else { //Added block
        if ((unsigned int )bash_input.type == 2U) {
          {
          prompt_again();
          }
        }
        }
      }
    }
    if (pass_next_character) {
      pass_next_character = 0;
      if (qc != 39) {
        if (ch == 10) {
          if (retind > 0) {
            retind --;
          }
          goto while_continue;
        }
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (retind + 2 >= retsize) {
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (retind + 2 >= retsize)) {
              goto while_break___1;
            }
            retsize += 64;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
          ret = xrealloc((void *)ret, (size_t )retsize);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (ch == 1) {
        tmp___0 = retind;
        retind ++;
        *(ret + tmp___0) = (char )'\001';
      } else { //Added block
      if (ch == 127) {
        tmp___0 = retind;
        retind ++;
        *(ret + tmp___0) = (char )'\001';
      }
      }
      tmp___1 = retind;
      retind ++;
      *(ret + tmp___1) = (char )ch;
      goto while_continue;
    } else { //Added block
    if (ch == 1) {
      goto _L___3;
    } else { //Added block
    if (ch == 127) {
      _L___3: 
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (retind + 2 >= retsize) {
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if (! (retind + 2 >= retsize)) {
              goto while_break___3;
            }
            retsize += 64;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
          ret = xrealloc((void *)ret, (size_t )retsize);
          }
        }
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      tmp___2 = retind;
      retind ++;
      *(ret + tmp___2) = (char )'\001';
      tmp___3 = retind;
      retind ++;
      *(ret + tmp___3) = (char )ch;
      goto while_continue;
    } else { //Added block
    if (ch == close___0) {
      count --;
    } else { //Added block
    if (open___0 != close___0) {
      if (was_dollar) {
        if (open___0 == 123) {
          if (ch == open___0) {
            count ++;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if ((flags & 1) == 0) {
      if (ch == open___0) {
        count ++;
      }
    }
    }
    }
    }
    }
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (retind + 1 >= retsize) {
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          if (! (retind + 1 >= retsize)) {
            goto while_break___5;
          }
          retsize += 64;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
        ret = xrealloc((void *)ret, (size_t )retsize);
        }
      }
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    tmp___4 = retind;
    retind ++;
    *(ret + tmp___4) = (char )ch;
    if (open___0 == 39) {
      if (flags & 2) {
        if (ch == 92) {
          pass_next_character ++;
        }
      }
      goto while_continue;
    }
    if (ch == 92) {
      pass_next_character ++;
    }
    if (open___0 != close___0) {
      if (sh_syntaxtab[ch] & 8) {
        {
        while (1) {
          while_continue___6: /* CIL Label */ ;
          if (dstack.delimiter_depth + 2 > dstack.delimiter_space) {
            {
            dstack.delimiter_space += 10;
            dstack.delimiters = xrealloc((void *)dstack.delimiters, (unsigned long )dstack.delimiter_space * sizeof(char ));
            }
          }
          *(dstack.delimiters + dstack.delimiter_depth) = (char )ch;
          (dstack.delimiter_depth) ++;
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        if (was_dollar) {
          if (ch == 39) {
            {
            nestret = parse_matched_pair(ch, ch, ch, & nestlen, 2);
            }
          } else {
            {
            nestret = parse_matched_pair(ch, ch, ch, & nestlen, 0);
            }
          }
        } else {
          {
          nestret = parse_matched_pair(ch, ch, ch, & nestlen, 0);
          }
        }
        (dstack.delimiter_depth) --;
        if ((unsigned long )nestret == (unsigned long )(& matched_pair_error)) {
          {
          free((void *)ret);
          }
          return (& matched_pair_error);
        }
        if (was_dollar) {
          if (ch == 39) {
            {
            ttrans = ansiexpand(nestret, 0, nestlen - 1, & ttranslen);
            free((void *)nestret);
            nestret = sh_single_quote(ttrans);
            free((void *)ttrans);
            tmp___5 = strlen((char const   *)nestret);
            nestlen = (int )tmp___5;
            retind -= 2;
            }
          } else {
            goto _L___4;
          }
        } else { //Added block
        _L___4: 
        if (was_dollar) {
          if (ch == 34) {
            {
            ttrans = localeexpand(nestret, 0, nestlen - 1, start_lineno, & ttranslen);
            free((void *)nestret);
            nestret = xmalloc((size_t )(ttranslen + 3));
            *(nestret + 0) = (char )'\"';
            strcpy((char * __restrict  )(nestret + 1), (char const   * __restrict  )ttrans);
            *(nestret + (ttranslen + 1)) = (char )'\"';
            ttranslen += 2;
            *(nestret + ttranslen) = (char )'\000';
            free((void *)ttrans);
            nestlen = ttranslen;
            retind -= 2;
            }
          }
        }
        }
        if (nestlen) {
          {
          while (1) {
            while_continue___7: /* CIL Label */ ;
            if (retind + nestlen >= retsize) {
              {
              while (1) {
                while_continue___8: /* CIL Label */ ;
                if (! (retind + nestlen >= retsize)) {
                  goto while_break___8;
                }
                retsize += 64;
              }
              while_break___8: /* CIL Label */ ;
              }
              {
              ret = xrealloc((void *)ret, (size_t )retsize);
              }
            }
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
          strcpy((char * __restrict  )(ret + retind), (char const   * __restrict  )nestret);
          retind += nestlen;
          }
        }
        {
        while (1) {
          while_continue___9: /* CIL Label */ ;
          if (nestret) {
            {
            free((void *)nestret);
            }
          }
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    } else { //Added block
    if (open___0 == 34) {
      if (ch == 96) {
        {
        nestret = parse_matched_pair(0, '`', '`', & nestlen, 0);
        }
        if ((unsigned long )nestret == (unsigned long )(& matched_pair_error)) {
          {
          free((void *)ret);
          }
          return (& matched_pair_error);
        }
        if (nestlen) {
          {
          while (1) {
            while_continue___10: /* CIL Label */ ;
            if (retind + nestlen >= retsize) {
              {
              while (1) {
                while_continue___11: /* CIL Label */ ;
                if (! (retind + nestlen >= retsize)) {
                  goto while_break___11;
                }
                retsize += 64;
              }
              while_break___11: /* CIL Label */ ;
              }
              {
              ret = xrealloc((void *)ret, (size_t )retsize);
              }
            }
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
          strcpy((char * __restrict  )(ret + retind), (char const   * __restrict  )nestret);
          retind += nestlen;
          }
        }
        {
        while (1) {
          while_continue___12: /* CIL Label */ ;
          if (nestret) {
            {
            free((void *)nestret);
            }
          }
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      } else {
        goto _L___6;
      }
    } else { //Added block
    _L___6: 
    if (was_dollar) {
      if (ch == 40) {
        goto _L___5;
      } else { //Added block
      if (ch == 123) {
        goto _L___5;
      } else { //Added block
      if (ch == 91) {
        _L___5: 
        if (open___0 == ch) {
          count --;
        }
        if (ch == 40) {
          {
          nestret = parse_matched_pair(0, '(', ')', & nestlen, 0);
          }
        } else { //Added block
        if (ch == 123) {
          {
          nestret = parse_matched_pair(0, '{', '}', & nestlen, 1);
          }
        } else { //Added block
        if (ch == 91) {
          {
          nestret = parse_matched_pair(0, '[', ']', & nestlen, 0);
          }
        }
        }
        }
        if ((unsigned long )nestret == (unsigned long )(& matched_pair_error)) {
          {
          free((void *)ret);
          }
          return (& matched_pair_error);
        }
        if (nestlen) {
          {
          while (1) {
            while_continue___13: /* CIL Label */ ;
            if (retind + nestlen >= retsize) {
              {
              while (1) {
                while_continue___14: /* CIL Label */ ;
                if (! (retind + nestlen >= retsize)) {
                  goto while_break___14;
                }
                retsize += 64;
              }
              while_break___14: /* CIL Label */ ;
              }
              {
              ret = xrealloc((void *)ret, (size_t )retsize);
              }
            }
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
          strcpy((char * __restrict  )(ret + retind), (char const   * __restrict  )nestret);
          retind += nestlen;
          }
        }
        {
        while (1) {
          while_continue___15: /* CIL Label */ ;
          if (nestret) {
            {
            free((void *)nestret);
            }
          }
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      }
      }
    }
    }
    }
    was_dollar = ch == 36;
  }
  while_break: /* CIL Label */ ;
  }
  *(ret + retind) = (char )'\000';
  if (lenp) {
    *lenp = retind;
  }
  return (ret);
}
}
static int parse_arith_cmd(char **ep ) 
{ 
  int exp_lineno ;
  int rval ;
  int c ;
  char *ttok ;
  char *token___0 ;
  int ttoklen ;

  {
  {
  exp_lineno = line_number;
  ttok = parse_matched_pair(0, '(', ')', & ttoklen, 0);
  rval = 1;
  }
  if ((unsigned long )ttok == (unsigned long )(& matched_pair_error)) {
    return (-1);
  }
  {
  c = shell_getc(0);
  }
  if (c != 41) {
    rval = 0;
  }
  {
  token___0 = xmalloc((size_t )(ttoklen + 4));
  }
  if (rval == 1) {
    *(token___0 + 0) = (char )'\"';
  } else {
    *(token___0 + 0) = (char )'(';
  }
  {
  strncpy((char * __restrict  )(token___0 + 1), (char const   * __restrict  )ttok,
          (size_t )(ttoklen - 1));
  }
  if (rval == 1) {
    *(token___0 + ttoklen) = (char )'\"';
    *(token___0 + (ttoklen + 1)) = (char )'\000';
  } else {
    *(token___0 + ttoklen) = (char )')';
    *(token___0 + (ttoklen + 1)) = (char )c;
    *(token___0 + (ttoklen + 2)) = (char )'\000';
  }
  *ep = token___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (ttok) {
      {
      free((void *)ttok);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return (rval);
}
}
static COND_COM *cond_term(void) ;
static COND_COM *cond_and(void) ;
static COND_COM *cond_or(void) ;
static COND_COM *cond_expr(void) ;
static COND_COM *cond_expr(void) 
{ 
  COND_COM *tmp ;

  {
  {
  tmp = cond_or();
  }
  return (tmp);
}
}
static COND_COM *cond_or(void) 
{ 
  COND_COM *l ;
  COND_COM *r ;

  {
  {
  l = cond_and();
  }
  if (cond_token == 285) {
    {
    r = cond_or();
    l = make_cond_node(2, (WORD_DESC *)((void *)0), l, r);
    }
  }
  return (l);
}
}
static COND_COM *cond_and(void) 
{ 
  COND_COM *l ;
  COND_COM *r ;

  {
  {
  l = cond_term();
  }
  if (cond_token == 284) {
    {
    r = cond_and();
    l = make_cond_node(1, (WORD_DESC *)((void *)0), l, r);
    }
  }
  return (l);
}
}
static int cond_skip_newlines(void) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    cond_token = read_token(0);
    }
    if (! (cond_token == 10)) {
      goto while_break;
    }
    if (interactive) {
      if ((unsigned int )bash_input.type == 1U) {
        {
        prompt_again();
        }
      } else { //Added block
      if ((unsigned int )bash_input.type == 2U) {
        {
        prompt_again();
        }
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (cond_token);
}
}
int test_binop(char *op ) ;
int test_unop(char *op ) ;
static COND_COM *cond_term(void) 
{ 
  WORD_DESC *op ;
  COND_COM *term___0 ;
  COND_COM *tleft ;
  COND_COM *tright ;
  int tok ;
  int lineno ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tok = cond_skip_newlines();
  lineno = line_number;
  }
  if (tok == 272) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      cond_token = 273;
      return ((COND_COM *)((void *)0));
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if (tok == 40) {
    {
    term___0 = cond_expr();
    }
    if (cond_token != 41) {
      if (term___0) {
        {
        dispose_cond_node(term___0);
        }
      }
      {
      parser_error(lineno, "expected `)\'");
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        cond_token = 273;
        return ((COND_COM *)((void *)0));
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    term___0 = make_cond_node(6, (WORD_DESC *)((void *)0), term___0, (COND_COM *)((void *)0));
    cond_skip_newlines();
    }
  } else { //Added block
  if (tok == 275) {
    goto _L___1;
  } else { //Added block
  if (tok == 278) {
    if ((int )*((yylval.word)->word + 0) == 33) {
      if ((int )*((yylval.word)->word + 1) == 0) {
        _L___1: 
        if (tok == 278) {
          {
          dispose_word(yylval.word);
          }
        }
        {
        term___0 = cond_term();
        }
        if (term___0) {
          term___0->flags |= 4;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if (tok == 278) {
    {
    tmp___0 = test_unop((yylval.word)->word);
    }
    if (tmp___0) {
      {
      op = yylval.word;
      tok = read_token(0);
      }
      if (tok == 278) {
        {
        tleft = make_cond_node(5, yylval.word, (COND_COM *)((void *)0), (COND_COM *)((void *)0));
        term___0 = make_cond_node(3, op, tleft, (COND_COM *)((void *)0));
        }
      } else {
        {
        dispose_word(op);
        parser_error(line_number, "unexpected argument to conditional unary operator");
        }
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          cond_token = 273;
          return ((COND_COM *)((void *)0));
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
      cond_skip_newlines();
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (tok == 278) {
    {
    tleft = make_cond_node(5, yylval.word, (COND_COM *)((void *)0), (COND_COM *)((void *)0));
    tok = read_token(0);
    }
    if (tok == 278) {
      {
      tmp = test_binop((yylval.word)->word);
      }
      if (tmp) {
        op = yylval.word;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (tok == 60) {
      {
      op = make_word_from_token(tok);
      }
    } else { //Added block
    if (tok == 62) {
      {
      op = make_word_from_token(tok);
      }
    } else { //Added block
    if (tok == 272) {
      {
      op = make_word((char *)"-n");
      term___0 = make_cond_node(3, op, tleft, (COND_COM *)((void *)0));
      cond_token = tok;
      }
      return (term___0);
    } else { //Added block
    if (tok == 284) {
      {
      op = make_word((char *)"-n");
      term___0 = make_cond_node(3, op, tleft, (COND_COM *)((void *)0));
      cond_token = tok;
      }
      return (term___0);
    } else { //Added block
    if (tok == 285) {
      {
      op = make_word((char *)"-n");
      term___0 = make_cond_node(3, op, tleft, (COND_COM *)((void *)0));
      cond_token = tok;
      }
      return (term___0);
    } else { //Added block
    if (tok == 41) {
      {
      op = make_word((char *)"-n");
      term___0 = make_cond_node(3, op, tleft, (COND_COM *)((void *)0));
      cond_token = tok;
      }
      return (term___0);
    } else {
      {
      parser_error(line_number, "conditional binary operator expected");
      dispose_cond_node(tleft);
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        cond_token = 273;
        return ((COND_COM *)((void *)0));
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    }
    }
    }
    }
    }
    }
    {
    tok = read_token(0);
    }
    if (tok == 278) {
      {
      tright = make_cond_node(5, yylval.word, (COND_COM *)((void *)0), (COND_COM *)((void *)0));
      term___0 = make_cond_node(4, op, tleft, tright);
      }
    } else {
      {
      parser_error(line_number, "unexpected argument to conditional binary operator");
      dispose_cond_node(tleft);
      dispose_word(op);
      }
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        cond_token = 273;
        return ((COND_COM *)((void *)0));
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    cond_skip_newlines();
    }
  } else {
    if (tok < 256) {
      {
      parser_error(line_number, "unexpected token `%c\' in conditional command", tok);
      }
    } else {
      {
      parser_error(line_number, "unexpected token %d in conditional command", tok);
      }
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      cond_token = 273;
      return ((COND_COM *)((void *)0));
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  }
  }
  }
  }
  }
  return (term___0);
}
}
static COMMAND *parse_cond_command(void) 
{ 
  COND_COM *cexp ;
  COMMAND *tmp ;

  {
  {
  cexp = cond_expr();
  tmp = make_cond_command(cexp);
  }
  return (tmp);
}
}
static int read_token_word(int character ) 
{ 
  WORD_DESC *the_word ;
  int token_index ;
  int all_digits___0 ;
  int dollar_present ;
  int quoted ;
  int pass_next_character ;
  int cd ;
  int result ;
  int peek_char ;
  char *ttok ;
  char *ttrans ;
  int ttoklen ;
  int ttranslen ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int first_line ;
  int tmp___7 ;
  size_t tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int i ;
  int tmp___16 ;
  int tmp___17 ;
  int i___0 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  if (token_buffer_size < 496) {
    {
    token_buffer_size = 496;
    token = xrealloc((void *)token, (size_t )token_buffer_size);
    }
  }
  {
  token_index = 0;
  tmp = __ctype_b_loc();
  all_digits___0 = (int )((int const   )*(*tmp + character) & 2048);
  pass_next_character = 0;
  quoted = pass_next_character;
  dollar_present = quoted;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (character == -1) {
      goto got_token;
    }
    if (pass_next_character) {
      pass_next_character = 0;
      goto got_character;
    }
    if (dstack.delimiter_depth) {
      cd = (int )*(dstack.delimiters + (dstack.delimiter_depth - 1));
    } else {
      cd = 0;
    }
    if (character == 92) {
      {
      peek_char = shell_getc(0);
      }
      if (peek_char == 10) {
        character = '\n';
        goto next_character;
      } else {
        {
        shell_ungetc(peek_char);
        }
        if (cd == 0) {
          pass_next_character ++;
        } else { //Added block
        if (cd == 96) {
          pass_next_character ++;
        } else { //Added block
        if (cd == 34) {
          if (sh_syntaxtab[peek_char] & 64) {
            pass_next_character ++;
          }
        }
        }
        }
        quoted = 1;
        goto got_character;
      }
    }
    if (sh_syntaxtab[character] & 8) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (dstack.delimiter_depth + 2 > dstack.delimiter_space) {
          {
          dstack.delimiter_space += 10;
          dstack.delimiters = xrealloc((void *)dstack.delimiters, (unsigned long )dstack.delimiter_space * sizeof(char ));
          }
        }
        *(dstack.delimiters + dstack.delimiter_depth) = (char )character;
        (dstack.delimiter_depth) ++;
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      ttok = parse_matched_pair(character, character, character, & ttoklen, 0);
      (dstack.delimiter_depth) --;
      }
      if ((unsigned long )ttok == (unsigned long )(& matched_pair_error)) {
        return (-1);
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (token_index + (ttoklen + 2) >= token_buffer_size) {
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! (token_index + (ttoklen + 2) >= token_buffer_size)) {
              goto while_break___2;
            }
            token_buffer_size += 512;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
          token = xrealloc((void *)token, (size_t )token_buffer_size);
          }
        }
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      tmp___0 = token_index;
      token_index ++;
      *(token + tmp___0) = (char )character;
      strcpy((char * __restrict  )(token + token_index), (char const   * __restrict  )ttok);
      token_index += ttoklen;
      all_digits___0 = 0;
      quoted = 1;
      }
      if (character == 34) {
        {
        tmp___1 = strchr((char const   *)ttok, '$');
        }
        if ((unsigned long )tmp___1 != (unsigned long )((char *)0)) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      dollar_present |= tmp___2;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (ttok) {
          {
          free((void *)ttok);
          }
        }
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      goto next_character;
    }
    if (extended_glob) {
      if (character == 64) {
        goto _L;
      } else { //Added block
      if (character == 42) {
        goto _L;
      } else { //Added block
      if (character == 43) {
        goto _L;
      } else { //Added block
      if (character == 63) {
        goto _L;
      } else { //Added block
      if (character == 33) {
        _L: 
        {
        peek_char = shell_getc(1);
        }
        if (peek_char == 40) {
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (dstack.delimiter_depth + 2 > dstack.delimiter_space) {
              {
              dstack.delimiter_space += 10;
              dstack.delimiters = xrealloc((void *)dstack.delimiters, (unsigned long )dstack.delimiter_space * sizeof(char ));
              }
            }
            *(dstack.delimiters + dstack.delimiter_depth) = (char )peek_char;
            (dstack.delimiter_depth) ++;
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
          ttok = parse_matched_pair(cd, '(', ')', & ttoklen, 0);
          (dstack.delimiter_depth) --;
          }
          if ((unsigned long )ttok == (unsigned long )(& matched_pair_error)) {
            return (-1);
          }
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (token_index + (ttoklen + 2) >= token_buffer_size) {
              {
              while (1) {
                while_continue___6: /* CIL Label */ ;
                if (! (token_index + (ttoklen + 2) >= token_buffer_size)) {
                  goto while_break___6;
                }
                token_buffer_size += 512;
              }
              while_break___6: /* CIL Label */ ;
              }
              {
              token = xrealloc((void *)token, (size_t )token_buffer_size);
              }
            }
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
          tmp___3 = token_index;
          token_index ++;
          *(token + tmp___3) = (char )character;
          tmp___4 = token_index;
          token_index ++;
          *(token + tmp___4) = (char )peek_char;
          strcpy((char * __restrict  )(token + token_index), (char const   * __restrict  )ttok);
          token_index += ttoklen;
          }
          {
          while (1) {
            while_continue___7: /* CIL Label */ ;
            if (ttok) {
              {
              free((void *)ttok);
              }
            }
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          all_digits___0 = 0;
          dollar_present = all_digits___0;
          goto next_character;
        } else {
          {
          shell_ungetc(peek_char);
          }
        }
      }
      }
      }
      }
      }
    }
    if (character == 36) {
      goto _L___5;
    } else { //Added block
    if (character == 60) {
      goto _L___5;
    } else { //Added block
    if (character == 62) {
      _L___5: 
      {
      peek_char = shell_getc(1);
      }
      if (peek_char == 40) {
        goto _L___2;
      } else { //Added block
      if (peek_char == 123) {
        goto _L___4;
      } else { //Added block
      if (peek_char == 91) {
        _L___4: 
        if (character == 36) {
          _L___2: 
          if (peek_char == 123) {
            {
            ttok = parse_matched_pair(cd, '{', '}', & ttoklen, 1);
            }
          } else { //Added block
          if (peek_char == 40) {
            {
            while (1) {
              while_continue___8: /* CIL Label */ ;
              if (dstack.delimiter_depth + 2 > dstack.delimiter_space) {
                {
                dstack.delimiter_space += 10;
                dstack.delimiters = xrealloc((void *)dstack.delimiters, (unsigned long )dstack.delimiter_space * sizeof(char ));
                }
              }
              *(dstack.delimiters + dstack.delimiter_depth) = (char )peek_char;
              (dstack.delimiter_depth) ++;
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
            {
            ttok = parse_matched_pair(cd, '(', ')', & ttoklen, 0);
            (dstack.delimiter_depth) --;
            }
          } else {
            {
            ttok = parse_matched_pair(cd, '[', ']', & ttoklen, 0);
            }
          }
          }
          if ((unsigned long )ttok == (unsigned long )(& matched_pair_error)) {
            return (-1);
          }
          {
          while (1) {
            while_continue___9: /* CIL Label */ ;
            if (token_index + (ttoklen + 2) >= token_buffer_size) {
              {
              while (1) {
                while_continue___10: /* CIL Label */ ;
                if (! (token_index + (ttoklen + 2) >= token_buffer_size)) {
                  goto while_break___10;
                }
                token_buffer_size += 512;
              }
              while_break___10: /* CIL Label */ ;
              }
              {
              token = xrealloc((void *)token, (size_t )token_buffer_size);
              }
            }
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
          tmp___5 = token_index;
          token_index ++;
          *(token + tmp___5) = (char )character;
          tmp___6 = token_index;
          token_index ++;
          *(token + tmp___6) = (char )peek_char;
          strcpy((char * __restrict  )(token + token_index), (char const   * __restrict  )ttok);
          token_index += ttoklen;
          }
          {
          while (1) {
            while_continue___11: /* CIL Label */ ;
            if (ttok) {
              {
              free((void *)ttok);
              }
            }
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          dollar_present = 1;
          all_digits___0 = 0;
          goto next_character;
        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: 
      if (character == 36) {
        if (peek_char == 39) {
          goto _L___1;
        } else { //Added block
        if (peek_char == 34) {
          _L___1: 
          first_line = line_number;
          {
          while (1) {
            while_continue___12: /* CIL Label */ ;
            if (dstack.delimiter_depth + 2 > dstack.delimiter_space) {
              {
              dstack.delimiter_space += 10;
              dstack.delimiters = xrealloc((void *)dstack.delimiters, (unsigned long )dstack.delimiter_space * sizeof(char ));
              }
            }
            *(dstack.delimiters + dstack.delimiter_depth) = (char )peek_char;
            (dstack.delimiter_depth) ++;
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          if (peek_char == 39) {
            tmp___7 = 2;
          } else {
            tmp___7 = 0;
          }
          {
          ttok = parse_matched_pair(peek_char, peek_char, peek_char, & ttoklen, tmp___7);
          (dstack.delimiter_depth) --;
          }
          if ((unsigned long )ttok == (unsigned long )(& matched_pair_error)) {
            return (-1);
          }
          if (peek_char == 39) {
            {
            ttrans = ansiexpand(ttok, 0, ttoklen - 1, & ttranslen);
            free((void *)ttok);
            ttok = sh_single_quote(ttrans);
            free((void *)ttrans);
            ttrans = ttok;
            tmp___8 = strlen((char const   *)ttrans);
            ttranslen = (int )tmp___8;
            }
          } else {
            {
            ttrans = localeexpand(ttok, 0, ttoklen - 1, first_line, & ttranslen);
            free((void *)ttok);
            ttok = xmalloc((size_t )(ttranslen + 3));
            *(ttok + 0) = (char )'\"';
            strcpy((char * __restrict  )(ttok + 1), (char const   * __restrict  )ttrans);
            *(ttok + (ttranslen + 1)) = (char )'\"';
            ttranslen += 2;
            *(ttok + ttranslen) = (char )'\000';
            free((void *)ttrans);
            ttrans = ttok;
            }
          }
          {
          while (1) {
            while_continue___13: /* CIL Label */ ;
            if (token_index + (ttranslen + 2) >= token_buffer_size) {
              {
              while (1) {
                while_continue___14: /* CIL Label */ ;
                if (! (token_index + (ttranslen + 2) >= token_buffer_size)) {
                  goto while_break___14;
                }
                token_buffer_size += 512;
              }
              while_break___14: /* CIL Label */ ;
              }
              {
              token = xrealloc((void *)token, (size_t )token_buffer_size);
              }
            }
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
          strcpy((char * __restrict  )(token + token_index), (char const   * __restrict  )ttrans);
          token_index += ttranslen;
          }
          {
          while (1) {
            while_continue___15: /* CIL Label */ ;
            if (ttrans) {
              {
              free((void *)ttrans);
              }
            }
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
          quoted = 1;
          all_digits___0 = 0;
          goto next_character;
        } else {
          goto _L___0;
        }
        }
      } else { //Added block
      _L___0: 
      if (character == 36) {
        if (peek_char == 36) {
          {
          ttok = xmalloc((size_t )3);
          tmp___9 = (char )'$';
          *(ttok + 1) = tmp___9;
          *(ttok + 0) = tmp___9;
          *(ttok + 2) = (char )'\000';
          }
          {
          while (1) {
            while_continue___16: /* CIL Label */ ;
            if (token_index + 3 >= token_buffer_size) {
              {
              while (1) {
                while_continue___17: /* CIL Label */ ;
                if (! (token_index + 3 >= token_buffer_size)) {
                  goto while_break___17;
                }
                token_buffer_size += 512;
              }
              while_break___17: /* CIL Label */ ;
              }
              {
              token = xrealloc((void *)token, (size_t )token_buffer_size);
              }
            }
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
          {
          strcpy((char * __restrict  )(token + token_index), (char const   * __restrict  )ttok);
          token_index += 2;
          dollar_present = 1;
          all_digits___0 = 0;
          }
          {
          while (1) {
            while_continue___18: /* CIL Label */ ;
            if (ttok) {
              {
              free((void *)ttok);
              }
            }
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
          goto next_character;
        } else {
          {
          shell_ungetc(peek_char);
          }
        }
      } else {
        {
        shell_ungetc(peek_char);
        }
      }
      }
      }
      }
      }
    } else { //Added block
    if (character == 61) {
      if (token_index > 0) {
        {
        peek_char = shell_getc(1);
        }
        if (peek_char == 40) {
          {
          ttok = parse_matched_pair(cd, '(', ')', & ttoklen, 0);
          }
          if ((unsigned long )ttok == (unsigned long )(& matched_pair_error)) {
            return (-1);
          }
          if ((int )*(ttok + 0) == 40) {
            {
            while (1) {
              while_continue___19: /* CIL Label */ ;
              if (ttok) {
                {
                free((void *)ttok);
                }
              }
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
            return (-1);
          }
          {
          while (1) {
            while_continue___20: /* CIL Label */ ;
            if (token_index + (ttoklen + 2) >= token_buffer_size) {
              {
              while (1) {
                while_continue___21: /* CIL Label */ ;
                if (! (token_index + (ttoklen + 2) >= token_buffer_size)) {
                  goto while_break___21;
                }
                token_buffer_size += 512;
              }
              while_break___21: /* CIL Label */ ;
              }
              {
              token = xrealloc((void *)token, (size_t )token_buffer_size);
              }
            }
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
          {
          tmp___10 = token_index;
          token_index ++;
          *(token + tmp___10) = (char )character;
          tmp___11 = token_index;
          token_index ++;
          *(token + tmp___11) = (char )peek_char;
          strcpy((char * __restrict  )(token + token_index), (char const   * __restrict  )ttok);
          token_index += ttoklen;
          }
          {
          while (1) {
            while_continue___22: /* CIL Label */ ;
            if (ttok) {
              {
              free((void *)ttok);
              }
            }
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
          all_digits___0 = 0;
          goto next_character;
        } else {
          {
          shell_ungetc(peek_char);
          }
        }
      }
    }
    }
    }
    }
    if (sh_syntaxtab[character] & 2) {
      {
      shell_ungetc(character);
      }
      goto got_token;
    }
    got_character: 
    {
    tmp___12 = __ctype_b_loc();
    all_digits___0 &= (int )((int const   )*(*tmp___12 + character) & 2048);
    dollar_present |= character == 36;
    }
    if (character == 1) {
      tmp___13 = token_index;
      token_index ++;
      *(token + tmp___13) = (char )'\001';
    } else { //Added block
    if (character == 127) {
      tmp___13 = token_index;
      token_index ++;
      *(token + tmp___13) = (char )'\001';
    }
    }
    tmp___14 = token_index;
    token_index ++;
    *(token + tmp___14) = (char )character;
    {
    while (1) {
      while_continue___23: /* CIL Label */ ;
      if (token_index + 1 >= token_buffer_size) {
        {
        while (1) {
          while_continue___24: /* CIL Label */ ;
          if (! (token_index + 1 >= token_buffer_size)) {
            goto while_break___24;
          }
          token_buffer_size += 512;
        }
        while_break___24: /* CIL Label */ ;
        }
        {
        token = xrealloc((void *)token, (size_t )token_buffer_size);
        }
      }
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    next_character: 
    if (character == 10) {
      if (interactive) {
        if ((unsigned int )bash_input.type == 1U) {
          {
          prompt_again();
          }
        } else { //Added block
        if ((unsigned int )bash_input.type == 2U) {
          {
          prompt_again();
          }
        }
        }
      }
    }
    if (dstack.delimiter_depth) {
      cd = (int )*(dstack.delimiters + (dstack.delimiter_depth - 1));
    } else {
      cd = 0;
    }
    if (cd != 39) {
      if (pass_next_character == 0) {
        tmp___15 = 1;
      } else {
        tmp___15 = 0;
      }
    } else {
      tmp___15 = 0;
    }
    {
    character = shell_getc(tmp___15);
    }
  }
  while_break: /* CIL Label */ ;
  }
  got_token: 
  *(token + token_index) = (char )'\000';
  if (all_digits___0) {
    if (character == 60) {
      {
      yylval.number = atoi((char const   *)token);
      }
      return (280);
    } else { //Added block
    if (character == 62) {
      {
      yylval.number = atoi((char const   *)token);
      }
      return (280);
    } else { //Added block
    if (last_read_token == 288) {
      {
      yylval.number = atoi((char const   *)token);
      }
      return (280);
    } else { //Added block
    if (last_read_token == 289) {
      {
      yylval.number = atoi((char const   *)token);
      }
      return (280);
    }
    }
    }
    }
  }
  {
  result = special_case_tokens(token);
  }
  if (result >= 0) {
    return (result);
  }
  if (posixly_correct) {
    {
    while (1) {
      while_continue___25: /* CIL Label */ ;
      if (! dollar_present) {
        if (! quoted) {
          {
          tmp___17 = reserved_word_acceptable(last_read_token);
          }
          if (tmp___17) {
            i = 0;
            {
            while (1) {
              while_continue___26: /* CIL Label */ ;
              if (! ((unsigned long )word_token_alist[i].word != (unsigned long )((char *)((void *)0)))) {
                goto while_break___26;
              }
              if ((int )*(token + 0) == (int )*(word_token_alist[i].word + 0)) {
                {
                tmp___16 = strcmp((char const   *)token, (char const   *)word_token_alist[i].word);
                }
                if (tmp___16 == 0) {
                  if (parser_state & 1) {
                    if (word_token_alist[i].token != 263) {
                      goto while_break___26;
                    }
                  }
                  if (word_token_alist[i].token == 276) {
                    goto while_break___26;
                  }
                  if (word_token_alist[i].token == 263) {
                    parser_state &= -130;
                  } else { //Added block
                  if (word_token_alist[i].token == 262) {
                    parser_state |= 128;
                  } else { //Added block
                  if (word_token_alist[i].token == 272) {
                    parser_state &= -769;
                  } else { //Added block
                  if (word_token_alist[i].token == 271) {
                    parser_state |= 256;
                  } else { //Added block
                  if (word_token_alist[i].token == 123) {
                    open_brace_count ++;
                  } else { //Added block
                  if (word_token_alist[i].token == 125) {
                    if (open_brace_count) {
                      open_brace_count --;
                    }
                  }
                  }
                  }
                  }
                  }
                  }
                  return (word_token_alist[i].token);
                }
              }
              i ++;
            }
            while_break___26: /* CIL Label */ ;
            }
          }
        }
      }
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
  }
  if (expand_aliases) {
    if (quoted == 0) {
      {
      result = alias_expand_token(token);
      }
      if (result == -99) {
        return (-99);
      } else { //Added block
      if (result == -100) {
        parser_state &= -3;
      }
      }
    }
  }
  if (posixly_correct == 0) {
    {
    while (1) {
      while_continue___27: /* CIL Label */ ;
      if (! dollar_present) {
        if (! quoted) {
          {
          tmp___19 = reserved_word_acceptable(last_read_token);
          }
          if (tmp___19) {
            i___0 = 0;
            {
            while (1) {
              while_continue___28: /* CIL Label */ ;
              if (! ((unsigned long )word_token_alist[i___0].word != (unsigned long )((char *)((void *)0)))) {
                goto while_break___28;
              }
              if ((int )*(token + 0) == (int )*(word_token_alist[i___0].word + 0)) {
                {
                tmp___18 = strcmp((char const   *)token, (char const   *)word_token_alist[i___0].word);
                }
                if (tmp___18 == 0) {
                  if (parser_state & 1) {
                    if (word_token_alist[i___0].token != 263) {
                      goto while_break___28;
                    }
                  }
                  if (word_token_alist[i___0].token == 276) {
                    goto while_break___28;
                  }
                  if (word_token_alist[i___0].token == 263) {
                    parser_state &= -130;
                  } else { //Added block
                  if (word_token_alist[i___0].token == 262) {
                    parser_state |= 128;
                  } else { //Added block
                  if (word_token_alist[i___0].token == 272) {
                    parser_state &= -769;
                  } else { //Added block
                  if (word_token_alist[i___0].token == 271) {
                    parser_state |= 256;
                  } else { //Added block
                  if (word_token_alist[i___0].token == 123) {
                    open_brace_count ++;
                  } else { //Added block
                  if (word_token_alist[i___0].token == 125) {
                    if (open_brace_count) {
                      open_brace_count --;
                    }
                  }
                  }
                  }
                  }
                  }
                  }
                  return (word_token_alist[i___0].token);
                }
              }
              i___0 ++;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
        }
      }
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
  }
  {
  tmp___20 = xmalloc(sizeof(WORD_DESC ));
  the_word = (WORD_DESC *)tmp___20;
  the_word->word = xmalloc((size_t )(1 + token_index));
  the_word->flags = 0;
  strcpy((char * __restrict  )the_word->word, (char const   * __restrict  )token);
  }
  if (dollar_present) {
    the_word->flags |= 1;
  }
  if (quoted) {
    the_word->flags |= 2;
  }
  {
  tmp___22 = assignment(token);
  }
  if (tmp___22) {
    the_word->flags |= 4;
    if (last_read_token == 279) {
      goto _L___6;
    } else { //Added block
    if (last_read_token != 290) {
      {
      tmp___21 = reserved_word_acceptable(last_read_token);
      }
      if (tmp___21) {
        _L___6: 
        if ((parser_state & 1) == 0) {
          the_word->flags |= 16;
        }
      }
    }
    }
  }
  yylval.word = the_word;
  if ((the_word->flags & 20) == 20) {
    result = 279;
  } else {
    result = 278;
  }
  if (last_read_token == 270) {
    parser_state |= 4;
    function_dstart = line_number;
  }
  return (result);
}
}
static char *ansiexpand(char *string , int start , int end , int *lenp ) 
{ 
  char *temp___0 ;
  char *t ;
  int len___0 ;
  int tlen ;
  int tmp ;
  int tmp___0 ;

  {
  {
  temp___0 = xmalloc((size_t )((end - start) + 1));
  tlen = 0;
  len___0 = start;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (len___0 < end)) {
      goto while_break;
    }
    tmp = tlen;
    tlen ++;
    tmp___0 = len___0;
    len___0 ++;
    *(temp___0 + tmp) = *(string + tmp___0);
  }
  while_break: /* CIL Label */ ;
  }
  *(temp___0 + tlen) = (char )'\000';
  if (*temp___0) {
    {
    t = ansicstr(temp___0, tlen, 0, (int *)((void *)0), lenp);
    free((void *)temp___0);
    }
    return (t);
  } else {
    if (lenp) {
      *lenp = 0;
    }
    return (temp___0);
  }
}
}
static char *mk_msgstr(char *string , int *foundnlp ) 
{ 
  register int c ;
  register int len___0 ;
  char *result ;
  char *r ;
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  len___0 = 0;
  s = string;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (s) {
      if (! *s) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    len___0 ++;
    if ((int )*s == 34) {
      len___0 ++;
    } else { //Added block
    if ((int )*s == 92) {
      len___0 ++;
    } else { //Added block
    if ((int )*s == 10) {
      len___0 += 5;
    }
    }
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  result = xmalloc((size_t )(len___0 + 3));
  r = result;
  tmp = r;
  r ++;
  *tmp = (char )'\"';
  s = string;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (s) {
      c = (int )*s;
      if (! c) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    if (c == 10) {
      tmp___0 = r;
      r ++;
      *tmp___0 = (char )'\\';
      tmp___1 = r;
      r ++;
      *tmp___1 = (char )'n';
      tmp___2 = r;
      r ++;
      *tmp___2 = (char )'\"';
      tmp___3 = r;
      r ++;
      *tmp___3 = (char )'\n';
      tmp___4 = r;
      r ++;
      *tmp___4 = (char )'\"';
      if (foundnlp) {
        *foundnlp = 1;
      }
      goto __Cont;
    }
    if (c == 34) {
      tmp___5 = r;
      r ++;
      *tmp___5 = (char )'\\';
    } else { //Added block
    if (c == 92) {
      tmp___5 = r;
      r ++;
      *tmp___5 = (char )'\\';
    }
    }
    tmp___6 = r;
    r ++;
    *tmp___6 = (char )c;
    __Cont: 
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  tmp___7 = r;
  r ++;
  *tmp___7 = (char )'\"';
  tmp___8 = r;
  r ++;
  *tmp___8 = (char )'\000';
  return (result);
}
}
static char *localeexpand(char *string , int start , int end , int lineno , int *lenp ) 
{ 
  int len___0 ;
  int tlen ;
  int foundnl ;
  char *temp___0 ;
  char *t ;
  char *t2 ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  temp___0 = xmalloc((size_t )((end - start) + 1));
  tlen = 0;
  len___0 = start;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (len___0 < end)) {
      goto while_break;
    }
    tmp = tlen;
    tlen ++;
    tmp___0 = len___0;
    len___0 ++;
    *(temp___0 + tmp) = *(string + tmp___0);
  }
  while_break: /* CIL Label */ ;
  }
  *(temp___0 + tlen) = (char )'\000';
  if (dump_translatable_strings) {
    if (dump_po_strings) {
      {
      foundnl = 0;
      t = mk_msgstr(temp___0, & foundnl);
      }
      if (foundnl) {
        t2 = (char *)"\"\"\n";
      } else {
        t2 = (char *)"";
      }
      if (bash_input.name) {
        tmp___1 = (char const   *)bash_input.name;
      } else {
        tmp___1 = "stdin";
      }
      {
      printf((char const   * __restrict  )"#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n", tmp___1,
             lineno, t2, t);
      free((void *)t);
      }
    } else {
      {
      printf((char const   * __restrict  )"\"%s\"\n", temp___0);
      }
    }
    if (lenp) {
      *lenp = tlen;
    }
    return (temp___0);
  } else { //Added block
  if (*temp___0) {
    {
    t = localetrans(temp___0, tlen, & len___0);
    free((void *)temp___0);
    }
    if (lenp) {
      *lenp = len___0;
    }
    return (t);
  } else {
    if (lenp) {
      *lenp = 0;
    }
    return (temp___0);
  }
  }
}
}
static int reserved_word_acceptable(int token___0 ) 
{ 


  {
  if (token___0 == 10) {
    return (1);
  } else { //Added block
  if (token___0 == 59) {
    return (1);
  } else { //Added block
  if (token___0 == 40) {
    return (1);
  } else { //Added block
  if (token___0 == 41) {
    return (1);
  } else { //Added block
  if (token___0 == 124) {
    return (1);
  } else { //Added block
  if (token___0 == 38) {
    return (1);
  } else { //Added block
  if (token___0 == 123) {
    return (1);
  } else { //Added block
  if (token___0 == 125) {
    return (1);
  } else { //Added block
  if (token___0 == 284) {
    return (1);
  } else { //Added block
  if (token___0 == 275) {
    return (1);
  } else { //Added block
  if (token___0 == 276) {
    return (1);
  } else { //Added block
  if (token___0 == 277) {
    return (1);
  } else { //Added block
  if (token___0 == 268) {
    return (1);
  } else { //Added block
  if (token___0 == 260) {
    return (1);
  } else { //Added block
  if (token___0 == 259) {
    return (1);
  } else { //Added block
  if (token___0 == 261) {
    return (1);
  } else { //Added block
  if (token___0 == 257) {
    return (1);
  } else { //Added block
  if (token___0 == 285) {
    return (1);
  } else { //Added block
  if (token___0 == 290) {
    return (1);
  } else { //Added block
  if (token___0 == 258) {
    return (1);
  } else { //Added block
  if (token___0 == 267) {
    return (1);
  } else { //Added block
  if (token___0 == 266) {
    return (1);
  } else { //Added block
  if (token___0 == 269) {
    return (1);
  } else { //Added block
  if (token___0 == 263) {
    return (1);
  } else { //Added block
  if (token___0 == 0) {
    return (1);
  } else {
    return (0);
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
}
}
int find_reserved_word(char *token___0 ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! word_token_alist[i].word) {
      goto while_break;
    }
    if ((int )*(token___0 + 0) == (int )*(word_token_alist[i].word + 0)) {
      {
      tmp = strcmp((char const   *)token___0, (char const   *)word_token_alist[i].word);
      }
      if (tmp == 0) {
        return (i);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static int no_semi_successors[19]  = 
  {      '\n',      '{',      '(',      ')', 
        ';',      '&',      '|',      262, 
        268,      259,      257,      290, 
        258,      267,      266,      284, 
        285,      274,      0};
char *history_delimiting_chars(void) 
{ 
  register int i ;

  {
  if (dstack.delimiter_depth != 0) {
    return ((char *)"\n");
  }
  if (token_before_that == 41) {
    if (two_tokens_ago == 40) {
      return ((char *)" ");
    } else { //Added block
    if (parser_state & 128) {
      return ((char *)" ");
    } else {
      return ((char *)"; ");
    }
    }
  } else { //Added block
  if (token_before_that == 278) {
    if (two_tokens_ago == 270) {
      return ((char *)" ");
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (token_before_that == 278) {
    if (two_tokens_ago == 264) {
      i = shell_input_line_index;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((int )*(shell_input_line + i) == 32)) {
          if (! ((int )*(shell_input_line + i) == 9)) {
            goto while_break;
          }
        }
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      if (*(shell_input_line + i)) {
        if ((int )*(shell_input_line + i) == 105) {
          if ((int )*(shell_input_line + (i + 1)) == 110) {
            return ((char *)" ");
          }
        }
      }
      return ((char *)";");
    }
  }
  }
  }
  i = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! no_semi_successors[i]) {
      goto while_break___0;
    }
    if (token_before_that == no_semi_successors[i]) {
      return ((char *)" ");
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((char *)"; ");
}
}
static void prompt_again(void) 
{ 
  char *temp_prompt ;
  char *tmp ;

  {
  if (! interactive) {
    return;
  }
  {
  ps1_prompt = get_string_value("PS1");
  ps2_prompt = get_string_value("PS2");
  }
  if (! prompt_string_pointer) {
    prompt_string_pointer = & ps1_prompt;
  }
  if (*prompt_string_pointer) {
    {
    tmp = decode_prompt_string(*prompt_string_pointer);
    temp_prompt = tmp;
    }
  } else {
    temp_prompt = (char *)((void *)0);
  }
  if ((unsigned long )temp_prompt == (unsigned long )((char *)0)) {
    {
    temp_prompt = xmalloc((size_t )1);
    *(temp_prompt + 0) = (char )'\000';
    }
  }
  current_prompt_string = *prompt_string_pointer;
  prompt_string_pointer = & ps2_prompt;
  if (! no_line_editing) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (current_readline_prompt) {
        {
        free((void *)current_readline_prompt);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    current_readline_prompt = temp_prompt;
  } else {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (current_decoded_prompt) {
        {
        free((void *)current_decoded_prompt);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    current_decoded_prompt = temp_prompt;
  }
  return;
}
}
int get_current_prompt_level(void) 
{ 
  int tmp ;

  {
  if (current_prompt_string) {
    if ((unsigned long )current_prompt_string == (unsigned long )ps2_prompt) {
      tmp = 2;
    } else {
      tmp = 1;
    }
  } else {
    tmp = 1;
  }
  return (tmp);
}
}
void set_current_prompt_level(int x ) 
{ 


  {
  if (x == 2) {
    prompt_string_pointer = & ps2_prompt;
  } else {
    prompt_string_pointer = & ps1_prompt;
  }
  current_prompt_string = *prompt_string_pointer;
  return;
}
}
static void print_prompt(void) 
{ 


  {
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", current_decoded_prompt);
  fflush(stderr);
  }
  return;
}
}
char *decode_prompt_string(char *string ) 
{ 
  WORD_LIST *list___0 ;
  char *result ;
  char *t ;
  struct dstack save_dstack ;
  int result_size ;
  int result_index ;
  int c ;
  int n ;
  char *temp___0 ;
  char octal_string[4] ;
  time_t the_time ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char t_string[4096] ;
  int tlen ;
  size_t tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;

  {
  {
  result_size = 48;
  result = xmalloc((size_t )result_size);
  result_index = 0;
  *(result + result_index) = (char)0;
  temp___0 = (char *)((void *)0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___39 = string;
    string ++;
    c = (int )*tmp___39;
    if (! c) {
      goto while_break;
    }
    if (posixly_correct) {
      if (c == 33) {
        if ((int )*string == 33) {
          {
          tmp = strlen("!");
          tmp___0 = xmalloc(1UL + tmp);
          tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )"!");
          temp___0 = tmp___1;
          }
          goto add_string;
        } else {
          {
          tmp___2 = history_number();
          temp___0 = itos(tmp___2);
          string --;
          }
          goto add_string;
        }
      }
    }
    if (c == 92) {
      c = (int )*string;
      {
      if (c == 48) {
        goto case_48;
      }
      if (c == 49) {
        goto case_48;
      }
      if (c == 50) {
        goto case_48;
      }
      if (c == 51) {
        goto case_48;
      }
      if (c == 52) {
        goto case_48;
      }
      if (c == 53) {
        goto case_48;
      }
      if (c == 54) {
        goto case_48;
      }
      if (c == 55) {
        goto case_48;
      }
      if (c == 116) {
        goto case_116;
      }
      if (c == 100) {
        goto case_116;
      }
      if (c == 84) {
        goto case_116;
      }
      if (c == 64) {
        goto case_116;
      }
      if (c == 114) {
        goto case_114;
      }
      if (c == 110) {
        goto case_110;
      }
      if (c == 115) {
        goto case_115;
      }
      if (c == 118) {
        goto case_118;
      }
      if (c == 86) {
        goto case_118;
      }
      if (c == 119) {
        goto case_119;
      }
      if (c == 87) {
        goto case_119;
      }
      if (c == 117) {
        goto case_117;
      }
      if (c == 104) {
        goto case_104;
      }
      if (c == 72) {
        goto case_104;
      }
      if (c == 35) {
        goto case_35;
      }
      if (c == 33) {
        goto case_33;
      }
      if (c == 36) {
        goto case_36;
      }
      if (c == 106) {
        goto case_106;
      }
      if (c == 108) {
        goto case_108;
      }
      if (c == 91) {
        goto case_91;
      }
      if (c == 93) {
        goto case_91;
      }
      if (c == 92) {
        goto case_92;
      }
      if (c == 97) {
        goto case_97;
      }
      if (c == 101) {
        goto case_97;
      }
      goto switch_default;
      case_48: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_55: /* CIL Label */ 
      {
      strncpy((char * __restrict  )(octal_string), (char const   * __restrict  )string,
              (size_t )3);
      octal_string[3] = (char )'\000';
      n = read_octal(octal_string);
      temp___0 = xmalloc((size_t )3);
      }
      if (n == 1) {
        *(temp___0 + 0) = (char )'\001';
        *(temp___0 + 1) = (char )n;
        *(temp___0 + 2) = (char )'\000';
      } else { //Added block
      if (n == 127) {
        *(temp___0 + 0) = (char )'\001';
        *(temp___0 + 1) = (char )n;
        *(temp___0 + 2) = (char )'\000';
      } else { //Added block
      if (n == -1) {
        *(temp___0 + 0) = (char )'\\';
        *(temp___0 + 1) = (char )'\000';
      } else {
        *(temp___0 + 0) = (char )n;
        *(temp___0 + 1) = (char )'\000';
      }
      }
      }
      c = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (n != -1) {
          if (c < 3) {
            if ((int )*string >= 48) {
              if (! ((int )*string <= 55)) {
                goto while_break___0;
              }
            } else {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        string ++;
        c ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      c = 0;
      goto add_string;
      case_116: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_64: /* CIL Label */ 
      {
      the_time = time((time_t *)0);
      temp___0 = ctime((time_t const   *)(& the_time));
      }
      if (c != 100) {
        {
        tmp___3 = strlen((char const   *)(temp___0 + 11));
        tmp___4 = xmalloc(1UL + tmp___3);
        tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )(temp___0 + 11));
        temp___0 = tmp___5;
        }
      } else {
        {
        tmp___6 = strlen((char const   *)temp___0);
        tmp___7 = xmalloc(1UL + tmp___6);
        tmp___8 = strcpy((char * __restrict  )tmp___7, (char const   * __restrict  )temp___0);
        temp___0 = tmp___8;
        }
      }
      if (c != 100) {
        tmp___9 = 8;
      } else {
        tmp___9 = 10;
      }
      *(temp___0 + tmp___9) = (char )'\000';
      if (c == 84) {
        goto _L;
      } else { //Added block
      if (c == 64) {
        _L: 
        if (c == 64) {
          *(temp___0 + 5) = (char )'a';
          *(temp___0 + 6) = (char )'m';
          *(temp___0 + 7) = (char )'\000';
        }
        {
        c = (int )*(temp___0 + 2);
        *(temp___0 + 2) = (char )'\000';
        n = atoi((char const   *)temp___0);
        *(temp___0 + 2) = (char )c;
        n -= 12;
        }
        if (n > 0) {
          *(temp___0 + 0) = (char )(n / 10 + 48);
          *(temp___0 + 1) = (char )(n % 10 + 48);
        }
        if (n >= 0) {
          if ((int )*(temp___0 + 5) == 97) {
            *(temp___0 + 5) = (char )'p';
          }
        }
      }
      }
      goto add_string;
      case_114: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )2);
      *(temp___0 + 0) = (char )'\r';
      *(temp___0 + 1) = (char )'\000';
      }
      goto add_string;
      case_110: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )3);
      }
      if (no_line_editing) {
        *(temp___0 + 0) = (char )'\n';
      } else {
        *(temp___0 + 0) = (char )'\r';
      }
      if (no_line_editing) {
        *(temp___0 + 1) = (char )'\000';
      } else {
        *(temp___0 + 1) = (char )'\n';
      }
      *(temp___0 + 2) = (char )'\000';
      goto add_string;
      case_115: /* CIL Label */ 
      {
      temp___0 = base_pathname(shell_name);
      tmp___10 = strlen((char const   *)temp___0);
      tmp___11 = xmalloc(1UL + tmp___10);
      tmp___12 = strcpy((char * __restrict  )tmp___11, (char const   * __restrict  )temp___0);
      temp___0 = tmp___12;
      }
      goto add_string;
      case_118: /* CIL Label */ 
      case_86: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )8);
      }
      if (c == 118) {
        {
        strcpy((char * __restrict  )temp___0, (char const   * __restrict  )dist_version);
        }
      } else {
        {
        sprintf((char * __restrict  )temp___0, (char const   * __restrict  )"%s.%d",
                dist_version, patch_level);
        }
      }
      goto add_string;
      case_119: /* CIL Label */ 
      case_87: /* CIL Label */ 
      {
      temp___0 = get_string_value("PWD");
      }
      if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
        {
        tmp___14 = getcwd(t_string, sizeof(t_string));
        }
        if ((unsigned long )tmp___14 == (unsigned long )((char *)0)) {
          t_string[0] = (char )'.';
          tlen = 1;
        } else {
          {
          tmp___13 = strlen((char const   *)(t_string));
          tlen = (int )tmp___13;
          }
        }
      } else {
        {
        tlen = (int )(sizeof(t_string) - 1UL);
        strncpy((char * __restrict  )(t_string), (char const   * __restrict  )temp___0,
                (size_t )tlen);
        }
      }
      t_string[tlen] = (char )'\000';
      if (c == 87) {
        if ((int )t_string[0] == 47) {
          if ((int )t_string[1] == 0) {
            tmp___15 = 1;
          } else {
            tmp___15 = 0;
          }
        } else {
          tmp___15 = 0;
        }
        if (tmp___15 == 0) {
          if ((int )t_string[0] == 47) {
            if ((int )t_string[1] == 47) {
              if ((int )t_string[2] == 0) {
                tmp___16 = 1;
              } else {
                tmp___16 = 0;
              }
            } else {
              tmp___16 = 0;
            }
          } else {
            tmp___16 = 0;
          }
          if (tmp___16 == 0) {
            {
            t = strrchr((char const   *)(t_string), '/');
            }
            if (t) {
              {
              strcpy((char * __restrict  )(t_string), (char const   * __restrict  )(t + 1));
              }
            }
          }
        }
      } else {
        {
        tmp___17 = polite_directory_format(t_string);
        strcpy((char * __restrict  )(t_string), (char const   * __restrict  )tmp___17);
        }
      }
      if (promptvars) {
        {
        temp___0 = sh_backslash_quote_for_double_quotes(t_string);
        }
      } else { //Added block
      if (posixly_correct) {
        {
        temp___0 = sh_backslash_quote_for_double_quotes(t_string);
        }
      } else {
        {
        tmp___18 = strlen((char const   *)(t_string));
        tmp___19 = xmalloc(1UL + tmp___18);
        tmp___20 = strcpy((char * __restrict  )tmp___19, (char const   * __restrict  )(t_string));
        temp___0 = tmp___20;
        }
      }
      }
      goto add_string;
      case_117: /* CIL Label */ 
      if ((unsigned long )current_user.user_name == (unsigned long )((char *)0)) {
        {
        get_current_user_info();
        }
      }
      {
      tmp___21 = strlen((char const   *)current_user.user_name);
      tmp___22 = xmalloc(1UL + tmp___21);
      tmp___23 = strcpy((char * __restrict  )tmp___22, (char const   * __restrict  )current_user.user_name);
      temp___0 = tmp___23;
      }
      goto add_string;
      case_104: /* CIL Label */ 
      case_72: /* CIL Label */ 
      {
      tmp___24 = strlen((char const   *)current_host_name);
      tmp___25 = xmalloc(1UL + tmp___24);
      tmp___26 = strcpy((char * __restrict  )tmp___25, (char const   * __restrict  )current_host_name);
      temp___0 = tmp___26;
      }
      if (c == 104) {
        {
        tmp___27 = strchr((char const   *)temp___0, '.');
        t = tmp___27;
        }
        if (t) {
          *t = (char )'\000';
        }
      }
      goto add_string;
      case_35: /* CIL Label */ 
      {
      temp___0 = itos(current_command_number);
      }
      goto add_string;
      case_33: /* CIL Label */ 
      {
      tmp___28 = history_number();
      temp___0 = itos(tmp___28);
      }
      goto add_string;
      case_36: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )3);
      t = temp___0;
      }
      if (promptvars) {
        goto _L___0;
      } else { //Added block
      if (posixly_correct) {
        _L___0: 
        if (current_user.euid != 0U) {
          tmp___29 = t;
          t ++;
          *tmp___29 = (char )'\\';
        }
      }
      }
      tmp___30 = t;
      t ++;
      if (current_user.euid == 0U) {
        *tmp___30 = (char )'#';
      } else {
        *tmp___30 = (char )'$';
      }
      *t = (char )'\000';
      goto add_string;
      case_106: /* CIL Label */ 
      {
      tmp___31 = count_all_jobs();
      temp___0 = itos(tmp___31);
      }
      goto add_string;
      case_108: /* CIL Label */ 
      {
      tmp___32 = fileno(stdin);
      tmp___33 = ttyname(tmp___32);
      temp___0 = tmp___33;
      }
      if (temp___0) {
        {
        tmp___34 = base_pathname(temp___0);
        t = tmp___34;
        }
      } else {
        t = (char *)"tty";
      }
      {
      tmp___35 = strlen((char const   *)t);
      tmp___36 = xmalloc(1UL + tmp___35);
      tmp___37 = strcpy((char * __restrict  )tmp___36, (char const   * __restrict  )t);
      temp___0 = tmp___37;
      }
      goto add_string;
      case_91: /* CIL Label */ 
      case_93: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )3);
      *(temp___0 + 0) = (char )'\001';
      }
      if (c == 91) {
        *(temp___0 + 1) = (char )'\001';
      } else {
        *(temp___0 + 1) = (char )'\002';
      }
      *(temp___0 + 2) = (char )'\000';
      goto add_string;
      case_92: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )2);
      *(temp___0 + 0) = (char )c;
      *(temp___0 + 1) = (char )'\000';
      }
      goto add_string;
      case_97: /* CIL Label */ 
      case_101: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )2);
      }
      if (c == 97) {
        *(temp___0 + 0) = (char )'\a';
      } else {
        *(temp___0 + 0) = (char )'\033';
      }
      *(temp___0 + 1) = (char )'\000';
      goto add_string;
      switch_default: /* CIL Label */ 
      {
      temp___0 = xmalloc((size_t )3);
      *(temp___0 + 0) = (char )'\\';
      *(temp___0 + 1) = (char )c;
      *(temp___0 + 2) = (char )'\000';
      }
      add_string: 
      if (c) {
        string ++;
      }
      {
      result = sub_append_string(temp___0, result, & result_index, & result_size);
      temp___0 = (char *)((void *)0);
      *(result + result_index) = (char )'\000';
      }
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (result_index + 3 >= result_size) {
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! (result_index + 3 >= result_size)) {
              goto while_break___2;
            }
            result_size += 48;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
          result = xrealloc((void *)result, (size_t )result_size);
          }
        }
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      tmp___38 = result_index;
      result_index ++;
      *(result + tmp___38) = (char )c;
      *(result + result_index) = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
  save_dstack = dstack;
  dstack = temp_dstack;
  dstack.delimiter_depth = 0;
  if (promptvars) {
    {
    list___0 = expand_prompt_string(result, 1);
    free((void *)result);
    result = string_list(list___0);
    dispose_words(list___0);
    }
  } else { //Added block
  if (posixly_correct) {
    {
    list___0 = expand_prompt_string(result, 1);
    free((void *)result);
    result = string_list(list___0);
    dispose_words(list___0);
    }
  } else {
    {
    t = dequote_string(result);
    free((void *)result);
    result = t;
    }
  }
  }
  dstack = save_dstack;
  return (result);
}
}
int yyerror() 
{ 


  {
  {
  report_syntax_error((char *)((void *)0));
  reset_parser();
  }
  return (0);
}
}
static void report_syntax_error(char *message ) 
{ 
  char *msg ;
  char *t ;
  int token_end ;
  int i ;
  char msg2[2] ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
  if (message) {
    {
    parser_error(line_number, "%s", message);
    }
    if (interactive) {
      if (EOF_Reached) {
        EOF_Reached = 0;
      }
    }
    last_command_exit_value = 258;
    return;
  }
  if (shell_input_line) {
    if (*shell_input_line) {
      t = shell_input_line;
      i = shell_input_line_index;
      token_end = 0;
      if (i) {
        if ((int )*(t + i) == 0) {
          i --;
        }
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (i) {
          if (! ((int )*(t + i) == 32)) {
            if (! ((int )*(t + i) == 9)) {
              if (! ((int )*(t + i) == 10)) {
                goto while_break;
              }
            }
          }
        } else {
          goto while_break;
        }
        i --;
      }
      while_break: /* CIL Label */ ;
      }
      if (i) {
        token_end = i + 1;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (i) {
          if (*(t + i)) {
            {
            tmp = strchr(" \n\t;|&", (int )*(t + i));
            tmp___0 = (unsigned long )tmp != (unsigned long )((char *)((void *)0));
            }
          } else {
            tmp___0 = 0;
          }
          if (! (tmp___0 == 0)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (i != token_end) {
          if (! ((int )*(t + i) == 32)) {
            if (! ((int )*(t + i) == 9)) {
              if (! ((int )*(t + i) == 10)) {
                goto while_break___1;
              }
            }
          }
        } else {
          goto while_break___1;
        }
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      if (token_end) {
        goto _L;
      } else { //Added block
      if (i == 0) {
        if (token_end == 0) {
          _L: 
          if (token_end) {
            {
            msg = substring(t, i, token_end);
            }
          } else {
            msg2[0] = *(t + i);
            msg2[1] = (char )'\000';
            msg = msg2;
          }
          {
          parser_error(line_number, "syntax error near unexpected token `%s\'", msg);
          }
          if ((unsigned long )msg != (unsigned long )(msg2)) {
            {
            free((void *)msg);
            }
          }
        }
      }
      }
      if (interactive == 0) {
        {
        tmp___1 = strlen((char const   *)shell_input_line);
        tmp___2 = xmalloc(1UL + tmp___1);
        tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )shell_input_line);
        msg = tmp___3;
        tmp___4 = strlen((char const   *)msg);
        token_end = (int )tmp___4;
        }
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (token_end) {
            if (! ((int )*(msg + (token_end - 1)) == 10)) {
              goto while_break___2;
            }
          } else {
            goto while_break___2;
          }
          token_end --;
          *(msg + token_end) = (char )'\000';
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        parser_error(line_number, "`%s\'", msg);
        free((void *)msg);
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (EOF_Reached) {
      msg = (char *)"syntax error: unexpected end of file";
    } else {
      msg = (char *)"syntax error";
    }
    {
    parser_error(line_number, "%s", msg);
    }
    if (interactive) {
      if (EOF_Reached) {
        EOF_Reached = 0;
      }
    }
  }
  last_command_exit_value = 258;
  return;
}
}
static void discard_parser_constructs(int error_p ) 
{ 


  {
  return;
}
}
int ignoreeof  =    0;
int eof_encountered  =    0;
int eof_encountered_limit  =    10;
static void handle_eof_input_unit(void) 
{ 
  char const   *tmp ;

  {
  if (interactive) {
    if (EOF_Reached) {
      EOF_Reached = 0;
    }
    if (ignoreeof) {
      if (eof_encountered < eof_encountered_limit) {
        if (login_shell) {
          tmp = "logout";
        } else {
          tmp = "exit";
        }
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Use \"%s\" to leave the shell.\n",
                tmp);
        eof_encountered ++;
        prompt_string_pointer = (char **)((void *)0);
        prompt_again();
        current_token = '\n';
        last_read_token = current_token;
        }
        return;
      }
    }
    {
    reset_parser();
    exit_builtin((WORD_LIST *)((void *)0));
    }
  } else {
    EOF_Reached = 1;
  }
  return;
}
}
static WORD_LIST parse_string_error  ;
WORD_LIST *parse_string_to_word_list(char *s , char *whom ) 
{ 
  WORD_LIST *wl ;
  int tok ;
  int orig_line_number ;
  int orig_input_terminator ;
  int orig_line_count ;
  int old_remember_on_history ;
  int old_history_expansion_inhibited ;
  GENERIC_LIST *tmp ;
  WORD_LIST *tmp___0 ;

  {
  {
  old_remember_on_history = remember_on_history;
  old_history_expansion_inhibited = history_expansion_inhibited;
  bash_history_disable();
  orig_line_number = line_number;
  orig_line_count = current_command_line_count;
  orig_input_terminator = shell_input_line_terminator;
  push_stream(1);
  last_read_token = '\n';
  current_command_line_count = 0;
  with_input_from_string(s, whom);
  wl = (WORD_LIST *)((void *)0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tok = read_token(0);
    }
    if (! (tok != 295)) {
      goto while_break;
    }
    if (tok == 10) {
      if ((int )*(bash_input.location.string) == 0) {
        goto while_break;
      }
    }
    if (tok == 10) {
      goto while_continue;
    }
    if (tok != 278) {
      if (tok != 279) {
        {
        line_number = (orig_line_number + line_number) - 1;
        yyerror();
        }
        if (wl) {
          {
          dispose_words(wl);
          }
        }
        wl = & parse_string_error;
        goto while_break;
      }
    }
    {
    wl = make_word_list(yylval.word, wl);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  last_read_token = '\n';
  pop_stream();
  remember_on_history = old_remember_on_history;
  history_expansion_inhibited = old_history_expansion_inhibited;
  current_command_line_count = orig_line_count;
  shell_input_line_terminator = orig_input_terminator;
  }
  if ((unsigned long )wl == (unsigned long )(& parse_string_error)) {
    last_command_exit_value = 1;
    if (interactive_shell == 0) {
      if (posixly_correct) {
        {
        jump_to_top_level(1);
        }
      } else {
        {
        jump_to_top_level(2);
        }
      }
    } else {
      {
      jump_to_top_level(2);
      }
    }
  }
  if (wl) {
    if (wl->next) {
      {
      tmp = reverse_list((GENERIC_LIST *)wl);
      tmp___0 = (WORD_LIST *)tmp;
      }
    } else {
      tmp___0 = wl;
    }
  } else {
    tmp___0 = wl;
  }
  return (tmp___0);
}
}
static int yygrowstack(void) 
{ 
  int newsize ;
  int i ;
  short *newss ;
  YYSTYPE *newvs ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  newsize = yystacksize;
  if (newsize == 0) {
    newsize = 200;
  } else { //Added block
  if (newsize >= 10000) {
    return (-1);
  } else {
    newsize *= 2;
    if (newsize > 10000) {
      newsize = 10000;
    }
  }
  }
  i = (int )(yyssp - yyss);
  if (yyss) {
    {
    tmp = realloc((void *)yyss, (unsigned long )newsize * sizeof(*newss));
    newss = (short *)tmp;
    }
  } else {
    {
    tmp___0 = malloc((unsigned long )newsize * sizeof(*newss));
    newss = (short *)tmp___0;
    }
  }
  if ((unsigned long )newss == (unsigned long )((void *)0)) {
    return (-1);
  }
  yyss = newss;
  yyssp = newss + i;
  if (yyvs) {
    {
    tmp___1 = realloc((void *)yyvs, (unsigned long )newsize * sizeof(*newvs));
    newvs = (YYSTYPE *)tmp___1;
    }
  } else {
    {
    tmp___2 = malloc((unsigned long )newsize * sizeof(*newvs));
    newvs = (YYSTYPE *)tmp___2;
    }
  }
  if ((unsigned long )newvs == (unsigned long )((void *)0)) {
    return (-1);
  }
  yyvs = newvs;
  yyvsp = newvs + i;
  yystacksize = newsize;
  yysslim = (yyss + newsize) - 1;
  return (0);
}
}
int yyparse(void) 
{ 
  register int yym ;
  register int yyn ;
  register int yystate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  register REDIRECT *t ;
  COMMAND *tc ;
  register REDIRECT *t___0 ;
  WORD_LIST *tmp___6 ;
  WORD_LIST *tmp___7 ;
  WORD_LIST *tmp___8 ;
  WORD_LIST *tmp___9 ;
  GENERIC_LIST *tmp___10 ;
  WORD_LIST *tmp___11 ;
  GENERIC_LIST *tmp___12 ;
  WORD_LIST *tmp___13 ;
  WORD_LIST *tmp___14 ;
  WORD_LIST *tmp___15 ;
  WORD_LIST *tmp___16 ;
  WORD_LIST *tmp___17 ;
  GENERIC_LIST *tmp___18 ;
  GENERIC_LIST *tmp___19 ;
  COMMAND *tc___0 ;
  register REDIRECT *t___1 ;
  int tmp___20 ;

  {
  yynerrs = 0;
  yyerrflag = 0;
  yychar = -1;
  if ((unsigned long )yyss == (unsigned long )((void *)0)) {
    {
    tmp = yygrowstack();
    }
    if (tmp) {
      goto yyoverflow;
    }
  }
  yyssp = yyss;
  yyvsp = yyvs;
  yystate = 0;
  *yyssp = (short )yystate;
  yyloop: 
  yyn = (int )yydefred[yystate];
  if (yyn) {
    goto yyreduce;
  }
  if (yychar < 0) {
    {
    yychar = yylex();
    }
    if (yychar < 0) {
      yychar = 0;
    }
  }
  yyn = (int )yysindex[yystate];
  if (yyn) {
    yyn += yychar;
    if (yyn >= 0) {
      if (yyn <= 1468) {
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
          if ((unsigned long )yyssp >= (unsigned long )yysslim) {
            {
            tmp___0 = yygrowstack();
            }
            if (tmp___0) {
              goto yyoverflow;
            }
          }
          yyssp ++;
          yystate = (int )yytable[yyn];
          *yyssp = (short )yystate;
          yyvsp ++;
          *yyvsp = yylval;
          yychar = -1;
          if (yyerrflag > 0) {
            yyerrflag --;
          }
          goto yyloop;
        }
      }
    }
  }
  yyn = (int )yyrindex[yystate];
  if (yyn) {
    yyn += yychar;
    if (yyn >= 0) {
      if (yyn <= 1468) {
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
          yyn = (int )yytable[yyn];
          goto yyreduce;
        }
      }
    }
  }
  if (yyerrflag) {
    goto yyinrecovery;
  }
  goto yynewerror;
  yynewerror: 
  {
  yyerror("syntax error");
  }
  goto yyerrlab;
  yyerrlab: 
  yynerrs ++;
  yyinrecovery: 
  if (yyerrflag < 3) {
    yyerrflag = 3;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      yyn = (int )yysindex[*yyssp];
      if (yyn) {
        yyn += 256;
        if (yyn >= 0) {
          if (yyn <= 1468) {
            if ((int const   )yycheck[yyn] == 256) {
              if ((unsigned long )yyssp >= (unsigned long )yysslim) {
                {
                tmp___1 = yygrowstack();
                }
                if (tmp___1) {
                  goto yyoverflow;
                }
              }
              yyssp ++;
              yystate = (int )yytable[yyn];
              *yyssp = (short )yystate;
              yyvsp ++;
              *yyvsp = yylval;
              goto yyloop;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        if ((unsigned long )yyssp <= (unsigned long )yyss) {
          goto yyabort;
        }
        yyssp --;
        yyvsp --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    if (yychar == 0) {
      goto yyabort;
    }
    yychar = -1;
    goto yyloop;
  }
  yyreduce: 
  yym = (int )yylen[yyn];
  yyval = *(yyvsp + (1 - yym));
  {
  if (yyn == 1) {
    goto case_1;
  }
  if (yyn == 2) {
    goto case_2;
  }
  if (yyn == 3) {
    goto case_3;
  }
  if (yyn == 4) {
    goto case_4;
  }
  if (yyn == 5) {
    goto case_5;
  }
  if (yyn == 6) {
    goto case_6;
  }
  if (yyn == 7) {
    goto case_7;
  }
  if (yyn == 8) {
    goto case_8;
  }
  if (yyn == 9) {
    goto case_9;
  }
  if (yyn == 10) {
    goto case_10;
  }
  if (yyn == 11) {
    goto case_11;
  }
  if (yyn == 12) {
    goto case_12;
  }
  if (yyn == 13) {
    goto case_13;
  }
  if (yyn == 14) {
    goto case_14;
  }
  if (yyn == 15) {
    goto case_15;
  }
  if (yyn == 16) {
    goto case_16;
  }
  if (yyn == 17) {
    goto case_17;
  }
  if (yyn == 18) {
    goto case_18;
  }
  if (yyn == 19) {
    goto case_19;
  }
  if (yyn == 20) {
    goto case_20;
  }
  if (yyn == 21) {
    goto case_21;
  }
  if (yyn == 22) {
    goto case_22;
  }
  if (yyn == 23) {
    goto case_23;
  }
  if (yyn == 24) {
    goto case_24;
  }
  if (yyn == 25) {
    goto case_25;
  }
  if (yyn == 26) {
    goto case_26;
  }
  if (yyn == 27) {
    goto case_27;
  }
  if (yyn == 28) {
    goto case_28;
  }
  if (yyn == 29) {
    goto case_29;
  }
  if (yyn == 30) {
    goto case_30;
  }
  if (yyn == 31) {
    goto case_31;
  }
  if (yyn == 32) {
    goto case_32;
  }
  if (yyn == 33) {
    goto case_33;
  }
  if (yyn == 34) {
    goto case_34;
  }
  if (yyn == 35) {
    goto case_35;
  }
  if (yyn == 36) {
    goto case_36;
  }
  if (yyn == 37) {
    goto case_37;
  }
  if (yyn == 38) {
    goto case_38;
  }
  if (yyn == 39) {
    goto case_39;
  }
  if (yyn == 40) {
    goto case_40;
  }
  if (yyn == 41) {
    goto case_41;
  }
  if (yyn == 42) {
    goto case_42;
  }
  if (yyn == 43) {
    goto case_43;
  }
  if (yyn == 44) {
    goto case_44;
  }
  if (yyn == 45) {
    goto case_45;
  }
  if (yyn == 46) {
    goto case_46;
  }
  if (yyn == 47) {
    goto case_47;
  }
  if (yyn == 48) {
    goto case_48;
  }
  if (yyn == 49) {
    goto case_49;
  }
  if (yyn == 50) {
    goto case_50;
  }
  if (yyn == 51) {
    goto case_51;
  }
  if (yyn == 52) {
    goto case_52;
  }
  if (yyn == 53) {
    goto case_53;
  }
  if (yyn == 54) {
    goto case_54;
  }
  if (yyn == 55) {
    goto case_55;
  }
  if (yyn == 56) {
    goto case_56;
  }
  if (yyn == 57) {
    goto case_57;
  }
  if (yyn == 58) {
    goto case_58;
  }
  if (yyn == 59) {
    goto case_59;
  }
  if (yyn == 60) {
    goto case_60;
  }
  if (yyn == 61) {
    goto case_61;
  }
  if (yyn == 62) {
    goto case_62;
  }
  if (yyn == 63) {
    goto case_63;
  }
  if (yyn == 64) {
    goto case_64;
  }
  if (yyn == 65) {
    goto case_65;
  }
  if (yyn == 66) {
    goto case_66;
  }
  if (yyn == 67) {
    goto case_67;
  }
  if (yyn == 68) {
    goto case_68;
  }
  if (yyn == 69) {
    goto case_69;
  }
  if (yyn == 70) {
    goto case_70;
  }
  if (yyn == 71) {
    goto case_71;
  }
  if (yyn == 72) {
    goto case_72;
  }
  if (yyn == 73) {
    goto case_73;
  }
  if (yyn == 74) {
    goto case_74;
  }
  if (yyn == 75) {
    goto case_75;
  }
  if (yyn == 76) {
    goto case_76;
  }
  if (yyn == 77) {
    goto case_77;
  }
  if (yyn == 78) {
    goto case_78;
  }
  if (yyn == 79) {
    goto case_79;
  }
  if (yyn == 80) {
    goto case_80;
  }
  if (yyn == 81) {
    goto case_81;
  }
  if (yyn == 82) {
    goto case_82;
  }
  if (yyn == 83) {
    goto case_83;
  }
  if (yyn == 84) {
    goto case_84;
  }
  if (yyn == 85) {
    goto case_85;
  }
  if (yyn == 86) {
    goto case_86;
  }
  if (yyn == 87) {
    goto case_87;
  }
  if (yyn == 88) {
    goto case_88;
  }
  if (yyn == 89) {
    goto case_89;
  }
  if (yyn == 91) {
    goto case_91;
  }
  if (yyn == 92) {
    goto case_92;
  }
  if (yyn == 93) {
    goto case_93;
  }
  if (yyn == 94) {
    goto case_94;
  }
  if (yyn == 95) {
    goto case_95;
  }
  if (yyn == 97) {
    goto case_97;
  }
  if (yyn == 98) {
    goto case_98;
  }
  if (yyn == 99) {
    goto case_99;
  }
  if (yyn == 100) {
    goto case_100;
  }
  if (yyn == 102) {
    goto case_102;
  }
  if (yyn == 104) {
    goto case_104;
  }
  if (yyn == 106) {
    goto case_106;
  }
  if (yyn == 107) {
    goto case_107;
  }
  if (yyn == 108) {
    goto case_108;
  }
  if (yyn == 109) {
    goto case_109;
  }
  if (yyn == 110) {
    goto case_110;
  }
  if (yyn == 111) {
    goto case_111;
  }
  if (yyn == 117) {
    goto case_117;
  }
  if (yyn == 118) {
    goto case_118;
  }
  if (yyn == 119) {
    goto case_119;
  }
  if (yyn == 120) {
    goto case_120;
  }
  if (yyn == 121) {
    goto case_121;
  }
  if (yyn == 122) {
    goto case_122;
  }
  if (yyn == 123) {
    goto case_123;
  }
  if (yyn == 124) {
    goto case_124;
  }
  if (yyn == 125) {
    goto case_125;
  }
  if (yyn == 126) {
    goto case_126;
  }
  if (yyn == 127) {
    goto case_127;
  }
  if (yyn == 128) {
    goto case_128;
  }
  if (yyn == 129) {
    goto case_129;
  }
  if (yyn == 130) {
    goto case_130;
  }
  if (yyn == 131) {
    goto case_131;
  }
  if (yyn == 132) {
    goto case_132;
  }
  if (yyn == 133) {
    goto case_133;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  global_command = (yyvsp + -1)->command;
  eof_encountered = 0;
  discard_parser_constructs(0);
  }
  goto yyaccept;
  goto switch_break;
  case_2: /* CIL Label */ 
  global_command = (COMMAND *)((void *)0);
  goto yyaccept;
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  global_command = (COMMAND *)((void *)0);
  eof_encountered = 0;
  discard_parser_constructs(1);
  }
  if (interactive) {
    goto yyaccept;
  } else {
    goto yyabort;
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  global_command = (COMMAND *)((void *)0);
  handle_eof_input_unit();
  }
  goto yyaccept;
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  yyval.word_list = make_word_list((yyvsp + 0)->word, (WORD_LIST *)((void *)0));
  }
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  yyval.word_list = make_word_list((yyvsp + 0)->word, (yyvsp + -1)->word_list);
  }
  goto switch_break;
  case_7: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(1, (enum r_instruction )0, redir);
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(0, (enum r_instruction )1, redir);
  }
  goto switch_break;
  case_9: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )0,
                                    redir);
  }
  goto switch_break;
  case_10: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )1,
                                    redir);
  }
  goto switch_break;
  case_11: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(1, (enum r_instruction )3, redir);
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )3,
                                    redir);
  }
  goto switch_break;
  case_13: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(0, (enum r_instruction )4, redir);
  tmp___2 = need_here_doc;
  need_here_doc ++;
  redir_stack[tmp___2] = yyval.redirect;
  }
  goto switch_break;
  case_14: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )4,
                                    redir);
  tmp___3 = need_here_doc;
  need_here_doc ++;
  redir_stack[tmp___3] = yyval.redirect;
  }
  goto switch_break;
  case_15: /* CIL Label */ 
  {
  redir.dest = (long )(yyvsp + 0)->number;
  yyval.redirect = make_redirection(0, (enum r_instruction )5, redir);
  }
  goto switch_break;
  case_16: /* CIL Label */ 
  {
  redir.dest = (long )(yyvsp + 0)->number;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )5,
                                    redir);
  }
  goto switch_break;
  case_17: /* CIL Label */ 
  {
  redir.dest = (long )(yyvsp + 0)->number;
  yyval.redirect = make_redirection(1, (enum r_instruction )6, redir);
  }
  goto switch_break;
  case_18: /* CIL Label */ 
  {
  redir.dest = (long )(yyvsp + 0)->number;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )6,
                                    redir);
  }
  goto switch_break;
  case_19: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(0, (enum r_instruction )12, redir);
  }
  goto switch_break;
  case_20: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )12,
                                    redir);
  }
  goto switch_break;
  case_21: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(1, (enum r_instruction )13, redir);
  }
  goto switch_break;
  case_22: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )13,
                                    redir);
  }
  goto switch_break;
  case_23: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(0, (enum r_instruction )7, redir);
  tmp___4 = need_here_doc;
  need_here_doc ++;
  redir_stack[tmp___4] = yyval.redirect;
  }
  goto switch_break;
  case_24: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )7,
                                    redir);
  tmp___5 = need_here_doc;
  need_here_doc ++;
  redir_stack[tmp___5] = yyval.redirect;
  }
  goto switch_break;
  case_25: /* CIL Label */ 
  {
  redir.dest = 0L;
  yyval.redirect = make_redirection(1, (enum r_instruction )8, redir);
  }
  goto switch_break;
  case_26: /* CIL Label */ 
  {
  redir.dest = 0L;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )8,
                                    redir);
  }
  goto switch_break;
  case_27: /* CIL Label */ 
  {
  redir.dest = 0L;
  yyval.redirect = make_redirection(0, (enum r_instruction )8, redir);
  }
  goto switch_break;
  case_28: /* CIL Label */ 
  {
  redir.dest = 0L;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )8,
                                    redir);
  }
  goto switch_break;
  case_29: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(1, (enum r_instruction )9, redir);
  }
  goto switch_break;
  case_30: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )10,
                                    redir);
  }
  goto switch_break;
  case_31: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(0, (enum r_instruction )10, redir);
  }
  goto switch_break;
  case_32: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection(1, (enum r_instruction )11, redir);
  }
  goto switch_break;
  case_33: /* CIL Label */ 
  {
  redir.filename = (yyvsp + 0)->word;
  yyval.redirect = make_redirection((yyvsp + -2)->number, (enum r_instruction )11,
                                    redir);
  }
  goto switch_break;
  case_34: /* CIL Label */ 
  yyval.element.word = (yyvsp + 0)->word;
  yyval.element.redirect = (REDIRECT *)0;
  goto switch_break;
  case_35: /* CIL Label */ 
  yyval.element.word = (yyvsp + 0)->word;
  yyval.element.redirect = (REDIRECT *)0;
  goto switch_break;
  case_36: /* CIL Label */ 
  yyval.element.redirect = (yyvsp + 0)->redirect;
  yyval.element.word = (WORD_DESC *)0;
  goto switch_break;
  case_37: /* CIL Label */ 
  yyval.redirect = (yyvsp + 0)->redirect;
  goto switch_break;
  case_38: /* CIL Label */ 
  t = (yyvsp + -1)->redirect;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! t->next) {
      goto while_break___0;
    }
    t = t->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  t->next = (yyvsp + 0)->redirect;
  yyval.redirect = (yyvsp + -1)->redirect;
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  yyval.command = make_simple_command((yyvsp + 0)->element, (COMMAND *)((void *)0));
  }
  goto switch_break;
  case_40: /* CIL Label */ 
  {
  yyval.command = make_simple_command((yyvsp + 0)->element, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_41: /* CIL Label */ 
  {
  yyval.command = clean_simple_command((yyvsp + 0)->command);
  }
  goto switch_break;
  case_42: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_43: /* CIL Label */ 
  tc = (yyvsp + -1)->command;
  if (tc->redirects) {
    t___0 = tc->redirects;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! t___0->next) {
        goto while_break___1;
      }
      t___0 = t___0->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    t___0->next = (yyvsp + 0)->redirect;
  } else {
    tc->redirects = (yyvsp + 0)->redirect;
  }
  yyval.command = (yyvsp + -1)->command;
  goto switch_break;
  case_44: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_45: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_46: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_47: /* CIL Label */ 
  {
  yyval.command = make_while_command((yyvsp + -3)->command, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_48: /* CIL Label */ 
  {
  yyval.command = make_until_command((yyvsp + -3)->command, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_49: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_50: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_51: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_52: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_53: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_54: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_55: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_56: /* CIL Label */ 
  {
  tmp___6 = add_string_to_list((char *)"\"$@\"", (WORD_LIST *)((void *)0));
  yyval.command = make_for_command((yyvsp + -4)->word, tmp___6, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_57: /* CIL Label */ 
  {
  tmp___7 = add_string_to_list((char *)"$@", (WORD_LIST *)((void *)0));
  yyval.command = make_for_command((yyvsp + -4)->word, tmp___7, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_58: /* CIL Label */ 
  {
  tmp___8 = add_string_to_list((char *)"\"$@\"", (WORD_LIST *)((void *)0));
  yyval.command = make_for_command((yyvsp + -5)->word, tmp___8, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_59: /* CIL Label */ 
  {
  tmp___9 = add_string_to_list((char *)"\"$@\"", (WORD_LIST *)((void *)0));
  yyval.command = make_for_command((yyvsp + -5)->word, tmp___9, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_60: /* CIL Label */ 
  if ((yyvsp + -5)->word_list) {
    if (((yyvsp + -5)->word_list)->next) {
      {
      tmp___10 = reverse_list((GENERIC_LIST *)(yyvsp + -5)->word_list);
      tmp___11 = (WORD_LIST *)tmp___10;
      }
    } else {
      tmp___11 = (yyvsp + -5)->word_list;
    }
  } else {
    tmp___11 = (yyvsp + -5)->word_list;
  }
  {
  yyval.command = make_for_command((yyvsp + -8)->word, tmp___11, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_61: /* CIL Label */ 
  if ((yyvsp + -5)->word_list) {
    if (((yyvsp + -5)->word_list)->next) {
      {
      tmp___12 = reverse_list((GENERIC_LIST *)(yyvsp + -5)->word_list);
      tmp___13 = (WORD_LIST *)tmp___12;
      }
    } else {
      tmp___13 = (yyvsp + -5)->word_list;
    }
  } else {
    tmp___13 = (yyvsp + -5)->word_list;
  }
  {
  yyval.command = make_for_command((yyvsp + -8)->word, tmp___13, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_62: /* CIL Label */ 
  {
  yyval.command = make_arith_for_command((yyvsp + -5)->word_list, (yyvsp + -1)->command,
                                         arith_for_lineno);
  }
  goto switch_break;
  case_63: /* CIL Label */ 
  {
  yyval.command = make_arith_for_command((yyvsp + -5)->word_list, (yyvsp + -1)->command,
                                         arith_for_lineno);
  }
  goto switch_break;
  case_64: /* CIL Label */ 
  {
  yyval.command = make_arith_for_command((yyvsp + -3)->word_list, (yyvsp + -1)->command,
                                         arith_for_lineno);
  }
  goto switch_break;
  case_65: /* CIL Label */ 
  {
  yyval.command = make_arith_for_command((yyvsp + -3)->word_list, (yyvsp + -1)->command,
                                         arith_for_lineno);
  }
  goto switch_break;
  case_66: /* CIL Label */ 
  {
  tmp___14 = add_string_to_list((char *)"\"$@\"", (WORD_LIST *)((void *)0));
  yyval.command = make_select_command((yyvsp + -4)->word, tmp___14, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_67: /* CIL Label */ 
  {
  tmp___15 = add_string_to_list((char *)"$@", (WORD_LIST *)((void *)0));
  yyval.command = make_select_command((yyvsp + -4)->word, tmp___15, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_68: /* CIL Label */ 
  {
  tmp___16 = add_string_to_list((char *)"\"$@\"", (WORD_LIST *)((void *)0));
  yyval.command = make_select_command((yyvsp + -5)->word, tmp___16, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_69: /* CIL Label */ 
  {
  tmp___17 = add_string_to_list((char *)"\"$@\"", (WORD_LIST *)((void *)0));
  yyval.command = make_select_command((yyvsp + -5)->word, tmp___17, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_70: /* CIL Label */ 
  {
  tmp___18 = reverse_list((GENERIC_LIST *)(yyvsp + -5)->word_list);
  yyval.command = make_select_command((yyvsp + -8)->word, (WORD_LIST *)tmp___18, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_71: /* CIL Label */ 
  {
  tmp___19 = reverse_list((GENERIC_LIST *)(yyvsp + -5)->word_list);
  yyval.command = make_select_command((yyvsp + -8)->word, (WORD_LIST *)tmp___19, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_72: /* CIL Label */ 
  {
  yyval.command = make_case_command((yyvsp + -4)->word, (PATTERN_LIST *)((void *)0));
  }
  goto switch_break;
  case_73: /* CIL Label */ 
  {
  yyval.command = make_case_command((yyvsp + -5)->word, (yyvsp + -2)->pattern);
  }
  goto switch_break;
  case_74: /* CIL Label */ 
  {
  yyval.command = make_case_command((yyvsp + -4)->word, (yyvsp + -1)->pattern);
  }
  goto switch_break;
  case_75: /* CIL Label */ 
  {
  yyval.command = make_function_def((yyvsp + -4)->word, (yyvsp + 0)->command, function_dstart,
                                    function_bstart);
  }
  goto switch_break;
  case_76: /* CIL Label */ 
  {
  yyval.command = make_function_def((yyvsp + -4)->word, (yyvsp + 0)->command, function_dstart,
                                    function_bstart);
  }
  goto switch_break;
  case_77: /* CIL Label */ 
  {
  yyval.command = make_function_def((yyvsp + -2)->word, (yyvsp + 0)->command, function_dstart,
                                    function_bstart);
  }
  goto switch_break;
  case_78: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_79: /* CIL Label */ 
  tc___0 = (yyvsp + -1)->command;
  if (tc___0->redirects) {
    t___1 = tc___0->redirects;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! t___1->next) {
        goto while_break___2;
      }
      t___1 = t___1->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    t___1->next = (yyvsp + 0)->redirect;
  } else {
    tc___0->redirects = (yyvsp + 0)->redirect;
  }
  yyval.command = (yyvsp + -1)->command;
  goto switch_break;
  case_80: /* CIL Label */ 
  {
  yyval.command = make_subshell_command((yyvsp + -1)->command);
  (yyval.command)->flags |= 1;
  }
  goto switch_break;
  case_81: /* CIL Label */ 
  {
  yyval.command = make_if_command((yyvsp + -3)->command, (yyvsp + -1)->command, (COMMAND *)((void *)0));
  }
  goto switch_break;
  case_82: /* CIL Label */ 
  {
  yyval.command = make_if_command((yyvsp + -5)->command, (yyvsp + -3)->command, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  yyval.command = make_if_command((yyvsp + -4)->command, (yyvsp + -2)->command, (yyvsp + -1)->command);
  }
  goto switch_break;
  case_84: /* CIL Label */ 
  {
  yyval.command = make_group_command((yyvsp + -1)->command);
  }
  goto switch_break;
  case_85: /* CIL Label */ 
  {
  yyval.command = make_arith_command((yyvsp + 0)->word_list);
  }
  goto switch_break;
  case_86: /* CIL Label */ 
  yyval.command = (yyvsp + -1)->command;
  goto switch_break;
  case_87: /* CIL Label */ 
  {
  yyval.command = make_if_command((yyvsp + -2)->command, (yyvsp + 0)->command, (COMMAND *)((void *)0));
  }
  goto switch_break;
  case_88: /* CIL Label */ 
  {
  yyval.command = make_if_command((yyvsp + -4)->command, (yyvsp + -2)->command, (yyvsp + 0)->command);
  }
  goto switch_break;
  case_89: /* CIL Label */ 
  {
  yyval.command = make_if_command((yyvsp + -3)->command, (yyvsp + -1)->command, (yyvsp + 0)->command);
  }
  goto switch_break;
  case_91: /* CIL Label */ 
  ((yyvsp + 0)->pattern)->next = (yyvsp + -1)->pattern;
  yyval.pattern = (yyvsp + 0)->pattern;
  goto switch_break;
  case_92: /* CIL Label */ 
  {
  yyval.pattern = make_pattern_list((yyvsp + -2)->word_list, (yyvsp + 0)->command);
  }
  goto switch_break;
  case_93: /* CIL Label */ 
  {
  yyval.pattern = make_pattern_list((yyvsp + -2)->word_list, (COMMAND *)((void *)0));
  }
  goto switch_break;
  case_94: /* CIL Label */ 
  {
  yyval.pattern = make_pattern_list((yyvsp + -2)->word_list, (yyvsp + 0)->command);
  }
  goto switch_break;
  case_95: /* CIL Label */ 
  {
  yyval.pattern = make_pattern_list((yyvsp + -2)->word_list, (COMMAND *)((void *)0));
  }
  goto switch_break;
  case_97: /* CIL Label */ 
  ((yyvsp + -1)->pattern)->next = (yyvsp + -2)->pattern;
  yyval.pattern = (yyvsp + -1)->pattern;
  goto switch_break;
  case_98: /* CIL Label */ 
  {
  yyval.word_list = make_word_list((yyvsp + 0)->word, (WORD_LIST *)((void *)0));
  }
  goto switch_break;
  case_99: /* CIL Label */ 
  {
  yyval.word_list = make_word_list((yyvsp + 0)->word, (yyvsp + -2)->word_list);
  }
  goto switch_break;
  case_100: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  if (need_here_doc) {
    {
    gather_here_documents();
    }
  }
  goto switch_break;
  case_102: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_104: /* CIL Label */ 
  if ((unsigned int )((yyvsp + -2)->command)->type == 6U) {
    {
    yyval.command = connect_async_list((yyvsp + -2)->command, (COMMAND *)((void *)0),
                                       '&');
    }
  } else {
    {
    yyval.command = command_connect((yyvsp + -2)->command, (COMMAND *)((void *)0),
                                    '&');
    }
  }
  goto switch_break;
  case_106: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, 284);
  }
  goto switch_break;
  case_107: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, 285);
  }
  goto switch_break;
  case_108: /* CIL Label */ 
  if ((unsigned int )((yyvsp + -3)->command)->type == 6U) {
    {
    yyval.command = connect_async_list((yyvsp + -3)->command, (yyvsp + 0)->command,
                                       '&');
    }
  } else {
    {
    yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, '&');
    }
  }
  goto switch_break;
  case_109: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, ';');
  }
  goto switch_break;
  case_110: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, ';');
  }
  goto switch_break;
  case_111: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_117: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  if (need_here_doc) {
    {
    gather_here_documents();
    }
  }
  goto switch_break;
  case_118: /* CIL Label */ 
  if ((unsigned int )((yyvsp + -1)->command)->type == 6U) {
    {
    yyval.command = connect_async_list((yyvsp + -1)->command, (COMMAND *)((void *)0),
                                       '&');
    }
  } else {
    {
    yyval.command = command_connect((yyvsp + -1)->command, (COMMAND *)((void *)0),
                                    '&');
    }
  }
  if (need_here_doc) {
    {
    gather_here_documents();
    }
  }
  goto switch_break;
  case_119: /* CIL Label */ 
  yyval.command = (yyvsp + -1)->command;
  if (need_here_doc) {
    {
    gather_here_documents();
    }
  }
  goto switch_break;
  case_120: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, 284);
  }
  goto switch_break;
  case_121: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, 285);
  }
  goto switch_break;
  case_122: /* CIL Label */ 
  if ((unsigned int )((yyvsp + -2)->command)->type == 6U) {
    {
    yyval.command = connect_async_list((yyvsp + -2)->command, (yyvsp + 0)->command,
                                       '&');
    }
  } else {
    {
    yyval.command = command_connect((yyvsp + -2)->command, (yyvsp + 0)->command, '&');
    }
  }
  goto switch_break;
  case_123: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -2)->command, (yyvsp + 0)->command, ';');
  }
  goto switch_break;
  case_124: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_125: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_126: /* CIL Label */ 
  ((yyvsp + 0)->command)->flags |= 4;
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_127: /* CIL Label */ 
  ((yyvsp + 0)->command)->flags |= (yyvsp + -1)->number;
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_128: /* CIL Label */ 
  ((yyvsp + 0)->command)->flags |= (yyvsp + -2)->number | 4;
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_129: /* CIL Label */ 
  ((yyvsp + 0)->command)->flags |= (yyvsp + -1)->number | 4;
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_130: /* CIL Label */ 
  {
  yyval.command = command_connect((yyvsp + -3)->command, (yyvsp + 0)->command, '|');
  }
  goto switch_break;
  case_131: /* CIL Label */ 
  yyval.command = (yyvsp + 0)->command;
  goto switch_break;
  case_132: /* CIL Label */ 
  yyval.number = 128;
  goto switch_break;
  case_133: /* CIL Label */ 
  yyval.number = 384;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  yyssp -= yym;
  yystate = (int )*yyssp;
  yyvsp -= yym;
  yym = (int )yylhs[yyn];
  if (yystate == 0) {
    if (yym == 0) {
      yystate = 30;
      yyssp ++;
      *yyssp = (short)30;
      yyvsp ++;
      *yyvsp = yyval;
      if (yychar < 0) {
        {
        yychar = yylex();
        }
        if (yychar < 0) {
          yychar = 0;
        }
      }
      if (yychar == 0) {
        goto yyaccept;
      }
      goto yyloop;
    }
  }
  yyn = (int )yygindex[yym];
  if (yyn) {
    yyn += yystate;
    if (yyn >= 0) {
      if (yyn <= 1468) {
        if ((int const   )yycheck[yyn] == (int const   )yystate) {
          yystate = (int )yytable[yyn];
        } else {
          yystate = (int )yydgoto[yym];
        }
      } else {
        yystate = (int )yydgoto[yym];
      }
    } else {
      yystate = (int )yydgoto[yym];
    }
  } else {
    yystate = (int )yydgoto[yym];
  }
  if ((unsigned long )yyssp >= (unsigned long )yysslim) {
    {
    tmp___20 = yygrowstack();
    }
    if (tmp___20) {
      goto yyoverflow;
    }
  }
  yyssp ++;
  *yyssp = (short )yystate;
  yyvsp ++;
  *yyvsp = yyval;
  goto yyloop;
  yyoverflow: 
  {
  yyerror("yacc stack overflow");
  }
  yyabort: 
  return (1);
  yyaccept: 
  return (0);
}
}
#pragma merger("0","/tmp/cil-eAThNTkx.i","-g")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getdtablesize)(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern int putchar(int __c ) ;
void posix_initialize(int on ) ;
rlim_t string_to_rlimtype(char *s ) ;
void print_rlimtype(rlim_t n , int addnl ) ;
int all_digits(char *string ) ;
int legal_number(char *string , long *result ) ;
int legal_identifier(char *name ) ;
int check_identifier(WORD_DESC *word , int check_word ) ;
int same_file(char *path1 , char *path2 , struct stat *stp1 , struct stat *stp2 ) ;
char *make_absolute(char *string , char *dot_path ) ;
int absolute_pathname(char *string ) ;
char *full_pathname(char *file ) ;
char *extract_colon_unit(char *string , int *p_index ) ;
char *bash_tilde_expand(char *s ) ;
int group_member(gid_t gid ) ;
char **get_group_list(int *ngp ) ;
int *get_group_array(int *ngp ) ;
extern char *sh_makepath(char * , char * , int  ) ;
extern char **alloc_array(int  ) ;
extern tilde_hook_func_t *tilde_expansion_preexpansion_hook ;
extern char **tilde_additional_prefixes ;
extern char **tilde_additional_suffixes ;
extern char *tilde_expand(char const   * ) ;
extern int source_uses_path ;
extern int source_searches_cwd ;
char *bash_getcwd_errstr  =    (char *)"getcwd: cannot access parent directories";
void posix_initialize(int on ) 
{ 


  {
  if (on != 0) {
    expand_aliases = 1;
    source_uses_path = expand_aliases;
    interactive_comments = source_uses_path;
  }
  if (on == 0) {
    source_searches_cwd = 1;
    expand_aliases = interactive_shell;
  }
  return;
}
}
rlim_t string_to_rlimtype(char *s ) 
{ 
  rlim_t ret ;
  int neg ;
  unsigned short const   **tmp ;
  rlim_t tmp___0 ;

  {
  ret = (rlim_t )0;
  neg = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (s) {
      if (*s) {
        if (! ((int )*s == 32)) {
          if (! ((int )*s == 9)) {
            goto while_break;
          }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*s == 45) {
    neg = (int )*s == 45;
    s ++;
  } else { //Added block
  if ((int )*s == 43) {
    neg = (int )*s == 45;
    s ++;
  }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (s) {
      if (*s) {
        {
        tmp = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    ret = ret * 10UL + (rlim_t )((int )*s - 48);
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (neg) {
    tmp___0 = - ret;
  } else {
    tmp___0 = ret;
  }
  return (tmp___0);
}
}
void print_rlimtype(rlim_t n , int addnl ) 
{ 
  char s[sizeof(rlim_t ) * 3UL + 1UL] ;
  int len___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (n == 0UL) {
    if (addnl) {
      tmp = "\n";
    } else {
      tmp = "";
    }
    {
    printf((char const   * __restrict  )"0%s", tmp);
    }
    return;
  }
  if (n < 0UL) {
    {
    putchar('-');
    n = - n;
    }
  }
  len___0 = (int )(sizeof(rlim_t ) * 3UL + 1UL);
  len___0 --;
  s[len___0] = (char )'\000';
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (n != 0UL)) {
      goto while_break;
    }
    len___0 --;
    s[len___0] = (char )(n % 10UL + 48UL);
    n /= 10UL;
  }
  while_break: /* CIL Label */ ;
  }
  if (addnl) {
    tmp___0 = "\n";
  } else {
    tmp___0 = "";
  }
  {
  printf((char const   * __restrict  )"%s%s", s + len___0, tmp___0);
  }
  return;
}
}
int all_digits(char *string ) 
{ 
  register char *s ;
  unsigned short const   **tmp ;

  {
  s = string;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp = __ctype_b_loc();
    }
    if (((int const   )*(*tmp + (int )*s) & 2048) == 0) {
      return (0);
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
int legal_number(char *string , long *result ) 
{ 
  long value ;
  char *ep ;

  {
  if (result) {
    *result = 0L;
  }
  {
  value = strtol((char const   * __restrict  )string, (char ** __restrict  )(& ep),
                 10);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*ep == 32)) {
      if (! ((int )*ep == 9)) {
        goto while_break;
      }
    }
    ep ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (string) {
    if (*string) {
      if ((int )*ep == 0) {
        if (result) {
          *result = value;
        }
        return (1);
      }
    }
  }
  return (0);
}
}
int legal_identifier(char *name ) 
{ 
  register char *s ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  if (! name) {
    return (0);
  } else { //Added block
  if (! *name) {
    return (0);
  } else {
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )*name) & 1024) {
      tmp___0 = 1;
    } else { //Added block
    if ((int )*name == 95) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    }
    if (tmp___0 == 0) {
      return (0);
    }
  }
  }
  s = name + 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp___1 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___1 + (int )*s) & 1024) {
      tmp___3 = 1;
    } else {
      {
      tmp___2 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___2 + (int )*s) & 2048) {
        tmp___3 = 1;
      } else { //Added block
      if ((int )*s == 95) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      }
    }
    if (tmp___3 == 0) {
      return (0);
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
int check_identifier(WORD_DESC *word , int check_word ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (word->flags & 3) {
    {
    internal_error("`%s\': not a valid identifier", word->word);
    }
    return (0);
  } else {
    {
    tmp___0 = all_digits(word->word);
    }
    if (tmp___0) {
      {
      internal_error("`%s\': not a valid identifier", word->word);
      }
      return (0);
    } else { //Added block
    if (check_word) {
      {
      tmp = legal_identifier(word->word);
      }
      if (tmp == 0) {
        {
        internal_error("`%s\': not a valid identifier", word->word);
        }
        return (0);
      } else {
        return (1);
      }
    } else {
      return (1);
    }
    }
  }
}
}
int sh_unset_nodelay_mode(int fd ) 
{ 
  int flags ;
  int bflags ;
  int tmp ;

  {
  {
  flags = fcntl(fd, 3, 0);
  }
  if (flags < 0) {
    return (-1);
  }
  bflags = 0;
  bflags |= 2048;
  bflags |= 2048;
  if (flags & bflags) {
    {
    flags &= ~ bflags;
    tmp = fcntl(fd, 4, flags);
    }
    return (tmp);
  }
  return (0);
}
}
void check_dev_tty(void) 
{ 
  int tty_fd ;
  char *tty ;
  int tmp ;
  char *tmp___0 ;

  {
  {
  tty_fd = open("/dev/tty", 2050);
  }
  if (tty_fd < 0) {
    {
    tmp = fileno(stdin);
    tmp___0 = ttyname(tmp);
    tty = tmp___0;
    }
    if ((unsigned long )tty == (unsigned long )((char *)0)) {
      return;
    }
    {
    tty_fd = open((char const   *)tty, 2050);
    }
  }
  {
  close(tty_fd);
  }
  return;
}
}
int same_file(char *path1 , char *path2 , struct stat *stp1 , struct stat *stp2 ) 
{ 
  struct stat st1 ;
  struct stat st2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )stp1 == (unsigned long )((void *)0)) {
    {
    tmp = stat((char const   * __restrict  )path1, (struct stat * __restrict  )(& st1));
    }
    if (tmp != 0) {
      return (0);
    }
    stp1 = & st1;
  }
  if ((unsigned long )stp2 == (unsigned long )((void *)0)) {
    {
    tmp___0 = stat((char const   * __restrict  )path2, (struct stat * __restrict  )(& st2));
    }
    if (tmp___0 != 0) {
      return (0);
    }
    stp2 = & st2;
  }
  if (stp1->st_dev == stp2->st_dev) {
    if (stp1->st_ino == stp2->st_ino) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
int move_to_high_fd(int fd , int check_new , int maxfd ) 
{ 
  int script_fd ;
  int nfds___0 ;
  int ignore ;
  int tmp ;
  int tmp___0 ;

  {
  if (maxfd < 20) {
    {
    nfds___0 = getdtablesize();
    }
    if (nfds___0 <= 0) {
      nfds___0 = 20;
    }
    if (nfds___0 > 256) {
      nfds___0 = 256;
    }
  } else {
    nfds___0 = maxfd;
  }
  nfds___0 --;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (check_new) {
      if (! (nfds___0 > 3)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = fcntl(nfds___0, 1, & ignore);
    }
    if (tmp == -1) {
      goto while_break;
    }
    nfds___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  if (nfds___0) {
    if (fd != nfds___0) {
      {
      script_fd = dup2(fd, nfds___0);
      }
      if (script_fd != -1) {
        if (check_new == 0) {
          {
          close(fd);
          }
        } else {
          {
          tmp___0 = fileno(stderr);
          }
          if (fd != tmp___0) {
            {
            close(fd);
            }
          }
        }
        return (script_fd);
      }
    }
  }
  return (fd);
}
}
int check_binary_file(unsigned char *sample , int sample_len ) 
{ 
  register int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < sample_len)) {
      goto while_break;
    }
    if ((int )*(sample + i) == 10) {
      return (0);
    }
    {
    tmp = __ctype_b_loc();
    }
    if (((int const   )*(*tmp + (int )*(sample + i)) & 8192) == 0) {
      {
      tmp___0 = __ctype_b_loc();
      }
      if (((int const   )*(*tmp___0 + (int )*(sample + i)) & 16384) == 0) {
        return (1);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
char *make_absolute(char *string , char *dot_path ) 
{ 
  char *result ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned long )dot_path == (unsigned long )((char *)0)) {
    {
    tmp = strlen((char const   *)string);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
    result = tmp___1;
    }
  } else { //Added block
  if ((int )*(string + 0) == 47) {
    {
    tmp = strlen((char const   *)string);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
    result = tmp___1;
    }
  } else {
    {
    result = sh_makepath(dot_path, string, 0);
    }
  }
  }
  return (result);
}
}
int absolute_pathname(char *string ) 
{ 


  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return (0);
  } else { //Added block
  if ((int )*string == 0) {
    return (0);
  }
  }
  if ((int )*(string + 0) == 47) {
    return (1);
  }
  if ((int )*(string + 0) == 46) {
    if ((int )*(string + 1) == 47) {
      return (1);
    } else { //Added block
    if ((int )*(string + 1) == 0) {
      return (1);
    }
    }
  }
  if ((int )*(string + 0) == 46) {
    if ((int )*(string + 1) == 46) {
      if ((int )*(string + 2) == 47) {
        return (1);
      } else { //Added block
      if ((int )*(string + 2) == 0) {
        return (1);
      }
      }
    }
  }
  return (0);
}
}
int absolute_program(char *string ) 
{ 
  char *tmp ;

  {
  {
  tmp = strchr((char const   *)string, '/');
  }
  return ((unsigned long )tmp != (unsigned long )((char *)((void *)0)));
}
}
char *base_pathname(char *string ) 
{ 
  char *p ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp = absolute_pathname(string);
  }
  if (tmp == 0) {
    return (string);
  }
  {
  tmp___0 = strrchr((char const   *)string, '/');
  p = tmp___0;
  }
  if (p) {
    p ++;
    tmp___1 = p;
  } else {
    tmp___1 = string;
  }
  return (tmp___1);
}
}
char *full_pathname(char *file ) 
{ 
  char *ret ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if ((int )*file == 126) {
    {
    tmp = bash_tilde_expand(file);
    file = tmp;
    }
  } else {
    {
    tmp___0 = strlen((char const   *)file);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )file);
    file = tmp___2;
    }
  }
  if ((int )*(file + 0) == 47) {
    return (file);
  }
  {
  ret = sh_makepath((char *)((void *)0), file, 6);
  free((void *)file);
  }
  return (ret);
}
}
static char tdir[4096]  ;
char *polite_directory_format(char *name ) 
{ 
  char *home ;
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  home = get_string_value("HOME");
  }
  if (home) {
    {
    tmp = strlen((char const   *)home);
    l = (int )tmp;
    }
  } else {
    l = 0;
  }
  if (l > 1) {
    {
    tmp___0 = strncmp((char const   *)home, (char const   *)name, (size_t )l);
    }
    if (tmp___0 == 0) {
      if (! *(name + l)) {
        {
        strncpy((char * __restrict  )(tdir + 1), (char const   * __restrict  )(name + l),
                sizeof(tdir) - 2UL);
        tdir[0] = (char )'~';
        tdir[sizeof(tdir) - 1UL] = (char )'\000';
        }
        return (tdir);
      } else { //Added block
      if ((int )*(name + l) == 47) {
        {
        strncpy((char * __restrict  )(tdir + 1), (char const   * __restrict  )(name + l),
                sizeof(tdir) - 2UL);
        tdir[0] = (char )'~';
        tdir[sizeof(tdir) - 1UL] = (char )'\000';
        }
        return (tdir);
      } else {
        return (name);
      }
      }
    } else {
      return (name);
    }
  } else {
    return (name);
  }
}
}
char *extract_colon_unit(char *string , int *p_index ) 
{ 
  int i ;
  int start ;
  int len___0 ;
  char *value ;
  size_t tmp ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return (string);
  }
  {
  tmp = strlen((char const   *)string);
  len___0 = (int )tmp;
  }
  if (*p_index >= len___0) {
    return ((char *)((void *)0));
  }
  i = *p_index;
  if (i) {
    if ((int )*(string + i) == 58) {
      i ++;
    }
  }
  start = i;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(string + i)) {
      if (! ((int )*(string + i) != 58)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  *p_index = i;
  if (i == start) {
    if (*(string + i)) {
      (*p_index) ++;
    }
    {
    value = xmalloc((size_t )1);
    *(value + 0) = (char )'\000';
    }
  } else {
    {
    value = substring(string, start, i);
    }
  }
  return (value);
}
}
extern char *get_dirstack_from_string(char * ) ;
static char *bash_special_tilde_expansions(char *text___0 ) 
{ 
  char *result ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  result = (char *)((void *)0);
  if ((int )*(text___0 + 0) == 43) {
    if ((int )*(text___0 + 1) == 0) {
      {
      result = get_string_value("PWD");
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if ((int )*(text___0 + 0) == 45) {
    if ((int )*(text___0 + 1) == 0) {
      {
      result = get_string_value("OLDPWD");
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )*text___0) & 2048) {
      {
      result = get_dirstack_from_string(text___0);
      }
    } else { //Added block
    if ((int )*text___0 == 43) {
      goto _L;
    } else { //Added block
    if ((int )*text___0 == 45) {
      _L: 
      {
      tmp___0 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___0 + (int )*(text___0 + 1)) & 2048) {
        {
        result = get_dirstack_from_string(text___0);
        }
      }
    }
    }
    }
  }
  }
  if (result) {
    {
    tmp___1 = strlen((char const   *)result);
    tmp___2 = xmalloc(1UL + tmp___1);
    tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )result);
    tmp___4 = tmp___3;
    }
  } else {
    tmp___4 = (char *)((void *)0);
  }
  return (tmp___4);
}
}
static int times_called  =    0;
void tilde_initialize(void) 
{ 
  int tmp ;

  {
  tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)((CPFunction *)(& bash_special_tilde_expansions));
  tmp = times_called;
  times_called ++;
  if (tmp == 0) {
    {
    tilde_additional_prefixes = alloc_array(3);
    *(tilde_additional_prefixes + 0) = (char *)"=~";
    *(tilde_additional_prefixes + 1) = (char *)":~";
    *(tilde_additional_prefixes + 2) = (char *)((void *)0);
    tilde_additional_suffixes = alloc_array(3);
    *(tilde_additional_suffixes + 0) = (char *)":";
    *(tilde_additional_suffixes + 1) = (char *)"=~";
    *(tilde_additional_suffixes + 2) = (char *)((void *)0);
    }
  }
  return;
}
}
char *bash_tilde_expand(char *s ) 
{ 
  int old_immed ;
  char *ret ;

  {
  {
  old_immed = interrupt_immediately;
  interrupt_immediately = 1;
  ret = tilde_expand((char const   *)s);
  interrupt_immediately = old_immed;
  }
  return (ret);
}
}
static int ngroups  ;
static int maxgroups  ;
static gid_t *group_array  =    (gid_t *)((void *)0);
static void initialize_group_array(void) 
{ 
  register int i ;
  long tmp ;
  char *tmp___0 ;

  {
  if (maxgroups == 0) {
    {
    tmp = sysconf(3);
    maxgroups = (int )tmp;
    }
  }
  {
  ngroups = 0;
  tmp___0 = xrealloc((void *)group_array, (unsigned long )maxgroups * sizeof(gid_t ));
  group_array = (gid_t *)tmp___0;
  ngroups = getgroups(maxgroups, group_array);
  }
  if (ngroups == 0) {
    *(group_array + 0) = current_user.gid;
    ngroups = 1;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < ngroups)) {
      goto while_break;
    }
    if (current_user.gid == *(group_array + i)) {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (i == ngroups) {
    if (ngroups < maxgroups) {
      i = ngroups;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i > 0)) {
          goto while_break___0;
        }
        *(group_array + i) = *(group_array + (i - 1));
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
      *(group_array + 0) = current_user.gid;
      ngroups ++;
    }
  }
  if (*(group_array + 0) != current_user.gid) {
    i = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i < ngroups)) {
        goto while_break___1;
      }
      if (*(group_array + i) == current_user.gid) {
        goto while_break___1;
      }
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (i < ngroups) {
      *(group_array + i) = *(group_array + 0);
      *(group_array + 0) = current_user.gid;
    }
  }
  return;
}
}
int group_member(gid_t gid ) 
{ 
  register int i ;

  {
  if (gid == current_user.gid) {
    return (1);
  } else { //Added block
  if (gid == current_user.egid) {
    return (1);
  }
  }
  if (ngroups == 0) {
    {
    initialize_group_array();
    }
  }
  if (ngroups <= 0) {
    return (0);
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < ngroups)) {
      goto while_break;
    }
    if (gid == *(group_array + i)) {
      return (1);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static char **group_vector  =    (char **)((void *)0);
char **get_group_list(int *ngp ) 
{ 
  register int i ;
  char *nbuf ;

  {
  if (group_vector) {
    if (ngp) {
      *ngp = ngroups;
    }
    return (group_vector);
  }
  if (ngroups == 0) {
    {
    initialize_group_array();
    }
  }
  if (ngroups <= 0) {
    if (ngp) {
      *ngp = 0;
    }
    return ((char **)((void *)0));
  }
  {
  group_vector = alloc_array(ngroups);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < ngroups)) {
      goto while_break;
    }
    {
    nbuf = itos((int )*(group_array + i));
    *(group_vector + i) = nbuf;
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (ngp) {
    *ngp = ngroups;
  }
  return (group_vector);
}
}
static int *group_iarray  =    (int *)((void *)0);
int *get_group_array(int *ngp ) 
{ 
  int i ;
  char *tmp ;

  {
  if (group_iarray) {
    if (ngp) {
      *ngp = ngroups;
    }
    return (group_iarray);
  }
  if (ngroups == 0) {
    {
    initialize_group_array();
    }
  }
  if (ngroups <= 0) {
    if (ngp) {
      *ngp = 0;
    }
    return ((int *)((void *)0));
  }
  {
  tmp = xmalloc((unsigned long )ngroups * sizeof(int ));
  group_iarray = (int *)tmp;
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < ngroups)) {
      goto while_break;
    }
    *(group_iarray + i) = (int )*(group_array + i);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (ngp) {
    *ngp = ngroups;
  }
  return (group_iarray);
}
}
#pragma merger("0","/tmp/cil-_6xuh3VB.i","-g")
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
void programming_error(char const   *format  , ...) ;
WORD_DESC *make_bare_word(char *string ) ;
COMMAND *make_command(enum command_type type , SIMPLE_COM *pointer ) ;
COMMAND *make_bare_simple_command(void) ;
char *string_quote_removal(char *string , int quoted ) ;
WORD_DESC *make_bare_word(char *string ) 
{ 
  WORD_DESC *temp___0 ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  tmp = xmalloc(sizeof(WORD_DESC ));
  temp___0 = (WORD_DESC *)tmp;
  }
  if (*string) {
    {
    tmp___0 = strlen((char const   *)string);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )string);
    temp___0->word = tmp___2;
    }
  } else {
    {
    temp___0->word = xmalloc((size_t )1);
    *(temp___0->word + 0) = (char )'\000';
    }
  }
  temp___0->flags = 0;
  return (temp___0);
}
}
WORD_DESC *make_word_flags(WORD_DESC *w , char *string ) 
{ 
  register char *s ;

  {
  s = string;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    if ((int )*s == 36) {
      goto case_36;
    }
    if ((int )*s == 92) {
      goto case_92;
    }
    if ((int )*s == 39) {
      goto case_39;
    }
    if ((int )*s == 96) {
      goto case_39;
    }
    if ((int )*s == 34) {
      goto case_39;
    }
    goto switch_break;
    case_36: /* CIL Label */ 
    w->flags |= 1;
    goto switch_break;
    case_92: /* CIL Label */ 
    goto switch_break;
    case_39: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_34: /* CIL Label */ 
    w->flags |= 2;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (w);
}
}
WORD_DESC *make_word(char *string ) 
{ 
  WORD_DESC *temp___0 ;
  WORD_DESC *tmp ;

  {
  {
  temp___0 = make_bare_word(string);
  tmp = make_word_flags(temp___0, string);
  }
  return (tmp);
}
}
WORD_DESC *make_word_from_token(int token___0 ) 
{ 
  char tokenizer[2] ;
  WORD_DESC *tmp ;

  {
  {
  tokenizer[0] = (char )token___0;
  tokenizer[1] = (char )'\000';
  tmp = make_word(tokenizer);
  }
  return (tmp);
}
}
WORD_LIST *make_word_list(WORD_DESC *word , WORD_LIST *link___0 ) 
{ 
  WORD_LIST *temp___0 ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(WORD_LIST ));
  temp___0 = (WORD_LIST *)tmp;
  temp___0->word = word;
  temp___0->next = link___0;
  }
  return (temp___0);
}
}
WORD_LIST *add_string_to_list(char *string , WORD_LIST *list___0 ) 
{ 
  WORD_LIST *temp___0 ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(WORD_LIST ));
  temp___0 = (WORD_LIST *)tmp;
  temp___0->word = make_word(string);
  temp___0->next = list___0;
  }
  return (temp___0);
}
}
COMMAND *make_command(enum command_type type , SIMPLE_COM *pointer ) 
{ 
  COMMAND *temp___0 ;
  char *tmp ;
  int tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(COMMAND ));
  temp___0 = (COMMAND *)tmp;
  temp___0->type = type;
  temp___0->value.Simple = pointer;
  tmp___0 = 0;
  temp___0->flags = tmp___0;
  (temp___0->value.Simple)->flags = tmp___0;
  temp___0->redirects = (REDIRECT *)((void *)0);
  }
  return (temp___0);
}
}
COMMAND *command_connect(COMMAND *com1 , COMMAND *com2 , int connector ) 
{ 
  CONNECTION *temp___0 ;
  char *tmp ;
  COMMAND *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(CONNECTION ));
  temp___0 = (CONNECTION *)tmp;
  temp___0->connector = connector;
  temp___0->first = com1;
  temp___0->second = com2;
  tmp___0 = make_command((enum command_type )6, (SIMPLE_COM *)temp___0);
  }
  return (tmp___0);
}
}
static COMMAND *make_for_or_select(enum command_type type , WORD_DESC *name , WORD_LIST *map_list ,
                                   COMMAND *action ) 
{ 
  FOR_COM *temp___0 ;
  char *tmp ;
  COMMAND *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(FOR_COM ));
  temp___0 = (FOR_COM *)tmp;
  temp___0->flags = 0;
  temp___0->name = name;
  temp___0->map_list = map_list;
  temp___0->action = action;
  tmp___0 = make_command(type, (SIMPLE_COM *)temp___0);
  }
  return (tmp___0);
}
}
COMMAND *make_for_command(WORD_DESC *name , WORD_LIST *map_list , COMMAND *action ) 
{ 
  COMMAND *tmp ;

  {
  {
  tmp = make_for_or_select((enum command_type )0, name, map_list, action);
  }
  return (tmp);
}
}
COMMAND *make_select_command(WORD_DESC *name , WORD_LIST *map_list , COMMAND *action ) 
{ 
  COMMAND *tmp ;

  {
  {
  tmp = make_for_or_select((enum command_type )5, name, map_list, action);
  }
  return (tmp);
}
}
static WORD_LIST *make_arith_for_expr(char *s ) 
{ 
  WORD_LIST *result ;
  WORD_DESC *w ;

  {
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((int )*s == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  {
  w = make_word(s);
  result = make_word_list(w, (WORD_LIST *)((void *)0));
  }
  return (result);
}
}
COMMAND *make_arith_for_command(WORD_LIST *exprs , COMMAND *action , int lineno ) 
{ 
  ARITH_FOR_COM *temp___0 ;
  WORD_LIST *init ;
  WORD_LIST *test ;
  WORD_LIST *step ;
  char *s ;
  char *t ;
  char *start ;
  int nsemi ;
  char *tmp ;
  char *tmp___0 ;
  WORD_LIST *tmp___1 ;
  WORD_LIST *tmp___2 ;
  WORD_LIST *tmp___3 ;
  COMMAND *tmp___4 ;

  {
  step = (WORD_LIST *)((void *)0);
  test = step;
  init = test;
  s = (exprs->word)->word;
  t = s;
  start = t;
  nsemi = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((int )*s == 32)) {
        if (! ((int )*s == 9)) {
          goto while_break___0;
        }
      }
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    start = s;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (*s) {
        if (! ((int )*s != 59)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((unsigned long )s > (unsigned long )start) {
      {
      tmp = substring(start, 0, (int )(s - start));
      t = tmp;
      }
    } else {
      t = (char *)((void *)0);
    }
    nsemi ++;
    {
    if (nsemi == 1) {
      goto case_1;
    }
    if (nsemi == 2) {
      goto case_2;
    }
    if (nsemi == 3) {
      goto case_3;
    }
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    init = make_arith_for_expr(t);
    }
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    test = make_arith_for_expr(t);
    }
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    step = make_arith_for_expr(t);
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (t) {
        {
        free((void *)t);
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    if ((int )*s == 0) {
      goto while_break;
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (nsemi != 3) {
    if (nsemi < 3) {
      {
      parser_error(lineno, "syntax error: arithmetic expression required");
      }
    } else {
      {
      parser_error(lineno, "syntax error: `;\' unexpected");
      }
    }
    {
    parser_error(lineno, "syntax error: `((%s))\'", (exprs->word)->word);
    last_command_exit_value = 2;
    }
    return ((COMMAND *)((void *)0));
  }
  {
  tmp___0 = xmalloc(sizeof(ARITH_FOR_COM ));
  temp___0 = (ARITH_FOR_COM *)tmp___0;
  temp___0->flags = 0;
  temp___0->line = lineno;
  }
  if (init) {
    temp___0->init = init;
  } else {
    {
    tmp___1 = make_arith_for_expr((char *)"1");
    temp___0->init = tmp___1;
    }
  }
  if (test) {
    temp___0->test = test;
  } else {
    {
    tmp___2 = make_arith_for_expr((char *)"1");
    temp___0->test = tmp___2;
    }
  }
  if (step) {
    temp___0->step = step;
  } else {
    {
    tmp___3 = make_arith_for_expr((char *)"1");
    temp___0->step = tmp___3;
    }
  }
  {
  temp___0->action = action;
  tmp___4 = make_command((enum command_type )12, (SIMPLE_COM *)temp___0);
  }
  return (tmp___4);
}
}
COMMAND *make_group_command(COMMAND *command ) 
{ 
  GROUP_COM *temp___0 ;
  char *tmp ;
  COMMAND *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(GROUP_COM ));
  temp___0 = (GROUP_COM *)tmp;
  temp___0->command = command;
  tmp___0 = make_command((enum command_type )9, (SIMPLE_COM *)temp___0);
  }
  return (tmp___0);
}
}
COMMAND *make_case_command(WORD_DESC *word , PATTERN_LIST *clauses ) 
{ 
  CASE_COM *temp___0 ;
  char *tmp ;
  GENERIC_LIST *tmp___0 ;
  COMMAND *tmp___1 ;

  {
  {
  tmp = xmalloc(sizeof(CASE_COM ));
  temp___0 = (CASE_COM *)tmp;
  temp___0->flags = 0;
  temp___0->word = word;
  }
  if (clauses) {
    if (clauses->next) {
      {
      tmp___0 = reverse_list((GENERIC_LIST *)clauses);
      temp___0->clauses = (PATTERN_LIST *)tmp___0;
      }
    } else {
      temp___0->clauses = clauses;
    }
  } else {
    temp___0->clauses = clauses;
  }
  {
  tmp___1 = make_command((enum command_type )1, (SIMPLE_COM *)temp___0);
  }
  return (tmp___1);
}
}
PATTERN_LIST *make_pattern_list(WORD_LIST *patterns , COMMAND *action ) 
{ 
  PATTERN_LIST *temp___0 ;
  char *tmp ;
  GENERIC_LIST *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(PATTERN_LIST ));
  temp___0 = (PATTERN_LIST *)tmp;
  }
  if (patterns) {
    if (patterns->next) {
      {
      tmp___0 = reverse_list((GENERIC_LIST *)patterns);
      temp___0->patterns = (WORD_LIST *)tmp___0;
      }
    } else {
      temp___0->patterns = patterns;
    }
  } else {
    temp___0->patterns = patterns;
  }
  temp___0->action = action;
  temp___0->next = (struct pattern_list *)((void *)0);
  return (temp___0);
}
}
COMMAND *make_if_command(COMMAND *test , COMMAND *true_case , COMMAND *false_case ) 
{ 
  IF_COM *temp___0 ;
  char *tmp ;
  COMMAND *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(IF_COM ));
  temp___0 = (IF_COM *)tmp;
  temp___0->flags = 0;
  temp___0->test = test;
  temp___0->true_case = true_case;
  temp___0->false_case = false_case;
  tmp___0 = make_command((enum command_type )3, (SIMPLE_COM *)temp___0);
  }
  return (tmp___0);
}
}
static COMMAND *make_until_or_while(enum command_type which , COMMAND *test , COMMAND *action ) 
{ 
  WHILE_COM *temp___0 ;
  char *tmp ;
  COMMAND *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(WHILE_COM ));
  temp___0 = (WHILE_COM *)tmp;
  temp___0->flags = 0;
  temp___0->test = test;
  temp___0->action = action;
  tmp___0 = make_command(which, (SIMPLE_COM *)temp___0);
  }
  return (tmp___0);
}
}
COMMAND *make_while_command(COMMAND *test , COMMAND *action ) 
{ 
  COMMAND *tmp ;

  {
  {
  tmp = make_until_or_while((enum command_type )2, test, action);
  }
  return (tmp);
}
}
COMMAND *make_until_command(COMMAND *test , COMMAND *action ) 
{ 
  COMMAND *tmp ;

  {
  {
  tmp = make_until_or_while((enum command_type )8, test, action);
  }
  return (tmp);
}
}
COMMAND *make_arith_command(WORD_LIST *exp ) 
{ 
  COMMAND *command ;
  ARITH_COM *temp___0 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(COMMAND ));
  command = (COMMAND *)tmp;
  tmp___0 = xmalloc(sizeof(ARITH_COM ));
  temp___0 = (ARITH_COM *)tmp___0;
  command->value.Arith = temp___0;
  temp___0->flags = 0;
  temp___0->line = line_number;
  temp___0->exp = exp;
  command->type = (enum command_type )10;
  command->redirects = (REDIRECT *)((void *)0);
  command->flags = 0;
  }
  return (command);
}
}
struct cond_com *make_cond_node(int type , WORD_DESC *op , struct cond_com *left ,
                                struct cond_com *right ) 
{ 
  COND_COM *temp___0 ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(COND_COM ));
  temp___0 = (COND_COM *)tmp;
  temp___0->flags = 0;
  temp___0->line = line_number;
  temp___0->type = type;
  temp___0->op = op;
  temp___0->left = left;
  temp___0->right = right;
  }
  return (temp___0);
}
}
COMMAND *make_cond_command(COND_COM *cond_node ) 
{ 
  COMMAND *command ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(COMMAND ));
  command = (COMMAND *)tmp;
  command->value.Cond = cond_node;
  command->type = (enum command_type )11;
  command->redirects = (REDIRECT *)((void *)0);
  command->flags = 0;
  }
  if (cond_node) {
    command->line = cond_node->line;
  } else {
    command->line = 0;
  }
  return (command);
}
}
COMMAND *make_bare_simple_command(void) 
{ 
  COMMAND *command ;
  SIMPLE_COM *temp___0 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(COMMAND ));
  command = (COMMAND *)tmp;
  tmp___0 = xmalloc(sizeof(SIMPLE_COM ));
  temp___0 = (SIMPLE_COM *)tmp___0;
  command->value.Simple = temp___0;
  temp___0->flags = 0;
  temp___0->line = line_number;
  temp___0->words = (WORD_LIST *)((void *)0);
  temp___0->redirects = (REDIRECT *)((void *)0);
  command->type = (enum command_type )4;
  command->redirects = (REDIRECT *)((void *)0);
  command->flags = 0;
  }
  return (command);
}
}
COMMAND *make_simple_command(ELEMENT element , COMMAND *command ) 
{ 
  WORD_LIST *tw ;
  char *tmp ;
  REDIRECT *r ;

  {
  if (! command) {
    {
    command = make_bare_simple_command();
    }
  }
  if (element.word) {
    {
    tmp = xmalloc(sizeof(WORD_LIST ));
    tw = (WORD_LIST *)tmp;
    tw->word = element.word;
    tw->next = (command->value.Simple)->words;
    (command->value.Simple)->words = tw;
    }
  } else {
    r = element.redirect;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! r->next) {
        goto while_break;
      }
      r = r->next;
    }
    while_break: /* CIL Label */ ;
    }
    r->next = (command->value.Simple)->redirects;
    (command->value.Simple)->redirects = element.redirect;
  }
  return (command);
}
}
void make_here_document(REDIRECT *temp___0 ) 
{ 
  int kill_leading ;
  int redir_len ;
  char *redir_word ;
  char *document ;
  char *full_line ;
  int document_index ;
  int document_size ;
  int delim_unquoted ;
  size_t tmp ;
  register char *line ;
  int len___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  if ((unsigned int )temp___0->instruction != 7U) {
    if ((unsigned int )temp___0->instruction != 4U) {
      {
      internal_error("make_here_document: bad instruction type %d", (unsigned int )temp___0->instruction);
      }
      return;
    }
  }
  {
  kill_leading = (unsigned int )temp___0->instruction == 7U;
  document = (char *)((void *)0);
  document_size = 0;
  document_index = document_size;
  redir_word = string_quote_removal((temp___0->redirectee.filename)->word, 0);
  }
  if (redir_word) {
    {
    tmp = strlen((char const   *)redir_word);
    redir_len = (int )tmp;
    }
  } else {
    {
    temp___0->here_doc_eof = xmalloc((size_t )1);
    *(temp___0->here_doc_eof + 0) = (char )'\000';
    }
    goto document_done;
  }
  {
  free((void *)(temp___0->redirectee.filename)->word);
  temp___0->here_doc_eof = redir_word;
  delim_unquoted = ((temp___0->redirectee.filename)->flags & 2) == 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    full_line = read_secondary_line(delim_unquoted);
    }
    if (! full_line) {
      goto while_break;
    }
    line = full_line;
    line_number ++;
    if (kill_leading) {
      if (*line) {
        if (redir_len == 0) {
          tmp___2 = 1;
        } else {
          if ((int )*(line + 0) == (int )*(redir_word + 0)) {
            {
            tmp___0 = strncmp((char const   *)line, (char const   *)redir_word, (size_t )redir_len);
            }
            if (tmp___0 == 0) {
              tmp___1 = 1;
            } else {
              tmp___1 = 0;
            }
          } else {
            tmp___1 = 0;
          }
          tmp___2 = tmp___1;
        }
        if (tmp___2) {
          if ((int )*(line + redir_len) == 10) {
            goto document_done;
          }
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((int )*line == 9)) {
            goto while_break___0;
          }
          line ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    if ((int )*line == 0) {
      goto while_continue;
    }
    if (redir_len == 0) {
      tmp___5 = 1;
    } else {
      if ((int )*(line + 0) == (int )*(redir_word + 0)) {
        {
        tmp___3 = strncmp((char const   *)line, (char const   *)redir_word, (size_t )redir_len);
        }
        if (tmp___3 == 0) {
          tmp___4 = 1;
        } else {
          tmp___4 = 0;
        }
      } else {
        tmp___4 = 0;
      }
      tmp___5 = tmp___4;
    }
    if (tmp___5) {
      if ((int )*(line + redir_len) == 10) {
        goto document_done;
      }
    }
    {
    tmp___6 = strlen((char const   *)line);
    len___0 = (int )tmp___6;
    }
    if (len___0 + document_index >= document_size) {
      if (document_size) {
        document_size = 2 * (document_size + len___0);
      } else {
        document_size = len___0 + 2;
      }
      {
      document = xrealloc((void *)document, (size_t )document_size);
      }
    }
    {
    __builtin_memcpy((void *)(document + document_index), (void const   *)line, (unsigned long )len___0);
    document_index += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  document_done: 
  if (document) {
    *(document + document_index) = (char )'\000';
  } else {
    {
    document = xmalloc((size_t )1);
    *(document + 0) = (char )'\000';
    }
  }
  (temp___0->redirectee.filename)->word = document;
  return;
}
}
REDIRECT *make_redirection(int source , enum r_instruction instruction , REDIRECTEE dest_and_filename ) 
{ 
  REDIRECT *temp___0 ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(REDIRECT ));
  temp___0 = (REDIRECT *)tmp;
  temp___0->redirector = source;
  temp___0->redirectee = dest_and_filename;
  temp___0->instruction = instruction;
  temp___0->flags = 0;
  temp___0->next = (REDIRECT *)((void *)0);
  }
  {
  if ((unsigned int )instruction == 0U) {
    goto case_0;
  }
  if ((unsigned int )instruction == 11U) {
    goto case_0;
  }
  if ((unsigned int )instruction == 9U) {
    goto case_0;
  }
  if ((unsigned int )instruction == 3U) {
    goto case_3;
  }
  if ((unsigned int )instruction == 1U) {
    goto case_1;
  }
  if ((unsigned int )instruction == 2U) {
    goto case_1;
  }
  if ((unsigned int )instruction == 10U) {
    goto case_10;
  }
  if ((unsigned int )instruction == 7U) {
    goto case_7;
  }
  if ((unsigned int )instruction == 4U) {
    goto case_7;
  }
  if ((unsigned int )instruction == 8U) {
    goto case_7;
  }
  if ((unsigned int )instruction == 5U) {
    goto case_7;
  }
  if ((unsigned int )instruction == 6U) {
    goto case_7;
  }
  if ((unsigned int )instruction == 12U) {
    goto case_7;
  }
  if ((unsigned int )instruction == 13U) {
    goto case_7;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  temp___0->flags = 577;
  goto switch_break;
  case_3: /* CIL Label */ 
  temp___0->flags = 1089;
  goto switch_break;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  temp___0->flags = 0;
  goto switch_break;
  case_10: /* CIL Label */ 
  temp___0->flags = 66;
  goto switch_break;
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  programming_error("make_redirection: redirection instruction `%d\' out of range",
                    (unsigned int )instruction);
  abort();
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (temp___0);
}
}
COMMAND *make_function_def(WORD_DESC *name , COMMAND *command , int lineno , int lstart ) 
{ 
  FUNCTION_DEF *temp___0 ;
  char *tmp ;
  COMMAND *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(FUNCTION_DEF ));
  temp___0 = (FUNCTION_DEF *)tmp;
  temp___0->command = command;
  temp___0->name = name;
  temp___0->line = lineno;
  temp___0->flags = 0;
  command->line = lstart;
  tmp___0 = make_command((enum command_type )7, (SIMPLE_COM *)temp___0);
  }
  return (tmp___0);
}
}
COMMAND *make_subshell_command(COMMAND *command ) 
{ 
  SUBSHELL_COM *temp___0 ;
  char *tmp ;
  COMMAND *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(SUBSHELL_COM ));
  temp___0 = (SUBSHELL_COM *)tmp;
  temp___0->command = command;
  temp___0->flags = 1;
  tmp___0 = make_command((enum command_type )13, (SIMPLE_COM *)temp___0);
  }
  return (tmp___0);
}
}
COMMAND *clean_simple_command(COMMAND *command ) 
{ 
  GENERIC_LIST *tmp ;
  GENERIC_LIST *tmp___0 ;

  {
  if ((unsigned int )command->type != 4U) {
    {
    command_error("clean_simple_command", 1, (int )command->type, 0);
    }
  } else {
    if ((command->value.Simple)->words) {
      if (((command->value.Simple)->words)->next) {
        {
        tmp = reverse_list((GENERIC_LIST *)(command->value.Simple)->words);
        (command->value.Simple)->words = (WORD_LIST *)tmp;
        }
      } else {
        (command->value.Simple)->words = (command->value.Simple)->words;
      }
    } else {
      (command->value.Simple)->words = (command->value.Simple)->words;
    }
    if ((command->value.Simple)->redirects) {
      if (((command->value.Simple)->redirects)->next) {
        {
        tmp___0 = reverse_list((GENERIC_LIST *)(command->value.Simple)->redirects);
        (command->value.Simple)->redirects = (REDIRECT *)tmp___0;
        }
      } else {
        (command->value.Simple)->redirects = (command->value.Simple)->redirects;
      }
    } else {
      (command->value.Simple)->redirects = (command->value.Simple)->redirects;
    }
  }
  return (command);
}
}
COMMAND *connect_async_list(COMMAND *command , COMMAND *command2 , int connector ) 
{ 
  COMMAND *t ;
  COMMAND *t1 ;
  COMMAND *t2 ;

  {
  t1 = command;
  t = (command->value.Connection)->second;
  if (! t) {
    {
    t = command_connect(command, command2, connector);
    }
    return (t);
  } else { //Added block
  if (command->flags & 1) {
    {
    t = command_connect(command, command2, connector);
    }
    return (t);
  } else { //Added block
  if ((command->value.Connection)->connector != 59) {
    {
    t = command_connect(command, command2, connector);
    }
    return (t);
  }
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((t->flags & 1) == 0) {
      if ((unsigned int )t->type == 6U) {
        if (! ((t->value.Connection)->connector == 59)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    t1 = t;
    t = (t->value.Connection)->second;
  }
  while_break: /* CIL Label */ ;
  }
  {
  t2 = command_connect(t, command2, connector);
  (t1->value.Connection)->second = t2;
  }
  return (command);
}
}
#pragma merger("0","/tmp/cil-wVkFgDrD.i","-g")
REDIRECT *copy_redirect(REDIRECT *redirect ) ;
COMMAND *copy_command(COMMAND *command ) ;
char *indirection_level_string(void) ;
void add_unwind_protect(Function *cleanup , char *arg ) ;
void remove_unwind_protect(void) ;
void dispose_redirects(REDIRECT *list___0 ) ;
char *make_command_string(COMMAND *command ) ;
void print_command(COMMAND *command ) ;
void print_simple_command(SIMPLE_COM *simple_command ) ;
char *named_function_string(char *name , COMMAND *command , int multi_line ) ;
void print_word_list(WORD_LIST *list___0 , char *separator ) ;
void xtrace_print_word_list(WORD_LIST *list___0 ) ;
void xtrace_print_arith_cmd(WORD_LIST *list___0 ) ;
void xtrace_print_cond_term(int type , int invert , WORD_DESC *op , char *arg1 , char *arg2 ) ;
extern char *inttostr(int  , char * , int  ) ;
extern int sh_contains_shell_metas(char * ) ;
static int indentation  ;
static int indentation_amount  =    4;
static void cprintf(char *control  , ...) ;
static void newline(char *string ) ;
static void indent(int amount ) ;
static void the_printed_command_resize(int length ) ;
static void semicolon(void) ;
static void xprintf(char *format , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 ) ;
static void make_command_string_internal(COMMAND *command ) ;
static void command_print_word_list(WORD_LIST *list___0 , char *separator ) ;
static void print_case_clauses(PATTERN_LIST *clauses ) ;
static void print_redirection_list(REDIRECT *redirects ) ;
static void print_redirection(REDIRECT *redirect ) ;
static void print_for_command(FOR_COM *for_command ) ;
static void print_select_command(SELECT_COM *select_command ) ;
static void print_group_command(GROUP_COM *group_command ) ;
static void print_case_command(CASE_COM *case_command ) ;
static void print_while_command(WHILE_COM *while_command ) ;
static void print_until_command(WHILE_COM *while_command ) ;
static void print_until_or_while(WHILE_COM *while_command , char *which ) ;
static void print_if_command(IF_COM *if_command ) ;
static void print_function_def(FUNCTION_DEF *func ) ;
static void print_arith_command(ARITH_COM *arith_command ) ;
static void print_cond_node(COND_COM *cond ) ;
static void print_cond_command(COND_COM *cond ) ;
static void print_arith_for_command(ARITH_FOR_COM *arith_for_command ) ;
char *the_printed_command  =    (char *)((void *)0);
int the_printed_command_size  =    0;
int command_string_index  =    0;
static int inside_function_def  ;
static int skip_this_indent  ;
static int was_heredoc  ;
static int group_command_nesting  ;
void print_command(COMMAND *command ) 
{ 
  char *tmp ;

  {
  {
  command_string_index = 0;
  tmp = make_command_string(command);
  printf((char const   * __restrict  )"%s", tmp);
  }
  return;
}
}
char *make_command_string(COMMAND *command ) 
{ 


  {
  {
  was_heredoc = 0;
  command_string_index = was_heredoc;
  make_command_string_internal(command);
  }
  return (the_printed_command);
}
}
static void make_command_string_internal(COMMAND *command ) 
{ 
  char c ;

  {
  if ((unsigned long )command == (unsigned long )((COMMAND *)0)) {
    {
    cprintf((char *)"");
    }
  } else {
    if (skip_this_indent) {
      skip_this_indent --;
    } else {
      {
      indent(indentation);
      }
    }
    if (command->flags & 128) {
      {
      cprintf((char *)"time ");
      }
      if (command->flags & 256) {
        {
        cprintf((char *)"-p ");
        }
      }
    }
    if (command->flags & 4) {
      {
      cprintf((char *)"! ");
      }
    }
    {
    if ((unsigned int )command->type == 0U) {
      goto case_0;
    }
    if ((unsigned int )command->type == 12U) {
      goto case_12;
    }
    if ((unsigned int )command->type == 5U) {
      goto case_5;
    }
    if ((unsigned int )command->type == 1U) {
      goto case_1;
    }
    if ((unsigned int )command->type == 2U) {
      goto case_2;
    }
    if ((unsigned int )command->type == 8U) {
      goto case_8;
    }
    if ((unsigned int )command->type == 3U) {
      goto case_3;
    }
    if ((unsigned int )command->type == 10U) {
      goto case_10;
    }
    if ((unsigned int )command->type == 11U) {
      goto case_11;
    }
    if ((unsigned int )command->type == 4U) {
      goto case_4;
    }
    if ((unsigned int )command->type == 6U) {
      goto case_6;
    }
    if ((unsigned int )command->type == 7U) {
      goto case_7;
    }
    if ((unsigned int )command->type == 9U) {
      goto case_9;
    }
    if ((unsigned int )command->type == 13U) {
      goto case_13;
    }
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
    print_for_command(command->value.For);
    }
    goto switch_break;
    case_12: /* CIL Label */ 
    {
    print_arith_for_command(command->value.ArithFor);
    }
    goto switch_break;
    case_5: /* CIL Label */ 
    {
    print_select_command(command->value.Select);
    }
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    print_case_command(command->value.Case);
    }
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    print_while_command(command->value.While);
    }
    goto switch_break;
    case_8: /* CIL Label */ 
    {
    print_until_command(command->value.While);
    }
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    print_if_command(command->value.If);
    }
    goto switch_break;
    case_10: /* CIL Label */ 
    {
    print_arith_command(command->value.Arith);
    }
    goto switch_break;
    case_11: /* CIL Label */ 
    {
    print_cond_command(command->value.Cond);
    }
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    print_simple_command(command->value.Simple);
    }
    goto switch_break;
    case_6: /* CIL Label */ 
    {
    skip_this_indent ++;
    make_command_string_internal((command->value.Connection)->first);
    }
    {
    if ((command->value.Connection)->connector == 38) {
      goto case_38;
    }
    if ((command->value.Connection)->connector == 124) {
      goto case_38;
    }
    if ((command->value.Connection)->connector == 284) {
      goto case_284;
    }
    if ((command->value.Connection)->connector == 285) {
      goto case_285;
    }
    if ((command->value.Connection)->connector == 59) {
      goto case_59;
    }
    goto switch_default;
    case_38: /* CIL Label */ 
    case_124: /* CIL Label */ 
    {
    c = (char )(command->value.Connection)->connector;
    cprintf((char *)" %c", (int )c);
    }
    if ((int )c != 38) {
      {
      cprintf((char *)" ");
      skip_this_indent ++;
      }
    } else { //Added block
    if ((command->value.Connection)->second) {
      {
      cprintf((char *)" ");
      skip_this_indent ++;
      }
    }
    }
    goto switch_break___0;
    case_284: /* CIL Label */ 
    {
    cprintf((char *)" && ");
    }
    if ((command->value.Connection)->second) {
      skip_this_indent ++;
    }
    goto switch_break___0;
    case_285: /* CIL Label */ 
    {
    cprintf((char *)" || ");
    }
    if ((command->value.Connection)->second) {
      skip_this_indent ++;
    }
    goto switch_break___0;
    case_59: /* CIL Label */ 
    if (was_heredoc == 0) {
      {
      cprintf((char *)";");
      }
    } else {
      was_heredoc = 0;
    }
    if (inside_function_def) {
      {
      cprintf((char *)"\n");
      }
    } else {
      {
      cprintf((char *)" ");
      }
      if ((command->value.Connection)->second) {
        skip_this_indent ++;
      }
    }
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
    cprintf((char *)"print_command: bad connector `%d\'", (command->value.Connection)->connector);
    }
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
    make_command_string_internal((command->value.Connection)->second);
    }
    goto switch_break;
    case_7: /* CIL Label */ 
    {
    print_function_def(command->value.Function_def);
    }
    goto switch_break;
    case_9: /* CIL Label */ 
    {
    print_group_command(command->value.Group);
    }
    goto switch_break;
    case_13: /* CIL Label */ 
    {
    cprintf((char *)"( ");
    skip_this_indent ++;
    make_command_string_internal((command->value.Subshell)->command);
    cprintf((char *)" )");
    }
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
    command_error("print_command", 1, (int )command->type, 0);
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    if (command->redirects) {
      {
      cprintf((char *)" ");
      print_redirection_list(command->redirects);
      }
    }
  }
  return;
}
}
static void _print_word_list(WORD_LIST *list___0 , char *separator , VFunction *pfunc ) 
{ 
  WORD_LIST *w ;
  char const   *tmp ;

  {
  w = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! w) {
      goto while_break;
    }
    if (w->next) {
      tmp = (char const   *)separator;
    } else {
      tmp = "";
    }
    {
    (*pfunc)("%s%s", (w->word)->word, tmp);
    w = w->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void print_word_list(WORD_LIST *list___0 , char *separator ) 
{ 


  {
  {
  _print_word_list(list___0, separator, (VFunction *)(& xprintf));
  }
  return;
}
}
void xtrace_print_word_list(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *w ;
  char *t ;
  char *x ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = indirection_level_string();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", tmp);
  w = list___0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! w) {
      goto while_break;
    }
    t = (w->word)->word;
    if ((unsigned long )t == (unsigned long )((char *)0)) {
      goto _L;
    } else { //Added block
    if ((int )*t == 0) {
      _L: 
      if (w->next) {
        tmp___0 = " ";
      } else {
        tmp___0 = "";
      }
      {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\'\'%s",
              tmp___0);
      }
    } else {
      {
      tmp___3 = sh_contains_shell_metas(t);
      }
      if (tmp___3) {
        {
        x = sh_single_quote(t);
        }
        if (w->next) {
          tmp___1 = " ";
        } else {
          tmp___1 = "";
        }
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s%s",
                x, tmp___1);
        free((void *)x);
        }
      } else {
        if (w->next) {
          tmp___2 = " ";
        } else {
          tmp___2 = "";
        }
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s%s",
                t, tmp___2);
        }
      }
    }
    }
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
  return;
}
}
static void command_print_word_list(WORD_LIST *list___0 , char *separator ) 
{ 


  {
  {
  _print_word_list(list___0, separator, (VFunction *)(& cprintf));
  }
  return;
}
}
static void print_for_command(FOR_COM *for_command ) 
{ 


  {
  {
  cprintf((char *)"for %s in ", (for_command->name)->word);
  command_print_word_list(for_command->map_list, (char *)" ");
  cprintf((char *)";");
  newline((char *)"do\n");
  indentation += indentation_amount;
  make_command_string_internal(for_command->action);
  semicolon();
  indentation -= indentation_amount;
  newline((char *)"done");
  }
  return;
}
}
static void print_arith_for_command(ARITH_FOR_COM *arith_for_command ) 
{ 


  {
  {
  cprintf((char *)"for (( ");
  command_print_word_list(arith_for_command->init, (char *)" ");
  cprintf((char *)" ; ");
  command_print_word_list(arith_for_command->test, (char *)" ");
  cprintf((char *)" ; ");
  command_print_word_list(arith_for_command->step, (char *)" ");
  cprintf((char *)" ))");
  newline((char *)"do\n");
  indentation += indentation_amount;
  make_command_string_internal(arith_for_command->action);
  semicolon();
  indentation -= indentation_amount;
  newline((char *)"done");
  }
  return;
}
}
static void print_select_command(SELECT_COM *select_command ) 
{ 


  {
  {
  cprintf((char *)"select %s in ", (select_command->name)->word);
  command_print_word_list(select_command->map_list, (char *)" ");
  cprintf((char *)";");
  newline((char *)"do\n");
  indentation += indentation_amount;
  make_command_string_internal(select_command->action);
  semicolon();
  indentation -= indentation_amount;
  newline((char *)"done");
  }
  return;
}
}
static void print_group_command(GROUP_COM *group_command ) 
{ 


  {
  {
  group_command_nesting ++;
  cprintf((char *)"{ ");
  }
  if (inside_function_def == 0) {
    skip_this_indent ++;
  } else {
    {
    cprintf((char *)"\n");
    indentation += indentation_amount;
    }
  }
  {
  make_command_string_internal(group_command->command);
  }
  if (inside_function_def) {
    {
    cprintf((char *)"\n");
    indentation -= indentation_amount;
    indent(indentation);
    }
  } else {
    {
    semicolon();
    cprintf((char *)" ");
    }
  }
  {
  cprintf((char *)"}");
  group_command_nesting --;
  }
  return;
}
}
static void print_case_command(CASE_COM *case_command ) 
{ 


  {
  {
  cprintf((char *)"case %s in ", (case_command->word)->word);
  }
  if (case_command->clauses) {
    {
    print_case_clauses(case_command->clauses);
    }
  }
  {
  newline((char *)"esac");
  }
  return;
}
}
static void print_case_clauses(PATTERN_LIST *clauses ) 
{ 


  {
  indentation += indentation_amount;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! clauses) {
      goto while_break;
    }
    {
    newline((char *)"");
    command_print_word_list(clauses->patterns, (char *)" | ");
    cprintf((char *)")\n");
    indentation += indentation_amount;
    make_command_string_internal(clauses->action);
    indentation -= indentation_amount;
    newline((char *)";;");
    clauses = clauses->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  indentation -= indentation_amount;
  return;
}
}
static void print_while_command(WHILE_COM *while_command ) 
{ 


  {
  {
  print_until_or_while(while_command, (char *)"while");
  }
  return;
}
}
static void print_until_command(WHILE_COM *while_command ) 
{ 


  {
  {
  print_until_or_while(while_command, (char *)"until");
  }
  return;
}
}
static void print_until_or_while(WHILE_COM *while_command , char *which ) 
{ 


  {
  {
  cprintf((char *)"%s ", which);
  skip_this_indent ++;
  make_command_string_internal(while_command->test);
  semicolon();
  cprintf((char *)" do\n");
  indentation += indentation_amount;
  make_command_string_internal(while_command->action);
  indentation -= indentation_amount;
  semicolon();
  newline((char *)"done");
  }
  return;
}
}
static void print_if_command(IF_COM *if_command ) 
{ 


  {
  {
  cprintf((char *)"if ");
  skip_this_indent ++;
  make_command_string_internal(if_command->test);
  semicolon();
  cprintf((char *)" then\n");
  indentation += indentation_amount;
  make_command_string_internal(if_command->true_case);
  indentation -= indentation_amount;
  }
  if (if_command->false_case) {
    {
    semicolon();
    newline((char *)"else\n");
    indentation += indentation_amount;
    make_command_string_internal(if_command->false_case);
    indentation -= indentation_amount;
    }
  }
  {
  semicolon();
  newline((char *)"fi");
  }
  return;
}
}
static void print_arith_command(ARITH_COM *arith_command ) 
{ 


  {
  {
  cprintf((char *)"(( ");
  command_print_word_list(arith_command->exp, (char *)" ");
  cprintf((char *)" ))");
  }
  return;
}
}
static void print_cond_node(COND_COM *cond ) 
{ 


  {
  if (cond->flags & 4) {
    {
    cprintf((char *)"! ");
    }
  }
  if (cond->type == 6) {
    {
    cprintf((char *)"( ");
    print_cond_node(cond->left);
    cprintf((char *)" )");
    }
  } else { //Added block
  if (cond->type == 1) {
    {
    print_cond_node(cond->left);
    cprintf((char *)" && ");
    print_cond_node(cond->right);
    }
  } else { //Added block
  if (cond->type == 2) {
    {
    print_cond_node(cond->left);
    cprintf((char *)" || ");
    print_cond_node(cond->right);
    }
  } else { //Added block
  if (cond->type == 3) {
    {
    cprintf((char *)"%s", (cond->op)->word);
    cprintf((char *)" ");
    print_cond_node(cond->left);
    }
  } else { //Added block
  if (cond->type == 4) {
    {
    print_cond_node(cond->left);
    cprintf((char *)" ");
    cprintf((char *)"%s", (cond->op)->word);
    cprintf((char *)" ");
    print_cond_node(cond->right);
    }
  } else { //Added block
  if (cond->type == 5) {
    {
    cprintf((char *)"%s", (cond->op)->word);
    }
  }
  }
  }
  }
  }
  }
  return;
}
}
static void print_cond_command(COND_COM *cond ) 
{ 


  {
  {
  cprintf((char *)"[[ ");
  print_cond_node(cond);
  cprintf((char *)" ]]");
  }
  return;
}
}
void xtrace_print_cond_term(int type , int invert , WORD_DESC *op , char *arg1 , char *arg2 ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  command_string_index = 0;
  tmp = indirection_level_string();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", tmp);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[[ ");
  }
  if (invert) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"! ");
    }
  }
  if (type == 3) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s ", op->word);
    }
    if (arg1) {
      if (*arg1) {
        tmp___0 = (char const   *)arg1;
      } else {
        tmp___0 = "\'\'";
      }
    } else {
      tmp___0 = "\'\'";
    }
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", tmp___0);
    }
  } else { //Added block
  if (type == 4) {
    if (arg1) {
      if (*arg1) {
        tmp___1 = (char const   *)arg1;
      } else {
        tmp___1 = "\'\'";
      }
    } else {
      tmp___1 = "\'\'";
    }
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", tmp___1);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %s ", op->word);
    }
    if (arg2) {
      if (*arg2) {
        tmp___2 = (char const   *)arg2;
      } else {
        tmp___2 = "\'\'";
      }
    } else {
      tmp___2 = "\'\'";
    }
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", tmp___2);
    }
  }
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ]]\n");
  }
  return;
}
}
void xtrace_print_arith_cmd(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *w ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
  tmp = indirection_level_string();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", tmp);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(( ");
  w = list___0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! w) {
      goto while_break;
    }
    if (w->next) {
      tmp___0 = " ";
    } else {
      tmp___0 = "";
    }
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s%s", (w->word)->word,
            tmp___0);
    w = w->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ))\n");
  }
  return;
}
}
void print_simple_command(SIMPLE_COM *simple_command ) 
{ 


  {
  {
  command_print_word_list(simple_command->words, (char *)" ");
  }
  if (simple_command->redirects) {
    {
    cprintf((char *)" ");
    print_redirection_list(simple_command->redirects);
    }
  }
  return;
}
}
static void print_redirection_list(REDIRECT *redirects ) 
{ 
  REDIRECT *heredocs ;
  REDIRECT *hdtail ;
  REDIRECT *newredir ;

  {
  heredocs = (REDIRECT *)((void *)0);
  hdtail = heredocs;
  was_heredoc = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! redirects) {
      goto while_break;
    }
    if ((unsigned int )redirects->instruction == 4U) {
      goto _L;
    } else { //Added block
    if ((unsigned int )redirects->instruction == 7U) {
      _L: 
      {
      newredir = copy_redirect(redirects);
      newredir->next = (REDIRECT *)((void *)0);
      }
      if (heredocs) {
        hdtail->next = newredir;
        hdtail = newredir;
      } else {
        heredocs = newredir;
        hdtail = heredocs;
      }
    } else {
      {
      print_redirection(redirects);
      }
    }
    }
    redirects = redirects->next;
    if (redirects) {
      {
      cprintf((char *)" ");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (heredocs) {
    {
    cprintf((char *)" ");
    hdtail = heredocs;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! hdtail) {
        goto while_break___0;
      }
      {
      print_redirection(hdtail);
      cprintf((char *)"\n");
      hdtail = hdtail->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    dispose_redirects(heredocs);
    was_heredoc = 1;
    }
  }
  return;
}
}
static void print_redirection(REDIRECT *redirect ) 
{ 
  int kill_leading ;
  int redirector ;
  int redir_fd ;
  WORD_DESC *redirectee ;
  char *x ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  kill_leading = 0;
  redirectee = redirect->redirectee.filename;
  redirector = redirect->redirector;
  redir_fd = (int )redirect->redirectee.dest;
  {
  if ((unsigned int )redirect->instruction == 0U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 1U) {
    goto case_1;
  }
  if ((unsigned int )redirect->instruction == 2U) {
    goto case_2;
  }
  if ((unsigned int )redirect->instruction == 3U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 7U) {
    goto case_7;
  }
  if ((unsigned int )redirect->instruction == 4U) {
    goto case_4;
  }
  if ((unsigned int )redirect->instruction == 5U) {
    goto case_5;
  }
  if ((unsigned int )redirect->instruction == 6U) {
    goto case_6;
  }
  if ((unsigned int )redirect->instruction == 12U) {
    goto case_12;
  }
  if ((unsigned int )redirect->instruction == 13U) {
    goto case_13;
  }
  if ((unsigned int )redirect->instruction == 8U) {
    goto case_8;
  }
  if ((unsigned int )redirect->instruction == 9U) {
    goto case_9;
  }
  if ((unsigned int )redirect->instruction == 10U) {
    goto case_10;
  }
  if ((unsigned int )redirect->instruction == 11U) {
    goto case_11;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  if (redirector != 1) {
    {
    cprintf((char *)"%d", redirector);
    }
  }
  {
  cprintf((char *)">%s", redirectee->word);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  if (redirector != 0) {
    {
    cprintf((char *)"%d", redirector);
    }
  }
  {
  cprintf((char *)"<%s", redirectee->word);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  cprintf((char *)"&");
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  if (redirector != 1) {
    {
    cprintf((char *)"%d", redirector);
    }
  }
  {
  cprintf((char *)">>%s", redirectee->word);
  }
  goto switch_break;
  case_7: /* CIL Label */ 
  kill_leading ++;
  case_4: /* CIL Label */ 
  if (redirector != 0) {
    {
    cprintf((char *)"%d", redirector);
    }
  }
  if ((redirect->redirectee.filename)->flags & 2) {
    {
    x = sh_single_quote(redirect->here_doc_eof);
    }
    if (kill_leading) {
      tmp = "-";
    } else {
      tmp = "";
    }
    {
    cprintf((char *)"<<%s%s\n", tmp, x);
    free((void *)x);
    }
  } else {
    if (kill_leading) {
      tmp___0 = "-";
    } else {
      tmp___0 = "";
    }
    {
    cprintf((char *)"<<%s%s\n", tmp___0, redirect->here_doc_eof);
    }
  }
  {
  cprintf((char *)"%s%s", (redirect->redirectee.filename)->word, redirect->here_doc_eof);
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  cprintf((char *)"%d<&%d", redirector, redir_fd);
  }
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  cprintf((char *)"%d>&%d", redirector, redir_fd);
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  {
  cprintf((char *)"%d<&%s", redirector, redirectee->word);
  }
  goto switch_break;
  case_13: /* CIL Label */ 
  {
  cprintf((char *)"%d>&%s", redirector, redirectee->word);
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  {
  cprintf((char *)"%d>&-", redirector);
  }
  goto switch_break;
  case_9: /* CIL Label */ 
  {
  cprintf((char *)">&%s", redirectee->word);
  }
  goto switch_break;
  case_10: /* CIL Label */ 
  if (redirector != 1) {
    {
    cprintf((char *)"%d", redirector);
    }
  }
  {
  cprintf((char *)"<>%s", redirectee->word);
  }
  goto switch_break;
  case_11: /* CIL Label */ 
  if (redirector != 1) {
    {
    cprintf((char *)"%d", redirector);
    }
  }
  {
  cprintf((char *)">|%s", redirectee->word);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
static void reset_locals(void) 
{ 


  {
  inside_function_def = 0;
  indentation = 0;
  return;
}
}
static void print_function_def(FUNCTION_DEF *func ) 
{ 
  COMMAND *cmdcopy ;
  REDIRECT *func_redirects ;
  COMMAND *tmp ;

  {
  {
  cprintf((char *)"function %s () \n", (func->name)->word);
  add_unwind_protect((Function *)(& reset_locals), (char *)0);
  indent(indentation);
  cprintf((char *)"{ \n");
  inside_function_def ++;
  indentation += indentation_amount;
  cmdcopy = copy_command(func->command);
  }
  if ((unsigned int )cmdcopy->type == 9U) {
    func_redirects = cmdcopy->redirects;
    cmdcopy->redirects = (REDIRECT *)((void *)0);
  }
  if ((unsigned int )cmdcopy->type == 9U) {
    tmp = (cmdcopy->value.Group)->command;
  } else {
    tmp = cmdcopy;
  }
  {
  make_command_string_internal(tmp);
  remove_unwind_protect();
  indentation -= indentation_amount;
  inside_function_def --;
  }
  if (func_redirects) {
    {
    newline((char *)"} ");
    print_redirection_list(func_redirects);
    cmdcopy->redirects = func_redirects;
    }
  } else {
    {
    newline((char *)"}");
    }
  }
  {
  dispose_command(cmdcopy);
  }
  return;
}
}
char *named_function_string(char *name , COMMAND *command , int multi_line ) 
{ 
  char *result ;
  int old_indent ;
  int old_amount ;
  COMMAND *cmdcopy ;
  REDIRECT *func_redirects ;
  char const   *tmp ;
  COMMAND *tmp___0 ;

  {
  old_indent = indentation;
  old_amount = indentation_amount;
  was_heredoc = 0;
  command_string_index = was_heredoc;
  if (name) {
    if (*name) {
      {
      cprintf((char *)"%s ", name);
      }
    }
  }
  {
  cprintf((char *)"() ");
  }
  if (multi_line == 0) {
    indentation = 1;
    indentation_amount = 0;
  } else {
    {
    cprintf((char *)"\n");
    indentation += indentation_amount;
    }
  }
  inside_function_def ++;
  if (multi_line) {
    tmp = "{ \n";
  } else {
    tmp = "{ ";
  }
  {
  cprintf((char *)tmp);
  cmdcopy = copy_command(command);
  func_redirects = (REDIRECT *)((void *)0);
  }
  if ((unsigned int )cmdcopy->type == 9U) {
    func_redirects = cmdcopy->redirects;
    cmdcopy->redirects = (REDIRECT *)((void *)0);
  }
  if ((unsigned int )cmdcopy->type == 9U) {
    tmp___0 = (cmdcopy->value.Group)->command;
  } else {
    tmp___0 = cmdcopy;
  }
  {
  make_command_string_internal(tmp___0);
  indentation = old_indent;
  indentation_amount = old_amount;
  inside_function_def --;
  }
  if (func_redirects) {
    {
    newline((char *)"} ");
    print_redirection_list(func_redirects);
    cmdcopy->redirects = func_redirects;
    }
  } else {
    {
    newline((char *)"}");
    }
  }
  result = the_printed_command;
  if (! multi_line) {
    if ((int )*(result + 2) == 10) {
      {
      strcpy((char * __restrict  )(result + 2), (char const   * __restrict  )(result + 3));
      }
    }
  }
  {
  dispose_command(cmdcopy);
  }
  return (result);
}
}
static void newline(char *string ) 
{ 


  {
  {
  cprintf((char *)"\n");
  indent(indentation);
  }
  if (string) {
    if (*string) {
      {
      cprintf((char *)"%s", string);
      }
    }
  }
  return;
}
}
static char *indentation_string  ;
static int indentation_size  ;
static void indent(int amount ) 
{ 
  register int i ;
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (amount >= indentation_size) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (amount >= indentation_size)) {
          goto while_break___0;
        }
        indentation_size += 16;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      indentation_string = xrealloc((void *)indentation_string, (size_t )indentation_size);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (amount > 0)) {
      goto while_break___1;
    }
    tmp = i;
    i ++;
    *(indentation_string + tmp) = (char )' ';
    amount --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  *(indentation_string + i) = (char )'\000';
  cprintf(indentation_string);
  }
  return;
}
}
static void semicolon(void) 
{ 


  {
  if (command_string_index > 0) {
    if ((int )*(the_printed_command + (command_string_index - 1)) == 38) {
      return;
    }
  }
  {
  cprintf((char *)";");
  }
  return;
}
}
static void cprintf(char *control  , ...) 
{ 
  register char *s ;
  char char_arg[2] ;
  char *argp ;
  char intbuf[32] ;
  int digit_arg ;
  int arg_len ;
  int c ;
  va_list args ;
  size_t tmp ;
  int free_argp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char tmp___9 ;

  {
  {
  __builtin_va_start(args, control);
  tmp = strlen((char const   *)control);
  arg_len = (int )tmp;
  the_printed_command_resize(arg_len + 1);
  char_arg[1] = (char )'\000';
  s = control;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (s) {
      if (! *s) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    free_argp = 0;
    tmp___0 = s;
    s ++;
    c = (int )*tmp___0;
    argp = (char *)((void *)0);
    if (c != 37) {
      argp = s - 1;
      arg_len = 1;
    } else { //Added block
    if (! *s) {
      argp = s - 1;
      arg_len = 1;
    } else {
      tmp___1 = s;
      s ++;
      c = (int )*tmp___1;
      {
      if (c == 37) {
        goto case_37;
      }
      if (c == 115) {
        goto case_115;
      }
      if (c == 100) {
        goto case_100;
      }
      if (c == 99) {
        goto case_99;
      }
      goto switch_default;
      case_37: /* CIL Label */ 
      char_arg[0] = (char )c;
      argp = char_arg;
      arg_len = 1;
      goto switch_break;
      case_115: /* CIL Label */ 
      {
      tmp___7 = __builtin_va_arg(args, char *);
      tmp___2 = tmp___7;
      argp = tmp___2;
      tmp___3 = strlen((char const   *)argp);
      arg_len = (int )tmp___3;
      }
      goto switch_break;
      case_100: /* CIL Label */ 
      {
      tmp___8 = __builtin_va_arg(args, int );
      tmp___4 = tmp___8;
      digit_arg = tmp___4;
      argp = inttostr(digit_arg, intbuf, (int )sizeof(intbuf));
      tmp___5 = strlen((char const   *)argp);
      arg_len = (int )tmp___5;
      }
      goto switch_break;
      case_99: /* CIL Label */ 
      {
      tmp___9 = __builtin_va_arg(args, int );
      tmp___6 = tmp___9;
      char_arg[0] = tmp___6;
      argp = char_arg;
      arg_len = 1;
      }
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      programming_error("cprintf: bad `%%\' argument (%c)", c);
      }
      switch_break: /* CIL Label */ ;
      }
    }
    }
    if (argp) {
      if (arg_len) {
        {
        the_printed_command_resize(arg_len + 1);
        __builtin_memcpy((void *)(the_printed_command + command_string_index), (void const   *)argp,
                         (unsigned long )arg_len);
        command_string_index += arg_len;
        }
        if (free_argp) {
          {
          free((void *)argp);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  *(the_printed_command + command_string_index) = (char )'\000';
  return;
}
}
static void the_printed_command_resize(int length ) 
{ 
  int new ;

  {
  if ((unsigned long )the_printed_command == (unsigned long )((char *)0)) {
    {
    the_printed_command_size = ((length + 64) - 1) & -64;
    the_printed_command = xmalloc((size_t )the_printed_command_size);
    command_string_index = 0;
    }
  } else { //Added block
  if (command_string_index + length >= the_printed_command_size) {
    {
    new = (command_string_index + length) + 1;
    new = ((new + 128) - 1) & -128;
    the_printed_command_size = new;
    the_printed_command = xrealloc((void *)the_printed_command, (size_t )the_printed_command_size);
    }
  }
  }
  return;
}
}
static void xprintf(char *format , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 ) 
{ 


  {
  {
  printf((char const   * __restrict  )format, arg1, arg2, arg3, arg4, arg5);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-V0E4qTLL.i","-g")
void dispose_command(COMMAND *command ) 
{ 
  register FOR_COM *c ;
  register ARITH_FOR_COM *c___0 ;
  register CASE_COM *c___1 ;
  PATTERN_LIST *t ;
  PATTERN_LIST *p ;
  register WHILE_COM *c___2 ;
  register IF_COM *c___3 ;
  register SIMPLE_COM *c___4 ;
  register CONNECTION *c___5 ;
  register ARITH_COM *c___6 ;
  register COND_COM *c___7 ;
  register FUNCTION_DEF *c___8 ;

  {
  if ((unsigned long )command == (unsigned long )((COMMAND *)0)) {
    return;
  }
  if (command->redirects) {
    {
    dispose_redirects(command->redirects);
    }
  }
  {
  if ((unsigned int )command->type == 0U) {
    goto case_0;
  }
  if ((unsigned int )command->type == 5U) {
    goto case_0;
  }
  if ((unsigned int )command->type == 12U) {
    goto case_12;
  }
  if ((unsigned int )command->type == 9U) {
    goto case_9;
  }
  if ((unsigned int )command->type == 13U) {
    goto case_13;
  }
  if ((unsigned int )command->type == 1U) {
    goto case_1;
  }
  if ((unsigned int )command->type == 8U) {
    goto case_8;
  }
  if ((unsigned int )command->type == 2U) {
    goto case_8;
  }
  if ((unsigned int )command->type == 3U) {
    goto case_3;
  }
  if ((unsigned int )command->type == 4U) {
    goto case_4;
  }
  if ((unsigned int )command->type == 6U) {
    goto case_6;
  }
  if ((unsigned int )command->type == 10U) {
    goto case_10;
  }
  if ((unsigned int )command->type == 11U) {
    goto case_11;
  }
  if ((unsigned int )command->type == 7U) {
    goto case_7;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
  if ((unsigned int )command->type == 5U) {
    c = (FOR_COM *)command->value.Select;
  } else {
    c = command->value.For;
  }
  {
  dispose_word(c->name);
  dispose_words(c->map_list);
  dispose_command(c->action);
  free((void *)c);
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  {
  c___0 = command->value.ArithFor;
  dispose_words(c___0->init);
  dispose_words(c___0->test);
  dispose_words(c___0->step);
  dispose_command(c___0->action);
  free((void *)c___0);
  }
  goto switch_break;
  case_9: /* CIL Label */ 
  {
  dispose_command((command->value.Group)->command);
  free((void *)command->value.Group);
  }
  goto switch_break;
  case_13: /* CIL Label */ 
  {
  dispose_command((command->value.Subshell)->command);
  free((void *)command->value.Subshell);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  c___1 = command->value.Case;
  dispose_word(c___1->word);
  p = c___1->clauses;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p) {
      goto while_break;
    }
    {
    dispose_words(p->patterns);
    dispose_command(p->action);
    t = p;
    p = p->next;
    free((void *)t);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)c___1);
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
  c___2 = command->value.While;
  dispose_command(c___2->test);
  dispose_command(c___2->action);
  free((void *)c___2);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  c___3 = command->value.If;
  dispose_command(c___3->test);
  dispose_command(c___3->true_case);
  dispose_command(c___3->false_case);
  free((void *)c___3);
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  c___4 = command->value.Simple;
  dispose_words(c___4->words);
  dispose_redirects(c___4->redirects);
  free((void *)c___4);
  }
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  c___5 = command->value.Connection;
  dispose_command(c___5->first);
  dispose_command(c___5->second);
  free((void *)c___5);
  }
  goto switch_break;
  case_10: /* CIL Label */ 
  {
  c___6 = command->value.Arith;
  dispose_words(c___6->exp);
  free((void *)c___6);
  }
  goto switch_break;
  case_11: /* CIL Label */ 
  {
  c___7 = command->value.Cond;
  dispose_cond_node(c___7);
  }
  goto switch_break;
  case_7: /* CIL Label */ 
  {
  c___8 = command->value.Function_def;
  dispose_word(c___8->name);
  dispose_command(c___8->command);
  free((void *)c___8);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  command_error("dispose_command", 1, (int )command->type, 0);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  free((void *)command);
  }
  return;
}
}
void dispose_cond_node(COND_COM *cond ) 
{ 


  {
  if (cond) {
    if (cond->left) {
      {
      dispose_cond_node(cond->left);
      }
    }
    if (cond->right) {
      {
      dispose_cond_node(cond->right);
      }
    }
    if (cond->op) {
      {
      dispose_word(cond->op);
      }
    }
    {
    free((void *)cond);
    }
  }
  return;
}
}
void dispose_word(WORD_DESC *w ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (w->word) {
      {
      free((void *)w->word);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)w);
  }
  return;
}
}
void dispose_words(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *t ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    {
    t = list___0;
    list___0 = list___0->next;
    dispose_word(t->word);
    free((void *)t);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void dispose_redirects(REDIRECT *list___0 ) 
{ 
  register REDIRECT *t ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    t = list___0;
    list___0 = list___0->next;
    {
    if ((unsigned int )t->instruction == 4U) {
      goto case_4;
    }
    if ((unsigned int )t->instruction == 7U) {
      goto case_4;
    }
    if ((unsigned int )t->instruction == 0U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 1U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 2U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 3U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 9U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 10U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 11U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 12U) {
      goto case_0;
    }
    if ((unsigned int )t->instruction == 13U) {
      goto case_0;
    }
    goto switch_default;
    case_4: /* CIL Label */ 
    case_7: /* CIL Label */ 
    {
    free((void *)t->here_doc_eof);
    }
    case_0: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
    dispose_word(t->redirectee.filename);
    }
    switch_default: /* CIL Label */ 
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    free((void *)t);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-mdCWXE3M.i","-g")
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
sigjmp_buf return_catch  ;
WORD_LIST *copy_word_list(WORD_LIST *list___0 ) ;
REDIRECT *copy_redirects(REDIRECT *list___0 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
void xfree(void *string ) ;
void sys_error(char const   *format  , ...) ;
char **export_env ;
void make_funcname_visible(int on_or_off ) ;
SHELL_VAR *find_function(char *name ) ;
SHELL_VAR *bind_function(char *name , COMMAND *value ) ;
void dispose_function_env(void) ;
void dispose_builtin_env(void) ;
void merge_temporary_env(void) ;
void merge_builtin_env(void) ;
void merge_function_env(void) ;
void maybe_make_export_env(void) ;
void put_command_name_into_env(char *command_name ) ;
void set_pipestatus_from_exit(int s ) ;
void begin_unwind_frame(char *tag ) ;
void discard_unwind_frame(char *tag ) ;
void run_unwind_frame(char *tag ) ;
void unwind_protect_var(int *var , char *value , int size ) ;
void clear_unwind_protect_list(int flags ) ;
WORD_LIST *expand_word_unsplit(WORD_DESC *word , int quoted ) ;
WORD_LIST *expand_word_leave_quoted(WORD_DESC *word , int quoted ) ;
WORD_LIST *expand_words(WORD_LIST *list___0 ) ;
char *cond_expand_word(WORD_DESC *w , int special ) ;
void reset_terminating_signals(void) ;
SigHandler *set_sigint_handler(void) ;
long evalexp(char *expr___0 , int *validp ) ;
int list_length(GENERIC_LIST *list___0 ) ;
char **word_list_to_argv(WORD_LIST *list___0 , int copy , int starting_index , int *ip ) ;
extern char *strindex(char const   * , char const   * ) ;
extern int array_len(char ** ) ;
extern char **copy_array(char ** ) ;
extern void timeval_to_secs() ;
int echo_command_at_execute ;
void reset_shell_flags(void) ;
void delete_all_aliases(void) ;
pid_t original_pgrp ;
pid_t last_made_pid ;
pid_t last_asynchronous_pid ;
JOB **jobs ;
int job_slots ;
int stop_pipeline(int async , COMMAND *deferred ) ;
void terminate_current_pipeline(void) ;
void kill_current_pipeline(void) ;
void describe_pid(pid_t pid ) ;
pid_t make_child(char *command , int async_p ) ;
int wait_for(pid_t pid ) ;
void reap_dead_jobs(void) ;
int start_job(int job , int foreground ) ;
void without_job_control(void) ;
void set_sigchld_handler(void) ;
struct fd_bitmap *new_fd_bitmap(long size ) ;
void dispose_fd_bitmap(struct fd_bitmap *fdbp ) ;
void close_fd_bitmap(struct fd_bitmap *fdbp ) ;
int executing_line_number(void) ;
int execute_command_internal(COMMAND *command , int asynchronous , int pipe_in , int pipe_out ,
                             struct fd_bitmap *fds_to_close ) ;
int shell_execve(char *command , char **args , char **env ) ;
void setup_async_signals(void) ;
void dispose_exec_redirects(void) ;
int execute_shell_function(SHELL_VAR *var , WORD_LIST *words ) ;
char *search_for_command(char *pathname ) ;
int do_redirections(REDIRECT *list___0 , int for_real , int internal , int set_clexec ) ;
char *trap_list[66]  ;
void set_debug_trap(char *command ) ;
void restore_default_signal(int sig ) ;
void run_debug_trap(void) ;
void restore_original_signals(void) ;
void set_signal_ignored(int sig ) ;
char *quote_string_for_globbing(char const   *pathname , int qflags ) ;
int unary_test(char *op , char *arg ) ;
int binary_test(char *op , char *arg1 , char *arg2 , int flags ) ;
extern void push_context(void) ;
extern void pop_context(void) ;
extern struct builtin *builtin_address_internal(char * , int  ) ;
extern Function *find_shell_builtin(char * ) ;
extern Function *builtin_address(char * ) ;
extern Function *find_special_builtin(char * ) ;
extern void reset_shell_options(void) ;
extern void reset_shopt_options(void) ;
extern int command_builtin() ;
extern int eval_builtin() ;
extern int exec_builtin() ;
extern int jobs_builtin() ;
extern int read_builtin() ;
extern int return_builtin() ;
extern int source_builtin() ;
int history_lines_this_session  ;
extern int breaking ;
extern int continuing ;
extern int loop_level ;
int running_trap  ;
int trap_line_number  ;
int already_making_children ;
char **temporary_env ;
char **function_env ;
char **builtin_env ;
pid_t last_command_subst_pid ;
static void close_pipes(int in , int out ) ;
static void do_piping(int pipe_in , int pipe_out ) ;
static void bind_lastarg(char *arg ) ;
static void cleanup_redirects(REDIRECT *list___0 ) ;
static int execute_for_command(FOR_COM *for_command ) ;
static int execute_select_command(SELECT_COM *select_command ) ;
static int execute_arith_command(ARITH_COM *arith_command ) ;
static int execute_cond_command(COND_COM *cond_command ) ;
static int time_command(COMMAND *command , int asynchronous , int pipe_in , int pipe_out ,
                        struct fd_bitmap *fds_to_close ) ;
static int execute_arith_for_command(ARITH_FOR_COM *arith_for_command ) ;
static int execute_case_command(CASE_COM *case_command ) ;
static int execute_while_command(WHILE_COM *while_command ) ;
static int execute_until_command(WHILE_COM *while_command ) ;
static int execute_while_or_until(WHILE_COM *while_command , int type ) ;
static int execute_if_command(IF_COM *if_command ) ;
static int execute_simple_command(SIMPLE_COM *simple_command , int pipe_in , int pipe_out ,
                                  int async , struct fd_bitmap *fds_to_close ) ;
static int execute_builtin(Function *builtin , WORD_LIST *words , int flags , int subshell ) ;
static int execute_function(SHELL_VAR *var , WORD_LIST *words , int flags , struct fd_bitmap *fds_to_close ,
                            int async , int subshell ) ;
static int execute_builtin_or_function(WORD_LIST *words , Function *builtin , SHELL_VAR *var ,
                                       REDIRECT *redirects , struct fd_bitmap *fds_to_close ,
                                       int flags ) ;
static int builtin_status(int result ) ;
static void execute_subshell_builtin_or_function(WORD_LIST *words , REDIRECT *redirects ,
                                                 Function *builtin , SHELL_VAR *var ,
                                                 int pipe_in , int pipe_out , int async ,
                                                 struct fd_bitmap *fds_to_close ,
                                                 int flags ) ;
static void execute_disk_command(WORD_LIST *words , REDIRECT *redirects , char *command_line ,
                                 int pipe_in , int pipe_out , int async , struct fd_bitmap *fds_to_close ,
                                 int cmdflags ) ;
static int execute_connection(COMMAND *command , int asynchronous , int pipe_in ,
                              int pipe_out , struct fd_bitmap *fds_to_close ) ;
static int execute_intern_function(WORD_DESC *name , COMMAND *function ) ;
static int execute_in_subshell(COMMAND *command , int asynchronous , int pipe_in ,
                               int pipe_out , struct fd_bitmap *fds_to_close ) ;
static int function_line_number  ;
static COMMAND *currently_executing_command  ;
struct stat SB  ;
static int special_builtin_failed  ;
int return_catch_flag  ;
int return_catch_value  ;
REDIRECT *redirection_undo_list  =    (REDIRECT *)((void *)0);
REDIRECT *exec_redirection_undo_list  =    (REDIRECT *)((void *)0);
SHELL_VAR *this_shell_function  ;
struct fd_bitmap *current_fds_to_close  =    (struct fd_bitmap *)((void *)0);
struct fd_bitmap *new_fd_bitmap(long size ) 
{ 
  struct fd_bitmap *ret ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(struct fd_bitmap ));
  ret = (struct fd_bitmap *)tmp;
  ret->size = size;
  }
  if (size) {
    {
    ret->bitmap = xmalloc((size_t )size);
    bzero((void *)ret->bitmap, (size_t )size);
    }
  } else {
    ret->bitmap = (char *)((void *)0);
  }
  return (ret);
}
}
void dispose_fd_bitmap(struct fd_bitmap *fdbp ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (fdbp->bitmap) {
      {
      free((void *)fdbp->bitmap);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)fdbp);
  }
  return;
}
}
void close_fd_bitmap(struct fd_bitmap *fdbp ) 
{ 
  register int i ;

  {
  if (fdbp) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((long )i < fdbp->size)) {
        goto while_break;
      }
      if (*(fdbp->bitmap + i)) {
        {
        close(i);
        *(fdbp->bitmap + i) = (char)0;
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
int executing_line_number(void) 
{ 


  {
  if (executing) {
    if (variable_context == 0) {
      if (currently_executing_command) {
        if ((unsigned int )currently_executing_command->type == 4U) {
          return ((currently_executing_command->value.Simple)->line);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (running_trap) {
    return (trap_line_number);
  } else {
    return (line_number);
  }
  }
}
}
int execute_command(COMMAND *command ) 
{ 
  struct fd_bitmap *bitmap ;
  int result ;

  {
  {
  current_fds_to_close = (struct fd_bitmap *)((void *)0);
  bitmap = new_fd_bitmap(32L);
  begin_unwind_frame((char *)"execute-command");
  add_unwind_protect((Function *)(& dispose_fd_bitmap), (char *)bitmap);
  result = execute_command_internal(command, 0, -1, -1, bitmap);
  dispose_fd_bitmap(bitmap);
  discard_unwind_frame((char *)"execute-command");
  }
  if (variable_context == 0) {
    {
    unlink_fifo_list();
    }
  }
  return (result);
}
}
static int shell_control_structure(enum command_type type ) 
{ 


  {
  {
  if ((unsigned int )type == 0U) {
    goto case_0;
  }
  if ((unsigned int )type == 12U) {
    goto case_0;
  }
  if ((unsigned int )type == 5U) {
    goto case_0;
  }
  if ((unsigned int )type == 10U) {
    goto case_0;
  }
  if ((unsigned int )type == 11U) {
    goto case_0;
  }
  if ((unsigned int )type == 1U) {
    goto case_0;
  }
  if ((unsigned int )type == 2U) {
    goto case_0;
  }
  if ((unsigned int )type == 8U) {
    goto case_0;
  }
  if ((unsigned int )type == 3U) {
    goto case_0;
  }
  if ((unsigned int )type == 9U) {
    goto case_0;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_9: /* CIL Label */ 
  return (1);
  switch_default: /* CIL Label */ 
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
static void cleanup_redirects(REDIRECT *list___0 ) 
{ 


  {
  {
  do_redirections(list___0, 1, 0, 0);
  dispose_redirects(list___0);
  }
  return;
}
}
void dispose_exec_redirects(void) 
{ 


  {
  if (exec_redirection_undo_list) {
    {
    dispose_redirects(exec_redirection_undo_list);
    exec_redirection_undo_list = (REDIRECT *)((void *)0);
    }
  }
  return;
}
}
void open_files(void) 
{ 
  register int i ;
  int f ;
  int fd_table_size ;
  __pid_t tmp ;
  char const   *tmp___0 ;

  {
  {
  fd_table_size = getdtablesize();
  tmp = getpid();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"pid %d open files:",
          tmp);
  i = 3;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < fd_table_size)) {
      goto while_break;
    }
    {
    f = fcntl(i, 1, 0);
    }
    if (f != -1) {
      if (f) {
        tmp___0 = "close";
      } else {
        tmp___0 = "open";
      }
      {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %d (%s)",
              i, tmp___0);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
  return;
}
}
static void async_redirect_stdin(void) 
{ 
  int fd ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
  fd = open("/dev/null", 0);
  }
  if (fd > 0) {
    {
    dup2(fd, 0);
    close(fd);
    }
  } else { //Added block
  if (fd < 0) {
    {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    internal_error("cannot redirect standard input from /dev/null: %s", tmp___0);
    }
  }
  }
  return;
}
}
int stdin_redirects(REDIRECT *redirs ) ;
int execute_command_internal(COMMAND *command , int asynchronous , int pipe_in , int pipe_out ,
                             struct fd_bitmap *fds_to_close ) 
{ 
  int exec_result ;
  int invert ;
  int ignore_return ;
  int was_debug_trap ;
  REDIRECT *my_undo_list ;
  REDIRECT *exec_undo_list ;
  pid_t volatile   last_pid___0 ;
  int tmp ;
  pid_t paren_pid ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  REDIRECT *tmp___9 ;
  REDIRECT *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  if ((unsigned long )command == (unsigned long )((COMMAND *)0)) {
    return (0);
  } else { //Added block
  if (breaking) {
    return (0);
  } else { //Added block
  if (continuing) {
    return (0);
  } else { //Added block
  if (read_but_dont_execute) {
    return (0);
  }
  }
  }
  }
  {
  run_pending_traps();
  }
  if (running_trap == 0) {
    currently_executing_command = command;
  }
  invert = (command->flags & 4) != 0;
  if (exit_immediately_on_error) {
    if (invert) {
      command->flags |= 8;
    }
  }
  exec_result = 0;
  if ((unsigned int )command->type == 13U) {
    if (command->flags & 64) {
      {
      tmp = execute_in_subshell(command, asynchronous, pipe_in, pipe_out, fds_to_close);
      }
      return (tmp);
    }
  }
  if ((unsigned int )command->type == 13U) {
    goto _L___0;
  } else { //Added block
  if (command->flags & 3) {
    goto _L___0;
  } else {
    {
    tmp___6 = shell_control_structure(command->type);
    }
    if (tmp___6) {
      if (pipe_out != -1) {
        goto _L___0;
      } else { //Added block
      if (pipe_in != -1) {
        goto _L___0;
      } else { //Added block
      if (asynchronous) {
        _L___0: 
        {
        tmp___0 = make_command_string(command);
        tmp___1 = make_command_string(command);
        tmp___2 = strlen((char const   *)tmp___1);
        tmp___3 = xmalloc(1UL + tmp___2);
        tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )tmp___0);
        paren_pid = make_child(tmp___4, asynchronous);
        }
        if (paren_pid == 0) {
          {
          tmp___5 = execute_in_subshell(command, asynchronous, pipe_in, pipe_out,
                                        fds_to_close);
          exit(tmp___5);
          }
        } else {
          {
          close_pipes(pipe_in, pipe_out);
          unlink_fifo_list();
          }
          if (pipe_out != -1) {
            return (0);
          }
          {
          stop_pipeline(asynchronous, (COMMAND *)((void *)0));
          }
          if (asynchronous == 0) {
            {
            last_command_exit_value = wait_for(paren_pid);
            }
            if (invert) {
              if (last_command_exit_value == 0) {
                exec_result = 1;
              } else {
                exec_result = 0;
              }
            } else {
              exec_result = last_command_exit_value;
            }
            last_command_exit_value = exec_result;
            return (last_command_exit_value);
          } else {
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              if (interactive) {
                {
                describe_pid(paren_pid);
                }
              }
              goto while_break;
            }
            while_break: /* CIL Label */ ;
            }
            {
            run_pending_traps();
            }
            return (0);
          }
        }
      }
      }
      }
    }
  }
  }
  if (command->flags & 128) {
    if (asynchronous) {
      {
      command->flags |= 2;
      exec_result = execute_command_internal(command, 1, pipe_in, pipe_out, fds_to_close);
      }
    } else {
      {
      exec_result = time_command(command, asynchronous, pipe_in, pipe_out, fds_to_close);
      }
      if (running_trap == 0) {
        currently_executing_command = (COMMAND *)((void *)0);
      }
    }
    return (exec_result);
  }
  {
  tmp___7 = shell_control_structure(command->type);
  }
  if (tmp___7) {
    if (command->redirects) {
      {
      stdin_redir = stdin_redirects(command->redirects);
      }
    }
  }
  {
  tmp___8 = do_redirections(command->redirects, 1, 1, 0);
  }
  if (tmp___8 != 0) {
    {
    cleanup_redirects(redirection_undo_list);
    redirection_undo_list = (REDIRECT *)((void *)0);
    dispose_exec_redirects();
    }
    return (1);
  }
  if (redirection_undo_list) {
    {
    tmp___9 = copy_redirects(redirection_undo_list);
    my_undo_list = tmp___9;
    dispose_redirects(redirection_undo_list);
    redirection_undo_list = (REDIRECT *)((void *)0);
    }
  } else {
    my_undo_list = (REDIRECT *)((void *)0);
  }
  if (exec_redirection_undo_list) {
    {
    tmp___10 = copy_redirects(exec_redirection_undo_list);
    exec_undo_list = tmp___10;
    dispose_redirects(exec_redirection_undo_list);
    exec_redirection_undo_list = (REDIRECT *)((void *)0);
    }
  } else {
    exec_undo_list = (REDIRECT *)((void *)0);
  }
  if (my_undo_list) {
    {
    begin_unwind_frame((char *)"loop_redirections");
    }
  } else { //Added block
  if (exec_undo_list) {
    {
    begin_unwind_frame((char *)"loop_redirections");
    }
  }
  }
  if (my_undo_list) {
    {
    add_unwind_protect((Function *)(& cleanup_redirects), (char *)my_undo_list);
    }
  }
  if (exec_undo_list) {
    {
    add_unwind_protect((Function *)(& dispose_redirects), (char *)exec_undo_list);
    }
  }
  ignore_return = (command->flags & 8) != 0;
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  {
  if ((unsigned int )command->type == 4U) {
    goto case_4;
  }
  if ((unsigned int )command->type == 0U) {
    goto case_0;
  }
  if ((unsigned int )command->type == 12U) {
    goto case_12;
  }
  if ((unsigned int )command->type == 5U) {
    goto case_5;
  }
  if ((unsigned int )command->type == 1U) {
    goto case_1;
  }
  if ((unsigned int )command->type == 2U) {
    goto case_2;
  }
  if ((unsigned int )command->type == 8U) {
    goto case_8;
  }
  if ((unsigned int )command->type == 3U) {
    goto case_3;
  }
  if ((unsigned int )command->type == 9U) {
    goto case_9;
  }
  if ((unsigned int )command->type == 6U) {
    goto case_6;
  }
  if ((unsigned int )command->type == 10U) {
    goto case_10;
  }
  if ((unsigned int )command->type == 11U) {
    goto case_11;
  }
  if ((unsigned int )command->type == 7U) {
    goto case_7;
  }
  goto switch_default;
  case_4: /* CIL Label */ 
  {
  last_pid___0 = (pid_t volatile   )last_made_pid;
  tmp___11 = signal_is_trapped(65);
  }
  if (tmp___11) {
    {
    tmp___12 = signal_is_ignored(65);
    }
    if (tmp___12 == 0) {
      tmp___13 = 1;
    } else {
      tmp___13 = 0;
    }
  } else {
    tmp___13 = 0;
  }
  was_debug_trap = tmp___13;
  if (ignore_return) {
    if (command->value.Simple) {
      (command->value.Simple)->flags |= 8;
    }
  }
  if (command->flags & 1024) {
    (command->value.Simple)->flags |= 1024;
  }
  {
  exec_result = execute_simple_command(command->value.Simple, pipe_in, pipe_out, asynchronous,
                                       fds_to_close);
  dispose_used_env_vars();
  }
  if (already_making_children) {
    if (pipe_out == -1) {
      if (last_pid___0 != (pid_t volatile   )last_made_pid) {
        {
        stop_pipeline(asynchronous, (COMMAND *)((void *)0));
        }
        if (asynchronous) {
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (interactive) {
              {
              describe_pid(last_made_pid);
              }
            }
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
          exec_result = wait_for(last_made_pid);
          }
        }
      }
    }
  }
  if (was_debug_trap) {
    {
    last_command_exit_value = exec_result;
    run_debug_trap();
    }
  }
  if (ignore_return == 0) {
    if (invert == 0) {
      if (posixly_correct) {
        if (interactive == 0) {
          if (special_builtin_failed) {
            {
            last_command_exit_value = exec_result;
            run_pending_traps();
            jump_to_top_level(3);
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else { //Added block
      _L___2: 
      if (exit_immediately_on_error) {
        if (exec_result != 0) {
          {
          last_command_exit_value = exec_result;
          run_pending_traps();
          jump_to_top_level(3);
          }
        }
      }
      }
    }
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  if (ignore_return) {
    (command->value.For)->flags |= 8;
  }
  {
  exec_result = execute_for_command(command->value.For);
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  if (ignore_return) {
    (command->value.ArithFor)->flags |= 8;
  }
  {
  exec_result = execute_arith_for_command(command->value.ArithFor);
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  if (ignore_return) {
    (command->value.Select)->flags |= 8;
  }
  {
  exec_result = execute_select_command(command->value.Select);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  if (ignore_return) {
    (command->value.Case)->flags |= 8;
  }
  {
  exec_result = execute_case_command(command->value.Case);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  if (ignore_return) {
    (command->value.While)->flags |= 8;
  }
  {
  exec_result = execute_while_command(command->value.While);
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  if (ignore_return) {
    (command->value.While)->flags |= 8;
  }
  {
  exec_result = execute_until_command(command->value.While);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  if (ignore_return) {
    (command->value.If)->flags |= 8;
  }
  {
  exec_result = execute_if_command(command->value.If);
  }
  goto switch_break;
  case_9: /* CIL Label */ 
  if (asynchronous) {
    {
    command->flags |= 2;
    exec_result = execute_command_internal(command, 1, pipe_in, pipe_out, fds_to_close);
    }
  } else {
    if (ignore_return) {
      if ((command->value.Group)->command) {
        ((command->value.Group)->command)->flags |= 8;
      }
    }
    {
    exec_result = execute_command_internal((command->value.Group)->command, asynchronous,
                                           pipe_in, pipe_out, fds_to_close);
    }
  }
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  exec_result = execute_connection(command, asynchronous, pipe_in, pipe_out, fds_to_close);
  }
  goto switch_break;
  case_10: /* CIL Label */ 
  if (ignore_return) {
    (command->value.Arith)->flags |= 8;
  }
  {
  exec_result = execute_arith_command(command->value.Arith);
  }
  goto switch_break;
  case_11: /* CIL Label */ 
  if (ignore_return) {
    (command->value.Cond)->flags |= 8;
  }
  {
  exec_result = execute_cond_command(command->value.Cond);
  }
  goto switch_break;
  case_7: /* CIL Label */ 
  {
  exec_result = execute_intern_function((command->value.Function_def)->name, (command->value.Function_def)->command);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  command_error("execute_command", 1, (int )command->type, 0);
  }
  switch_break: /* CIL Label */ ;
  }
  if (my_undo_list) {
    {
    do_redirections(my_undo_list, 1, 0, 0);
    dispose_redirects(my_undo_list);
    }
  }
  if (exec_undo_list) {
    {
    dispose_redirects(exec_undo_list);
    }
  }
  if (my_undo_list) {
    {
    discard_unwind_frame((char *)"loop_redirections");
    }
  } else { //Added block
  if (exec_undo_list) {
    {
    discard_unwind_frame((char *)"loop_redirections");
    }
  }
  }
  if (invert) {
    if (exec_result == 0) {
      exec_result = 1;
    } else {
      exec_result = 0;
    }
  }
  {
  last_command_exit_value = exec_result;
  run_pending_traps();
  }
  if (running_trap == 0) {
    currently_executing_command = (COMMAND *)((void *)0);
  }
  return (last_command_exit_value);
}
}
extern struct timeval *difftimeval() ;
extern struct timeval *addtimeval() ;
extern int timeval_to_cpu() ;
static int precs[4]  = {      0,      100,      10,      1};
static int mkfmt(char *buf , int prec , int lng , long sec , int sec_fraction ) 
{ 
  long min ;
  char abuf[16] ;
  int ind___1 ;
  int aind ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  ind___1 = 0;
  abuf[15] = (char )'\000';
  if (lng) {
    min = sec / 60L;
    sec %= 60L;
    aind = 14;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp = aind;
      aind --;
      abuf[tmp] = (char )(min % 10L + 48L);
      min /= 10L;
      if (! min) {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    aind ++;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! abuf[aind]) {
        goto while_break___0;
      }
      tmp___0 = ind___1;
      ind___1 ++;
      tmp___1 = aind;
      aind ++;
      *(buf + tmp___0) = abuf[tmp___1];
    }
    while_break___0: /* CIL Label */ ;
    }
    tmp___2 = ind___1;
    ind___1 ++;
    *(buf + tmp___2) = (char )'m';
  }
  aind = 14;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    tmp___3 = aind;
    aind --;
    abuf[tmp___3] = (char )(sec % 10L + 48L);
    sec /= 10L;
    if (! sec) {
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  aind ++;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! abuf[aind]) {
      goto while_break___2;
    }
    tmp___4 = ind___1;
    ind___1 ++;
    tmp___5 = aind;
    aind ++;
    *(buf + tmp___4) = abuf[tmp___5];
  }
  while_break___2: /* CIL Label */ ;
  }
  if (prec != 0) {
    tmp___6 = ind___1;
    ind___1 ++;
    *(buf + tmp___6) = (char )'.';
    aind = 1;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! (aind <= prec)) {
        goto while_break___3;
      }
      tmp___7 = ind___1;
      ind___1 ++;
      *(buf + tmp___7) = (char )(sec_fraction / precs[aind] + 48);
      sec_fraction %= precs[aind];
      aind ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  if (lng) {
    tmp___8 = ind___1;
    ind___1 ++;
    *(buf + tmp___8) = (char )'s';
  }
  *(buf + ind___1) = (char )'\000';
  return (ind___1);
}
}
static void print_formatted_time(FILE *fp , char *format , long rs , int rsf , long us ,
                                 int usf , long ss , int ssf , int cpu ) 
{ 
  int prec ;
  int lng ;
  int len___0 ;
  char *str ;
  char *s ;
  char ts[32] ;
  long sum ;
  int sum_frac ;
  int sindex ;
  int ssize ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
  tmp = strlen((char const   *)format);
  len___0 = (int )tmp;
  ssize = (len___0 + 64) - len___0 % 64;
  str = xmalloc((size_t )ssize);
  sindex = 0;
  s = format;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    if ((int )*s != 37) {
      goto _L;
    } else { //Added block
    if ((int )*(s + 1) == 0) {
      _L: 
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (sindex + 1 >= ssize) {
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (sindex + 1 >= ssize)) {
              goto while_break___1;
            }
            ssize += 64;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
          str = xrealloc((void *)str, (size_t )ssize);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      tmp___0 = sindex;
      sindex ++;
      *(str + tmp___0) = *s;
    } else { //Added block
    if ((int )*(s + 1) == 37) {
      s ++;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (sindex + 1 >= ssize) {
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if (! (sindex + 1 >= ssize)) {
              goto while_break___3;
            }
            ssize += 64;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
          str = xrealloc((void *)str, (size_t )ssize);
          }
        }
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      tmp___1 = sindex;
      sindex ++;
      *(str + tmp___1) = *s;
    } else { //Added block
    if ((int )*(s + 1) == 80) {
      s ++;
      if (cpu > 10000) {
        cpu = 10000;
      }
      {
      sum = (long )(cpu / 100);
      sum_frac = (cpu % 100) * 10;
      len___0 = mkfmt(ts, 2, 0, sum, sum_frac);
      }
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (sindex + len___0 >= ssize) {
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (! (sindex + len___0 >= ssize)) {
              goto while_break___5;
            }
            ssize += 64;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
          str = xrealloc((void *)str, (size_t )ssize);
          }
        }
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      strcpy((char * __restrict  )(str + sindex), (char const   * __restrict  )(ts));
      sindex += len___0;
      }
    } else {
      {
      prec = 3;
      lng = 0;
      s ++;
      tmp___3 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___3 + (int )*s) & 2048) {
        tmp___2 = s;
        s ++;
        prec = (int )*tmp___2 - 48;
        if (prec > 3) {
          prec = 3;
        }
      }
      if ((int )*s == 108) {
        lng = 1;
        s ++;
      }
      if ((int )*s == 82) {
        {
        len___0 = mkfmt(ts, prec, lng, rs, rsf);
        }
      } else { //Added block
      if ((int )*s == 69) {
        {
        len___0 = mkfmt(ts, prec, lng, rs, rsf);
        }
      } else { //Added block
      if ((int )*s == 85) {
        {
        len___0 = mkfmt(ts, prec, lng, us, usf);
        }
      } else { //Added block
      if ((int )*s == 83) {
        {
        len___0 = mkfmt(ts, prec, lng, ss, ssf);
        }
      } else {
        {
        internal_error("bad format character in time format: %c", (int )*s);
        free((void *)str);
        }
        return;
      }
      }
      }
      }
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        if (sindex + len___0 >= ssize) {
          {
          while (1) {
            while_continue___7: /* CIL Label */ ;
            if (! (sindex + len___0 >= ssize)) {
              goto while_break___7;
            }
            ssize += 64;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
          str = xrealloc((void *)str, (size_t )ssize);
          }
        }
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      strcpy((char * __restrict  )(str + sindex), (char const   * __restrict  )(ts));
      sindex += len___0;
      }
    }
    }
    }
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *(str + sindex) = (char )'\000';
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", str);
  fflush(fp);
  free((void *)str);
  }
  return;
}
}
static int time_command(COMMAND *command , int asynchronous , int pipe_in , int pipe_out ,
                        struct fd_bitmap *fds_to_close ) 
{ 
  int rv ;
  int posix_time ;
  int old_flags ;
  long rs ;
  long us ;
  long ss ;
  int rsf ;
  int usf ;
  int ssf ;
  int cpu ;
  char *time_format ;
  struct timeval real ;
  struct timeval user ;
  struct timeval sys ;
  struct timeval before ;
  struct timeval after ;
  struct timezone dtz ;
  struct rusage selfb ;
  struct rusage selfa ;
  struct rusage kidsb ;
  struct rusage kidsa ;
  struct timeval *tmp ;
  struct timeval *tmp___0 ;
  struct timeval *tmp___1 ;
  struct timeval *tmp___2 ;

  {
  {
  gettimeofday((struct timeval * __restrict  )(& before), (__timezone_ptr_t )(& dtz));
  getrusage(0, & selfb);
  getrusage(-1, & kidsb);
  posix_time = command->flags & 256;
  old_flags = command->flags;
  command->flags &= -385;
  rv = execute_command_internal(command, asynchronous, pipe_in, pipe_out, fds_to_close);
  command->flags = old_flags;
  ss = 0L;
  us = ss;
  rs = us;
  cpu = 0;
  ssf = cpu;
  usf = ssf;
  rsf = usf;
  gettimeofday((struct timeval * __restrict  )(& after), (__timezone_ptr_t )(& dtz));
  getrusage(0, & selfa);
  getrusage(-1, & kidsa);
  difftimeval(& real, & before, & after);
  timeval_to_secs(& real, & rs, & rsf);
  tmp = difftimeval(& before, & kidsb.ru_utime, & kidsa.ru_utime);
  tmp___0 = difftimeval(& after, & selfb.ru_utime, & selfa.ru_utime);
  addtimeval(& user, tmp___0, tmp);
  timeval_to_secs(& user, & us, & usf);
  tmp___1 = difftimeval(& before, & kidsb.ru_stime, & kidsa.ru_stime);
  tmp___2 = difftimeval(& after, & selfb.ru_stime, & selfa.ru_stime);
  addtimeval(& sys, tmp___2, tmp___1);
  timeval_to_secs(& sys, & ss, & ssf);
  cpu = timeval_to_cpu(& real, & user, & sys);
  }
  if (posix_time) {
    time_format = (char *)"real %2R\nuser %2U\nsys %2S";
  } else {
    {
    time_format = get_string_value("TIMEFORMAT");
    }
    if ((unsigned long )time_format == (unsigned long )((char *)0)) {
      time_format = (char *)"\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS";
    }
  }
  if (time_format) {
    if (*time_format) {
      {
      print_formatted_time(stderr, time_format, rs, rsf, us, usf, ss, ssf, cpu);
      }
    }
  }
  return (rv);
}
}
static int execute_in_subshell(COMMAND *command , int asynchronous , int pipe_in ,
                               int pipe_out , struct fd_bitmap *fds_to_close ) 
{ 
  int user_subshell ;
  int return_code ;
  int function_value ;
  int should_redir_stdin ;
  int invert ;
  int ois ;
  COMMAND *tcom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (asynchronous) {
    if (command->flags & 1024) {
      if (pipe_in == -1) {
        {
        tmp = stdin_redirects(command->redirects);
        }
        if (tmp == 0) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  should_redir_stdin = tmp___0;
  invert = (command->flags & 4) != 0;
  if ((unsigned int )command->type == 13U) {
    tmp___1 = 1;
  } else { //Added block
  if ((command->flags & 1) != 0) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  }
  user_subshell = tmp___1;
  command->flags &= -8;
  if (asynchronous) {
    original_pgrp = -1;
    ois = interactive_shell;
    interactive_shell = 0;
    if (ois != interactive_shell) {
      expand_aliases = 0;
    }
    asynchronous = 0;
  }
  interactive = 0;
  login_shell = interactive;
  if (user_subshell) {
    subshell_environment = 2;
  } else {
    subshell_environment = 1;
  }
  {
  reset_terminating_signals();
  restore_original_signals();
  }
  if (asynchronous) {
    {
    setup_async_signals();
    }
  }
  {
  set_sigchld_handler();
  set_sigint_handler();
  without_job_control();
  }
  if (fds_to_close) {
    {
    close_fd_bitmap(fds_to_close);
    }
  }
  {
  do_piping(pipe_in, pipe_out);
  }
  if (user_subshell) {
    {
    stdin_redir = stdin_redirects(command->redirects);
    restore_default_signal(0);
    }
  }
  if (should_redir_stdin) {
    if (stdin_redir == 0) {
      {
      async_redirect_stdin();
      }
    }
  }
  if (command->redirects) {
    {
    tmp___3 = do_redirections(command->redirects, 1, 0, 0);
    }
    if (tmp___3 != 0) {
      if (invert) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      {
      exit(tmp___2);
      }
    }
    {
    dispose_redirects(command->redirects);
    command->redirects = (REDIRECT *)((void *)0);
    }
  }
  if ((unsigned int )command->type == 13U) {
    tcom = (command->value.Subshell)->command;
  } else {
    tcom = command;
  }
  if (user_subshell) {
    if ((unsigned int )tcom->type == 4U) {
      goto _L;
    } else { //Added block
    if ((unsigned int )tcom->type == 13U) {
      _L: 
      if ((tcom->flags & 128) == 0) {
        if ((tcom->flags & 4) == 0) {
          tcom->flags |= 64;
          if ((unsigned int )tcom->type == 4U) {
            (tcom->value.Simple)->flags |= 64;
          }
        }
      }
    }
    }
  }
  invert = (tcom->flags & 4) != 0;
  tcom->flags &= -5;
  function_value = 0;
  if (return_catch_flag) {
    {
    function_value = __sigsetjmp(return_catch, 1);
    }
  }
  if (function_value) {
    return_code = return_catch_value;
  } else {
    {
    return_code = execute_command_internal(tcom, asynchronous, -1, -1, fds_to_close);
    }
  }
  if (invert) {
    if (return_code == 0) {
      return_code = 1;
    } else {
      return_code = 0;
    }
  }
  if (user_subshell) {
    {
    tmp___4 = signal_is_trapped(0);
    }
    if (tmp___4) {
      {
      last_command_exit_value = return_code;
      return_code = run_exit_trap();
      }
    }
  }
  return (return_code);
}
}
static int execute_pipeline(COMMAND *command , int asynchronous , int pipe_in , int pipe_out ,
                            struct fd_bitmap *fds_to_close ) 
{ 
  int prev ;
  int fildes[2] ;
  int new_bitmap_size ;
  int dummyfd ;
  int ignore_return ;
  int exec_result ;
  COMMAND *cmd ;
  struct fd_bitmap *fd_bitmap ;
  sigset_t set ;
  sigset_t oset ;
  int tmp ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  ignore_return = (command->flags & 8) != 0;
  prev = pipe_in;
  cmd = command;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (cmd) {
      if ((unsigned int )cmd->type == 6U) {
        if (cmd->value.Connection) {
          if (! ((cmd->value.Connection)->connector == 124)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = pipe(fildes);
    }
    if (tmp < 0) {
      {
      sys_error("pipe error");
      terminate_current_pipeline();
      kill_current_pipeline();
      last_command_exit_value = 1;
      throw_to_top_level();
      }
      return (1);
    }
    if ((long )fildes[0] < fds_to_close->size) {
      new_bitmap_size = (int )fds_to_close->size;
    } else {
      new_bitmap_size = fildes[0] + 8;
    }
    {
    fd_bitmap = new_fd_bitmap((long )new_bitmap_size);
    xbcopy(fds_to_close->bitmap, fd_bitmap->bitmap, (int )fds_to_close->size);
    *(fd_bitmap->bitmap + fildes[0]) = (char)1;
    begin_unwind_frame((char *)"pipe-file-descriptors");
    add_unwind_protect((Function *)(& dispose_fd_bitmap), (char *)fd_bitmap);
    add_unwind_protect((Function *)(& close_fd_bitmap), (char *)fd_bitmap);
    }
    if (prev >= 0) {
      {
      add_unwind_protect((Function *)(& close), (char *)prev);
      }
    }
    {
    dummyfd = fildes[1];
    add_unwind_protect((Function *)(& close), (char *)dummyfd);
    }
    if (ignore_return) {
      if ((cmd->value.Connection)->first) {
        ((cmd->value.Connection)->first)->flags |= 8;
      }
    }
    {
    execute_command_internal((cmd->value.Connection)->first, asynchronous, prev, fildes[1],
                             fd_bitmap);
    }
    if (prev >= 0) {
      {
      close(prev);
      }
    }
    {
    prev = fildes[0];
    close(fildes[1]);
    dispose_fd_bitmap(fd_bitmap);
    discard_unwind_frame((char *)"pipe-file-descriptors");
    cmd = (cmd->value.Connection)->second;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (ignore_return) {
    if (cmd) {
      cmd->flags |= 8;
    }
  }
  {
  exec_result = execute_command_internal(cmd, asynchronous, prev, pipe_out, fds_to_close);
  }
  if (prev >= 0) {
    {
    close(prev);
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (exec_result);
}
}
static int execute_connection(COMMAND *command , int asynchronous , int pipe_in ,
                              int pipe_out , struct fd_bitmap *fds_to_close ) 
{ 
  REDIRECT *rp ;
  COMMAND *tc ;
  COMMAND *second ;
  int ignore_return ;
  int exec_result ;

  {
  ignore_return = (command->flags & 8) != 0;
  {
  if ((command->value.Connection)->connector == 38) {
    goto case_38;
  }
  if ((command->value.Connection)->connector == 59) {
    goto case_59;
  }
  if ((command->value.Connection)->connector == 124) {
    goto case_124;
  }
  if ((command->value.Connection)->connector == 284) {
    goto case_284;
  }
  if ((command->value.Connection)->connector == 285) {
    goto case_284;
  }
  goto switch_default;
  case_38: /* CIL Label */ 
  tc = (command->value.Connection)->first;
  if ((unsigned long )tc == (unsigned long )((COMMAND *)0)) {
    return (0);
  }
  rp = tc->redirects;
  if (ignore_return) {
    tc->flags |= 8;
  }
  tc->flags |= 512;
  if (! interactive_shell) {
    goto _L;
  } else { //Added block
  if (subshell_environment) {
    goto _L;
  } else { //Added block
  if (! job_control) {
    _L: 
    if (! stdin_redir) {
      tc->flags |= 1024;
    }
  }
  }
  }
  {
  exec_result = execute_command_internal(tc, 1, pipe_in, pipe_out, fds_to_close);
  }
  if (tc->flags & 1024) {
    tc->flags &= -1025;
  }
  second = (command->value.Connection)->second;
  if (second) {
    if (ignore_return) {
      second->flags |= 8;
    }
    {
    exec_result = execute_command_internal(second, asynchronous, pipe_in, pipe_out,
                                           fds_to_close);
    }
  }
  goto switch_break;
  case_59: /* CIL Label */ 
  if (ignore_return) {
    if ((command->value.Connection)->first) {
      ((command->value.Connection)->first)->flags |= 8;
    }
    if ((command->value.Connection)->second) {
      ((command->value.Connection)->second)->flags |= 8;
    }
  }
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  {
  execute_command((command->value.Connection)->first);
  }
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  {
  exec_result = execute_command_internal((command->value.Connection)->second, asynchronous,
                                         pipe_in, pipe_out, fds_to_close);
  }
  goto switch_break;
  case_124: /* CIL Label */ 
  {
  exec_result = execute_pipeline(command, asynchronous, pipe_in, pipe_out, fds_to_close);
  }
  goto switch_break;
  case_284: /* CIL Label */ 
  case_285: /* CIL Label */ 
  if (asynchronous) {
    {
    command->flags |= 2;
    exec_result = execute_command_internal(command, 1, pipe_in, pipe_out, fds_to_close);
    }
    goto switch_break;
  }
  if ((command->value.Connection)->first) {
    ((command->value.Connection)->first)->flags |= 8;
  }
  {
  exec_result = execute_command((command->value.Connection)->first);
  }
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  if ((command->value.Connection)->connector == 284) {
    if (exec_result == 0) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if ((command->value.Connection)->connector == 285) {
    if (exec_result != 0) {
      _L___0: 
      if (ignore_return) {
        if ((command->value.Connection)->second) {
          ((command->value.Connection)->second)->flags |= 8;
        }
      }
      {
      exec_result = execute_command((command->value.Connection)->second);
      }
    }
  }
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  command_error("execute_connection", 2, (command->value.Connection)->connector, 0);
  jump_to_top_level(2);
  exec_result = 1;
  }
  switch_break: /* CIL Label */ ;
  }
  return (exec_result);
}
}
static int execute_for_command(FOR_COM *for_command ) 
{ 
  register WORD_LIST *releaser ;
  register WORD_LIST *list___0 ;
  SHELL_VAR *v___0 ;
  char *identifier ;
  int retval ;
  int tmp ;

  {
  {
  tmp = check_identifier(for_command->name, 1);
  }
  if (tmp == 0) {
    if (posixly_correct) {
      if (interactive_shell == 0) {
        {
        last_command_exit_value = 258;
        jump_to_top_level(3);
        }
      }
    }
    return (1);
  }
  {
  loop_level ++;
  identifier = (for_command->name)->word;
  releaser = expand_words_no_vars(for_command->map_list);
  list___0 = releaser;
  begin_unwind_frame((char *)"for");
  add_unwind_protect((Function *)(& dispose_words), (char *)releaser);
  }
  if (for_command->flags & 8) {
    (for_command->action)->flags |= 8;
  }
  retval = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    {
    this_command_name = (char *)((void *)0);
    v___0 = bind_variable(identifier, (list___0->word)->word);
    }
    if (v___0->attributes & 2) {
      goto _L;
    } else { //Added block
    if (v___0->attributes & 2048) {
      _L: 
      if (v___0->attributes & 2) {
        if (interactive_shell == 0) {
          if (posixly_correct) {
            {
            last_command_exit_value = 1;
            jump_to_top_level(1);
            }
          } else {
            {
            run_unwind_frame((char *)"for");
            loop_level --;
            }
            return (1);
          }
        } else {
          {
          run_unwind_frame((char *)"for");
          loop_level --;
          }
          return (1);
        }
      } else {
        {
        run_unwind_frame((char *)"for");
        loop_level --;
        }
        return (1);
      }
    }
    }
    {
    retval = execute_command(for_command->action);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! interactive_shell) {
        {
        reap_dead_jobs();
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if (breaking) {
      breaking --;
      goto while_break;
    }
    if (continuing) {
      continuing --;
      if (continuing) {
        goto while_break;
      }
    }
    list___0 = list___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  loop_level --;
  dispose_words(releaser);
  discard_unwind_frame((char *)"for");
  }
  return (retval);
}
}
static long eval_arith_for_expr(WORD_LIST *l , int *okp ) 
{ 
  WORD_LIST *new ;
  long expresult ;

  {
  {
  new = expand_words_no_vars(l);
  }
  if (echo_command_at_execute) {
    {
    xtrace_print_arith_cmd(new);
    }
  }
  {
  expresult = evalexp((new->word)->word, okp);
  dispose_words(new);
  }
  return (expresult);
}
}
static int execute_arith_for_command(ARITH_FOR_COM *arith_for_command ) 
{ 
  long expresult ;
  int expok ;
  int body_status ;

  {
  body_status = 0;
  loop_level ++;
  if (arith_for_command->flags & 8) {
    (arith_for_command->action)->flags |= 8;
  }
  this_command_name = (char *)"((";
  if (variable_context) {
    line_number = arith_for_command->line - function_line_number;
  }
  {
  expresult = eval_arith_for_expr(arith_for_command->init, & expok);
  }
  if (expok == 0) {
    return (1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    expresult = eval_arith_for_expr(arith_for_command->test, & expok);
    }
    if (expok == 0) {
      body_status = 1;
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! interactive_shell) {
        {
        reap_dead_jobs();
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (expresult == 0L) {
      goto while_break;
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    {
    body_status = execute_command(arith_for_command->action);
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if (breaking) {
      breaking --;
      goto while_break;
    }
    if (continuing) {
      continuing --;
      if (continuing) {
        goto while_break;
      }
    }
    {
    expresult = eval_arith_for_expr(arith_for_command->step, & expok);
    }
    if (expok == 0) {
      body_status = 1;
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  loop_level --;
  return (body_status);
}
}
static int LINES  ;
static int COLS  ;
static int tabsize  ;
static int print_index_and_element(int len___0 , int ind___1 , WORD_LIST *list___0 ) 
{ 
  register WORD_LIST *l ;
  register int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
    return (0);
  }
  i = ind___1;
  l = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (l) {
      i --;
      if (! i) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%*d%s%s", len___0,
          ind___1, ") ", (l->word)->word);
  }
  if ((l->word)->word) {
    if (*((l->word)->word + 0)) {
      if (*((l->word)->word + 1)) {
        if (*((l->word)->word + 2)) {
          {
          tmp = strlen((char const   *)(l->word)->word);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      tmp___2 = tmp___1;
    } else {
      tmp___2 = (size_t )0;
    }
  } else {
    tmp___2 = (size_t )0;
  }
  return ((int )tmp___2);
}
}
static void indent___0(int from , int to ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (from < to)) {
      goto while_break;
    }
    if (to / tabsize > from / tabsize) {
      {
      _IO_putc('\t', stderr);
      from += tabsize - from % tabsize;
      }
    } else {
      {
      _IO_putc(' ', stderr);
      from ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void print_select_list(WORD_LIST *list___0 , int list_len , int max_elem_len ,
                              int indices_len ) 
{ 
  int ind___1 ;
  int row ;
  int elem_len ;
  int pos___0 ;
  int cols ;
  int rows ;
  int first_column_indices_len ;
  int other_indices_len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
    {
    _IO_putc('\n', stderr);
    }
    return;
  }
  if (max_elem_len) {
    cols = COLS / max_elem_len;
  } else {
    cols = 1;
  }
  if (cols == 0) {
    cols = 1;
  }
  if (list_len) {
    rows = list_len / cols + (list_len % cols != 0);
  } else {
    rows = 1;
  }
  if (list_len) {
    cols = list_len / rows + (list_len % rows != 0);
  } else {
    cols = 1;
  }
  if (rows == 1) {
    rows = cols;
    cols = 1;
  }
  if (rows < 10) {
    first_column_indices_len = 1;
  } else {
    if (rows < 100) {
      tmp___2 = 2;
    } else {
      if (rows < 1000) {
        tmp___1 = 3;
      } else {
        if (rows < 10000) {
          tmp___0 = 4;
        } else {
          if (rows < 100000) {
            tmp = 5;
          } else {
            tmp = 6;
          }
          tmp___0 = tmp;
        }
        tmp___1 = tmp___0;
      }
      tmp___2 = tmp___1;
    }
    first_column_indices_len = tmp___2;
  }
  other_indices_len = indices_len;
  row = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (row < rows)) {
      goto while_break;
    }
    ind___1 = row;
    pos___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (pos___0 == 0) {
        indices_len = first_column_indices_len;
      } else {
        indices_len = other_indices_len;
      }
      {
      elem_len = print_index_and_element(indices_len, ind___1 + 1, list___0);
      elem_len += indices_len + 2;
      ind___1 += rows;
      }
      if (ind___1 >= list_len) {
        goto while_break___0;
      }
      {
      indent___0(pos___0 + elem_len, pos___0 + max_elem_len);
      pos___0 += max_elem_len;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    _IO_putc('\n', stderr);
    row ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char *select_query(WORD_LIST *list___0 , int list_len , char *prompt ) 
{ 
  int max_elem_len ;
  int indices_len ;
  int len___0 ;
  long reply ;
  WORD_LIST *l ;
  char *repl_string ;
  char *t ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
  t = get_string_value("LINES");
  }
  if (t) {
    if (*t) {
      {
      tmp = atoi((char const   *)t);
      LINES = tmp;
      }
    } else {
      LINES = 24;
    }
  } else {
    LINES = 24;
  }
  {
  t = get_string_value("COLUMNS");
  }
  if (t) {
    if (*t) {
      {
      tmp___0 = atoi((char const   *)t);
      COLS = tmp___0;
      }
    } else {
      COLS = 80;
    }
  } else {
    COLS = 80;
  }
  tabsize = 8;
  max_elem_len = 0;
  l = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! l) {
      goto while_break;
    }
    if ((l->word)->word) {
      if (*((l->word)->word + 0)) {
        if (*((l->word)->word + 1)) {
          if (*((l->word)->word + 2)) {
            {
            tmp___1 = strlen((char const   *)(l->word)->word);
            tmp___2 = tmp___1;
            }
          } else {
            tmp___2 = (size_t )2;
          }
          tmp___3 = tmp___2;
        } else {
          tmp___3 = (size_t )1;
        }
        len___0 = (int )tmp___3;
      } else {
        len___0 = 0;
      }
    } else {
      len___0 = 0;
    }
    if (len___0 > max_elem_len) {
      max_elem_len = len___0;
    }
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  if (list_len < 10) {
    indices_len = 1;
  } else {
    if (list_len < 100) {
      tmp___7 = 2;
    } else {
      if (list_len < 1000) {
        tmp___6 = 3;
      } else {
        if (list_len < 10000) {
          tmp___5 = 4;
        } else {
          if (list_len < 100000) {
            tmp___4 = 5;
          } else {
            tmp___4 = 6;
          }
          tmp___5 = tmp___4;
        }
        tmp___6 = tmp___5;
      }
      tmp___7 = tmp___6;
    }
    indices_len = tmp___7;
  }
  max_elem_len += (indices_len + 2) + 2;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    print_select_list(list___0, list_len, max_elem_len, indices_len);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", prompt);
    fflush(stderr);
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    {
    tmp___8 = read_builtin((WORD_LIST *)((void *)0));
    }
    if (tmp___8 == 1) {
      {
      putchar('\n');
      }
      return ((char *)((void *)0));
    }
    {
    repl_string = get_string_value("REPLY");
    }
    if ((int )*repl_string == 0) {
      goto while_continue___0;
    }
    {
    tmp___9 = legal_number(repl_string, & reply);
    }
    if (tmp___9 == 0) {
      return ((char *)"");
    }
    if (reply < 1L) {
      return ((char *)"");
    } else { //Added block
    if (reply > (long )list_len) {
      return ((char *)"");
    }
    }
    l = list___0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (l) {
        reply --;
        if (! reply) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      l = l->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    return ((l->word)->word);
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
static int execute_select_command(SELECT_COM *select_command ) 
{ 
  WORD_LIST *releaser ;
  WORD_LIST *list___0 ;
  SHELL_VAR *v___0 ;
  char *identifier ;
  char *ps3_prompt ;
  char *selection ;
  int retval ;
  int list_len ;
  int return_val ;
  int tmp ;
  UWP u ;

  {
  {
  tmp = check_identifier(select_command->name, 1);
  }
  if (tmp == 0) {
    return (1);
  }
  {
  loop_level ++;
  identifier = (select_command->name)->word;
  releaser = expand_words_no_vars(select_command->map_list);
  list___0 = releaser;
  list_len = list_length((GENERIC_LIST *)list___0);
  }
  if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
    goto _L;
  } else { //Added block
  if (list_len == 0) {
    _L: 
    if (list___0) {
      {
      dispose_words(list___0);
      }
    }
    return (0);
  }
  }
  {
  begin_unwind_frame((char *)"select");
  add_unwind_protect((Function *)(& dispose_words), (char *)releaser);
  }
  if (select_command->flags & 8) {
    (select_command->action)->flags |= 8;
  }
  retval = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    u.i = return_catch_flag;
    unwind_protect_var(& return_catch_flag, u.s, (int )sizeof(int ));
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  unwind_protect_var((int *)(return_catch), (char *)(return_catch), (int )sizeof(sigjmp_buf ));
  return_catch_flag ++;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    ps3_prompt = get_string_value("PS3");
    }
    if ((unsigned long )ps3_prompt == (unsigned long )((char *)0)) {
      ps3_prompt = (char *)"#? ";
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    {
    selection = select_query(list___0, list_len, ps3_prompt);
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if ((unsigned long )selection == (unsigned long )((char *)0)) {
      goto while_break___0;
    }
    {
    v___0 = bind_variable(identifier, selection);
    }
    if (v___0->attributes & 2) {
      goto _L___0;
    } else { //Added block
    if (v___0->attributes & 2048) {
      _L___0: 
      if (v___0->attributes & 2) {
        if (interactive_shell == 0) {
          if (posixly_correct) {
            {
            last_command_exit_value = 1;
            jump_to_top_level(1);
            }
          } else {
            {
            run_unwind_frame((char *)"select");
            }
            return (1);
          }
        } else {
          {
          run_unwind_frame((char *)"select");
          }
          return (1);
        }
      } else {
        {
        run_unwind_frame((char *)"select");
        }
        return (1);
      }
    }
    }
    {
    return_val = __sigsetjmp(return_catch, 1);
    }
    if (return_val) {
      retval = return_catch_value;
      goto while_break___0;
    } else {
      {
      retval = execute_command(select_command->action);
      }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! interactive_shell) {
        {
        reap_dead_jobs();
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if (breaking) {
      breaking --;
      goto while_break___0;
    }
    if (continuing) {
      continuing --;
      if (continuing) {
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  loop_level --;
  run_unwind_frame((char *)"select");
  }
  return (retval);
}
}
static int execute_case_command(CASE_COM *case_command ) 
{ 
  register WORD_LIST *list___0 ;
  WORD_LIST *wlist ;
  WORD_LIST *es ;
  PATTERN_LIST *clauses ;
  char *word ;
  char *pattern ;
  int retval ;
  int match ;
  int ignore_return ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  tmp = strchr((char const   *)(case_command->word)->word, '~');
  }
  if ((unsigned long )tmp != (unsigned long )((char *)((void *)0))) {
    {
    word = bash_tilde_expand((case_command->word)->word);
    free((void *)(case_command->word)->word);
    (case_command->word)->word = word;
    }
  }
  {
  wlist = expand_word_unsplit(case_command->word, 0);
  }
  if (wlist) {
    {
    tmp___0 = string_list(wlist);
    word = tmp___0;
    }
  } else {
    {
    tmp___1 = strlen("");
    tmp___2 = xmalloc(1UL + tmp___1);
    tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )"");
    word = tmp___3;
    }
  }
  {
  dispose_words(wlist);
  retval = 0;
  ignore_return = case_command->flags & 8;
  begin_unwind_frame((char *)"case");
  add_unwind_protect((Function *)(& xfree), word);
  clauses = case_command->clauses;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! clauses) {
      goto while_break;
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    list___0 = clauses->patterns;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! list___0) {
        goto while_break___0;
      }
      {
      tmp___4 = strchr((char const   *)(list___0->word)->word, '~');
      }
      if ((unsigned long )tmp___4 != (unsigned long )((char *)((void *)0))) {
        {
        pattern = bash_tilde_expand((list___0->word)->word);
        free((void *)(list___0->word)->word);
        (list___0->word)->word = pattern;
        }
      }
      {
      es = expand_word_leave_quoted(list___0->word, 0);
      }
      if (es) {
        if (es->word) {
          if ((es->word)->word) {
            if (*((es->word)->word)) {
              {
              pattern = quote_string_for_globbing((char const   *)(es->word)->word,
                                                  1);
              }
            } else {
              {
              pattern = xmalloc((size_t )1);
              *(pattern + 0) = (char )'\000';
              }
            }
          } else {
            {
            pattern = xmalloc((size_t )1);
            *(pattern + 0) = (char )'\000';
            }
          }
        } else {
          {
          pattern = xmalloc((size_t )1);
          *(pattern + 0) = (char )'\000';
          }
        }
      } else {
        {
        pattern = xmalloc((size_t )1);
        *(pattern + 0) = (char )'\000';
        }
      }
      if (extended_glob) {
        tmp___5 = 1 << 5;
      } else {
        tmp___5 = 0;
      }
      {
      tmp___6 = fnmatch(pattern, word, tmp___5);
      match = tmp___6 != 1;
      free((void *)pattern);
      dispose_words(es);
      }
      if (match) {
        if (clauses->action) {
          if (ignore_return) {
            (clauses->action)->flags |= 8;
          }
        }
        {
        retval = execute_command(clauses->action);
        }
        goto exit_case_command;
      }
      if (interrupt_state) {
        {
        throw_to_top_level();
        }
      }
      list___0 = list___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    clauses = clauses->next;
  }
  while_break: /* CIL Label */ ;
  }
  exit_case_command: 
  {
  free((void *)word);
  discard_unwind_frame((char *)"case");
  }
  return (retval);
}
}
static int execute_while_command(WHILE_COM *while_command ) 
{ 
  int tmp ;

  {
  {
  tmp = execute_while_or_until(while_command, 0);
  }
  return (tmp);
}
}
static int execute_until_command(WHILE_COM *while_command ) 
{ 
  int tmp ;

  {
  {
  tmp = execute_while_or_until(while_command, 1);
  }
  return (tmp);
}
}
static int execute_while_or_until(WHILE_COM *while_command , int type ) 
{ 
  int return_value ;
  int body_status ;

  {
  body_status = 0;
  loop_level ++;
  (while_command->test)->flags |= 8;
  if (while_command->flags & 8) {
    (while_command->action)->flags |= 8;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    return_value = execute_command(while_command->test);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! interactive_shell) {
        {
        reap_dead_jobs();
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (type == 0) {
      if (return_value != 0) {
        goto while_break;
      }
    }
    if (type == 1) {
      if (return_value == 0) {
        goto while_break;
      }
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    {
    body_status = execute_command(while_command->action);
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if (breaking) {
      breaking --;
      goto while_break;
    }
    if (continuing) {
      continuing --;
      if (continuing) {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  loop_level --;
  return (body_status);
}
}
static int execute_if_command(IF_COM *if_command ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
  {
  (if_command->test)->flags |= 8;
  return_value = execute_command(if_command->test);
  }
  if (return_value == 0) {
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if (if_command->true_case) {
      if (if_command->flags & 8) {
        (if_command->true_case)->flags |= 8;
      }
    }
    {
    tmp = execute_command(if_command->true_case);
    }
    return (tmp);
  } else {
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    if (if_command->false_case) {
      if (if_command->flags & 8) {
        (if_command->false_case)->flags |= 8;
      }
    }
    {
    tmp___0 = execute_command(if_command->false_case);
    }
    return (tmp___0);
  }
}
}
static int execute_arith_command(ARITH_COM *arith_command ) 
{ 
  int result ;
  int expok ;
  WORD_LIST *new ;
  long tmp ;
  int tmp___0 ;

  {
  result = 0;
  this_command_name = (char *)"((";
  if (variable_context) {
    line_number = arith_command->line - function_line_number;
  }
  {
  new = expand_words(arith_command->exp);
  }
  if (echo_command_at_execute) {
    {
    xtrace_print_arith_cmd(new);
    }
  }
  {
  tmp = evalexp((new->word)->word, & expok);
  result = (int )tmp;
  dispose_words(new);
  }
  if (expok == 0) {
    return (1);
  }
  if (result == 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static char *nullstr  =    (char *)"";
static int execute_cond_node(COND_COM *cond ) 
{ 
  int result ;
  int invert ;
  int patmatch ;
  char *arg1 ;
  char *arg2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  invert = cond->flags & 4;
  if (cond->type == 6) {
    {
    result = execute_cond_node(cond->left);
    }
  } else { //Added block
  if (cond->type == 2) {
    {
    result = execute_cond_node(cond->left);
    }
    if (result != 0) {
      {
      result = execute_cond_node(cond->right);
      }
    }
  } else { //Added block
  if (cond->type == 1) {
    {
    result = execute_cond_node(cond->left);
    }
    if (result == 0) {
      {
      result = execute_cond_node(cond->right);
      }
    }
  } else { //Added block
  if (cond->type == 3) {
    {
    arg1 = cond_expand_word((cond->left)->op, 0);
    }
    if ((unsigned long )arg1 == (unsigned long )((char *)0)) {
      arg1 = nullstr;
    }
    if (echo_command_at_execute) {
      {
      xtrace_print_cond_term(cond->type, invert, cond->op, arg1, (char *)((void *)0));
      }
    }
    {
    tmp___0 = unary_test((cond->op)->word, arg1);
    }
    if (tmp___0) {
      result = 0;
    } else {
      result = 1;
    }
    if ((unsigned long )arg1 != (unsigned long )nullstr) {
      {
      free((void *)arg1);
      }
    }
  } else { //Added block
  if (cond->type == 4) {
    if ((int )*((cond->op)->word + 1) == 61) {
      if ((int )*((cond->op)->word + 2) == 0) {
        if ((int )*((cond->op)->word + 0) == 33) {
          tmp___1 = 1;
        } else { //Added block
        if ((int )*((cond->op)->word + 0) == 61) {
          tmp___1 = 1;
        } else {
          goto _L___0;
        }
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((int )*((cond->op)->word + 0) == 61) {
      if ((int )*((cond->op)->word + 1) == 0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    }
    {
    patmatch = tmp___1;
    arg1 = cond_expand_word((cond->left)->op, 0);
    }
    if ((unsigned long )arg1 == (unsigned long )((char *)0)) {
      arg1 = nullstr;
    }
    {
    arg2 = cond_expand_word((cond->right)->op, patmatch);
    }
    if ((unsigned long )arg2 == (unsigned long )((char *)0)) {
      arg2 = nullstr;
    }
    if (echo_command_at_execute) {
      {
      xtrace_print_cond_term(cond->type, invert, cond->op, arg1, arg2);
      }
    }
    {
    tmp___3 = binary_test((cond->op)->word, arg1, arg2, 3);
    }
    if (tmp___3) {
      result = 0;
    } else {
      result = 1;
    }
    if ((unsigned long )arg1 != (unsigned long )nullstr) {
      {
      free((void *)arg1);
      }
    }
    if ((unsigned long )arg2 != (unsigned long )nullstr) {
      {
      free((void *)arg2);
      }
    }
  } else {
    {
    command_error("execute_cond_node", 1, cond->type, 0);
    jump_to_top_level(2);
    result = 1;
    }
  }
  }
  }
  }
  }
  if (invert) {
    if (result == 0) {
      result = 1;
    } else {
      result = 0;
    }
  }
  return (result);
}
}
static int execute_cond_command(COND_COM *cond_command ) 
{ 
  int result ;

  {
  result = 0;
  this_command_name = (char *)"[[";
  if (variable_context) {
    line_number = cond_command->line - function_line_number;
  }
  {
  result = execute_cond_node(cond_command);
  last_command_exit_value = result;
  }
  return (result);
}
}
static void bind_lastarg(char *arg ) 
{ 
  SHELL_VAR *var ;

  {
  if ((unsigned long )arg == (unsigned long )((char *)0)) {
    arg = (char *)"";
  }
  {
  var = bind_variable((char *)"_", arg);
  var->attributes &= -2;
  }
  return;
}
}
static int execute_null_command(REDIRECT *redirects , int pipe_in , int pipe_out ,
                                int async , pid_t old_last_command_subst_pid ) 
{ 
  int tmp ;
  pid_t tmp___0 ;
  int tmp___1 ;

  {
  if (pipe_in != -1) {
    goto _L;
  } else { //Added block
  if (pipe_out != -1) {
    goto _L;
  } else { //Added block
  if (async) {
    _L: 
    {
    tmp___0 = make_child((char *)((void *)0), async);
    }
    if (tmp___0 == 0) {
      {
      restore_original_signals();
      do_piping(pipe_in, pipe_out);
      subshell_environment = 1;
      tmp = do_redirections(redirects, 1, 0, 0);
      }
      if (tmp == 0) {
        {
        exit(0);
        }
      } else {
        {
        exit(1);
        }
      }
    } else {
      {
      close_pipes(pipe_in, pipe_out);
      unlink_fifo_list();
      }
      return (0);
    }
  } else {
    {
    tmp___1 = do_redirections(redirects, 0, 0, 0);
    }
    if (tmp___1 != 0) {
      return (1);
    } else { //Added block
    if (old_last_command_subst_pid != last_command_subst_pid) {
      return (last_command_exit_value);
    } else {
      return (0);
    }
    }
  }
  }
  }
}
}
static void fix_assignment_words(WORD_LIST *words ) 
{ 
  WORD_LIST *w ;
  struct builtin *b ;

  {
  if ((unsigned long )words == (unsigned long )((WORD_LIST *)0)) {
    return;
  }
  {
  b = builtin_address_internal((words->word)->word, 0);
  }
  if ((unsigned long )b == (unsigned long )((struct builtin *)0)) {
    return;
  } else { //Added block
  if ((b->flags & 16) == 0) {
    return;
  }
  }
  w = words;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! w) {
      goto while_break;
    }
    if ((w->word)->flags & 4) {
      (w->word)->flags |= 48;
    }
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int execute_simple_command(SIMPLE_COM *simple_command , int pipe_in , int pipe_out ,
                                  int async , struct fd_bitmap *fds_to_close ) 
{ 
  WORD_LIST *words ;
  WORD_LIST *lastword ;
  char *command_line ;
  char *lastarg ;
  char *temp___0 ;
  int first_word_quoted ;
  int result ;
  int builtin_is_special ;
  int already_forked ;
  int dofork ;
  pid_t old_last_command_subst_pid ;
  pid_t old_last_async_pid ;
  Function *builtin ;
  SHELL_VAR *func ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  pid_t tmp___3 ;
  int tmp___4 ;
  char *word ;
  register int i ;
  int wl ;
  int cl ;
  int exact ;
  int substring___0 ;
  int match ;
  int started_status ;
  register PROCESS *p ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  result = 0;
  builtin_is_special = 0;
  special_builtin_failed = builtin_is_special;
  command_line = (char *)0;
  if (variable_context) {
    line_number = simple_command->line - function_line_number;
  }
  {
  command_string_index = 0;
  print_simple_command(simple_command);
  }
  if (simple_command->words) {
    first_word_quoted = ((simple_command->words)->word)->flags & 2;
  } else {
    first_word_quoted = 0;
  }
  old_last_command_subst_pid = last_command_subst_pid;
  old_last_async_pid = last_asynchronous_pid;
  dofork = 0;
  already_forked = dofork;
  if (pipe_in != -1) {
    tmp = 1;
  } else { //Added block
  if (pipe_out != -1) {
    tmp = 1;
  } else { //Added block
  if (async) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  dofork = tmp;
  if (dofork) {
    if (pipe_in == -1) {
      if (pipe_out == -1) {
        if (simple_command->words) {
          if ((simple_command->words)->word) {
            if (((simple_command->words)->word)->word) {
              if ((int )*(((simple_command->words)->word)->word + 0) == 37) {
                dofork = 0;
              }
            }
          }
        }
      }
    }
  }
  if (dofork) {
    {
    tmp___0 = strlen((char const   *)the_printed_command);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )the_printed_command);
    command_line = tmp___2;
    maybe_make_export_env();
    tmp___3 = make_child(command_line, async);
    }
    if (tmp___3 == 0) {
      already_forked = 1;
      simple_command->flags |= 64;
      if (pipe_in != -1) {
        subshell_environment = 24;
      } else { //Added block
      if (pipe_out != -1) {
        subshell_environment = 24;
      } else {
        subshell_environment = 9;
      }
      }
      if (fds_to_close) {
        {
        close_fd_bitmap(fds_to_close);
        }
      }
      {
      do_piping(pipe_in, pipe_out);
      pipe_out = -1;
      pipe_in = pipe_out;
      last_asynchronous_pid = old_last_async_pid;
      }
    } else {
      {
      close_pipes(pipe_in, pipe_out);
      unlink_fifo_list();
      command_line = (char *)((void *)0);
      bind_lastarg((char *)((void *)0));
      }
      return (result);
    }
  }
  if ((simple_command->flags & 32) == 0) {
    {
    current_fds_to_close = fds_to_close;
    fix_assignment_words(simple_command->words);
    words = expand_words(simple_command->words);
    current_fds_to_close = (struct fd_bitmap *)((void *)0);
    }
  } else {
    {
    words = copy_word_list(simple_command->words);
    }
  }
  if ((unsigned long )words == (unsigned long )((WORD_LIST *)0)) {
    if (already_forked) {
      tmp___4 = 0;
    } else {
      tmp___4 = async;
    }
    {
    result = execute_null_command(simple_command->redirects, pipe_in, pipe_out, tmp___4,
                                  old_last_command_subst_pid);
    }
    if (already_forked) {
      {
      exit(result);
      }
    } else {
      {
      bind_lastarg((char *)((void *)0));
      set_pipestatus_from_exit(result);
      }
      return (result);
    }
  }
  {
  lastarg = (char *)((void *)0);
  begin_unwind_frame((char *)"simple-command");
  }
  if (echo_command_at_execute) {
    {
    xtrace_print_word_list(words);
    }
  }
  builtin = (Function *)((void *)0);
  func = (SHELL_VAR *)((void *)0);
  if ((simple_command->flags & 16) == 0) {
    if (posixly_correct) {
      {
      builtin = find_special_builtin((words->word)->word);
      }
      if (builtin) {
        builtin_is_special = 1;
      }
    }
    if ((unsigned long )builtin == (unsigned long )((Function *)0)) {
      {
      func = find_function((words->word)->word);
      }
    }
  }
  {
  add_unwind_protect((Function *)(& dispose_words), (char *)words);
  }
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  lastword = words;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! lastword->next) {
      goto while_break;
    }
    lastword = lastword->next;
  }
  while_break: /* CIL Label */ ;
  }
  lastarg = (lastword->word)->word;
  if ((int )*((words->word)->word + 0) == 37) {
    if (already_forked == 0) {
      if (async) {
        this_command_name = (char *)"bg";
      } else {
        this_command_name = (char *)"fg";
      }
      {
      last_shell_builtin = this_shell_builtin;
      this_shell_builtin = builtin_address(this_command_name);
      result = (*this_shell_builtin)(words);
      }
      goto return_result;
    }
  }
  if (job_control) {
    if (already_forked == 0) {
      if (async == 0) {
        if (! first_word_quoted) {
          if (! words->next) {
            if (*((words->word)->word + 0)) {
              if (! simple_command->redirects) {
                if (pipe_in == -1) {
                  if (pipe_out == -1) {
                    {
                    temp___0 = get_string_value("auto_resume");
                    }
                    if (temp___0) {
                      word = (words->word)->word;
                      if ((int )*(temp___0 + 0) == (int )*("exact" + 0)) {
                        {
                        tmp___5 = strcmp((char const   *)temp___0, "exact");
                        }
                        if (tmp___5 == 0) {
                          tmp___6 = 1;
                        } else {
                          tmp___6 = 0;
                        }
                      } else {
                        tmp___6 = 0;
                      }
                      exact = tmp___6;
                      if ((int )*(temp___0 + 0) == (int )*("substring" + 0)) {
                        {
                        tmp___7 = strcmp((char const   *)temp___0, "substring");
                        }
                        if (tmp___7 == 0) {
                          tmp___8 = 1;
                        } else {
                          tmp___8 = 0;
                        }
                      } else {
                        tmp___8 = 0;
                      }
                      {
                      substring___0 = tmp___8;
                      tmp___9 = strlen((char const   *)word);
                      wl = (int )tmp___9;
                      i = job_slots - 1;
                      }
                      {
                      while (1) {
                        while_continue___0: /* CIL Label */ ;
                        if (! (i > -1)) {
                          goto while_break___0;
                        }
                        if ((unsigned long )*(jobs + i) == (unsigned long )((JOB *)0)) {
                          goto __Cont;
                        } else { //Added block
                        if ((unsigned int )(*(jobs + i))->state != 1U) {
                          goto __Cont;
                        }
                        }
                        p = (*(jobs + i))->pipe;
                        {
                        while (1) {
                          while_continue___1: /* CIL Label */ ;
                          if (exact) {
                            {
                            tmp___10 = strlen((char const   *)p->command);
                            cl = (int )tmp___10;
                            }
                            if (cl == 0) {
                              match = 1;
                            } else {
                              if ((int )*(p->command + 0) == (int )*(word + 0)) {
                                {
                                tmp___11 = strncmp((char const   *)p->command, (char const   *)word,
                                                   (size_t )cl);
                                }
                                if (tmp___11 == 0) {
                                  tmp___12 = 1;
                                } else {
                                  tmp___12 = 0;
                                }
                              } else {
                                tmp___12 = 0;
                              }
                              match = tmp___12;
                            }
                          } else { //Added block
                          if (substring___0) {
                            {
                            tmp___13 = strindex((char const   *)p->command, (char const   *)word);
                            match = (unsigned long )tmp___13 != (unsigned long )((char *)0);
                            }
                          } else { //Added block
                          if (wl == 0) {
                            match = 1;
                          } else {
                            if ((int )*(p->command + 0) == (int )*(word + 0)) {
                              {
                              tmp___14 = strncmp((char const   *)p->command, (char const   *)word,
                                                 (size_t )wl);
                              }
                              if (tmp___14 == 0) {
                                tmp___15 = 1;
                              } else {
                                tmp___15 = 0;
                              }
                            } else {
                              tmp___15 = 0;
                            }
                            match = tmp___15;
                          }
                          }
                          }
                          if (match == 0) {
                            p = p->next;
                            goto __Cont___0;
                          }
                          {
                          run_unwind_frame((char *)"simple-command");
                          this_command_name = (char *)"fg";
                          last_shell_builtin = this_shell_builtin;
                          this_shell_builtin = builtin_address((char *)"fg");
                          started_status = start_job(i, 1);
                          }
                          if (started_status < 0) {
                            tmp___16 = 1;
                          } else {
                            tmp___16 = started_status;
                          }
                          return (tmp___16);
                          __Cont___0: 
                          if (! ((unsigned long )p != (unsigned long )(*(jobs + i))->pipe)) {
                            goto while_break___1;
                          }
                        }
                        while_break___1: /* CIL Label */ ;
                        }
                        __Cont: 
                        i --;
                      }
                      while_break___0: /* CIL Label */ ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  this_command_name = (words->word)->word;
  if (interrupt_state) {
    {
    throw_to_top_level();
    }
  }
  if ((unsigned long )func == (unsigned long )((SHELL_VAR *)0)) {
    if ((unsigned long )builtin == (unsigned long )((Function *)0)) {
      {
      builtin = find_shell_builtin(this_command_name);
      }
    }
  }
  last_shell_builtin = this_shell_builtin;
  this_shell_builtin = builtin;
  if (builtin) {
    goto _L;
  } else { //Added block
  if (func) {
    _L: 
    if (already_forked) {
      {
      restore_original_signals();
      }
      if (async) {
        if (simple_command->flags & 1024) {
          if (pipe_in == -1) {
            {
            tmp___17 = stdin_redirects(simple_command->redirects);
            }
            if (tmp___17 == 0) {
              {
              async_redirect_stdin();
              }
            }
          }
        }
        {
        setup_async_signals();
        }
      }
      {
      execute_subshell_builtin_or_function(words, simple_command->redirects, builtin,
                                           func, pipe_in, pipe_out, async, fds_to_close,
                                           simple_command->flags);
      }
    } else {
      {
      result = execute_builtin_or_function(words, builtin, func, simple_command->redirects,
                                           fds_to_close, simple_command->flags);
      }
      if (builtin) {
        if (result > 256) {
          {
          result = builtin_status(result);
          }
          if (builtin_is_special) {
            special_builtin_failed = 1;
          }
        }
        if (posixly_correct) {
          if (builtin_is_special) {
            if (temporary_env) {
              {
              merge_temporary_env();
              }
            }
          }
        }
      } else { //Added block
      if (result == 258) {
        result = 2;
      } else { //Added block
      if (result > 256) {
        result = 1;
      }
      }
      }
      {
      set_pipestatus_from_exit(result);
      }
      goto return_result;
    }
  }
  }
  if ((unsigned long )command_line == (unsigned long )((char *)0)) {
    {
    tmp___18 = strlen((char const   *)the_printed_command);
    tmp___19 = xmalloc(1UL + tmp___18);
    tmp___20 = strcpy((char * __restrict  )tmp___19, (char const   * __restrict  )the_printed_command);
    command_line = tmp___20;
    }
  }
  {
  execute_disk_command(words, simple_command->redirects, command_line, pipe_in, pipe_out,
                       async, fds_to_close, simple_command->flags);
  }
  return_result: 
  {
  bind_lastarg(lastarg);
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (command_line) {
      {
      free((void *)command_line);
      }
    }
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  run_unwind_frame((char *)"simple-command");
  }
  return (result);
}
}
static int builtin_status(int result ) 
{ 
  int r ;

  {
  {
  if (result == 258) {
    goto case_258;
  }
  if (result == 259) {
    goto case_259;
  }
  if (result == 257) {
    goto case_259;
  }
  if (result == 260) {
    goto case_259;
  }
  if (result == 261) {
    goto case_259;
  }
  goto switch_default;
  case_258: /* CIL Label */ 
  r = 2;
  goto switch_break;
  case_259: /* CIL Label */ 
  case_257: /* CIL Label */ 
  case_260: /* CIL Label */ 
  case_261: /* CIL Label */ 
  r = 1;
  goto switch_break;
  switch_default: /* CIL Label */ 
  r = 0;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (r);
}
}
static int execute_builtin(Function *builtin , WORD_LIST *words , int flags , int subshell ) 
{ 
  int old_e_flag ;
  int result ;
  int eval_unwind ;
  UWP u ;

  {
  old_e_flag = exit_immediately_on_error;
  if (subshell == 0) {
    if ((unsigned long )builtin == (unsigned long )(& eval_builtin)) {
      if (flags & 8) {
        {
        begin_unwind_frame((char *)"eval_builtin");
        }
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          {
          u.i = exit_immediately_on_error;
          unwind_protect_var(& exit_immediately_on_error, u.s, (int )sizeof(int ));
          }
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        exit_immediately_on_error = 0;
        eval_unwind = 1;
      } else {
        eval_unwind = 0;
      }
    } else {
      eval_unwind = 0;
    }
  } else {
    eval_unwind = 0;
  }
  if ((unsigned long )builtin == (unsigned long )(& source_builtin)) {
    goto _L;
  } else { //Added block
  if ((unsigned long )builtin == (unsigned long )(& eval_builtin)) {
    _L: 
    if (subshell == 0) {
      {
      begin_unwind_frame((char *)"builtin_env");
      }
    }
    if (temporary_env) {
      {
      builtin_env = copy_array(temporary_env);
      }
      if (subshell == 0) {
        {
        add_unwind_protect((Function *)(& dispose_builtin_env), (char *)((void *)0));
        }
      }
      {
      dispose_used_env_vars();
      }
    }
  }
  }
  if (posixly_correct) {
    if (subshell == 0) {
      if ((unsigned long )builtin == (unsigned long )(& return_builtin)) {
        if (temporary_env) {
          {
          begin_unwind_frame((char *)"return_temp_env");
          add_unwind_protect((Function *)(& merge_temporary_env), (char *)((void *)0));
          }
        }
      }
    }
  }
  {
  result = (*builtin)(words->next);
  }
  if (posixly_correct) {
    if (subshell == 0) {
      if ((unsigned long )builtin == (unsigned long )(& return_builtin)) {
        if (temporary_env) {
          {
          discard_unwind_frame((char *)"return_temp_env");
          }
        }
      }
    }
  }
  if (subshell == 0) {
    if ((unsigned long )builtin == (unsigned long )(& source_builtin)) {
      goto _L___0;
    } else { //Added block
    if ((unsigned long )builtin == (unsigned long )(& eval_builtin)) {
      _L___0: 
      if (posixly_correct) {
        if (builtin_env) {
          {
          merge_builtin_env();
          }
        }
      }
      {
      run_unwind_frame((char *)"builtin_env");
      }
    }
    }
  }
  if (eval_unwind) {
    {
    exit_immediately_on_error += old_e_flag;
    discard_unwind_frame((char *)"eval_builtin");
    }
  }
  return (result);
}
}
static int execute_function(SHELL_VAR *var , WORD_LIST *words , int flags , struct fd_bitmap *fds_to_close ,
                            int async , int subshell ) 
{ 
  int return_val ;
  int result ;
  COMMAND *tc ;
  COMMAND *fc ;
  char *debug_trap ;
  COMMAND *tmp ;
  UWP u ;
  UWP u___0 ;
  char *tmp___0 ;
  UWP u___1 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
  tmp = copy_command((COMMAND *)var->value);
  tc = tmp;
  }
  if (tc) {
    if (flags & 8) {
      tc->flags |= 8;
    }
  }
  if (subshell == 0) {
    {
    begin_unwind_frame((char *)"function_calling");
    push_context();
    add_unwind_protect((Function *)(& pop_context), (char *)((void *)0));
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      u.i = line_number;
      unwind_protect_var(& line_number, u.s, (int )sizeof(int ));
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      u___0.i = return_catch_flag;
      unwind_protect_var(& return_catch_flag, u___0.s, (int )sizeof(int ));
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    unwind_protect_var((int *)(return_catch), (char *)(return_catch), (int )sizeof(sigjmp_buf ));
    add_unwind_protect((Function *)(& dispose_command), (char *)tc);
    }
    if (sizeof(char *) == sizeof(int )) {
      tmp___0 = (char *)this_shell_function;
    } else {
      tmp___0 = (char *)(& this_shell_function);
    }
    {
    unwind_protect_var((int *)(& this_shell_function), tmp___0, (int )sizeof(char *));
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      u___1.i = loop_level;
      unwind_protect_var(& loop_level, u___1.s, (int )sizeof(int ));
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  this_shell_function = var;
  make_funcname_visible(1);
  tmp___3 = signal_is_trapped(65);
  }
  if (tmp___3) {
    {
    tmp___4 = signal_is_ignored(65);
    }
    if (tmp___4 == 0) {
      debug_trap = trap_list[65];
    } else {
      debug_trap = (char *)((void *)0);
    }
  } else {
    debug_trap = (char *)((void *)0);
  }
  if (debug_trap) {
    if (subshell == 0) {
      {
      tmp___5 = strlen((char const   *)debug_trap);
      tmp___6 = xmalloc(1UL + tmp___5);
      tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )debug_trap);
      debug_trap = tmp___7;
      add_unwind_protect((Function *)(& xfree), debug_trap);
      add_unwind_protect((Function *)(& set_debug_trap), debug_trap);
      }
    }
    {
    restore_default_signal(65);
    }
  }
  if (temporary_env) {
    {
    function_env = copy_array(temporary_env);
    }
    if (subshell == 0) {
      if (posixly_correct) {
        {
        add_unwind_protect((Function *)(& merge_function_env), (char *)((void *)0));
        }
      } else {
        {
        add_unwind_protect((Function *)(& dispose_function_env), (char *)((void *)0));
        }
      }
    }
    {
    dispose_used_env_vars();
    }
  }
  {
  remember_args(words->next, 1);
  function_line_number = tc->line;
  line_number = function_line_number;
  }
  if (subshell) {
    {
    stop_pipeline(async, (COMMAND *)((void *)0));
    }
    if ((unsigned int )tc->type == 9U) {
      fc = (tc->value.Group)->command;
    } else {
      fc = tc;
    }
    if (fc) {
      if (flags & 8) {
        fc->flags |= 8;
      }
    }
    variable_context ++;
  } else {
    fc = tc;
  }
  {
  return_catch_flag ++;
  return_val = __sigsetjmp(return_catch, 1);
  }
  if (return_val) {
    result = return_catch_value;
  } else {
    {
    result = execute_command_internal(fc, 0, -1, -1, fds_to_close);
    }
  }
  if (subshell == 0) {
    {
    run_unwind_frame((char *)"function_calling");
    }
  }
  if (variable_context == 0) {
    {
    make_funcname_visible(0);
    }
  } else { //Added block
  if ((unsigned long )this_shell_function == (unsigned long )((SHELL_VAR *)0)) {
    {
    make_funcname_visible(0);
    }
  }
  }
  return (result);
}
}
int execute_shell_function(SHELL_VAR *var , WORD_LIST *words ) 
{ 
  int ret ;
  struct fd_bitmap *bitmap ;

  {
  {
  bitmap = new_fd_bitmap(32L);
  begin_unwind_frame((char *)"execute-shell-function");
  add_unwind_protect((Function *)(& dispose_fd_bitmap), (char *)bitmap);
  ret = execute_function(var, words, 0, bitmap, 0, 0);
  dispose_fd_bitmap(bitmap);
  discard_unwind_frame((char *)"execute-shell-function");
  }
  return (ret);
}
}
static void execute_subshell_builtin_or_function(WORD_LIST *words , REDIRECT *redirects ,
                                                 Function *builtin , SHELL_VAR *var ,
                                                 int pipe_in , int pipe_out , int async ,
                                                 struct fd_bitmap *fds_to_close ,
                                                 int flags ) 
{ 
  int result ;
  int r ;
  int jobs_hack ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )builtin == (unsigned long )(& jobs_builtin)) {
    if ((subshell_environment & 1) == 0) {
      tmp = 1;
    } else { //Added block
    if (pipe_out != -1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
  } else {
    tmp = 0;
  }
  {
  jobs_hack = tmp;
  interactive = 0;
  login_shell = interactive;
  subshell_environment = 1;
  maybe_make_export_env();
  }
  if (jobs_hack) {
    {
    kill_current_pipeline();
    }
  } else {
    {
    without_job_control();
    }
  }
  {
  set_sigchld_handler();
  set_sigint_handler();
  }
  if (fds_to_close) {
    {
    close_fd_bitmap(fds_to_close);
    }
  }
  {
  do_piping(pipe_in, pipe_out);
  tmp___0 = do_redirections(redirects, 1, 0, 0);
  }
  if (tmp___0 != 0) {
    {
    exit(1);
    }
  }
  if (builtin) {
    {
    result = __sigsetjmp(top_level, 1);
    }
    if (result == 3) {
      {
      exit(last_command_exit_value);
      }
    } else { //Added block
    if (result) {
      {
      exit(1);
      }
    } else {
      {
      r = execute_builtin(builtin, words, flags, 1);
      }
      if (r == 258) {
        r = 2;
      }
      {
      exit(r);
      }
    }
    }
  } else {
    {
    tmp___1 = execute_function(var, words, flags, fds_to_close, async, 1);
    exit(tmp___1);
    }
  }
}
}
static int execute_builtin_or_function(WORD_LIST *words , Function *builtin , SHELL_VAR *var ,
                                       REDIRECT *redirects , struct fd_bitmap *fds_to_close ,
                                       int flags ) 
{ 
  int result ;
  REDIRECT *saved_undo_list ;
  Function *saved_this_shell_builtin ;
  int tmp ;

  {
  {
  tmp = do_redirections(redirects, 1, 1, 0);
  }
  if (tmp != 0) {
    {
    cleanup_redirects(redirection_undo_list);
    redirection_undo_list = (REDIRECT *)((void *)0);
    dispose_exec_redirects();
    }
    return (259);
  }
  saved_this_shell_builtin = this_shell_builtin;
  saved_undo_list = redirection_undo_list;
  if ((unsigned long )builtin == (unsigned long )(& exec_builtin)) {
    {
    dispose_redirects(saved_undo_list);
    saved_undo_list = exec_redirection_undo_list;
    exec_redirection_undo_list = (REDIRECT *)((void *)0);
    }
  } else {
    {
    dispose_exec_redirects();
    }
  }
  if (saved_undo_list) {
    {
    begin_unwind_frame((char *)"saved redirects");
    add_unwind_protect((Function *)(& cleanup_redirects), (char *)saved_undo_list);
    }
  }
  redirection_undo_list = (REDIRECT *)((void *)0);
  if (builtin) {
    {
    result = execute_builtin(builtin, words, flags, 0);
    }
  } else {
    {
    result = execute_function(var, words, flags, fds_to_close, 0, 0);
    }
  }
  if ((unsigned long )builtin == (unsigned long )(& command_builtin)) {
    if ((unsigned long )this_shell_builtin == (unsigned long )(& exec_builtin)) {
      if (saved_undo_list) {
        {
        dispose_redirects(saved_undo_list);
        }
      }
      {
      redirection_undo_list = exec_redirection_undo_list;
      exec_redirection_undo_list = (REDIRECT *)((void *)0);
      saved_undo_list = exec_redirection_undo_list;
      discard_unwind_frame((char *)"saved_redirects");
      }
    }
  }
  if (saved_undo_list) {
    {
    redirection_undo_list = saved_undo_list;
    discard_unwind_frame((char *)"saved redirects");
    }
  }
  if (redirection_undo_list) {
    {
    cleanup_redirects(redirection_undo_list);
    redirection_undo_list = (REDIRECT *)((void *)0);
    }
  }
  return (result);
}
}
void setup_async_signals(void) 
{ 


  {
  if (job_control == 0) {
    {
    set_signal_handler(2, (SigHandler *)((void (*)(int  ))1));
    set_signal_ignored(2);
    set_signal_handler(3, (SigHandler *)((void (*)(int  ))1));
    set_signal_ignored(3);
    }
  }
  return;
}
}
static void execute_disk_command(WORD_LIST *words , REDIRECT *redirects , char *command_line ,
                                 int pipe_in , int pipe_out , int async , struct fd_bitmap *fds_to_close ,
                                 int cmdflags ) 
{ 
  char *pathname ;
  char *command ;
  char **args ;
  int nofork ;
  pid_t pid ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int old_interactive ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  nofork = cmdflags & 64;
  pathname = (words->word)->word;
  if (restricted) {
    {
    tmp = strchr((char const   *)pathname, '/');
    }
    if (tmp) {
      {
      internal_error("%s: restricted: cannot specify `/\' in command names", pathname);
      last_command_exit_value = 1;
      }
      return;
    }
  }
  {
  command = search_for_command(pathname);
  }
  if (command) {
    {
    maybe_make_export_env();
    put_command_name_into_env(command);
    }
  }
  if (nofork) {
    if (pipe_in == -1) {
      if (pipe_out == -1) {
        pid = 0;
      } else {
        {
        tmp___0 = strlen((char const   *)command_line);
        tmp___1 = xmalloc(1UL + tmp___0);
        tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )command_line);
        pid = make_child(tmp___2, async);
        }
      }
    } else {
      {
      tmp___0 = strlen((char const   *)command_line);
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )command_line);
      pid = make_child(tmp___2, async);
      }
    }
  } else {
    {
    tmp___0 = strlen((char const   *)command_line);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )command_line);
    pid = make_child(tmp___2, async);
    }
  }
  if (pid == 0) {
    {
    restore_original_signals();
    }
    if (async) {
      if (cmdflags & 1024) {
        if (pipe_in == -1) {
          {
          tmp___3 = stdin_redirects(redirects);
          }
          if (tmp___3 == 0) {
            {
            async_redirect_stdin();
            }
          }
        }
      }
      {
      setup_async_signals();
      }
    }
    if (fds_to_close) {
      {
      close_fd_bitmap(fds_to_close);
      }
    }
    {
    do_piping(pipe_in, pipe_out);
    }
    if (async) {
      old_interactive = interactive;
      interactive = 0;
    }
    subshell_environment = 8;
    if (redirects) {
      {
      tmp___4 = do_redirections(redirects, 1, 0, 0);
      }
      if (tmp___4 != 0) {
        {
        unlink_fifo_list();
        exit(1);
        }
      }
    }
    if (async) {
      interactive = old_interactive;
    }
    if ((unsigned long )command == (unsigned long )((char *)0)) {
      {
      internal_error("%s: command not found", pathname);
      exit(127);
      }
    }
    {
    args = word_list_to_argv(words, 0, 0, (int *)((void *)0));
    tmp___5 = shell_execve(command, args, export_env);
    exit(tmp___5);
    }
  } else {
    {
    close_pipes(pipe_in, pipe_out);
    unlink_fifo_list();
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (command) {
        {
        free((void *)command);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
static void initialize_subshell(void) 
{ 


  {
  {
  delete_all_aliases();
  history_lines_this_session = 0;
  without_job_control();
  set_sigchld_handler();
  reset_shell_flags();
  reset_shell_options();
  reset_shopt_options();
  builtin_env = (char **)0;
  clear_unwind_protect_list(0);
  return_catch_flag = 0;
  variable_context = return_catch_flag;
  }
  if (interactive_shell == 0) {
    {
    unset_bash_input(1);
    }
  }
  return;
}
}
int shell_execve(char *command , char **args , char **env ) 
{ 
  struct stat finfo ;
  int larray ;
  int i ;
  int fd ;
  unsigned char sample[80] ;
  int sample_len ;
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
  execve((char const   *)command, (char * const  *)args, (char * const  *)env);
  tmp = __errno_location();
  i = *tmp;
  }
  if (i != 8) {
    {
    tmp___3 = stat((char const   * __restrict  )command, (struct stat * __restrict  )(& finfo));
    }
    if (tmp___3 == 0) {
      if ((finfo.st_mode & 61440U) == 16384U) {
        {
        internal_error("%s: is a directory", command);
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        fd = open((char const   *)command, 0);
        }
        if (fd >= 0) {
          {
          tmp___0 = read(fd, (void *)((char *)(sample)), (size_t )80);
          sample_len = (int )tmp___0;
          close(fd);
          }
        } else {
          sample_len = -1;
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      if (sample_len > 2) {
        if ((int )sample[0] == 35) {
          if ((int )sample[1] == 33) {
            {
            tmp___1 = __errno_location();
            *tmp___1 = i;
            sys_error("%s: bad interpreter", command);
            }
            return (126);
          }
        }
      }
      {
      tmp___2 = __errno_location();
      *tmp___2 = i;
      file_error(command);
      }
    }
    if (i == 2) {
      tmp___4 = 127;
    } else {
      tmp___4 = 126;
    }
    return (tmp___4);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    fd = open((char const   *)command, 0);
    }
    if (fd >= 0) {
      {
      tmp___5 = read(fd, (void *)((char *)(sample)), (size_t )80);
      sample_len = (int )tmp___5;
      close(fd);
      }
    } else {
      sample_len = -1;
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (sample_len == 0) {
    return (0);
  }
  if (sample_len > 0) {
    {
    tmp___6 = check_binary_file(sample, sample_len);
    }
    if (tmp___6) {
      {
      internal_error("%s: cannot execute binary file", command);
      }
      return (126);
    }
  }
  {
  initialize_subshell();
  set_sigint_handler();
  tmp___7 = array_len(args);
  larray = tmp___7 + 1;
  tmp___8 = xrealloc((void *)((char *)args), (unsigned long )(1 + larray) * sizeof(char *));
  args = (char **)tmp___8;
  i = larray - 1;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! i) {
      goto while_break___1;
    }
    *(args + i) = *(args + (i - 1));
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  *(args + 0) = shell_name;
  *(args + 1) = command;
  *(args + larray) = (char *)((void *)0);
  if ((int )*(*(args + 0) + 0) == 45) {
    (*(args + 0)) ++;
  }
  if (restricted) {
    {
    change_flag('r', '+');
    }
  }
  if (subshell_argv) {
    i = 1;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (i < subshell_argc)) {
        goto while_break___2;
      }
      {
      free((void *)*(subshell_argv + i));
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    free((void *)subshell_argv);
    }
  }
  {
  dispose_command(currently_executing_command);
  currently_executing_command = (COMMAND *)((void *)0);
  subshell_argc = larray;
  subshell_argv = args;
  subshell_envp = env;
  unbind_args();
  siglongjmp(subshell_top_level, 1);
  }
}
}
static int execute_intern_function(WORD_DESC *name , COMMAND *function ) 
{ 
  SHELL_VAR *var ;
  int tmp ;

  {
  {
  tmp = check_identifier(name, posixly_correct);
  }
  if (tmp == 0) {
    if (posixly_correct) {
      if (interactive_shell == 0) {
        {
        last_command_exit_value = 258;
        jump_to_top_level(3);
        }
      }
    }
    return (1);
  }
  {
  var = find_function(name->word);
  }
  if (var) {
    if (var->attributes & 2) {
      goto _L;
    } else { //Added block
    if (var->attributes & 2048) {
      _L: 
      if (var->attributes & 2) {
        {
        internal_error("%s: readonly function", var->name);
        }
      }
      return (1);
    }
    }
  }
  {
  bind_function(name->word, function);
  }
  return (0);
}
}
static void close_pipes(int in , int out ) 
{ 


  {
  if (in >= 0) {
    {
    close(in);
    }
  }
  if (out >= 0) {
    {
    close(out);
    }
  }
  return;
}
}
static void do_piping(int pipe_in , int pipe_out ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (pipe_in != -1) {
    {
    tmp = dup2(pipe_in, 0);
    }
    if (tmp < 0) {
      {
      sys_error("cannot duplicate fd %d to fd 0", pipe_in);
      }
    }
    if (pipe_in > 0) {
      {
      close(pipe_in);
      }
    }
  }
  if (pipe_out != -1) {
    if (pipe_out != -2) {
      {
      tmp___0 = dup2(pipe_out, 1);
      }
      if (tmp___0 < 0) {
        {
        sys_error("cannot duplicate fd %d to fd 1", pipe_out);
        }
      }
      if (pipe_out == 0) {
        {
        close(pipe_out);
        }
      } else { //Added block
      if (pipe_out > 1) {
        {
        close(pipe_out);
        }
      }
      }
    } else {
      {
      tmp___1 = dup2(1, 2);
      }
      if (tmp___1 < 0) {
        {
        sys_error("cannot duplicate fd 1 to fd 2");
        }
      }
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-nrpP9uo_.i","-g")
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
void internal_warning(char const   *format  , ...) ;
char *array_reference(ARRAY *a , arrayind_t i ) ;
int array_add_element(ARRAY *a , arrayind_t i , char *v___0 ) ;
ARRAY_ELEMENT *array_delete_element(ARRAY *a , arrayind_t i ) ;
void destroy_array_element(ARRAY_ELEMENT *ae ) ;
ARRAY *new_array(void) ;
void empty_array(ARRAY *a ) ;
void dispose_array(ARRAY *a ) ;
ARRAY *word_list_to_array(WORD_LIST *list___0 ) ;
char *array_to_assignment_string(ARRAY *a ) ;
char *quoted_array_assignment_string(ARRAY *a ) ;
HASH_TABLE *make_hash_table(int buckets ) ;
BUCKET_CONTENTS *find_hash_item(char *string , HASH_TABLE *table ) ;
BUCKET_CONTENTS *remove_hash_item(char *string , HASH_TABLE *table ) ;
BUCKET_CONTENTS *add_hash_item(char *string , HASH_TABLE *table ) ;
void flush_hash_table(HASH_TABLE *table , VFunction *free_data ) ;
SHELL_VAR *set_if_not(char *name , char *value ) ;
void sh_set_lines_and_columns(int lines , int cols ) ;
void set_pwd(void) ;
void set_ppid(void) ;
SHELL_VAR *find_variable_internal(char *name , int search_tempenv ) ;
SHELL_VAR *find_tempenv_variable(char *name ) ;
SHELL_VAR *make_local_variable(char *name ) ;
SHELL_VAR **map_over(Function *function , HASH_TABLE *var_hash_table ) ;
SHELL_VAR **all_shell_variables(void) ;
SHELL_VAR **all_shell_functions(void) ;
SHELL_VAR **all_visible_variables(void) ;
SHELL_VAR **all_visible_functions(void) ;
SHELL_VAR **all_exported_variables(void) ;
SHELL_VAR **all_array_variables(void) ;
char **all_variables_matching_prefix(char *prefix ) ;
char **make_var_array(HASH_TABLE *hashed_vars ) ;
char **add_or_supercede_exported_var(char *assign , int do_alloc ) ;
char *make_variable_value(SHELL_VAR *var , char *value ) ;
SHELL_VAR *bind_variable_value(SHELL_VAR *var , char *value ) ;
SHELL_VAR *bind_int_variable(char *lhs , char *rhs ) ;
int variable_in_context(SHELL_VAR *var ) ;
int assign_in_env(char *string ) ;
int unbind_variable(char *name ) ;
void adjust_shell_level(int change ) ;
void dispose_variable(SHELL_VAR *var ) ;
void kill_all_local_variables(void) ;
void sort_variables(SHELL_VAR **array ) ;
void update_export_env_inplace(char *env_prefix , int preflen , char *value ) ;
void print_var_list(SHELL_VAR **list___0 ) ;
void print_func_list(SHELL_VAR **list___0 ) ;
void print_assignment(SHELL_VAR *var ) ;
void print_var_value(SHELL_VAR *var , int quote ) ;
void print_var_function(SHELL_VAR *var ) ;
SHELL_VAR *make_new_array_variable(char *name ) ;
SHELL_VAR *make_local_array_variable(char *name ) ;
SHELL_VAR *convert_var_to_array(SHELL_VAR *var ) ;
SHELL_VAR *bind_array_variable(char *name , int ind___1 , char *value ) ;
SHELL_VAR *assign_array_from_string(char *name , char *value ) ;
SHELL_VAR *assign_array_var_from_word_list(SHELL_VAR *var , WORD_LIST *list___0 ) ;
SHELL_VAR *assign_array_var_from_string(SHELL_VAR *var , char *value ) ;
int unbind_array_element(SHELL_VAR *var , char *sub ) ;
int skipsubscript(char *s , int i ) ;
void print_array_assignment(SHELL_VAR *var , int quoted ) ;
void set_pipestatus_array(int *ps ) ;
void stupidly_hack_special_variables(char *name ) ;
int get_random_number(void) ;
void sv_path(char *name ) ;
void sv_mail(char *name ) ;
void sv_ignoreeof(char *name ) ;
void sv_optind(char *name ) ;
void sv_opterr(char *name ) ;
void sv_globignore(char *name ) ;
void sv_locale(char *name ) ;
void sv_terminal(char *name ) ;
void sv_hostfile(char *name ) ;
void sv_tz(char *name ) ;
void sv_histsize(char *name ) ;
void sv_histignore(char *name ) ;
void sv_history_control(char *name ) ;
void sv_histchars(char *name ) ;
int array_expand_index(char *s , int len___0 ) ;
char *extract_array_assignment_list(char *string , int *sindex ) ;
int set_locale_var(char *var , char *value ) ;
int set_lang(char *var , char *value ) ;
extern char *sh_canonpath(char * , int  ) ;
extern void free_array_members(char ** ) ;
extern void free_array(char ** ) ;
extern char *ansic_quote(char * , int  , int * ) ;
WORD_LIST *rest_of_args ;
int mark_modified_vars ;
int no_invisible_vars ;
int file_status(char *name ) ;
char *find_user_command(char *name ) ;
void free_mail_files(void) ;
extern int sh_opterr ;
extern void builtin_error(char const   *  , ...) ;
extern void set_working_directory(char * ) ;
extern void set_dirstack_element(int  , int  , char * ) ;
extern WORD_LIST *get_directory_stack(void) ;
void posix_readline_initialize(int on_or_off ) ;
void clear_hostname_list(void) ;
extern int rl_reset_terminal(char const   * ) ;
int history_lines_in_file  ;
int history_control  ;
void setup_history_ignore(char *varname___0 ) ;
extern void stifle_history(int  ) ;
extern int unstifle_history(void) ;
extern int where_history(void) ;
extern int history_truncate_file(char const   * , int  ) ;
extern char history_expansion_char ;
extern char history_subst_char ;
extern char history_comment_char ;
ITEMLIST it_functions ;
void set_itemlist_dirty(ITEMLIST *it ) ;
int build_version ;
char *release_status ;
HASH_TABLE *shell_variables  =    (HASH_TABLE *)((void *)0);
HASH_TABLE *shell_functions  =    (HASH_TABLE *)((void *)0);
int variable_context  =    0;
char **temporary_env  =    (char **)((void *)0);
char **function_env  =    (char **)((void *)0);
char **builtin_env  =    (char **)((void *)0);
WORD_LIST *rest_of_args  =    (WORD_LIST *)((void *)0);
int dollar_dollar_pid  ;
char **export_env  =    (char **)((void *)0);
static int export_env_index  ;
static int export_env_size  ;
int array_needs_making  =    1;
int shell_level  =    0;
static char *have_local_variables  ;
static int local_variable_stack_size  ;
static void set_home_var(void) ;
static void set_shell_var(void) ;
static char *get_bash_name(void) ;
static void initialize_shell_level(void) ;
static void uidset(void) ;
static void initialize_dynamic_variables(void) ;
static void make_vers_array(void) ;
static void sbrand(int seed ) ;
static int qsort_var_comp(SHELL_VAR **var1 , SHELL_VAR **var2 ) ;
static SHELL_VAR *bind_tempenv_variable(char *name , char *value ) ;
extern int getopts_reset() ;
void initialize_shell_variables(char **env , int privmode ) 
{ 
  char *name ;
  char *string ;
  char *temp_string ;
  int c ;
  int char_index ;
  int string_index ;
  int string_length ;
  SHELL_VAR *temp_var ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  __pid_t tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;

  {
  if ((unsigned long )shell_variables == (unsigned long )((HASH_TABLE *)0)) {
    {
    shell_variables = make_hash_table(0);
    }
  }
  if ((unsigned long )shell_functions == (unsigned long )((HASH_TABLE *)0)) {
    {
    shell_functions = make_hash_table(0);
    }
  }
  string_index = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___6 = string_index;
    string_index ++;
    string = *(env + tmp___6);
    if (! string) {
      goto while_break;
    }
    char_index = 0;
    name = string;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      tmp = string;
      string ++;
      c = (int )*tmp;
      if (c) {
        if (! (c != 61)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((int )*(string + -1) == 61) {
      char_index = (int )((string - name) - 1L);
    }
    if (char_index == 0) {
      goto __Cont;
    }
    *(name + char_index) = (char )'\000';
    if (privmode == 0) {
      if (read_but_dont_execute == 0) {
        if ((int const   )*("() {" + 0) == (int const   )*(string + 0)) {
          {
          tmp___1 = strncmp("() {", (char const   *)string, (size_t )4);
          }
          if (tmp___1 == 0) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
        } else {
          tmp___2 = 0;
        }
        if (tmp___2) {
          {
          tmp___0 = strlen((char const   *)string);
          string_length = (int )tmp___0;
          temp_string = xmalloc((size_t )((3 + string_length) + char_index));
          strcpy((char * __restrict  )temp_string, (char const   * __restrict  )name);
          *(temp_string + char_index) = (char )' ';
          strcpy((char * __restrict  )((temp_string + char_index) + 1), (char const   * __restrict  )string);
          parse_and_execute(temp_string, name, 5);
          }
          if ((int )*(name + (char_index - 1)) == 41) {
            if ((int )*(name + (char_index - 2)) == 40) {
              *(name + (char_index - 2)) = (char )'\000';
            }
          }
          {
          temp_var = find_function(name);
          }
          if (temp_var) {
            temp_var->attributes |= 129;
            array_needs_making = 1;
          } else {
            {
            report_error("error importing function definition for `%s\'", name);
            }
          }
          if ((int )*(name + (char_index - 1)) == 41) {
            if ((int )*(name + (char_index - 2)) == 0) {
              *(name + (char_index - 2)) = (char )'(';
            }
          }
        } else {
          {
          temp_var = bind_variable(name, string);
          temp_var->attributes |= 129;
          array_needs_making = 1;
          }
        }
      } else {
        {
        temp_var = bind_variable(name, string);
        temp_var->attributes |= 129;
        array_needs_making = 1;
        }
      }
    } else {
      {
      temp_var = bind_variable(name, string);
      temp_var->attributes |= 129;
      array_needs_making = 1;
      }
    }
    *(name + char_index) = (char )'=';
    if (temp_var) {
      if ((temp_var->attributes & 32) == 0) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
          tmp___3 = strlen((char const   *)name);
          tmp___4 = xmalloc(1UL + tmp___3);
          tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )name);
          temp_var->exportstr = tmp___5;
          }
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  set_pwd();
  temp_var = bind_variable((char *)"_", dollar_vars[0]);
  tmp___7 = getpid();
  dollar_dollar_pid = tmp___7;
  temp_var = set_if_not((char *)"PATH", (char *)"/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.");
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    temp_var->attributes |= 1;
    array_needs_making = 1;
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  temp_var = set_if_not((char *)"TERM", (char *)"dumb");
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    temp_var->attributes |= 1;
    array_needs_making = 1;
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  if (interactive_shell) {
    {
    set_if_not((char *)"PS1", primary_prompt);
    set_if_not((char *)"PS2", secondary_prompt);
    }
  }
  {
  set_if_not((char *)"PS4", (char *)"+ ");
  temp_var = bind_variable((char *)"IFS", (char *)" \t\n");
  temp_var = set_if_not((char *)"HOSTTYPE", (char *)"");
  }
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    temp_var->attributes |= 1;
    array_needs_making = 1;
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
  temp_var = set_if_not((char *)"OSTYPE", (char *)"");
  }
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    temp_var->attributes |= 1;
    array_needs_making = 1;
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
  temp_var = set_if_not((char *)"MACHTYPE", (char *)"");
  }
  {
  while (1) {
    while_continue___6: /* CIL Label */ ;
    temp_var->attributes |= 1;
    array_needs_making = 1;
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  temp_var = set_if_not((char *)"HOSTNAME", current_host_name);
  }
  {
  while (1) {
    while_continue___7: /* CIL Label */ ;
    temp_var->attributes |= 1;
    array_needs_making = 1;
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  if (interactive_shell) {
    {
    set_if_not((char *)"MAILCHECK", (char *)"60");
    }
  }
  {
  initialize_shell_level();
  set_ppid();
  bind_variable((char *)"OPTIND", (char *)"1");
  getopts_reset(0);
  bind_variable((char *)"OPTERR", (char *)"1");
  sh_opterr = 1;
  }
  if (login_shell == 1) {
    {
    set_home_var();
    }
  }
  {
  name = get_bash_name();
  temp_var = bind_variable((char *)"BASH", name);
  free((void *)name);
  set_shell_var();
  tmp___8 = shell_version_string();
  bind_variable((char *)"BASH_VERSION", tmp___8);
  make_vers_array();
  temp_var = find_variable((char *)"POSIXLY_CORRECT");
  }
  if (! temp_var) {
    {
    temp_var = find_variable((char *)"POSIX_PEDANTIC");
    }
  }
  if (temp_var) {
    if (temp_var->attributes & 128) {
      {
      sv_strict_posix(temp_var->name);
      }
    }
  }
  if (remember_on_history) {
    if (posixly_correct) {
      tmp___9 = "~/.sh_history";
    } else {
      tmp___9 = "~/.bash_history";
    }
    {
    name = bash_tilde_expand((char *)tmp___9);
    set_if_not((char *)"HISTFILE", name);
    free((void *)name);
    set_if_not((char *)"HISTSIZE", (char *)"500");
    sv_histsize((char *)"HISTSIZE");
    }
  }
  {
  sbrand((int )((long )dollar_dollar_pid + shell_start_time));
  }
  if (interactive_shell) {
    {
    temp_var = find_variable((char *)"IGNOREEOF");
    }
    if (! temp_var) {
      {
      temp_var = find_variable((char *)"ignoreeof");
      }
    }
    if (temp_var) {
      if (temp_var->attributes & 128) {
        {
        sv_ignoreeof(temp_var->name);
        }
      }
    }
  }
  if (interactive_shell) {
    if (remember_on_history) {
      {
      sv_history_control((char *)"HISTCONTROL");
      sv_histignore((char *)"HISTIGNORE");
      }
    }
  }
  {
  temp_var = find_variable((char *)"SSH_CLIENT");
  }
  if (temp_var) {
    if (temp_var->attributes & 128) {
      temp_var->attributes &= -2;
      array_needs_making = 1;
    }
  }
  {
  temp_var = find_variable((char *)"SSH2_CLIENT");
  }
  if (temp_var) {
    if (temp_var->attributes & 128) {
      temp_var->attributes &= -2;
      array_needs_making = 1;
    }
  }
  {
  uidset();
  initialize_dynamic_variables();
  }
  return;
}
}
char *sh_get_home_dir(void) 
{ 


  {
  if ((unsigned long )current_user.home_dir == (unsigned long )((char *)0)) {
    {
    get_current_user_info();
    }
  }
  return (current_user.home_dir);
}
}
static void set_home_var(void) 
{ 
  SHELL_VAR *temp_var ;
  char *tmp ;

  {
  {
  temp_var = find_variable((char *)"HOME");
  }
  if ((unsigned long )temp_var == (unsigned long )((SHELL_VAR *)0)) {
    {
    tmp = sh_get_home_dir();
    temp_var = bind_variable((char *)"HOME", tmp);
    }
  }
  temp_var->attributes |= 1;
  return;
}
}
static void set_shell_var(void) 
{ 
  SHELL_VAR *temp_var ;

  {
  {
  temp_var = find_variable((char *)"SHELL");
  }
  if ((unsigned long )temp_var == (unsigned long )((SHELL_VAR *)0)) {
    if ((unsigned long )current_user.shell == (unsigned long )((char *)0)) {
      {
      get_current_user_info();
      }
    }
    {
    temp_var = bind_variable((char *)"SHELL", current_user.shell);
    }
  }
  temp_var->attributes |= 1;
  return;
}
}
static char *get_bash_name(void) 
{ 
  char *name ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *cdir ;
  int len___0 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tname ;
  int s ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  if (login_shell == 1) {
    if ((int )*(shell_name + 0) != 47) {
      if ((unsigned long )current_user.shell == (unsigned long )((char *)0)) {
        {
        get_current_user_info();
        }
      }
      {
      tmp = strlen((char const   *)current_user.shell);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )current_user.shell);
      name = tmp___1;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((int )*(shell_name + 0) == 47) {
    {
    tmp___2 = strlen((char const   *)shell_name);
    tmp___3 = xmalloc(1UL + tmp___2);
    tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )shell_name);
    name = tmp___4;
    }
  } else { //Added block
  if ((int )*(shell_name + 0) == 46) {
    if ((int )*(shell_name + 1) == 47) {
      {
      cdir = get_string_value("PWD");
      }
      if (cdir) {
        {
        tmp___5 = strlen((char const   *)cdir);
        len___0 = (int )tmp___5;
        tmp___6 = strlen((char const   *)shell_name);
        name = xmalloc(((size_t )len___0 + tmp___6) + 1UL);
        strcpy((char * __restrict  )name, (char const   * __restrict  )cdir);
        strcpy((char * __restrict  )(name + len___0), (char const   * __restrict  )(shell_name + 1));
        }
      } else {
        {
        tmp___7 = strlen((char const   *)shell_name);
        tmp___8 = xmalloc(1UL + tmp___7);
        tmp___9 = strcpy((char * __restrict  )tmp___8, (char const   * __restrict  )shell_name);
        name = tmp___9;
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    tname = find_user_command(shell_name);
    }
    if ((unsigned long )tname == (unsigned long )((char *)0)) {
      {
      s = file_status(shell_name);
      }
      if (s & 2) {
        {
        tmp___10 = get_string_value("PWD");
        tname = make_absolute(shell_name, tmp___10);
        }
        if ((int )*shell_name == 46) {
          {
          name = sh_canonpath(tname, 3);
          }
          if ((unsigned long )name == (unsigned long )((char *)0)) {
            name = tname;
          } else {
            {
            free((void *)tname);
            }
          }
        } else {
          name = tname;
        }
      } else {
        if ((unsigned long )current_user.shell == (unsigned long )((char *)0)) {
          {
          get_current_user_info();
          }
        }
        {
        tmp___11 = strlen((char const   *)current_user.shell);
        tmp___12 = xmalloc(1UL + tmp___11);
        tmp___13 = strcpy((char * __restrict  )tmp___12, (char const   * __restrict  )current_user.shell);
        name = tmp___13;
        }
      }
    } else {
      {
      name = full_pathname(tname);
      free((void *)tname);
      }
    }
  }
  }
  }
  return (name);
}
}
void adjust_shell_level(int change ) 
{ 
  char new_level[5] ;
  char *old_SHLVL ;
  int old_level ;
  SHELL_VAR *temp_var ;
  int tmp ;

  {
  {
  old_SHLVL = get_string_value("SHLVL");
  }
  if (old_SHLVL) {
    {
    tmp = atoi((char const   *)old_SHLVL);
    old_level = tmp;
    }
  } else {
    old_level = 0;
  }
  shell_level = old_level + change;
  if (shell_level < 0) {
    shell_level = 0;
  } else { //Added block
  if (shell_level > 1000) {
    {
    internal_warning("shell level (%d) too high, resetting to 1", shell_level);
    shell_level = 1;
    }
  }
  }
  if (shell_level < 10) {
    new_level[0] = (char )(shell_level + 48);
    new_level[1] = (char )'\000';
  } else { //Added block
  if (shell_level < 100) {
    new_level[0] = (char )(shell_level / 10 + 48);
    new_level[1] = (char )(shell_level % 10 + 48);
    new_level[2] = (char )'\000';
  } else { //Added block
  if (shell_level < 1000) {
    new_level[0] = (char )(shell_level / 100 + 48);
    old_level = shell_level % 100;
    new_level[1] = (char )(old_level / 10 + 48);
    new_level[2] = (char )(old_level % 10 + 48);
    new_level[3] = (char )'\000';
  }
  }
  }
  {
  temp_var = bind_variable((char *)"SHLVL", new_level);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    temp_var->attributes |= 1;
    array_needs_making = 1;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void initialize_shell_level(void) 
{ 


  {
  {
  adjust_shell_level(1);
  }
  return;
}
}
void set_pwd(void) 
{ 
  SHELL_VAR *temp_var ;
  SHELL_VAR *home_var ;
  char *temp_string ;
  char *home_string ;
  int tmp ;
  int tmp___0 ;

  {
  {
  home_var = find_variable((char *)"HOME");
  }
  if (home_var) {
    home_string = home_var->value;
  } else {
    home_string = (char *)((void *)0);
  }
  {
  temp_var = find_variable((char *)"PWD");
  }
  if (temp_var) {
    if (temp_var->attributes & 128) {
      temp_string = temp_var->value;
      if (temp_string) {
        {
        tmp___0 = same_file(temp_string, (char *)".", (struct stat *)((void *)0),
                            (struct stat *)((void *)0));
        }
        if (tmp___0) {
          {
          set_working_directory(temp_string);
          }
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: 
  if (home_string) {
    if (interactive_shell) {
      if (login_shell) {
        {
        tmp = same_file(home_string, (char *)".", (struct stat *)((void *)0), (struct stat *)((void *)0));
        }
        if (tmp) {
          {
          set_working_directory(home_string);
          temp_var = bind_variable((char *)"PWD", home_string);
          }
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            temp_var->attributes |= 1;
            array_needs_making = 1;
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    {
    temp_string = get_working_directory((char *)"shell-init");
    }
    if (temp_string) {
      {
      temp_var = bind_variable((char *)"PWD", temp_string);
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        temp_var->attributes |= 1;
        array_needs_making = 1;
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      free((void *)temp_string);
      }
    }
  }
  }
  {
  temp_var = bind_variable((char *)"OLDPWD", (char *)((void *)0));
  temp_var->attributes |= 5;
  }
  return;
}
}
void set_ppid(void) 
{ 
  char namebuf[32] ;
  char *name ;
  SHELL_VAR *temp_var ;
  __pid_t tmp ;

  {
  {
  tmp = getppid();
  name = inttostr(tmp, namebuf, (int )sizeof(namebuf));
  temp_var = find_variable((char *)"PPID");
  }
  if (temp_var) {
    temp_var->attributes &= -4;
  }
  {
  temp_var = bind_variable((char *)"PPID", name);
  temp_var->attributes |= 66;
  }
  return;
}
}
static void uidset(void) 
{ 
  char buff[32] ;
  char *b ;
  register SHELL_VAR *v___0 ;

  {
  {
  b = inttostr((int )current_user.uid, buff, (int )sizeof(buff));
  v___0 = find_variable((char *)"UID");
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    {
    v___0 = bind_variable((char *)"UID", b);
    v___0->attributes |= 66;
    }
  }
  if (current_user.euid != current_user.uid) {
    {
    b = inttostr((int )current_user.euid, buff, (int )sizeof(buff));
    }
  }
  {
  v___0 = find_variable((char *)"EUID");
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    {
    v___0 = bind_variable((char *)"EUID", b);
    v___0->attributes |= 66;
    }
  }
  return;
}
}
static void make_vers_array(void) 
{ 
  SHELL_VAR *vv ;
  ARRAY *av ;
  char *s ;
  char d___0[32] ;
  char *tmp ;

  {
  {
  makunbound((char *)"BASH_VERSINFO", shell_variables);
  vv = make_new_array_variable((char *)"BASH_VERSINFO");
  av = (ARRAY *)vv->value;
  strcpy((char * __restrict  )(d___0), (char const   * __restrict  )dist_version);
  s = strchr((char const   *)(d___0), '.');
  }
  if (s) {
    tmp = s;
    s ++;
    *tmp = (char )'\000';
  }
  {
  array_add_element(av, 0, d___0);
  array_add_element(av, 1, s);
  s = inttostr(patch_level, d___0, (int )sizeof(d___0));
  array_add_element(av, 2, s);
  s = inttostr(build_version, d___0, (int )sizeof(d___0));
  array_add_element(av, 3, s);
  array_add_element(av, 4, release_status);
  array_add_element(av, 5, (char *)"");
  vv->attributes |= 2;
  }
  return;
}
}
void sh_set_lines_and_columns(int lines , int cols ) 
{ 
  char val___0[32] ;
  char *v___0 ;

  {
  {
  v___0 = inttostr(lines, val___0, (int )sizeof(val___0));
  bind_variable((char *)"LINES", v___0);
  v___0 = inttostr(cols, val___0, (int )sizeof(val___0));
  bind_variable((char *)"COLUMNS", v___0);
  }
  return;
}
}
SHELL_VAR *set_if_not(char *name , char *value ) 
{ 
  SHELL_VAR *v___0 ;

  {
  {
  v___0 = find_variable(name);
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    {
    v___0 = bind_variable(name, value);
    }
  }
  return (v___0);
}
}
SHELL_VAR **map_over(Function *function , HASH_TABLE *var_hash_table ) 
{ 
  register int i ;
  register BUCKET_CONTENTS *tlist ;
  SHELL_VAR *var ;
  SHELL_VAR **list___0 ;
  int list_index___0 ;
  int list_size ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  list___0 = (SHELL_VAR **)((void *)0);
  list_size = 0;
  list_index___0 = list_size;
  i = list_index___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < var_hash_table->nbuckets)) {
      goto while_break;
    }
    if (var_hash_table) {
      if (i < var_hash_table->nbuckets) {
        tlist = *(var_hash_table->bucket_array + i);
      } else {
        tlist = (BUCKET_CONTENTS *)((void *)0);
      }
    } else {
      tlist = (BUCKET_CONTENTS *)((void *)0);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! tlist) {
        goto while_break___0;
      }
      var = (SHELL_VAR *)tlist->data;
      if (! function) {
        goto _L;
      } else {
        {
        tmp___1 = (*function)(var);
        }
        if (tmp___1) {
          _L: 
          if (list_index___0 + 1 >= list_size) {
            {
            list_size += 20;
            tmp = xrealloc((void *)list___0, (unsigned long )list_size * sizeof(SHELL_VAR *));
            list___0 = (SHELL_VAR **)tmp;
            }
          }
          tmp___0 = list_index___0;
          list_index___0 ++;
          *(list___0 + tmp___0) = var;
          *(list___0 + list_index___0) = (SHELL_VAR *)((void *)0);
        }
      }
      tlist = tlist->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (list___0);
}
}
void sort_variables(SHELL_VAR **array ) 
{ 
  int tmp ;

  {
  {
  tmp = array_len((char **)array);
  qsort((void *)array, (size_t )tmp, sizeof(SHELL_VAR *), (int (*)(void const   * ,
                                                                   void const   * ))(& qsort_var_comp));
  }
  return;
}
}
static int qsort_var_comp(SHELL_VAR **var1 , SHELL_VAR **var2 ) 
{ 
  int result ;

  {
  result = (int )*((*var1)->name + 0) - (int )*((*var2)->name + 0);
  if (result == 0) {
    {
    result = strcmp((char const   *)(*var1)->name, (char const   *)(*var2)->name);
    }
  }
  return (result);
}
}
static SHELL_VAR **all_vars(HASH_TABLE *table ) 
{ 
  SHELL_VAR **list___0 ;

  {
  {
  list___0 = map_over((Function *)((void *)0), table);
  }
  if (list___0) {
    {
    sort_variables(list___0);
    }
  }
  return (list___0);
}
}
SHELL_VAR **all_shell_variables(void) 
{ 
  SHELL_VAR **tmp ;

  {
  {
  tmp = all_vars(shell_variables);
  }
  return (tmp);
}
}
SHELL_VAR **all_shell_functions(void) 
{ 
  SHELL_VAR **tmp ;

  {
  {
  tmp = all_vars(shell_functions);
  }
  return (tmp);
}
}
void print_var_list(SHELL_VAR **list___0 ) 
{ 
  register int i ;
  register SHELL_VAR *var ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (list___0) {
      var = *(list___0 + i);
      if (! var) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (! (var->attributes & 4)) {
      {
      print_assignment(var);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void print_func_list(SHELL_VAR **list___0 ) 
{ 
  register int i ;
  register SHELL_VAR *var ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (list___0) {
      var = *(list___0 + i);
      if (! var) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    printf((char const   * __restrict  )"%s ", var->name);
    print_var_function(var);
    printf((char const   * __restrict  )"\n");
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void print_assignment(SHELL_VAR *var ) 
{ 


  {
  if (var->attributes & 32) {
    if (var->value) {
      {
      printf((char const   * __restrict  )"%s", var->name);
      print_var_function(var);
      printf((char const   * __restrict  )"\n");
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (var->attributes & 8) {
    if (var->value) {
      {
      print_array_assignment(var, 0);
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (var->value) {
    {
    printf((char const   * __restrict  )"%s=", var->name);
    print_var_value(var, 1);
    printf((char const   * __restrict  )"\n");
    }
  }
  }
  }
  return;
}
}
void print_var_value(SHELL_VAR *var , int quote ) 
{ 
  char *t ;
  int tmp ;

  {
  if (var->value) {
    if (quote) {
      {
      tmp = sh_contains_shell_metas(var->value);
      }
      if (tmp) {
        {
        t = ansic_quote(var->value, 0, (int *)0);
        printf((char const   * __restrict  )"%s", t);
        free((void *)t);
        }
      } else {
        {
        printf((char const   * __restrict  )"%s", var->value);
        }
      }
    } else {
      {
      printf((char const   * __restrict  )"%s", var->value);
      }
    }
  }
  return;
}
}
void print_var_function(SHELL_VAR *var ) 
{ 
  char *tmp ;

  {
  if (var->attributes & 32) {
    if (var->value) {
      {
      tmp = named_function_string((char *)((void *)0), (COMMAND *)var->value, 1);
      printf((char const   * __restrict  )"%s", tmp);
      }
    }
  }
  return;
}
}
void print_array_assignment(SHELL_VAR *var , int quoted ) 
{ 
  char *vstr ;
  char const   *tmp ;

  {
  if (quoted) {
    {
    vstr = quoted_array_assignment_string((ARRAY *)var->value);
    }
  } else {
    {
    vstr = array_to_assignment_string((ARRAY *)var->value);
    }
  }
  if ((unsigned long )vstr == (unsigned long )((char *)0)) {
    if (quoted) {
      tmp = "\'()\'";
    } else {
      tmp = "()";
    }
    {
    printf((char const   * __restrict  )"%s=%s\n", var->name, tmp);
    }
  } else {
    {
    printf((char const   * __restrict  )"%s=%s\n", var->name, vstr);
    free((void *)vstr);
    }
  }
  return;
}
}
static SHELL_VAR *null_assign(SHELL_VAR *self , char *value ) 
{ 


  {
  return (self);
}
}
static SHELL_VAR *null_array_assign(SHELL_VAR *self , int ind___1 , char *value ) 
{ 


  {
  return (self);
}
}
static long seconds_value_assigned  ;
static SHELL_VAR *assign_seconds(SHELL_VAR *self , char *value ) 
{ 
  int tmp ;
  time_t tmp___0 ;

  {
  {
  seconds_value_assigned = strtol((char const   * __restrict  )value, (char ** __restrict  )((char **)((void *)0)),
                                  10);
  tmp___0 = time((time_t *)0);
  tmp = (int )tmp___0;
  shell_start_time = (time_t )tmp;
  }
  return (self);
}
}
static SHELL_VAR *get_seconds(SHELL_VAR *var ) 
{ 
  time_t time_since_start ;
  char *p ;
  int tmp ;
  time_t tmp___0 ;

  {
  {
  tmp___0 = time((time_t *)0);
  tmp = (int )tmp___0;
  time_since_start = (time_t )tmp - shell_start_time;
  p = itos((int )((time_t )((int )seconds_value_assigned) + time_since_start));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (var->value) {
      {
      free((void *)var->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  var->attributes |= 64;
  var->value = p;
  return (var);
}
}
static unsigned long rseed  =    1UL;
static unsigned long last_random_value  ;
static int brand(void) 
{ 


  {
  rseed = rseed * 1103515245UL + 12345UL;
  return ((int )((unsigned int )(rseed & 32767UL)));
}
}
static void sbrand(int seed ) 
{ 


  {
  rseed = (unsigned long )seed;
  last_random_value = 0UL;
  return;
}
}
static SHELL_VAR *assign_random(SHELL_VAR *self , char *value ) 
{ 
  int tmp ;

  {
  {
  tmp = atoi((char const   *)value);
  sbrand(tmp);
  }
  return (self);
}
}
int get_random_number(void) 
{ 
  int rv ;
  __pid_t tmp ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
  if (subshell_environment) {
    {
    tmp = getpid();
    tmp___1 = time((time_t *)0);
    tmp___0 = (int )tmp___1;
    sbrand((int )(rseed + (unsigned long )((int )((time_t )tmp + (time_t )tmp___0))));
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    rv = brand();
    }
    if (! (rv == (int )last_random_value)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (rv);
}
}
static SHELL_VAR *get_random(SHELL_VAR *var ) 
{ 
  int rv ;
  char *p ;

  {
  {
  rv = get_random_number();
  last_random_value = (unsigned long )rv;
  p = itos(rv);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (var->value) {
      {
      free((void *)var->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  var->attributes |= 64;
  var->value = p;
  return (var);
}
}
static SHELL_VAR *get_lineno(SHELL_VAR *var ) 
{ 
  char *p ;
  int ln ;

  {
  {
  ln = executing_line_number();
  p = itos(ln);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (var->value) {
      {
      free((void *)var->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  var->value = p;
  return (var);
}
}
static SHELL_VAR *assign_lineno(SHELL_VAR *var , char *value ) 
{ 


  {
  {
  line_number = atoi((char const   *)value);
  }
  return (var);
}
}
static SHELL_VAR *get_histcmd(SHELL_VAR *var ) 
{ 
  char *p ;
  int tmp ;

  {
  {
  tmp = history_number();
  p = itos(tmp);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (var->value) {
      {
      free((void *)var->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  var->value = p;
  return (var);
}
}
static SHELL_VAR *get_dirstack(SHELL_VAR *self ) 
{ 
  ARRAY *a ;
  WORD_LIST *l ;

  {
  {
  l = get_directory_stack();
  a = word_list_to_array(l);
  dispose_array((ARRAY *)self->value);
  dispose_words(l);
  self->value = (char *)a;
  }
  return (self);
}
}
static SHELL_VAR *assign_dirstack(SHELL_VAR *self , int ind___1 , char *value ) 
{ 


  {
  {
  set_dirstack_element(ind___1, 1, value);
  }
  return (self);
}
}
static SHELL_VAR *get_groupset(SHELL_VAR *self ) ;
static char **group_set  =    (char **)((void *)0);
static SHELL_VAR *get_groupset(SHELL_VAR *self ) 
{ 
  register int i ;
  int ng ;
  ARRAY *a ;

  {
  if ((unsigned long )group_set == (unsigned long )((char **)0)) {
    {
    group_set = get_group_list(& ng);
    a = (ARRAY *)self->value;
    i = 0;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < ng)) {
        goto while_break;
      }
      {
      array_add_element(a, i, *(group_set + i));
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (self);
}
}
static SHELL_VAR *get_funcname(SHELL_VAR *self ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (variable_context) {
    if (this_shell_function) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (self->value) {
          {
          free((void *)self->value);
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
      tmp = strlen((char const   *)this_shell_function->name);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )this_shell_function->name);
      self->value = tmp___1;
      }
    }
  }
  return (self);
}
}
void make_funcname_visible(int on_or_off ) 
{ 
  SHELL_VAR *v___0 ;

  {
  {
  v___0 = find_variable((char *)"FUNCNAME");
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    return;
  } else { //Added block
  if ((unsigned long )v___0->dynamic_value == (unsigned long )((DYNAMIC_FUNC *)0)) {
    return;
  }
  }
  if (on_or_off) {
    v___0->attributes &= -5;
  } else {
    v___0->attributes |= 4;
  }
  return;
}
}
static void initialize_dynamic_variables(void) 
{ 
  SHELL_VAR *v___0 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    v___0 = bind_variable((char *)"SECONDS", (char *)((void *)0));
    v___0->dynamic_value = (DYNAMIC_FUNC *)(& get_seconds);
    v___0->assign_func = (DYNAMIC_FUNC *)(& assign_seconds);
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    v___0 = bind_variable((char *)"RANDOM", (char *)((void *)0));
    v___0->dynamic_value = (DYNAMIC_FUNC *)(& get_random);
    v___0->assign_func = (DYNAMIC_FUNC *)(& assign_random);
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    v___0 = bind_variable((char *)"LINENO", (char *)((void *)0));
    v___0->dynamic_value = (DYNAMIC_FUNC *)(& get_lineno);
    v___0->assign_func = (DYNAMIC_FUNC *)(& assign_lineno);
    }
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
    v___0 = bind_variable((char *)"HISTCMD", (char *)((void *)0));
    v___0->dynamic_value = (DYNAMIC_FUNC *)(& get_histcmd);
    v___0->assign_func = (DYNAMIC_FUNC *)((void *)0);
    }
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
    v___0 = make_new_array_variable((char *)"DIRSTACK");
    v___0->dynamic_value = (DYNAMIC_FUNC *)(& get_dirstack);
    v___0->assign_func = (DYNAMIC_FUNC *)(& assign_dirstack);
    }
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
    v___0 = make_new_array_variable((char *)"GROUPS");
    v___0->dynamic_value = (DYNAMIC_FUNC *)(& get_groupset);
    v___0->assign_func = (DYNAMIC_FUNC *)(& null_array_assign);
    }
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  v___0->attributes |= 2048;
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
    v___0 = bind_variable((char *)"FUNCNAME", (char *)((void *)0));
    v___0->dynamic_value = (DYNAMIC_FUNC *)(& get_funcname);
    v___0->assign_func = (DYNAMIC_FUNC *)(& null_assign);
    }
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  v___0->attributes |= 2052;
  return;
}
}
SHELL_VAR *var_lookup(char *name , HASH_TABLE *hashed_vars ) 
{ 
  BUCKET_CONTENTS *bucket ;
  SHELL_VAR *tmp ;

  {
  {
  bucket = find_hash_item(name, hashed_vars);
  }
  if (bucket) {
    tmp = (SHELL_VAR *)bucket->data;
  } else {
    tmp = (SHELL_VAR *)((void *)0);
  }
  return (tmp);
}
}
SHELL_VAR *find_variable_internal(char *name , int search_tempenv ) 
{ 
  SHELL_VAR *var ;
  struct variable *tmp ;
  struct variable *tmp___0 ;

  {
  var = (SHELL_VAR *)((void *)0);
  if (search_tempenv) {
    goto _L;
  } else { //Added block
  if (subshell_environment) {
    _L: 
    if (temporary_env) {
      {
      var = find_tempenv_variable(name);
      }
    } else { //Added block
    if (builtin_env) {
      {
      var = find_tempenv_variable(name);
      }
    } else { //Added block
    if (function_env) {
      {
      var = find_tempenv_variable(name);
      }
    }
    }
    }
  }
  }
  if (! var) {
    {
    var = var_lookup(name, shell_variables);
    }
  }
  if (! var) {
    return ((SHELL_VAR *)((void *)0));
  }
  if (var->dynamic_value) {
    {
    tmp = (*(var->dynamic_value))(var);
    tmp___0 = tmp;
    }
  } else {
    tmp___0 = var;
  }
  return (tmp___0);
}
}
SHELL_VAR *find_variable(char *name ) 
{ 
  int tmp ;
  SHELL_VAR *tmp___0 ;

  {
  if (variable_context) {
    tmp = 1;
  } else { //Added block
  if (this_shell_builtin) {
    tmp = 1;
  } else { //Added block
  if (builtin_env) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  {
  tmp___0 = find_variable_internal(name, tmp);
  }
  return (tmp___0);
}
}
SHELL_VAR *find_function(char *name ) 
{ 
  SHELL_VAR *tmp ;

  {
  {
  tmp = var_lookup(name, shell_functions);
  }
  return (tmp);
}
}
char *get_string_value(char const   *var_name ) 
{ 
  SHELL_VAR *var ;
  char *tmp ;

  {
  {
  var = find_variable((char *)var_name);
  }
  if (! var) {
    return ((char *)((void *)0));
  } else { //Added block
  if (var->attributes & 8) {
    {
    tmp = array_reference((ARRAY *)var->value, 0);
    }
    return (tmp);
  } else {
    return (var->value);
  }
  }
}
}
char *sh_get_env_value(char const   *v___0 ) 
{ 
  char *tmp ;

  {
  {
  tmp = get_string_value(v___0);
  }
  return (tmp);
}
}
SHELL_VAR *make_local_variable(char *name ) 
{ 
  SHELL_VAR *new_var ;
  SHELL_VAR *old_var ;
  BUCKET_CONTENTS *elt ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int old_size ;

  {
  {
  old_var = find_variable(name);
  }
  if (old_var) {
    if (old_var->context == variable_context) {
      return (old_var);
    }
  }
  if (old_var) {
    if (old_var->attributes & 2048) {
      goto _L;
    } else { //Added block
    if (old_var->attributes & 2) {
      if (old_var->context == 0) {
        _L: 
        if (old_var->attributes & 2) {
          {
          builtin_error("%s: readonly variable");
          }
        }
        return ((SHELL_VAR *)((void *)0));
      }
    }
    }
  }
  {
  elt = remove_hash_item(name, shell_variables);
  }
  if (elt) {
    {
    old_var = (SHELL_VAR *)elt->data;
    free((void *)elt->key);
    free((void *)elt);
    }
  } else {
    old_var = (SHELL_VAR *)((void *)0);
  }
  if ((unsigned long )old_var == (unsigned long )((SHELL_VAR *)0)) {
    {
    new_var = bind_variable(name, (char *)"");
    }
  } else {
    {
    tmp = xmalloc(sizeof(SHELL_VAR ));
    new_var = (SHELL_VAR *)tmp;
    tmp___0 = strlen((char const   *)name);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )name);
    new_var->name = tmp___2;
    new_var->value = xmalloc((size_t )1);
    *(new_var->value + 0) = (char )'\000';
    new_var->exportstr = (char *)((void *)0);
    new_var->dynamic_value = (DYNAMIC_FUNC *)((void *)0);
    new_var->assign_func = (DYNAMIC_FUNC *)((void *)0);
    }
    if (old_var->attributes & 1) {
      new_var->attributes = 1;
    } else {
      new_var->attributes = 0;
    }
    {
    new_var->prev_context = old_var;
    tmp___3 = strlen((char const   *)name);
    tmp___4 = xmalloc(1UL + tmp___3);
    tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )name);
    elt = add_hash_item(tmp___5, shell_variables);
    elt->data = (char *)new_var;
    }
  }
  new_var->context = variable_context;
  new_var->attributes |= 256;
  if (variable_context >= local_variable_stack_size) {
    old_size = local_variable_stack_size;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (variable_context + 1 >= local_variable_stack_size) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (variable_context + 1 >= local_variable_stack_size)) {
            goto while_break___0;
          }
          local_variable_stack_size += 8;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        have_local_variables = xrealloc((void *)have_local_variables, (size_t )local_variable_stack_size);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    bzero((void *)(have_local_variables + old_size), (size_t )(local_variable_stack_size - old_size));
    }
  }
  *(have_local_variables + variable_context) = (char)1;
  return (new_var);
}
}
SHELL_VAR *make_local_array_variable(char *name ) 
{ 
  SHELL_VAR *var ;
  ARRAY *array ;

  {
  {
  var = make_local_variable(name);
  }
  if ((unsigned long )var == (unsigned long )((SHELL_VAR *)0)) {
    return (var);
  }
  {
  array = new_array();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (var->value) {
      {
      free((void *)var->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  var->value = (char *)array;
  var->attributes |= 8;
  return (var);
}
}
static SHELL_VAR *make_new_variable(char *name ) 
{ 
  SHELL_VAR *entry ;
  BUCKET_CONTENTS *elt ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
  tmp = xmalloc(sizeof(SHELL_VAR ));
  entry = (SHELL_VAR *)tmp;
  entry->attributes = 0;
  tmp___0 = strlen((char const   *)name);
  tmp___1 = xmalloc(1UL + tmp___0);
  tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )name);
  entry->name = tmp___2;
  entry->value = (char *)((void *)0);
  entry->exportstr = (char *)((void *)0);
  entry->dynamic_value = (DYNAMIC_FUNC *)((void *)0);
  entry->assign_func = (DYNAMIC_FUNC *)((void *)0);
  entry->context = 0;
  entry->prev_context = (SHELL_VAR *)((void *)0);
  }
  if ((unsigned long )shell_variables == (unsigned long )((HASH_TABLE *)0)) {
    {
    shell_variables = make_hash_table(0);
    }
  }
  {
  tmp___3 = strlen((char const   *)name);
  tmp___4 = xmalloc(1UL + tmp___3);
  tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )name);
  elt = add_hash_item(tmp___5, shell_variables);
  elt->data = (char *)entry;
  }
  return (entry);
}
}
SHELL_VAR *make_new_array_variable(char *name ) 
{ 
  SHELL_VAR *entry ;
  ARRAY *array ;

  {
  {
  entry = make_new_variable(name);
  array = new_array();
  entry->value = (char *)array;
  entry->attributes |= 8;
  }
  return (entry);
}
}
char *make_variable_value(SHELL_VAR *var , char *value ) 
{ 
  char *retval ;
  long lval ;
  int expok ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (var->attributes & 64) {
    {
    lval = evalexp(value, & expok);
    }
    if (expok == 0) {
      {
      jump_to_top_level(2);
      }
    }
    {
    retval = itos((int )lval);
    }
  } else { //Added block
  if (value) {
    if (*value) {
      {
      tmp = strlen((char const   *)value);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )value);
      retval = tmp___1;
      }
    } else {
      {
      retval = xmalloc((size_t )1);
      *(retval + 0) = (char )'\000';
      }
    }
  } else {
    retval = (char *)((void *)0);
  }
  }
  return (retval);
}
}
SHELL_VAR *bind_variable(char *name , char *value ) 
{ 
  char *newval ;
  SHELL_VAR *entry ;
  SHELL_VAR *tempenv_entry ;
  int found_in_tempenv ;
  struct variable *tmp ;

  {
  entry = (SHELL_VAR *)0;
  found_in_tempenv = 0;
  if (temporary_env) {
    goto _L;
  } else { //Added block
  if (builtin_env) {
    goto _L;
  } else { //Added block
  if (function_env) {
    _L: 
    {
    tempenv_entry = find_tempenv_variable(name);
    }
    if (tempenv_entry) {
      {
      dispose_variable(tempenv_entry);
      tempenv_entry = bind_tempenv_variable(name, value);
      dispose_variable(tempenv_entry);
      }
    }
  }
  }
  }
  {
  entry = var_lookup(name, shell_variables);
  }
  if ((unsigned long )entry == (unsigned long )((SHELL_VAR *)0)) {
    {
    entry = make_new_variable(name);
    entry->value = make_variable_value(entry, value);
    }
  } else { //Added block
  if (entry->assign_func) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (entry->exportstr) {
        if ((entry->attributes & 1024) == 0) {
          {
          free((void *)entry->exportstr);
          }
        }
        entry->exportstr = (char *)((void *)0);
        entry->attributes &= -1025;
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    tmp = (*(entry->assign_func))(entry, value);
    }
    return (tmp);
  } else {
    if (entry->attributes & 2) {
      goto _L___0;
    } else { //Added block
    if (entry->attributes & 2048) {
      _L___0: 
      if (entry->attributes & 2) {
        {
        report_error("%s: readonly variable", name);
        }
      }
      return (entry);
    }
    }
    {
    entry->attributes &= -5;
    newval = make_variable_value(entry, value);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (entry->exportstr) {
        if ((entry->attributes & 1024) == 0) {
          {
          free((void *)entry->exportstr);
          }
        }
        entry->exportstr = (char *)((void *)0);
        entry->attributes &= -1025;
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (entry->attributes & 8) {
      {
      array_add_element((ARRAY *)entry->value, 0, newval);
      free((void *)newval);
      }
    } else {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (entry->value) {
          {
          free((void *)entry->value);
          }
        }
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      entry->value = newval;
    }
  }
  }
  if (mark_modified_vars) {
    entry->attributes |= 1;
  }
  if (entry->attributes & 1) {
    array_needs_making = 1;
  }
  return (entry);
}
}
SHELL_VAR *bind_variable_value(SHELL_VAR *var , char *value ) 
{ 
  char *t ;

  {
  {
  var->attributes &= -5;
  t = make_variable_value(var, value);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (var->value) {
      {
      free((void *)var->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  var->value = t;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (var->exportstr) {
      if ((var->attributes & 1024) == 0) {
        {
        free((void *)var->exportstr);
        }
      }
      var->exportstr = (char *)((void *)0);
      var->attributes &= -1025;
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (mark_modified_vars) {
    var->attributes |= 1;
  }
  if (var->attributes & 1) {
    array_needs_making = 1;
  }
  return (var);
}
}
SHELL_VAR *bind_int_variable(char *lhs , char *rhs ) 
{ 
  register SHELL_VAR *v___0 ;
  int isint ;

  {
  {
  isint = 0;
  v___0 = find_variable(lhs);
  }
  if (v___0) {
    isint = v___0->attributes & 64;
    v___0->attributes &= -65;
  }
  {
  v___0 = bind_variable(lhs, rhs);
  }
  if (isint) {
    v___0->attributes |= 64;
  }
  return (v___0);
}
}
SHELL_VAR *convert_var_to_array(SHELL_VAR *var ) 
{ 
  char *oldval ;
  ARRAY *array ;

  {
  {
  oldval = var->value;
  array = new_array();
  array_add_element(array, 0, oldval);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (var->value) {
      {
      free((void *)var->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  var->value = (char *)array;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (var->exportstr) {
      if ((var->attributes & 1024) == 0) {
        {
        free((void *)var->exportstr);
        }
      }
      var->exportstr = (char *)((void *)0);
      var->attributes &= -1025;
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  var->attributes |= 8;
  var->attributes &= -5;
  return (var);
}
}
SHELL_VAR *bind_array_variable(char *name , int ind___1 , char *value ) 
{ 
  SHELL_VAR *entry ;
  char *newval ;

  {
  {
  entry = var_lookup(name, shell_variables);
  }
  if ((unsigned long )entry == (unsigned long )((SHELL_VAR *)0)) {
    {
    entry = make_new_array_variable(name);
    }
  } else { //Added block
  if (entry->attributes & 2) {
    goto _L;
  } else { //Added block
  if (entry->attributes & 2048) {
    _L: 
    if (entry->attributes & 2) {
      {
      report_error("%s: readonly variable", name);
      }
    }
    return (entry);
  } else { //Added block
  if ((entry->attributes & 8) == 0) {
    {
    entry = convert_var_to_array(entry);
    }
  }
  }
  }
  }
  {
  newval = make_variable_value(entry, value);
  }
  if (entry->assign_func) {
    {
    (*(entry->assign_func))(entry, ind___1, newval);
    }
  } else {
    {
    array_add_element((ARRAY *)entry->value, ind___1, newval);
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (newval) {
      {
      free((void *)newval);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return (entry);
}
}
SHELL_VAR *assign_array_from_string(char *name , char *value ) 
{ 
  SHELL_VAR *var ;
  SHELL_VAR *tmp ;

  {
  {
  var = find_variable(name);
  }
  if ((unsigned long )var == (unsigned long )((SHELL_VAR *)0)) {
    {
    var = make_new_array_variable(name);
    }
  } else { //Added block
  if (var->attributes & 2) {
    goto _L;
  } else { //Added block
  if (var->attributes & 2048) {
    _L: 
    if (var->attributes & 2) {
      {
      report_error("%s: readonly variable", name);
      }
    }
    return ((SHELL_VAR *)((void *)0));
  } else { //Added block
  if ((var->attributes & 8) == 0) {
    {
    var = convert_var_to_array(var);
    }
  }
  }
  }
  }
  {
  tmp = assign_array_var_from_string(var, value);
  }
  return (tmp);
}
}
SHELL_VAR *assign_array_var_from_word_list(SHELL_VAR *var , WORD_LIST *list___0 ) 
{ 
  register int i ;
  register WORD_LIST *l ;
  ARRAY *a ;

  {
  a = (ARRAY *)var->value;
  l = list___0;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! l) {
      goto while_break;
    }
    if (var->assign_func) {
      {
      (*(var->assign_func))(var, i, (l->word)->word);
      }
    } else {
      {
      array_add_element(a, i, (l->word)->word);
      }
    }
    l = l->next;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (var);
}
}
static void quote_array_assignment_chars(WORD_LIST *list___0 ) 
{ 
  char *s ;
  char *t ;
  char *nword ;
  int saw_eq ;
  WORD_LIST *l ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  l = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! l) {
      goto while_break;
    }
    if ((unsigned long )l->word == (unsigned long )((WORD_DESC *)0)) {
      goto __Cont;
    } else { //Added block
    if ((unsigned long )(l->word)->word == (unsigned long )((char *)0)) {
      goto __Cont;
    } else { //Added block
    if ((int )*((l->word)->word + 0) == 0) {
      goto __Cont;
    }
    }
    }
    if ((int )*((l->word)->word + 0) != 91) {
      goto __Cont;
    } else {
      {
      tmp = strchr((char const   *)(l->word)->word, '=');
      }
      if ((unsigned long )tmp == (unsigned long )((char *)0)) {
        goto __Cont;
      }
    }
    {
    tmp___0 = strlen((char const   *)(l->word)->word);
    nword = xmalloc(tmp___0 * 2UL + 1UL);
    s = nword;
    saw_eq = 0;
    t = (l->word)->word;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *t) {
        goto while_break___0;
      }
      if ((int )*t == 61) {
        saw_eq = 1;
      }
      if (saw_eq == 0) {
        if ((int )*t == 91) {
          tmp___1 = s;
          s ++;
          *tmp___1 = (char )'\\';
        } else { //Added block
        if ((int )*t == 93) {
          tmp___1 = s;
          s ++;
          *tmp___1 = (char )'\\';
        }
        }
      }
      tmp___2 = s;
      s ++;
      tmp___3 = t;
      t ++;
      *tmp___2 = *tmp___3;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    *s = (char )'\000';
    free((void *)(l->word)->word);
    (l->word)->word = nword;
    }
    __Cont: 
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
SHELL_VAR *assign_array_var_from_string(SHELL_VAR *var , char *value ) 
{ 
  ARRAY *a ;
  WORD_LIST *list___0 ;
  WORD_LIST *nlist ;
  char *w ;
  char *val___0 ;
  char *nval ;
  int ni ;
  int len___0 ;
  int ind___1 ;
  int last_ind ;
  WORD_LIST *tmp ;

  {
  if ((unsigned long )value == (unsigned long )((char *)0)) {
    return (var);
  }
  if ((int )*value == 40) {
    {
    ni = 1;
    val___0 = extract_array_assignment_list(value, & ni);
    }
    if ((unsigned long )val___0 == (unsigned long )((char *)0)) {
      return (var);
    }
  } else {
    val___0 = value;
  }
  {
  list___0 = parse_string_to_word_list(val___0, (char *)"array assign");
  }
  if (list___0) {
    {
    quote_array_assignment_chars(list___0);
    }
  }
  if (list___0) {
    {
    tmp = expand_words_no_vars(list___0);
    nlist = tmp;
    }
  } else {
    nlist = (WORD_LIST *)((void *)0);
  }
  {
  dispose_words(list___0);
  }
  if ((unsigned long )val___0 != (unsigned long )value) {
    {
    free((void *)val___0);
    }
  }
  a = (ARRAY *)var->value;
  if (a) {
    {
    empty_array(a);
    }
  }
  last_ind = 0;
  list___0 = nlist;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    w = (list___0->word)->word;
    if ((int )*(w + 0) == 91) {
      {
      len___0 = skipsubscript(w, 0);
      }
      if ((int )*(w + len___0) != 93) {
        goto _L;
      } else { //Added block
      if ((int )*(w + (len___0 + 1)) != 61) {
        _L: 
        {
        nval = make_variable_value(var, w);
        }
        if (var->assign_func) {
          {
          (*(var->assign_func))(var, last_ind, nval);
          }
        } else {
          {
          array_add_element(a, last_ind, nval);
          }
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (nval) {
            {
            free((void *)nval);
            }
          }
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        last_ind ++;
        goto __Cont;
      }
      }
      if (len___0 == 1) {
        {
        report_error("%s: bad array subscript", w);
        }
        goto __Cont;
      }
      if ((int )*(w + 1) == 64) {
        goto _L___0;
      } else { //Added block
      if ((int )*(w + 1) == 42) {
        _L___0: 
        if (len___0 == 2) {
          {
          report_error("%s: cannot assign to non-numeric index", w);
          }
          goto __Cont;
        }
      }
      }
      {
      ind___1 = array_expand_index(w + 1, len___0);
      }
      if (ind___1 < 0) {
        {
        report_error("%s: bad array subscript", w);
        }
        goto __Cont;
      }
      last_ind = ind___1;
      val___0 = (w + len___0) + 2;
    } else {
      ind___1 = last_ind;
      val___0 = w;
    }
    if (var->attributes & 64) {
      this_command_name = (char *)((void *)0);
    }
    {
    nval = make_variable_value(var, val___0);
    }
    if (var->assign_func) {
      {
      (*(var->assign_func))(var, ind___1, nval);
      }
    } else {
      {
      array_add_element(a, ind___1, nval);
      }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (nval) {
        {
        free((void *)nval);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    last_ind ++;
    __Cont: 
    list___0 = list___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  dispose_words(nlist);
  }
  return (var);
}
}
void dispose_variable(SHELL_VAR *var ) 
{ 


  {
  if (! var) {
    return;
  }
  if (var->attributes & 32) {
    {
    dispose_command((COMMAND *)var->value);
    }
  } else { //Added block
  if (var->attributes & 8) {
    {
    dispose_array((ARRAY *)var->value);
    }
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (var->value) {
        {
        free((void *)var->value);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (var->exportstr) {
      if ((var->attributes & 1024) == 0) {
        {
        free((void *)var->exportstr);
        }
      }
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  free((void *)var->name);
  }
  if (var->attributes & 1) {
    array_needs_making = 1;
  }
  {
  free((void *)var);
  }
  return;
}
}
int unbind_array_element(SHELL_VAR *var , char *sub ) 
{ 
  int len___0 ;
  int ind___1 ;
  ARRAY_ELEMENT *ae ;

  {
  {
  len___0 = skipsubscript(sub, 0);
  }
  if ((int )*(sub + len___0) != 93) {
    {
    builtin_error("%s[%s: bad array subscript", var->name, sub);
    }
    return (-1);
  } else { //Added block
  if (len___0 == 0) {
    {
    builtin_error("%s[%s: bad array subscript", var->name, sub);
    }
    return (-1);
  }
  }
  *(sub + len___0) = (char )'\000';
  if ((int )*(sub + 0) == 64) {
    goto _L;
  } else { //Added block
  if ((int )*(sub + 0) == 42) {
    _L: 
    if ((int )*(sub + 1) == 0) {
      {
      makunbound(var->name, shell_variables);
      }
      return (0);
    }
  }
  }
  {
  ind___1 = array_expand_index(sub, len___0 + 1);
  }
  if (ind___1 < 0) {
    {
    builtin_error("[%s]: bad array subscript", sub);
    }
    return (-1);
  }
  {
  ae = array_delete_element((ARRAY *)var->value, ind___1);
  }
  if (ae) {
    {
    destroy_array_element(ae);
    }
  }
  return (0);
}
}
int unbind_variable(char *name ) 
{ 
  SHELL_VAR *var ;

  {
  {
  var = find_variable(name);
  }
  if (! var) {
    return (-1);
  }
  if ((var->attributes & 8) == 0) {
    if (var->value) {
      {
      free((void *)var->value);
      var->value = (char *)((void *)0);
      }
    }
  }
  {
  makunbound(name, shell_variables);
  }
  return (0);
}
}
int makunbound(char *name , HASH_TABLE *hash_list ) 
{ 
  BUCKET_CONTENTS *elt ;
  BUCKET_CONTENTS *new_elt ;
  SHELL_VAR *old_var ;
  SHELL_VAR *new_var ;
  char *t ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
  elt = remove_hash_item(name, hash_list);
  }
  if ((unsigned long )elt == (unsigned long )((BUCKET_CONTENTS *)0)) {
    return (-1);
  }
  old_var = (SHELL_VAR *)elt->data;
  new_var = old_var->prev_context;
  if (old_var) {
    if (old_var->attributes & 1) {
      array_needs_making ++;
    }
  }
  if ((unsigned long )hash_list == (unsigned long )shell_functions) {
    {
    set_itemlist_dirty(& it_functions);
    }
  }
  if (old_var) {
    if (old_var->attributes & 256) {
      if (variable_context == old_var->context) {
        old_var->attributes |= 4;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (old_var->exportstr) {
            if ((old_var->attributes & 1024) == 0) {
              {
              free((void *)old_var->exportstr);
              }
            }
            old_var->exportstr = (char *)((void *)0);
            old_var->attributes &= -1025;
          }
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
        tmp = strlen((char const   *)old_var->name);
        tmp___0 = xmalloc(1UL + tmp);
        tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )old_var->name);
        new_elt = add_hash_item(tmp___1, hash_list);
        new_elt->data = (char *)old_var;
        stupidly_hack_special_variables(old_var->name);
        free((void *)elt->key);
        free((void *)elt);
        }
        return (0);
      }
    }
  }
  if (new_var) {
    {
    tmp___2 = strlen((char const   *)new_var->name);
    tmp___3 = xmalloc(1UL + tmp___2);
    tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )new_var->name);
    new_elt = add_hash_item(tmp___4, hash_list);
    new_elt->data = (char *)new_var;
    }
    if (new_var->attributes & 1) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        new_var->attributes |= 1;
        array_needs_making = 1;
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
  tmp___5 = strlen((char const   *)name);
  tmp___6 = xmalloc(1UL + tmp___5);
  tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )name);
  t = tmp___7;
  free((void *)elt->key);
  free((void *)elt);
  dispose_variable(old_var);
  stupidly_hack_special_variables(t);
  free((void *)t);
  }
  return (0);
}
}
int variable_in_context(SHELL_VAR *var ) 
{ 
  int tmp ;

  {
  if (var) {
    if (var->context == variable_context) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void kill_all_local_variables(void) 
{ 
  register int i ;
  register int pass ;
  register SHELL_VAR *var ;
  register SHELL_VAR **list___0 ;
  HASH_TABLE *varlist___1 ;

  {
  if ((unsigned long )have_local_variables == (unsigned long )((char *)0)) {
    return;
  } else { //Added block
  if (variable_context >= local_variable_stack_size) {
    return;
  } else { //Added block
  if ((int )*(have_local_variables + variable_context) == 0) {
    return;
  }
  }
  }
  pass = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (pass < 2)) {
      goto while_break;
    }
    if (pass) {
      varlist___1 = shell_functions;
    } else {
      varlist___1 = shell_variables;
    }
    {
    list___0 = map_over((Function *)(& variable_in_context), varlist___1);
    }
    if (list___0) {
      i = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        var = *(list___0 + i);
        if (! var) {
          goto while_break___0;
        }
        {
        var->attributes &= -257;
        makunbound(var->name, varlist___1);
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      free((void *)list___0);
      }
    }
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
  *(have_local_variables + variable_context) = (char)0;
  return;
}
}
static void free_variable_hash_data(char *data ) 
{ 
  SHELL_VAR *var ;
  SHELL_VAR *prev ;

  {
  var = (SHELL_VAR *)data;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! var) {
      goto while_break;
    }
    {
    prev = var->prev_context;
    dispose_variable(var);
    var = prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void delete_all_variables(HASH_TABLE *hashed_vars ) 
{ 


  {
  {
  flush_hash_table(hashed_vars, (VFunction *)(& free_variable_hash_data));
  }
  return;
}
}
static SHELL_VAR *new_shell_variable(char *name ) 
{ 
  SHELL_VAR *var ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  tmp = xmalloc(sizeof(SHELL_VAR ));
  var = (SHELL_VAR *)tmp;
  bzero((void *)((char *)var), sizeof(SHELL_VAR ));
  tmp___0 = strlen((char const   *)name);
  tmp___1 = xmalloc(1UL + tmp___0);
  tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )name);
  var->name = tmp___2;
  }
  return (var);
}
}
SHELL_VAR *bind_function(char *name , COMMAND *value ) 
{ 
  SHELL_VAR *entry ;
  BUCKET_CONTENTS *elt ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  DYNAMIC_FUNC *tmp___2 ;
  COMMAND *tmp___3 ;

  {
  {
  entry = find_function(name);
  }
  if (! entry) {
    {
    tmp = strlen((char const   *)name);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )name);
    elt = add_hash_item(tmp___1, shell_functions);
    entry = new_shell_variable(name);
    tmp___2 = (DYNAMIC_FUNC *)((void *)0);
    entry->assign_func = tmp___2;
    entry->dynamic_value = tmp___2;
    entry->exportstr = (char *)((void *)0);
    entry->context = 0;
    elt->data = (char *)entry;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (entry->exportstr) {
      if ((entry->attributes & 1024) == 0) {
        {
        free((void *)entry->exportstr);
        }
      }
      entry->exportstr = (char *)((void *)0);
      entry->attributes &= -1025;
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (entry->value) {
    {
    dispose_command((COMMAND *)entry->value);
    }
  }
  if (value) {
    {
    tmp___3 = copy_command(value);
    entry->value = (char *)tmp___3;
    }
  } else {
    entry->value = (char *)((void *)0);
  }
  entry->attributes |= 32;
  if (mark_modified_vars) {
    entry->attributes |= 1;
  }
  entry->attributes &= -5;
  if (entry->attributes & 1) {
    array_needs_making = 1;
  }
  {
  set_itemlist_dirty(& it_functions);
  }
  return (entry);
}
}
void set_var_read_only(char *name ) 
{ 
  SHELL_VAR *entry ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    entry = find_variable(name);
    }
    if (! entry) {
      {
      entry = bind_variable(name, (char *)"");
      }
      if (! no_invisible_vars) {
        entry->attributes |= 4;
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  entry->attributes |= 2;
  return;
}
}
int skipsubscript(char *s , int i ) 
{ 
  int count ;
  int c ;

  {
  count = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (count) {
      i ++;
      c = (int )*(s + i);
      if (! c) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (c == 91) {
      count ++;
    } else { //Added block
    if (c == 93) {
      count --;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (i);
}
}
int assignment(char *string ) 
{ 
  register int c ;
  register int newi ;
  register int indx ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
  {
  indx = 0;
  c = (int )*(string + indx);
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + c) & 1024) {
    tmp___0 = 1;
  } else { //Added block
  if (c == 95) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  }
  if (tmp___0 == 0) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + indx);
    if (! c) {
      goto while_break;
    }
    if (c == 61) {
      return (indx);
    }
    if (c == 91) {
      {
      newi = skipsubscript(string, indx);
      tmp___1 = newi;
      newi ++;
      }
      if ((int )*(string + tmp___1) != 93) {
        return (0);
      }
      if ((int )*(string + newi) == 61) {
        tmp___2 = newi;
      } else {
        tmp___2 = 0;
      }
      return (tmp___2);
    }
    {
    tmp___3 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___3 + c) & 1024) {
      tmp___5 = 1;
    } else {
      {
      tmp___4 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___4 + c) & 2048) {
        tmp___5 = 1;
      } else { //Added block
      if (c == 95) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
      }
    }
    if (tmp___5 == 0) {
      return (0);
    }
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int visible_var(SHELL_VAR *var ) 
{ 


  {
  return ((var->attributes & 4) == 0);
}
}
static SHELL_VAR **_visible_names(HASH_TABLE *table ) 
{ 
  SHELL_VAR **list___0 ;

  {
  {
  list___0 = map_over((Function *)(& visible_var), table);
  }
  if (list___0) {
    {
    sort_variables(list___0);
    }
  }
  return (list___0);
}
}
SHELL_VAR **all_visible_functions(void) 
{ 
  SHELL_VAR **tmp ;

  {
  {
  tmp = _visible_names(shell_functions);
  }
  return (tmp);
}
}
SHELL_VAR **all_visible_variables(void) 
{ 
  SHELL_VAR **tmp ;

  {
  {
  tmp = _visible_names(shell_variables);
  }
  return (tmp);
}
}
static int visible_and_exported(SHELL_VAR *var ) 
{ 
  int tmp ;

  {
  if ((var->attributes & 4) == 0) {
    if (var->attributes & 1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
SHELL_VAR **all_exported_variables(void) 
{ 
  SHELL_VAR **list___0 ;

  {
  {
  list___0 = map_over((Function *)(& visible_and_exported), shell_variables);
  }
  if (list___0) {
    {
    sort_variables(list___0);
    }
  }
  return (list___0);
}
}
static int visible_array_vars(SHELL_VAR *var ) 
{ 
  int tmp ;

  {
  if ((var->attributes & 4) == 0) {
    if (var->attributes & 8) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
SHELL_VAR **all_array_variables(void) 
{ 
  SHELL_VAR **list___0 ;

  {
  {
  list___0 = map_over((Function *)(& visible_array_vars), shell_variables);
  }
  if (list___0) {
    {
    sort_variables(list___0);
    }
  }
  return (list___0);
}
}
char **all_variables_matching_prefix(char *prefix ) 
{ 
  SHELL_VAR **varlist___1 ;
  char **rlist ;
  int vind ;
  int rind ;
  int plen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  if (prefix) {
    if (*(prefix + 0)) {
      if (*(prefix + 1)) {
        if (*(prefix + 2)) {
          {
          tmp = strlen((char const   *)prefix);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      plen = (int )tmp___1;
    } else {
      plen = 0;
    }
  } else {
    plen = 0;
  }
  {
  varlist___1 = all_visible_variables();
  vind = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (varlist___1) {
      if (! *(varlist___1 + vind)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    vind ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )varlist___1 == (unsigned long )((SHELL_VAR **)0)) {
    return ((char **)((void *)0));
  } else { //Added block
  if (vind == 0) {
    return ((char **)((void *)0));
  }
  }
  {
  rlist = alloc_array(vind + 1);
  rind = 0;
  vind = rind;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *(varlist___1 + vind)) {
      goto while_break___0;
    }
    if (plen == 0) {
      goto _L;
    } else {
      if (plen == 0) {
        tmp___8 = 1;
      } else {
        if ((int )*(prefix + 0) == (int )*((*(varlist___1 + vind))->name + 0)) {
          {
          tmp___6 = strncmp((char const   *)prefix, (char const   *)(*(varlist___1 + vind))->name,
                            (size_t )plen);
          }
          if (tmp___6 == 0) {
            tmp___7 = 1;
          } else {
            tmp___7 = 0;
          }
        } else {
          tmp___7 = 0;
        }
        tmp___8 = tmp___7;
      }
      if (tmp___8) {
        _L: 
        {
        tmp___2 = rind;
        rind ++;
        tmp___3 = strlen((char const   *)(*(varlist___1 + vind))->name);
        tmp___4 = xmalloc(1UL + tmp___3);
        tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )(*(varlist___1 + vind))->name);
        *(rlist + tmp___2) = tmp___5;
        }
      }
    }
    vind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  *(rlist + rind) = (char *)0;
  free((void *)varlist___1);
  }
  return (rlist);
}
}
__inline static char *mk_env_string(char *name , char *value ) 
{ 
  int name_len ;
  int value_len ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
  tmp = strlen((char const   *)name);
  name_len = (int )tmp;
  }
  if (value) {
    if (*(value + 0)) {
      if (*(value + 1)) {
        if (*(value + 2)) {
          {
          tmp___0 = strlen((char const   *)value);
          tmp___1 = tmp___0;
          }
        } else {
          tmp___1 = (size_t )2;
        }
        tmp___2 = tmp___1;
      } else {
        tmp___2 = (size_t )1;
      }
      value_len = (int )tmp___2;
    } else {
      value_len = 0;
    }
  } else {
    value_len = 0;
  }
  {
  p = xmalloc((size_t )((2 + name_len) + value_len));
  strcpy((char * __restrict  )p, (char const   * __restrict  )name);
  *(p + name_len) = (char )'=';
  }
  if (value) {
    if (*value) {
      {
      strcpy((char * __restrict  )((p + name_len) + 1), (char const   * __restrict  )value);
      }
    } else {
      *(p + (name_len + 1)) = (char )'\000';
    }
  } else {
    *(p + (name_len + 1)) = (char )'\000';
  }
  return (p);
}
}
char **make_var_array(HASH_TABLE *hashed_vars ) 
{ 
  register int i ;
  register int list_index___0 ;
  register SHELL_VAR *var ;
  char **list___0 ;
  char *value ;
  SHELL_VAR **vars ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
  vars = map_over((Function *)(& visible_and_exported), hashed_vars);
  }
  if ((unsigned long )vars == (unsigned long )((SHELL_VAR **)0)) {
    return ((char **)((void *)0));
  }
  {
  tmp = array_len((char **)vars);
  list___0 = alloc_array(1 + tmp);
  i = 0;
  list_index___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    var = *(vars + i);
    if (! var) {
      goto while_break;
    }
    if (var->exportstr) {
      value = var->exportstr;
    } else { //Added block
    if (var->attributes & 32) {
      {
      value = named_function_string((char *)((void *)0), (COMMAND *)var->value, 0);
      }
    } else { //Added block
    if (var->attributes & 8) {
      goto __Cont;
    } else {
      value = var->value;
    }
    }
    }
    if (value) {
      if ((unsigned long )value == (unsigned long )var->exportstr) {
        {
        tmp___0 = strlen((char const   *)value);
        tmp___1 = xmalloc(1UL + tmp___0);
        tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )value);
        *(list___0 + list_index___0) = tmp___2;
        }
      } else {
        {
        tmp___3 = mk_env_string(var->name, value);
        *(list___0 + list_index___0) = tmp___3;
        }
      }
      if (((unsigned long )value == (unsigned long )var->exportstr) == 0) {
        if (var->attributes & 32) {
          if (*(list___0 + list_index___0)) {
            {
            tmp___4 = strlen((char const   *)*(list___0 + list_index___0));
            tmp___5 = xmalloc(1UL + tmp___4);
            tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )*(list___0 + list_index___0));
            var->exportstr = tmp___6;
            }
          } else {
            var->exportstr = (char *)((void *)0);
          }
        }
      }
      list_index___0 ++;
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)vars);
  *(list___0 + list_index___0) = (char *)((void *)0);
  }
  return (list___0);
}
}
int assign_in_env(char *string ) 
{ 
  int size ;
  int offset ;
  char *name ;
  char *temp___0 ;
  char *value ;
  WORD_LIST *list___0 ;
  SHELL_VAR *var ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
  offset = assignment(string);
  tmp = strlen((char const   *)string);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
  name = tmp___1;
  value = (char *)((void *)0);
  }
  if ((int )*(name + offset) == 61) {
    {
    *(name + offset) = (char)0;
    var = find_variable(name);
    }
    if (var) {
      if (var->attributes & 2) {
        goto _L;
      } else { //Added block
      if (var->attributes & 2048) {
        _L: 
        if (var->attributes & 2) {
          {
          report_error("%s: readonly variable", name);
          }
        }
        {
        free((void *)name);
        }
        return (0);
      }
      }
    }
    {
    temp___0 = (name + offset) + 1;
    tmp___7 = strchr((char const   *)temp___0, '~');
    }
    if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
      {
      tmp___3 = bash_tilde_expand(temp___0);
      temp___0 = tmp___3;
      }
    } else {
      {
      tmp___4 = strlen((char const   *)temp___0);
      tmp___5 = xmalloc(1UL + tmp___4);
      tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )temp___0);
      temp___0 = tmp___6;
      }
    }
    {
    list___0 = expand_string_unsplit(temp___0, 0);
    value = string_list(list___0);
    }
    if (list___0) {
      {
      dispose_words(list___0);
      }
    }
    {
    free((void *)temp___0);
    }
  }
  {
  temp___0 = mk_env_string(name, value);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (value) {
      {
      free((void *)value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)name);
  }
  if ((unsigned long )temporary_env == (unsigned long )((char **)0)) {
    {
    tmp___8 = xmalloc(sizeof(char *));
    temporary_env = (char **)tmp___8;
    *(temporary_env + 0) = (char *)((void *)0);
    }
  }
  {
  size = array_len(temporary_env);
  tmp___9 = xrealloc((void *)temporary_env, (unsigned long )(size + 2) * sizeof(char *));
  temporary_env = (char **)tmp___9;
  *(temporary_env + size) = temp___0;
  *(temporary_env + (size + 1)) = (char *)((void *)0);
  array_needs_making = 1;
  }
  if (echo_command_at_execute) {
    {
    tmp___10 = indirection_level_string();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s%s\n", tmp___10,
            temp___0);
    fflush(stderr);
    }
  }
  return (1);
}
}
static SHELL_VAR *shell_var_from_env_string(char *name , char *env_string , int l ) 
{ 
  SHELL_VAR *temp___0 ;
  char *w ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  DYNAMIC_FUNC *tmp___2 ;

  {
  {
  temp___0 = new_shell_variable(name);
  w = (env_string + l) + 1;
  }
  if (*w) {
    {
    tmp = strlen((char const   *)w);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )w);
    temp___0->value = tmp___1;
    }
  } else {
    temp___0->value = (char *)((void *)0);
  }
  temp___0->attributes = 513;
  temp___0->context = 0;
  temp___0->prev_context = (SHELL_VAR *)((void *)0);
  tmp___2 = (DYNAMIC_FUNC *)((void *)0);
  temp___0->assign_func = tmp___2;
  temp___0->dynamic_value = tmp___2;
  temp___0->exportstr = (char *)((void *)0);
  return (temp___0);
}
}
static SHELL_VAR *bind_name_in_env_array(char *name , char *value , char **array ) 
{ 
  register int i ;
  register int l ;
  char *new_env_string ;
  SHELL_VAR *temp___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )array == (unsigned long )((char **)0)) {
    return ((SHELL_VAR *)((void *)0));
  }
  {
  i = 0;
  tmp = strlen((char const   *)name);
  l = (int )tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(array + i)) {
      goto while_break;
    }
    if (l == 0) {
      tmp___2 = 1;
    } else {
      if ((int )*(*(array + i) + 0) == (int )*(name + 0)) {
        {
        tmp___0 = strncmp((char const   *)*(array + i), (char const   *)name, (size_t )l);
        }
        if (tmp___0 == 0) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
      tmp___2 = tmp___1;
    }
    if (tmp___2) {
      if ((int )*(*(array + i) + l) == 61) {
        {
        new_env_string = mk_env_string(name, value);
        temp___0 = shell_var_from_env_string(name, new_env_string, l);
        free((void *)*(array + i));
        *(array + i) = new_env_string;
        }
        return (temp___0);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((SHELL_VAR *)((void *)0));
}
}
static SHELL_VAR *find_name_in_env_array(char *name , char **array ) 
{ 
  register int i ;
  register int l ;
  SHELL_VAR *temp___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )array == (unsigned long )((char **)0)) {
    return ((SHELL_VAR *)((void *)0));
  }
  {
  i = 0;
  tmp = strlen((char const   *)name);
  l = (int )tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(array + i)) {
      goto while_break;
    }
    if (l == 0) {
      tmp___2 = 1;
    } else {
      if ((int )*(*(array + i) + 0) == (int )*(name + 0)) {
        {
        tmp___0 = strncmp((char const   *)*(array + i), (char const   *)name, (size_t )l);
        }
        if (tmp___0 == 0) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
      tmp___2 = tmp___1;
    }
    if (tmp___2) {
      if ((int )*(*(array + i) + l) == 61) {
        {
        temp___0 = shell_var_from_env_string(name, *(array + i), l);
        }
        return (temp___0);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((SHELL_VAR *)((void *)0));
}
}
static SHELL_VAR *bind_tempenv_variable(char *name , char *value ) 
{ 
  SHELL_VAR *var ;

  {
  var = (SHELL_VAR *)((void *)0);
  if (temporary_env) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      var = find_name_in_env_array(name, temporary_env);
      }
      if (var) {
        {
        dispose_variable(var);
        var = bind_name_in_env_array(name, value, temporary_env);
        }
        return (var);
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if (builtin_env) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      var = find_name_in_env_array(name, builtin_env);
      }
      if (var) {
        {
        dispose_variable(var);
        var = bind_name_in_env_array(name, value, builtin_env);
        }
        return (var);
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  if (variable_context) {
    if (function_env) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
        var = find_name_in_env_array(name, function_env);
        }
        if (var) {
          {
          dispose_variable(var);
          var = bind_name_in_env_array(name, value, function_env);
          }
          return (var);
        }
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return ((SHELL_VAR *)((void *)0));
}
}
SHELL_VAR *find_tempenv_variable(char *name ) 
{ 
  SHELL_VAR *var ;

  {
  var = (SHELL_VAR *)((void *)0);
  if (temporary_env) {
    {
    var = find_name_in_env_array(name, temporary_env);
    }
  }
  if (! var) {
    if (builtin_env) {
      {
      var = find_name_in_env_array(name, builtin_env);
      }
    }
  }
  if (! var) {
    if (variable_context) {
      if (function_env) {
        {
        var = find_name_in_env_array(name, function_env);
        }
      }
    }
  }
  return (var);
}
}
static void dispose_temporary_vars(char ***arrayp ) 
{ 


  {
  if (! *arrayp) {
    return;
  }
  {
  free_array(*arrayp);
  *arrayp = (char **)((void *)0);
  array_needs_making = 1;
  }
  return;
}
}
void dispose_used_env_vars(void) 
{ 


  {
  {
  dispose_temporary_vars(& temporary_env);
  }
  return;
}
}
void dispose_function_env(void) 
{ 


  {
  {
  dispose_temporary_vars(& function_env);
  }
  return;
}
}
void dispose_builtin_env(void) 
{ 


  {
  {
  dispose_temporary_vars(& builtin_env);
  }
  return;
}
}
static void merge_env_array(char **env_array ) 
{ 
  register int i ;
  register int l ;
  SHELL_VAR *temp___0 ;
  char *val___0 ;
  char *name ;

  {
  if ((unsigned long )env_array == (unsigned long )((char **)0)) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(env_array + i)) {
      goto while_break;
    }
    {
    l = assignment(*(env_array + i));
    name = *(env_array + i);
    val___0 = (*(env_array + i) + l) + 1;
    *(name + l) = (char )'\000';
    temp___0 = bind_variable(name, val___0);
    *(name + l) = (char )'=';
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void merge_temporary_env(void) 
{ 


  {
  {
  merge_env_array(temporary_env);
  }
  return;
}
}
void merge_builtin_env(void) 
{ 


  {
  {
  merge_env_array(builtin_env);
  }
  return;
}
}
void merge_function_env(void) 
{ 


  {
  {
  merge_env_array(function_env);
  }
  return;
}
}
int any_temporary_variables(void) 
{ 
  int tmp ;

  {
  if (temporary_env) {
    tmp = 1;
  } else { //Added block
  if (function_env) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
char **add_or_supercede_exported_var(char *assign , int do_alloc ) 
{ 
  register int i ;
  int equal_offset ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
  equal_offset = assignment(assign);
  }
  if (equal_offset == 0) {
    return (export_env);
  }
  if ((int )*(assign + (equal_offset + 1)) == 40) {
    equal_offset ++;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < export_env_index)) {
      goto while_break;
    }
    if (equal_offset + 1 == 0) {
      tmp___4 = 1;
    } else {
      if ((int )*(assign + 0) == (int )*(*(export_env + i) + 0)) {
        {
        tmp___2 = strncmp((char const   *)assign, (char const   *)*(export_env + i),
                          (size_t )(equal_offset + 1));
        }
        if (tmp___2 == 0) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      {
      free((void *)*(export_env + i));
      }
      if (do_alloc) {
        {
        tmp = strlen((char const   *)assign);
        tmp___0 = xmalloc(1UL + tmp);
        tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )assign);
        *(export_env + i) = tmp___1;
        }
      } else {
        *(export_env + i) = assign;
      }
      return (export_env);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (export_env_index >= export_env_size - 1) {
      {
      export_env_size += 16;
      tmp___5 = xrealloc((void *)export_env, (unsigned long )export_env_size * sizeof(char *));
      export_env = (char **)tmp___5;
      }
    }
    tmp___6 = export_env_index;
    export_env_index ++;
    if (do_alloc) {
      {
      tmp___7 = strlen((char const   *)assign);
      tmp___8 = xmalloc(1UL + tmp___7);
      tmp___9 = strcpy((char * __restrict  )tmp___8, (char const   * __restrict  )assign);
      *(export_env + tmp___6) = tmp___9;
      }
    } else {
      *(export_env + tmp___6) = assign;
    }
    *(export_env + export_env_index) = (char *)((void *)0);
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (export_env);
}
}
void maybe_make_export_env(void) 
{ 
  register int i ;
  register char **temp_array ;
  int new_size ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  if (array_needs_making) {
    if (export_env) {
      {
      free_array_members(export_env);
      }
    }
    new_size = (shell_variables->nentries + shell_functions->nentries) + 1;
    if (new_size > export_env_size) {
      {
      export_env_size = new_size;
      tmp = xrealloc((void *)export_env, (unsigned long )export_env_size * sizeof(char *));
      export_env = (char **)tmp;
      }
    }
    {
    export_env_index = 0;
    *(export_env + export_env_index) = (char *)((void *)0);
    temp_array = make_var_array(shell_variables);
    }
    if (temp_array) {
      i = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! *(temp_array + i)) {
          goto while_break;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (export_env_index >= export_env_size - 1) {
            {
            export_env_size += 16;
            tmp___0 = xrealloc((void *)export_env, (unsigned long )export_env_size * sizeof(char *));
            export_env = (char **)tmp___0;
            }
          }
          tmp___1 = export_env_index;
          export_env_index ++;
          *(export_env + tmp___1) = *(temp_array + i);
          *(export_env + export_env_index) = (char *)((void *)0);
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
      free((void *)temp_array);
      }
    }
    {
    temp_array = make_var_array(shell_functions);
    }
    if (temp_array) {
      i = 0;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! *(temp_array + i)) {
          goto while_break___1;
        }
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (export_env_index >= export_env_size - 1) {
            {
            export_env_size += 16;
            tmp___5 = xrealloc((void *)export_env, (unsigned long )export_env_size * sizeof(char *));
            export_env = (char **)tmp___5;
            }
          }
          tmp___6 = export_env_index;
          export_env_index ++;
          *(export_env + tmp___6) = *(temp_array + i);
          *(export_env + export_env_index) = (char *)((void *)0);
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      free((void *)temp_array);
      }
    }
    if (function_env) {
      i = 0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! *(function_env + i)) {
          goto while_break___3;
        }
        {
        export_env = add_or_supercede_exported_var(*(function_env + i), 1);
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    if (builtin_env) {
      i = 0;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! *(builtin_env + i)) {
          goto while_break___4;
        }
        {
        export_env = add_or_supercede_exported_var(*(builtin_env + i), 1);
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    if (temporary_env) {
      i = 0;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! *(temporary_env + i)) {
          goto while_break___5;
        }
        {
        export_env = add_or_supercede_exported_var(*(temporary_env + i), 1);
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    array_needs_making = 0;
  }
  return;
}
}
void update_export_env_inplace(char *env_prefix , int preflen , char *value ) 
{ 
  char *evar ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  if (value) {
    if (*(value + 0)) {
      if (*(value + 1)) {
        if (*(value + 2)) {
          {
          tmp = strlen((char const   *)value);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      tmp___2 = tmp___1;
    } else {
      tmp___2 = (size_t )0;
    }
  } else {
    tmp___2 = (size_t )0;
  }
  {
  evar = xmalloc((tmp___2 + (size_t )preflen) + 1UL);
  strcpy((char * __restrict  )evar, (char const   * __restrict  )env_prefix);
  }
  if (value) {
    {
    strcpy((char * __restrict  )(evar + preflen), (char const   * __restrict  )value);
    }
  }
  {
  export_env = add_or_supercede_exported_var(evar, 0);
  }
  return;
}
}
void put_command_name_into_env(char *command_name ) 
{ 


  {
  {
  update_export_env_inplace((char *)"_=", 2, command_name);
  }
  return;
}
}
static char indirection_string[100]  ;
char *indirection_level_string(void) 
{ 
  register int i ;
  register int j ;
  char *ps4 ;

  {
  {
  indirection_string[0] = (char )'\000';
  ps4 = get_string_value("PS4");
  }
  if ((unsigned long )ps4 == (unsigned long )((char *)0)) {
    return (indirection_string);
  } else { //Added block
  if ((int )*ps4 == 0) {
    return (indirection_string);
  }
  }
  {
  ps4 = decode_prompt_string(ps4);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*ps4) {
      if (i < indirection_level) {
        if (! (i < 99)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    indirection_string[i] = *ps4;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  j = 1;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (*ps4) {
      if (*(ps4 + j)) {
        if (! (i < 99)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    indirection_string[i] = *(ps4 + j);
    i ++;
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  indirection_string[i] = (char )'\000';
  free((void *)ps4);
  }
  return (indirection_string);
}
}
int hostname_list_initialized ;
struct name_and_function special_vars[29]  = 
  {      {(char *)"PATH", (VFunction *)(& sv_path)}, 
        {(char *)"MAIL", (VFunction *)(& sv_mail)}, 
        {(char *)"MAILPATH", (VFunction *)(& sv_mail)}, 
        {(char *)"MAILCHECK", (VFunction *)(& sv_mail)}, 
        {(char *)"POSIXLY_CORRECT", (VFunction *)(& sv_strict_posix)}, 
        {(char *)"GLOBIGNORE", (VFunction *)(& sv_globignore)}, 
        {(char *)"TERM", (VFunction *)(& sv_terminal)}, 
        {(char *)"TERMCAP", (VFunction *)(& sv_terminal)}, 
        {(char *)"TERMINFO", (VFunction *)(& sv_terminal)}, 
        {(char *)"HOSTFILE", (VFunction *)(& sv_hostfile)}, 
        {(char *)"HISTIGNORE", (VFunction *)(& sv_histignore)}, 
        {(char *)"HISTSIZE", (VFunction *)(& sv_histsize)}, 
        {(char *)"HISTFILESIZE", (VFunction *)(& sv_histsize)}, 
        {(char *)"HISTCONTROL", (VFunction *)(& sv_history_control)}, 
        {(char *)"histchars", (VFunction *)(& sv_histchars)}, 
        {(char *)"IGNOREEOF", (VFunction *)(& sv_ignoreeof)}, 
        {(char *)"ignoreeof", (VFunction *)(& sv_ignoreeof)}, 
        {(char *)"OPTIND", (VFunction *)(& sv_optind)}, 
        {(char *)"OPTERR", (VFunction *)(& sv_opterr)}, 
        {(char *)"TEXTDOMAIN", (VFunction *)(& sv_locale)}, 
        {(char *)"TEXTDOMAINDIR", (VFunction *)(& sv_locale)}, 
        {(char *)"LC_ALL", (VFunction *)(& sv_locale)}, 
        {(char *)"LC_COLLATE", (VFunction *)(& sv_locale)}, 
        {(char *)"LC_CTYPE", (VFunction *)(& sv_locale)}, 
        {(char *)"LC_MESSAGES", (VFunction *)(& sv_locale)}, 
        {(char *)"LC_NUMERIC", (VFunction *)(& sv_locale)}, 
        {(char *)"LANG", (VFunction *)(& sv_locale)}, 
        {(char *)"TZ", (VFunction *)(& sv_tz)}, 
        {(char *)0, (VFunction *)0}};
void stupidly_hack_special_variables(char *name ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! special_vars[i].name) {
      goto while_break;
    }
    if ((int )*(special_vars[i].name + 0) == (int )*(name + 0)) {
      {
      tmp = strcmp((char const   *)special_vars[i].name, (char const   *)name);
      }
      if (tmp == 0) {
        {
        (*(special_vars[i].function))(name);
        }
        return;
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void flush_hashed_filenames(void) ;
void sv_path(char *name ) 
{ 


  {
  {
  flush_hashed_filenames();
  }
  return;
}
}
void sv_mail(char *name ) 
{ 


  {
  if ((int )*(name + 4) == 67) {
    {
    reset_mail_timer();
    }
  } else {
    {
    free_mail_files();
    remember_mail_dates();
    }
  }
  return;
}
}
void setup_glob_ignore(char *name ) ;
void sv_globignore(char *name ) 
{ 


  {
  {
  setup_glob_ignore(name);
  }
  return;
}
}
void sv_terminal(char *name ) 
{ 
  char *tmp ;

  {
  if (interactive_shell) {
    if (no_line_editing == 0) {
      {
      tmp = get_string_value("TERM");
      rl_reset_terminal((char const   *)tmp);
      }
    }
  }
  return;
}
}
void sv_hostfile(char *name ) 
{ 
  SHELL_VAR *v___0 ;

  {
  {
  v___0 = find_variable(name);
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    {
    clear_hostname_list();
    }
  } else {
    hostname_list_initialized = 0;
  }
  return;
}
}
void sv_histsize(char *name ) 
{ 
  char *temp___0 ;
  long num ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
  temp___0 = get_string_value((char const   *)name);
  }
  if (temp___0) {
    if (*temp___0) {
      {
      tmp___1 = legal_number(temp___0, & num);
      }
      if (tmp___1) {
        if ((int )*(name + 4) == 83) {
          {
          stifle_history((int )num);
          tmp = where_history();
          num = (long )tmp;
          }
          if ((long )history_lines_this_session > num) {
            history_lines_this_session = (int )num;
          }
        } else {
          {
          tmp___0 = get_string_value("HISTFILE");
          history_truncate_file((char const   *)tmp___0, (int )num);
          }
          if (num <= (long )history_lines_in_file) {
            history_lines_in_file = (int )num;
          }
        }
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(name + 4) == 83) {
    {
    unstifle_history();
    }
  }
  }
  return;
}
}
void sv_histignore(char *name ) 
{ 


  {
  {
  setup_history_ignore(name);
  }
  return;
}
}
void sv_history_control(char *name ) 
{ 
  char *temp___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  history_control = 0;
  temp___0 = get_string_value((char const   *)name);
  }
  if (temp___0) {
    if (*temp___0) {
      if ((int )*(temp___0 + 0) == (int )*("ignore" + 0)) {
        {
        tmp = strncmp((char const   *)temp___0, "ignore", (size_t )6);
        }
        if (tmp == 0) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      if (tmp___0) {
        if ((int )*(temp___0 + 6) == 115) {
          history_control = 1;
        } else { //Added block
        if ((int )*(temp___0 + 6) == 100) {
          history_control = 2;
        } else { //Added block
        if ((int )*(temp___0 + 6) == 98) {
          history_control = 3;
        }
        }
        }
      }
    }
  }
  return;
}
}
void sv_histchars(char *name ) 
{ 
  char *temp___0 ;

  {
  {
  temp___0 = get_string_value((char const   *)name);
  }
  if (temp___0) {
    history_expansion_char = *temp___0;
    if (*(temp___0 + 0)) {
      if (*(temp___0 + 1)) {
        history_subst_char = *(temp___0 + 1);
        if (*(temp___0 + 2)) {
          history_comment_char = *(temp___0 + 2);
        }
      }
    }
  } else {
    history_expansion_char = (char )'!';
    history_subst_char = (char )'^';
    history_comment_char = (char )'#';
  }
  return;
}
}
extern int tzset() ;
void sv_tz(char *name ) 
{ 


  {
  {
  tzset();
  }
  return;
}
}
extern int set_shellopts() ;
void sv_ignoreeof(char *name ) 
{ 
  SHELL_VAR *tmp_var ;
  char *temp___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  eof_encountered = 0;
  tmp_var = find_variable(name);
  ignoreeof = (unsigned long )tmp_var != (unsigned long )((SHELL_VAR *)0);
  }
  if (tmp_var) {
    temp___0 = tmp_var->value;
  } else {
    temp___0 = (char *)((void *)0);
  }
  if (temp___0) {
    if (*temp___0) {
      {
      tmp___1 = all_digits(temp___0);
      }
      if (tmp___1) {
        {
        tmp___0 = atoi((char const   *)temp___0);
        eof_encountered_limit = tmp___0;
        }
      } else {
        eof_encountered_limit = 10;
      }
    } else {
      eof_encountered_limit = 10;
    }
  }
  {
  set_shellopts();
  }
  return;
}
}
void sv_optind(char *name ) 
{ 
  char *tt___0 ;
  int s ;

  {
  {
  tt___0 = get_string_value("OPTIND");
  }
  if (tt___0) {
    if (*tt___0) {
      {
      s = atoi((char const   *)tt___0);
      }
      if (s < 0) {
        s = 0;
      } else { //Added block
      if (s == 1) {
        s = 0;
      }
      }
    } else {
      s = 0;
    }
  } else {
    s = 0;
  }
  {
  getopts_reset(s);
  }
  return;
}
}
void sv_opterr(char *name ) 
{ 
  char *tt___0 ;
  int tmp ;

  {
  {
  tt___0 = get_string_value("OPTERR");
  }
  if (tt___0) {
    if (*tt___0) {
      {
      tmp = atoi((char const   *)tt___0);
      sh_opterr = tmp;
      }
    } else {
      sh_opterr = 1;
    }
  } else {
    sh_opterr = 1;
  }
  return;
}
}
void sv_strict_posix(char *name ) 
{ 
  SHELL_VAR *tmp ;

  {
  {
  tmp = find_variable(name);
  posixly_correct = (unsigned long )tmp != (unsigned long )((SHELL_VAR *)0);
  posix_initialize(posixly_correct);
  }
  if (interactive_shell) {
    {
    posix_readline_initialize(posixly_correct);
    }
  }
  {
  set_shellopts();
  }
  return;
}
}
void sv_locale(char *name ) 
{ 
  char *v___0 ;

  {
  {
  v___0 = get_string_value((char const   *)name);
  }
  if ((int )*(name + 0) == 76) {
    if ((int )*(name + 1) == 65) {
      {
      set_lang(name, v___0);
      }
    } else {
      {
      set_locale_var(name, v___0);
      }
    }
  } else {
    {
    set_locale_var(name, v___0);
    }
  }
  return;
}
}
void set_pipestatus_array(int *ps ) 
{ 
  SHELL_VAR *v___0 ;
  ARRAY *a ;
  register int i ;
  char *t ;
  char tbuf[16] ;

  {
  {
  v___0 = find_variable((char *)"PIPESTATUS");
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    {
    v___0 = make_new_array_variable((char *)"PIPESTATUS");
    }
  }
  if ((v___0->attributes & 8) == 0) {
    return;
  }
  a = (ARRAY *)v___0->value;
  if (a) {
    {
    empty_array(a);
    }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (*(ps + i) != -1)) {
      goto while_break;
    }
    {
    t = inttostr(*(ps + i), tbuf, (int )sizeof(tbuf));
    array_add_element(a, i, t);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int v[2]  = {      0,      -1};
void set_pipestatus_from_exit(int s ) 
{ 


  {
  {
  v[0] = s;
  set_pipestatus_array(v);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-EBc3aGHC.i","-g")
WORD_DESC *copy_word(WORD_DESC *w ) ;
WORD_DESC *copy_word(WORD_DESC *w ) 
{ 
  WORD_DESC *new_word ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  tmp = xmalloc(sizeof(WORD_DESC ));
  new_word = (WORD_DESC *)tmp;
  new_word->flags = w->flags;
  tmp___0 = strlen((char const   *)w->word);
  tmp___1 = xmalloc(1UL + tmp___0);
  tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )w->word);
  new_word->word = tmp___2;
  }
  return (new_word);
}
}
WORD_LIST *copy_word_list(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *new_list ;
  WORD_LIST *temp___0 ;
  char *tmp ;
  GENERIC_LIST *tmp___0 ;
  WORD_LIST *tmp___1 ;

  {
  new_list = (WORD_LIST *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    {
    tmp = xmalloc(sizeof(WORD_LIST ));
    temp___0 = (WORD_LIST *)tmp;
    temp___0->next = new_list;
    new_list = temp___0;
    new_list->word = copy_word(list___0->word);
    list___0 = list___0->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (new_list) {
    if (new_list->next) {
      {
      tmp___0 = reverse_list((GENERIC_LIST *)new_list);
      tmp___1 = (WORD_LIST *)tmp___0;
      }
    } else {
      tmp___1 = new_list;
    }
  } else {
    tmp___1 = new_list;
  }
  return (tmp___1);
}
}
static PATTERN_LIST *copy_case_clause(PATTERN_LIST *clause ) 
{ 
  PATTERN_LIST *new_clause ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(PATTERN_LIST ));
  new_clause = (PATTERN_LIST *)tmp;
  new_clause->patterns = copy_word_list(clause->patterns);
  new_clause->action = copy_command(clause->action);
  }
  return (new_clause);
}
}
static PATTERN_LIST *copy_case_clauses(PATTERN_LIST *clauses ) 
{ 
  PATTERN_LIST *new_list ;
  PATTERN_LIST *new_clause ;
  GENERIC_LIST *tmp ;
  PATTERN_LIST *tmp___0 ;

  {
  new_list = (PATTERN_LIST *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! clauses) {
      goto while_break;
    }
    {
    new_clause = copy_case_clause(clauses);
    new_clause->next = new_list;
    new_list = new_clause;
    clauses = clauses->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (new_list) {
    if (new_list->next) {
      {
      tmp = reverse_list((GENERIC_LIST *)new_list);
      tmp___0 = (PATTERN_LIST *)tmp;
      }
    } else {
      tmp___0 = new_list;
    }
  } else {
    tmp___0 = new_list;
  }
  return (tmp___0);
}
}
REDIRECT *copy_redirect(REDIRECT *redirect ) 
{ 
  REDIRECT *new_redirect ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  tmp = xmalloc(sizeof(REDIRECT ));
  new_redirect = (REDIRECT *)tmp;
  __builtin_memcpy((void *)((char *)new_redirect), (void const   *)((char *)redirect),
                   sizeof(REDIRECT ));
  }
  {
  if ((unsigned int )redirect->instruction == 4U) {
    goto case_4;
  }
  if ((unsigned int )redirect->instruction == 7U) {
    goto case_4;
  }
  if ((unsigned int )redirect->instruction == 3U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 0U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 1U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 2U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 9U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 10U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 11U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 12U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 13U) {
    goto case_3;
  }
  if ((unsigned int )redirect->instruction == 5U) {
    goto case_5;
  }
  if ((unsigned int )redirect->instruction == 6U) {
    goto case_5;
  }
  if ((unsigned int )redirect->instruction == 8U) {
    goto case_5;
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  case_7: /* CIL Label */ 
  {
  tmp___0 = strlen((char const   *)redirect->here_doc_eof);
  tmp___1 = xmalloc(1UL + tmp___0);
  tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )redirect->here_doc_eof);
  new_redirect->here_doc_eof = tmp___2;
  }
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
  new_redirect->redirectee.filename = copy_word(redirect->redirectee.filename);
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_8: /* CIL Label */ 
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (new_redirect);
}
}
REDIRECT *copy_redirects(REDIRECT *list___0 ) 
{ 
  REDIRECT *new_list ;
  REDIRECT *temp___0 ;
  GENERIC_LIST *tmp ;
  REDIRECT *tmp___0 ;

  {
  new_list = (REDIRECT *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    {
    temp___0 = copy_redirect(list___0);
    temp___0->next = new_list;
    new_list = temp___0;
    list___0 = list___0->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (new_list) {
    if (new_list->next) {
      {
      tmp = reverse_list((GENERIC_LIST *)new_list);
      tmp___0 = (REDIRECT *)tmp;
      }
    } else {
      tmp___0 = new_list;
    }
  } else {
    tmp___0 = new_list;
  }
  return (tmp___0);
}
}
static FOR_COM *copy_for_command(FOR_COM *com ) 
{ 
  FOR_COM *new_for ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(FOR_COM ));
  new_for = (FOR_COM *)tmp;
  new_for->flags = com->flags;
  new_for->name = copy_word(com->name);
  new_for->map_list = copy_word_list(com->map_list);
  new_for->action = copy_command(com->action);
  }
  return (new_for);
}
}
static ARITH_FOR_COM *copy_arith_for_command(ARITH_FOR_COM *com ) 
{ 
  ARITH_FOR_COM *new_arith_for ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(ARITH_FOR_COM ));
  new_arith_for = (ARITH_FOR_COM *)tmp;
  new_arith_for->flags = com->flags;
  new_arith_for->line = com->line;
  new_arith_for->init = copy_word_list(com->init);
  new_arith_for->test = copy_word_list(com->test);
  new_arith_for->step = copy_word_list(com->step);
  new_arith_for->action = copy_command(com->action);
  }
  return (new_arith_for);
}
}
static GROUP_COM *copy_group_command(GROUP_COM *com ) 
{ 
  GROUP_COM *new_group ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(GROUP_COM ));
  new_group = (GROUP_COM *)tmp;
  new_group->command = copy_command(com->command);
  }
  return (new_group);
}
}
static SUBSHELL_COM *copy_subshell_command(SUBSHELL_COM *com ) 
{ 
  SUBSHELL_COM *new_subshell ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(SUBSHELL_COM ));
  new_subshell = (SUBSHELL_COM *)tmp;
  new_subshell->command = copy_command(com->command);
  new_subshell->flags = com->flags;
  }
  return (new_subshell);
}
}
static CASE_COM *copy_case_command(CASE_COM *com ) 
{ 
  CASE_COM *new_case ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(CASE_COM ));
  new_case = (CASE_COM *)tmp;
  new_case->flags = com->flags;
  new_case->word = copy_word(com->word);
  new_case->clauses = copy_case_clauses(com->clauses);
  }
  return (new_case);
}
}
static WHILE_COM *copy_while_command(WHILE_COM *com ) 
{ 
  WHILE_COM *new_while ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(WHILE_COM ));
  new_while = (WHILE_COM *)tmp;
  new_while->flags = com->flags;
  new_while->test = copy_command(com->test);
  new_while->action = copy_command(com->action);
  }
  return (new_while);
}
}
static IF_COM *copy_if_command(IF_COM *com ) 
{ 
  IF_COM *new_if ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(IF_COM ));
  new_if = (IF_COM *)tmp;
  new_if->flags = com->flags;
  new_if->test = copy_command(com->test);
  new_if->true_case = copy_command(com->true_case);
  new_if->false_case = copy_command(com->false_case);
  }
  return (new_if);
}
}
static ARITH_COM *copy_arith_command(ARITH_COM *com ) 
{ 
  ARITH_COM *new_arith ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(ARITH_COM ));
  new_arith = (ARITH_COM *)tmp;
  new_arith->flags = com->flags;
  new_arith->exp = copy_word_list(com->exp);
  new_arith->line = com->line;
  }
  return (new_arith);
}
}
static COND_COM *copy_cond_command(COND_COM *com ) 
{ 
  COND_COM *new_cond ;
  char *tmp ;
  WORD_DESC *tmp___0 ;
  COND_COM *tmp___1 ;
  COND_COM *tmp___2 ;

  {
  {
  tmp = xmalloc(sizeof(COND_COM ));
  new_cond = (COND_COM *)tmp;
  new_cond->flags = com->flags;
  new_cond->line = com->line;
  new_cond->type = com->type;
  }
  if (com->op) {
    {
    tmp___0 = copy_word(com->op);
    new_cond->op = tmp___0;
    }
  } else {
    new_cond->op = com->op;
  }
  if (com->left) {
    {
    tmp___1 = copy_cond_command(com->left);
    new_cond->left = tmp___1;
    }
  } else {
    new_cond->left = (COND_COM *)((void *)0);
  }
  if (com->right) {
    {
    tmp___2 = copy_cond_command(com->right);
    new_cond->right = tmp___2;
    }
  } else {
    new_cond->right = (COND_COM *)((void *)0);
  }
  return (new_cond);
}
}
static SIMPLE_COM *copy_simple_command(SIMPLE_COM *com ) 
{ 
  SIMPLE_COM *new_simple ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(SIMPLE_COM ));
  new_simple = (SIMPLE_COM *)tmp;
  new_simple->flags = com->flags;
  new_simple->words = copy_word_list(com->words);
  new_simple->redirects = copy_redirects(com->redirects);
  new_simple->line = com->line;
  }
  return (new_simple);
}
}
static FUNCTION_DEF *copy_function_def(FUNCTION_DEF *com ) 
{ 
  FUNCTION_DEF *new_def ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(FUNCTION_DEF ));
  new_def = (FUNCTION_DEF *)tmp;
  new_def->name = copy_word(com->name);
  new_def->command = copy_command(com->command);
  new_def->flags = com->flags;
  new_def->line = com->line;
  }
  return (new_def);
}
}
COMMAND *copy_command(COMMAND *command ) 
{ 
  COMMAND *new_command ;
  char *tmp ;
  FOR_COM *tmp___0 ;
  CONNECTION *new_connection ;
  char *tmp___1 ;

  {
  if ((unsigned long )command == (unsigned long )((void *)0)) {
    return (command);
  }
  {
  tmp = xmalloc(sizeof(COMMAND ));
  new_command = (COMMAND *)tmp;
  __builtin_memcpy((void *)((char *)new_command), (void const   *)((char *)command),
                   sizeof(COMMAND ));
  new_command->flags = command->flags;
  new_command->line = command->line;
  }
  if (command->redirects) {
    {
    new_command->redirects = copy_redirects(command->redirects);
    }
  }
  {
  if ((unsigned int )command->type == 0U) {
    goto case_0;
  }
  if ((unsigned int )command->type == 12U) {
    goto case_12;
  }
  if ((unsigned int )command->type == 5U) {
    goto case_5;
  }
  if ((unsigned int )command->type == 9U) {
    goto case_9;
  }
  if ((unsigned int )command->type == 13U) {
    goto case_13;
  }
  if ((unsigned int )command->type == 1U) {
    goto case_1;
  }
  if ((unsigned int )command->type == 8U) {
    goto case_8;
  }
  if ((unsigned int )command->type == 2U) {
    goto case_8;
  }
  if ((unsigned int )command->type == 3U) {
    goto case_3;
  }
  if ((unsigned int )command->type == 10U) {
    goto case_10;
  }
  if ((unsigned int )command->type == 11U) {
    goto case_11;
  }
  if ((unsigned int )command->type == 4U) {
    goto case_4;
  }
  if ((unsigned int )command->type == 6U) {
    goto case_6;
  }
  if ((unsigned int )command->type == 7U) {
    goto case_7;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  new_command->value.For = copy_for_command(command->value.For);
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  {
  new_command->value.ArithFor = copy_arith_for_command(command->value.ArithFor);
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  tmp___0 = copy_for_command((FOR_COM *)command->value.Select);
  new_command->value.Select = (SELECT_COM *)tmp___0;
  }
  goto switch_break;
  case_9: /* CIL Label */ 
  {
  new_command->value.Group = copy_group_command(command->value.Group);
  }
  goto switch_break;
  case_13: /* CIL Label */ 
  {
  new_command->value.Subshell = copy_subshell_command(command->value.Subshell);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  new_command->value.Case = copy_case_command(command->value.Case);
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
  new_command->value.While = copy_while_command(command->value.While);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  new_command->value.If = copy_if_command(command->value.If);
  }
  goto switch_break;
  case_10: /* CIL Label */ 
  {
  new_command->value.Arith = copy_arith_command(command->value.Arith);
  }
  goto switch_break;
  case_11: /* CIL Label */ 
  {
  new_command->value.Cond = copy_cond_command(command->value.Cond);
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  new_command->value.Simple = copy_simple_command(command->value.Simple);
  }
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  tmp___1 = xmalloc(sizeof(CONNECTION ));
  new_connection = (CONNECTION *)tmp___1;
  new_connection->connector = (command->value.Connection)->connector;
  new_connection->first = copy_command((command->value.Connection)->first);
  new_connection->second = copy_command((command->value.Connection)->second);
  new_command->value.Connection = new_connection;
  }
  goto switch_break;
  case_7: /* CIL Label */ 
  {
  new_command->value.Function_def = copy_function_def(command->value.Function_def);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (new_command);
}
}
#pragma merger("0","/tmp/cil-Ol0usMYC.i","-g")
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
char *get_name_for_error(void) ;
void fatal_error(char const   *format  , ...) ;
char *command_errstr(int code ) ;
char *last_history_line(void) ;
char *the_current_maintainer  =    (char *)"bash-maintainers@gnu.org";
char *get_name_for_error(void) 
{ 
  char *name ;

  {
  name = (char *)((void *)0);
  if (interactive_shell == 0) {
    name = dollar_vars[0];
  }
  if ((unsigned long )name == (unsigned long )((char *)0)) {
    if (shell_name) {
      if (*shell_name) {
        {
        name = base_pathname(shell_name);
        }
      }
    }
  }
  if ((unsigned long )name == (unsigned long )((char *)0)) {
    name = (char *)"bash";
  }
  return (name);
}
}
void file_error(char *filename ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = __errno_location();
  tmp___0 = strerror(*tmp);
  report_error("%s: %s", filename, tmp___0);
  }
  return;
}
}
void programming_error(char const   *format  , ...) 
{ 
  va_list args ;
  char *h ;
  char const   *tmp ;

  {
  {
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  __builtin_va_end(args);
  }
  if (remember_on_history) {
    {
    h = last_history_line();
    }
    if (h) {
      tmp = (char const   *)h;
    } else {
      tmp = "(null)";
    }
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"last command: %s\n",
            tmp);
    }
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Stopping myself...");
  fflush(stderr);
  abort();
  }
}
}
void report_error(char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
  tmp = get_name_for_error();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", tmp);
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  __builtin_va_end(args);
  }
  if (exit_immediately_on_error) {
    {
    exit(1);
    }
  }
  return;
}
}
void fatal_error(char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
  tmp = get_name_for_error();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", tmp);
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  __builtin_va_end(args);
  exit(2);
  }
}
}
void internal_error(char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
  tmp = get_name_for_error();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", tmp);
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  __builtin_va_end(args);
  }
  return;
}
}
void internal_warning(char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
  tmp = get_name_for_error();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: warning: ",
          tmp);
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  __builtin_va_end(args);
  }
  return;
}
}
void sys_error(char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp = get_name_for_error();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", tmp);
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  tmp___0 = __errno_location();
  tmp___1 = strerror(*tmp___0);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )": %s\n", tmp___1);
  __builtin_va_end(args);
  }
  return;
}
}
void parser_error(int lineno , char const   *format  , ...) 
{ 
  va_list args ;
  char *ename ;
  char *iname ;
  int tmp ;

  {
  {
  ename = get_name_for_error();
  }
  if (bash_input.name) {
    iname = bash_input.name;
  } else {
    iname = (char *)"stdin";
  }
  if (interactive) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", ename);
    }
  } else { //Added block
  if (interactive_shell) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: line %d: ",
            ename, iname, lineno);
    }
  } else { //Added block
  if ((int )*(ename + 0) == (int )*(iname + 0)) {
    {
    tmp = strcmp((char const   *)ename, (char const   *)iname);
    }
    if (tmp == 0) {
      {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: ",
              ename, lineno);
      }
    } else {
      {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: line %d: ",
              ename, iname, lineno);
      }
    }
  } else {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: line %d: ",
            ename, iname, lineno);
    }
  }
  }
  }
  {
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  __builtin_va_end(args);
  }
  if (exit_immediately_on_error) {
    {
    exit(2);
    }
  }
  return;
}
}
static char *cmd_error_table[5]  = {      (char *)"unknown command error",      (char *)"bad command type",      (char *)"bad connector",      (char *)"bad jump", 
        (char *)0};
void command_error(char const   *func , int code , int e , int flags ) 
{ 


  {
  if (code > 3) {
    code = 0;
  }
  {
  programming_error("%s: %s: %d", func, cmd_error_table[code], e);
  }
  return;
}
}
char *command_errstr(int code ) 
{ 


  {
  if (code > 3) {
    code = 0;
  }
  return (cmd_error_table[code]);
}
}
#pragma merger("0","/tmp/cil-sa2WQS_3.i","-g")
char *get_array_value(char *s , int allow_all ) ;
static char *expression  ;
static char *tp  ;
static char *lasttp  ;
static int curtok  ;
static int lasttok  ;
static int assigntok  ;
static char *tokstr  ;
static int tokval  ;
static int noeval  ;
static sigjmp_buf evalbuf  ;
static void readtok(void) ;
static long subexpr(char *expr___0 ) ;
static long expassign(void) ;
static long exp0(void) ;
static long exp1(void) ;
static long exp2(void) ;
static long exp3(void) ;
static long exp4(void) ;
static long exp5(void) ;
static long expshift(void) ;
static long expland(void) ;
static long explor(void) ;
static long expband(void) ;
static long expbor(void) ;
static long expbxor(void) ;
static long expcond(void) ;
static long exppower(void) ;
static long expcomma(void) ;
static long strlong(char *num ) ;
static void evalerror(char *msg ) ;
static EXPR_CONTEXT **expr_stack  ;
static int expr_depth  ;
static int expr_stack_size  ;
static void pushexp(void) 
{ 
  EXPR_CONTEXT *context ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  if (expr_depth >= 1024) {
    {
    evalerror((char *)"expression recursion level exceeded");
    }
  }
  if (expr_depth >= expr_stack_size) {
    {
    expr_stack_size += 10;
    tmp = xrealloc((void *)expr_stack, (unsigned long )expr_stack_size * sizeof(EXPR_CONTEXT *));
    expr_stack = (EXPR_CONTEXT **)tmp;
    }
  }
  {
  tmp___0 = xmalloc(sizeof(EXPR_CONTEXT ));
  context = (EXPR_CONTEXT *)tmp___0;
  context->expression = expression;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    context->curtok = curtok;
    context->lasttok = lasttok;
    context->tp = tp;
    context->lasttp = lasttp;
    context->tokval = tokval;
    context->tokstr = tokstr;
    context->noeval = noeval;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  tmp___1 = expr_depth;
  expr_depth ++;
  *(expr_stack + tmp___1) = context;
  return;
}
}
static void popexp(void) 
{ 
  EXPR_CONTEXT *context ;

  {
  if (expr_depth == 0) {
    {
    evalerror((char *)"recursion stack underflow");
    }
  }
  expr_depth --;
  context = *(expr_stack + expr_depth);
  expression = context->expression;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    curtok = context->curtok;
    lasttok = context->lasttok;
    tp = context->tp;
    lasttp = context->lasttp;
    tokval = context->tokval;
    tokstr = context->tokstr;
    noeval = context->noeval;
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)context);
  }
  return;
}
}
long evalexp(char *expr___0 , int *validp ) 
{ 
  long val___0 ;
  int tmp ;

  {
  {
  val___0 = 0L;
  tmp = __sigsetjmp(evalbuf, 1);
  }
  if (tmp) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (tokstr) {
        {
        free((void *)tokstr);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (expression) {
        {
        free((void *)expression);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    expression = (char *)((void *)0);
    tokstr = expression;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      expr_depth --;
      if (! (expr_depth > 0)) {
        goto while_break___1;
      }
      if ((*(expr_stack + expr_depth))->tokstr) {
        {
        free((void *)(*(expr_stack + expr_depth))->tokstr);
        }
      }
      if ((*(expr_stack + expr_depth))->expression) {
        {
        free((void *)(*(expr_stack + expr_depth))->expression);
        }
      }
      {
      free((void *)*(expr_stack + expr_depth));
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    free((void *)*(expr_stack + expr_depth));
    }
    if (validp) {
      *validp = 0;
    }
    return (0L);
  }
  {
  val___0 = subexpr(expr___0);
  }
  if (validp) {
    *validp = 1;
  }
  return (val___0);
}
}
static long subexpr(char *expr___0 ) 
{ 
  long val___0 ;
  char *p ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  p = expr___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (p) {
      if (*p) {
        if (! ((int )*p == 32)) {
          if (! ((int )*p == 9)) {
            if (! ((int )*p == 10)) {
              goto while_break;
            }
          }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return (0L);
  } else { //Added block
  if ((int )*p == 0) {
    return (0L);
  }
  }
  {
  pushexp();
  lasttok = 0;
  curtok = lasttok;
  tmp = strlen((char const   *)expr___0);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )expr___0);
  expression = tmp___1;
  tp = expression;
  tokstr = (char *)((void *)0);
  tokval = 0;
  readtok();
  val___0 = expcomma();
  }
  if (curtok != 0) {
    {
    evalerror((char *)"syntax error in expression");
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (tokstr) {
      {
      free((void *)tokstr);
      }
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (expression) {
      {
      free((void *)expression);
      }
    }
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  popexp();
  }
  return (val___0);
}
}
static long expcomma(void) 
{ 
  register long value ;

  {
  {
  value = expassign();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 44)) {
      goto while_break;
    }
    {
    readtok();
    value = expassign();
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (value);
}
}
static long expassign(void) 
{ 
  register long value ;
  char *lhs ;
  char *rhs ;
  int special ;
  int op ;
  long lvalue ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  value = expcond();
  }
  if (curtok == 61) {
    goto _L;
  } else { //Added block
  if (curtok == 11) {
    _L: 
    special = curtok == 11;
    if (lasttok != 5) {
      {
      evalerror((char *)"attempted assignment to non-variable");
      }
    }
    if (special) {
      op = assigntok;
      lvalue = value;
    }
    {
    tmp = strlen((char const   *)tokstr);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )tokstr);
    lhs = tmp___1;
    readtok();
    value = expassign();
    }
    if (special) {
      {
      if (op == 42) {
        goto case_42;
      }
      if (op == 47) {
        goto case_47;
      }
      if (op == 37) {
        goto case_37;
      }
      if (op == 43) {
        goto case_43;
      }
      if (op == 45) {
        goto case_45;
      }
      if (op == 9) {
        goto case_9;
      }
      if (op == 10) {
        goto case_10;
      }
      if (op == 38) {
        goto case_38;
      }
      if (op == 124) {
        goto case_124;
      }
      if (op == 94) {
        goto case_94;
      }
      goto switch_default;
      case_42: /* CIL Label */ 
      lvalue *= value;
      goto switch_break;
      case_47: /* CIL Label */ 
      lvalue /= value;
      goto switch_break;
      case_37: /* CIL Label */ 
      lvalue %= value;
      goto switch_break;
      case_43: /* CIL Label */ 
      lvalue += value;
      goto switch_break;
      case_45: /* CIL Label */ 
      lvalue -= value;
      goto switch_break;
      case_9: /* CIL Label */ 
      lvalue <<= value;
      goto switch_break;
      case_10: /* CIL Label */ 
      lvalue >>= value;
      goto switch_break;
      case_38: /* CIL Label */ 
      lvalue &= value;
      goto switch_break;
      case_124: /* CIL Label */ 
      lvalue |= value;
      goto switch_break;
      case_94: /* CIL Label */ 
      lvalue ^= value;
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      free((void *)lhs);
      evalerror((char *)"bug: bad expassign token");
      }
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      value = lvalue;
    }
    {
    rhs = itos((int )value);
    }
    if (noeval == 0) {
      {
      bind_int_variable(lhs, rhs);
      }
    }
    {
    free((void *)rhs);
    free((void *)lhs);
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (tokstr) {
        {
        free((void *)tokstr);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    tokstr = (char *)((void *)0);
  }
  }
  return (value);
}
}
static long expcond(void) 
{ 
  long cval ;
  long val1 ;
  long val2 ;
  long rval ;
  int set_noeval ;

  {
  {
  set_noeval = 0;
  cval = explor();
  rval = cval;
  }
  if (curtok == 63) {
    {
    readtok();
    }
    if (curtok == 0) {
      {
      evalerror((char *)"expression expected");
      }
    } else { //Added block
    if (curtok == 58) {
      {
      evalerror((char *)"expression expected");
      }
    }
    }
    if (cval == 0L) {
      set_noeval = 1;
      noeval ++;
    }
    {
    val1 = expcomma();
    }
    if (set_noeval) {
      noeval --;
    }
    if (curtok != 58) {
      {
      evalerror((char *)"`:\' expected for conditional expression");
      }
    }
    {
    readtok();
    }
    if (curtok == 0) {
      {
      evalerror((char *)"expression expected");
      }
    }
    set_noeval = 0;
    if (cval) {
      set_noeval = 1;
      noeval ++;
    }
    {
    val2 = explor();
    }
    if (set_noeval) {
      noeval --;
    }
    if (cval) {
      rval = val1;
    } else {
      rval = val2;
    }
    lasttok = 12;
  }
  return (rval);
}
}
static long explor(void) 
{ 
  register long val1 ;
  register long val2 ;
  int set_noeval ;
  int tmp ;

  {
  {
  val1 = expland();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 8)) {
      goto while_break;
    }
    set_noeval = 0;
    if (val1 != 0L) {
      noeval ++;
      set_noeval = 1;
    }
    {
    readtok();
    val2 = expland();
    }
    if (set_noeval) {
      noeval --;
    }
    if (val1) {
      tmp = 1;
    } else { //Added block
    if (val2) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
    val1 = (long )tmp;
    lasttok = 8;
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long expland(void) 
{ 
  register long val1 ;
  register long val2 ;
  int set_noeval ;
  int tmp ;

  {
  {
  val1 = expbor();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 7)) {
      goto while_break;
    }
    set_noeval = 0;
    if (val1 == 0L) {
      set_noeval = 1;
      noeval ++;
    }
    {
    readtok();
    val2 = expbor();
    }
    if (set_noeval) {
      noeval --;
    }
    if (val1) {
      if (val2) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    val1 = (long )tmp;
    lasttok = 7;
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long expbor(void) 
{ 
  register long val1 ;
  register long val2 ;

  {
  {
  val1 = expbxor();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 124)) {
      goto while_break;
    }
    {
    readtok();
    val2 = expbxor();
    val1 |= val2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long expbxor(void) 
{ 
  register long val1 ;
  register long val2 ;

  {
  {
  val1 = expband();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 94)) {
      goto while_break;
    }
    {
    readtok();
    val2 = expband();
    val1 ^= val2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long expband(void) 
{ 
  register long val1 ;
  register long val2 ;

  {
  {
  val1 = exp5();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 38)) {
      goto while_break;
    }
    {
    readtok();
    val2 = exp5();
    val1 &= val2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long exp5(void) 
{ 
  register long val1 ;
  register long val2 ;
  int op ;

  {
  {
  val1 = exp4();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 1)) {
      if (! (curtok == 2)) {
        goto while_break;
      }
    }
    {
    op = curtok;
    readtok();
    val2 = exp4();
    }
    if (op == 1) {
      val1 = (long )(val1 == val2);
    } else { //Added block
    if (op == 2) {
      val1 = (long )(val1 != val2);
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long exp4(void) 
{ 
  register long val1 ;
  register long val2 ;
  int op ;

  {
  {
  val1 = expshift();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 3)) {
      if (! (curtok == 4)) {
        if (! (curtok == 60)) {
          if (! (curtok == 62)) {
            goto while_break;
          }
        }
      }
    }
    {
    op = curtok;
    readtok();
    val2 = expshift();
    }
    if (op == 3) {
      val1 = (long )(val1 <= val2);
    } else { //Added block
    if (op == 4) {
      val1 = (long )(val1 >= val2);
    } else { //Added block
    if (op == 60) {
      val1 = (long )(val1 < val2);
    } else {
      val1 = (long )(val1 > val2);
    }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long expshift(void) 
{ 
  register long val1 ;
  register long val2 ;
  int op ;

  {
  {
  val1 = exp3();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 9)) {
      if (! (curtok == 10)) {
        goto while_break;
      }
    }
    {
    op = curtok;
    readtok();
    val2 = exp3();
    }
    if (op == 9) {
      val1 <<= val2;
    } else {
      val1 >>= val2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long exp3(void) 
{ 
  register long val1 ;
  register long val2 ;
  int op ;

  {
  {
  val1 = exp2();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 43)) {
      if (! (curtok == 45)) {
        goto while_break;
      }
    }
    {
    op = curtok;
    readtok();
    val2 = exp2();
    }
    if (op == 43) {
      val1 += val2;
    } else { //Added block
    if (op == 45) {
      val1 -= val2;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long exp2(void) 
{ 
  register long val1 ;
  register long val2 ;
  int op ;

  {
  {
  val1 = exppower();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curtok == 42)) {
      if (! (curtok == 47)) {
        if (! (curtok == 37)) {
          goto while_break;
        }
      }
    }
    {
    op = curtok;
    readtok();
    val2 = exppower();
    }
    if (op == 47) {
      goto _L;
    } else { //Added block
    if (op == 37) {
      _L: 
      if (val2 == 0L) {
        {
        evalerror((char *)"division by 0");
        }
      }
    }
    }
    if (op == 42) {
      val1 *= val2;
    } else { //Added block
    if (op == 47) {
      val1 /= val2;
    } else { //Added block
    if (op == 37) {
      val1 %= val2;
    }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (val1);
}
}
static long exppower(void) 
{ 
  register long val1 ;
  register long val2 ;
  register long c ;
  long tmp ;

  {
  {
  val1 = exp1();
  }
  if (curtok == 13) {
    {
    readtok();
    val2 = exp1();
    }
    if (val2 == 0L) {
      return (1L);
    }
    if (val2 < 0L) {
      {
      evalerror((char *)"exponent less than 0");
      }
    }
    c = 1L;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp = val2;
      val2 --;
      if (! tmp) {
        goto while_break;
      }
      c *= val1;
    }
    while_break: /* CIL Label */ ;
    }
    val1 = c;
  }
  return (val1);
}
}
static long exp1(void) 
{ 
  register long val___0 ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  if (curtok == 33) {
    {
    readtok();
    tmp = exp1();
    }
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    val___0 = (long )tmp___0;
  } else { //Added block
  if (curtok == 126) {
    {
    readtok();
    tmp___1 = exp1();
    val___0 = ~ tmp___1;
    }
  } else {
    {
    val___0 = exp0();
    }
  }
  }
  return (val___0);
}
}
static long exp0(void) 
{ 
  register long val___0 ;
  register long v2 ;
  char *vincdec ;
  int stok ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  val___0 = 0L;
  if (curtok == 14) {
    goto _L___2;
  } else { //Added block
  if (curtok == 15) {
    _L___2: 
    {
    lasttok = curtok;
    stok = lasttok;
    readtok();
    }
    if (curtok != 5) {
      {
      evalerror((char *)"identifier expected after pre-increment or pre-decrement");
      }
    }
    if (stok == 14) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    {
    v2 = (long )(tokval + tmp);
    vincdec = itos((int )v2);
    }
    if (noeval == 0) {
      {
      bind_int_variable(tokstr, vincdec);
      }
    }
    {
    free((void *)vincdec);
    val___0 = v2;
    curtok = 6;
    readtok();
    }
  } else { //Added block
  if (curtok == 45) {
    {
    readtok();
    tmp___0 = exp0();
    val___0 = - tmp___0;
    }
  } else { //Added block
  if (curtok == 43) {
    {
    readtok();
    val___0 = exp0();
    }
  } else { //Added block
  if (curtok == 40) {
    {
    readtok();
    val___0 = expcomma();
    }
    if (curtok != 41) {
      {
      evalerror((char *)"missing `)\'");
      }
    }
    {
    readtok();
    }
  } else { //Added block
  if (curtok == 6) {
    goto _L___1;
  } else { //Added block
  if (curtok == 5) {
    _L___1: 
    val___0 = (long )tokval;
    if (curtok == 5) {
      if ((int )*tp == 43) {
        goto _L___0;
      } else { //Added block
      if ((int )*tp == 45) {
        _L___0: 
        if ((int )*(tp + 1) == (int )*tp) {
          if ((int )*(tp + 2) == 0) {
            goto _L;
          } else {
            {
            tmp___2 = __ctype_b_loc();
            }
            if (((int const   )*(*tmp___2 + (int )*(tp + 2)) & 8) == 0) {
              _L: 
              if ((int )*tp == 43) {
                tmp___1 = 1;
              } else {
                tmp___1 = -1;
              }
              {
              v2 = val___0 + (long )tmp___1;
              vincdec = itos((int )v2);
              }
              if (noeval == 0) {
                {
                bind_int_variable(tokstr, vincdec);
                }
              }
              {
              free((void *)vincdec);
              tp += 2;
              curtok = 6;
              }
            }
          }
        }
      }
      }
    }
    {
    readtok();
    }
  } else {
    {
    evalerror((char *)"syntax error: operand expected");
    }
  }
  }
  }
  }
  }
  }
  }
  return (val___0);
}
}
static void readtok(void) 
{ 
  register char *cp ;
  register int c ;
  register int c1 ;
  register int e ;
  char *value ;
  char *savecp ;
  EXPR_CONTEXT ec ;
  int peektok ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;

  {
  cp = tp;
  e = 0;
  c = e;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (cp) {
      c = (int )*cp;
      if (c) {
        if (! (c == 32)) {
          if (! (c == 9)) {
            if (! (c == 10)) {
              goto while_break;
            }
          }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (c) {
    cp ++;
  }
  tp = cp - 1;
  lasttp = tp;
  if (c == 0) {
    lasttok = curtok;
    curtok = 0;
    tp = cp;
    return;
  }
  {
  tmp___18 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___18 + c) & 1024) {
    goto _L___13;
  } else { //Added block
  if (c == 95) {
    _L___13: 
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___0 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___0 + c) & 1024)) {
        {
        tmp___1 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___1 + c) & 2048)) {
          if (! (c == 95)) {
            goto while_break___0;
          }
        }
      }
      tmp = cp;
      cp ++;
      c = (int )*tmp;
    }
    while_break___0: /* CIL Label */ ;
    }
    cp --;
    c = (int )*cp;
    if (c == 91) {
      {
      e = skipsubscript(cp, 0);
      }
      if ((int )*(cp + e) == 93) {
        cp += e + 1;
        c = (int )*cp;
        e = ']';
      } else {
        {
        evalerror((char *)"bad array subscript");
        }
      }
    }
    *cp = (char )'\000';
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (tokstr) {
        {
        free((void *)tokstr);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    tmp___2 = strlen((char const   *)tp);
    tmp___3 = xmalloc(1UL + tmp___2);
    tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )tp);
    tokstr = tmp___4;
    *cp = (char )c;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      ec.curtok = curtok;
      ec.lasttok = lasttok;
      ec.tp = tp;
      ec.lasttp = lasttp;
      ec.tokval = tokval;
      ec.tokstr = tokstr;
      ec.noeval = noeval;
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    tokstr = (char *)((void *)0);
    savecp = cp;
    tp = savecp;
    noeval = 1;
    readtok();
    peektok = curtok;
    }
    if (peektok == 5) {
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (tokstr) {
          {
          free((void *)tokstr);
          }
        }
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      curtok = ec.curtok;
      lasttok = ec.lasttok;
      tp = ec.tp;
      lasttp = ec.lasttp;
      tokval = ec.tokval;
      tokstr = ec.tokstr;
      noeval = ec.noeval;
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    cp = savecp;
    if (lasttok == 14) {
      goto _L;
    } else { //Added block
    if (lasttok == 15) {
      goto _L;
    } else { //Added block
    if (peektok != 61) {
      _L: 
      if (e == 93) {
        {
        tmp___5 = get_array_value(tokstr, 0);
        value = tmp___5;
        }
      } else {
        {
        tmp___6 = get_string_value((char const   *)tokstr);
        value = tmp___6;
        }
      }
      if (value) {
        if (*value) {
          {
          tmp___7 = subexpr(value);
          tokval = (int )tmp___7;
          }
        } else {
          tokval = 0;
        }
      } else {
        tokval = 0;
      }
      if (e == 93) {
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          if (value) {
            {
            free((void *)value);
            }
          }
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    } else {
      tokval = 0;
    }
    }
    }
    lasttok = curtok;
    curtok = 5;
  } else {
    {
    tmp___17 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___17 + c) & 2048) {
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
        tmp___9 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___9 + c) & 2048)) {
          {
          tmp___10 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___10 + c) & 1024)) {
            if (! (c == 35)) {
              if (! (c == 64)) {
                if (! (c == 95)) {
                  goto while_break___6;
                }
              }
            }
          }
        }
        tmp___8 = cp;
        cp ++;
        c = (int )*tmp___8;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      cp --;
      c = (int )*cp;
      *cp = (char )'\000';
      tmp___11 = strlong(tp);
      tokval = (int )tmp___11;
      *cp = (char )c;
      lasttok = curtok;
      curtok = 6;
      }
    } else {
      tmp___12 = cp;
      cp ++;
      c1 = (int )*tmp___12;
      if (c == 61) {
        if (c1 == 61) {
          c = 1;
        } else {
          goto _L___12;
        }
      } else { //Added block
      _L___12: 
      if (c == 33) {
        if (c1 == 61) {
          c = 2;
        } else {
          goto _L___11;
        }
      } else { //Added block
      _L___11: 
      if (c == 62) {
        if (c1 == 61) {
          c = 4;
        } else {
          goto _L___10;
        }
      } else { //Added block
      _L___10: 
      if (c == 60) {
        if (c1 == 61) {
          c = 3;
        } else {
          goto _L___9;
        }
      } else { //Added block
      _L___9: 
      if (c == 60) {
        if (c1 == 60) {
          if ((int )*cp == 61) {
            assigntok = 9;
            c = 11;
            cp ++;
          } else {
            c = 9;
          }
        } else {
          goto _L___8;
        }
      } else { //Added block
      _L___8: 
      if (c == 62) {
        if (c1 == 62) {
          if ((int )*cp == 61) {
            assigntok = 10;
            c = 11;
            cp ++;
          } else {
            c = 10;
          }
        } else {
          goto _L___7;
        }
      } else { //Added block
      _L___7: 
      if (c == 38) {
        if (c1 == 38) {
          c = 7;
        } else {
          goto _L___6;
        }
      } else { //Added block
      _L___6: 
      if (c == 124) {
        if (c1 == 124) {
          c = 8;
        } else {
          goto _L___5;
        }
      } else { //Added block
      _L___5: 
      if (c == 42) {
        if (c1 == 42) {
          c = 13;
        } else {
          goto _L___4;
        }
      } else { //Added block
      _L___4: 
      if (c == 45) {
        if (c1 == 45) {
          {
          tmp___16 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___16 + (int )*cp) & 1024) {
            c = 15;
          } else { //Added block
          if ((int )*cp == 95) {
            c = 15;
          } else {
            goto _L___3;
          }
          }
        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: 
      if (c == 43) {
        if (c1 == 43) {
          {
          tmp___15 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___15 + (int )*cp) & 1024) {
            c = 14;
          } else { //Added block
          if ((int )*cp == 95) {
            c = 14;
          } else {
            goto _L___1;
          }
          }
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (c1 == 61) {
        if (c) {
          {
          tmp___13 = strchr("*/%+-&^|", c);
          tmp___14 = (unsigned long )tmp___13 != (unsigned long )((char *)((void *)0));
          }
        } else {
          tmp___14 = 0;
        }
        if (tmp___14) {
          assigntok = c;
          c = 11;
        } else {
          cp --;
        }
      } else {
        cp --;
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      lasttok = curtok;
      curtok = c;
    }
  }
  }
  tp = cp;
  return;
}
}
static void evalerror(char *msg ) 
{ 
  char *name ;
  char *t ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  name = this_command_name;
  t = expression;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*t == 32)) {
      if (! ((int )*t == 9)) {
        goto while_break;
      }
    }
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (lasttp) {
    if (*lasttp) {
      tmp = (char const   *)lasttp;
    } else {
      tmp = "";
    }
  } else {
    tmp = "";
  }
  if (name) {
    tmp___0 = ": ";
  } else {
    tmp___0 = "";
  }
  if (name) {
    tmp___1 = (char const   *)name;
  } else {
    tmp___1 = "";
  }
  {
  internal_error("%s%s%s: %s (error token is \"%s\")", tmp___1, tmp___0, t, msg, tmp);
  siglongjmp(evalbuf, 1);
  }
}
}
static long strlong(char *num ) 
{ 
  register char *s ;
  register int c ;
  int base ;
  int foundbase ;
  long val___0 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  val___0 = 0L;
  s = num;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return (0L);
  } else { //Added block
  if ((int )*s == 0) {
    return (0L);
  }
  }
  base = 10;
  foundbase = 0;
  if ((int )*s == 48) {
    s ++;
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      return (0L);
    } else { //Added block
    if ((int )*s == 0) {
      return (0L);
    }
    }
    if ((int )*s == 120) {
      base = 16;
      s ++;
    } else { //Added block
    if ((int )*s == 88) {
      base = 16;
      s ++;
    } else {
      base = 8;
    }
    }
    foundbase ++;
  }
  val___0 = 0L;
  tmp = s;
  s ++;
  c = (int )*tmp;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! c) {
      goto while_break;
    }
    if (c == 35) {
      if (foundbase) {
        {
        evalerror((char *)"bad number");
        }
      }
      base = (int )val___0;
      if (base < 2) {
        {
        evalerror((char *)"illegal arithmetic base");
        }
      } else { //Added block
      if (base > 64) {
        {
        evalerror((char *)"illegal arithmetic base");
        }
      }
      }
      val___0 = 0L;
      foundbase ++;
    } else {
      {
      tmp___3 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___3 + c) & 1024) {
        goto _L___1;
      } else {
        {
        tmp___4 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___4 + c) & 2048) {
          goto _L___1;
        } else { //Added block
        if (c == 95) {
          goto _L___1;
        } else { //Added block
        if (c == 64) {
          _L___1: 
          {
          tmp___2 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___2 + c) & 2048) {
            c -= 48;
          } else { //Added block
          if (c >= 97) {
            if (c <= 122) {
              c -= 87;
            } else {
              goto _L___0;
            }
          } else { //Added block
          _L___0: 
          if (c >= 65) {
            if (c <= 90) {
              if (base <= 36) {
                tmp___1 = 10;
              } else {
                tmp___1 = 36;
              }
              c -= 65 - tmp___1;
            } else {
              goto _L;
            }
          } else { //Added block
          _L: 
          if (c == 95) {
            c = 62;
          } else { //Added block
          if (c == 64) {
            c = 63;
          }
          }
          }
          }
          }
          if (c >= base) {
            {
            evalerror((char *)"value too great for base");
            }
          }
          val___0 = val___0 * (long )base + (long )c;
        } else {
          goto while_break;
        }
        }
        }
      }
    }
    tmp___0 = s;
    s ++;
    c = (int )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  return (val___0);
}
}
#pragma merger("0","/tmp/cil-ci0gsWsr.i","-g")
struct flags_alist shell_flags[21] ;
int disallow_filename_globbing ;
int place_keywords_in_env ;
int unbound_vars_is_error ;
int noclobber ;
int hashing_enabled ;
int asynchronous_notification ;
int no_symbolic_links ;
int brace_expansion ;
int history_expansion ;
int *find_flag(int name ) ;
char *which_set_flags(void) ;
int mark_modified_vars  =    0;
int asynchronous_notification  =    0;
int exit_immediately_on_error  =    0;
int disallow_filename_globbing  =    0;
int place_keywords_in_env  =    0;
int read_but_dont_execute  =    0;
int just_one_command  =    0;
int noclobber  =    0;
int unbound_vars_is_error  =    0;
int echo_input_at_read  =    0;
int echo_command_at_execute  =    0;
int jobs_m_flag  =    0;
int forced_interactive  =    0;
int no_symbolic_links  =    0;
int no_invisible_vars  =    0;
int hashing_enabled  =    1;
int history_expansion  =    1;
int interactive_comments  =    1;
int restricted  =    0;
int restricted_shell  =    0;
int privileged_mode  =    0;
int brace_expansion  =    1;
struct flags_alist shell_flags[21]  = 
  {      {(char )'a', & mark_modified_vars}, 
        {(char )'b', & asynchronous_notification}, 
        {(char )'e', & exit_immediately_on_error}, 
        {(char )'f', & disallow_filename_globbing}, 
        {(char )'h', & hashing_enabled}, 
        {(char )'i', & forced_interactive}, 
        {(char )'k', & place_keywords_in_env}, 
        {(char )'m', & jobs_m_flag}, 
        {(char )'n', & read_but_dont_execute}, 
        {(char )'p', & privileged_mode}, 
        {(char )'r', & restricted}, 
        {(char )'t', & just_one_command}, 
        {(char )'u', & unbound_vars_is_error}, 
        {(char )'v', & echo_input_at_read}, 
        {(char )'x', & echo_command_at_execute}, 
        {(char )'C', & noclobber}, 
        {(char )'I', & no_invisible_vars}, 
        {(char )'P', & no_symbolic_links}, 
        {(char )'B', & brace_expansion}, 
        {(char )'H', & history_expansion}, 
        {(char)0, (int *)((void *)0)}};
int *find_flag(int name ) 
{ 
  int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! shell_flags[i].name) {
      goto while_break;
    }
    if ((int )shell_flags[i].name == name) {
      return (shell_flags[i].value);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((int *)0);
}
}
int change_flag(int flag , int on_or_off ) 
{ 
  int *value ;
  int old_value ;

  {
  if (restricted) {
    if (flag == 114) {
      if (on_or_off == 43) {
        return (-1);
      }
    }
  }
  {
  value = find_flag(flag);
  }
  if ((unsigned long )value == (unsigned long )((int *)0)) {
    return (-1);
  } else { //Added block
  if (on_or_off != 45) {
    if (on_or_off != 43) {
      return (-1);
    }
  }
  }
  old_value = *value;
  if (on_or_off == 45) {
    *value = 1;
  } else {
    *value = 0;
  }
  {
  if (flag == 109) {
    goto case_109;
  }
  if (flag == 114) {
    goto case_114;
  }
  if (flag == 72) {
    goto case_72;
  }
  if (flag == 112) {
    goto case_112;
  }
  goto switch_break;
  case_109: /* CIL Label */ 
  {
  set_job_control(on_or_off == 45);
  }
  goto switch_break;
  case_114: /* CIL Label */ 
  if (on_or_off == 45) {
    {
    maybe_make_restricted(shell_name);
    }
  }
  goto switch_break;
  case_72: /* CIL Label */ 
  if (on_or_off == 45) {
    {
    bash_initialize_history();
    }
  }
  goto switch_break;
  case_112: /* CIL Label */ 
  if (on_or_off == 43) {
    {
    disable_priv_mode();
    }
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (old_value);
}
}
char *which_set_flags(void) 
{ 
  char *temp___0 ;
  int i ;
  int string_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  temp___0 = xmalloc(((1UL + sizeof(shell_flags) / sizeof(struct flags_alist )) + (unsigned long )read_from_stdin) + (unsigned long )want_pending_command);
  string_index = 0;
  i = string_index;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! shell_flags[i].name) {
      goto while_break;
    }
    if (*(shell_flags[i].value)) {
      tmp = string_index;
      string_index ++;
      *(temp___0 + tmp) = shell_flags[i].name;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (want_pending_command) {
    tmp___0 = string_index;
    string_index ++;
    *(temp___0 + tmp___0) = (char )'c';
  }
  if (read_from_stdin) {
    tmp___1 = string_index;
    string_index ++;
    *(temp___0 + tmp___1) = (char )'s';
  }
  *(temp___0 + string_index) = (char )'\000';
  return (temp___0);
}
}
void reset_shell_flags(void) 
{ 


  {
  disallow_filename_globbing = 0;
  exit_immediately_on_error = disallow_filename_globbing;
  mark_modified_vars = exit_immediately_on_error;
  just_one_command = 0;
  read_but_dont_execute = just_one_command;
  place_keywords_in_env = read_but_dont_execute;
  echo_input_at_read = 0;
  unbound_vars_is_error = echo_input_at_read;
  noclobber = unbound_vars_is_error;
  forced_interactive = 0;
  jobs_m_flag = forced_interactive;
  echo_command_at_execute = jobs_m_flag;
  privileged_mode = 0;
  no_invisible_vars = privileged_mode;
  no_symbolic_links = no_invisible_vars;
  interactive_comments = 1;
  hashing_enabled = interactive_comments;
  asynchronous_notification = 0;
  history_expansion = 1;
  brace_expansion = 1;
  restricted = 0;
  return;
}
}
#pragma merger("0","/tmp/cil-Dk93Pefc.i","-g")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp ,
                                                                             int __sig ) ;
void maybe_set_sigchld_trap(char *command_string ) ;
char *signal_name(int sig ) ;
int maybe_call_trap_handler(int sig ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgrp)(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd ,
                                                                                __pid_t __pgrp_id ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
int sync_buffered_stream(int bfd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
void termination_unwind_protect(int sig ) ;
SigHandler *trap_to_sighandler(int sig ) ;
void trap_handler(int sig ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
pid_t pipeline_pgrp ;
int current_job ;
int previous_job ;
void making_children(void) ;
void stop_making_children(void) ;
void cleanup_the_pipeline(void) ;
void save_pipeline(int clear ) ;
void restore_pipeline(int discard ) ;
void start_pipeline(void) ;
void delete_job(int job_index , int warn_stopped ) ;
void nohup_job(int job_index ) ;
void delete_all_jobs(int running_only ) ;
void nohup_all_jobs(int running_only ) ;
void terminate_stopped_jobs(void) ;
int get_job_by_pid(pid_t pid , int block ) ;
void list_one_job(JOB *job , int format , int ignore , int job_index ) ;
void list_all_jobs(int format ) ;
void list_stopped_jobs(int format ) ;
void list_running_jobs(int format ) ;
int set_tty_state(void) ;
int wait_for_single_pid(pid_t pid ) ;
void wait_for_background_pids(void) ;
int wait_for_job(int job ) ;
int kill_pid(pid_t pid , int sig , int group ) ;
void initialize_job_signals(void) ;
void set_sigwinch_handler(void) ;
void unset_sigwinch_handler(void) ;
void unfreeze_jobs_list(void) ;
void restart_job_control(void) ;
void ignore_tty_job_signals(void) ;
void default_tty_job_signals(void) ;
extern int wait_builtin() ;
extern char *the_current_working_directory ;
extern void rl_set_screen_size(int  , int  ) ;
extern int sourcelevel ;
sigset_t top_level_mask  ;
extern sigjmp_buf wait_intr_buf ;
WORD_LIST *subst_assign_varlist ;
static int *pstatuses  ;
static int statsize  ;
static int set_job_status_and_cleanup(int job ) ;
static void setjstatus(int j ) ;
static void get_new_window_size(int from_sig ) ;
static void run_sigchld_trap(int nchild ) ;
JOB **jobs  =    (JOB **)((void *)0);
int job_slots  =    0;
int shell_tty  =    -1;
pid_t shell_pgrp  =    -1;
pid_t terminal_pgrp  =    -1;
pid_t original_pgrp  =    -1;
pid_t pipeline_pgrp  =    0;
int current_job  =    -1;
int previous_job  =    -1;
pid_t last_made_pid  =    -1;
pid_t last_asynchronous_pid  =    -1;
PROCESS *the_pipeline  =    (PROCESS *)((void *)0);
int job_control  =    1;
int already_making_children  =    0;
int check_window_size  ;
static void sigchld_handler(int sig ) ;
static int waitchld(pid_t wpid , int block ) ;
static PROCESS *find_pipeline(pid_t pid ) ;
static char *current_working_directory(void) ;
static char *job_working_directory(void) ;
static pid_t find_last_pid(int job ) ;
static pid_t last_pid(int job ) ;
static int set_new_line_discipline(int tty ) ;
static int map_over_jobs(Function *func , int arg1 , int arg2 ) ;
static int job_last_running(int job ) ;
static int job_last_stopped(int job ) ;
static int most_recent_job_in_state(int job , JOB_STATE state ) ;
static int find_job(pid_t pid ) ;
static void notify_of_job_status(void) ;
static void cleanup_dead_jobs(void) ;
static void discard_pipeline(PROCESS *chain ) ;
static void add_process(char *name , pid_t pid ) ;
static void set_current_job(int job ) ;
static void reset_current(void) ;
static void print_pipeline(PROCESS *p , int job_index , int format , FILE *stream ) ;
static void pretty_print_job(int job_index , int format , FILE *stream ) ;
static void mark_all_jobs_as_dead(void) ;
static void mark_dead_jobs_as_notified(int force ) ;
static int sigchld  ;
static int waiting_for_job  ;
static PROCESS *saved_pipeline  ;
static int saved_already_making_children  ;
static int jobs_list_frozen  ;
static char retcode_name_buffer[64]  ;
static char d[4096]  ;
static char *current_working_directory(void) 
{ 
  char *dir ;
  char const   *tmp ;

  {
  {
  dir = get_string_value("PWD");
  }
  if ((unsigned long )dir == (unsigned long )((char *)0)) {
    if (the_current_working_directory) {
      if (no_symbolic_links) {
        dir = the_current_working_directory;
      }
    }
  }
  if ((unsigned long )dir == (unsigned long )((char *)0)) {
    {
    dir = getcwd(d, sizeof(d));
    }
    if (dir) {
      dir = d;
    }
  }
  if ((unsigned long )dir == (unsigned long )((char *)0)) {
    tmp = "<unknown>";
  } else {
    tmp = (char const   *)dir;
  }
  return ((char *)tmp);
}
}
static char *job_working_directory(void) 
{ 
  char *dir ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
  dir = get_string_value("PWD");
  }
  if (dir) {
    {
    tmp = strlen((char const   *)dir);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )dir);
    }
    return (tmp___1);
  }
  {
  dir = get_working_directory((char *)"job-working-directory");
  }
  if (dir) {
    return (dir);
  }
  {
  tmp___2 = strlen("<unknown>");
  tmp___3 = xmalloc(1UL + tmp___2);
  tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )"<unknown>");
  }
  return (tmp___4);
}
}
void making_children(void) 
{ 


  {
  if (already_making_children) {
    return;
  }
  {
  already_making_children = 1;
  start_pipeline();
  }
  return;
}
}
void stop_making_children(void) 
{ 


  {
  already_making_children = 0;
  return;
}
}
void cleanup_the_pipeline(void) 
{ 


  {
  if (the_pipeline) {
    {
    discard_pipeline(the_pipeline);
    the_pipeline = (PROCESS *)((void *)0);
    }
  }
  return;
}
}
void save_pipeline(int clear ) 
{ 


  {
  saved_pipeline = the_pipeline;
  saved_already_making_children = already_making_children;
  if (clear) {
    the_pipeline = (PROCESS *)((void *)0);
  }
  return;
}
}
void restore_pipeline(int discard ) 
{ 
  PROCESS *old_pipeline ;

  {
  old_pipeline = the_pipeline;
  the_pipeline = saved_pipeline;
  already_making_children = saved_already_making_children;
  if (discard) {
    {
    discard_pipeline(old_pipeline);
    }
  }
  return;
}
}
void start_pipeline(void) 
{ 


  {
  if (the_pipeline) {
    {
    cleanup_the_pipeline();
    pipeline_pgrp = 0;
    }
  }
  return;
}
}
int stop_pipeline(int async , COMMAND *deferred ) 
{ 
  register int i ;
  register int j ;
  JOB *newjob ;
  sigset_t set ;
  sigset_t oset ;
  char *tmp ;
  char *tmp___0 ;
  register PROCESS *p ;
  int any_alive ;
  int any_stopped ;
  char *tmp___1 ;
  GENERIC_LIST *tmp___2 ;
  int tmp___3 ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  cleanup_dead_jobs();
  }
  if (job_slots == 0) {
    {
    job_slots = 8;
    tmp = xmalloc((unsigned long )job_slots * sizeof(JOB *));
    jobs = (JOB **)tmp;
    i = 0;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break;
      }
      *(jobs + i) = (JOB *)((void *)0);
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if (interactive) {
    i = job_slots;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! i) {
        goto while_break___0;
      }
      if (*(jobs + (i - 1))) {
        goto while_break___0;
      }
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    i = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break___1;
      }
      if ((unsigned long )*(jobs + i) == (unsigned long )((JOB *)0)) {
        goto while_break___1;
      }
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  if (i == job_slots) {
    {
    job_slots += 8;
    tmp___0 = xrealloc((void *)jobs, (unsigned long )(1 + job_slots) * sizeof(JOB *));
    jobs = (JOB **)tmp___0;
    j = i;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (j < job_slots)) {
        goto while_break___2;
      }
      *(jobs + j) = (JOB *)((void *)0);
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  if (the_pipeline) {
    {
    tmp___1 = xmalloc(sizeof(JOB ));
    newjob = (JOB *)tmp___1;
    p = the_pipeline;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! ((unsigned long )p->next != (unsigned long )the_pipeline)) {
        goto while_break___3;
      }
      p = p->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    p->next = (PROCESS *)((void *)0);
    if (the_pipeline) {
      if (the_pipeline->next) {
        {
        tmp___2 = reverse_list((GENERIC_LIST *)the_pipeline);
        newjob->pipe = (PROCESS *)tmp___2;
        }
      } else {
        newjob->pipe = the_pipeline;
      }
    } else {
      newjob->pipe = the_pipeline;
    }
    p = newjob->pipe;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! p->next) {
        goto while_break___4;
      }
      p = p->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    p->next = newjob->pipe;
    the_pipeline = (PROCESS *)((void *)0);
    newjob->pgrp = pipeline_pgrp;
    pipeline_pgrp = 0;
    newjob->flags = 0;
    if (job_control) {
      newjob->flags |= 4;
    }
    p = newjob->pipe;
    any_stopped = 0;
    any_alive = any_stopped;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      any_alive |= p->running;
      any_stopped |= (p->status & 255) == 127;
      p = p->next;
      if (! ((unsigned long )p != (unsigned long )newjob->pipe)) {
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    if (any_alive) {
      newjob->state = (JOB_STATE )0;
    } else {
      if (any_stopped) {
        tmp___3 = 1;
      } else {
        tmp___3 = 2;
      }
      newjob->state = (JOB_STATE )tmp___3;
    }
    {
    newjob->wd = job_working_directory();
    newjob->deferred = deferred;
    newjob->j_cleanup = (VFunction *)((void *)0);
    newjob->cleanarg = (void *)0;
    *(jobs + i) = newjob;
    }
    if ((unsigned int )newjob->state == 2U) {
      if (newjob->flags & 1) {
        {
        setjstatus(i);
        }
      }
    }
  } else {
    newjob = (JOB *)((void *)0);
  }
  if (async) {
    if (newjob) {
      newjob->flags &= -2;
    }
    {
    reset_current();
    }
  } else { //Added block
  if (newjob) {
    newjob->flags |= 1;
    if (job_control) {
      if (newjob->pgrp) {
        {
        give_terminal_to(newjob->pgrp, 0);
        }
      }
    }
  }
  }
  {
  stop_making_children();
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (current_job);
}
}
static void cleanup_dead_jobs(void) 
{ 
  register int i ;
  sigset_t set ;
  sigset_t oset ;

  {
  if (job_slots == 0) {
    return;
  } else { //Added block
  if (jobs_list_frozen) {
    return;
  }
  }
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < job_slots)) {
      goto while_break;
    }
    if (*(jobs + i)) {
      if ((unsigned int )(*(jobs + i))->state == 2U) {
        if (((*(jobs + i))->flags & 2) != 0) {
          {
          delete_job(i, 0);
          }
        }
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return;
}
}
void delete_job(int job_index , int warn_stopped ) 
{ 
  register JOB *temp___0 ;

  {
  if (job_slots == 0) {
    return;
  } else { //Added block
  if (jobs_list_frozen) {
    return;
  }
  }
  if (warn_stopped) {
    if (subshell_environment == 0) {
      if ((unsigned int )(*(jobs + job_index))->state == 1U) {
        {
        internal_warning("deleting stopped job %d with process group %d", job_index + 1,
                         (*(jobs + job_index))->pgrp);
        }
      }
    }
  }
  temp___0 = *(jobs + job_index);
  if (job_index == current_job) {
    {
    reset_current();
    }
  } else { //Added block
  if (job_index == previous_job) {
    {
    reset_current();
    }
  }
  }
  {
  *(jobs + job_index) = (JOB *)((void *)0);
  free((void *)temp___0->wd);
  discard_pipeline(temp___0->pipe);
  }
  if (temp___0->deferred) {
    {
    dispose_command(temp___0->deferred);
    }
  }
  {
  free((void *)temp___0);
  }
  return;
}
}
void nohup_job(int job_index ) 
{ 
  register JOB *temp___0 ;

  {
  if (job_slots == 0) {
    return;
  }
  temp___0 = *(jobs + job_index);
  if (temp___0) {
    temp___0->flags |= 8;
  }
  return;
}
}
static void discard_pipeline(PROCESS *chain ) 
{ 
  register PROCESS *this ;
  register PROCESS *next ;

  {
  this = chain;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    next = this->next;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (this->command) {
        {
        free((void *)this->command);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    free((void *)this);
    this = next;
    }
    if (! ((unsigned long )this != (unsigned long )chain)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void add_process(char *name , pid_t pid ) 
{ 
  PROCESS *t ;
  PROCESS *p ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(PROCESS ));
  t = (PROCESS *)tmp;
  t->next = the_pipeline;
  t->pid = pid;
  t->status = 0;
  t->running = 1;
  t->command = name;
  the_pipeline = t;
  }
  if ((unsigned long )t->next == (unsigned long )((struct process *)0)) {
    t->next = t;
  } else {
    p = t->next;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )p->next != (unsigned long )t->next)) {
        goto while_break;
      }
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
    p->next = t;
  }
  return;
}
}
static int map_over_jobs(Function *func , int arg1 , int arg2 ) 
{ 
  register int i ;
  int result ;
  sigset_t set ;
  sigset_t oset ;

  {
  if (job_slots == 0) {
    return (0);
  }
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  result = 0;
  i = result;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < job_slots)) {
      goto while_break;
    }
    if (*(jobs + i)) {
      {
      result = (*func)(*(jobs + i), arg1, arg2, i);
      }
      if (result) {
        goto while_break;
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (result);
}
}
void terminate_current_pipeline(void) 
{ 


  {
  if (pipeline_pgrp) {
    if (pipeline_pgrp != shell_pgrp) {
      {
      killpg(pipeline_pgrp, 15);
      killpg(pipeline_pgrp, 18);
      }
    }
  }
  return;
}
}
void terminate_stopped_jobs(void) 
{ 
  register int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < job_slots)) {
      goto while_break;
    }
    if (*(jobs + i)) {
      if ((unsigned int )(*(jobs + i))->state == 1U) {
        {
        killpg((*(jobs + i))->pgrp, 15);
        killpg((*(jobs + i))->pgrp, 18);
        }
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void hangup_all_jobs(void) 
{ 
  register int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < job_slots)) {
      goto while_break;
    }
    if (*(jobs + i)) {
      if (((*(jobs + i))->flags & 8) == 0) {
        {
        killpg((*(jobs + i))->pgrp, 1);
        }
      }
      if ((unsigned int )(*(jobs + i))->state == 1U) {
        {
        killpg((*(jobs + i))->pgrp, 18);
        }
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void kill_current_pipeline(void) 
{ 


  {
  {
  stop_making_children();
  start_pipeline();
  }
  return;
}
}
static PROCESS *find_pipeline(pid_t pid ) 
{ 
  int job ;
  register PROCESS *p ;
  PROCESS *tmp ;

  {
  if (the_pipeline) {
    p = the_pipeline;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (p->pid == pid) {
        return (p);
      }
      p = p->next;
      if (! ((unsigned long )p != (unsigned long )the_pipeline)) {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  job = find_job(pid);
  }
  if (job == -1) {
    tmp = (PROCESS *)((void *)0);
  } else {
    tmp = (*(jobs + job))->pipe;
  }
  return (tmp);
}
}
static int find_job(pid_t pid ) 
{ 
  register int i ;
  register PROCESS *p ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < job_slots)) {
      goto while_break;
    }
    if (*(jobs + i)) {
      p = (*(jobs + i))->pipe;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (p->pid == pid) {
          return (i);
        }
        p = p->next;
        if (! ((unsigned long )p != (unsigned long )(*(jobs + i))->pipe)) {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
int get_job_by_pid(pid_t pid , int block ) 
{ 
  int job ;
  sigset_t set ;
  sigset_t oset ;

  {
  if (block) {
    {
    sigemptyset(& set);
    }
  }
  {
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  job = find_job(pid);
  }
  if (block) {
    {
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
  }
  return (job);
}
}
void describe_pid(pid_t pid ) 
{ 
  int job ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  job = find_job(pid);
  }
  if (job != -1) {
    {
    printf((char const   * __restrict  )"[%d] %d\n", job + 1, pid);
    }
  } else {
    {
    programming_error("describe_pid: %d: no such pid", pid);
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return;
}
}
static char *temp  ;
static char *printable_job_status(int j , PROCESS *p , int format ) 
{ 
  int es ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  temp = (char *)"Done";
  if ((unsigned int )(*(jobs + j))->state == 1U) {
    if (format == 0) {
      if (posixly_correct == 0) {
        temp = (char *)"Stopped";
      } else { //Added block
      if ((unsigned long )p == (unsigned long )((PROCESS *)0)) {
        temp = (char *)"Stopped";
      } else { //Added block
      if (((p->status & 255) == 127) == 0) {
        temp = (char *)"Stopped";
      } else {
        {
        temp = retcode_name_buffer;
        tmp = signal_name((p->status & 65280) >> 8);
        sprintf((char * __restrict  )temp, (char const   * __restrict  )"Stopped(%s)",
                tmp);
        }
      }
      }
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((unsigned int )(*(jobs + j))->state == 0U) {
    temp = (char *)"Running";
  } else { //Added block
  if ((p->status & 255) == 127) {
    {
    tmp___0 = strsignal((p->status & 65280) >> 8);
    temp = tmp___0;
    }
  } else { //Added block
  if ((int )((signed char )((p->status & 127) + 1)) >> 1 > 0) {
    {
    tmp___1 = strsignal(p->status & 127);
    temp = tmp___1;
    }
  } else { //Added block
  if ((p->status & 127) == 0) {
    temp = retcode_name_buffer;
    es = (p->status & 65280) >> 8;
    if (es == 0) {
      {
      strcpy((char * __restrict  )temp, (char const   * __restrict  )"Done");
      }
    } else { //Added block
    if (posixly_correct) {
      {
      sprintf((char * __restrict  )temp, (char const   * __restrict  )"Done(%d)",
              es);
      }
    } else {
      {
      sprintf((char * __restrict  )temp, (char const   * __restrict  )"Exit %d", es);
      }
    }
    }
  } else {
    temp = (char *)"Unknown status";
  }
  }
  }
  }
  }
  return (temp);
}
}
static void print_pipeline(PROCESS *p , int job_index , int format , FILE *stream ) 
{ 
  PROCESS *first ;
  PROCESS *last ;
  PROCESS *show ;
  int es ;
  int name_padding ;
  char *temp___0 ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )p == (unsigned long )((PROCESS *)0)) {
    return;
  }
  last = p;
  first = last;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )last->next != (unsigned long )first)) {
      goto while_break;
    }
    last = last->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if ((unsigned long )p != (unsigned long )first) {
      if (format) {
        tmp = "     ";
      } else {
        tmp = " |";
      }
      {
      fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp);
      }
    }
    if (format != 0) {
      {
      fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%5d", p->pid);
      }
    }
    {
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )" ");
    }
    if (format > -1) {
      if (job_index >= 0) {
        if (format) {
          show = p;
        } else {
          show = last;
        }
        {
        temp___0 = printable_job_status(job_index, show, format);
        }
        if ((unsigned long )p != (unsigned long )first) {
          if (format) {
            if (show->running == first->running) {
              if (show->status == first->status) {
                temp___0 = (char *)"";
              }
            }
          } else {
            temp___0 = (char *)((void *)0);
          }
        }
        if (temp___0) {
          {
          fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s",
                  temp___0);
          }
          if (temp___0) {
            if (*(temp___0 + 0)) {
              if (*(temp___0 + 1)) {
                if (*(temp___0 + 2)) {
                  {
                  tmp___0 = strlen((char const   *)temp___0);
                  tmp___1 = tmp___0;
                  }
                } else {
                  tmp___1 = (size_t )2;
                }
                tmp___2 = tmp___1;
              } else {
                tmp___2 = (size_t )1;
              }
              es = (int )tmp___2;
            } else {
              es = 0;
            }
          } else {
            es = 0;
          }
          if (es == 0) {
            es = 2;
          }
          {
          name_padding = 24 - es;
          fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%*s",
                  name_padding, "");
          }
          if (((show->status & 255) == 127) == 0) {
            if (show->status & 128) {
              {
              fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"(core dumped) ");
              }
            }
          }
        }
      }
    }
    if ((unsigned long )p != (unsigned long )first) {
      if (format) {
        {
        fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"| ");
        }
      }
    }
    if (p->command) {
      {
      fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s", p->command);
      }
    }
    if ((unsigned long )p == (unsigned long )last) {
      if (job_index >= 0) {
        {
        temp___0 = current_working_directory();
        }
        if ((unsigned int )(*(jobs + job_index))->state == 0U) {
          if ((((*(jobs + job_index))->flags & 1) != 0) == 0) {
            {
            fprintf((FILE * __restrict  )stream, (char const   * __restrict  )" &");
            }
          }
        }
        {
        tmp___4 = strcmp((char const   *)temp___0, (char const   *)(*(jobs + job_index))->wd);
        }
        if (tmp___4 != 0) {
          {
          tmp___3 = polite_directory_format((*(jobs + job_index))->wd);
          fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"  (wd: %s)",
                  tmp___3);
          }
        }
      }
    }
    if (format) {
      goto _L;
    } else { //Added block
    if ((unsigned long )p == (unsigned long )last) {
      _L: 
      if (asynchronous_notification) {
        if (interactive) {
          {
          fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\r\n");
          }
        } else {
          {
          fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\n");
          }
        }
      } else {
        {
        fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\n");
        }
      }
    }
    }
    if ((unsigned long )p == (unsigned long )last) {
      goto while_break___0;
    }
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  fflush(stream);
  }
  return;
}
}
static void pretty_print_job(int job_index , int format , FILE *stream ) 
{ 
  register PROCESS *p ;
  sigset_t set ;
  sigset_t oset ;
  int tmp ;
  int tmp___0 ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  }
  if (format == 2) {
    {
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%d\n", ((*(jobs + job_index))->pipe)->pid);
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
    return;
  }
  if (format == 3) {
    if (((*(jobs + job_index))->flags & 2) != 0) {
      {
      sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
      }
      return;
    }
    format = 0;
  }
  if (format != 4) {
    if (job_index == current_job) {
      tmp___0 = '+';
    } else {
      if (job_index == previous_job) {
        tmp = '-';
      } else {
        tmp = ' ';
      }
      tmp___0 = tmp;
    }
    {
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"[%d]%c ", job_index + 1,
            tmp___0);
    }
  }
  if (format == 4) {
    format = 1;
  }
  {
  p = (*(jobs + job_index))->pipe;
  print_pipeline(p, job_index, format, stream);
  (*(jobs + job_index))->flags |= 2;
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return;
}
}
static int print_job(JOB *job , int format , int state , int job_index ) 
{ 


  {
  if (state == -1) {
    {
    pretty_print_job(job_index, format, stdout);
    }
  } else { //Added block
  if ((unsigned int )((JOB_STATE )state) == (unsigned int )job->state) {
    {
    pretty_print_job(job_index, format, stdout);
    }
  }
  }
  return (0);
}
}
void list_one_job(JOB *job , int format , int ignore , int job_index ) 
{ 


  {
  {
  print_job(job, format, -1, job_index);
  }
  return;
}
}
void list_stopped_jobs(int format ) 
{ 


  {
  {
  cleanup_dead_jobs();
  map_over_jobs((Function *)(& print_job), format, 1);
  }
  return;
}
}
void list_running_jobs(int format ) 
{ 


  {
  {
  cleanup_dead_jobs();
  map_over_jobs((Function *)(& print_job), format, 0);
  }
  return;
}
}
void list_all_jobs(int format ) 
{ 


  {
  {
  cleanup_dead_jobs();
  map_over_jobs((Function *)(& print_job), format, -1);
  }
  return;
}
}
pid_t make_child(char *command , int async_p ) 
{ 
  sigset_t set ;
  sigset_t oset ;
  pid_t pid ;
  pid_t mypid ;
  int tmp ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigaddset(& set, 2);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  making_children();
  }
  if (default_buffered_input != -1) {
    if (! async_p) {
      {
      sync_buffered_stream(default_buffered_input);
      }
    } else { //Added block
    if (default_buffered_input > 0) {
      {
      sync_buffered_stream(default_buffered_input);
      }
    }
    }
  }
  {
  pid = fork();
  }
  if (pid < 0) {
    {
    sys_error("fork");
    terminate_current_pipeline();
    }
    if (the_pipeline) {
      {
      kill_current_pipeline();
      }
    }
    {
    throw_to_top_level();
    }
  }
  if (pid == 0) {
    {
    mypid = getpid();
    unset_bash_input(0);
    sigprocmask(2, (sigset_t const   * __restrict  )(& top_level_mask), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
    if (job_control) {
      if (pipeline_pgrp == 0) {
        pipeline_pgrp = mypid;
      }
      if (pipeline_pgrp == shell_pgrp) {
        {
        ignore_tty_job_signals();
        }
      } else {
        {
        default_tty_job_signals();
        }
      }
      {
      tmp = setpgid(mypid, pipeline_pgrp);
      }
      if (tmp < 0) {
        {
        sys_error("child setpgid (%d to %d)", mypid, pipeline_pgrp);
        }
      }
      if (async_p == 0) {
        if (pipeline_pgrp != shell_pgrp) {
          {
          give_terminal_to(pipeline_pgrp, 0);
          }
        }
      }
    } else {
      if (pipeline_pgrp == 0) {
        pipeline_pgrp = shell_pgrp;
      }
      {
      default_tty_job_signals();
      }
    }
    if (async_p) {
      {
      last_asynchronous_pid = getpid();
      }
    }
  } else {
    if (job_control) {
      if (pipeline_pgrp == 0) {
        pipeline_pgrp = pid;
      }
      {
      setpgid(pid, pipeline_pgrp);
      }
    } else { //Added block
    if (pipeline_pgrp == 0) {
      pipeline_pgrp = shell_pgrp;
    }
    }
    {
    add_process(command, pid);
    }
    if (async_p) {
      last_asynchronous_pid = pid;
    }
    {
    last_made_pid = pid;
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
  }
  return (pid);
}
}
void ignore_tty_job_signals(void) 
{ 


  {
  {
  set_signal_handler(20, (SigHandler *)((void (*)(int  ))1));
  set_signal_handler(21, (SigHandler *)((void (*)(int  ))1));
  set_signal_handler(22, (SigHandler *)((void (*)(int  ))1));
  }
  return;
}
}
void default_tty_job_signals(void) 
{ 


  {
  {
  set_signal_handler(20, (SigHandler *)((void (*)(int  ))0));
  set_signal_handler(21, (SigHandler *)((void (*)(int  ))0));
  set_signal_handler(22, (SigHandler *)((void (*)(int  ))0));
  }
  return;
}
}
static struct termios shell_tty_info  ;
int get_tty_state(void) 
{ 
  int tty ;
  int tmp ;
  int tmp___0 ;

  {
  if (shell_tty != -1) {
    tty = shell_tty;
  } else {
    {
    tmp = fileno(stderr);
    tty = tmp;
    }
  }
  if (tty != -1) {
    {
    tmp___0 = tcgetattr(tty, & shell_tty_info);
    }
    if (tmp___0 < 0) {
      return (-1);
    }
    if (check_window_size) {
      {
      get_new_window_size(0);
      }
    }
  }
  return (0);
}
}
int set_tty_state(void) 
{ 
  int tty ;
  int tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
  if (shell_tty != -1) {
    tty = shell_tty;
  } else {
    {
    tmp = fileno(stderr);
    tty = tmp;
    }
  }
  if (tty != -1) {
    {
    tmp___1 = tcsetattr(tty, 1, (struct termios  const  *)(& shell_tty_info));
    }
    if (tmp___1 < 0) {
      if (interactive) {
        {
        tmp___0 = getpid();
        sys_error("[%d: %d] tcsetattr", tmp___0, shell_level);
        }
      }
      return (-1);
    }
  }
  return (0);
}
}
static pid_t find_last_pid(int job ) 
{ 
  register PROCESS *p ;

  {
  p = (*(jobs + job))->pipe;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p->next != (unsigned long )(*(jobs + job))->pipe)) {
      goto while_break;
    }
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (p->pid);
}
}
static pid_t last_pid(int job ) 
{ 
  pid_t pid ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  pid = find_last_pid(job);
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (pid);
}
}
int wait_for_single_pid(pid_t pid ) 
{ 
  register PROCESS *child ;
  sigset_t set ;
  sigset_t oset ;
  int r ;
  int job ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  child = find_pipeline(pid);
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  if ((unsigned long )child == (unsigned long )((PROCESS *)0)) {
    {
    internal_error("wait: pid %d is not a child of this shell", pid);
    }
    return (127);
  }
  {
  r = wait_for(pid);
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  job = find_job(pid);
  }
  if (job != -1) {
    if (*(jobs + job)) {
      if ((unsigned int )(*(jobs + job))->state == 2U) {
        (*(jobs + job))->flags |= 2;
      }
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (r);
}
}
void wait_for_background_pids(void) 
{ 
  register int i ;
  register int count ;
  register int r ;
  register int waited_for ;
  sigset_t set ;
  sigset_t oset ;
  pid_t pid ;
  int *tmp ;
  int *tmp___0 ;

  {
  waited_for = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    sigemptyset(& set);
    sigaddset(& set, 17);
    sigemptyset(& oset);
    sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
    count = 0;
    i = 0;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break___0;
      }
      if (*(jobs + i)) {
        if ((unsigned int )(*(jobs + i))->state == 0U) {
          if ((((*(jobs + i))->flags & 1) != 0) == 0) {
            count ++;
            goto while_break___0;
          }
        }
      }
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (count == 0) {
      {
      sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
      }
      goto while_break;
    }
    i = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break___1;
      }
      if (*(jobs + i)) {
        if ((unsigned int )(*(jobs + i))->state == 0U) {
          if ((((*(jobs + i))->flags & 1) != 0) == 0) {
            {
            pid = last_pid(i);
            sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
            }
            if (interrupt_state) {
              {
              throw_to_top_level();
              }
            }
            {
            tmp = __errno_location();
            *tmp = 0;
            r = wait_for_single_pid(pid);
            }
            if (r == -1) {
              {
              tmp___0 = __errno_location();
              }
              if (*tmp___0 == 10) {
                {
                mark_all_jobs_as_dead();
                }
              }
            } else {
              waited_for ++;
            }
            goto while_break___1;
          }
        }
      }
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  mark_dead_jobs_as_notified(1);
  cleanup_dead_jobs();
  }
  return;
}
}
static SigHandler *old_sigint_handler  =    & wait_for_background_pids;
static void restore_sigint_handler(void) 
{ 


  {
  if ((unsigned long )old_sigint_handler != (unsigned long )(& wait_for_background_pids)) {
    {
    set_signal_handler(2, old_sigint_handler);
    old_sigint_handler = & wait_for_background_pids;
    }
  }
  return;
}
}
static int wait_sigint_received  ;
static void wait_sigint_handler(int sig ) 
{ 
  SigHandler *sigint_handler ;
  int tmp ;

  {
  if (interrupt_immediately) {
    goto _L;
  } else { //Added block
  if (this_shell_builtin) {
    if ((unsigned long )this_shell_builtin == (unsigned long )(& wait_builtin)) {
      _L: 
      {
      last_command_exit_value = 1;
      restore_sigint_handler();
      }
      if (this_shell_builtin) {
        if ((unsigned long )this_shell_builtin == (unsigned long )(& wait_builtin)) {
          {
          tmp = signal_is_trapped(2);
          }
          if (tmp) {
            {
            sigint_handler = trap_to_sighandler(2);
            }
            if ((unsigned long )sigint_handler == (unsigned long )(& trap_handler)) {
              {
              interrupt_immediately = 0;
              trap_handler(2);
              siglongjmp(wait_intr_buf, 1);
              }
            }
          }
        }
      }
      interrupt_state ++;
      if (interrupt_state) {
        {
        throw_to_top_level();
        }
      }
    }
  }
  }
  wait_sigint_received = 1;
  return;
}
}
static int process_exit_status(WAIT status ) 
{ 


  {
  if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
    return (128 + (status & 127));
  } else { //Added block
  if (((status & 255) == 127) == 0) {
    return ((status & 65280) >> 8);
  } else {
    return (0);
  }
  }
}
}
static WAIT raw_job_exit_status(int job ) 
{ 
  register PROCESS *p ;

  {
  p = (*(jobs + job))->pipe;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p->next != (unsigned long )(*(jobs + job))->pipe)) {
      goto while_break;
    }
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (p->status);
}
}
static WAIT job_exit_status(int job ) 
{ 
  WAIT tmp ;
  int tmp___0 ;

  {
  {
  tmp = raw_job_exit_status(job);
  tmp___0 = process_exit_status(tmp);
  }
  return (tmp___0);
}
}
int wait_for(pid_t pid ) 
{ 
  int job ;
  int termination_state ;
  int r ;
  WAIT s ;
  register PROCESS *child ;
  sigset_t set ;
  sigset_t oset ;
  register PROCESS *p ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  wait_sigint_received = 0;
  }
  if (job_control == 0) {
    {
    old_sigint_handler = set_signal_handler(2, (SigHandler *)(& wait_sigint_handler));
    }
  }
  termination_state = last_command_exit_value;
  if (interactive) {
    if (job_control == 0) {
      if (interrupt_state) {
        {
        throw_to_top_level();
        }
      }
    }
  }
  job = -1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      child = find_pipeline(pid);
      }
      if ((unsigned long )child == (unsigned long )((PROCESS *)0)) {
        {
        give_terminal_to(shell_pgrp, 0);
        sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
        internal_error("wait_for: No record of process %d", pid);
        restore_sigint_handler();
        termination_state = 127;
        }
        return (termination_state);
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (job == -1) {
      {
      job = find_job(pid);
      }
    }
    if (child->running) {
      goto _L;
    } else { //Added block
    if (job != -1) {
      if ((unsigned int )(*(jobs + job))->state == 0U) {
        _L: 
        {
        waiting_for_job = 1;
        r = waitchld(pid, 1);
        waiting_for_job = 0;
        }
        if (r == -1) {
          {
          tmp = __errno_location();
          }
          if (*tmp == 10) {
            if ((unsigned long )this_shell_builtin == (unsigned long )(& wait_builtin)) {
              termination_state = -1;
              goto wait_for_return;
            }
          }
        }
        if (r == -1) {
          {
          tmp___0 = __errno_location();
          }
          if (*tmp___0 == 10) {
            child->running = 0;
            child->status = 0;
            if (job != -1) {
              (*(jobs + job))->state = (JOB_STATE )2;
            }
          }
        }
      }
    }
    }
    if (interactive) {
      if (job_control == 0) {
        if (interrupt_state) {
          {
          throw_to_top_level();
          }
        }
      }
    }
    if (! child->running) {
      if (job != -1) {
        if (! ((unsigned int )(*(jobs + job))->state == 0U)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (job != -1) {
    {
    termination_state = job_exit_status(job);
    }
  } else {
    {
    termination_state = process_exit_status(child->status);
    }
  }
  if (job == -1) {
    {
    give_terminal_to(shell_pgrp, 0);
    }
  } else { //Added block
  if (((*(jobs + job))->flags & 4) != 0) {
    {
    give_terminal_to(shell_pgrp, 0);
    }
  }
  }
  if (job != -1) {
    if (interactive_shell) {
      if (subshell_environment == 0) {
        p = (*(jobs + job))->pipe;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          s = p->status;
          if ((int )((signed char )((s & 127) + 1)) >> 1 > 0) {
            goto while_break___1;
          } else { //Added block
          if ((s & 255) == 127) {
            goto while_break___1;
          }
          }
          p = p->next;
          if (! ((unsigned long )p != (unsigned long )(*(jobs + job))->pipe)) {
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        if ((int )((signed char )((s & 127) + 1)) >> 1 > 0) {
          goto _L___0;
        } else { //Added block
        if ((s & 255) == 127) {
          _L___0: 
          {
          set_tty_state();
          }
          if (check_window_size) {
            if (job == current_job) {
              {
              get_new_window_size(0);
              }
            }
          }
        } else {
          {
          get_tty_state();
          }
        }
        }
        if (job_control) {
          if (((*(jobs + job))->flags & 4) != 0) {
            if (((*(jobs + job))->flags & 1) != 0) {
              if ((int )((signed char )((s & 127) + 1)) >> 1 > 0) {
                if ((s & 127) == 2) {
                  {
                  tmp___1 = signal_is_trapped(2);
                  }
                  if (tmp___1 == 0) {
                    if (loop_level) {
                      interrupt_state ++;
                    } else {
                      {
                      putchar('\n');
                      fflush(stdout);
                      }
                    }
                  } else {
                    {
                    putchar('\n');
                    fflush(stdout);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
    notify_and_cleanup();
    }
  }
  wait_for_return: 
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  restore_sigint_handler();
  }
  return (termination_state);
}
}
int wait_for_job(int job ) 
{ 
  pid_t pid ;
  int r ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  }
  if ((unsigned int )(*(jobs + job))->state == 1U) {
    {
    internal_warning("wait_for_job: job %d is stopped", job + 1);
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  pid = last_pid(job);
  r = wait_for(pid);
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  }
  if (job != -1) {
    if (*(jobs + job)) {
      if ((unsigned int )(*(jobs + job))->state == 2U) {
        (*(jobs + job))->flags |= 2;
      }
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (r);
}
}
void notify_and_cleanup(void) 
{ 


  {
  if (jobs_list_frozen) {
    return;
  }
  if (interactive) {
    {
    notify_of_job_status();
    }
  } else { //Added block
  if (interactive_shell == 0) {
    {
    notify_of_job_status();
    }
  } else { //Added block
  if (sourcelevel) {
    {
    notify_of_job_status();
    }
  }
  }
  }
  {
  cleanup_dead_jobs();
  }
  return;
}
}
void reap_dead_jobs(void) 
{ 


  {
  {
  mark_dead_jobs_as_notified(0);
  cleanup_dead_jobs();
  }
  return;
}
}
static int most_recent_job_in_state(int job , JOB_STATE state ) 
{ 
  register int i ;
  register int result ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  result = -1;
  i = job - 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i >= 0)) {
      goto while_break;
    }
    if (*(jobs + i)) {
      if ((unsigned int )(*(jobs + i))->state == (unsigned int )state) {
        result = i;
        goto while_break;
      }
    }
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (result);
}
}
static int job_last_stopped(int job ) 
{ 
  int tmp ;

  {
  {
  tmp = most_recent_job_in_state(job, (JOB_STATE )1);
  }
  return (tmp);
}
}
static int job_last_running(int job ) 
{ 
  int tmp ;

  {
  {
  tmp = most_recent_job_in_state(job, (JOB_STATE )0);
  }
  return (tmp);
}
}
static void set_current_job(int job ) 
{ 
  int candidate ;
  int tmp ;
  int tmp___0 ;

  {
  if (current_job != job) {
    previous_job = current_job;
    current_job = job;
  }
  if (previous_job != current_job) {
    if (previous_job != -1) {
      if (*(jobs + previous_job)) {
        if ((unsigned int )(*(jobs + previous_job))->state == 1U) {
          return;
        }
      }
    }
  }
  candidate = -1;
  if ((unsigned int )(*(jobs + current_job))->state == 1U) {
    {
    candidate = job_last_stopped(current_job);
    }
    if (candidate != -1) {
      previous_job = candidate;
      return;
    }
  }
  if ((unsigned int )(*(jobs + current_job))->state == 0U) {
    {
    tmp = job_last_running(current_job);
    candidate = tmp;
    }
  } else {
    {
    tmp___0 = job_last_running(job_slots);
    candidate = tmp___0;
    }
  }
  if (candidate != -1) {
    previous_job = candidate;
    return;
  }
  previous_job = current_job;
  return;
}
}
static void reset_current(void) 
{ 
  int candidate ;

  {
  if (job_slots) {
    if (current_job != -1) {
      if (*(jobs + current_job)) {
        if ((unsigned int )(*(jobs + current_job))->state == 1U) {
          candidate = current_job;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    candidate = -1;
    if (previous_job != -1) {
      if (*(jobs + previous_job)) {
        if ((unsigned int )(*(jobs + previous_job))->state == 1U) {
          candidate = previous_job;
        }
      }
    }
    if (candidate == -1) {
      {
      candidate = job_last_stopped(job_slots);
      }
    }
    if (candidate == -1) {
      {
      candidate = job_last_running(job_slots);
      }
    }
  }
  if (candidate != -1) {
    {
    set_current_job(candidate);
    }
  } else {
    previous_job = -1;
    current_job = previous_job;
  }
  return;
}
}
static void set_job_running(int job ) 
{ 
  register PROCESS *p ;

  {
  p = (*(jobs + job))->pipe;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((p->status & 255) == 127) {
      p->running = 1;
    }
    p = p->next;
    if (! ((unsigned long )p != (unsigned long )(*(jobs + job))->pipe)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  (*(jobs + job))->state = (JOB_STATE )0;
  return;
}
}
static struct termios save_stty  ;
int start_job(int job , int foreground ) 
{ 
  register PROCESS *p ;
  int already_running ;
  sigset_t set ;
  sigset_t oset ;
  char *wd ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  pid_t pid ;
  int s ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  }
  if ((unsigned int )(*(jobs + job))->state == 2U) {
    {
    internal_error("%s: job has terminated", this_command_name);
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
    return (-1);
  }
  already_running = (unsigned int )(*(jobs + job))->state == 0U;
  if (foreground == 0) {
    if (already_running) {
      {
      internal_error("%s: bg background job?", this_command_name);
      sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
      }
      return (-1);
    }
  }
  {
  wd = current_working_directory();
  (*(jobs + job))->flags &= -3;
  }
  if (foreground) {
    {
    set_current_job(job);
    (*(jobs + job))->flags |= 1;
    }
  }
  p = (*(jobs + job))->pipe;
  if (foreground == 0) {
    if (job == current_job) {
      tmp___0 = '+';
    } else {
      if (job == previous_job) {
        tmp = '-';
      } else {
        tmp = ' ';
      }
      tmp___0 = tmp;
    }
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%d]%c ", job + 1,
            tmp___0);
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )p->next != (unsigned long )(*(jobs + job))->pipe) {
      tmp___1 = " | ";
    } else {
      tmp___1 = "";
    }
    if (p->command) {
      tmp___2 = (char const   *)p->command;
    } else {
      tmp___2 = "";
    }
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s%s", tmp___2,
            tmp___1);
    p = p->next;
    }
    if (! ((unsigned long )p != (unsigned long )(*(jobs + job))->pipe)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (foreground == 0) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" &");
    }
  }
  {
  tmp___4 = strcmp((char const   *)wd, (char const   *)(*(jobs + job))->wd);
  }
  if (tmp___4 != 0) {
    {
    tmp___3 = polite_directory_format((*(jobs + job))->wd);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t(wd: %s)",
            tmp___3);
    }
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
  if (already_running == 0) {
    {
    set_job_running(job);
    }
  }
  if (foreground) {
    {
    get_tty_state();
    save_stty = shell_tty_info;
    }
    if (((*(jobs + job))->flags & 4) != 0) {
      {
      give_terminal_to((*(jobs + job))->pgrp, 0);
      }
    }
  } else {
    (*(jobs + job))->flags &= -2;
  }
  if (already_running == 0) {
    {
    (*(jobs + job))->flags |= 2;
    killpg((*(jobs + job))->pgrp, 18);
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  if (foreground) {
    {
    pid = last_pid(job);
    s = wait_for(pid);
    shell_tty_info = save_stty;
    set_tty_state();
    }
    return (s);
  } else {
    {
    sigemptyset(& set);
    sigaddset(& set, 17);
    sigemptyset(& oset);
    sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
    reset_current();
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
    return (0);
  }
}
}
int kill_pid(pid_t pid , int sig , int group ) 
{ 
  register PROCESS *p ;
  int job ;
  int result ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  p = find_pipeline(pid);
  job = find_job(pid);
  result = 0;
  }
  if (group) {
    if (job != -1) {
      (*(jobs + job))->flags &= -3;
      if ((*(jobs + job))->pgrp == shell_pgrp) {
        p = (*(jobs + job))->pipe;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          {
          kill(p->pid, sig);
          }
          if (p->running == 0) {
            if (sig == 15) {
              {
              kill(p->pid, 18);
              }
            } else { //Added block
            if (sig == 1) {
              {
              kill(p->pid, 18);
              }
            }
            }
          }
          p = p->next;
          if (! ((unsigned long )p != (unsigned long )(*(jobs + job))->pipe)) {
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
        result = killpg((*(jobs + job))->pgrp, sig);
        }
        if (p) {
          if ((unsigned int )(*(jobs + job))->state == 1U) {
            if (sig == 15) {
              {
              killpg((*(jobs + job))->pgrp, 18);
              }
            } else { //Added block
            if (sig == 1) {
              {
              killpg((*(jobs + job))->pgrp, 18);
              }
            }
            }
          }
        }
        if (p) {
          if ((unsigned int )(*(jobs + job))->state == 1U) {
            if (sig == 18) {
              {
              set_job_running(job);
              (*(jobs + job))->flags &= -2;
              (*(jobs + job))->flags |= 2;
              }
            }
          }
        }
      }
    } else {
      {
      result = killpg(pid, sig);
      }
    }
  } else {
    {
    result = kill(pid, sig);
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (result);
}
}
static void sigchld_handler(int sig ) 
{ 
  int n ;
  int oerrno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
  tmp = __errno_location();
  oerrno = *tmp;
  sigchld ++;
  n = 0;
  }
  if (waiting_for_job == 0) {
    {
    n = waitchld(-1, 0);
    }
  }
  {
  tmp___0 = __errno_location();
  *tmp___0 = oerrno;
  }
  return;
}
}
static int waitchld(pid_t wpid , int block ) 
{ 
  WAIT status ;
  PROCESS *child ;
  pid_t pid ;
  int call_set_current ;
  int last_stopped_job ;
  int job ;
  int children_exited ;
  int waitpid_flags ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  children_exited = 0;
  call_set_current = children_exited;
  last_stopped_job = -1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (job_control) {
      if (subshell_environment == 0) {
        waitpid_flags = 2;
      } else {
        waitpid_flags = 0;
      }
    } else {
      waitpid_flags = 0;
    }
    if (sigchld) {
      waitpid_flags |= 1;
    } else { //Added block
    if (block == 0) {
      waitpid_flags |= 1;
    }
    }
    {
    pid = waitpid(-1, & status, waitpid_flags);
    }
    if (sigchld > 0) {
      if (waitpid_flags & 1) {
        sigchld --;
      }
    }
    if (pid < 0) {
      {
      tmp = __errno_location();
      }
      if (*tmp == 10) {
        if (children_exited == 0) {
          return (-1);
        } else {
          goto while_break;
        }
      }
    }
    if (pid <= 0) {
      goto __Cont;
    }
    {
    children_exited ++;
    child = find_pipeline(pid);
    }
    if ((unsigned long )child == (unsigned long )((PROCESS *)0)) {
      goto __Cont;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (child->pid != pid)) {
        goto while_break___0;
      }
      child = child->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    child->status = status;
    child->running = 0;
    job = find_job(pid);
    }
    if (job == -1) {
      goto __Cont;
    }
    {
    tmp___0 = set_job_status_and_cleanup(job);
    call_set_current += tmp___0;
    }
    if ((unsigned int )(*(jobs + job))->state == 1U) {
      last_stopped_job = job;
    } else { //Added block
    if ((unsigned int )(*(jobs + job))->state == 2U) {
      if (last_stopped_job == job) {
        last_stopped_job = -1;
      }
    }
    }
    __Cont: 
    if (sigchld) {
      goto _L;
    } else { //Added block
    if (block == 0) {
      _L: 
      if (! (pid > 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (call_set_current) {
    if (last_stopped_job != -1) {
      {
      set_current_job(last_stopped_job);
      }
    } else {
      {
      reset_current();
      }
    }
  }
  if (job_control) {
    {
    tmp___1 = signal_is_trapped(17);
    }
    if (tmp___1) {
      if (children_exited) {
        if ((unsigned long )trap_list[17] != (unsigned long )((char *)((void (*)(int  ))1))) {
          {
          run_sigchld_trap(children_exited);
          }
        }
      }
    }
  }
  if (asynchronous_notification) {
    if (interactive) {
      {
      notify_of_job_status();
      }
    }
  }
  return (children_exited);
}
}
static int set_job_status_and_cleanup(int job ) 
{ 
  PROCESS *child ;
  int tstatus ;
  int job_state ;
  int any_stopped ;
  int any_tstped ;
  int call_set_current ;
  SigHandler *temp_handler ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  child = (*(jobs + job))->pipe;
  (*(jobs + job))->flags &= -3;
  call_set_current = 0;
  any_tstped = 0;
  any_stopped = any_tstped;
  job_state = any_stopped;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    job_state |= child->running;
    if (child->running == 0) {
      if ((child->status & 255) == 127) {
        any_stopped = 1;
        if (interactive) {
          if (job_control) {
            if ((child->status & 65280) >> 8 == 20) {
              tmp = 1;
            } else {
              tmp = 0;
            }
          } else {
            tmp = 0;
          }
        } else {
          tmp = 0;
        }
        any_tstped |= tmp;
      }
    }
    child = child->next;
    if (! ((unsigned long )child != (unsigned long )(*(jobs + job))->pipe)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (job_state != 0) {
    return (0);
  }
  if (any_stopped) {
    (*(jobs + job))->state = (JOB_STATE )1;
    (*(jobs + job))->flags &= -2;
    call_set_current ++;
    if (any_tstped) {
      if (loop_level) {
        breaking = loop_level;
      }
    }
  } else {
    (*(jobs + job))->state = (JOB_STATE )2;
    if (((*(jobs + job))->flags & 1) != 0) {
      {
      setjstatus(job);
      }
    }
    if ((*(jobs + job))->j_cleanup) {
      {
      (*((*(jobs + job))->j_cleanup))((*(jobs + job))->cleanarg);
      (*(jobs + job))->j_cleanup = (VFunction *)((void *)0);
      }
    }
  }
  if ((unsigned int )(*(jobs + job))->state == 2U) {
    if (wait_sigint_received) {
      if (interactive_shell == 0) {
        if (((int )((signed char )((child->status & 127) + 1)) >> 1 > 0) == 0) {
          if (((*(jobs + job))->flags & 1) != 0) {
            {
            tmp___2 = signal_is_trapped(2);
            }
            if (tmp___2) {
              {
              wait_sigint_received = 0;
              last_command_exit_value = process_exit_status(child->status);
              jobs_list_frozen = 1;
              tstatus = maybe_call_trap_handler(2);
              jobs_list_frozen = 0;
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if (wait_sigint_received) {
      if ((child->status & 127) == 2) {
        if (((*(jobs + job))->flags & 1) != 0) {
          if ((((*(jobs + job))->flags & 4) != 0) == 0) {
            {
            wait_sigint_received = 0;
            tmp___0 = signal_is_trapped(2);
            }
            if (tmp___0) {
              {
              last_command_exit_value = process_exit_status(child->status);
              }
            }
            {
            jobs_list_frozen = 1;
            tstatus = maybe_call_trap_handler(2);
            jobs_list_frozen = 0;
            }
            if (tstatus == 0) {
              if ((unsigned long )old_sigint_handler != (unsigned long )(& wait_for_background_pids)) {
                temp_handler = old_sigint_handler;
                if ((unsigned long )temp_handler == (unsigned long )(& trap_handler)) {
                  {
                  tmp___1 = signal_is_trapped(2);
                  }
                  if (tmp___1 == 0) {
                    {
                    temp_handler = trap_to_sighandler(2);
                    }
                  }
                }
                {
                restore_sigint_handler();
                }
                if ((unsigned long )temp_handler == (unsigned long )((void (*)(int  ))0)) {
                  {
                  termination_unwind_protect(2);
                  }
                } else { //Added block
                if ((unsigned long )temp_handler != (unsigned long )((void (*)(int  ))1)) {
                  {
                  (*temp_handler)(2);
                  }
                }
                }
              }
            }
          }
        }
      }
    }
    }
  }
  return (call_set_current);
}
}
static void setjstatus(int j ) 
{ 
  register int i ;
  register PROCESS *p ;
  char *tmp ;
  int tmp___0 ;

  {
  i = 1;
  p = (*(jobs + j))->pipe;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p->next != (unsigned long )(*(jobs + j))->pipe)) {
      goto while_break;
    }
    p = p->next;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  i ++;
  if (statsize <= i) {
    {
    tmp = xrealloc((void *)pstatuses, (unsigned long )i * sizeof(int ));
    pstatuses = (int *)tmp;
    statsize = i;
    }
  }
  i = 0;
  p = (*(jobs + j))->pipe;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    tmp___0 = i;
    i ++;
    *(pstatuses + tmp___0) = process_exit_status(p->status);
    p = p->next;
    }
    if (! ((unsigned long )p != (unsigned long )(*(jobs + j))->pipe)) {
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  *(pstatuses + i) = -1;
  set_pipestatus_array(pstatuses);
  }
  return;
}
}
static void run_sigchld_trap(int nchild ) 
{ 
  char *trap_command ;
  int i ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  UWP u ;
  UWP u___0 ;
  UWP u___1 ;
  UWP u___2 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
  tmp = strlen((char const   *)trap_list[17]);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )trap_list[17]);
  trap_command = tmp___1;
  begin_unwind_frame((char *)"SIGCHLD trap");
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    u.i = last_command_exit_value;
    unwind_protect_var(& last_command_exit_value, u.s, (int )sizeof(int ));
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (sizeof(pid_t ) == sizeof(short )) {
    {
    unwind_protect_var(& last_made_pid, (char *)(& last_made_pid), (int )sizeof(short ));
    }
  } else {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      u___0.i = last_made_pid;
      unwind_protect_var(& last_made_pid, u___0.s, (int )sizeof(int ));
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    u___1.i = interrupt_immediately;
    unwind_protect_var(& interrupt_immediately, u___1.s, (int )sizeof(int ));
    }
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
    u___2.i = jobs_list_frozen;
    unwind_protect_var(& jobs_list_frozen, u___2.s, (int )sizeof(int ));
    }
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  if (sizeof(char *) == sizeof(int )) {
    tmp___2 = (char *)the_pipeline;
  } else {
    tmp___2 = (char *)(& the_pipeline);
  }
  {
  unwind_protect_var((int *)(& the_pipeline), tmp___2, (int )sizeof(char *));
  }
  if (sizeof(char *) == sizeof(int )) {
    tmp___3 = (char *)subst_assign_varlist;
  } else {
    tmp___3 = (char *)(& subst_assign_varlist);
  }
  {
  unwind_protect_var((int *)(& subst_assign_varlist), tmp___3, (int )sizeof(char *));
  add_unwind_protect((Function *)(& xfree), trap_command);
  add_unwind_protect((Function *)(& maybe_set_sigchld_trap), trap_command);
  subst_assign_varlist = (WORD_LIST *)((void *)0);
  the_pipeline = (PROCESS *)((void *)0);
  restore_default_signal(17);
  jobs_list_frozen = 1;
  i = 0;
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (i < nchild)) {
      goto while_break___3;
    }
    {
    interrupt_immediately = 1;
    tmp___4 = strlen((char const   *)trap_command);
    tmp___5 = xmalloc(1UL + tmp___4);
    tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )trap_command);
    parse_and_execute(tmp___6, (char *)"trap", 4);
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  run_unwind_frame((char *)"SIGCHLD trap");
  }
  return;
}
}
static void notify_of_job_status(void) 
{ 
  register int job ;
  register int termsig ;
  char *dir ;
  sigset_t set ;
  sigset_t oset ;
  WAIT s ;
  pid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned long )jobs == (unsigned long )((JOB **)0)) {
    return;
  } else { //Added block
  if (job_slots == 0) {
    return;
  }
  }
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigaddset(& set, 22);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  job = 0;
  dir = (char *)((void *)0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (job < job_slots)) {
      goto while_break;
    }
    if (*(jobs + job)) {
      if ((((*(jobs + job))->flags & 2) != 0) == 0) {
        {
        s = raw_job_exit_status(job);
        termsig = s & 127;
        }
        if (startup_state == 0) {
          if (((int )((signed char )((s & 127) + 1)) >> 1 > 0) == 0) {
            if ((unsigned int )(*(jobs + job))->state == 2U) {
              if ((((*(jobs + job))->flags & 1) != 0) == 0) {
                goto __Cont;
              } else {
                goto _L;
              }
            } else { //Added block
            _L: 
            if ((unsigned int )(*(jobs + job))->state == 1U) {
              goto __Cont;
            }
            }
          }
        }
        if (job_control == 0) {
          if (interactive_shell) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if (startup_state == 2) {
          _L___0: 
          if ((unsigned int )(*(jobs + job))->state == 2U) {
            if (interactive_shell) {
              (*(jobs + job))->flags |= 2;
            } else {
              {
              tmp = find_last_pid(job);
              }
              if (tmp != last_asynchronous_pid) {
                (*(jobs + job))->flags |= 2;
              }
            }
          }
          goto __Cont;
        }
        }
        {
        if ((unsigned int )(*(jobs + job))->state == 2U) {
          goto case_2;
        }
        if ((unsigned int )(*(jobs + job))->state == 1U) {
          goto case_1;
        }
        if ((unsigned int )(*(jobs + job))->state == 0U) {
          goto case_0;
        }
        if ((unsigned int )(*(jobs + job))->state == 3U) {
          goto case_0;
        }
        goto switch_default;
        case_2: /* CIL Label */ 
        if (interactive_shell == 0) {
          if (termsig) {
            if ((int )((signed char )((s & 127) + 1)) >> 1 > 0) {
              if (termsig != 2) {
                {
                tmp___4 = signal_is_trapped(termsig);
                }
                if (tmp___4 == 0) {
                  {
                  tmp___0 = get_name_for_error();
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: ",
                          tmp___0, line_number);
                  pretty_print_job(job, 4, stderr);
                  }
                } else {
                  goto _L___5;
                }
              } else {
                goto _L___5;
              }
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else { //Added block
        _L___5: 
        if (((*(jobs + job))->flags & 1) != 0) {
          if (termsig) {
            if ((int )((signed char )((s & 127) + 1)) >> 1 > 0) {
              if (termsig != 2) {
                {
                tmp___1 = strsignal(termsig);
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                        tmp___1);
                }
                if (s & 128) {
                  {
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" (core dumped)");
                  }
                }
                {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
                }
              }
            }
          }
        } else {
          if ((unsigned long )dir == (unsigned long )((char *)0)) {
            {
            dir = current_working_directory();
            }
          }
          {
          pretty_print_job(job, 0, stderr);
          }
          if (dir) {
            {
            tmp___3 = strcmp((char const   *)dir, (char const   *)(*(jobs + job))->wd);
            }
            if (tmp___3 != 0) {
              {
              tmp___2 = polite_directory_format(dir);
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(wd now: %s)\n",
                      tmp___2);
              }
            }
          }
        }
        }
        (*(jobs + job))->flags |= 2;
        goto switch_break;
        case_1: /* CIL Label */ 
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
        }
        if ((unsigned long )dir == (unsigned long )((char *)0)) {
          {
          dir = current_working_directory();
          }
        }
        {
        pretty_print_job(job, 0, stderr);
        }
        if (dir) {
          {
          tmp___6 = strcmp((char const   *)dir, (char const   *)(*(jobs + job))->wd);
          }
          if (tmp___6 != 0) {
            {
            tmp___5 = polite_directory_format(dir);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(wd now: %s)\n",
                    tmp___5);
            }
          }
        }
        (*(jobs + job))->flags |= 2;
        goto switch_break;
        case_0: /* CIL Label */ 
        case_3: /* CIL Label */ 
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
        programming_error("notify_of_job_status");
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
    __Cont: 
    job ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return;
}
}
int initialize_job_control(int force ) 
{ 
  int tmp ;
  SigHandler *old_ttin___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  shell_pgrp = getpgrp();
  }
  if (shell_pgrp == -1) {
    {
    sys_error("initialize_job_control: getpgrp failed");
    exit(1);
    }
  }
  if (interactive == 0) {
    {
    job_control = 0;
    original_pgrp = -1;
    shell_tty = fileno(stderr);
    }
  } else {
    {
    tmp = fileno(stderr);
    shell_tty = dup(tmp);
    shell_tty = move_to_high_fd(shell_tty, 1, -1);
    }
    if (shell_pgrp == 0) {
      {
      shell_pgrp = getpid();
      setpgid(0, shell_pgrp);
      tcsetpgrp(shell_tty, shell_pgrp);
      }
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      terminal_pgrp = tcgetpgrp(shell_tty);
      }
      if (! (terminal_pgrp != -1)) {
        goto while_break;
      }
      if (shell_pgrp != terminal_pgrp) {
        {
        old_ttin___0 = set_signal_handler(21, (SigHandler *)((void (*)(int  ))0));
        kill(0, 21);
        set_signal_handler(21, old_ttin___0);
        }
        goto while_continue;
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    tmp___2 = set_new_line_discipline(shell_tty);
    }
    if (tmp___2 < 0) {
      {
      sys_error("initialize_job_control: line discipline");
      job_control = 0;
      }
    } else {
      {
      original_pgrp = shell_pgrp;
      shell_pgrp = getpid();
      }
      if (original_pgrp != shell_pgrp) {
        {
        tmp___0 = setpgid(0, shell_pgrp);
        }
        if (tmp___0 < 0) {
          {
          sys_error("initialize_job_control: setpgid");
          shell_pgrp = original_pgrp;
          }
        }
      }
      job_control = 1;
      if (shell_pgrp != original_pgrp) {
        if (shell_pgrp != terminal_pgrp) {
          {
          tmp___1 = give_terminal_to(shell_pgrp, 0);
          }
          if (tmp___1 < 0) {
            {
            setpgid(0, original_pgrp);
            shell_pgrp = original_pgrp;
            job_control = 0;
            }
          }
        }
      }
    }
    if (job_control == 0) {
      {
      internal_error("no job control in this shell");
      }
    }
  }
  {
  tmp___3 = fileno(stderr);
  }
  if (shell_tty != tmp___3) {
    {
    fcntl(shell_tty, 2, 1);
    }
  }
  {
  set_signal_handler(17, (SigHandler *)(& sigchld_handler));
  }
  if (job_control) {
    tmp___4 = '-';
  } else {
    tmp___4 = '+';
  }
  {
  change_flag('m', tmp___4);
  }
  if (interactive) {
    {
    get_tty_state();
    }
  }
  return (job_control);
}
}
static int set_new_line_discipline(int tty ) 
{ 


  {
  return (0);
}
}
static SigHandler *old_tstp  ;
static SigHandler *old_ttou  ;
static SigHandler *old_ttin  ;
static SigHandler *old_cont  =    (SigHandler *)((void (*)(int  ))0);
static void sigstop_sighandler(int sig ) ;
static void sigcont_sighandler(int sig ) ;
static SigHandler *old_winch  =    (SigHandler *)((void (*)(int  ))0);
static void get_new_window_size(int from_sig ) 
{ 
  struct winsize win ;
  int tmp ;

  {
  {
  tmp = ioctl(shell_tty, 21523UL, & win);
  }
  if (tmp == 0) {
    if ((int )win.ws_row > 0) {
      if ((int )win.ws_col > 0) {
        {
        sh_set_lines_and_columns((int )win.ws_row, (int )win.ws_col);
        rl_set_screen_size((int )win.ws_row, (int )win.ws_col);
        }
      }
    }
  }
  return;
}
}
static void sigwinch_sighandler(int sig ) 
{ 


  {
  {
  get_new_window_size(1);
  }
  return;
}
}
void set_sigwinch_handler(void) 
{ 


  {
  {
  old_winch = set_signal_handler(28, (SigHandler *)(& sigwinch_sighandler));
  }
  return;
}
}
void unset_sigwinch_handler(void) 
{ 


  {
  {
  set_signal_handler(28, old_winch);
  }
  return;
}
}
void initialize_job_signals(void) 
{ 


  {
  if (interactive) {
    {
    set_signal_handler(2, (SigHandler *)(& sigint_sighandler));
    set_signal_handler(20, (SigHandler *)((void (*)(int  ))1));
    set_signal_handler(22, (SigHandler *)((void (*)(int  ))1));
    set_signal_handler(21, (SigHandler *)((void (*)(int  ))1));
    set_sigwinch_handler();
    }
  } else { //Added block
  if (job_control) {
    {
    old_tstp = set_signal_handler(20, (SigHandler *)(& sigstop_sighandler));
    old_ttou = set_signal_handler(22, (SigHandler *)(& sigstop_sighandler));
    old_ttin = set_signal_handler(21, (SigHandler *)(& sigstop_sighandler));
    }
  }
  }
  return;
}
}
static void sigcont_sighandler(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
  initialize_job_signals();
  set_signal_handler(18, old_cont);
  tmp = getpid();
  kill(tmp, 18);
  }
  return;
}
}
static void sigstop_sighandler(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
  set_signal_handler(20, old_tstp);
  set_signal_handler(22, old_ttou);
  set_signal_handler(21, old_ttin);
  old_cont = set_signal_handler(18, (SigHandler *)(& sigcont_sighandler));
  give_terminal_to(shell_pgrp, 0);
  tmp = getpid();
  kill(tmp, sig);
  }
  return;
}
}
int give_terminal_to(pid_t pgrp , int force ) 
{ 
  sigset_t set ;
  sigset_t oset ;
  int r ;
  int tmp ;

  {
  r = 0;
  if (job_control) {
    goto _L;
  } else { //Added block
  if (force) {
    _L: 
    {
    sigemptyset(& set);
    sigaddset(& set, 22);
    sigaddset(& set, 21);
    sigaddset(& set, 20);
    sigaddset(& set, 17);
    sigemptyset(& oset);
    sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
    tmp = tcsetpgrp(shell_tty, pgrp);
    }
    if (tmp < 0) {
      r = -1;
    } else {
      terminal_pgrp = pgrp;
    }
    {
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
  }
  }
  return (r);
}
}
void delete_all_jobs(int running_only ) 
{ 
  register int i ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  }
  if (job_slots) {
    previous_job = -1;
    current_job = previous_job;
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break;
      }
      if (*(jobs + i)) {
        if (running_only == 0) {
          {
          delete_job(i, 1);
          }
        } else { //Added block
        if (running_only) {
          if ((unsigned int )(*(jobs + i))->state == 0U) {
            {
            delete_job(i, 1);
            }
          }
        }
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (running_only == 0) {
      {
      free((void *)((char *)jobs));
      job_slots = 0;
      }
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return;
}
}
void nohup_all_jobs(int running_only ) 
{ 
  register int i ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  }
  if (job_slots) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break;
      }
      if (*(jobs + i)) {
        if (running_only == 0) {
          {
          nohup_job(i);
          }
        } else { //Added block
        if (running_only) {
          if ((unsigned int )(*(jobs + i))->state == 0U) {
            {
            nohup_job(i);
            }
          }
        }
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return;
}
}
int count_all_jobs(void) 
{ 
  int i ;
  int n ;
  sigset_t set ;
  sigset_t oset ;

  {
  {
  sigemptyset(& set);
  sigaddset(& set, 17);
  sigemptyset(& oset);
  sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
  n = 0;
  i = n;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < job_slots)) {
      goto while_break;
    }
    if (*(jobs + i)) {
      if (((unsigned int )(*(jobs + i))->state == 2U) == 0) {
        n ++;
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  }
  return (n);
}
}
static void mark_all_jobs_as_dead(void) 
{ 
  register int i ;
  sigset_t set ;
  sigset_t oset ;

  {
  if (job_slots) {
    {
    sigemptyset(& set);
    sigaddset(& set, 17);
    sigemptyset(& oset);
    sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
    i = 0;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break;
      }
      if (*(jobs + i)) {
        (*(jobs + i))->state = (JOB_STATE )2;
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
  }
  return;
}
}
static void mark_dead_jobs_as_notified(int force ) 
{ 
  register int i ;
  register int ndead ;
  sigset_t set ;
  sigset_t oset ;
  pid_t tmp ;

  {
  if (job_slots) {
    {
    sigemptyset(& set);
    sigaddset(& set, 17);
    sigemptyset(& oset);
    sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
    ndead = 0;
    i = ndead;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (force == 0) {
        if (! (i < job_slots)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      if (*(jobs + i)) {
        if ((unsigned int )(*(jobs + i))->state == 2U) {
          ndead ++;
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (force == 0) {
      if (ndead <= 32) {
        {
        sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
        }
        return;
      }
    }
    i = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i < job_slots)) {
        goto while_break___0;
      }
      if (*(jobs + i)) {
        if ((unsigned int )(*(jobs + i))->state == 2U) {
          if (interactive_shell) {
            goto _L;
          } else {
            {
            tmp = find_last_pid(i);
            }
            if (tmp != last_asynchronous_pid) {
              _L: 
              (*(jobs + i))->flags |= 2;
              if (force == 0) {
                ndead --;
                if (ndead <= 32) {
                  goto while_break___0;
                }
              }
            }
          }
        }
      }
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
    }
  }
  return;
}
}
void unfreeze_jobs_list(void) 
{ 


  {
  jobs_list_frozen = 0;
  return;
}
}
int set_job_control(int arg ) 
{ 
  int old ;

  {
  old = job_control;
  job_control = arg;
  return (old);
}
}
void without_job_control(void) 
{ 


  {
  {
  stop_making_children();
  start_pipeline();
  delete_all_jobs(0);
  set_job_control(0);
  }
  return;
}
}
void end_job_control(void) 
{ 


  {
  if (interactive_shell) {
    {
    terminate_stopped_jobs();
    }
    if (original_pgrp >= 0) {
      {
      give_terminal_to(original_pgrp, 1);
      }
    }
  }
  if (original_pgrp >= 0) {
    {
    setpgid(0, original_pgrp);
    }
  }
  return;
}
}
void restart_job_control(void) 
{ 


  {
  if (shell_tty != -1) {
    {
    close(shell_tty);
    }
  }
  {
  initialize_job_control(0);
  }
  return;
}
}
void set_sigchld_handler(void) 
{ 


  {
  {
  set_signal_handler(17, (SigHandler *)(& sigchld_handler));
  }
  return;
}
}
#pragma merger("0","/tmp/cil-kHtl8SO5.i","-g")
WORD_LIST *array_to_word_list(ARRAY *a ) ;
char *array_subrange(ARRAY *a , int start , int end , int quoted ) ;
char *array_pat_subst(ARRAY *a , char *pat , char *rep , int mflags ) ;
char *de_backslash(char *string ) ;
char *extract_command_subst(char *string , int *sindex ) ;
char *extract_arithmetic_subst(char *string , int *sindex ) ;
char *extract_process_subst(char *string , char *starter , int *sindex ) ;
void word_list_remove_quoted_nulls(WORD_LIST *list___0 ) ;
WORD_LIST *list_string(char *string , char *separators , int quoted ) ;
char *get_word_from_string(char **stringp , char *separators , char **endptr ) ;
char *strip_trailing_ifs_whitespace(char *string , char *separators , int saw_escape ) ;
int do_assignment(char *string ) ;
int do_assignment_no_expand(char *string ) ;
SHELL_VAR *do_array_element_assignment(char *name , char *value ) ;
WORD_LIST *list_rest_of_args(void) ;
char *string_rest_of_args(int dollar_star ) ;
int number_of_args(void) ;
WORD_LIST *expand_string(char *string , int quoted ) ;
WORD_LIST *expand_word(WORD_DESC *word , int quoted ) ;
char *get_dollar_var_value(int ind___1 ) ;
char *quote_string(char *string ) ;
WORD_LIST *word_split(WORD_DESC *w ) ;
WORD_LIST *expand_words_shellexp(WORD_LIST *list___0 ) ;
char *command_substitute(char *string , int quoted ) ;
char *pat_subst(char *string , char *pat , char *rep , int mflags ) ;
int valid_array_reference(char *name ) ;
SHELL_VAR *array_variable_part(char *s , char **subp , int *lenp ) ;
char *remove_backslashes(char *string ) ;
int char_is_quoted(char *string , int eindex ) ;
int unclosed_pair(char *string , int eindex , char *openstr ) ;
int skip_to_delim(char *string , int start , char *delims ) ;
WORD_LIST *split_at_delims(char *string , int slen , char *delims , int sentinel ,
                           int *nwp , int *cwp ) ;
char **brace_expand(char *text___0 ) ;
GENERIC_LIST *list_append(GENERIC_LIST *head , GENERIC_LIST *tail ) ;
WORD_LIST *argv_to_word_list(char **array , int copy , int starting_index ) ;
void strip_trailing(char *string , int len___0 , int newlines_only ) ;
extern int zread(int  , char * , size_t  ) ;
void reset_signal_handlers(void) ;
extern char *glob_error_return ;
int unquoted_glob_pattern_p(char *string ) ;
char **shell_glob_filename(char const   *pathname ) ;
pid_t last_command_subst_pid  =    -1;
pid_t current_command_subst_pid  =    -1;
int allow_null_glob_expansion  ;
char *glob_argv_flags  ;
static WORD_LIST expand_word_error  ;
static WORD_LIST expand_word_fatal  ;
static char expand_param_error  ;
static char expand_param_fatal  ;
static int no_longjmp_on_fatal_error  =    0;
static int expand_no_split_dollar_star  =    0;
WORD_LIST *subst_assign_varlist  =    (WORD_LIST *)((void *)0);
static WORD_LIST *garglist  =    (WORD_LIST *)((void *)0);
static char *make_quoted_char(int c ) ;
static void remove_quoted_nulls(char *string ) ;
static char *param_expand(char *string , int *sindex , int quoted , int *expanded_something ,
                          int *contains_dollar_at , int *quoted_dollar_at_p , int *had_quoted_null_p ,
                          int pflags ) ;
static char *maybe_expand_string(char *string , int quoted , WORD_LIST *(*func)() ) ;
static WORD_LIST *call_expand_word_internal(WORD_DESC *w , int q , int i , int *c ,
                                            int *e ) ;
static WORD_LIST *expand_string_internal(char *string , int quoted ) ;
static WORD_LIST *expand_word_internal(WORD_DESC *word , int quoted , int isexp ,
                                       int *contains_dollar_at , int *expanded_something ) ;
static WORD_LIST *expand_word_list_internal(WORD_LIST *list___0 , int eflags ) ;
static WORD_LIST *expand_string_leave_quoted(char *string , int quoted ) ;
static WORD_LIST *expand_string_for_rhs(char *string , int quoted , int *dollar_at_p ,
                                        int *has_dollar_at ) ;
static char *getifs(void) ;
static WORD_LIST *word_list_split(WORD_LIST *list___0 ) ;
static WORD_LIST *quote_list(WORD_LIST *list___0 ) ;
static WORD_LIST *dequote_list(WORD_LIST *list___0 ) ;
static char *quote_escapes(char *string ) ;
static WORD_LIST *list_quote_escapes(WORD_LIST *list___0 ) ;
static int unquoted_substring(char *substr , char *string ) ;
static int unquoted_member(int character , char *string ) ;
static int do_assignment_internal(char *string , int expand ) ;
static char *string_extract_verbatim(char *string , int *sindex , char *charlist ) ;
static char *string_extract(char *string , int *sindex , char *charlist , int varname___0 ) ;
__inline static char *string_extract_double_quoted(char *string , int *sindex , int stripdq ) ;
__inline static char *string_extract_single_quoted(char *string , int *sindex ) ;
static char *string_list_dollar_at(WORD_LIST *list___0 , int quoted ) ;
static char *string_list_dollar_star(WORD_LIST *list___0 ) ;
__inline static int skip_single_quoted(char *string , int sind ) ;
__inline static int skip_double_quoted(char *string , int sind ) ;
static char *extract_delimited_string(char *string , int *sindex , char *opener ,
                                      char *alt_opener , char *closer ) ;
static char *extract_dollar_brace_string(char *string , int *sindex , int quoted ) ;
char *substring(char *string , int start , int end ) 
{ 
  register int len___0 ;
  register char *result ;

  {
  {
  len___0 = end - start;
  result = xmalloc((size_t )(len___0 + 1));
  strncpy((char * __restrict  )result, (char const   * __restrict  )(string + start),
          (size_t )len___0);
  *(result + len___0) = (char )'\000';
  }
  return (result);
}
}
static char *quoted_substring(char *string , int start , int end ) 
{ 
  register int len___0 ;
  register int l ;
  register char *result ;
  register char *s ;
  register char *r ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  len___0 = end - start;
  s = string;
  l = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*s) {
      if (! (l < start)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*s == 1) {
      s ++;
      goto __Cont;
    }
    l ++;
    if ((int )*s == 0) {
      goto while_break;
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  result = xmalloc((size_t )(2 * len___0 + 1));
  r = result;
  s = string + l;
  l = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (l < len___0)) {
      goto while_break___0;
    }
    if ((int )*s == 1) {
      tmp = r;
      r ++;
      tmp___0 = s;
      s ++;
      *tmp = *tmp___0;
    }
    tmp___1 = r;
    r ++;
    *tmp___1 = *s;
    l ++;
    if ((int )*s == 0) {
      goto while_break___0;
    }
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *r = (char )'\000';
  return (result);
}
}
__inline static char *quoted_strchr(char *s , int c , int flags ) 
{ 
  register char *p ;

  {
  p = s;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p) {
      goto while_break;
    }
    if (flags & 1) {
      if ((int )*p == 92) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (flags & 2) {
      if ((int )*p == 1) {
        _L: 
        p ++;
        if ((int )*p == 0) {
          return ((char *)((void *)0));
        }
        goto __Cont;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((int )*p == c) {
      return (p);
    }
    }
    }
    __Cont: 
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char *)((void *)0));
}
}
static int unquoted_member(int character , char *string ) 
{ 
  int sindex ;
  int c ;

  {
  sindex = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + sindex);
    if (! c) {
      goto while_break;
    }
    if (c == character) {
      return (1);
    }
    {
    if (c == 92) {
      goto case_92;
    }
    if (c == 39) {
      goto case_39;
    }
    if (c == 34) {
      goto case_34;
    }
    goto switch_default;
    switch_default: /* CIL Label */ 
    sindex ++;
    goto switch_break;
    case_92: /* CIL Label */ 
    sindex ++;
    if (*(string + sindex)) {
      sindex ++;
    }
    goto switch_break;
    case_39: /* CIL Label */ 
    {
    sindex ++;
    sindex = skip_single_quoted(string, sindex);
    }
    goto switch_break;
    case_34: /* CIL Label */ 
    {
    sindex ++;
    sindex = skip_double_quoted(string, sindex);
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int unquoted_substring(char *substr , char *string ) 
{ 
  int sindex ;
  int c ;
  int sublen ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )substr == (unsigned long )((char *)0)) {
    return (0);
  } else { //Added block
  if ((int )*substr == 0) {
    return (0);
  }
  }
  {
  tmp = strlen((char const   *)substr);
  sublen = (int )tmp;
  sindex = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + sindex);
    if (! c) {
      goto while_break;
    }
    if (sublen == 0) {
      tmp___2 = 1;
    } else {
      if ((int )*((string + sindex) + 0) == (int )*(substr + 0)) {
        {
        tmp___0 = strncmp((char const   *)(string + sindex), (char const   *)substr,
                          (size_t )sublen);
        }
        if (tmp___0 == 0) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
      tmp___2 = tmp___1;
    }
    if (tmp___2) {
      return (1);
    }
    {
    if (c == 92) {
      goto case_92;
    }
    if (c == 39) {
      goto case_39;
    }
    if (c == 34) {
      goto case_34;
    }
    goto switch_default;
    case_92: /* CIL Label */ 
    sindex ++;
    if (*(string + sindex)) {
      sindex ++;
    }
    goto switch_break;
    case_39: /* CIL Label */ 
    {
    sindex ++;
    sindex = skip_single_quoted(string, sindex);
    }
    goto switch_break;
    case_34: /* CIL Label */ 
    {
    sindex ++;
    sindex = skip_double_quoted(string, sindex);
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    sindex ++;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
char *sub_append_string(char *source , char *target , int *indx , int *size ) 
{ 
  int srclen ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if (source) {
    if (source) {
      if (*(source + 0)) {
        if (*(source + 1)) {
          if (*(source + 2)) {
            {
            tmp = strlen((char const   *)source);
            tmp___0 = tmp;
            }
          } else {
            tmp___0 = (size_t )2;
          }
          tmp___1 = tmp___0;
        } else {
          tmp___1 = (size_t )1;
        }
        srclen = (int )tmp___1;
      } else {
        srclen = 0;
      }
    } else {
      srclen = 0;
    }
    if (srclen >= *size - *indx) {
      {
      n = srclen + *indx;
      n = (n + 128) - n % 128;
      tmp___2 = n;
      *size = tmp___2;
      target = xrealloc((void *)target, (size_t )tmp___2);
      }
    }
    {
    __builtin_memcpy((void *)(target + *indx), (void const   *)source, (unsigned long )srclen);
    *indx += srclen;
    *(target + *indx) = (char )'\000';
    free((void *)source);
    }
  }
  return (target);
}
}
static char *string_extract(char *string , int *sindex , char *charlist , int varname___0 ) 
{ 
  register int c ;
  register int i ;
  char *temp___0 ;
  int ni ;
  char *tmp ;
  int tmp___0 ;

  {
  i = *sindex;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + i);
    if (! c) {
      goto while_break;
    }
    if (c == 92) {
      if (*(string + (i + 1))) {
        i ++;
      } else {
        goto while_break;
      }
    } else { //Added block
    if (varname___0) {
      if (c == 91) {
        {
        ni = skipsubscript(string, i);
        }
        if ((int )*(string + ni) == 93) {
          i = ni;
        }
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (c) {
      if (c == (int )*(charlist + 0)) {
        if (! *(charlist + 1)) {
          goto while_break;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (c) {
        {
        tmp = strchr((char const   *)charlist, c);
        tmp___0 = (unsigned long )tmp != (unsigned long )((char *)((void *)0));
        }
      } else {
        tmp___0 = 0;
      }
      if (tmp___0) {
        goto while_break;
      }
    }
    }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  temp___0 = substring(string, *sindex, i);
  *sindex = i;
  }
  return (temp___0);
}
}
__inline static char *string_extract_double_quoted(char *string , int *sindex , int stripdq ) 
{ 
  int c ;
  int j ;
  int i ;
  int t ;
  char *temp___0 ;
  char *ret ;
  int pass_next ;
  int backquote ;
  int si ;
  int dquote ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
  dquote = 0;
  backquote = dquote;
  pass_next = backquote;
  tmp = strlen((char const   *)string);
  temp___0 = xmalloc((1UL + tmp) - (size_t )*sindex);
  j = 0;
  i = *sindex;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + i);
    if (! c) {
      goto while_break;
    }
    if (pass_next) {
      if (stripdq == 0) {
        if (c != 34) {
          tmp___0 = j;
          j ++;
          *(temp___0 + tmp___0) = (char )'\\';
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if (stripdq) {
        if (dquote) {
          if (sh_syntaxtab[c] & 64) {
            tmp___0 = j;
            j ++;
            *(temp___0 + tmp___0) = (char )'\\';
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if (dquote == 0) {
          tmp___0 = j;
          j ++;
          *(temp___0 + tmp___0) = (char )'\\';
        }
        }
      }
      }
      tmp___1 = j;
      j ++;
      *(temp___0 + tmp___1) = (char )c;
      pass_next = 0;
      goto __Cont;
    }
    if (c == 92) {
      pass_next ++;
      goto __Cont;
    }
    if (backquote) {
      if (c == 96) {
        backquote = 0;
      }
      tmp___2 = j;
      j ++;
      *(temp___0 + tmp___2) = (char )c;
      goto __Cont;
    }
    if (c == 96) {
      tmp___3 = j;
      j ++;
      *(temp___0 + tmp___3) = (char )c;
      backquote ++;
      goto __Cont;
    }
    if (c == 36) {
      if ((int )*(string + (i + 1)) == 40) {
        goto _L___1;
      } else { //Added block
      if ((int )*(string + (i + 1)) == 123) {
        _L___1: 
        si = i + 2;
        if ((int )*(string + (i + 1)) == 40) {
          {
          ret = extract_delimited_string(string, & si, (char *)"$(", (char *)"(",
                                         (char *)")");
          }
        } else {
          {
          ret = extract_dollar_brace_string(string, & si, 1);
          }
        }
        tmp___4 = j;
        j ++;
        *(temp___0 + tmp___4) = (char )'$';
        tmp___5 = j;
        j ++;
        *(temp___0 + tmp___5) = *(string + (i + 1));
        t = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! *(ret + t)) {
            goto while_break___0;
          }
          *(temp___0 + j) = *(ret + t);
          t ++;
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        tmp___6 = j;
        j ++;
        *(temp___0 + tmp___6) = *(string + si);
        i = si;
        free((void *)ret);
        }
        goto __Cont;
      }
      }
    }
    if (c != 34) {
      tmp___7 = j;
      j ++;
      *(temp___0 + tmp___7) = (char )c;
      goto __Cont;
    }
    if (stripdq) {
      dquote ^= 1;
      goto __Cont;
    }
    goto while_break;
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  *(temp___0 + j) = (char )'\000';
  if (c) {
    i ++;
  }
  *sindex = i;
  return (temp___0);
}
}
__inline static int skip_double_quoted(char *string , int sind ) 
{ 
  int c ;
  int j ;
  int i ;
  char *ret ;
  int pass_next ;
  int backquote ;
  int si ;

  {
  backquote = 0;
  pass_next = backquote;
  j = 0;
  i = sind;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + i);
    if (! c) {
      goto while_break;
    }
    if (pass_next) {
      pass_next = 0;
      goto __Cont;
    } else { //Added block
    if (c == 92) {
      pass_next ++;
      goto __Cont;
    } else { //Added block
    if (backquote) {
      if (c == 96) {
        backquote = 0;
      }
      goto __Cont;
    } else { //Added block
    if (c == 96) {
      backquote ++;
      goto __Cont;
    } else { //Added block
    if (c == 36) {
      if ((int )*(string + (i + 1)) == 40) {
        goto _L___0;
      } else { //Added block
      if ((int )*(string + (i + 1)) == 123) {
        _L___0: 
        si = i + 2;
        if ((int )*(string + (i + 1)) == 40) {
          {
          ret = extract_delimited_string(string, & si, (char *)"$(", (char *)"(",
                                         (char *)")");
          }
        } else {
          {
          ret = extract_dollar_brace_string(string, & si, 0);
          }
        }
        {
        i = si;
        free((void *)ret);
        }
        goto __Cont;
      } else {
        goto _L;
      }
      }
    } else { //Added block
    _L: 
    if (! (c != 34)) {
      goto while_break;
    }
    }
    }
    }
    }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (c) {
    i ++;
  }
  return (i);
}
}
__inline static char *string_extract_single_quoted(char *string , int *sindex ) 
{ 
  register int i ;
  char *t ;

  {
  i = *sindex;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(string + i)) {
      if (! ((int )*(string + i) != 39)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  t = substring(string, *sindex, i);
  }
  if (*(string + i)) {
    i ++;
  }
  *sindex = i;
  return (t);
}
}
__inline static int skip_single_quoted(char *string , int sind ) 
{ 
  register int c ;

  {
  c = sind;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(string + c)) {
      if (! ((int )*(string + c) != 39)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (*(string + c)) {
    c ++;
  }
  return (c);
}
}
static char *string_extract_verbatim(char *string , int *sindex , char *charlist ) 
{ 
  register int i ;
  int c ;
  char *temp___0 ;
  char *tmp ;
  int tmp___0 ;

  {
  i = *sindex;
  if ((int )*(charlist + 0) == 39) {
    if ((int )*(charlist + 1) == 0) {
      {
      temp___0 = string_extract_single_quoted(string, sindex);
      (*sindex) --;
      }
      return (temp___0);
    }
  }
  i = *sindex;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + i);
    if (! c) {
      goto while_break;
    }
    if (c == 1) {
      i ++;
      goto __Cont;
    }
    if (c) {
      if (c == (int )*(charlist + 0)) {
        if (! *(charlist + 1)) {
          goto while_break;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (c) {
        {
        tmp = strchr((char const   *)charlist, c);
        tmp___0 = (unsigned long )tmp != (unsigned long )((char *)((void *)0));
        }
      } else {
        tmp___0 = 0;
      }
      if (tmp___0) {
        goto while_break;
      }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  temp___0 = substring(string, *sindex, i);
  *sindex = i;
  }
  return (temp___0);
}
}
char *extract_command_subst(char *string , int *sindex ) 
{ 
  char *tmp ;

  {
  {
  tmp = extract_delimited_string(string, sindex, (char *)"$(", (char *)"(", (char *)")");
  }
  return (tmp);
}
}
char *extract_arithmetic_subst(char *string , int *sindex ) 
{ 
  char *tmp ;

  {
  {
  tmp = extract_delimited_string(string, sindex, (char *)"$[", (char *)"[", (char *)"]");
  }
  return (tmp);
}
}
char *extract_process_subst(char *string , char *starter , int *sindex ) 
{ 
  char *tmp ;

  {
  {
  tmp = extract_delimited_string(string, sindex, starter, (char *)"(", (char *)")");
  }
  return (tmp);
}
}
char *extract_array_assignment_list(char *string , int *sindex ) 
{ 
  char *tmp ;

  {
  {
  tmp = extract_delimited_string(string, sindex, (char *)"(", (char *)((void *)0),
                                 (char *)")");
  }
  return (tmp);
}
}
static char *extract_delimited_string(char *string , int *sindex , char *opener ,
                                      char *alt_opener , char *closer ) 
{ 
  int i ;
  int c ;
  int si ;
  char *t ;
  char *result ;
  int pass_character ;
  int nesting_level ;
  int len_closer ;
  int len_opener ;
  int len_alt_opener ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  if (opener) {
    if (*(opener + 0)) {
      if (*(opener + 1)) {
        if (*(opener + 2)) {
          {
          tmp = strlen((char const   *)opener);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      len_opener = (int )tmp___1;
    } else {
      len_opener = 0;
    }
  } else {
    len_opener = 0;
  }
  if (alt_opener) {
    if (*(alt_opener + 0)) {
      if (*(alt_opener + 1)) {
        if (*(alt_opener + 2)) {
          {
          tmp___2 = strlen((char const   *)alt_opener);
          tmp___3 = tmp___2;
          }
        } else {
          tmp___3 = (size_t )2;
        }
        tmp___4 = tmp___3;
      } else {
        tmp___4 = (size_t )1;
      }
      len_alt_opener = (int )tmp___4;
    } else {
      len_alt_opener = 0;
    }
  } else {
    len_alt_opener = 0;
  }
  if (closer) {
    if (*(closer + 0)) {
      if (*(closer + 1)) {
        if (*(closer + 2)) {
          {
          tmp___5 = strlen((char const   *)closer);
          tmp___6 = tmp___5;
          }
        } else {
          tmp___6 = (size_t )2;
        }
        tmp___7 = tmp___6;
      } else {
        tmp___7 = (size_t )1;
      }
      len_closer = (int )tmp___7;
    } else {
      len_closer = 0;
    }
  } else {
    len_closer = 0;
  }
  pass_character = 0;
  nesting_level = 1;
  i = *sindex;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! nesting_level) {
      goto while_break;
    }
    c = (int )*(string + i);
    if (c == 0) {
      goto while_break;
    }
    if (pass_character) {
      pass_character = 0;
      i ++;
      goto while_continue;
    }
    if (c == 1) {
      pass_character ++;
      i ++;
      goto while_continue;
    }
    if (c == 92) {
      pass_character ++;
      i ++;
      goto while_continue;
    }
    if (len_opener == 0) {
      tmp___10 = 1;
    } else {
      if ((int )*((string + i) + 0) == (int )*(opener + 0)) {
        {
        tmp___8 = strncmp((char const   *)(string + i), (char const   *)opener, (size_t )len_opener);
        }
        if (tmp___8 == 0) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      tmp___10 = tmp___9;
    }
    if (tmp___10) {
      {
      si = i + len_opener;
      t = extract_delimited_string(string, & si, opener, alt_opener, closer);
      i = si + 1;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (t) {
          {
          free((void *)t);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      goto while_continue;
    }
    if (len_alt_opener) {
      if (len_alt_opener == 0) {
        tmp___13 = 1;
      } else {
        if ((int )*((string + i) + 0) == (int )*(alt_opener + 0)) {
          {
          tmp___11 = strncmp((char const   *)(string + i), (char const   *)alt_opener,
                             (size_t )len_alt_opener);
          }
          if (tmp___11 == 0) {
            tmp___12 = 1;
          } else {
            tmp___12 = 0;
          }
        } else {
          tmp___12 = 0;
        }
        tmp___13 = tmp___12;
      }
      if (tmp___13) {
        {
        si = i + len_alt_opener;
        t = extract_delimited_string(string, & si, alt_opener, alt_opener, closer);
        i = si + 1;
        }
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (t) {
            {
            free((void *)t);
            }
          }
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        goto while_continue;
      }
    }
    if (len_closer == 0) {
      tmp___16 = 1;
    } else {
      if ((int )*((string + i) + 0) == (int )*(closer + 0)) {
        {
        tmp___14 = strncmp((char const   *)(string + i), (char const   *)closer, (size_t )len_closer);
        }
        if (tmp___14 == 0) {
          tmp___15 = 1;
        } else {
          tmp___15 = 0;
        }
      } else {
        tmp___15 = 0;
      }
      tmp___16 = tmp___15;
    }
    if (tmp___16) {
      i += len_closer - 1;
      nesting_level --;
      if (nesting_level == 0) {
        goto while_break;
      }
    }
    if (c == 96) {
      {
      si = i + 1;
      t = string_extract(string, & si, (char *)"`", 0);
      i = si + 1;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (t) {
          {
          free((void *)t);
          }
        }
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      goto while_continue;
    }
    if (c == 39) {
      {
      si = i + 1;
      i = skip_single_quoted(string, si);
      }
      goto while_continue;
    }
    if (c == 34) {
      {
      si = i + 1;
      i = skip_double_quoted(string, si);
      }
      goto while_continue;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (c == 0) {
    if (nesting_level) {
      if (no_longjmp_on_fatal_error == 0) {
        {
        report_error("bad substitution: no `%s\' in %s", closer, string);
        last_command_exit_value = 1;
        jump_to_top_level(2);
        }
      }
    }
  }
  {
  si = ((i - *sindex) - len_closer) + 1;
  result = xmalloc((size_t )(1 + si));
  strncpy((char * __restrict  )result, (char const   * __restrict  )(string + *sindex),
          (size_t )si);
  *(result + si) = (char )'\000';
  *sindex = i;
  }
  return (result);
}
}
static char *extract_dollar_brace_string(char *string , int *sindex , int quoted ) 
{ 
  register int i ;
  register int c ;
  int pass_character ;
  int nesting_level ;
  int si ;
  char *result ;
  char *t ;
  int tmp ;
  int tmp___0 ;

  {
  pass_character = 0;
  nesting_level = 1;
  i = *sindex;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + i);
    if (! c) {
      goto while_break;
    }
    if (pass_character) {
      pass_character = 0;
      goto __Cont;
    }
    if (c == 1) {
      pass_character ++;
      goto __Cont;
    } else { //Added block
    if (c == 92) {
      pass_character ++;
      goto __Cont;
    }
    }
    if ((int )*(string + i) == 36) {
      if ((int )*(string + (i + 1)) == 123) {
        nesting_level ++;
        i ++;
        goto __Cont;
      }
    }
    if (c == 125) {
      nesting_level --;
      if (nesting_level == 0) {
        goto while_break;
      }
      goto __Cont;
    }
    if (c == 96) {
      {
      si = i + 1;
      t = string_extract(string, & si, (char *)"`", 0);
      i = si;
      free((void *)t);
      }
      goto __Cont;
    }
    if ((int )*(string + i) == 36) {
      if ((int )*(string + (i + 1)) == 40) {
        {
        si = i + 2;
        t = extract_delimited_string(string, & si, (char *)"$(", (char *)"(", (char *)")");
        i = si;
        free((void *)t);
        }
        goto __Cont;
      }
    }
    if (c == 39) {
      goto _L;
    } else { //Added block
    if (c == 34) {
      _L: 
      si = i + 1;
      if (c == 39) {
        {
        tmp = skip_single_quoted(string, si);
        i = tmp;
        }
      } else {
        {
        tmp___0 = skip_double_quoted(string, si);
        i = tmp___0;
        }
      }
      i --;
      goto __Cont;
    }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (c == 0) {
    if (nesting_level) {
      if (no_longjmp_on_fatal_error == 0) {
        {
        report_error("bad substitution: no ending `}\' in %s", string);
        last_command_exit_value = 1;
        jump_to_top_level(2);
        }
      }
    }
  }
  {
  result = substring(string, *sindex, i);
  *sindex = i;
  }
  return (result);
}
}
char *de_backslash(char *string ) 
{ 
  register int i ;
  register int l ;
  size_t tmp ;

  {
  {
  i = 0;
  tmp = strlen((char const   *)string);
  l = (int )tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < l)) {
      goto while_break;
    }
    if ((int )*(string + i) == 92) {
      if ((int )*(string + (i + 1)) == 96) {
        {
        strcpy((char * __restrict  )(string + i), (char const   * __restrict  )((string + i) + 1));
        }
      } else { //Added block
      if ((int )*(string + (i + 1)) == 92) {
        {
        strcpy((char * __restrict  )(string + i), (char const   * __restrict  )((string + i) + 1));
        }
      } else { //Added block
      if ((int )*(string + (i + 1)) == 36) {
        {
        strcpy((char * __restrict  )(string + i), (char const   * __restrict  )((string + i) + 1));
        }
      }
      }
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (string);
}
}
int char_is_quoted(char *string , int eindex ) 
{ 
  int i ;
  int pass_next ;
  int quoted ;
  int tmp ;
  int tmp___0 ;

  {
  no_longjmp_on_fatal_error = 1;
  quoted = 0;
  pass_next = quoted;
  i = pass_next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= eindex)) {
      goto while_break;
    }
    if (pass_next) {
      pass_next = 0;
      if (i >= eindex) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          no_longjmp_on_fatal_error = 0;
          return (1);
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      goto __Cont;
    } else { //Added block
    if ((int )*(string + i) == 39) {
      goto _L;
    } else { //Added block
    if ((int )*(string + i) == 34) {
      _L: 
      if ((int )*(string + i) == 39) {
        {
        i ++;
        tmp = skip_single_quoted(string, i);
        i = tmp;
        }
      } else {
        {
        i ++;
        tmp___0 = skip_double_quoted(string, i);
        i = tmp___0;
        }
      }
      if (i > eindex) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          no_longjmp_on_fatal_error = 0;
          return (1);
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      i --;
    } else { //Added block
    if ((int )*(string + i) == 92) {
      pass_next = 1;
      goto __Cont;
    }
    }
    }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    no_longjmp_on_fatal_error = 0;
    return (0);
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  return (0);
}
}
int unclosed_pair(char *string , int eindex , char *openstr ) 
{ 
  int i ;
  int pass_next ;
  int openc ;
  int olen ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = strlen((char const   *)openstr);
  olen = (int )tmp;
  openc = 0;
  pass_next = openc;
  i = pass_next;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i <= eindex)) {
      goto while_break;
    }
    if (pass_next) {
      pass_next = 0;
      if (i >= eindex) {
        return (0);
      }
      goto __Cont;
    } else {
      if (olen == 0) {
        tmp___4 = 1;
      } else {
        if ((int )*((string + i) + 0) == (int )*(openstr + 0)) {
          {
          tmp___2 = strncmp((char const   *)(string + i), (char const   *)openstr,
                            (size_t )olen);
          }
          if (tmp___2 == 0) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
        tmp___4 = tmp___3;
      }
      if (tmp___4) {
        openc = 1 - openc;
        i += olen - 1;
      } else { //Added block
      if ((int )*(string + i) == 39) {
        goto _L;
      } else { //Added block
      if ((int )*(string + i) == 34) {
        _L: 
        if ((int )*(string + i) == 39) {
          {
          tmp___0 = skip_single_quoted(string, i);
          i = tmp___0;
          }
        } else {
          {
          tmp___1 = skip_double_quoted(string, i);
          i = tmp___1;
          }
        }
        if (i > eindex) {
          return (0);
        }
      } else { //Added block
      if ((int )*(string + i) == 92) {
        pass_next = 1;
        goto __Cont;
      }
      }
      }
      }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (openc);
}
}
int skip_to_delim(char *string , int start , char *delims ) 
{ 
  int i ;
  int pass_next ;
  int backq ;
  int si ;
  char *temp___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  no_longjmp_on_fatal_error = 1;
  i = start;
  backq = 0;
  pass_next = backq;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(string + i)) {
      goto while_break;
    }
    if (pass_next) {
      pass_next = 0;
      if ((int )*(string + i) == 0) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          no_longjmp_on_fatal_error = 0;
          return (i);
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      goto __Cont;
    } else { //Added block
    if ((int )*(string + i) == 92) {
      pass_next = 1;
      goto __Cont;
    } else { //Added block
    if (backq) {
      if ((int )*(string + i) == 96) {
        backq = 0;
      }
      goto __Cont;
    } else { //Added block
    if ((int )*(string + i) == 96) {
      backq = 1;
      goto __Cont;
    } else { //Added block
    if ((int )*(string + i) == 39) {
      goto _L___1;
    } else { //Added block
    if ((int )*(string + i) == 34) {
      _L___1: 
      if ((int )*(string + i) == 39) {
        {
        i ++;
        tmp = skip_single_quoted(string, i);
        i = tmp;
        }
      } else {
        {
        i ++;
        tmp___0 = skip_double_quoted(string, i);
        i = tmp___0;
        }
      }
      i --;
    } else { //Added block
    if ((int )*(string + i) == 36) {
      if ((int )*(string + (i + 1)) == 40) {
        goto _L___0;
      } else { //Added block
      if ((int )*(string + (i + 1)) == 123) {
        _L___0: 
        si = i + 2;
        if ((int )*(string + si) == 0) {
          goto while_break;
        }
        if ((int )*(string + (i + 1)) == 40) {
          {
          temp___0 = extract_delimited_string(string, & si, (char *)"$(", (char *)"(",
                                              (char *)")");
          }
        } else {
          {
          temp___0 = extract_dollar_brace_string(string, & si, 0);
          }
        }
        {
        i = si;
        free((void *)temp___0);
        }
        goto __Cont;
      } else {
        goto _L;
      }
      }
    } else {
      _L: 
      if (*(string + i)) {
        {
        tmp___1 = strchr((char const   *)delims, (int )*(string + i));
        tmp___2 = (unsigned long )tmp___1 != (unsigned long )((char *)((void *)0));
        }
      } else {
        tmp___2 = 0;
      }
      if (tmp___2) {
        goto while_break;
      }
    }
    }
    }
    }
    }
    }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    no_longjmp_on_fatal_error = 0;
    return (i);
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  return (0);
}
}
WORD_LIST *split_at_delims(char *string , int slen , char *delims , int sentinel ,
                           int *nwp , int *cwp ) 
{ 
  int ts ;
  int te ;
  int i ;
  int nw ;
  int cw ;
  char *token___0 ;
  char *d___0 ;
  char *d2 ;
  WORD_LIST *ret ;
  WORD_LIST *tl ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  GENERIC_LIST *tmp___14 ;
  WORD_LIST *tmp___15 ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    goto _L;
  } else { //Added block
  if ((int )*string == 0) {
    _L: 
    if (nwp) {
      *nwp = 0;
    }
    if (cwp) {
      *cwp = 0;
    }
    return ((WORD_LIST *)((void *)0));
  }
  }
  if ((unsigned long )delims == (unsigned long )((char *)0)) {
    {
    tmp = getifs();
    d___0 = tmp;
    }
  } else {
    d___0 = delims;
  }
  d2 = (char *)0;
  if (delims) {
    {
    tmp___0 = strlen((char const   *)delims);
    d2 = xmalloc(tmp___0 + 1UL);
    ts = 0;
    i = ts;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *(delims + i)) {
        goto while_break;
      }
      if ((int )*(delims + i) == 32) {
        tmp___2 = 1;
      } else { //Added block
      if ((int )*(delims + i) == 9) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
      }
      if (tmp___2 == 0) {
        tmp___1 = ts;
        ts ++;
        *(d2 + tmp___1) = *(delims + i);
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    *(d2 + ts) = (char )'\000';
  }
  ret = (WORD_LIST *)((void *)0);
  i = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (*(string + i)) {
      {
      tmp___3 = strchr((char const   *)d___0, (int )*(string + i));
      tmp___4 = (unsigned long )tmp___3 != (unsigned long )((char *)((void *)0));
      }
    } else {
      tmp___4 = 0;
    }
    if (tmp___4) {
      if (! ((int )*(string + i) == 32)) {
        if (! ((int )*(string + i) == 9)) {
          if (! ((int )*(string + i) == 10)) {
            goto while_break___0;
          }
        }
      }
    } else {
      goto while_break___0;
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((int )*(string + i) == 0) {
    return (ret);
  }
  ts = i;
  nw = 0;
  cw = -1;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    te = skip_to_delim(string, ts, d___0);
    }
    if (ts == te) {
      if (d2) {
        if (*(string + ts)) {
          {
          tmp___7 = strchr((char const   *)d2, (int )*(string + ts));
          tmp___8 = (unsigned long )tmp___7 != (unsigned long )((char *)((void *)0));
          }
        } else {
          tmp___8 = 0;
        }
        if (tmp___8) {
          te = ts + 1;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (*(string + te)) {
              {
              tmp___5 = strchr((char const   *)d2, (int )*(string + te));
              tmp___6 = (unsigned long )tmp___5 != (unsigned long )((char *)((void *)0));
              }
            } else {
              tmp___6 = 0;
            }
            if (! tmp___6) {
              goto while_break___2;
            }
            te ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
    {
    token___0 = substring(string, ts, te);
    ret = add_string_to_list(token___0, ret);
    free((void *)token___0);
    nw ++;
    }
    if (sentinel >= ts) {
      if (sentinel <= te) {
        cw = nw;
      }
    }
    if (cwp) {
      if (cw == -1) {
        if (sentinel == ts - 1) {
          cw = nw;
        }
      }
    }
    if (cwp) {
      if (cw == -1) {
        if (sentinel < ts) {
          {
          tmp___9 = xmalloc(sizeof(WORD_LIST ));
          tl = (WORD_LIST *)tmp___9;
          tl->word = make_word((char *)"");
          tl->next = ret->next;
          ret->next = tl;
          cw = nw;
          nw ++;
          }
        }
      }
    }
    if ((int )*(string + te) == 0) {
      goto while_break___1;
    }
    if (*(string + te)) {
      {
      tmp___10 = strchr((char const   *)d___0, (int )*(string + te));
      tmp___11 = (unsigned long )tmp___10 != (unsigned long )((char *)((void *)0));
      }
    } else {
      tmp___11 = 0;
    }
    i = te + tmp___11;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (*(string + i)) {
        {
        tmp___12 = strchr((char const   *)d___0, (int )*(string + i));
        tmp___13 = (unsigned long )tmp___12 != (unsigned long )((char *)((void *)0));
        }
      } else {
        tmp___13 = 0;
      }
      if (tmp___13) {
        if (! ((int )*(string + i) == 32)) {
          if (! ((int )*(string + i) == 9)) {
            goto while_break___3;
          }
        }
      } else {
        goto while_break___3;
      }
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    if (*(string + i)) {
      ts = i;
    } else {
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  if (cwp) {
    if (cw == -1) {
      if (sentinel >= slen) {
        if ((int )*(string + (sentinel - 1)) == 32) {
          {
          token___0 = (char *)"";
          ret = add_string_to_list(token___0, ret);
          nw ++;
          }
        } else { //Added block
        if ((int )*(string + (sentinel - 1)) == 9) {
          {
          token___0 = (char *)"";
          ret = add_string_to_list(token___0, ret);
          nw ++;
          }
        }
        }
        cw = nw;
      }
    }
  }
  if (nwp) {
    *nwp = nw;
  }
  if (cwp) {
    *cwp = cw;
  }
  if (ret) {
    if (ret->next) {
      {
      tmp___14 = reverse_list((GENERIC_LIST *)ret);
      tmp___15 = (WORD_LIST *)tmp___14;
      }
    } else {
      tmp___15 = ret;
    }
  } else {
    tmp___15 = ret;
  }
  return (tmp___15);
}
}
static char *string_list_internal(WORD_LIST *list___0 , char *sep ) 
{ 
  register WORD_LIST *t ;
  char *result ;
  char *r ;
  int word_len ;
  int sep_len ;
  int result_size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
  if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
    return ((char *)((void *)0));
  }
  if (sep) {
    if (*(sep + 0)) {
      if (*(sep + 1)) {
        if (*(sep + 2)) {
          {
          tmp = strlen((char const   *)sep);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      sep_len = (int )tmp___1;
    } else {
      sep_len = 0;
    }
  } else {
    sep_len = 0;
  }
  result_size = 0;
  t = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! t) {
      goto while_break;
    }
    if ((unsigned long )t != (unsigned long )list___0) {
      result_size += sep_len;
    }
    {
    tmp___2 = strlen((char const   *)(t->word)->word);
    result_size = (int )((size_t )result_size + tmp___2);
    t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  result = xmalloc((size_t )(result_size + 1));
  r = result;
  t = list___0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! t) {
      goto while_break___0;
    }
    if ((unsigned long )t != (unsigned long )list___0) {
      if (sep_len) {
        if (sep_len > 1) {
          {
          __builtin_memcpy((void *)r, (void const   *)sep, (unsigned long )sep_len);
          r += sep_len;
          }
        } else {
          tmp___3 = r;
          r ++;
          *tmp___3 = *(sep + 0);
        }
      }
    }
    {
    tmp___4 = strlen((char const   *)(t->word)->word);
    word_len = (int )tmp___4;
    __builtin_memcpy((void *)r, (void const   *)(t->word)->word, (unsigned long )word_len);
    r += word_len;
    t = t->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  *r = (char )'\000';
  return (result);
}
}
char *string_list(WORD_LIST *list___0 ) 
{ 
  char *tmp ;

  {
  {
  tmp = string_list_internal(list___0, (char *)" ");
  }
  return (tmp);
}
}
static char *string_list_dollar_star(WORD_LIST *list___0 ) 
{ 
  char *ifs ;
  char sep[2] ;
  char *tmp ;

  {
  {
  ifs = get_string_value("IFS");
  }
  if ((unsigned long )ifs == (unsigned long )((char *)0)) {
    sep[0] = (char )' ';
  } else {
    sep[0] = *ifs;
  }
  {
  sep[1] = (char )'\000';
  tmp = string_list_internal(list___0, sep);
  }
  return (tmp);
}
}
static char *string_list_dollar_at(WORD_LIST *list___0 , int quoted ) 
{ 
  char *ifs ;
  char sep[2] ;
  WORD_LIST *tlist ;
  WORD_LIST *tmp ;
  WORD_LIST *tmp___0 ;
  char *tmp___1 ;

  {
  {
  ifs = get_string_value("IFS");
  }
  if ((unsigned long )ifs == (unsigned long )((char *)0)) {
    sep[0] = (char )' ';
  } else { //Added block
  if ((int )*ifs == 0) {
    sep[0] = (char )' ';
  } else {
    sep[0] = *ifs;
  }
  }
  sep[1] = (char )'\000';
  if (quoted & 3) {
    {
    tmp = quote_list(list___0);
    tlist = tmp;
    }
  } else { //Added block
  if (ifs) {
    if ((int )*ifs == 0) {
      {
      tmp = quote_list(list___0);
      tlist = tmp;
      }
    } else {
      {
      tmp___0 = list_quote_escapes(list___0);
      tlist = tmp___0;
      }
    }
  } else {
    {
    tmp___0 = list_quote_escapes(list___0);
    tlist = tmp___0;
    }
  }
  }
  {
  tmp___1 = string_list_internal(tlist, sep);
  }
  return (tmp___1);
}
}
WORD_LIST *list_string(char *string , char *separators , int quoted ) 
{ 
  WORD_LIST *result ;
  WORD_DESC *t ;
  char *current_word ;
  char *s ;
  int sindex ;
  int sh_style_split ;
  int whitesep ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  GENERIC_LIST *tmp___8 ;
  WORD_LIST *tmp___9 ;

  {
  if (! string) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if (! *string) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  if (separators) {
    if (*separators) {
      if ((int )*(separators + 0) == (int )*(" \t\n" + 0)) {
        {
        tmp = strcmp((char const   *)separators, " \t\n");
        }
        if (tmp == 0) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  sh_style_split = tmp___0;
  if (! quoted) {
    goto _L___0;
  } else { //Added block
  if (! separators) {
    goto _L___0;
  } else { //Added block
  if (! *separators) {
    _L___0: 
    s = string;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (*s) {
        if ((int )*s == 32) {
          goto _L;
        } else { //Added block
        if ((int )*s == 9) {
          goto _L;
        } else { //Added block
        if ((int )*s == 10) {
          _L: 
          if (*s) {
            {
            tmp___1 = strchr((char const   *)separators, (int )*s);
            tmp___2 = (unsigned long )tmp___1 != (unsigned long )((char *)((void *)0));
            }
          } else {
            tmp___2 = 0;
          }
          if (! tmp___2) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        }
        }
      } else {
        goto while_break;
      }
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (! *s) {
      return ((WORD_LIST *)((void *)0));
    }
    string = s;
  }
  }
  }
  result = (WORD_LIST *)((void *)0);
  sindex = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *(string + sindex)) {
      goto while_break___0;
    }
    {
    current_word = string_extract_verbatim(string, & sindex, separators);
    }
    if ((unsigned long )current_word == (unsigned long )((char *)0)) {
      goto while_break___0;
    }
    if ((int )*(current_word + 0) == 127) {
      if ((int )*(current_word + 1) == 0) {
        {
        t = make_bare_word((char *)"");
        t->flags |= 2;
        free((void *)t->word);
        t->word = make_quoted_char('\000');
        result = make_word_list(t, result);
        }
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if ((int )*(current_word + 0) != 0) {
      {
      remove_quoted_nulls(current_word);
      result = add_string_to_list(current_word, result);
      }
      if (quoted & 3) {
        (result->word)->flags |= 2;
      }
    } else { //Added block
    if (! sh_style_split) {
      if (! ((int )*(string + sindex) == 32)) {
        if (! ((int )*(string + sindex) == 9)) {
          if (! ((int )*(string + sindex) == 10)) {
            {
            t = make_bare_word((char *)"");
            t->flags |= 2;
            free((void *)t->word);
            t->word = make_quoted_char('\000');
            result = make_word_list(t, result);
            }
          }
        }
      }
    }
    }
    }
    {
    free((void *)current_word);
    }
    if (*(string + sindex)) {
      if ((int )*(string + sindex) == 32) {
        tmp___3 = 1;
      } else { //Added block
      if ((int )*(string + sindex) == 9) {
        tmp___3 = 1;
      } else { //Added block
      if ((int )*(string + sindex) == 10) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      }
      }
    } else {
      tmp___3 = 0;
    }
    whitesep = tmp___3;
    if (*(string + sindex)) {
      sindex ++;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (*(string + sindex)) {
        if ((int )*(string + sindex) == 32) {
          goto _L___2;
        } else { //Added block
        if ((int )*(string + sindex) == 9) {
          goto _L___2;
        } else { //Added block
        if ((int )*(string + sindex) == 10) {
          _L___2: 
          if (*(string + sindex)) {
            {
            tmp___4 = strchr((char const   *)separators, (int )*(string + sindex));
            tmp___5 = (unsigned long )tmp___4 != (unsigned long )((char *)((void *)0));
            }
          } else {
            tmp___5 = 0;
          }
          if (! tmp___5) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        }
        }
      } else {
        goto while_break___1;
      }
      sindex ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (*(string + sindex)) {
      if (whitesep) {
        if (*(string + sindex)) {
          {
          tmp___6 = strchr((char const   *)separators, (int )*(string + sindex));
          tmp___7 = (unsigned long )tmp___6 != (unsigned long )((char *)((void *)0));
          }
        } else {
          tmp___7 = 0;
        }
        if (tmp___7) {
          if (! ((int )*(string + sindex) == 32)) {
            if (! ((int )*(string + sindex) == 9)) {
              if (! ((int )*(string + sindex) == 10)) {
                sindex ++;
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (result) {
    if (result->next) {
      {
      tmp___8 = reverse_list((GENERIC_LIST *)result);
      tmp___9 = (WORD_LIST *)tmp___8;
      }
    } else {
      tmp___9 = result;
    }
  } else {
    tmp___9 = result;
  }
  return (tmp___9);
}
}
char *get_word_from_string(char **stringp , char *separators , char **endptr ) 
{ 
  register char *s ;
  char *current_word ;
  int sindex ;
  int sh_style_split ;
  int whitesep ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  if (! stringp) {
    return ((char *)((void *)0));
  } else { //Added block
  if (! *stringp) {
    return ((char *)((void *)0));
  } else { //Added block
  if (! *(*stringp)) {
    return ((char *)((void *)0));
  }
  }
  }
  s = *stringp;
  if (separators) {
    if (*separators) {
      if ((int )*(separators + 0) == (int )*(" \t\n" + 0)) {
        {
        tmp = strcmp((char const   *)separators, " \t\n");
        }
        if (tmp == 0) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  sh_style_split = tmp___0;
  if (sh_style_split) {
    goto _L___0;
  } else { //Added block
  if (! separators) {
    goto _L___0;
  } else { //Added block
  if (! *separators) {
    _L___0: 
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (*s) {
        if ((int )*s == 32) {
          goto _L;
        } else { //Added block
        if ((int )*s == 9) {
          goto _L;
        } else { //Added block
        if ((int )*s == 10) {
          _L: 
          if (*s) {
            {
            tmp___1 = strchr((char const   *)separators, (int )*s);
            tmp___2 = (unsigned long )tmp___1 != (unsigned long )((char *)((void *)0));
            }
          } else {
            tmp___2 = 0;
          }
          if (! tmp___2) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        }
        }
      } else {
        goto while_break;
      }
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (! *s) {
      *stringp = s;
      if (endptr) {
        *endptr = s;
      }
      return ((char *)((void *)0));
    }
  }
  }
  }
  {
  sindex = 0;
  current_word = string_extract_verbatim(s, & sindex, separators);
  }
  if (endptr) {
    *endptr = s + sindex;
  }
  if (*(s + sindex)) {
    if ((int )*(s + sindex) == 32) {
      tmp___3 = 1;
    } else { //Added block
    if ((int )*(s + sindex) == 9) {
      tmp___3 = 1;
    } else { //Added block
    if ((int )*(s + sindex) == 10) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
    }
    }
  } else {
    tmp___3 = 0;
  }
  whitesep = tmp___3;
  if (*(s + sindex)) {
    sindex ++;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (*(s + sindex)) {
      if ((int )*(s + sindex) == 32) {
        goto _L___1;
      } else { //Added block
      if ((int )*(s + sindex) == 9) {
        goto _L___1;
      } else { //Added block
      if ((int )*(s + sindex) == 10) {
        _L___1: 
        if (*(s + sindex)) {
          {
          tmp___4 = strchr((char const   *)separators, (int )*(s + sindex));
          tmp___5 = (unsigned long )tmp___4 != (unsigned long )((char *)((void *)0));
          }
        } else {
          tmp___5 = 0;
        }
        if (! tmp___5) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      }
      }
    } else {
      goto while_break___0;
    }
    sindex ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (*(s + sindex)) {
    if (whitesep) {
      if (*(s + sindex)) {
        {
        tmp___6 = strchr((char const   *)separators, (int )*(s + sindex));
        tmp___7 = (unsigned long )tmp___6 != (unsigned long )((char *)((void *)0));
        }
      } else {
        tmp___7 = 0;
      }
      if (tmp___7) {
        if (! ((int )*(s + sindex) == 32)) {
          if (! ((int )*(s + sindex) == 9)) {
            if (! ((int )*(s + sindex) == 10)) {
              sindex ++;
            }
          }
        }
      }
    }
  }
  *stringp = s + sindex;
  return (current_word);
}
}
char *strip_trailing_ifs_whitespace(char *string , char *separators , int saw_escape ) 
{ 
  char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  if (string) {
    if (*(string + 0)) {
      if (*(string + 1)) {
        if (*(string + 2)) {
          {
          tmp = strlen((char const   *)string);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      tmp___2 = tmp___1;
    } else {
      tmp___2 = (size_t )0;
    }
  } else {
    tmp___2 = (size_t )0;
  }
  s = (string + tmp___2) - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )s > (unsigned long )string) {
      if ((int )*s == 32) {
        goto _L___0;
      } else { //Added block
      if ((int )*s == 9) {
        goto _L___0;
      } else { //Added block
      if ((int )*s == 10) {
        _L___0: 
        if (*s) {
          {
          tmp___3 = strchr((char const   *)separators, (int )*s);
          tmp___4 = (unsigned long )tmp___3 != (unsigned long )((char *)((void *)0));
          }
        } else {
          tmp___4 = 0;
        }
        if (! tmp___4) {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (saw_escape) {
        if ((int )*s == 1) {
          if (! ((int )*(s + 1) == 32)) {
            if (! ((int )*(s + 1) == 9)) {
              if (! ((int )*(s + 1) == 10)) {
                goto while_break;
              }
            }
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      }
      }
      }
    } else {
      goto while_break;
    }
    s --;
  }
  while_break: /* CIL Label */ ;
  }
  s ++;
  *s = (char )'\000';
  return (string);
}
}
SHELL_VAR *do_array_element_assignment(char *name , char *value ) 
{ 
  char *t ;
  int ind___1 ;
  int ni ;
  SHELL_VAR *entry ;
  char *tmp ;

  {
  {
  t = strchr((char const   *)name, '[');
  }
  if ((unsigned long )t == (unsigned long )((char *)0)) {
    return ((SHELL_VAR *)((void *)0));
  }
  {
  ind___1 = (int )(t - name);
  ni = skipsubscript(name, ind___1);
  }
  if ((int )*(t + 1) == 64) {
    goto _L___0;
  } else { //Added block
  if ((int )*(t + 1) == 42) {
    _L___0: 
    if ((int )*(t + 2) == 93) {
      {
      report_error("%s: bad array subscript", name);
      }
      return ((SHELL_VAR *)((void *)0));
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (ni <= ind___1 + 1) {
    {
    report_error("%s: bad array subscript", name);
    }
    return ((SHELL_VAR *)((void *)0));
  }
  }
  }
  {
  tmp = t;
  t ++;
  *tmp = (char )'\000';
  ind___1 = array_expand_index(t, ni - ind___1);
  }
  if (ind___1 < 0) {
    {
    *(t + -1) = (char )'[';
    report_error("%s: bad array subscript", name);
    }
    return ((SHELL_VAR *)((void *)0));
  }
  {
  entry = bind_array_variable(name, ind___1, value);
  *(t + -1) = (char )'[';
  }
  return (entry);
}
}
static int do_assignment_internal(char *string , int expand ) 
{ 
  int offset ;
  char *name ;
  char *value ;
  SHELL_VAR *entry ;
  char *t ;
  int ni ;
  int assign_list ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *temp___0 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
  assign_list = 0;
  offset = assignment(string);
  tmp = strlen((char const   *)string);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
  name = tmp___1;
  value = (char *)((void *)0);
  }
  if ((int )*(name + offset) == 61) {
    *(name + offset) = (char)0;
    temp___0 = (name + offset) + 1;
    if (expand) {
      if ((int )*(temp___0 + 0) == 40) {
        {
        tmp___13 = strchr((char const   *)temp___0, ')');
        }
        if (tmp___13) {
          {
          ni = 1;
          assign_list = ni;
          value = extract_delimited_string(temp___0, & ni, (char *)"(", (char *)((void *)0),
                                           (char *)")");
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (expand) {
      if (*(temp___0 + 0)) {
        {
        tmp___8 = strchr((char const   *)temp___0, '~');
        }
        if (tmp___8) {
          {
          tmp___9 = unquoted_member('~', temp___0);
          }
          if (tmp___9) {
            {
            tmp___4 = bash_tilde_expand(temp___0);
            temp___0 = tmp___4;
            }
          } else {
            {
            tmp___5 = strlen((char const   *)temp___0);
            tmp___6 = xmalloc(1UL + tmp___5);
            tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )temp___0);
            temp___0 = tmp___7;
            }
          }
        } else {
          {
          tmp___5 = strlen((char const   *)temp___0);
          tmp___6 = xmalloc(1UL + tmp___5);
          tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )temp___0);
          temp___0 = tmp___7;
          }
        }
        {
        value = maybe_expand_string(temp___0, 0, (WORD_LIST *(*)())(& expand_string_unsplit));
        free((void *)temp___0);
        }
      } else {
        {
        tmp___10 = strlen((char const   *)temp___0);
        tmp___11 = xmalloc(1UL + tmp___10);
        tmp___12 = strcpy((char * __restrict  )tmp___11, (char const   * __restrict  )temp___0);
        value = tmp___12;
        }
      }
    } else {
      {
      tmp___10 = strlen((char const   *)temp___0);
      tmp___11 = xmalloc(1UL + tmp___10);
      tmp___12 = strcpy((char * __restrict  )tmp___11, (char const   * __restrict  )temp___0);
      value = tmp___12;
      }
    }
    }
  }
  if ((unsigned long )value == (unsigned long )((char *)0)) {
    {
    value = xmalloc((size_t )1);
    *(value + 0) = (char )'\000';
    }
  }
  if (echo_command_at_execute) {
    if (assign_list) {
      {
      tmp___14 = indirection_level_string();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s%s=(%s)\n",
              tmp___14, name, value);
      }
    } else {
      {
      tmp___15 = indirection_level_string();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s%s=%s\n",
              tmp___15, name, value);
      }
    }
  }
  {
  t = strchr((char const   *)name, '[');
  }
  if (t) {
    if (assign_list) {
      {
      report_error("%s: cannot assign list to array member", name);
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (value) {
            {
            free((void *)value);
            }
          }
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        free((void *)name);
        }
        return (0);
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
    entry = do_array_element_assignment(name, value);
    }
    if ((unsigned long )entry == (unsigned long )((SHELL_VAR *)0)) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (value) {
            {
            free((void *)value);
            }
          }
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        free((void *)name);
        }
        return (0);
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else { //Added block
  if (assign_list) {
    {
    entry = assign_array_from_string(name, value);
    }
  } else {
    {
    entry = bind_variable(name, value);
    }
  }
  }
  {
  stupidly_hack_special_variables(name);
  }
  if (entry) {
    entry->attributes &= -5;
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (value) {
        {
        free((void *)value);
        }
      }
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    free((void *)name);
    }
    if (entry) {
      if ((entry->attributes & 2) == 0) {
        if ((entry->attributes & 2048) == 0) {
          tmp___16 = 1;
        } else {
          tmp___16 = 0;
        }
      } else {
        tmp___16 = 0;
      }
      tmp___17 = tmp___16;
    } else {
      tmp___17 = 0;
    }
    return (tmp___17);
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  return (0);
}
}
int do_assignment(char *string ) 
{ 
  int tmp ;

  {
  {
  tmp = do_assignment_internal(string, 1);
  }
  return (tmp);
}
}
int do_assignment_no_expand(char *string ) 
{ 
  int tmp ;

  {
  {
  tmp = do_assignment_internal(string, 0);
  }
  return (tmp);
}
}
WORD_LIST *list_rest_of_args(void) 
{ 
  register WORD_LIST *list___0 ;
  register WORD_LIST *args ;
  int i ;
  WORD_DESC *tmp ;
  WORD_DESC *tmp___0 ;
  GENERIC_LIST *tmp___1 ;
  WORD_LIST *tmp___2 ;

  {
  i = 1;
  list___0 = (WORD_LIST *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i < 10) {
      if (! dollar_vars[i]) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = make_bare_word(dollar_vars[i]);
    list___0 = make_word_list(tmp, list___0);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  args = rest_of_args;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! args) {
      goto while_break___0;
    }
    {
    tmp___0 = make_bare_word((args->word)->word);
    list___0 = make_word_list(tmp___0, list___0);
    args = args->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (list___0) {
    if (list___0->next) {
      {
      tmp___1 = reverse_list((GENERIC_LIST *)list___0);
      tmp___2 = (WORD_LIST *)tmp___1;
      }
    } else {
      tmp___2 = list___0;
    }
  } else {
    tmp___2 = list___0;
  }
  return (tmp___2);
}
}
int number_of_args(void) 
{ 
  register WORD_LIST *list___0 ;
  int n ;

  {
  n = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (n < 9) {
      if (! dollar_vars[n + 1]) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  list___0 = rest_of_args;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! list___0) {
      goto while_break___0;
    }
    n ++;
    list___0 = list___0->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (n);
}
}
char *get_dollar_var_value(int ind___1 ) 
{ 
  char *temp___0 ;
  WORD_LIST *p ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  if (ind___1 < 10) {
    if (dollar_vars[ind___1]) {
      {
      tmp = strlen((char const   *)dollar_vars[ind___1]);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )dollar_vars[ind___1]);
      temp___0 = tmp___1;
      }
    } else {
      temp___0 = (char *)((void *)0);
    }
  } else {
    ind___1 -= 10;
    p = rest_of_args;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (p) {
        tmp___2 = ind___1;
        ind___1 --;
        if (! tmp___2) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
    if (p) {
      {
      tmp___3 = strlen((char const   *)(p->word)->word);
      tmp___4 = xmalloc(1UL + tmp___3);
      tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )(p->word)->word);
      temp___0 = tmp___5;
      }
    } else {
      temp___0 = (char *)((void *)0);
    }
  }
  return (temp___0);
}
}
char *string_rest_of_args(int dollar_star ) 
{ 
  register WORD_LIST *list___0 ;
  char *string ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
  list___0 = list_rest_of_args();
  }
  if (dollar_star) {
    {
    tmp = string_list_dollar_star(list___0);
    string = tmp;
    }
  } else {
    {
    tmp___0 = string_list(list___0);
    string = tmp___0;
    }
  }
  {
  dispose_words(list___0);
  }
  return (string);
}
}
static char *pos_params(char *string , int start , int end , int quoted ) 
{ 
  WORD_LIST *save ;
  WORD_LIST *params ;
  WORD_LIST *h ;
  WORD_LIST *t ;
  char *ret ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  WORD_LIST *tmp___1 ;
  WORD_LIST *tmp___2 ;

  {
  if (start == end) {
    return ((char *)((void *)0));
  }
  {
  params = list_rest_of_args();
  save = params;
  }
  if ((unsigned long )save == (unsigned long )((WORD_LIST *)0)) {
    return ((char *)((void *)0));
  }
  i = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (params) {
      if (! (i < start)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    params = params->next;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )params == (unsigned long )((WORD_LIST *)0)) {
    return ((char *)((void *)0));
  }
  t = params;
  h = t;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (params) {
      if (! (i < end)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    t = params;
    params = params->next;
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  t->next = (WORD_LIST *)((void *)0);
  if ((int )*(string + 0) == 42) {
    if (quoted & 3) {
      {
      tmp = string_list_dollar_star(h);
      ret = tmp;
      }
    } else {
      {
      tmp___0 = string_list(h);
      ret = tmp___0;
      }
    }
  } else {
    if (quoted & 3) {
      {
      tmp___1 = quote_list(h);
      tmp___2 = tmp___1;
      }
    } else {
      tmp___2 = h;
    }
    {
    ret = string_list(tmp___2);
    }
  }
  if ((unsigned long )t != (unsigned long )params) {
    t->next = params;
  }
  {
  dispose_words(save);
  }
  return (ret);
}
}
static char *maybe_expand_string(char *string , int quoted , WORD_LIST *(*func)() ) 
{ 
  WORD_LIST *list___0 ;
  int i ;
  int saw_quote ;
  char *ret ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  saw_quote = 0;
  i = saw_quote;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(string + i)) {
      goto while_break;
    }
    if ((int )*(string + i) == 36) {
      goto while_break;
    } else { //Added block
    if ((int )*(string + i) == 96) {
      goto while_break;
    } else { //Added block
    if ((int )*(string + i) == 60) {
      goto while_break;
    } else { //Added block
    if ((int )*(string + i) == 62) {
      goto while_break;
    } else { //Added block
    if ((int )*(string + i) == 1) {
      goto while_break;
    } else { //Added block
    if ((int )*(string + i) == 39) {
      saw_quote = 1;
    } else { //Added block
    if ((int )*(string + i) == 92) {
      saw_quote = 1;
    } else { //Added block
    if ((int )*(string + i) == 34) {
      saw_quote = 1;
    }
    }
    }
    }
    }
    }
    }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (*(string + i)) {
    {
    list___0 = (*func)(string, quoted);
    }
    if (list___0) {
      {
      ret = string_list(list___0);
      dispose_words(list___0);
      }
    } else {
      ret = (char *)((void *)0);
    }
  } else { //Added block
  if (saw_quote) {
    if ((quoted & 3) == 0) {
      {
      ret = string_quote_removal(string, quoted);
      }
    } else {
      {
      tmp = strlen((char const   *)string);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
      ret = tmp___1;
      }
    }
  } else {
    {
    tmp = strlen((char const   *)string);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
    ret = tmp___1;
    }
  }
  }
  return (ret);
}
}
__inline static char *expand_string_to_string(char *string , int quoted , WORD_LIST *(*func)() ) 
{ 
  WORD_LIST *list___0 ;
  char *ret ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return ((char *)((void *)0));
  } else { //Added block
  if ((int )*string == 0) {
    return ((char *)((void *)0));
  }
  }
  {
  list___0 = (*func)(string, quoted);
  }
  if (list___0) {
    {
    ret = string_list(list___0);
    dispose_words(list___0);
    }
  } else {
    ret = (char *)((void *)0);
  }
  return (ret);
}
}
char *remove_backslashes(char *string ) 
{ 
  char *r ;
  char *ret ;
  char *s ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp = strlen((char const   *)string);
  ret = xmalloc(tmp + 1UL);
  r = ret;
  s = string;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (s) {
      if (! *s) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*s == 92) {
      s ++;
    }
    if ((int )*s == 0) {
      goto while_break;
    }
    tmp___0 = r;
    r ++;
    tmp___1 = s;
    s ++;
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
  *r = (char )'\000';
  return (ret);
}
}
char *cond_expand_word(WORD_DESC *w , int special ) 
{ 
  char *r ;
  char *p ;
  WORD_LIST *l ;
  char *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )w->word == (unsigned long )((char *)0)) {
    return ((char *)((void *)0));
  } else { //Added block
  if ((int )*(w->word + 0) == 0) {
    return ((char *)((void *)0));
  }
  }
  {
  tmp = strchr((char const   *)w->word, '~');
  }
  if (tmp) {
    {
    tmp___0 = unquoted_member('~', w->word);
    }
    if (tmp___0) {
      {
      p = bash_tilde_expand(w->word);
      free((void *)w->word);
      w->word = p;
      }
    }
  }
  {
  l = call_expand_word_internal(w, 0, 0, (int *)0, (int *)0);
  }
  if (l) {
    if (special == 0) {
      {
      dequote_list(l);
      r = string_list(l);
      }
    } else {
      {
      p = string_list(l);
      r = quote_string_for_globbing((char const   *)p, 1);
      free((void *)p);
      }
    }
    {
    dispose_words(l);
    }
  } else {
    r = (char *)((void *)0);
  }
  return (r);
}
}
static WORD_LIST *call_expand_word_internal(WORD_DESC *w , int q , int i , int *c ,
                                            int *e ) 
{ 
  WORD_LIST *result ;
  int tmp ;

  {
  {
  result = expand_word_internal(w, q, i, c, e);
  }
  if ((unsigned long )result == (unsigned long )(& expand_word_error)) {
    goto _L;
  } else { //Added block
  if ((unsigned long )result == (unsigned long )(& expand_word_fatal)) {
    _L: 
    expand_no_split_dollar_star = 0;
    w->word = (char *)((void *)0);
    last_command_exit_value = 1;
    if ((unsigned long )result == (unsigned long )(& expand_word_error)) {
      tmp = 2;
    } else {
      tmp = 1;
    }
    {
    jump_to_top_level(tmp);
    }
  } else {
    return (result);
  }
  }
  return ((WORD_LIST *)0);
}
}
static WORD_LIST *expand_string_internal(char *string , int quoted ) 
{ 
  WORD_DESC td ;
  WORD_LIST *tresult ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((int )*string == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  {
  td.flags = 0;
  tmp = strlen((char const   *)string);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
  td.word = tmp___1;
  tresult = call_expand_word_internal(& td, quoted, 0, (int *)((void *)0), (int *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (td.word) {
      {
      free((void *)td.word);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return (tresult);
}
}
WORD_LIST *expand_string_unsplit(char *string , int quoted ) 
{ 
  WORD_LIST *value ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((int )*string == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  {
  expand_no_split_dollar_star = 1;
  value = expand_string_internal(string, quoted);
  expand_no_split_dollar_star = 0;
  }
  if (value) {
    if (value->word) {
      {
      remove_quoted_nulls((value->word)->word);
      }
    }
    {
    dequote_list(value);
    }
  }
  return (value);
}
}
WORD_LIST *expand_prompt_string(char *string , int quoted ) 
{ 
  WORD_LIST *value ;
  WORD_DESC td ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  WORD_DESC *tmp___2 ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((int )*string == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  {
  td.flags = 0;
  tmp = strlen((char const   *)string);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
  td.word = tmp___1;
  no_longjmp_on_fatal_error = 1;
  value = expand_word_internal(& td, quoted, 0, (int *)((void *)0), (int *)((void *)0));
  no_longjmp_on_fatal_error = 0;
  }
  if ((unsigned long )value == (unsigned long )(& expand_word_error)) {
    {
    tmp___2 = make_bare_word(string);
    value = make_word_list(tmp___2, (WORD_LIST *)((void *)0));
    }
    return (value);
  } else { //Added block
  if ((unsigned long )value == (unsigned long )(& expand_word_fatal)) {
    {
    tmp___2 = make_bare_word(string);
    value = make_word_list(tmp___2, (WORD_LIST *)((void *)0));
    }
    return (value);
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (td.word) {
      {
      free((void *)td.word);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if (value) {
    if (value->word) {
      {
      remove_quoted_nulls((value->word)->word);
      }
    }
    {
    dequote_list(value);
    }
  }
  return (value);
}
}
static WORD_LIST *expand_string_leave_quoted(char *string , int quoted ) 
{ 
  WORD_LIST *tlist ;
  WORD_LIST *tresult ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((int )*string == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  {
  tlist = expand_string_internal(string, quoted);
  }
  if (tlist) {
    {
    tresult = word_list_split(tlist);
    dispose_words(tlist);
    }
    return (tresult);
  }
  return ((WORD_LIST *)((void *)0));
}
}
static WORD_LIST *expand_string_for_rhs(char *string , int quoted , int *dollar_at_p ,
                                        int *has_dollar_at ) 
{ 
  WORD_DESC td ;
  WORD_LIST *tresult ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((int )*string == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  {
  td.flags = 0;
  td.word = string;
  tresult = call_expand_word_internal(& td, quoted, 1, dollar_at_p, has_dollar_at);
  }
  return (tresult);
}
}
WORD_LIST *expand_string(char *string , int quoted ) 
{ 
  WORD_LIST *result ;
  WORD_LIST *tmp ;
  WORD_LIST *tmp___0 ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((int )*string == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  {
  result = expand_string_leave_quoted(string, quoted);
  }
  if (result) {
    {
    tmp = dequote_list(result);
    tmp___0 = tmp;
    }
  } else {
    tmp___0 = result;
  }
  return (tmp___0);
}
}
static char *remove_quoted_escapes(char *string ) 
{ 
  register char *s ;
  int docopy ;
  char *t ;
  char *t1 ;
  size_t tmp ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    return (string);
  }
  {
  tmp = strlen((char const   *)string);
  t = xmalloc(tmp + 1UL);
  t1 = t;
  docopy = 0;
  s = string;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    if ((int )*s == 1) {
      if ((int )*(s + 1) == 1) {
        s ++;
        docopy = 1;
      } else { //Added block
      if ((int )*(s + 1) == 127) {
        s ++;
        docopy = 1;
      }
      }
    }
    *t1 = *s;
    s ++;
    t1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  *t1 = (char )'\000';
  if (docopy) {
    {
    strcpy((char * __restrict  )string, (char const   * __restrict  )t);
    }
  }
  {
  free((void *)t);
  }
  return (string);
}
}
static char *quote_escapes(char *string ) 
{ 
  register char *s ;
  register char *t ;
  char *result ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  tmp = strlen((char const   *)string);
  result = xmalloc(tmp * 2UL + 1UL);
  s = string;
  t = result;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    if ((int )*s == 1) {
      tmp___0 = t;
      t ++;
      *tmp___0 = (char )'\001';
    } else { //Added block
    if ((int )*s == 127) {
      tmp___0 = t;
      t ++;
      *tmp___0 = (char )'\001';
    }
    }
    tmp___1 = t;
    t ++;
    tmp___2 = s;
    s ++;
    *tmp___1 = *tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
  *t = (char )'\000';
  return (result);
}
}
static WORD_LIST *list_quote_escapes(WORD_LIST *list___0 ) 
{ 
  register WORD_LIST *w ;
  char *t ;

  {
  w = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! w) {
      goto while_break;
    }
    {
    t = (w->word)->word;
    (w->word)->word = quote_escapes(t);
    free((void *)t);
    w = w->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (list___0);
}
}
static WORD_LIST *dequote_list(WORD_LIST *list___0 ) 
{ 
  register char *s ;
  register WORD_LIST *tlist ;

  {
  tlist = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! tlist) {
      goto while_break;
    }
    {
    s = dequote_string((tlist->word)->word);
    free((void *)(tlist->word)->word);
    (tlist->word)->word = s;
    tlist = tlist->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (list___0);
}
}
static char *make_quoted_char(int c ) 
{ 
  char *temp___0 ;

  {
  {
  temp___0 = xmalloc((size_t )3);
  }
  if (c == 0) {
    *(temp___0 + 0) = (char )'\177';
    *(temp___0 + 1) = (char )'\000';
  } else {
    *(temp___0 + 0) = (char )'\001';
    *(temp___0 + 1) = (char )c;
    *(temp___0 + 2) = (char )'\000';
  }
  return (temp___0);
}
}
char *quote_string(char *string ) 
{ 
  register char *t ;
  char *result ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if ((int )*string == 0) {
    {
    result = xmalloc((size_t )2);
    *(result + 0) = (char )'\177';
    *(result + 1) = (char )'\000';
    }
  } else {
    {
    tmp = strlen((char const   *)string);
    result = xmalloc(tmp * 2UL + 1UL);
    t = result;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *string) {
        goto while_break;
      }
      tmp___0 = t;
      t ++;
      *tmp___0 = (char )'\001';
      tmp___1 = t;
      t ++;
      tmp___2 = string;
      string ++;
      *tmp___1 = *tmp___2;
    }
    while_break: /* CIL Label */ ;
    }
    *t = (char )'\000';
  }
  return (result);
}
}
char *dequote_string(char *string ) 
{ 
  register char *t ;
  char *result ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
  tmp = strlen((char const   *)string);
  result = xmalloc(tmp + 1UL);
  }
  if ((int )*(string + 0) == 127) {
    if ((int )*(string + 1) == 0) {
      *(result + 0) = (char )'\000';
      return (result);
    }
  }
  {
  tmp___0 = strchr((char const   *)string, '\001');
  }
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    strcpy((char * __restrict  )result, (char const   * __restrict  )string);
    }
    return (result);
  }
  t = result;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *string) {
      goto while_break;
    }
    if ((int )*string == 1) {
      string ++;
      if (! *string) {
        goto while_break;
      }
    }
    *t = *string;
    string ++;
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  *t = (char )'\000';
  return (result);
}
}
static WORD_LIST *quote_list(WORD_LIST *list___0 ) 
{ 
  register WORD_LIST *w ;
  char *t ;

  {
  w = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! w) {
      goto while_break;
    }
    {
    t = (w->word)->word;
    (w->word)->word = quote_string(t);
    free((void *)t);
    (w->word)->flags |= 2;
    w = w->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (list___0);
}
}
static void remove_quoted_nulls(char *string ) 
{ 
  char *nstr ;
  char *s ;
  char *p ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
  tmp = strlen((char const   *)string);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
  nstr = tmp___1;
  *(nstr + 0) = (char )'\000';
  p = nstr;
  s = string;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    if ((int )*s == 1) {
      tmp___2 = p;
      p ++;
      tmp___3 = s;
      s ++;
      *tmp___2 = *tmp___3;
      if ((int )*s == 0) {
        goto while_break;
      }
      tmp___4 = p;
      p ++;
      *tmp___4 = *s;
      goto __Cont;
    }
    if ((int )*s == 127) {
      goto __Cont;
    }
    tmp___5 = p;
    p ++;
    *tmp___5 = *s;
    __Cont: 
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *p = (char )'\000';
  strcpy((char * __restrict  )string, (char const   * __restrict  )nstr);
  free((void *)nstr);
  }
  return;
}
}
void word_list_remove_quoted_nulls(WORD_LIST *list___0 ) 
{ 
  register WORD_LIST *t ;

  {
  t = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! t) {
      goto while_break;
    }
    {
    remove_quoted_nulls((t->word)->word);
    t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char *remove_pattern(char *param , char *pattern , int op ) 
{ 
  register int len___0 ;
  register char *end ;
  register char *p ;
  register char *ret ;
  register char c ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
  if ((unsigned long )param == (unsigned long )((void *)0)) {
    return (param);
  } else { //Added block
  if ((int )*param == 0) {
    return (param);
  }
  }
  if ((unsigned long )pattern == (unsigned long )((void *)0)) {
    {
    tmp = strlen((char const   *)param);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )param);
    }
    return (tmp___1);
  } else { //Added block
  if ((int )*pattern == 0) {
    {
    tmp = strlen((char const   *)param);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )param);
    }
    return (tmp___1);
  }
  }
  if (param) {
    if (*(param + 0)) {
      if (*(param + 1)) {
        if (*(param + 2)) {
          {
          tmp___2 = strlen((char const   *)param);
          tmp___3 = tmp___2;
          }
        } else {
          tmp___3 = (size_t )2;
        }
        tmp___4 = tmp___3;
      } else {
        tmp___4 = (size_t )1;
      }
      len___0 = (int )tmp___4;
    } else {
      len___0 = 0;
    }
  } else {
    len___0 = 0;
  }
  end = param + len___0;
  {
  if (op == 1) {
    goto case_1;
  }
  if (op == 2) {
    goto case_2;
  }
  if (op == 3) {
    goto case_3;
  }
  if (op == 4) {
    goto case_4;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  p = end;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p >= (unsigned long )param)) {
      goto while_break;
    }
    c = *p;
    *p = (char )'\000';
    if (extended_glob) {
      tmp___8 = 1 << 5;
    } else {
      tmp___8 = 0;
    }
    {
    tmp___9 = fnmatch(pattern, param, tmp___8);
    }
    if (tmp___9 != 1) {
      {
      *p = c;
      tmp___5 = strlen((char const   *)p);
      tmp___6 = xmalloc(1UL + tmp___5);
      tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )p);
      }
      return (tmp___7);
    }
    *p = c;
    p --;
  }
  while_break: /* CIL Label */ ;
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  p = param;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )p <= (unsigned long )end)) {
      goto while_break___0;
    }
    c = *p;
    *p = (char )'\000';
    if (extended_glob) {
      tmp___13 = 1 << 5;
    } else {
      tmp___13 = 0;
    }
    {
    tmp___14 = fnmatch(pattern, param, tmp___13);
    }
    if (tmp___14 != 1) {
      {
      *p = c;
      tmp___10 = strlen((char const   *)p);
      tmp___11 = xmalloc(1UL + tmp___10);
      tmp___12 = strcpy((char * __restrict  )tmp___11, (char const   * __restrict  )p);
      }
      return (tmp___12);
    }
    *p = c;
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  p = param;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! ((unsigned long )p <= (unsigned long )end)) {
      goto while_break___1;
    }
    if (extended_glob) {
      tmp___18 = 1 << 5;
    } else {
      tmp___18 = 0;
    }
    {
    tmp___19 = fnmatch(pattern, p, tmp___18);
    }
    if (tmp___19 != 1) {
      {
      c = *p;
      *p = (char )'\000';
      tmp___15 = strlen((char const   *)param);
      tmp___16 = xmalloc(1UL + tmp___15);
      tmp___17 = strcpy((char * __restrict  )tmp___16, (char const   * __restrict  )param);
      ret = tmp___17;
      *p = c;
      }
      return (ret);
    }
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  p = end;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! ((unsigned long )p >= (unsigned long )param)) {
      goto while_break___2;
    }
    if (extended_glob) {
      tmp___23 = 1 << 5;
    } else {
      tmp___23 = 0;
    }
    {
    tmp___24 = fnmatch(pattern, p, tmp___23);
    }
    if (tmp___24 != 1) {
      {
      c = *p;
      *p = (char )'\000';
      tmp___20 = strlen((char const   *)param);
      tmp___21 = xmalloc(1UL + tmp___20);
      tmp___22 = strcpy((char * __restrict  )tmp___21, (char const   * __restrict  )param);
      ret = tmp___22;
      *p = c;
      }
      return (ret);
    }
    p --;
  }
  while_break___2: /* CIL Label */ ;
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  tmp___25 = strlen((char const   *)param);
  tmp___26 = xmalloc(1UL + tmp___25);
  tmp___27 = strcpy((char * __restrict  )tmp___26, (char const   * __restrict  )param);
  }
  return (tmp___27);
}
}
static int match_pattern_char(char *pat , char *string ) 
{ 
  char c ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )*string == 0) {
    return (0);
  }
  tmp = pat;
  pat ++;
  c = *tmp;
  {
  if ((int )c == 92) {
    goto case_92;
  }
  if ((int )c == 63) {
    goto case_63;
  }
  if ((int )c == 42) {
    goto case_42;
  }
  if ((int )c == 43) {
    goto case_43;
  }
  if ((int )c == 33) {
    goto case_43;
  }
  if ((int )c == 64) {
    goto case_43;
  }
  if ((int )c == 91) {
    goto case_91;
  }
  goto switch_default;
  switch_default: /* CIL Label */ 
  return ((int )*string == (int )c);
  case_92: /* CIL Label */ 
  return ((int )*string == (int )*pat);
  case_63: /* CIL Label */ 
  if ((int )*pat == 40) {
    tmp___0 = 1;
  } else {
    tmp___0 = (int )*string != 0;
  }
  return (tmp___0);
  case_42: /* CIL Label */ 
  return (1);
  case_43: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_64: /* CIL Label */ 
  if ((int )*pat == 40) {
    tmp___1 = 1;
  } else {
    tmp___1 = (int )*string == (int )c;
  }
  return (tmp___1);
  case_91: /* CIL Label */ 
  return ((int )*string != 0);
  switch_break: /* CIL Label */ ;
  }
}
}
static int match_pattern(char *string , char *pat , int mtype , char **sp , char **ep ) 
{ 
  int c ;
  register char *p ;
  register char *p1 ;
  char *end ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    return (0);
  } else { //Added block
  if ((int )*string == 0) {
    return (0);
  } else { //Added block
  if ((unsigned long )pat == (unsigned long )((char *)0)) {
    return (0);
  } else { //Added block
  if ((int )*pat == 0) {
    return (0);
  }
  }
  }
  }
  if (string) {
    if (*(string + 0)) {
      if (*(string + 1)) {
        if (*(string + 2)) {
          {
          tmp = strlen((char const   *)string);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      tmp___2 = tmp___1;
    } else {
      tmp___2 = (size_t )0;
    }
  } else {
    tmp___2 = (size_t )0;
  }
  end = string + tmp___2;
  {
  if (mtype == 0) {
    goto case_0;
  }
  if (mtype == 1) {
    goto case_1;
  }
  if (mtype == 2) {
    goto case_2;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  p = string;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p <= (unsigned long )end)) {
      goto while_break;
    }
    {
    tmp___5 = match_pattern_char(pat, p);
    }
    if (tmp___5) {
      p1 = end;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )p1 >= (unsigned long )p)) {
          goto while_break___0;
        }
        c = (int )*p1;
        *p1 = (char )'\000';
        if (extended_glob) {
          tmp___3 = 1 << 5;
        } else {
          tmp___3 = 0;
        }
        {
        tmp___4 = fnmatch(pat, p, tmp___3);
        }
        if (tmp___4 == 0) {
          *p1 = (char )c;
          *sp = p;
          *ep = p1;
          return (1);
        }
        *p1 = (char )c;
        p1 --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
  case_1: /* CIL Label */ 
  {
  tmp___6 = match_pattern_char(pat, string);
  }
  if (tmp___6 == 0) {
    return (0);
  }
  p = end;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! ((unsigned long )p >= (unsigned long )string)) {
      goto while_break___1;
    }
    c = (int )*p;
    *p = (char )'\000';
    if (extended_glob) {
      tmp___7 = 1 << 5;
    } else {
      tmp___7 = 0;
    }
    {
    tmp___8 = fnmatch(pat, string, tmp___7);
    }
    if (tmp___8 == 0) {
      *p = (char )c;
      *sp = string;
      *ep = p;
      return (1);
    }
    *p = (char )c;
    p --;
  }
  while_break___1: /* CIL Label */ ;
  }
  return (0);
  case_2: /* CIL Label */ 
  p = string;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! ((unsigned long )p <= (unsigned long )end)) {
      goto while_break___2;
    }
    if (extended_glob) {
      tmp___9 = 1 << 5;
    } else {
      tmp___9 = 0;
    }
    {
    tmp___10 = fnmatch(pat, p, tmp___9);
    }
    if (tmp___10 == 0) {
      *sp = p;
      *ep = end;
      return (1);
    }
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return (0);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int getpatspec(int c , char *value ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (c == 35) {
    if ((int )*value == 35) {
      tmp = 1;
    } else {
      tmp = 2;
    }
    return (tmp);
  } else {
    if ((int )*value == 37) {
      tmp___0 = 3;
    } else {
      tmp___0 = 4;
    }
    return (tmp___0);
  }
}
}
static char *getpattern(char *value , int quoted , int expandpat ) 
{ 
  char *pat ;
  char *tword ;
  WORD_LIST *l ;
  int i ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  WORD_LIST *tmp___6 ;

  {
  {
  tmp___4 = strchr((char const   *)value, '~');
  }
  if (tmp___4) {
    {
    tmp___0 = bash_tilde_expand(value);
    tword = tmp___0;
    }
  } else {
    {
    tmp___1 = strlen((char const   *)value);
    tmp___2 = xmalloc(1UL + tmp___1);
    tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )value);
    tword = tmp___3;
    }
  }
  if (expandpat) {
    if (quoted & 3) {
      if (*tword) {
        {
        i = 0;
        pat = string_extract_double_quoted(tword, & i, 1);
        free((void *)tword);
        tword = pat;
        }
      }
    }
  }
  if (*tword) {
    if (quoted & 3) {
      tmp___5 = 8;
    } else {
      tmp___5 = quoted;
    }
    {
    tmp___6 = expand_string_for_rhs(tword, tmp___5, (int *)((void *)0), (int *)((void *)0));
    l = tmp___6;
    }
  } else {
    l = (WORD_LIST *)0;
  }
  {
  free((void *)tword);
  pat = string_list(l);
  dispose_words(l);
  }
  if (pat) {
    {
    tword = quote_string_for_globbing((char const   *)pat, 1);
    free((void *)pat);
    pat = tword;
    }
  }
  return (pat);
}
}
static char *parameter_brace_remove_pattern(char *value , char *temp___0 , int c ,
                                            int quoted ) 
{ 
  int patspec ;
  char *pattern ;
  char *tword ;

  {
  {
  patspec = getpatspec(c, value);
  }
  if (patspec == 1) {
    value ++;
  } else { //Added block
  if (patspec == 3) {
    value ++;
  }
  }
  {
  pattern = getpattern(value, quoted, 1);
  tword = remove_pattern(temp___0, pattern, patspec);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (pattern) {
      {
      free((void *)pattern);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return (tword);
}
}
static char *list_remove_pattern(WORD_LIST *list___0 , char *pattern , int patspec ,
                                 int type , int quoted ) 
{ 
  WORD_LIST *new ;
  WORD_LIST *l ;
  WORD_DESC *w ;
  char *tword ;
  GENERIC_LIST *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  WORD_LIST *tmp___2 ;
  WORD_LIST *tmp___3 ;

  {
  new = (WORD_LIST *)((void *)0);
  l = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! l) {
      goto while_break;
    }
    {
    tword = remove_pattern((l->word)->word, pattern, patspec);
    w = make_bare_word(tword);
    free((void *)tword);
    new = make_word_list(w, new);
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (new) {
    if (new->next) {
      {
      tmp = reverse_list((GENERIC_LIST *)new);
      l = (WORD_LIST *)tmp;
      }
    } else {
      l = new;
    }
  } else {
    l = new;
  }
  if (type == 42) {
    if (quoted & 3) {
      {
      tmp___0 = string_list_dollar_star(l);
      tword = tmp___0;
      }
    } else {
      {
      tmp___1 = string_list(l);
      tword = tmp___1;
      }
    }
  } else {
    if (quoted & 3) {
      {
      tmp___2 = quote_list(l);
      tmp___3 = tmp___2;
      }
    } else {
      tmp___3 = l;
    }
    {
    tword = string_list(tmp___3);
    }
  }
  {
  dispose_words(l);
  }
  return (tword);
}
}
static char *parameter_list_remove_pattern(char *value , int type , int c , int quoted ) 
{ 
  int patspec ;
  char *pattern ;
  char *ret ;
  WORD_LIST *list___0 ;

  {
  {
  patspec = getpatspec(c, value);
  }
  if (patspec == 1) {
    value ++;
  } else { //Added block
  if (patspec == 3) {
    value ++;
  }
  }
  {
  pattern = getpattern(value, quoted, 1);
  list___0 = list_rest_of_args();
  ret = list_remove_pattern(list___0, pattern, patspec, type, quoted);
  dispose_words(list___0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (pattern) {
      {
      free((void *)pattern);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return (ret);
}
}
static char *array_remove_pattern(char *value , char *aspec , char *aval , int c ,
                                  int quoted ) 
{ 
  SHELL_VAR *var ;
  int len___0 ;
  int patspec ;
  char *ret ;
  char *t ;
  char *pattern ;
  WORD_LIST *l ;

  {
  {
  var = array_variable_part(aspec, & t, & len___0);
  }
  if ((unsigned long )var == (unsigned long )((SHELL_VAR *)0)) {
    return ((char *)((void *)0));
  }
  {
  patspec = getpatspec(c, value);
  }
  if (patspec == 1) {
    value ++;
  } else { //Added block
  if (patspec == 3) {
    value ++;
  }
  }
  {
  pattern = getpattern(value, quoted, 1);
  }
  if ((int )*(t + 0) == 64) {
    goto _L___0;
  } else { //Added block
  if ((int )*(t + 0) == 42) {
    _L___0: 
    if ((int )*(t + 1) == 93) {
      if ((var->attributes & 8) == 0) {
        {
        report_error("%s: bad array subscript", aspec);
        }
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (pattern) {
            {
            free((void *)pattern);
            }
          }
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        return ((char *)((void *)0));
      }
      {
      l = array_to_word_list((ARRAY *)var->value);
      }
      if ((unsigned long )l == (unsigned long )((WORD_LIST *)0)) {
        return ((char *)((void *)0));
      }
      {
      ret = list_remove_pattern(l, pattern, patspec, (int )*(t + 0), quoted);
      dispose_words(l);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    ret = remove_pattern(aval, pattern, patspec);
    }
    if (ret) {
      {
      t = quote_escapes(ret);
      free((void *)ret);
      ret = t;
      }
    }
  }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (pattern) {
      {
      free((void *)pattern);
      }
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (ret);
}
}
WORD_LIST *expand_word(WORD_DESC *word , int quoted ) 
{ 
  WORD_LIST *result ;
  WORD_LIST *tresult ;
  WORD_LIST *tmp ;
  WORD_LIST *tmp___0 ;

  {
  {
  tresult = call_expand_word_internal(word, quoted, 0, (int *)((void *)0), (int *)((void *)0));
  result = word_list_split(tresult);
  dispose_words(tresult);
  }
  if (result) {
    {
    tmp = dequote_list(result);
    tmp___0 = tmp;
    }
  } else {
    tmp___0 = result;
  }
  return (tmp___0);
}
}
WORD_LIST *expand_word_unsplit(WORD_DESC *word , int quoted ) 
{ 
  WORD_LIST *result ;
  WORD_LIST *tmp ;
  WORD_LIST *tmp___0 ;

  {
  {
  expand_no_split_dollar_star = 1;
  result = call_expand_word_internal(word, quoted, 0, (int *)((void *)0), (int *)((void *)0));
  expand_no_split_dollar_star = 0;
  }
  if (result) {
    {
    tmp = dequote_list(result);
    tmp___0 = tmp;
    }
  } else {
    tmp___0 = result;
  }
  return (tmp___0);
}
}
WORD_LIST *expand_word_leave_quoted(WORD_DESC *word , int quoted ) 
{ 
  WORD_LIST *tmp ;

  {
  {
  tmp = call_expand_word_internal(word, quoted, 0, (int *)((void *)0), (int *)((void *)0));
  }
  return (tmp);
}
}
static char *dev_fd_list  =    (char *)((void *)0);
static int nfds  ;
static int totfds  ;
static void add_fifo_list(int fd ) 
{ 
  int ofds ;

  {
  if (! dev_fd_list) {
    goto _L;
  } else { //Added block
  if (fd >= totfds) {
    _L: 
    {
    ofds = totfds;
    totfds = getdtablesize();
    }
    if (totfds < 0) {
      totfds = 256;
    } else { //Added block
    if (totfds > 256) {
      totfds = 256;
    }
    }
    if (fd > totfds) {
      totfds = fd + 2;
    }
    {
    dev_fd_list = xrealloc((void *)dev_fd_list, (size_t )totfds);
    bzero((void *)(dev_fd_list + ofds), (size_t )(totfds - ofds));
    }
  }
  }
  *(dev_fd_list + fd) = (char)1;
  nfds ++;
  return;
}
}
void unlink_fifo_list(void) 
{ 
  register int i ;

  {
  if (nfds == 0) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (nfds) {
      if (! (i < totfds)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (*(dev_fd_list + i)) {
      {
      close(i);
      *(dev_fd_list + i) = (char)0;
      nfds --;
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  nfds = 0;
  return;
}
}
static char *make_dev_fd_filename(int fd ) 
{ 
  char *ret ;
  char intbuf[16] ;
  char *p ;

  {
  {
  ret = xmalloc(sizeof("/dev/fd/") + 4UL);
  strcpy((char * __restrict  )ret, (char const   * __restrict  )"/dev/fd/");
  p = inttostr(fd, intbuf, (int )sizeof(intbuf));
  strcpy((char * __restrict  )((ret + sizeof("/dev/fd/")) - 1), (char const   * __restrict  )p);
  add_fifo_list(fd);
  }
  return (ret);
}
}
static char *process_substitute(char *string , int open_for_read_in_child ) 
{ 
  char *pathname ;
  int fd ;
  int result ;
  pid_t old_pid ;
  pid_t pid ;
  int parent_pipe_fd ;
  int child_pipe_fd ;
  int fildes[2] ;
  pid_t old_pipeline_pgrp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! string) {
    return ((char *)((void *)0));
  } else { //Added block
  if (! *string) {
    return ((char *)((void *)0));
  } else { //Added block
  if (wordexp_only) {
    return ((char *)((void *)0));
  }
  }
  }
  {
  tmp = pipe(fildes);
  }
  if (tmp < 0) {
    {
    sys_error("cannot make pipe for process substitution");
    }
    return ((char *)((void *)0));
  }
  {
  parent_pipe_fd = fildes[open_for_read_in_child];
  child_pipe_fd = fildes[1 - open_for_read_in_child];
  parent_pipe_fd = move_to_high_fd(parent_pipe_fd, 1, 64);
  pathname = make_dev_fd_filename(parent_pipe_fd);
  }
  if (! pathname) {
    {
    sys_error("cannot make pipe for process substitution");
    }
    return ((char *)((void *)0));
  }
  {
  old_pid = last_made_pid;
  old_pipeline_pgrp = pipeline_pgrp;
  pipeline_pgrp = shell_pgrp;
  save_pipeline(1);
  pid = make_child((char *)((void *)0), 1);
  }
  if (pid == 0) {
    {
    reset_terminating_signals();
    restore_original_signals();
    setup_async_signals();
    subshell_environment |= 4;
    }
  }
  {
  set_sigchld_handler();
  stop_making_children();
  pipeline_pgrp = old_pipeline_pgrp;
  }
  if (pid < 0) {
    {
    sys_error("cannot make child for process substitution");
    free((void *)pathname);
    close(parent_pipe_fd);
    close(child_pipe_fd);
    }
    return ((char *)((void *)0));
  }
  if (pid > 0) {
    {
    restore_pipeline(1);
    last_made_pid = old_pid;
    close(child_pipe_fd);
    }
    return (pathname);
  }
  {
  set_sigint_handler();
  set_job_control(0);
  fd = child_pipe_fd;
  }
  if (open_for_read_in_child) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  {
  tmp___2 = dup2(fd, tmp___1);
  }
  if (tmp___2 < 0) {
    if (open_for_read_in_child) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    {
    sys_error("cannot duplicate named pipe %s as fd %d", pathname, tmp___0);
    exit(127);
    }
  }
  {
  close(fd);
  }
  if (current_fds_to_close) {
    {
    close_fd_bitmap(current_fds_to_close);
    current_fds_to_close = (struct fd_bitmap *)((void *)0);
    }
  }
  {
  close(parent_pipe_fd);
  *(dev_fd_list + parent_pipe_fd) = (char)0;
  result = parse_and_execute(string, (char *)"process substitution", 5);
  exit(result);
  }
}
}
static char *read_comsub(int fd , int quoted ) 
{ 
  char *istring ;
  char buf[128] ;
  char *bufp ;
  int bufn ;
  int istring_index ;
  int istring_size ;
  int c ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  istring = (char *)((void *)0);
  bufn = 0;
  istring_size = bufn;
  istring_index = istring_size;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! (fd < 0))) {
      goto while_break;
    }
    bufn --;
    if (bufn <= 0) {
      {
      bufn = zread(fd, buf, sizeof(buf));
      }
      if (bufn <= 0) {
        goto while_break;
      }
      bufp = buf;
    }
    tmp = bufp;
    bufp ++;
    c = (int )*tmp;
    if (c == 0) {
      goto while_continue;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (istring_index + 2 >= istring_size) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (istring_index + 2 >= istring_size)) {
            goto while_break___1;
          }
          istring_size += 128;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        istring = xrealloc((void *)istring, (size_t )istring_size);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (quoted & 3) {
      tmp___0 = istring_index;
      istring_index ++;
      *(istring + tmp___0) = (char )'\001';
    } else { //Added block
    if (c == 1) {
      tmp___0 = istring_index;
      istring_index ++;
      *(istring + tmp___0) = (char )'\001';
    } else { //Added block
    if (c == 127) {
      tmp___0 = istring_index;
      istring_index ++;
      *(istring + tmp___0) = (char )'\001';
    }
    }
    }
    tmp___1 = istring_index;
    istring_index ++;
    *(istring + tmp___1) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  if (istring) {
    *(istring + istring_index) = (char )'\000';
  }
  if (istring_index == 0) {
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (istring) {
        {
        free((void *)istring);
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    return ((char *)((void *)0));
  }
  if (quoted & 3) {
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! (istring_index > 0)) {
        goto while_break___3;
      }
      if ((int )*(istring + (istring_index - 1)) == 10) {
        istring_index --;
        if ((int )*(istring + (istring_index - 1)) == 1) {
          istring_index --;
        }
      } else {
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    *(istring + istring_index) = (char )'\000';
  } else {
    {
    strip_trailing(istring, istring_index - 1, 1);
    }
  }
  return (istring);
}
}
char *command_substitute(char *string , int quoted ) 
{ 
  pid_t pid ;
  pid_t old_pid ;
  pid_t old_pipeline_pgrp ;
  char *istring ;
  int result ;
  int fildes[2] ;
  int function_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  __pid_t tmp___8 ;

  {
  istring = (char *)((void *)0);
  if (! string) {
    return ((char *)((void *)0));
  } else { //Added block
  if (! *string) {
    return ((char *)((void *)0));
  } else { //Added block
  if ((int )*(string + 0) == 10) {
    if (! *(string + 1)) {
      return ((char *)((void *)0));
    }
  }
  }
  }
  if (wordexp_only) {
    if (read_but_dont_execute) {
      {
      last_command_exit_value = 125;
      jump_to_top_level(3);
      }
    }
  }
  if ((unsigned long )subst_assign_varlist == (unsigned long )((WORD_LIST *)0)) {
    {
    maybe_make_export_env();
    }
  } else { //Added block
  if ((unsigned long )garglist == (unsigned long )((WORD_LIST *)0)) {
    {
    maybe_make_export_env();
    }
  }
  }
  {
  tmp = pipe(fildes);
  }
  if (tmp < 0) {
    {
    sys_error("cannot make pipes for command substitution");
    }
    goto error_exit;
  }
  old_pid = last_made_pid;
  old_pipeline_pgrp = pipeline_pgrp;
  if ((subshell_environment & 16) == 0) {
    pipeline_pgrp = shell_pgrp;
  }
  {
  cleanup_the_pipeline();
  pid = make_child((char *)((void *)0), 0);
  }
  if (pid == 0) {
    {
    reset_signal_handlers();
    }
  }
  {
  set_sigchld_handler();
  stop_making_children();
  pipeline_pgrp = old_pipeline_pgrp;
  }
  if (pid < 0) {
    {
    sys_error("cannot make child for command substitution");
    }
    error_exit: 
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (istring) {
        {
        free((void *)istring);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    close(fildes[0]);
    close(fildes[1]);
    }
    return ((char *)((void *)0));
  }
  if (pid == 0) {
    {
    set_sigint_handler();
    tmp___0 = dup2(fildes[1], 1);
    }
    if (tmp___0 < 0) {
      {
      sys_error("command_substitute: cannot duplicate pipe as fd 1");
      exit(1);
      }
    }
    {
    tmp___1 = fileno(stdin);
    }
    if (fildes[1] != tmp___1) {
      {
      tmp___2 = fileno(stdout);
      }
      if (fildes[1] != tmp___2) {
        {
        tmp___3 = fileno(stderr);
        }
        if (fildes[1] != tmp___3) {
          {
          close(fildes[1]);
          }
        }
      }
    }
    {
    tmp___4 = fileno(stdin);
    }
    if (fildes[0] != tmp___4) {
      {
      tmp___5 = fileno(stdout);
      }
      if (fildes[0] != tmp___5) {
        {
        tmp___6 = fileno(stderr);
        }
        if (fildes[0] != tmp___6) {
          {
          close(fildes[0]);
          }
        }
      }
    }
    interactive = 0;
    subshell_environment |= 4;
    if (posixly_correct == 0) {
      exit_immediately_on_error = 0;
    }
    {
    remove_quoted_escapes(string);
    startup_state = 2;
    result = __sigsetjmp(top_level, 1);
    }
    if (result == 0) {
      if (return_catch_flag) {
        {
        function_value = __sigsetjmp(return_catch, 1);
        }
      } else {
        function_value = 0;
      }
    } else {
      function_value = 0;
    }
    if (result == 3) {
      {
      exit(last_command_exit_value);
      }
    } else { //Added block
    if (result) {
      {
      exit(1);
      }
    } else { //Added block
    if (function_value) {
      {
      exit(return_catch_value);
      }
    } else {
      {
      tmp___7 = parse_and_execute(string, (char *)"command substitution", 4);
      exit(tmp___7);
      }
    }
    }
    }
  } else {
    {
    close(fildes[1]);
    istring = read_comsub(fildes[0], quoted);
    close(fildes[0]);
    current_command_subst_pid = pid;
    last_command_exit_value = wait_for(pid);
    last_command_subst_pid = pid;
    last_made_pid = old_pid;
    }
    if (last_command_exit_value == 130) {
      {
      tmp___8 = getpid();
      kill(tmp___8, 2);
      }
    }
    if (interactive) {
      if (pipeline_pgrp != 0) {
        if ((subshell_environment & 1) == 0) {
          {
          give_terminal_to(pipeline_pgrp, 0);
          }
        }
      }
    }
    return (istring);
  }
}
}
int valid_array_reference(char *name ) 
{ 
  char *t ;
  int r ;
  int len___0 ;
  int tmp ;

  {
  {
  t = strchr((char const   *)name, '[');
  }
  if (t) {
    {
    *t = (char )'\000';
    r = legal_identifier(name);
    *t = (char )'[';
    }
    if (r == 0) {
      return (0);
    }
    {
    len___0 = skipsubscript(t, 0);
    }
    if ((int )*(t + len___0) != 93) {
      return (0);
    } else { //Added block
    if (len___0 == 1) {
      return (0);
    }
    }
    r = 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (r < len___0)) {
        goto while_break;
      }
      if ((int )*(t + r) == 32) {
        tmp = 1;
      } else { //Added block
      if ((int )*(t + r) == 9) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      }
      if (tmp == 0) {
        return (1);
      }
      r ++;
    }
    while_break: /* CIL Label */ ;
    }
    return (0);
  }
  return (0);
}
}
int array_expand_index(char *s , int len___0 ) 
{ 
  char *exp ;
  char *t ;
  int val___0 ;
  int expok ;
  long tmp ;

  {
  {
  exp = xmalloc((size_t )len___0);
  strncpy((char * __restrict  )exp, (char const   * __restrict  )s, (size_t )(len___0 - 1));
  *(exp + (len___0 - 1)) = (char )'\000';
  t = maybe_expand_string(exp, 0, (WORD_LIST *(*)())(& expand_string));
  this_command_name = (char *)((void *)0);
  tmp = evalexp(t, & expok);
  val___0 = (int )tmp;
  free((void *)t);
  free((void *)exp);
  }
  if (expok == 0) {
    {
    last_command_exit_value = 1;
    jump_to_top_level(2);
    }
  }
  return (val___0);
}
}
SHELL_VAR *array_variable_part(char *s , char **subp , int *lenp ) 
{ 
  char *t ;
  int ind___1 ;
  int ni ;
  SHELL_VAR *var ;
  char *tmp ;

  {
  {
  t = strchr((char const   *)s, '[');
  ind___1 = (int )(t - s);
  ni = skipsubscript(s, ind___1);
  }
  if (ni <= ind___1 + 1) {
    {
    report_error("%s: bad array subscript", s);
    }
    return ((SHELL_VAR *)((void *)0));
  } else { //Added block
  if ((int )*(s + ni) != 93) {
    {
    report_error("%s: bad array subscript", s);
    }
    return ((SHELL_VAR *)((void *)0));
  }
  }
  {
  *t = (char )'\000';
  var = find_variable(s);
  tmp = t;
  t ++;
  *tmp = (char )'[';
  }
  if (subp) {
    *subp = t;
  }
  if (lenp) {
    *lenp = ni - ind___1;
  }
  return (var);
}
}
static char *array_value_internal(char *s , int quoted , int allow_all ) 
{ 
  int len___0 ;
  int ind___1 ;
  char *retval ;
  char *t ;
  char *temp___0 ;
  WORD_LIST *l ;
  SHELL_VAR *var ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  var = array_variable_part(s, & t, & len___0);
  }
  if ((unsigned long )var == (unsigned long )((SHELL_VAR *)0)) {
    return ((char *)((void *)0));
  }
  if ((int )*(t + 0) == 64) {
    goto _L___0;
  } else { //Added block
  if ((int )*(t + 0) == 42) {
    _L___0: 
    if ((int )*(t + 1) == 93) {
      if (allow_all == 0) {
        {
        report_error("%s: bad array subscript", s);
        }
        return ((char *)((void *)0));
      } else { //Added block
      if ((var->attributes & 8) == 0) {
        {
        l = (WORD_LIST *)((void *)0);
        l = add_string_to_list(var->value, l);
        }
      } else {
        {
        l = array_to_word_list((ARRAY *)var->value);
        }
        if ((unsigned long )l == (unsigned long )((WORD_LIST *)((void *)0))) {
          return ((char *)((void *)0));
        }
      }
      }
      if ((int )*(t + 0) == 42) {
        if (quoted & 3) {
          {
          temp___0 = string_list_dollar_star(l);
          retval = quote_string(temp___0);
          free((void *)temp___0);
          }
        } else {
          {
          retval = string_list_dollar_at(l, quoted);
          }
        }
      } else {
        {
        retval = string_list_dollar_at(l, quoted);
        }
      }
      {
      dispose_words(l);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    ind___1 = array_expand_index(t, len___0);
    }
    if (ind___1 < 0) {
      {
      report_error("%s: bad array subscript", var->name);
      }
      return ((char *)((void *)0));
    }
    if ((var->attributes & 8) == 0) {
      if (ind___1 == 0) {
        {
        tmp = strlen((char const   *)var->value);
        tmp___0 = xmalloc(1UL + tmp);
        tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )var->value);
        tmp___2 = tmp___1;
        }
      } else {
        tmp___2 = (char *)((void *)0);
      }
      return (tmp___2);
    }
    {
    retval = array_reference((ARRAY *)var->value, ind___1);
    }
    if (retval) {
      {
      retval = quote_escapes(retval);
      }
    }
  }
  }
  return (retval);
}
}
static char *array_value(char *s , int quoted ) 
{ 
  char *tmp ;

  {
  {
  tmp = array_value_internal(s, quoted, 1);
  }
  return (tmp);
}
}
char *get_array_value(char *s , int allow_all ) 
{ 
  char *tmp ;

  {
  {
  tmp = array_value_internal(s, 0, allow_all);
  }
  return (tmp);
}
}
static int array_length_reference(char *s ) 
{ 
  int ind___1 ;
  int len___0 ;
  char *t ;
  ARRAY *array ;
  SHELL_VAR *var ;
  char *tmp ;
  arrayind_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
  var = array_variable_part(s, & t, & len___0);
  }
  if ((unsigned long )var == (unsigned long )((SHELL_VAR *)0)) {
    goto _L___0;
  } else { //Added block
  if ((var->attributes & 8) == 0) {
    _L___0: 
    if (unbound_vars_is_error) {
      {
      t --;
      ind___1 = (int )*t;
      *t = (char )'\000';
      report_error("%s: unbound variable", s);
      tmp = t;
      t ++;
      *tmp = (char )ind___1;
      }
      return (-1);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((unsigned long )var == (unsigned long )((SHELL_VAR *)0)) {
    return (0);
  }
  }
  }
  if (var->attributes & 8) {
    array = (ARRAY *)var->value;
  } else {
    array = (ARRAY *)((void *)0);
  }
  if ((int )*(t + 0) == 64) {
    goto _L___1;
  } else { //Added block
  if ((int )*(t + 0) == 42) {
    _L___1: 
    if ((int )*(t + 1) == 93) {
      if (var->attributes & 8) {
        tmp___0 = array->num_elements;
      } else {
        tmp___0 = 1;
      }
      return (tmp___0);
    }
  }
  }
  {
  ind___1 = array_expand_index(t, len___0);
  }
  if (ind___1 < 0) {
    {
    report_error("%s: bad array subscript", t);
    }
    return (-1);
  }
  if (var->attributes & 8) {
    {
    t = array_reference(array, ind___1);
    }
  } else { //Added block
  if (ind___1 == 0) {
    t = var->value;
  } else {
    t = (char *)((void *)0);
  }
  }
  if (t) {
    if (*(t + 0)) {
      if (*(t + 1)) {
        if (*(t + 2)) {
          {
          tmp___1 = strlen((char const   *)t);
          tmp___2 = tmp___1;
          }
        } else {
          tmp___2 = (size_t )2;
        }
        tmp___3 = tmp___2;
      } else {
        tmp___3 = (size_t )1;
      }
      len___0 = (int )tmp___3;
    } else {
      len___0 = 0;
    }
  } else {
    len___0 = 0;
  }
  return (len___0);
}
}
extern int isdigit() ;
static int valid_brace_expansion_word(char *name , int var_is_special ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp___1 = isdigit((int )*name);
  }
  if (tmp___1) {
    {
    tmp___2 = all_digits(name);
    }
    if (tmp___2) {
      return (1);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (var_is_special) {
    return (1);
  } else {
    {
    tmp___0 = valid_array_reference(name);
    }
    if (tmp___0) {
      return (1);
    } else {
      {
      tmp = legal_identifier(name);
      }
      if (tmp) {
        return (1);
      } else {
        return (0);
      }
    }
  }
  }
}
}
static char *parameter_brace_expand_word(char *name , int var_is_special , int quoted ) 
{ 
  char *temp___0 ;
  char *tt___0 ;
  int arg_index ;
  SHELL_VAR *var ;
  int sindex ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp___2 = isdigit((int )*name);
  }
  if (tmp___2) {
    {
    arg_index = atoi((char const   *)name);
    temp___0 = get_dollar_var_value(arg_index);
    }
  } else { //Added block
  if (var_is_special) {
    {
    tmp = strlen((char const   *)name);
    tt___0 = xmalloc(2UL + tmp);
    sindex = 0;
    *(tt___0 + sindex) = (char )'$';
    strcpy((char * __restrict  )(tt___0 + 1), (char const   * __restrict  )name);
    temp___0 = param_expand(tt___0, & sindex, quoted, (int *)((void *)0), (int *)((void *)0),
                            (int *)((void *)0), (int *)((void *)0), 0);
    free((void *)tt___0);
    }
  } else {
    {
    tmp___1 = valid_array_reference(name);
    }
    if (tmp___1) {
      {
      temp___0 = array_value(name, quoted);
      }
    } else {
      {
      var = find_variable(name);
      }
      if (var) {
        if (var) {
          if ((var->attributes & 4) == 0) {
            if (var->attributes & 8) {
              {
              tmp___0 = array_reference((ARRAY *)var->value, 0);
              temp___0 = tmp___0;
              }
            } else {
              temp___0 = var->value;
            }
            if (temp___0) {
              {
              temp___0 = quote_escapes(temp___0);
              }
            }
            if (var->attributes & 512) {
              {
              dispose_variable(var);
              }
            }
          } else {
            temp___0 = (char *)((void *)0);
          }
        } else {
          temp___0 = (char *)((void *)0);
        }
      } else {
        temp___0 = (char *)((void *)0);
      }
    }
  }
  }
  return (temp___0);
}
}
static char *parameter_brace_expand_indir(char *name , int var_is_special , int quoted ) 
{ 
  char *temp___0 ;
  char *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  t = parameter_brace_expand_word(name, var_is_special, quoted);
  }
  if ((unsigned long )t == (unsigned long )((char *)0)) {
    return (t);
  }
  {
  tmp = isdigit((int )*t);
  }
  if (tmp) {
    {
    tmp___0 = all_digits(t);
    }
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(t + 1) == 0) {
    if (sh_syntaxtab[*t] & 2048) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  }
  {
  temp___0 = parameter_brace_expand_word(t, tmp___1, quoted);
  free((void *)t);
  }
  return (temp___0);
}
}
static char *parameter_brace_expand_rhs(char *name , char *value , int c , int quoted ,
                                        int *qdollaratp , int *hasdollarat ) 
{ 
  WORD_LIST *l ;
  char *t ;
  char *t1 ;
  char *temp___0 ;
  int hasdol ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  WORD_LIST *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  if ((int )*value == 126) {
    {
    tmp___1 = bash_tilde_expand(value);
    temp___0 = tmp___1;
    }
  } else {
    {
    tmp___5 = strchr((char const   *)value, '~');
    }
    if (tmp___5) {
      {
      tmp___6 = unquoted_substring((char *)"=~", value);
      }
      if (tmp___6) {
        {
        tmp___1 = bash_tilde_expand(value);
        temp___0 = tmp___1;
        }
      } else {
        {
        tmp___2 = strlen((char const   *)value);
        tmp___3 = xmalloc(1UL + tmp___2);
        tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )value);
        temp___0 = tmp___4;
        }
      }
    } else {
      {
      tmp___2 = strlen((char const   *)value);
      tmp___3 = xmalloc(1UL + tmp___2);
      tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )value);
      temp___0 = tmp___4;
      }
    }
  }
  if (quoted & 3) {
    if (*temp___0) {
      {
      hasdol = 0;
      t = string_extract_double_quoted(temp___0, & hasdol, 1);
      free((void *)temp___0);
      temp___0 = t;
      }
    }
  }
  hasdol = 0;
  if (*temp___0) {
    {
    tmp___7 = expand_string_for_rhs(temp___0, quoted, & hasdol, (int *)((void *)0));
    l = tmp___7;
    }
  } else {
    l = (WORD_LIST *)0;
  }
  if (hasdollarat) {
    if (hasdol) {
      tmp___8 = 1;
    } else { //Added block
    if (l) {
      if (l->next) {
        tmp___8 = 1;
      } else {
        tmp___8 = 0;
      }
    } else {
      tmp___8 = 0;
    }
    }
    *hasdollarat = tmp___8;
  }
  {
  free((void *)temp___0);
  }
  if (l) {
    {
    temp___0 = string_list(l);
    }
    if (hasdol) {
      if (quoted) {
        *qdollaratp = 1;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (l->next) {
      *qdollaratp = 1;
    }
    }
    {
    dispose_words(l);
    }
  } else { //Added block
  if (quoted & 3) {
    if (hasdol) {
      {
      temp___0 = xmalloc((size_t )2);
      *(temp___0 + 0) = (char )'\177';
      *(temp___0 + 1) = (char )'\000';
      }
    } else {
      temp___0 = (char *)((void *)0);
    }
  } else {
    temp___0 = (char *)((void *)0);
  }
  }
  if (c == 45) {
    return (temp___0);
  } else { //Added block
  if (c == 43) {
    return (temp___0);
  }
  }
  if (temp___0) {
    {
    tmp___9 = strlen((char const   *)temp___0);
    tmp___10 = xmalloc(1UL + tmp___9);
    tmp___11 = strcpy((char * __restrict  )tmp___10, (char const   * __restrict  )temp___0);
    t = tmp___11;
    }
  } else {
    {
    tmp___12 = strlen("");
    tmp___13 = xmalloc(1UL + tmp___12);
    tmp___14 = strcpy((char * __restrict  )tmp___13, (char const   * __restrict  )"");
    t = tmp___14;
    }
  }
  {
  t1 = dequote_string(t);
  free((void *)t);
  bind_variable(name, t1);
  free((void *)t1);
  }
  return (temp___0);
}
}
static void parameter_brace_expand_error(char *name , char *value ) 
{ 
  WORD_LIST *l ;
  char *temp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;

  {
  if (value) {
    if (*value) {
      if ((int )*value == 126) {
        {
        tmp___1 = bash_tilde_expand(value);
        temp___0 = tmp___1;
        }
      } else {
        {
        tmp___5 = strchr((char const   *)value, '~');
        }
        if (tmp___5) {
          {
          tmp___6 = unquoted_substring((char *)"=~", value);
          }
          if (tmp___6) {
            {
            tmp___1 = bash_tilde_expand(value);
            temp___0 = tmp___1;
            }
          } else {
            {
            tmp___2 = strlen((char const   *)value);
            tmp___3 = xmalloc(1UL + tmp___2);
            tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )value);
            temp___0 = tmp___4;
            }
          }
        } else {
          {
          tmp___2 = strlen((char const   *)value);
          tmp___3 = xmalloc(1UL + tmp___2);
          tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )value);
          temp___0 = tmp___4;
          }
        }
      }
      {
      l = expand_string(temp___0, 0);
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (temp___0) {
          {
          free((void *)temp___0);
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
      temp___0 = string_list(l);
      }
      if (temp___0) {
        tmp___7 = (char const   *)temp___0;
      } else {
        tmp___7 = "";
      }
      {
      report_error("%s: %s", name, tmp___7);
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (temp___0) {
          {
          free((void *)temp___0);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      dispose_words(l);
      }
    } else {
      {
      report_error("%s: parameter null or not set", name);
      }
    }
  } else {
    {
    report_error("%s: parameter null or not set", name);
    }
  }
  {
  free((void *)name);
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (value) {
      {
      free((void *)value);
      }
    }
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
static int valid_length_expression(char *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((int )*(name + 1) == 0) {
    tmp___3 = 1;
  } else { //Added block
  if (sh_syntaxtab[*(name + 1)] & 2048) {
    if ((int )*(name + 2) == 0) {
      tmp___3 = 1;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    {
    tmp = isdigit((int )*(name + 1));
    }
    if (tmp) {
      {
      tmp___0 = all_digits(name + 1);
      }
      if (tmp___0) {
        tmp___3 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
      tmp___1 = valid_array_reference(name + 1);
      }
      if (tmp___1) {
        tmp___3 = 1;
      } else {
        {
        tmp___2 = legal_identifier(name + 1);
        }
        if (tmp___2) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      }
    }
  }
  }
  return (tmp___3);
}
}
static int parameter_brace_expand_length(char *name ) 
{ 
  char *t ;
  char *newname ;
  int number ;
  WORD_LIST *list___0 ;
  SHELL_VAR *var ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  if ((int )*(name + 1) == 0) {
    {
    number = number_of_args();
    }
  } else { //Added block
  if ((int )*(name + 1) == 64) {
    goto _L___2;
  } else { //Added block
  if ((int )*(name + 1) == 42) {
    _L___2: 
    if ((int )*(name + 2) == 0) {
      {
      number = number_of_args();
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (sh_syntaxtab[*(name + 1)] & 2048) {
    if ((int )*(name + 2) == 0) {
      {
      if ((int )*(name + 1) == 45) {
        goto case_45;
      }
      if ((int )*(name + 1) == 63) {
        goto case_63;
      }
      if ((int )*(name + 1) == 36) {
        goto case_36;
      }
      if ((int )*(name + 1) == 33) {
        goto case_33;
      }
      if ((int )*(name + 1) == 35) {
        goto case_35;
      }
      goto switch_break;
      case_45: /* CIL Label */ 
      {
      t = which_set_flags();
      }
      goto switch_break;
      case_63: /* CIL Label */ 
      {
      t = itos(last_command_exit_value);
      }
      goto switch_break;
      case_36: /* CIL Label */ 
      {
      t = itos(dollar_dollar_pid);
      }
      goto switch_break;
      case_33: /* CIL Label */ 
      if (last_asynchronous_pid == -1) {
        t = (char *)((void *)0);
      } else {
        {
        t = itos(last_asynchronous_pid);
        }
      }
      goto switch_break;
      case_35: /* CIL Label */ 
      {
      tmp = number_of_args();
      t = itos(tmp);
      }
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      if (t) {
        if (*(t + 0)) {
          if (*(t + 1)) {
            if (*(t + 2)) {
              {
              tmp___0 = strlen((char const   *)t);
              tmp___1 = tmp___0;
              }
            } else {
              tmp___1 = (size_t )2;
            }
            tmp___2 = tmp___1;
          } else {
            tmp___2 = (size_t )1;
          }
          number = (int )tmp___2;
        } else {
          number = 0;
        }
      } else {
        number = 0;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (t) {
          {
          free((void *)t);
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    {
    tmp___18 = valid_array_reference(name + 1);
    }
    if (tmp___18) {
      {
      number = array_length_reference(name + 1);
      }
    } else {
      {
      number = 0;
      tmp___17 = isdigit((int )*(name + 1));
      }
      if (tmp___17) {
        {
        tmp___3 = atoi((char const   *)(name + 1));
        t = get_dollar_var_value(tmp___3);
        }
        if (t) {
          if (*(t + 0)) {
            if (*(t + 1)) {
              if (*(t + 2)) {
                {
                tmp___4 = strlen((char const   *)t);
                tmp___5 = tmp___4;
                }
              } else {
                tmp___5 = (size_t )2;
              }
              tmp___6 = tmp___5;
            } else {
              tmp___6 = (size_t )1;
            }
            number = (int )tmp___6;
          } else {
            number = 0;
          }
        } else {
          number = 0;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (t) {
            {
            free((void *)t);
            }
          }
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
        var = find_variable(name + 1);
        }
        if (var) {
          if (var->attributes & 8) {
            {
            t = array_reference((ARRAY *)var->value, 0);
            }
            if (t) {
              if (*(t + 0)) {
                if (*(t + 1)) {
                  if (*(t + 2)) {
                    {
                    tmp___7 = strlen((char const   *)t);
                    tmp___8 = tmp___7;
                    }
                  } else {
                    tmp___8 = (size_t )2;
                  }
                  tmp___9 = tmp___8;
                } else {
                  tmp___9 = (size_t )1;
                }
                number = (int )tmp___9;
              } else {
                number = 0;
              }
            } else {
              number = 0;
            }
          } else {
            goto _L;
          }
        } else {
          _L: 
          {
          tmp___10 = strlen((char const   *)name);
          tmp___11 = xmalloc(1UL + tmp___10);
          tmp___12 = strcpy((char * __restrict  )tmp___11, (char const   * __restrict  )name);
          newname = tmp___12;
          *(newname + 0) = (char )'$';
          list___0 = expand_string(newname, 1);
          }
          if (list___0) {
            {
            tmp___13 = string_list(list___0);
            t = tmp___13;
            }
          } else {
            t = (char *)((void *)0);
          }
          {
          free((void *)newname);
          }
          if (list___0) {
            {
            dispose_words(list___0);
            }
          }
          if (t) {
            if (*(t + 0)) {
              if (*(t + 1)) {
                if (*(t + 2)) {
                  {
                  tmp___14 = strlen((char const   *)t);
                  tmp___15 = tmp___14;
                  }
                } else {
                  tmp___15 = (size_t )2;
                }
                tmp___16 = tmp___15;
              } else {
                tmp___16 = (size_t )1;
              }
              number = (int )tmp___16;
            } else {
              number = 0;
            }
          } else {
            number = 0;
          }
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (t) {
              {
              free((void *)t);
              }
            }
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
  }
  }
  }
  return (number);
}
}
static char *skiparith(char *substr , int delim ) 
{ 
  int skipcol ;
  int pcount ;
  char *t ;

  {
  pcount = 0;
  skipcol = pcount;
  t = substr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *t) {
      goto while_break;
    }
    if ((int )*t == 40) {
      pcount ++;
      goto __Cont;
    }
    if ((int )*t == 41) {
      if (pcount) {
        pcount --;
        goto __Cont;
      }
    }
    if (pcount) {
      goto __Cont;
    }
    if ((int )*t == 58) {
      if (skipcol) {
        skipcol --;
        goto __Cont;
      }
    }
    if ((int )*t == delim) {
      goto while_break;
    }
    if ((int )*t == 63) {
      skipcol ++;
      goto __Cont;
    }
    __Cont: 
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (t);
}
}
static int verify_substring_values(char *value , char *substr , int vtype , int *e1p ,
                                   int *e2p ) 
{ 
  char *t ;
  char *temp1 ;
  char *temp2 ;
  int len___0 ;
  int expok ;
  ARRAY *a ;
  long tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;

  {
  {
  t = skiparith(substr, ':');
  }
  if (*t) {
    if ((int )*t == 58) {
      *t = (char )'\000';
    } else {
      t = (char *)0;
    }
  } else {
    t = (char *)0;
  }
  {
  temp1 = maybe_expand_string(substr, 1, (WORD_LIST *(*)())(& expand_string));
  tmp = evalexp(temp1, & expok);
  *e1p = (int )tmp;
  free((void *)temp1);
  }
  if (expok == 0) {
    return (0);
  }
  {
  if (vtype == 0) {
    goto case_0;
  }
  if (vtype == 3) {
    goto case_0;
  }
  if (vtype == 1) {
    goto case_1;
  }
  if (vtype == 2) {
    goto case_2;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  tmp___0 = strlen((char const   *)value);
  len___0 = (int )tmp___0;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  tmp___1 = number_of_args();
  len___0 = tmp___1 + 1;
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  a = (ARRAY *)value;
  len___0 = a->num_elements + 1;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (*e1p < 0) {
    *e1p += len___0;
  }
  if (*e1p >= len___0) {
    return (-1);
  } else { //Added block
  if (*e1p < 0) {
    return (-1);
  }
  }
  if (t) {
    {
    t ++;
    tmp___2 = strlen((char const   *)t);
    tmp___3 = xmalloc(1UL + tmp___2);
    tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )t);
    temp2 = tmp___4;
    temp1 = maybe_expand_string(temp2, 1, (WORD_LIST *(*)())(& expand_string));
    free((void *)temp2);
    *(t + -1) = (char )':';
    tmp___5 = evalexp(temp1, & expok);
    *e2p = (int )tmp___5;
    free((void *)temp1);
    }
    if (expok == 0) {
      return (0);
    }
    if (*e2p < 0) {
      {
      internal_error("%s: substring expression < 0", t);
      }
      return (0);
    }
    *e2p += *e1p;
    if (*e2p > len___0) {
      *e2p = len___0;
    }
  } else {
    *e2p = len___0;
  }
  return (1);
}
}
static int get_var_and_type(char *varname___0 , char *value , SHELL_VAR **varp , char **valp ) 
{ 
  int vtype ;
  char *temp___0 ;
  SHELL_VAR *v___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )*(varname___0 + 0) == 64) {
    goto _L;
  } else { //Added block
  if ((int )*(varname___0 + 0) == 42) {
    _L: 
    if ((int )*(varname___0 + 1) == 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  }
  {
  vtype = tmp;
  *varp = (SHELL_VAR *)((void *)0);
  tmp___0 = valid_array_reference(varname___0);
  }
  if (tmp___0) {
    {
    v___0 = array_variable_part(varname___0, & temp___0, (int *)0);
    }
    if (v___0) {
      if (v___0->attributes & 8) {
        if ((int )*(temp___0 + 0) == 64) {
          goto _L___0;
        } else { //Added block
        if ((int )*(temp___0 + 0) == 42) {
          _L___0: 
          if ((int )*(temp___0 + 1) == 93) {
            vtype = 2;
            *valp = (char *)((ARRAY *)v___0->value);
          } else {
            {
            vtype = 3;
            *valp = array_value(varname___0, 1);
            }
          }
        } else {
          {
          vtype = 3;
          *valp = array_value(varname___0, 1);
          }
        }
        }
        *varp = v___0;
      } else {
        return (-1);
      }
    } else {
      return (-1);
    }
  } else {
    {
    v___0 = find_variable(varname___0);
    }
    if (v___0) {
      if (v___0->attributes & 8) {
        {
        vtype = 0;
        *varp = v___0;
        *valp = array_reference((ARRAY *)v___0->value, 0);
        }
      } else {
        *valp = value;
      }
    } else {
      *valp = value;
    }
  }
  return (vtype);
}
}
static char *parameter_brace_substring(char *varname___0 , char *value , char *substr ,
                                       int quoted ) 
{ 
  int e1 ;
  int e2 ;
  int vtype ;
  int r ;
  char *temp___0 ;
  char *val___0 ;
  SHELL_VAR *v___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned long )value == (unsigned long )((char *)0)) {
    return ((char *)((void *)0));
  }
  {
  this_command_name = varname___0;
  vtype = get_var_and_type(varname___0, value, & v___0, & val___0);
  }
  if (vtype == -1) {
    return ((char *)((void *)0));
  }
  {
  r = verify_substring_values(val___0, substr, vtype, & e1, & e2);
  }
  if (r <= 0) {
    if (val___0) {
      if (vtype == 3) {
        {
        free((void *)val___0);
        }
      }
    }
    if (r == 0) {
      tmp = & expand_param_error;
    } else {
      tmp = (char *)((void *)0);
    }
    return (tmp);
  }
  {
  if (vtype == 0) {
    goto case_0;
  }
  if (vtype == 3) {
    goto case_0;
  }
  if (vtype == 1) {
    goto case_1;
  }
  if (vtype == 2) {
    goto case_2;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  if (quoted) {
    {
    tmp___0 = quoted_substring(value, e1, e2);
    temp___0 = tmp___0;
    }
  } else {
    {
    tmp___1 = substring(value, e1, e2);
    temp___0 = tmp___1;
    }
  }
  if (val___0) {
    if (vtype == 3) {
      {
      free((void *)val___0);
      }
    }
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  temp___0 = pos_params(varname___0, e1, e2, quoted);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  temp___0 = array_subrange((ARRAY *)v___0->value, e1, e2, quoted);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (temp___0);
}
}
char *pat_subst(char *string , char *pat , char *rep , int mflags ) 
{ 
  char *ret ;
  char *s ;
  char *e ;
  char *str ;
  int rsize ;
  int rptr ;
  int l ;
  int replen ;
  int mtype ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;

  {
  mtype = mflags & 3;
  if ((unsigned long )pat == (unsigned long )((char *)0)) {
    goto _L___0;
  } else { //Added block
  if ((int )*pat == 0) {
    _L___0: 
    if (mtype == 1) {
      goto _L;
    } else { //Added block
    if (mtype == 2) {
      _L: 
      if (rep) {
        if (*(rep + 0)) {
          if (*(rep + 1)) {
            if (*(rep + 2)) {
              {
              tmp = strlen((char const   *)rep);
              tmp___0 = tmp;
              }
            } else {
              tmp___0 = (size_t )2;
            }
            tmp___1 = tmp___0;
          } else {
            tmp___1 = (size_t )1;
          }
          replen = (int )tmp___1;
        } else {
          replen = 0;
        }
      } else {
        replen = 0;
      }
      {
      tmp___2 = strlen((char const   *)string);
      l = (int )tmp___2;
      ret = xmalloc((size_t )((replen + l) + 2));
      }
      if (replen == 0) {
        {
        strcpy((char * __restrict  )ret, (char const   * __restrict  )string);
        }
      } else { //Added block
      if (mtype == 1) {
        {
        strcpy((char * __restrict  )ret, (char const   * __restrict  )rep);
        strcpy((char * __restrict  )(ret + replen), (char const   * __restrict  )string);
        }
      } else {
        {
        strcpy((char * __restrict  )ret, (char const   * __restrict  )string);
        strcpy((char * __restrict  )(ret + l), (char const   * __restrict  )rep);
        }
      }
      }
      return (ret);
    }
    }
  }
  }
  {
  rsize = 64;
  ret = xmalloc((size_t )rsize);
  *(ret + 0) = (char )'\000';
  }
  if (rep) {
    if (*(rep + 0)) {
      if (*(rep + 1)) {
        if (*(rep + 2)) {
          {
          tmp___3 = strlen((char const   *)rep);
          tmp___4 = tmp___3;
          }
        } else {
          tmp___4 = (size_t )2;
        }
        tmp___5 = tmp___4;
      } else {
        tmp___5 = (size_t )1;
      }
      replen = (int )tmp___5;
    } else {
      replen = 0;
    }
  } else {
    replen = 0;
  }
  rptr = 0;
  str = string;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___6 = match_pattern(str, pat, mtype, & s, & e);
    }
    if (tmp___6 == 0) {
      goto while_break;
    }
    l = (int )(s - str);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (rptr + (l + replen) >= rsize) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (rptr + (l + replen) >= rsize)) {
            goto while_break___1;
          }
          rsize += 64;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        ret = xrealloc((void *)ret, (size_t )rsize);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (l) {
      {
      strncpy((char * __restrict  )(ret + rptr), (char const   * __restrict  )str,
              (size_t )l);
      rptr += l;
      }
    }
    if (replen) {
      {
      strncpy((char * __restrict  )(ret + rptr), (char const   * __restrict  )rep,
              (size_t )replen);
      rptr += replen;
      }
    }
    if ((unsigned long )s == (unsigned long )e) {
      e ++;
    }
    str = e;
    if ((mflags & 16) == 0) {
      goto while_break;
    } else { //Added block
    if (mtype != 0) {
      goto while_break;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (*str) {
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (str) {
        if (*(str + 0)) {
          if (*(str + 1)) {
            if (*(str + 2)) {
              {
              tmp___11 = strlen((char const   *)str);
              tmp___12 = tmp___11;
              }
            } else {
              tmp___12 = (size_t )2;
            }
            tmp___13 = tmp___12;
          } else {
            tmp___13 = (size_t )1;
          }
          tmp___14 = tmp___13;
        } else {
          tmp___14 = (size_t )0;
        }
      } else {
        tmp___14 = (size_t )0;
      }
      if ((size_t )rptr + (tmp___14 + 1UL) >= (size_t )rsize) {
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (str) {
            if (*(str + 0)) {
              if (*(str + 1)) {
                if (*(str + 2)) {
                  {
                  tmp___7 = strlen((char const   *)str);
                  tmp___8 = tmp___7;
                  }
                } else {
                  tmp___8 = (size_t )2;
                }
                tmp___9 = tmp___8;
              } else {
                tmp___9 = (size_t )1;
              }
              tmp___10 = tmp___9;
            } else {
              tmp___10 = (size_t )0;
            }
          } else {
            tmp___10 = (size_t )0;
          }
          if (! ((size_t )rptr + (tmp___10 + 1UL) >= (size_t )rsize)) {
            goto while_break___3;
          }
          rsize += 64;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
        ret = xrealloc((void *)ret, (size_t )rsize);
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    strcpy((char * __restrict  )(ret + rptr), (char const   * __restrict  )str);
    }
  } else {
    *(ret + rptr) = (char )'\000';
  }
  return (ret);
}
}
static char *pos_params_pat_subst(char *string , char *pat , char *rep , int mflags ) 
{ 
  WORD_LIST *save ;
  WORD_LIST *params ;
  WORD_DESC *w ;
  char *ret ;
  WORD_LIST *tmp ;
  WORD_LIST *tmp___0 ;

  {
  {
  params = list_rest_of_args();
  save = params;
  }
  if ((unsigned long )save == (unsigned long )((WORD_LIST *)0)) {
    return ((char *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! params) {
      goto while_break;
    }
    {
    ret = pat_subst((params->word)->word, pat, rep, mflags);
    w = make_bare_word(ret);
    dispose_word(params->word);
    params->word = w;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (ret) {
        {
        free((void *)ret);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    params = params->next;
  }
  while_break: /* CIL Label */ ;
  }
  if (mflags & 32) {
    {
    tmp = quote_list(save);
    tmp___0 = tmp;
    }
  } else {
    tmp___0 = save;
  }
  {
  ret = string_list(tmp___0);
  dispose_words(save);
  }
  return (ret);
}
}
static char *parameter_brace_patsub(char *varname___0 , char *value , char *patsub ,
                                    int quoted ) 
{ 
  int vtype ;
  int mflags ;
  char *val___0 ;
  char *temp___0 ;
  char *pat ;
  char *rep ;
  char *p ;
  char *lpatsub ;
  SHELL_VAR *v___0 ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if ((unsigned long )value == (unsigned long )((char *)0)) {
    return ((char *)((void *)0));
  }
  {
  this_command_name = varname___0;
  vtype = get_var_and_type(varname___0, value, & v___0, & val___0);
  }
  if (vtype == -1) {
    return ((char *)((void *)0));
  }
  mflags = 0;
  if ((int )*patsub == 47) {
    mflags |= 16;
    patsub ++;
  }
  {
  tmp = strlen((char const   *)patsub);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )patsub);
  lpatsub = tmp___1;
  }
  if (quoted & 3) {
    mflags |= 32;
  }
  {
  rep = quoted_strchr(lpatsub, '/', 1);
  }
  if (rep) {
    tmp___2 = rep;
    rep ++;
    *tmp___2 = (char )'\000';
  } else {
    rep = (char *)((void *)0);
  }
  if (rep) {
    if ((int )*rep == 0) {
      rep = (char *)((void *)0);
    }
  }
  {
  pat = maybe_expand_string(lpatsub, quoted & -2, (WORD_LIST *(*)())(& expand_string_unsplit));
  }
  if (rep) {
    if ((mflags & 32) == 0) {
      {
      rep = maybe_expand_string(rep, quoted, (WORD_LIST *(*)())(& expand_string_unsplit));
      }
    } else {
      {
      rep = expand_string_to_string(rep, quoted, (WORD_LIST *(*)())(& expand_string_unsplit));
      }
    }
  }
  p = pat;
  if (pat) {
    if ((int )*(pat + 0) == 35) {
      mflags |= 1;
      p ++;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (pat) {
    if ((int )*(pat + 0) == 37) {
      mflags |= 2;
      p ++;
    } else {
      mflags = mflags;
    }
  } else {
    mflags = mflags;
  }
  }
  {
  if (vtype == 0) {
    goto case_0;
  }
  if (vtype == 3) {
    goto case_0;
  }
  if (vtype == 1) {
    goto case_1;
  }
  if (vtype == 2) {
    goto case_2;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  temp___0 = pat_subst(val___0, p, rep, mflags);
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  temp___0 = pos_params_pat_subst(val___0, p, rep, mflags);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  temp___0 = array_pat_subst((ARRAY *)v___0->value, p, rep, mflags);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (val___0) {
    if (v___0) {
      if (v___0->attributes & 8) {
        if (vtype == 3) {
          {
          free((void *)val___0);
          }
        }
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (pat) {
      {
      free((void *)pat);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (rep) {
      {
      free((void *)rep);
      }
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  free((void *)lpatsub);
  }
  return (temp___0);
}
}
extern int isalpha() ;
static char *parameter_brace_expand(char *string , int *indexp , int quoted , int *quoted_dollar_atp ,
                                    int *contains_dollar_at ) 
{ 
  int check_nullness ;
  int var_is_set ;
  int var_is_null ;
  int var_is_special ;
  int want_substring ;
  int want_indir ;
  int want_patsub ;
  char *name ;
  char *value ;
  char *temp___0 ;
  char *temp1 ;
  int t_index ;
  int sindex ;
  int c ;
  int number ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char **x ;
  WORD_LIST *xlist ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;

  {
  {
  value = (char *)((void *)0);
  check_nullness = 0;
  var_is_special = check_nullness;
  var_is_null = var_is_special;
  var_is_set = var_is_null;
  want_patsub = 0;
  want_indir = want_patsub;
  want_substring = want_indir;
  sindex = *indexp;
  sindex ++;
  t_index = sindex;
  name = string_extract(string, & t_index, (char *)"#%:-=?+/}", 1);
  }
  if (sindex == t_index) {
    if ((int )*(string + t_index) == 45) {
      goto _L___0;
    } else { //Added block
    if ((int )*(string + t_index) == 63) {
      goto _L___0;
    } else { //Added block
    if ((int )*(string + t_index) == 35) {
      goto _L___0;
    } else {
      goto _L___1;
    }
    }
    }
  } else { //Added block
  _L___1: 
  if (sindex == t_index - 1) {
    if ((int )*(string + sindex) == 33) {
      if ((int )*(string + t_index) == 35) {
        goto _L___0;
      } else { //Added block
      if ((int )*(string + t_index) == 63) {
        goto _L___0;
      } else { //Added block
      if ((int )*(string + t_index) == 64) {
        goto _L___0;
      } else { //Added block
      if ((int )*(string + t_index) == 42) {
        _L___0: 
        {
        t_index ++;
        free((void *)name);
        temp1 = string_extract(string, & t_index, (char *)"#%:-=?+/}", 0);
        tmp = strlen((char const   *)temp1);
        name = xmalloc(3UL + tmp);
        *name = *(string + sindex);
        }
        if ((int )*(string + sindex) == 33) {
          {
          *(name + 1) = *(string + (sindex + 1));
          strcpy((char * __restrict  )(name + 2), (char const   * __restrict  )temp1);
          }
        } else {
          {
          strcpy((char * __restrict  )(name + 1), (char const   * __restrict  )temp1);
          }
        }
        {
        free((void *)temp1);
        }
      }
      }
      }
      }
    }
  }
  }
  sindex = t_index;
  c = (int )*(string + sindex);
  if (c) {
    sindex ++;
  }
  if (c == 58) {
    if ((int )*(string + sindex) == 45) {
      goto _L___4;
    } else { //Added block
    if ((int )*(string + sindex) == 61) {
      goto _L___4;
    } else { //Added block
    if ((int )*(string + sindex) == 63) {
      goto _L___4;
    } else { //Added block
    if ((int )*(string + sindex) == 43) {
      _L___4: 
      check_nullness ++;
      c = (int )*(string + sindex);
      if (c) {
        sindex ++;
      }
    } else {
      goto _L___3;
    }
    }
    }
    }
  } else { //Added block
  _L___3: 
  if (c == 58) {
    if ((int )*(string + sindex) != 125) {
      want_substring = 1;
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if (c == 47) {
    if ((int )*(string + sindex) != 125) {
      want_patsub = 1;
    }
  }
  }
  }
  if ((int )*(name + 0) == 35) {
    if ((int )*(name + 1) == 0) {
      if (check_nullness == 0) {
        if (c == 45) {
          goto _L___5;
        } else { //Added block
        if (c == 63) {
          goto _L___5;
        } else { //Added block
        if (c == 35) {
          _L___5: 
          if ((int )*(string + sindex) == 125) {
            {
            name = xrealloc((void *)name, (size_t )3);
            *(name + 1) = (char )c;
            *(name + 2) = (char )'\000';
            tmp___0 = sindex;
            sindex ++;
            c = (int )*(string + tmp___0);
            }
          }
        }
        }
        }
      }
    }
  }
  if ((int )*(name + 0) == 35) {
    if ((int )*(name + 1) == 0) {
      if (check_nullness == 0) {
        if (c) {
          {
          tmp___1 = strchr("%:=+/", c);
          tmp___2 = (unsigned long )tmp___1 != (unsigned long )((char *)((void *)0));
          }
        } else {
          tmp___2 = 0;
        }
        if (tmp___2) {
          if ((int )*(string + sindex) == 125) {
            temp___0 = (char *)((void *)0);
            goto bad_substitution;
          }
        }
      }
    }
  }
  if ((int )*name == 33) {
    {
    tmp___3 = isalpha((int )*(name + 1));
    }
    if (tmp___3) {
      tmp___5 = 1;
    } else { //Added block
    if ((int )*(name + 1) == 95) {
      tmp___5 = 1;
    } else {
      {
      tmp___4 = isdigit((int )*(name + 1));
      }
      if (tmp___4) {
        tmp___5 = 1;
      } else { //Added block
      if ((int )*(name + 1) == 35) {
        tmp___5 = 1;
      } else { //Added block
      if ((int )*(name + 1) == 63) {
        tmp___5 = 1;
      } else { //Added block
      if ((int )*(name + 1) == 64) {
        tmp___5 = 1;
      } else { //Added block
      if ((int )*(name + 1) == 42) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
      }
      }
      }
      }
    }
    }
  } else {
    tmp___5 = 0;
  }
  {
  want_indir = tmp___5;
  tmp___6 = isdigit((int )*name);
  }
  if (tmp___6) {
    {
    tmp___7 = all_digits(name);
    }
    if (tmp___7) {
      var_is_special ++;
    } else {
      goto _L___7;
    }
  } else { //Added block
  _L___7: 
  if ((int )*(name + 1) == 0) {
    if (sh_syntaxtab[*name] & 2048) {
      var_is_special ++;
    } else {
      goto _L___6;
    }
  } else { //Added block
  _L___6: 
  if (want_indir) {
    if ((int )*(name + 2) == 0) {
      if ((int )*(name + 1) == 35) {
        var_is_special ++;
      } else { //Added block
      if ((int )*(name + 1) == 63) {
        var_is_special ++;
      } else { //Added block
      if ((int )*(name + 1) == 64) {
        var_is_special ++;
      } else { //Added block
      if ((int )*(name + 1) == 42) {
        var_is_special ++;
      }
      }
      }
      }
    }
  }
  }
  }
  if ((int )*name == 35) {
    if (*(name + 1)) {
      if ((int )*(string + (sindex - 1)) != 125) {
        temp___0 = (char *)((void *)0);
        goto bad_substitution;
      } else {
        {
        tmp___8 = valid_length_expression(name);
        }
        if (tmp___8 == 0) {
          temp___0 = (char *)((void *)0);
          goto bad_substitution;
        }
      }
      {
      number = parameter_brace_expand_length(name);
      free((void *)name);
      *indexp = sindex;
      }
      if (number < 0) {
        tmp___10 = & expand_param_error;
      } else {
        {
        tmp___9 = itos(number);
        tmp___10 = tmp___9;
        }
      }
      return (tmp___10);
    }
  }
  if ((int )*(name + 0) == 64) {
    if ((int )*(name + 1) == 0) {
      if (quoted & 3) {
        if (quoted_dollar_atp) {
          *quoted_dollar_atp = 1;
        }
      }
      if (contains_dollar_at) {
        *contains_dollar_at = 1;
      }
    }
  }
  if (want_indir) {
    if ((int )*(string + (sindex - 1)) == 125) {
      if ((int )*(string + (sindex - 2)) == 42) {
        goto _L___9;
      } else { //Added block
      if ((int )*(string + (sindex - 2)) == 64) {
        _L___9: 
        {
        tmp___15 = isalpha((int )*(name + 1));
        }
        if (tmp___15) {
          goto _L___8;
        } else { //Added block
        if ((int )*(name + 1) == 95) {
          _L___8: 
          {
          tmp___11 = strlen((char const   *)(name + 1));
          tmp___12 = xmalloc(1UL + tmp___11);
          tmp___13 = strcpy((char * __restrict  )tmp___12, (char const   * __restrict  )(name + 1));
          temp1 = tmp___13;
          tmp___14 = strlen((char const   *)temp1);
          number = (int )tmp___14;
          *(temp1 + (number - 1)) = (char )'\000';
          x = all_variables_matching_prefix(temp1);
          xlist = argv_to_word_list(x, 1, 0);
          }
          if ((int )*(string + (sindex - 2)) == 42) {
            {
            temp___0 = string_list_dollar_star(xlist);
            }
          } else {
            {
            temp___0 = string_list_dollar_at(xlist, quoted);
            }
            if (quoted & 3) {
              if (quoted_dollar_atp) {
                *quoted_dollar_atp = 1;
              }
            }
            if (contains_dollar_at) {
              *contains_dollar_at = 1;
            }
          }
          {
          free((void *)x);
          free((void *)xlist);
          free((void *)temp1);
          *indexp = sindex;
          }
          return (temp___0);
        }
        }
      }
      }
    }
  }
  if (want_indir) {
    tmp___16 = name + 1;
  } else {
    tmp___16 = name;
  }
  {
  tmp___17 = valid_brace_expansion_word(tmp___16, var_is_special);
  }
  if (tmp___17 == 0) {
    temp___0 = (char *)((void *)0);
    goto bad_substitution;
  }
  if (want_indir) {
    {
    temp___0 = parameter_brace_expand_indir(name + 1, var_is_special, quoted);
    }
  } else {
    {
    temp___0 = parameter_brace_expand_word(name, var_is_special, quoted);
    }
  }
  {
  tmp___18 = valid_array_reference(name);
  }
  if (tmp___18) {
    {
    temp1 = strchr((char const   *)name, '[');
    }
    if (temp1) {
      if ((int )*(temp1 + 1) == 64) {
        if ((int )*(temp1 + 2) == 93) {
          if (quoted & 3) {
            if (quoted_dollar_atp) {
              *quoted_dollar_atp = 1;
            }
          }
          if (contains_dollar_at) {
            *contains_dollar_at = 1;
          }
        }
      }
    }
    if (temp1) {
      if ((int )*(temp1 + 1) == 42) {
        if ((int )*(temp1 + 2) == 93) {
          if (quoted == 0) {
            if (contains_dollar_at) {
              *contains_dollar_at = 1;
            }
          }
        }
      }
    }
  }
  var_is_set = (unsigned long )temp___0 != (unsigned long )((char *)0);
  if (check_nullness) {
    if (var_is_set == 0) {
      tmp___19 = 1;
    } else { //Added block
    if ((int )*temp___0 == 0) {
      tmp___19 = 1;
    } else {
      tmp___19 = 0;
    }
    }
  } else {
    tmp___19 = 0;
  }
  var_is_null = tmp___19;
  if (c) {
    if (c != 125) {
      {
      value = extract_dollar_brace_string(string, & sindex, quoted);
      }
      if ((int )*(string + sindex) == 125) {
        sindex ++;
      } else {
        goto bad_substitution;
      }
    } else {
      value = (char *)((void *)0);
    }
  } else {
    value = (char *)((void *)0);
  }
  *indexp = sindex;
  if (want_substring) {
    {
    temp1 = parameter_brace_substring(name, temp___0, value, quoted);
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (name) {
        {
        free((void *)name);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (value) {
        {
        free((void *)value);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (temp___0) {
        {
        free((void *)temp___0);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    return (temp1);
  } else { //Added block
  if (want_patsub) {
    {
    temp1 = parameter_brace_patsub(name, temp___0, value, quoted);
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (name) {
        {
        free((void *)name);
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (value) {
        {
        free((void *)value);
        }
      }
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (temp___0) {
        {
        free((void *)temp___0);
        }
      }
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    return (temp1);
  }
  }
  {
  if (c == 125) {
    goto case_125;
  }
  if (c == 35) {
    goto case_35;
  }
  if (c == 37) {
    goto case_35;
  }
  if (c == 45) {
    goto case_45;
  }
  if (c == 61) {
    goto case_45;
  }
  if (c == 63) {
    goto case_45;
  }
  if (c == 43) {
    goto case_45;
  }
  goto bad_substitution;
  bad_substitution: 
  switch_default: /* CIL Label */ 
  if (string) {
    tmp___20 = (char const   *)string;
  } else {
    tmp___20 = "??";
  }
  {
  report_error("%s: bad substitution", tmp___20);
  }
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    if (value) {
      {
      free((void *)value);
      }
    }
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___6: /* CIL Label */ ;
    if (temp___0) {
      {
      free((void *)temp___0);
      }
    }
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  free((void *)name);
  }
  return (& expand_param_error);
  case_125: /* CIL Label */ 
  if (var_is_set == 0) {
    if (unbound_vars_is_error) {
      {
      report_error("%s: unbound variable", name);
      }
      {
      while (1) {
        while_continue___7: /* CIL Label */ ;
        if (value) {
          {
          free((void *)value);
          }
        }
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        if (temp___0) {
          {
          free((void *)temp___0);
          }
        }
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
      free((void *)name);
      last_command_exit_value = 1;
      }
      if (interactive_shell) {
        tmp___21 = & expand_param_error;
      } else {
        tmp___21 = & expand_param_fatal;
      }
      return (tmp___21);
    }
  }
  goto switch_break;
  case_35: /* CIL Label */ 
  case_37: /* CIL Label */ 
  if ((unsigned long )value == (unsigned long )((char *)0)) {
    goto _L___10;
  } else { //Added block
  if ((int )*value == 0) {
    goto _L___10;
  } else { //Added block
  if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
    goto _L___10;
  } else { //Added block
  if ((int )*temp___0 == 0) {
    _L___10: 
    {
    while (1) {
      while_continue___9: /* CIL Label */ ;
      if (value) {
        {
        free((void *)value);
        }
      }
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    goto switch_break;
  }
  }
  }
  }
  if ((int )*(name + 0) == 64) {
    goto _L___12;
  } else { //Added block
  if ((int )*(name + 0) == 42) {
    _L___12: 
    if ((int )*(name + 1) == 0) {
      {
      temp1 = parameter_list_remove_pattern(value, (int )*(name + 0), c, quoted);
      }
    } else {
      goto _L___11;
    }
  } else {
    _L___11: 
    {
    tmp___22 = valid_array_reference(name);
    }
    if (tmp___22) {
      {
      temp1 = array_remove_pattern(value, name, temp___0, c, quoted);
      }
    } else {
      {
      temp1 = parameter_brace_remove_pattern(value, temp___0, c, quoted);
      }
    }
  }
  }
  {
  free((void *)temp___0);
  free((void *)value);
  temp___0 = temp1;
  }
  goto switch_break;
  case_45: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_43: /* CIL Label */ 
  if (var_is_set) {
    if (var_is_null == 0) {
      if (c == 43) {
        if (quoted & 3) {
          if (quoted_dollar_atp) {
            *quoted_dollar_atp = 0;
          }
        }
        if (contains_dollar_at) {
          *contains_dollar_at = 0;
        }
        {
        while (1) {
          while_continue___10: /* CIL Label */ ;
          if (temp___0) {
            {
            free((void *)temp___0);
            }
          }
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
        if (value) {
          {
          temp___0 = parameter_brace_expand_rhs(name, value, c, quoted, quoted_dollar_atp,
                                                contains_dollar_at);
          free((void *)value);
          }
        } else {
          temp___0 = (char *)((void *)0);
        }
      } else {
        {
        while (1) {
          while_continue___11: /* CIL Label */ ;
          if (value) {
            {
            free((void *)value);
            }
          }
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
    } else {
      goto _L___14;
    }
  } else {
    _L___14: 
    {
    while (1) {
      while_continue___12: /* CIL Label */ ;
      if (temp___0) {
        {
        free((void *)temp___0);
        }
      }
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    temp___0 = (char *)((void *)0);
    if (c == 61) {
      if (var_is_special) {
        {
        report_error("$%s: cannot assign in this way", name);
        free((void *)name);
        free((void *)value);
        }
        return (& expand_param_error);
      } else {
        goto _L___13;
      }
    } else { //Added block
    _L___13: 
    if (c == 63) {
      {
      parameter_brace_expand_error(name, value);
      }
      if (interactive_shell) {
        tmp___23 = & expand_param_error;
      } else {
        tmp___23 = & expand_param_fatal;
      }
      return (tmp___23);
    } else { //Added block
    if (c != 43) {
      if (quoted & 3) {
        if (quoted_dollar_atp) {
          *quoted_dollar_atp = 0;
        }
      }
      if (contains_dollar_at) {
        *contains_dollar_at = 0;
      }
      {
      temp___0 = parameter_brace_expand_rhs(name, value, c, quoted, quoted_dollar_atp,
                                            contains_dollar_at);
      }
    }
    }
    }
    {
    free((void *)value);
    }
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  free((void *)name);
  }
  return (temp___0);
}
}
static char *param_expand(char *string , int *sindex , int quoted , int *expanded_something ,
                          int *contains_dollar_at , int *quoted_dollar_at_p , int *had_quoted_null_p ,
                          int pflags ) 
{ 
  char *temp___0 ;
  char *temp1 ;
  int zindex ;
  int number ;
  int c ;
  int t_index ;
  int expok ;
  SHELL_VAR *var ;
  WORD_LIST *list___0 ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *temp2 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  zindex = *sindex;
  zindex ++;
  c = (int )*(string + zindex);
  temp___0 = (char *)((void *)0);
  {
  if (c == 48) {
    goto case_48;
  }
  if (c == 49) {
    goto case_48;
  }
  if (c == 50) {
    goto case_48;
  }
  if (c == 51) {
    goto case_48;
  }
  if (c == 52) {
    goto case_48;
  }
  if (c == 53) {
    goto case_48;
  }
  if (c == 54) {
    goto case_48;
  }
  if (c == 55) {
    goto case_48;
  }
  if (c == 56) {
    goto case_48;
  }
  if (c == 57) {
    goto case_48;
  }
  if (c == 36) {
    goto case_36;
  }
  if (c == 35) {
    goto case_35;
  }
  if (c == 63) {
    goto case_63;
  }
  if (c == 45) {
    goto case_45;
  }
  if (c == 33) {
    goto case_33;
  }
  if (c == 42) {
    goto case_42;
  }
  if (c == 64) {
    goto case_64;
  }
  if (c == 123) {
    goto case_123;
  }
  if (c == 40) {
    goto case_40;
  }
  if (c == 91) {
    goto case_91;
  }
  goto switch_default;
  case_48: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_57: /* CIL Label */ 
  temp1 = dollar_vars[c - 48];
  if (unbound_vars_is_error) {
    if ((unsigned long )temp1 == (unsigned long )((char *)((void *)0))) {
      {
      report_error("$%c: unbound variable", c);
      last_command_exit_value = 1;
      }
      if (interactive_shell) {
        tmp = & expand_param_error;
      } else {
        tmp = & expand_param_fatal;
      }
      return (tmp);
    }
  }
  if (temp1) {
    {
    tmp___0 = strlen((char const   *)temp1);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )temp1);
    temp___0 = tmp___2;
    }
  } else {
    temp___0 = (char *)((void *)0);
  }
  goto switch_break;
  case_36: /* CIL Label */ 
  {
  temp___0 = itos(dollar_dollar_pid);
  }
  goto switch_break;
  case_35: /* CIL Label */ 
  {
  tmp___3 = number_of_args();
  temp___0 = itos(tmp___3);
  }
  goto switch_break;
  case_63: /* CIL Label */ 
  {
  temp___0 = itos(last_command_exit_value);
  }
  goto switch_break;
  case_45: /* CIL Label */ 
  {
  temp___0 = which_set_flags();
  }
  goto switch_break;
  case_33: /* CIL Label */ 
  if (last_asynchronous_pid == -1) {
    if (expanded_something) {
      *expanded_something = 0;
    }
    temp___0 = (char *)((void *)0);
    if (unbound_vars_is_error) {
      {
      report_error("$%c: unbound variable", c);
      last_command_exit_value = 1;
      }
      if (interactive_shell) {
        tmp___4 = & expand_param_error;
      } else {
        tmp___4 = & expand_param_fatal;
      }
      return (tmp___4);
    }
  } else {
    {
    temp___0 = itos(last_asynchronous_pid);
    }
  }
  goto switch_break;
  case_42: /* CIL Label */ 
  {
  list___0 = list_rest_of_args();
  }
  if (quoted & 3) {
    if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
      temp___0 = (char *)((void *)0);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (quoted & 3) {
    {
    temp___0 = string_list_dollar_star(list___0);
    temp1 = quote_string(temp___0);
    free((void *)temp___0);
    temp___0 = temp1;
    }
  } else {
    {
    temp___0 = string_list_dollar_at(list___0, quoted);
    }
    if (expand_no_split_dollar_star == 0) {
      if (contains_dollar_at) {
        *contains_dollar_at = 1;
      }
    }
  }
  }
  {
  dispose_words(list___0);
  }
  goto switch_break;
  case_64: /* CIL Label */ 
  {
  list___0 = list_rest_of_args();
  }
  if (quoted_dollar_at_p) {
    if (quoted & 3) {
      *quoted_dollar_at_p = 1;
    }
  }
  if (contains_dollar_at) {
    *contains_dollar_at = 1;
  }
  {
  temp___0 = string_list_dollar_at(list___0, quoted);
  dispose_words(list___0);
  }
  goto switch_break;
  case_123: /* CIL Label */ 
  {
  temp___0 = parameter_brace_expand(string, & zindex, quoted, quoted_dollar_at_p,
                                    contains_dollar_at);
  }
  if ((unsigned long )temp___0 == (unsigned long )(& expand_param_error)) {
    return (temp___0);
  } else { //Added block
  if ((unsigned long )temp___0 == (unsigned long )(& expand_param_fatal)) {
    return (temp___0);
  }
  }
  if (temp___0) {
    if ((int )*(temp___0 + 0) == 127) {
      if ((int )*(temp___0 + 1) == 0) {
        if (had_quoted_null_p) {
          *had_quoted_null_p = 1;
        }
        if (*quoted_dollar_at_p == 0) {
          {
          free((void *)temp___0);
          temp___0 = (char *)((void *)0);
          }
        }
      }
    }
  }
  goto return0;
  case_40: /* CIL Label */ 
  {
  t_index = zindex + 1;
  temp___0 = extract_command_subst(string, & t_index);
  zindex = t_index;
  }
  if (temp___0) {
    if ((int )*temp___0 == 40) {
      {
      temp1 = temp___0 + 1;
      tmp___5 = strlen((char const   *)temp1);
      tmp___6 = xmalloc(1UL + tmp___5);
      tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )temp1);
      temp2 = tmp___7;
      tmp___8 = strlen((char const   *)temp2);
      t_index = (int )(tmp___8 - 1UL);
      }
      if ((int )*(temp2 + t_index) != 41) {
        {
        free((void *)temp2);
        }
        goto comsub;
      }
      {
      *(temp2 + t_index) = (char )'\000';
      temp1 = maybe_expand_string(temp2, 1, (WORD_LIST *(*)())(& expand_string));
      free((void *)temp2);
      }
      arithsub: 
      {
      this_command_name = (char *)((void *)0);
      tmp___9 = evalexp(temp1, & expok);
      number = (int )tmp___9;
      free((void *)temp___0);
      free((void *)temp1);
      }
      if (expok == 0) {
        if (interactive_shell == 0) {
          if (posixly_correct) {
            last_command_exit_value = 1;
            return (& expand_param_fatal);
          } else {
            return (& expand_param_error);
          }
        } else {
          return (& expand_param_error);
        }
      }
      {
      temp___0 = itos(number);
      }
      goto switch_break;
    }
  }
  comsub: 
  {
  temp1 = command_substitute(temp___0, quoted);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (temp___0) {
      {
      free((void *)temp___0);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  temp___0 = temp1;
  goto switch_break;
  case_91: /* CIL Label */ 
  {
  t_index = zindex + 1;
  temp___0 = extract_arithmetic_subst(string, & t_index);
  zindex = t_index;
  temp1 = maybe_expand_string(temp___0, 1, (WORD_LIST *(*)())(& expand_string));
  }
  goto arithsub;
  switch_default: /* CIL Label */ 
  temp___0 = (char *)((void *)0);
  t_index = zindex;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    c = (int )*(string + zindex);
    if (c) {
      {
      tmp___10 = isalpha(c);
      }
      if (! tmp___10) {
        {
        tmp___11 = isdigit(c);
        }
        if (! tmp___11) {
          if (! (c == 95)) {
            goto while_break___0;
          }
        }
      }
    } else {
      goto while_break___0;
    }
    zindex ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (zindex > t_index) {
    {
    tmp___12 = substring(string, t_index, zindex);
    temp1 = tmp___12;
    }
  } else {
    temp1 = (char *)((void *)0);
  }
  if ((unsigned long )temp1 == (unsigned long )((char *)0)) {
    goto _L___0;
  } else { //Added block
  if ((int )*temp1 == 0) {
    _L___0: 
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (temp1) {
        {
        free((void *)temp1);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    temp___0 = xmalloc((size_t )2);
    *(temp___0 + 0) = (char )'$';
    *(temp___0 + 1) = (char )'\000';
    }
    if (expanded_something) {
      *expanded_something = 0;
    }
    goto return0;
  }
  }
  {
  var = find_variable(temp1);
  }
  if (var) {
    if ((var->attributes & 4) == 0) {
      if (var->value) {
        if (var->attributes & 8) {
          {
          temp___0 = array_reference((ARRAY *)var->value, 0);
          }
          if (temp___0) {
            {
            temp___0 = quote_escapes(temp___0);
            }
          }
        } else {
          {
          temp___0 = quote_escapes(var->value);
          }
        }
        {
        free((void *)temp1);
        }
        if (var->attributes & 512) {
          {
          dispose_variable(var);
          var = (SHELL_VAR *)((void *)0);
          }
        }
        goto return0;
      }
    }
  }
  temp___0 = (char *)((void *)0);
  if (unbound_vars_is_error) {
    {
    report_error("%s: unbound variable", temp1);
    }
  } else {
    {
    free((void *)temp1);
    }
    goto return0;
  }
  {
  free((void *)temp1);
  last_command_exit_value = 1;
  }
  if (unbound_vars_is_error) {
    if (interactive_shell == 0) {
      tmp___13 = & expand_param_fatal;
    } else {
      tmp___13 = & expand_param_error;
    }
  } else {
    tmp___13 = & expand_param_error;
  }
  return (tmp___13);
  switch_break: /* CIL Label */ ;
  }
  if (*(string + zindex)) {
    zindex ++;
  }
  return0: 
  *sindex = zindex;
  return (temp___0);
}
}
static WORD_LIST *expand_word_internal(WORD_DESC *word , int quoted , int isexp ,
                                       int *contains_dollar_at , int *expanded_something ) 
{ 
  WORD_LIST *list___0 ;
  WORD_DESC *tword ;
  char *istring ;
  int istring_size ;
  int istring_index ;
  char *temp___0 ;
  char *temp1 ;
  register char *string ;
  int sindex ;
  int quoted_dollar_at ;
  int quoted_state ;
  int had_quoted_null ;
  int has_dollar_at ;
  int tflag ;
  register int c ;
  int t_index ;
  char ifscmap[256] ;
  char twochars[2] ;
  char const   *tmp ;
  char *tmp___0 ;
  WORD_LIST *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  WORD_LIST *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *ifs_chars ;
  char *tmp___12 ;
  char const   *tmp___13 ;

  {
  {
  istring_size = 112;
  istring = xmalloc((size_t )istring_size);
  istring_index = 0;
  *(istring + istring_index) = (char )'\000';
  has_dollar_at = 0;
  had_quoted_null = has_dollar_at;
  quoted_dollar_at = had_quoted_null;
  quoted_state = 0;
  string = word->word;
  }
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    goto finished_with_string;
  }
  if (contains_dollar_at) {
    *contains_dollar_at = 0;
  }
  {
  temp___0 = getifs();
  bzero((void *)(ifscmap), sizeof(ifscmap));
  temp1 = temp___0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (temp1) {
      if (! *temp1) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    ifscmap[(unsigned char )*temp1] = (char)1;
    temp1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  sindex = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    c = (int )*(string + sindex);
    {
    if (c == 0) {
      goto case_0;
    }
    if (c == 1) {
      goto case_1;
    }
    if (c == 60) {
      goto case_60;
    }
    if (c == 62) {
      goto case_60;
    }
    if (c == 36) {
      goto case_36;
    }
    if (c == 96) {
      goto case_96;
    }
    if (c == 92) {
      goto case_92;
    }
    if (c == 34) {
      goto case_34;
    }
    if (c == 39) {
      goto case_39;
    }
    goto switch_default;
    case_0: /* CIL Label */ 
    goto finished_with_string;
    case_1: /* CIL Label */ 
    {
    temp___0 = xmalloc((size_t )3);
    *(temp___0 + 0) = (char )'\001';
    sindex ++;
    c = (int )*(string + sindex);
    *(temp___0 + 1) = (char )c;
    *(temp___0 + 2) = (char )'\000';
    }
    dollar_add_string: 
    if (*(string + sindex)) {
      sindex ++;
    }
    add_string: 
    if (temp___0) {
      {
      istring = sub_append_string(temp___0, istring, & istring_index, & istring_size);
      temp___0 = (char *)0;
      }
    }
    goto switch_break;
    case_60: /* CIL Label */ 
    case_62: /* CIL Label */ 
    sindex ++;
    if ((int )*(string + sindex) != 40) {
      sindex --;
      goto add_character;
    } else { //Added block
    if (quoted & 3) {
      sindex --;
      goto add_character;
    } else { //Added block
    if (posixly_correct) {
      sindex --;
      goto add_character;
    } else {
      t_index = sindex + 1;
    }
    }
    }
    if (c == 60) {
      tmp = "<(";
    } else {
      tmp = ">(";
    }
    {
    temp1 = extract_process_subst(string, (char *)tmp, & t_index);
    sindex = t_index;
    }
    if (temp1) {
      {
      tmp___0 = process_substitute(temp1, c == 62);
      temp___0 = tmp___0;
      }
    } else {
      temp___0 = (char *)0;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (temp1) {
        {
        free((void *)temp1);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    goto dollar_add_string;
    case_36: /* CIL Label */ 
    if (expanded_something) {
      *expanded_something = 1;
    }
    {
    has_dollar_at = 0;
    temp___0 = param_expand(string, & sindex, quoted, expanded_something, & has_dollar_at,
                            & quoted_dollar_at, & had_quoted_null, 0);
    }
    if ((unsigned long )temp___0 == (unsigned long )(& expand_param_error)) {
      goto _L;
    } else { //Added block
    if ((unsigned long )temp___0 == (unsigned long )(& expand_param_fatal)) {
      _L: 
      {
      free((void *)string);
      free((void *)istring);
      }
      if ((unsigned long )temp___0 == (unsigned long )(& expand_param_error)) {
        tmp___1 = & expand_word_error;
      } else {
        tmp___1 = & expand_word_fatal;
      }
      return (tmp___1);
    }
    }
    if (contains_dollar_at) {
      if (has_dollar_at) {
        *contains_dollar_at = 1;
      }
    }
    goto add_string;
    goto switch_break;
    case_96: /* CIL Label */ 
    sindex ++;
    if (expanded_something) {
      *expanded_something = 1;
    }
    {
    temp___0 = string_extract(string, & sindex, (char *)"`", 0);
    de_backslash(temp___0);
    temp1 = command_substitute(temp___0, quoted);
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (temp___0) {
        {
        free((void *)temp___0);
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    temp___0 = temp1;
    goto dollar_add_string;
    case_92: /* CIL Label */ 
    if ((int )*(string + (sindex + 1)) == 10) {
      sindex += 2;
      goto __Cont;
    }
    sindex ++;
    c = (int )*(string + sindex);
    if (quoted & 2) {
      tflag = 128;
    } else { //Added block
    if (quoted & 1) {
      tflag = 64;
    } else {
      tflag = 0;
    }
    }
    if (quoted & 3) {
      if ((sh_syntaxtab[c] & (int const   )tflag) == 0) {
        twochars[0] = (char )'\\';
        twochars[1] = (char )c;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (c == 0) {
      c = '\177';
      sindex --;
      goto add_character;
    } else {
      twochars[0] = (char )'\001';
      twochars[1] = (char )c;
    }
    }
    sindex ++;
    add_twochars: 
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (istring_index + 2 >= istring_size) {
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          if (! (istring_index + 2 >= istring_size)) {
            goto while_break___4;
          }
          istring_size += 128;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
        istring = xrealloc((void *)istring, (size_t )istring_size);
        }
      }
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    tmp___2 = istring_index;
    istring_index ++;
    *(istring + tmp___2) = twochars[0];
    tmp___3 = istring_index;
    istring_index ++;
    *(istring + tmp___3) = twochars[1];
    *(istring + istring_index) = (char )'\000';
    goto switch_break;
    case_34: /* CIL Label */ 
    if (quoted & 11) {
      goto add_character;
    }
    {
    sindex ++;
    t_index = sindex;
    temp___0 = string_extract_double_quoted(string, & sindex, 0);
    }
    if (t_index == 1) {
      if ((int )*(string + sindex) == 0) {
        quoted_state = 2;
      } else {
        quoted_state = 1;
      }
    } else {
      quoted_state = 1;
    }
    if (temp___0) {
      if (*temp___0) {
        {
        tword = make_word(temp___0);
        free((void *)temp___0);
        temp___0 = (char *)((void *)0);
        has_dollar_at = 0;
        list___0 = expand_word_internal(tword, 1, 0, & has_dollar_at, (int *)((void *)0));
        }
        if ((unsigned long )list___0 == (unsigned long )(& expand_word_error)) {
          {
          free((void *)istring);
          free((void *)string);
          tword->word = (char *)((void *)0);
          dispose_word(tword);
          }
          return (list___0);
        } else { //Added block
        if ((unsigned long )list___0 == (unsigned long )(& expand_word_fatal)) {
          {
          free((void *)istring);
          free((void *)string);
          tword->word = (char *)((void *)0);
          dispose_word(tword);
          }
          return (list___0);
        }
        }
        {
        dispose_word(tword);
        }
        if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
          if (has_dollar_at) {
            quoted_dollar_at ++;
            goto switch_break;
          }
        }
        if (list___0) {
          {
          dequote_list(list___0);
          }
        }
        if (has_dollar_at) {
          quoted_dollar_at ++;
          if (contains_dollar_at) {
            *contains_dollar_at = 1;
          }
          if (expanded_something) {
            *expanded_something = 1;
          }
        }
      } else {
        {
        free((void *)temp___0);
        list___0 = (WORD_LIST *)((void *)0);
        }
      }
    } else {
      {
      free((void *)temp___0);
      list___0 = (WORD_LIST *)((void *)0);
      }
    }
    if (list___0) {
      if (list___0->next) {
        if (quoted_dollar_at) {
          {
          tmp___4 = string_list_dollar_at(list___0, 1);
          temp___0 = tmp___4;
          }
        } else {
          {
          tmp___5 = quote_list(list___0);
          tmp___6 = string_list(tmp___5);
          temp___0 = tmp___6;
          }
        }
        {
        dispose_words(list___0);
        }
        goto add_string;
      } else {
        {
        tmp___7 = strlen((char const   *)(list___0->word)->word);
        tmp___8 = xmalloc(1UL + tmp___7);
        tmp___9 = strcpy((char * __restrict  )tmp___8, (char const   * __restrict  )(list___0->word)->word);
        temp___0 = tmp___9;
        dispose_words(list___0);
        }
        if ((int )*(temp___0 + 0) == 127) {
          if ((int )*(temp___0 + 1) == 0) {
            tmp___10 = 1;
          } else {
            tmp___10 = 0;
          }
        } else {
          tmp___10 = 0;
        }
        if (tmp___10 == 0) {
          {
          remove_quoted_nulls(temp___0);
          }
        }
      }
    } else {
      temp___0 = (char *)((void *)0);
    }
    if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
      if (quoted_state == 1) {
        goto __Cont;
      }
    }
    add_quoted_string: 
    if (temp___0) {
      {
      temp1 = temp___0;
      temp___0 = quote_string(temp___0);
      free((void *)temp1);
      }
      goto add_string;
    } else {
      c = '\177';
      sindex --;
      goto add_character;
    }
    case_39: /* CIL Label */ 
    if (quoted & 11) {
      goto add_character;
    }
    {
    sindex ++;
    t_index = sindex;
    temp___0 = string_extract_single_quoted(string, & sindex);
    }
    if (t_index == 1) {
      if ((int )*(string + sindex) == 0) {
        quoted_state = 2;
      } else {
        quoted_state = 1;
      }
    } else {
      quoted_state = 1;
    }
    if ((int )*temp___0 == 0) {
      {
      free((void *)temp___0);
      temp___0 = (char *)((void *)0);
      }
    } else {
      {
      remove_quoted_escapes(temp___0);
      }
    }
    if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
      if (quoted_state == 1) {
        goto __Cont;
      }
    }
    if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
      c = '\177';
      sindex --;
      goto add_character;
    } else {
      goto add_quoted_string;
    }
    switch_default: /* CIL Label */ 
    if (quoted & 3) {
      goto _L___1;
    } else { //Added block
    if (isexp == 0) {
      if (ifscmap[c]) {
        _L___1: 
        if (*(string + sindex)) {
          sindex ++;
        }
        if (c == 0) {
          c = '\177';
          goto add_character;
        } else {
          twochars[0] = (char )'\001';
          twochars[1] = (char )c;
          goto add_twochars;
        }
      }
    }
    }
    add_character: 
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (istring_index + 1 >= istring_size) {
        {
        while (1) {
          while_continue___6: /* CIL Label */ ;
          if (! (istring_index + 1 >= istring_size)) {
            goto while_break___6;
          }
          istring_size += 128;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
        istring = xrealloc((void *)istring, (size_t )istring_size);
        }
      }
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    tmp___11 = istring_index;
    istring_index ++;
    *(istring + tmp___11) = (char )c;
    *(istring + istring_index) = (char )'\000';
    sindex ++;
    switch_break: /* CIL Label */ ;
    }
    __Cont: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  finished_with_string: 
  if ((int )*istring == 0) {
    if (quoted_dollar_at == 0) {
      if (had_quoted_null) {
        goto _L___3;
      } else { //Added block
      if (quoted_state == 1) {
        _L___3: 
        {
        *(istring + 0) = (char )'\177';
        *(istring + 1) = (char )'\000';
        tword = make_bare_word(istring);
        list___0 = make_word_list(tword, (WORD_LIST *)((void *)0));
        }
        if (quoted & 3) {
          tword->flags |= 2;
        }
      } else {
        goto _L___2;
      }
      }
    } else { //Added block
    _L___2: 
    if (quoted_state == 0) {
      list___0 = (WORD_LIST *)((void *)0);
    } else { //Added block
    if (quoted_dollar_at) {
      list___0 = (WORD_LIST *)((void *)0);
    }
    }
    }
  } else { //Added block
  if (word->flags & 16) {
    {
    tword = make_bare_word(istring);
    list___0 = make_word_list(tword, (WORD_LIST *)((void *)0));
    }
    if (word->flags & 4) {
      tword->flags |= 4;
    }
    if (word->flags & 32) {
      tword->flags |= 32;
    }
    if (quoted & 3) {
      tword->flags |= 2;
    }
  } else {
    if (quoted_dollar_at) {
      {
      tmp___12 = getifs();
      ifs_chars = tmp___12;
      }
    } else { //Added block
    if (has_dollar_at) {
      {
      tmp___12 = getifs();
      ifs_chars = tmp___12;
      }
    } else {
      ifs_chars = (char *)((void *)0);
    }
    }
    if (has_dollar_at) {
      if (ifs_chars) {
        if (*ifs_chars) {
          tmp___13 = (char const   *)ifs_chars;
        } else {
          tmp___13 = " ";
        }
        {
        list___0 = list_string(istring, (char *)tmp___13, 1);
        }
      } else {
        goto _L___4;
      }
    } else {
      _L___4: 
      {
      tword = make_bare_word(istring);
      list___0 = make_word_list(tword, (WORD_LIST *)((void *)0));
      }
      if (quoted & 3) {
        tword->flags |= 2;
      } else { //Added block
      if (quoted_state == 2) {
        tword->flags |= 2;
      }
      }
      if (word->flags & 4) {
        tword->flags |= 4;
      }
      if (word->flags & 32) {
        tword->flags |= 32;
      }
    }
  }
  }
  {
  free((void *)istring);
  }
  return (list___0);
}
}
char *string_quote_removal(char *string , int quoted ) 
{ 
  char *r ;
  char *result_string ;
  char *temp___0 ;
  int sindex ;
  int tindex ;
  int c ;
  int dquote ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
  tmp = strlen((char const   *)string);
  result_string = xmalloc(tmp + 1UL);
  r = result_string;
  sindex = 0;
  dquote = sindex;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(string + sindex);
    if (! c) {
      goto while_break;
    }
    {
    if (c == 92) {
      goto case_92;
    }
    if (c == 39) {
      goto case_39;
    }
    if (c == 34) {
      goto case_34;
    }
    goto switch_default;
    case_92: /* CIL Label */ 
    sindex ++;
    c = (int )*(string + sindex);
    if (quoted & 3) {
      goto _L;
    } else { //Added block
    if (dquote) {
      _L: 
      if ((sh_syntaxtab[c] & 64) == 0) {
        tmp___0 = r;
        r ++;
        *tmp___0 = (char )'\\';
      }
    }
    }
    switch_default: /* CIL Label */ 
    tmp___1 = r;
    r ++;
    *tmp___1 = (char )c;
    sindex ++;
    goto switch_break;
    case_39: /* CIL Label */ 
    if (quoted & 3) {
      tmp___2 = r;
      r ++;
      *tmp___2 = (char )c;
      sindex ++;
      goto switch_break;
    } else { //Added block
    if (dquote) {
      tmp___2 = r;
      r ++;
      *tmp___2 = (char )c;
      sindex ++;
      goto switch_break;
    }
    }
    {
    tindex = sindex + 1;
    temp___0 = string_extract_single_quoted(string, & tindex);
    }
    if (temp___0) {
      {
      strcpy((char * __restrict  )r, (char const   * __restrict  )temp___0);
      tmp___3 = strlen((char const   *)r);
      r += tmp___3;
      free((void *)temp___0);
      }
    }
    sindex = tindex;
    goto switch_break;
    case_34: /* CIL Label */ 
    dquote = 1 - dquote;
    sindex ++;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  *r = (char )'\000';
  return (result_string);
}
}
static char *getifs(void) 
{ 
  SHELL_VAR *ifs ;
  char const   *tmp ;

  {
  {
  ifs = find_variable((char *)"IFS");
  }
  if (ifs) {
    tmp = (char const   *)ifs->value;
  } else {
    tmp = " \t\n";
  }
  return ((char *)tmp);
}
}
WORD_LIST *word_split(WORD_DESC *w ) 
{ 
  WORD_LIST *result ;
  SHELL_VAR *ifs ;
  char *ifs_chars ;

  {
  if (w) {
    {
    ifs = find_variable((char *)"IFS");
    }
    if (ifs) {
      ifs_chars = ifs->value;
    } else {
      ifs_chars = (char *)" \t\n";
    }
    if (w->flags & 2) {
      ifs_chars = (char *)"";
    } else { //Added block
    if (! ifs_chars) {
      ifs_chars = (char *)"";
    }
    }
    {
    result = list_string(w->word, ifs_chars, w->flags & 2);
    }
    if (ifs) {
      if (ifs->attributes & 512) {
        {
        dispose_variable(ifs);
        }
      }
    }
  } else {
    result = (WORD_LIST *)((void *)0);
  }
  return (result);
}
}
static WORD_LIST *word_list_split(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *result ;
  WORD_LIST *t ;
  WORD_LIST *tresult ;
  GENERIC_LIST *tmp ;

  {
  t = list___0;
  result = (WORD_LIST *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! t) {
      goto while_break;
    }
    {
    tresult = word_split(t->word);
    tmp = list_append((GENERIC_LIST *)result, (GENERIC_LIST *)tresult);
    result = (WORD_LIST *)tmp;
    t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (result);
}
}
static WORD_LIST *separate_out_assignments(WORD_LIST *tlist ) 
{ 
  register WORD_LIST *vp ;
  register WORD_LIST *lp ;
  WORD_LIST *tp___0 ;

  {
  if (! tlist) {
    return ((WORD_LIST *)((void *)0));
  }
  if (subst_assign_varlist) {
    {
    dispose_words(subst_assign_varlist);
    }
  }
  subst_assign_varlist = (WORD_LIST *)((void *)0);
  lp = tlist;
  vp = lp;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (lp) {
      if (! ((lp->word)->flags & 4)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    vp = lp;
    lp = lp->next;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )lp != (unsigned long )tlist) {
    subst_assign_varlist = tlist;
    vp->next = (WORD_LIST *)((void *)0);
    tlist = lp;
  }
  if (! tlist) {
    return ((WORD_LIST *)((void *)0));
  }
  if (place_keywords_in_env) {
    tp___0 = tlist;
    lp = tlist->next;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! lp) {
        goto while_break___0;
      }
      if ((lp->word)->flags & 4) {
        if (! subst_assign_varlist) {
          vp = lp;
          subst_assign_varlist = vp;
        } else {
          vp->next = lp;
          vp = lp;
        }
        tp___0->next = lp->next;
        lp->next = (WORD_LIST *)((void *)0);
        lp = tp___0->next;
      } else {
        tp___0 = lp;
        lp = lp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return (tlist);
}
}
WORD_LIST *expand_words(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *tmp ;

  {
  {
  tmp = expand_word_list_internal(list___0, 31);
  }
  return (tmp);
}
}
WORD_LIST *expand_words_no_vars(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *tmp ;

  {
  {
  tmp = expand_word_list_internal(list___0, 30);
  }
  return (tmp);
}
}
WORD_LIST *expand_words_shellexp(WORD_LIST *list___0 ) 
{ 
  WORD_LIST *tmp ;

  {
  {
  tmp = expand_word_list_internal(list___0, 14);
  }
  return (tmp);
}
}
static WORD_LIST *glob_expand_word_list(WORD_LIST *tlist , int eflags ) 
{ 
  char **glob_array ;
  char *temp_string ;
  register int glob_index ;
  WORD_LIST *glob_list ;
  WORD_LIST *output_list ;
  WORD_LIST *disposables ;
  WORD_LIST *next ;
  WORD_DESC *tword ;
  char *tmp ;
  GENERIC_LIST *tmp___0 ;
  int tmp___1 ;
  GENERIC_LIST *tmp___2 ;

  {
  disposables = (WORD_LIST *)((void *)0);
  output_list = disposables;
  glob_array = (char **)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! tlist) {
      goto while_break;
    }
    next = tlist->next;
    if (((tlist->word)->flags & 32) == 0) {
      {
      tmp___1 = unquoted_glob_pattern_p((tlist->word)->word);
      }
      if (tmp___1) {
        {
        glob_array = shell_glob_filename((char const   *)(tlist->word)->word);
        }
        if ((unsigned long )glob_array == (unsigned long )(& glob_error_return)) {
          {
          tmp = xmalloc(sizeof(char *));
          glob_array = (char **)tmp;
          *(glob_array + 0) = (char *)((void *)0);
          }
        }
        if ((unsigned long )*(glob_array + 0) == (unsigned long )((void *)0)) {
          {
          temp_string = dequote_string((tlist->word)->word);
          free((void *)(tlist->word)->word);
          (tlist->word)->word = temp_string;
          }
        }
        glob_list = (WORD_LIST *)((void *)0);
        glob_index = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! *(glob_array + glob_index)) {
            goto while_break___0;
          }
          {
          tword = make_bare_word(*(glob_array + glob_index));
          tword->flags |= 8;
          glob_list = make_word_list(tword, glob_list);
          glob_index ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        if (glob_list) {
          {
          tmp___0 = list_append((GENERIC_LIST *)glob_list, (GENERIC_LIST *)output_list);
          output_list = (WORD_LIST *)tmp___0;
          }
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            tlist->next = disposables;
            disposables = tlist;
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else { //Added block
        if (allow_null_glob_expansion == 0) {
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            tlist->next = output_list;
            output_list = tlist;
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            tlist->next = disposables;
            disposables = tlist;
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
      temp_string = dequote_string((tlist->word)->word);
      free((void *)(tlist->word)->word);
      (tlist->word)->word = temp_string;
      }
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        tlist->next = output_list;
        output_list = tlist;
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
    free_array(glob_array);
    glob_array = (char **)((void *)0);
    tlist = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (disposables) {
    {
    dispose_words(disposables);
    }
  }
  if (output_list) {
    if (output_list) {
      if (output_list->next) {
        {
        tmp___2 = reverse_list((GENERIC_LIST *)output_list);
        output_list = (WORD_LIST *)tmp___2;
        }
      } else {
        output_list = output_list;
      }
    } else {
      output_list = output_list;
    }
  }
  return (output_list);
}
}
static WORD_LIST *brace_expand_word_list(WORD_LIST *tlist , int eflags ) 
{ 
  register char **expansions ;
  char *temp_string ;
  WORD_LIST *disposables ;
  WORD_LIST *output_list ;
  WORD_LIST *next ;
  WORD_DESC *w ;
  int eindex ;
  int tmp ;
  char *tmp___0 ;
  GENERIC_LIST *tmp___1 ;

  {
  output_list = (WORD_LIST *)((void *)0);
  disposables = output_list;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! tlist) {
      goto while_break;
    }
    {
    next = tlist->next;
    tmp___0 = strchr((char const   *)(tlist->word)->word, '{');
    }
    if (tmp___0) {
      {
      expansions = brace_expand((tlist->word)->word);
      eindex = 0;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        temp_string = *(expansions + eindex);
        if (! temp_string) {
          goto while_break___0;
        }
        {
        w = make_word(temp_string);
        }
        if ((int )*(temp_string + 0) == (int )*((tlist->word)->word + 0)) {
          {
          tmp = strcmp((char const   *)temp_string, (char const   *)(tlist->word)->word);
          }
          if (tmp == 0) {
            w->flags = (tlist->word)->flags;
          }
        }
        {
        output_list = make_word_list(w, output_list);
        free((void *)*(expansions + eindex));
        eindex ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      free((void *)expansions);
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        tlist->next = disposables;
        disposables = tlist;
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        tlist->next = output_list;
        output_list = tlist;
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    tlist = next;
  }
  while_break: /* CIL Label */ ;
  }
  if (disposables) {
    {
    dispose_words(disposables);
    }
  }
  if (output_list) {
    if (output_list) {
      if (output_list->next) {
        {
        tmp___1 = reverse_list((GENERIC_LIST *)output_list);
        output_list = (WORD_LIST *)tmp___1;
        }
      } else {
        output_list = output_list;
      }
    } else {
      output_list = output_list;
    }
  }
  return (output_list);
}
}
static WORD_LIST *shell_expand_word_list(WORD_LIST *tlist , int eflags ) 
{ 
  WORD_LIST *expanded ;
  WORD_LIST *orig_list ;
  WORD_LIST *new_list ;
  WORD_LIST *next ;
  WORD_LIST *temp_list ;
  int expanded_something ;
  int has_dollar_at ;
  char *temp_string ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  GENERIC_LIST *tmp___2 ;
  GENERIC_LIST *tmp___3 ;
  GENERIC_LIST *tmp___4 ;

  {
  new_list = (WORD_LIST *)((void *)0);
  orig_list = tlist;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! tlist) {
      goto while_break;
    }
    temp_string = (tlist->word)->word;
    next = tlist->next;
    if ((int )*(temp_string + 0) == 126) {
      {
      (tlist->word)->word = bash_tilde_expand(temp_string);
      free((void *)temp_string);
      }
    } else { //Added block
    if (((tlist->word)->flags & 6) == 4) {
      if (posixly_correct == 0) {
        {
        tmp = strchr((char const   *)temp_string, '~');
        }
        if (tmp) {
          {
          tmp___0 = unquoted_substring((char *)"=~", temp_string);
          }
          if (tmp___0) {
            {
            (tlist->word)->word = bash_tilde_expand(temp_string);
            free((void *)temp_string);
            }
          } else {
            {
            tmp___1 = unquoted_substring((char *)":~", temp_string);
            }
            if (tmp___1) {
              {
              (tlist->word)->word = bash_tilde_expand(temp_string);
              free((void *)temp_string);
              }
            }
          }
        }
      }
    }
    }
    {
    expanded_something = 0;
    expanded = expand_word_internal(tlist->word, 0, 0, & has_dollar_at, & expanded_something);
    }
    if ((unsigned long )expanded == (unsigned long )(& expand_word_error)) {
      goto _L;
    } else { //Added block
    if ((unsigned long )expanded == (unsigned long )(& expand_word_fatal)) {
      _L: 
      {
      (tlist->word)->word = (char *)((void *)0);
      dispose_words(orig_list);
      dispose_words(new_list);
      last_command_exit_value = 1;
      }
      if ((unsigned long )expanded == (unsigned long )(& expand_word_error)) {
        {
        jump_to_top_level(2);
        }
      } else {
        {
        jump_to_top_level(1);
        }
      }
    }
    }
    if (expanded_something) {
      if (((tlist->word)->flags & 16) == 0) {
        {
        temp_list = word_list_split(expanded);
        dispose_words(expanded);
        }
      } else {
        {
        word_list_remove_quoted_nulls(expanded);
        temp_list = expanded;
        }
      }
    } else {
      {
      word_list_remove_quoted_nulls(expanded);
      temp_list = expanded;
      }
    }
    if (temp_list) {
      if (temp_list->next) {
        {
        tmp___2 = reverse_list((GENERIC_LIST *)temp_list);
        expanded = (WORD_LIST *)tmp___2;
        }
      } else {
        expanded = temp_list;
      }
    } else {
      expanded = temp_list;
    }
    {
    tmp___3 = list_append((GENERIC_LIST *)expanded, (GENERIC_LIST *)new_list);
    new_list = (WORD_LIST *)tmp___3;
    tlist = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (orig_list) {
    {
    dispose_words(orig_list);
    }
  }
  if (new_list) {
    if (new_list) {
      if (new_list->next) {
        {
        tmp___4 = reverse_list((GENERIC_LIST *)new_list);
        new_list = (WORD_LIST *)tmp___4;
        }
      } else {
        new_list = new_list;
      }
    } else {
      new_list = new_list;
    }
  }
  return (new_list);
}
}
static WORD_LIST *expand_word_list_internal(WORD_LIST *list___0 , int eflags ) 
{ 
  WORD_LIST *new_list ;
  WORD_LIST *temp_list ;
  int tint ;
  Function *assign_func ;

  {
  if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
    return ((WORD_LIST *)((void *)0));
  }
  {
  new_list = copy_word_list(list___0);
  garglist = new_list;
  }
  if (eflags & 1) {
    {
    new_list = separate_out_assignments(new_list);
    garglist = new_list;
    }
    if ((unsigned long )new_list == (unsigned long )((WORD_LIST *)0)) {
      if (subst_assign_varlist) {
        temp_list = subst_assign_varlist;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! temp_list) {
            goto while_break;
          }
          {
          this_command_name = (char *)((void *)0);
          tint = do_assignment((temp_list->word)->word);
          }
          if (tint == 0) {
            last_command_exit_value = 1;
            if (interactive_shell == 0) {
              if (posixly_correct) {
                {
                jump_to_top_level(1);
                }
              } else {
                {
                jump_to_top_level(2);
                }
              }
            } else {
              {
              jump_to_top_level(2);
              }
            }
          }
          temp_list = temp_list->next;
        }
        while_break: /* CIL Label */ ;
        }
        {
        dispose_words(subst_assign_varlist);
        subst_assign_varlist = (WORD_LIST *)((void *)0);
        }
      }
      return ((WORD_LIST *)((void *)0));
    }
  }
  if (eflags & 2) {
    if (brace_expansion) {
      if (new_list) {
        {
        new_list = brace_expand_word_list(new_list, eflags);
        }
      }
    }
  }
  {
  new_list = shell_expand_word_list(new_list, eflags);
  }
  if (new_list) {
    if (eflags & 16) {
      if (disallow_filename_globbing == 0) {
        {
        new_list = glob_expand_word_list(new_list, eflags);
        }
      } else {
        {
        new_list = dequote_list(new_list);
        }
      }
    } else {
      {
      new_list = dequote_list(new_list);
      }
    }
  }
  if (eflags & 1) {
    if (subst_assign_varlist) {
      if (new_list) {
        assign_func = (Function *)(& assign_in_env);
      } else {
        assign_func = (Function *)(& do_assignment);
      }
      temp_list = subst_assign_varlist;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! temp_list) {
          goto while_break___0;
        }
        {
        this_command_name = (char *)((void *)0);
        tint = (*assign_func)((temp_list->word)->word);
        }
        if (tint == 0) {
          if ((unsigned long )assign_func == (unsigned long )(& do_assignment)) {
            last_command_exit_value = 1;
            if (interactive_shell == 0) {
              if (posixly_correct) {
                {
                jump_to_top_level(1);
                }
              } else {
                {
                jump_to_top_level(2);
                }
              }
            } else {
              {
              jump_to_top_level(2);
              }
            }
          }
        }
        temp_list = temp_list->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      dispose_words(subst_assign_varlist);
      subst_assign_varlist = (WORD_LIST *)((void *)0);
      }
    }
  }
  return (new_list);
}
}
#pragma merger("0","/tmp/cil-glN52wYl.i","-g")
int executable_file(char *file ) ;
HASH_TABLE *hashed_filenames  ;
void initialize_filename_hashing(void) ;
void remove_hashed_filename(char *filename ) ;
void remember_filename(char *filename , char *full_pathname___0 , int check_dot ,
                       int found ) ;
char *find_hashed_filename(char *filename ) ;
static int hashing_initialized  =    0;
void initialize_filename_hashing(void) 
{ 


  {
  if (hashing_initialized == 0) {
    {
    hashed_filenames = make_hash_table(107);
    hashing_initialized = 1;
    }
  }
  return;
}
}
static void free_filename_data(char *data ) 
{ 


  {
  {
  free((void *)((PATH_DATA *)data)->path);
  free((void *)data);
  }
  return;
}
}
void flush_hashed_filenames(void) 
{ 


  {
  if (hashed_filenames) {
    {
    flush_hash_table(hashed_filenames, (VFunction *)(& free_filename_data));
    }
  }
  return;
}
}
void remove_hashed_filename(char *filename ) 
{ 
  register BUCKET_CONTENTS *item ;

  {
  if (hashing_enabled == 0) {
    return;
  } else { //Added block
  if ((unsigned long )hashed_filenames == (unsigned long )((HASH_TABLE *)0)) {
    return;
  }
  }
  {
  item = remove_hash_item(filename, hashed_filenames);
  }
  if (item) {
    if (item->data) {
      {
      free_filename_data(item->data);
      }
    }
    {
    free((void *)item->key);
    free((void *)item);
    }
  }
  return;
}
}
void remember_filename(char *filename , char *full_pathname___0 , int check_dot ,
                       int found ) 
{ 
  register BUCKET_CONTENTS *item ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  if (hashing_enabled == 0) {
    return;
  }
  if ((unsigned long )hashed_filenames == (unsigned long )((HASH_TABLE *)0)) {
    {
    initialize_filename_hashing();
    }
  } else { //Added block
  if (hashing_initialized == 0) {
    {
    initialize_filename_hashing();
    }
  }
  }
  {
  item = add_hash_item(filename, hashed_filenames);
  }
  if (item->data) {
    {
    free((void *)((PATH_DATA *)item->data)->path);
    }
  } else {
    {
    tmp = strlen((char const   *)filename);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )filename);
    item->key = tmp___1;
    item->data = xmalloc(sizeof(PATH_DATA ));
    }
  }
  {
  tmp___2 = strlen((char const   *)full_pathname___0);
  tmp___3 = xmalloc(1UL + tmp___2);
  tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )full_pathname___0);
  ((PATH_DATA *)item->data)->path = tmp___4;
  ((PATH_DATA *)item->data)->flags = 0;
  }
  if (check_dot) {
    ((PATH_DATA *)item->data)->flags |= 2;
  }
  if ((int )*full_pathname___0 != 47) {
    ((PATH_DATA *)item->data)->flags |= 1;
  }
  item->times_found = found;
  return;
}
}
char *find_hashed_filename(char *filename ) 
{ 
  register BUCKET_CONTENTS *item ;
  char *path___0 ;
  char *dotted_filename ;
  char *tail ;
  int same ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  if (hashing_enabled == 0) {
    return ((char *)((void *)0));
  } else { //Added block
  if ((unsigned long )hashed_filenames == (unsigned long )((HASH_TABLE *)0)) {
    return ((char *)((void *)0));
  }
  }
  {
  item = find_hash_item(filename, hashed_filenames);
  }
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  path___0 = ((PATH_DATA *)item->data)->path;
  if (((PATH_DATA *)item->data)->flags & 3) {
    if (((PATH_DATA *)item->data)->flags & 1) {
      tail = path___0;
    } else {
      tail = filename;
    }
    if ((int )*(tail + 0) != 46) {
      {
      tmp = strlen((char const   *)tail);
      dotted_filename = xmalloc(3UL + tmp);
      *(dotted_filename + 0) = (char )'.';
      *(dotted_filename + 1) = (char )'/';
      strcpy((char * __restrict  )(dotted_filename + 2), (char const   * __restrict  )tail);
      }
    } else { //Added block
    if ((int )*(tail + 1) != 47) {
      {
      tmp = strlen((char const   *)tail);
      dotted_filename = xmalloc(3UL + tmp);
      *(dotted_filename + 0) = (char )'.';
      *(dotted_filename + 1) = (char )'/';
      strcpy((char * __restrict  )(dotted_filename + 2), (char const   * __restrict  )tail);
      }
    } else {
      {
      tmp___0 = strlen((char const   *)tail);
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )tail);
      dotted_filename = tmp___2;
      }
    }
    }
    {
    tmp___3 = executable_file(dotted_filename);
    }
    if (tmp___3) {
      return (dotted_filename);
    }
    {
    free((void *)dotted_filename);
    }
    if ((int )*path___0 == 46) {
      {
      same = 0;
      tmp___4 = strrchr((char const   *)path___0, '/');
      tail = tmp___4;
      }
      if (tail) {
        {
        *tail = (char )'\000';
        same = same_file((char *)".", path___0, (struct stat *)((void *)0), (struct stat *)((void *)0));
        *tail = (char )'/';
        }
      }
      if (same) {
        tmp___8 = (char *)((void *)0);
      } else {
        {
        tmp___5 = strlen((char const   *)path___0);
        tmp___6 = xmalloc(1UL + tmp___5);
        tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )path___0);
        tmp___8 = tmp___7;
        }
      }
      return (tmp___8);
    }
  }
  {
  tmp___9 = strlen((char const   *)path___0);
  tmp___10 = xmalloc(1UL + tmp___9);
  tmp___11 = strcpy((char * __restrict  )tmp___10, (char const   * __restrict  )path___0);
  }
  return (tmp___11);
}
}
#pragma merger("0","/tmp/cil-qHWAIyEN.i","-g")
int hash_string(char *string , HASH_TABLE *table ) ;
void dispose_hash_table(HASH_TABLE *table ) ;
static void initialize_hash_table(HASH_TABLE *table ) 
{ 
  register int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < table->nbuckets)) {
      goto while_break;
    }
    *(table->bucket_array + i) = (BUCKET_CONTENTS *)((void *)0);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
HASH_TABLE *make_hash_table(int buckets ) 
{ 
  HASH_TABLE *new_table ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(HASH_TABLE ));
  new_table = (HASH_TABLE *)tmp;
  }
  if (buckets == 0) {
    buckets = 53;
  }
  {
  tmp___0 = xmalloc((unsigned long )buckets * sizeof(BUCKET_CONTENTS *));
  new_table->bucket_array = (BUCKET_CONTENTS **)tmp___0;
  new_table->nbuckets = buckets;
  new_table->nentries = 0;
  initialize_hash_table(new_table);
  }
  return (new_table);
}
}
int hash_string(char *string , HASH_TABLE *table ) 
{ 
  register unsigned int i ;
  char *tmp ;

  {
  i = 0U;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *string) {
      goto while_break;
    }
    tmp = string;
    string ++;
    i = (i << 2) + (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
  return ((int )(((unsigned long )i & ~ (0xffffffffffffffffUL << 31)) % (unsigned long )table->nbuckets));
}
}
BUCKET_CONTENTS *find_hash_item(char *string , HASH_TABLE *table ) 
{ 
  BUCKET_CONTENTS *list___0 ;
  int which_bucket ;
  int tmp ;

  {
  if ((unsigned long )table == (unsigned long )((HASH_TABLE *)0)) {
    return ((BUCKET_CONTENTS *)((void *)0));
  }
  {
  which_bucket = hash_string(string, table);
  list___0 = *(table->bucket_array + which_bucket);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    if ((int )*(list___0->key + 0) == (int )*(string + 0)) {
      {
      tmp = strcmp((char const   *)list___0->key, (char const   *)string);
      }
      if (tmp == 0) {
        (list___0->times_found) ++;
        return (list___0);
      }
    }
    list___0 = list___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  return ((BUCKET_CONTENTS *)((void *)0));
}
}
BUCKET_CONTENTS *remove_hash_item(char *string , HASH_TABLE *table ) 
{ 
  int the_bucket ;
  BUCKET_CONTENTS *prev ;
  BUCKET_CONTENTS *temp___0 ;
  int tmp ;

  {
  if ((unsigned long )table == (unsigned long )((HASH_TABLE *)0)) {
    return ((BUCKET_CONTENTS *)((void *)0));
  }
  {
  the_bucket = hash_string(string, table);
  prev = (BUCKET_CONTENTS *)((void *)0);
  temp___0 = *(table->bucket_array + the_bucket);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! temp___0) {
      goto while_break;
    }
    if ((int )*(temp___0->key + 0) == (int )*(string + 0)) {
      {
      tmp = strcmp((char const   *)temp___0->key, (char const   *)string);
      }
      if (tmp == 0) {
        if (prev) {
          prev->next = temp___0->next;
        } else {
          *(table->bucket_array + the_bucket) = temp___0->next;
        }
        (table->nentries) --;
        return (temp___0);
      }
    }
    prev = temp___0;
    temp___0 = temp___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  return ((BUCKET_CONTENTS *)((void *)0));
}
}
BUCKET_CONTENTS *add_hash_item(char *string , HASH_TABLE *table ) 
{ 
  BUCKET_CONTENTS *item ;
  int bucket ;
  char *tmp ;
  char *tmp___0 ;

  {
  if ((unsigned long )table == (unsigned long )((HASH_TABLE *)0)) {
    {
    table = make_hash_table(0);
    }
  }
  {
  item = find_hash_item(string, table);
  }
  if ((unsigned long )item == (unsigned long )((BUCKET_CONTENTS *)0)) {
    {
    bucket = hash_string(string, table);
    item = *(table->bucket_array + bucket);
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (item) {
        if (! item->next) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      item = item->next;
    }
    while_break: /* CIL Label */ ;
    }
    if (item) {
      {
      tmp = xmalloc(sizeof(BUCKET_CONTENTS ));
      item->next = (BUCKET_CONTENTS *)tmp;
      item = item->next;
      }
    } else {
      {
      tmp___0 = xmalloc(sizeof(BUCKET_CONTENTS ));
      *(table->bucket_array + bucket) = (BUCKET_CONTENTS *)tmp___0;
      item = *(table->bucket_array + bucket);
      }
    }
    item->data = (char *)((void *)0);
    item->next = (BUCKET_CONTENTS *)((void *)0);
    item->key = string;
    (table->nentries) ++;
    item->times_found = 0;
  }
  return (item);
}
}
void flush_hash_table(HASH_TABLE *table , VFunction *free_data ) 
{ 
  int i ;
  register BUCKET_CONTENTS *bucket ;
  register BUCKET_CONTENTS *item ;

  {
  if ((unsigned long )table == (unsigned long )((HASH_TABLE *)0)) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < table->nbuckets)) {
      goto while_break;
    }
    bucket = *(table->bucket_array + i);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! bucket) {
        goto while_break___0;
      }
      item = bucket;
      bucket = bucket->next;
      if (free_data) {
        {
        (*free_data)(item->data);
        }
      } else {
        {
        free((void *)item->data);
        }
      }
      {
      free((void *)item->key);
      free((void *)item);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    *(table->bucket_array + i) = (BUCKET_CONTENTS *)((void *)0);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void dispose_hash_table(HASH_TABLE *table ) 
{ 


  {
  {
  free((void *)table->bucket_array);
  free((void *)table);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-NIdHC_nT.i","-g")
extern int puts(char const   *__s ) ;
void reset_mail_files(void) ;
char *make_default_mailpath(void) ;
static FILEINFO **mailfiles  =    (FILEINFO **)((void *)0);
static int mailfiles_count  ;
static int last_time_mail_checked  ;
int mail_warning  ;
int time_to_check_mail(void) 
{ 
  char *temp___0 ;
  time_t now ;
  long seconds ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;

  {
  {
  temp___0 = get_string_value("MAILCHECK");
  seconds = -1L;
  }
  if (temp___0) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((int )*temp___0 == 32)) {
        if (! ((int )*temp___0 == 9)) {
          goto while_break;
        }
      }
      temp___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    tmp = atoi((char const   *)temp___0);
    seconds = (long )tmp;
    }
  }
  if (seconds < 0L) {
    return (0);
  }
  {
  tmp___2 = time((time_t *)0);
  tmp___0 = (int )tmp___2;
  now = (time_t )tmp___0;
  }
  if (seconds == 0L) {
    tmp___1 = 1;
  } else { //Added block
  if (now - (time_t )last_time_mail_checked >= seconds) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  }
  return (tmp___1);
}
}
void reset_mail_timer(void) 
{ 
  int tmp ;
  time_t tmp___0 ;

  {
  {
  tmp___0 = time((time_t *)0);
  tmp = (int )tmp___0;
  last_time_mail_checked = (int )((time_t )tmp);
  }
  return;
}
}
static int find_mail_file(char *file ) 
{ 
  register int i ;
  int tmp ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < mailfiles_count)) {
      goto while_break;
    }
    if ((int )*((*(mailfiles + i))->name + 0) == (int )*(file + 0)) {
      {
      tmp = strcmp((char const   *)(*(mailfiles + i))->name, (char const   *)file);
      }
      if (tmp == 0) {
        return (i);
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static void update_mail_file(int i ) 
{ 
  char *file ;
  struct stat finfo ;
  time_t tmp ;
  int tmp___0 ;

  {
  {
  file = (*(mailfiles + i))->name;
  tmp___0 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& finfo));
  }
  if (tmp___0 == 0) {
    (*(mailfiles + i))->access_time = finfo.st_atim.tv_sec;
    (*(mailfiles + i))->mod_time = finfo.st_mtim.tv_sec;
    (*(mailfiles + i))->file_size = finfo.st_size;
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp = (time_t )0;
      (*(mailfiles + i))->mod_time = tmp;
      (*(mailfiles + i))->access_time = tmp;
      (*(mailfiles + i))->file_size = (off_t )0;
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
static int add_mail_file(char *file , char *msg ) 
{ 
  struct stat finfo ;
  char *filename ;
  int i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
  filename = full_pathname(file);
  i = find_mail_file(filename);
  }
  if (i >= 0) {
    {
    tmp = stat((char const   * __restrict  )filename, (struct stat * __restrict  )(& finfo));
    }
    if (tmp == 0) {
      (*(mailfiles + i))->mod_time = finfo.st_mtim.tv_sec;
      (*(mailfiles + i))->access_time = finfo.st_atim.tv_sec;
      (*(mailfiles + i))->file_size = finfo.st_size;
    }
    {
    free((void *)filename);
    }
    return (i);
  }
  {
  tmp___0 = mailfiles_count;
  mailfiles_count ++;
  i = tmp___0;
  tmp___1 = xrealloc((void *)mailfiles, (unsigned long )mailfiles_count * sizeof(FILEINFO *));
  mailfiles = (FILEINFO **)tmp___1;
  tmp___2 = xmalloc(sizeof(FILEINFO ));
  *(mailfiles + i) = (FILEINFO *)tmp___2;
  (*(mailfiles + i))->name = filename;
  }
  if (msg) {
    {
    tmp___3 = strlen((char const   *)msg);
    tmp___4 = xmalloc(1UL + tmp___3);
    tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )msg);
    (*(mailfiles + i))->msg = tmp___5;
    }
  } else {
    (*(mailfiles + i))->msg = (char *)((void *)0);
  }
  {
  update_mail_file(i);
  }
  return (i);
}
}
void reset_mail_files(void) 
{ 
  register int i ;
  time_t tmp ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < mailfiles_count)) {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      tmp = (time_t )0;
      (*(mailfiles + i))->mod_time = tmp;
      (*(mailfiles + i))->access_time = tmp;
      (*(mailfiles + i))->file_size = (off_t )0;
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void free_mail_files(void) 
{ 
  register int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < mailfiles_count)) {
      goto while_break;
    }
    {
    free((void *)(*(mailfiles + i))->name);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((*(mailfiles + i))->msg) {
        {
        free((void *)(*(mailfiles + i))->msg);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    free((void *)*(mailfiles + i));
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (mailfiles) {
    {
    free((void *)mailfiles);
    }
  }
  mailfiles_count = 0;
  mailfiles = (FILEINFO **)((void *)0);
  return;
}
}
static int file_mod_date_changed(int i ) 
{ 
  time_t mtime ;
  struct stat finfo ;
  char *file ;
  int tmp ;

  {
  {
  file = (*(mailfiles + i))->name;
  mtime = (*(mailfiles + i))->mod_time;
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& finfo));
  }
  if (tmp == 0) {
    if (finfo.st_size > 0L) {
      return (mtime != finfo.st_mtim.tv_sec);
    }
  }
  return (0);
}
}
static int file_access_date_changed(int i ) 
{ 
  time_t atime ;
  struct stat finfo ;
  char *file ;
  int tmp ;

  {
  {
  file = (*(mailfiles + i))->name;
  atime = (*(mailfiles + i))->access_time;
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& finfo));
  }
  if (tmp == 0) {
    if (finfo.st_size > 0L) {
      return (atime != finfo.st_atim.tv_sec);
    }
  }
  return (0);
}
}
static int file_has_grown(int i ) 
{ 
  off_t size ;
  struct stat finfo ;
  char *file ;
  int tmp ;
  int tmp___0 ;

  {
  {
  file = (*(mailfiles + i))->name;
  size = (*(mailfiles + i))->file_size;
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& finfo));
  }
  if (tmp == 0) {
    if (finfo.st_size > size) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static char *parse_mailpath_spec(char *str ) 
{ 
  char *s ;
  int pass_next ;

  {
  s = str;
  pass_next = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (s) {
      if (! *s) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (pass_next) {
      pass_next = 0;
      goto __Cont;
    }
    if ((int )*s == 92) {
      pass_next ++;
      goto __Cont;
    }
    if ((int )*s == 63) {
      return (s);
    } else { //Added block
    if ((int )*s == 37) {
      return (s);
    }
    }
    __Cont: 
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char *)((void *)0));
}
}
char *make_default_mailpath(void) 
{ 
  char *mp ;
  size_t tmp ;

  {
  {
  get_current_user_info();
  tmp = strlen((char const   *)current_user.user_name);
  mp = xmalloc((2UL + sizeof("/var/mail")) + tmp);
  strcpy((char * __restrict  )mp, (char const   * __restrict  )"/var/mail");
  *(mp + (sizeof("/var/mail") - 1UL)) = (char )'/';
  strcpy((char * __restrict  )(mp + sizeof("/var/mail")), (char const   * __restrict  )current_user.user_name);
  }
  return (mp);
}
}
void remember_mail_dates(void) 
{ 
  char *mailpaths ;
  char *mailfile ;
  char *mp ;
  int i ;
  char *tmp ;

  {
  {
  i = 0;
  mailpaths = get_string_value("MAILPATH");
  }
  if ((unsigned long )mailpaths == (unsigned long )((char *)0)) {
    {
    mailpaths = get_string_value("MAIL");
    }
    if (mailpaths) {
      {
      add_mail_file(mailpaths, (char *)((void *)0));
      }
      return;
    }
  }
  if ((unsigned long )mailpaths == (unsigned long )((char *)0)) {
    {
    mailpaths = make_default_mailpath();
    add_mail_file(mailpaths, (char *)((void *)0));
    free((void *)mailpaths);
    }
    return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    mailfile = extract_colon_unit(mailpaths, & i);
    }
    if (! mailfile) {
      goto while_break;
    }
    {
    mp = parse_mailpath_spec(mailfile);
    }
    if (mp) {
      if (*mp) {
        tmp = mp;
        mp ++;
        *tmp = (char )'\000';
      }
    }
    {
    add_mail_file(mailfile, mp);
    free((void *)mailfile);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void check_mail(void) 
{ 
  char *current_mail_file ;
  char *message ;
  int i ;
  int use_user_notification ;
  char *dollar_underscore ;
  char *temp___0 ;
  WORD_LIST *tlist ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int file_is_bigger ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  dollar_underscore = get_string_value("_");
  }
  if (dollar_underscore) {
    {
    tmp = strlen((char const   *)dollar_underscore);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )dollar_underscore);
    dollar_underscore = tmp___1;
    }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < mailfiles_count)) {
      goto while_break;
    }
    current_mail_file = (*(mailfiles + i))->name;
    if ((int )*current_mail_file == 0) {
      goto __Cont;
    }
    {
    tmp___2 = file_mod_date_changed(i);
    }
    if (tmp___2) {
      use_user_notification = (unsigned long )(*(mailfiles + i))->msg != (unsigned long )((char *)((void *)0));
      if ((*(mailfiles + i))->msg) {
        message = (*(mailfiles + i))->msg;
      } else {
        message = (char *)"You have mail in $_";
      }
      {
      bind_variable((char *)"_", current_mail_file);
      file_is_bigger = file_has_grown(i);
      update_mail_file(i);
      }
      if ((*(mailfiles + i))->access_time >= (*(mailfiles + i))->mod_time) {
        if (! file_is_bigger) {
          goto __Cont;
        }
      }
      if (use_user_notification == 0) {
        if ((*(mailfiles + i))->access_time < (*(mailfiles + i))->mod_time) {
          if (file_is_bigger) {
            message = (char *)"You have new mail in $_";
          }
        }
      }
      {
      tlist = expand_string(message, 1);
      }
      if (tlist) {
        {
        temp___0 = string_list(tlist);
        puts((char const   *)temp___0);
        free((void *)temp___0);
        dispose_words(tlist);
        }
      } else {
        {
        putchar('\n');
        }
      }
    }
    if (mail_warning) {
      {
      tmp___3 = file_access_date_changed(i);
      }
      if (tmp___3) {
        {
        update_mail_file(i);
        printf((char const   * __restrict  )"The mail in %s has been read\n", current_mail_file);
        }
      }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (dollar_underscore) {
    {
    bind_variable((char *)"_", dollar_underscore);
    free((void *)dollar_underscore);
    }
  } else {
    {
    unbind_variable((char *)"_");
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-SSqdxvx6.i","-g")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
void set_signal(int sig , char *string ) ;
void ignore_signal(int sig ) ;
void run_trap_cleanup(int sig ) ;
int decode_signal(char *string ) ;
void run_interrupt_trap(void) ;
int signal_is_special(int sig ) ;
void initialize_terminating_signals(void) ;
char *signal_names[67]  = 
  {      (char *)"EXIT",      (char *)"SIGHUP",      (char *)"SIGINT",      (char *)"SIGQUIT", 
        (char *)"SIGILL",      (char *)"SIGTRAP",      (char *)"SIGABRT",      (char *)"SIGBUS", 
        (char *)"SIGFPE",      (char *)"SIGKILL",      (char *)"SIGUSR1",      (char *)"SIGSEGV", 
        (char *)"SIGUSR2",      (char *)"SIGPIPE",      (char *)"SIGALRM",      (char *)"SIGTERM", 
        (char *)"SIGJUNK(16)",      (char *)"SIGCHLD",      (char *)"SIGCONT",      (char *)"SIGSTOP", 
        (char *)"SIGTSTP",      (char *)"SIGTTIN",      (char *)"SIGTTOU",      (char *)"SIGURG", 
        (char *)"SIGXCPU",      (char *)"SIGXFSZ",      (char *)"SIGVTALRM",      (char *)"SIGPROF", 
        (char *)"SIGWINCH",      (char *)"SIGIO",      (char *)"SIGPWR",      (char *)"SIGSYS", 
        (char *)"SIGJUNK(32)",      (char *)"SIGJUNK(33)",      (char *)"SIGRTMIN",      (char *)"SIGRTMIN+1", 
        (char *)"SIGRTMIN+2",      (char *)"SIGRTMIN+3",      (char *)"SIGRTMIN+4",      (char *)"SIGRTMIN+5", 
        (char *)"SIGRTMIN+6",      (char *)"SIGRTMIN+7",      (char *)"SIGRTMIN+8",      (char *)"SIGRTMIN+9", 
        (char *)"SIGRTMIN+10",      (char *)"SIGRTMIN+11",      (char *)"SIGRTMIN+12",      (char *)"SIGRTMIN+13", 
        (char *)"SIGRTMIN+14",      (char *)"SIGRTMIN+15",      (char *)"SIGRTMAX-14",      (char *)"SIGRTMAX-13", 
        (char *)"SIGRTMAX-12",      (char *)"SIGRTMAX-11",      (char *)"SIGRTMAX-10",      (char *)"SIGRTMAX-9", 
        (char *)"SIGRTMAX-8",      (char *)"SIGRTMAX-7",      (char *)"SIGRTMAX-6",      (char *)"SIGRTMAX-5", 
        (char *)"SIGRTMAX-4",      (char *)"SIGRTMAX-3",      (char *)"SIGRTMAX-2",      (char *)"SIGRTMAX-1", 
        (char *)"SIGRTMAX",      (char *)"DEBUG",      (char *)0};
static int sigmodes[66]  ;
static void change_signal(int sig , char *value ) ;
static void restore_signal(int sig ) ;
SigHandler *original_signals[65]  ;
int pending_traps[65]  ;
void initialize_traps(void) 
{ 
  register int i ;
  SigHandler *tmp ;
  SigHandler *tmp___0 ;
  SigHandler *tmp___1 ;
  SigHandler *tmp___2 ;

  {
  trap_list[65] = (char *)((void *)0);
  trap_list[0] = trap_list[65];
  sigmodes[65] = 0;
  sigmodes[0] = sigmodes[65];
  original_signals[0] = & initialize_traps;
  i = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < 65)) {
      goto while_break;
    }
    pending_traps[i] = 0;
    trap_list[i] = (char *)((void (*)(int  ))0);
    sigmodes[i] = 0;
    original_signals[i] = & initialize_traps;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp = set_signal_handler(17, (SigHandler *)((void (*)(int  ))0));
  original_signals[17] = tmp;
  set_signal_handler(17, original_signals[17]);
  sigmodes[17] |= 12;
  tmp___0 = set_signal_handler(2, (SigHandler *)((void (*)(int  ))0));
  original_signals[2] = tmp___0;
  set_signal_handler(2, original_signals[2]);
  sigmodes[2] |= 4;
  tmp___1 = set_signal_handler(3, (SigHandler *)((void (*)(int  ))0));
  original_signals[3] = tmp___1;
  set_signal_handler(3, original_signals[3]);
  sigmodes[3] |= 4;
  }
  if (interactive) {
    {
    tmp___2 = set_signal_handler(15, (SigHandler *)((void (*)(int  ))0));
    original_signals[15] = tmp___2;
    set_signal_handler(15, original_signals[15]);
    sigmodes[15] |= 4;
    }
  }
  return;
}
}
char *signal_name(int sig ) 
{ 
  char *ret ;

  {
  if (sig > 65) {
    ret = (char *)"bad signal number";
  } else { //Added block
  if (sig < 0) {
    ret = (char *)"bad signal number";
  } else {
    ret = signal_names[sig];
  }
  }
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    ret = (char *)"unrecognized signal number";
  }
  return (ret);
}
}
int decode_signal(char *string ) 
{ 
  long sig ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp___0 = legal_number(string, & sig);
  }
  if (tmp___0) {
    if (sig >= 0L) {
      if (sig <= 65L) {
        tmp = (int )sig;
      } else {
        tmp = -1;
      }
    } else {
      tmp = -1;
    }
    return (tmp);
  }
  sig = 0L;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (sig <= 65L)) {
      goto while_break;
    }
    if ((unsigned long )signal_names[sig] == (unsigned long )((char *)0)) {
      goto __Cont;
    } else { //Added block
    if ((int )*(signal_names[sig] + 0) == 0) {
      goto __Cont;
    }
    }
    {
    tmp___1 = strcasecmp((char const   *)string, (char const   *)signal_names[sig]);
    }
    if (tmp___1 == 0) {
      return ((int )sig);
    } else {
      if ((int )*(signal_names[sig] + 0) == (int )*("SIG" + 0)) {
        {
        tmp___2 = strncmp((char const   *)signal_names[sig], "SIG", (size_t )3);
        }
        if (tmp___2 == 0) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      if (tmp___3) {
        {
        tmp___4 = strcasecmp((char const   *)string, (char const   *)(signal_names[sig] + 3));
        }
        if (tmp___4 == 0) {
          return ((int )sig);
        }
      }
    }
    __Cont: 
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static int catch_flag  ;
void run_pending_traps(void) 
{ 
  register int sig ;
  int old_exit_value ;
  int *token_state ;
  sigset_t set ;
  sigset_t oset ;
  char *tmp ;
  __pid_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  if (catch_flag == 0) {
    return;
  }
  catch_flag = 0;
  old_exit_value = last_command_exit_value;
  sig = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (sig < 65)) {
      goto while_break;
    }
    if (pending_traps[sig]) {
      {
      sigemptyset(& set);
      sigemptyset(& oset);
      sigaddset(& set, sig);
      sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )(& oset));
      }
      if (sig == 2) {
        {
        run_interrupt_trap();
        interrupt_state = 0;
        }
      } else { //Added block
      if ((unsigned long )trap_list[sig] == (unsigned long )((char *)((void (*)(int  ))0))) {
        goto _L;
      } else { //Added block
      if ((unsigned long )trap_list[sig] == (unsigned long )((char *)((void (*)(int  ))1))) {
        goto _L;
      } else { //Added block
      if ((unsigned long )trap_list[sig] == (unsigned long )((char *)(& initialize_traps))) {
        _L: 
        {
        internal_warning("run_pending_traps: bad value in trap_list[%d]: 0x%x", sig,
                         (int )trap_list[sig]);
        }
        if ((unsigned long )trap_list[sig] == (unsigned long )((char *)((void (*)(int  ))0))) {
          {
          tmp = signal_name(sig);
          internal_warning("run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself",
                           sig, tmp);
          tmp___0 = getpid();
          kill(tmp___0, sig);
          }
        }
      } else {
        {
        token_state = save_token_state();
        tmp___1 = strlen((char const   *)trap_list[sig]);
        tmp___2 = xmalloc(1UL + tmp___1);
        tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )trap_list[sig]);
        parse_and_execute(tmp___3, (char *)"trap", 5);
        restore_token_state(token_state);
        free((void *)token_state);
        }
      }
      }
      }
      }
      {
      pending_traps[sig] = 0;
      sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
      }
    }
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
  last_command_exit_value = old_exit_value;
  return;
}
}
void trap_handler(int sig ) 
{ 
  int oerrno ;
  int *tmp ;
  int *tmp___0 ;

  {
  if (sig >= 65) {
    {
    programming_error("trap_handler: bad signal %d", sig);
    }
  } else { //Added block
  if ((unsigned long )trap_list[sig] == (unsigned long )((char *)((void (*)(int  ))0))) {
    {
    programming_error("trap_handler: bad signal %d", sig);
    }
  } else { //Added block
  if ((unsigned long )trap_list[sig] == (unsigned long )((char *)((void (*)(int  ))1))) {
    {
    programming_error("trap_handler: bad signal %d", sig);
    }
  } else {
    {
    tmp = __errno_location();
    oerrno = *tmp;
    catch_flag = 1;
    (pending_traps[sig]) ++;
    }
    if (interrupt_immediately) {
      {
      run_pending_traps();
      }
    }
    {
    tmp___0 = __errno_location();
    *tmp___0 = oerrno;
    }
  }
  }
  }
  return;
}
}
void maybe_set_sigchld_trap(char *command_string ) 
{ 


  {
  if ((sigmodes[17] & 1) == 0) {
    {
    set_signal(17, command_string);
    }
  }
  return;
}
}
void set_debug_trap(char *command ) 
{ 


  {
  {
  set_signal(65, command);
  }
  return;
}
}
SigHandler *set_sigint_handler(void) 
{ 
  SigHandler *tmp ;
  SigHandler *tmp___0 ;
  SigHandler *tmp___1 ;
  SigHandler *tmp___2 ;

  {
  if (sigmodes[2] & 2) {
    return ((SigHandler *)((void (*)(int  ))1));
  } else { //Added block
  if (sigmodes[2] & 64) {
    {
    tmp = set_signal_handler(2, (SigHandler *)((void (*)(int  ))1));
    }
    return (tmp);
  } else { //Added block
  if (sigmodes[2] & 1) {
    {
    tmp___0 = set_signal_handler(2, (SigHandler *)(& trap_handler));
    }
    return (tmp___0);
  } else { //Added block
  if (interactive) {
    {
    tmp___1 = set_signal_handler(2, (SigHandler *)(& sigint_sighandler));
    }
    return (tmp___1);
  } else {
    {
    tmp___2 = set_signal_handler(2, (SigHandler *)(& termination_unwind_protect));
    }
    return (tmp___2);
  }
  }
  }
  }
}
}
SigHandler *trap_to_sighandler(int sig ) 
{ 


  {
  if (sigmodes[sig] & 66) {
    return ((SigHandler *)((void (*)(int  ))1));
  } else { //Added block
  if (sigmodes[sig] & 1) {
    return ((SigHandler *)(& trap_handler));
  } else {
    return ((SigHandler *)((void (*)(int  ))0));
  }
  }
}
}
void set_signal(int sig , char *string ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  SigHandler *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  if (sig == 65) {
    goto _L;
  } else { //Added block
  if (sig == 0) {
    _L: 
    {
    tmp = strlen((char const   *)string);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )string);
    change_signal(sig, tmp___1);
    }
    if (sig == 0) {
      if (interactive == 0) {
        {
        initialize_terminating_signals();
        }
      }
    }
    return;
  }
  }
  if (sigmodes[sig] & 2) {
    return;
  }
  if ((sigmodes[sig] & 1) == 0) {
    if ((unsigned long )original_signals[sig] == (unsigned long )(& initialize_traps)) {
      {
      tmp___2 = set_signal_handler(sig, (SigHandler *)((void (*)(int  ))0));
      original_signals[sig] = tmp___2;
      set_signal_handler(sig, original_signals[sig]);
      }
    }
    if ((unsigned long )original_signals[sig] == (unsigned long )((void (*)(int  ))1)) {
      sigmodes[sig] |= 2;
      return;
    }
  }
  if ((sigmodes[sig] & 8) == 0) {
    {
    set_signal_handler(sig, (SigHandler *)((void (*)(int  ))1));
    tmp___3 = strlen((char const   *)string);
    tmp___4 = xmalloc(1UL + tmp___3);
    tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )string);
    change_signal(sig, tmp___5);
    set_signal_handler(sig, (SigHandler *)(& trap_handler));
    }
  } else {
    {
    tmp___6 = strlen((char const   *)string);
    tmp___7 = xmalloc(1UL + tmp___6);
    tmp___8 = strcpy((char * __restrict  )tmp___7, (char const   * __restrict  )string);
    change_signal(sig, tmp___8);
    }
  }
  return;
}
}
static void free_trap_command(int sig ) 
{ 


  {
  if (sigmodes[sig] & 1) {
    if (trap_list[sig]) {
      if ((unsigned long )trap_list[sig] != (unsigned long )((char *)((void (*)(int  ))1))) {
        if ((unsigned long )trap_list[sig] != (unsigned long )((char *)((void (*)(int  ))0))) {
          if ((unsigned long )trap_list[sig] != (unsigned long )((char *)(& initialize_traps))) {
            {
            free((void *)trap_list[sig]);
            }
          }
        }
      }
    }
  }
  return;
}
}
static void change_signal(int sig , char *value ) 
{ 


  {
  if ((sigmodes[sig] & 16) == 0) {
    {
    free_trap_command(sig);
    }
  }
  trap_list[sig] = value;
  sigmodes[sig] |= 1;
  if ((unsigned long )value == (unsigned long )((char *)((void (*)(int  ))1))) {
    sigmodes[sig] |= 64;
  } else {
    sigmodes[sig] &= -65;
  }
  if (sigmodes[sig] & 16) {
    sigmodes[sig] |= 32;
  }
  return;
}
}
static void get_original_signal(int sig ) 
{ 
  SigHandler *tmp ;

  {
  if ((unsigned long )original_signals[sig] == (unsigned long )(& initialize_traps)) {
    {
    tmp = set_signal_handler(sig, (SigHandler *)((void (*)(int  ))0));
    original_signals[sig] = tmp;
    set_signal_handler(sig, original_signals[sig]);
    }
    if ((unsigned long )original_signals[sig] == (unsigned long )((void (*)(int  ))1)) {
      sigmodes[sig] |= 2;
    }
  }
  return;
}
}
void restore_default_signal(int sig ) 
{ 


  {
  if (sig == 65) {
    goto _L;
  } else { //Added block
  if (sig == 0) {
    _L: 
    if (sig != 65) {
      {
      free_trap_command(sig);
      }
    } else { //Added block
    if ((sigmodes[sig] & 16) == 0) {
      {
      free_trap_command(sig);
      }
    }
    }
    trap_list[sig] = (char *)((void *)0);
    sigmodes[sig] &= -2;
    if (sigmodes[sig] & 16) {
      sigmodes[sig] |= 32;
    }
    return;
  }
  }
  if (sig) {
    if (sig < 65) {
      if ((unsigned long )original_signals[sig] == (unsigned long )(& initialize_traps)) {
        {
        get_original_signal(sig);
        }
      }
    }
  }
  if (sigmodes[sig] & 2) {
    return;
  }
  if ((sigmodes[sig] & 1) == 0) {
    return;
  }
  if ((sigmodes[sig] & 8) == 0) {
    {
    set_signal_handler(sig, original_signals[sig]);
    }
  }
  {
  change_signal(sig, (char *)((void (*)(int  ))0));
  sigmodes[sig] &= -2;
  }
  return;
}
}
void ignore_signal(int sig ) 
{ 


  {
  if (sig == 0) {
    goto _L;
  } else { //Added block
  if (sig == 65) {
    _L: 
    if ((sigmodes[sig] & 64) == 0) {
      {
      change_signal(sig, (char *)((void (*)(int  ))1));
      }
      return;
    }
  }
  }
  if (sig) {
    if (sig < 65) {
      if ((unsigned long )original_signals[sig] == (unsigned long )(& initialize_traps)) {
        {
        get_original_signal(sig);
        }
      }
    }
  }
  if (sigmodes[sig] & 2) {
    return;
  }
  if (sigmodes[sig] & 64) {
    return;
  }
  if ((sigmodes[sig] & 8) == 0) {
    {
    set_signal_handler(sig, (SigHandler *)((void (*)(int  ))1));
    }
  }
  {
  change_signal(sig, (char *)((void (*)(int  ))1));
  }
  return;
}
}
int run_exit_trap(void) 
{ 
  char *trap_command ;
  int code ;
  int old_exit_value ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  old_exit_value = last_command_exit_value;
  if (sigmodes[0] & 1) {
    if ((sigmodes[0] & 80) == 0) {
      {
      tmp = strlen((char const   *)trap_list[0]);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )trap_list[0]);
      trap_command = tmp___1;
      sigmodes[0] &= -2;
      sigmodes[0] |= 16;
      code = __sigsetjmp(top_level, 1);
      }
      if (code == 0) {
        {
        reset_parser();
        parse_and_execute(trap_command, (char *)"exit trap", 5);
        }
      } else { //Added block
      if (code == 3) {
        return (last_command_exit_value);
      } else {
        return (old_exit_value);
      }
      }
    }
  }
  return (old_exit_value);
}
}
void run_trap_cleanup(int sig ) 
{ 


  {
  sigmodes[sig] &= -49;
  return;
}
}
static void _run_trap_internal(int sig , char *tag ) 
{ 
  char *trap_command ;
  char *old_trap ;
  int old_exit_value ;
  int *token_state ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (sigmodes[sig] & 1) {
    if ((sigmodes[sig] & 64) == 0) {
      if ((unsigned long )trap_list[sig] != (unsigned long )((char *)(& initialize_traps))) {
        if ((sigmodes[sig] & 16) == 0) {
          {
          old_trap = trap_list[sig];
          sigmodes[sig] |= 16;
          sigmodes[sig] &= -33;
          tmp = strlen((char const   *)old_trap);
          tmp___0 = xmalloc(1UL + tmp);
          tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )old_trap);
          trap_command = tmp___1;
          running_trap = sig + 1;
          old_exit_value = last_command_exit_value;
          trap_line_number = line_number;
          token_state = save_token_state();
          parse_and_execute(trap_command, tag, 5);
          restore_token_state(token_state);
          free((void *)token_state);
          last_command_exit_value = old_exit_value;
          running_trap = 0;
          sigmodes[sig] &= -17;
          }
          if (sigmodes[sig] & 32) {
            {
            free((void *)old_trap);
            sigmodes[sig] &= -33;
            }
          }
        }
      }
    }
  }
  return;
}
}
void run_debug_trap(void) 
{ 


  {
  if (sigmodes[65] & 1) {
    if ((sigmodes[65] & 16) == 0) {
      {
      _run_trap_internal(65, (char *)"debug trap");
      }
    }
  }
  return;
}
}
void run_interrupt_trap(void) 
{ 


  {
  {
  _run_trap_internal(2, (char *)"interrupt trap");
  }
  return;
}
}
static void reset_signal(int sig ) 
{ 


  {
  {
  set_signal_handler(sig, original_signals[sig]);
  }
  return;
}
}
static void restore_signal(int sig ) 
{ 


  {
  {
  set_signal_handler(sig, original_signals[sig]);
  change_signal(sig, (char *)((void (*)(int  ))0));
  sigmodes[sig] &= -2;
  }
  return;
}
}
static void reset_or_restore_signal_handlers(VFunction *reset ) 
{ 
  register int i ;

  {
  if (sigmodes[0] & 1) {
    {
    free_trap_command(0);
    trap_list[0] = (char *)((void *)0);
    sigmodes[0] &= -2;
    }
  }
  i = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < 65)) {
      goto while_break;
    }
    if (sigmodes[i] & 1) {
      if ((unsigned long )trap_list[i] == (unsigned long )((char *)((void (*)(int  ))1))) {
        {
        set_signal_handler(i, (SigHandler *)((void (*)(int  ))1));
        }
      } else {
        {
        (*reset)(i);
        }
      }
    } else { //Added block
    if (sigmodes[i] & 4) {
      {
      (*reset)(i);
      }
    }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void reset_signal_handlers(void) 
{ 


  {
  {
  reset_or_restore_signal_handlers((VFunction *)(& reset_signal));
  }
  return;
}
}
void restore_original_signals(void) 
{ 


  {
  {
  reset_or_restore_signal_handlers((VFunction *)(& restore_signal));
  }
  return;
}
}
int maybe_call_trap_handler(int sig ) 
{ 


  {
  if (sigmodes[sig] & 1) {
    if ((sigmodes[sig] & 64) == 0) {
      {
      if (sig == 2) {
        goto case_2;
      }
      if (sig == 0) {
        goto case_0;
      }
      if (sig == 65) {
        goto case_65;
      }
      goto switch_default;
      case_2: /* CIL Label */ 
      {
      run_interrupt_trap();
      }
      goto switch_break;
      case_0: /* CIL Label */ 
      {
      run_exit_trap();
      }
      goto switch_break;
      case_65: /* CIL Label */ 
      {
      run_debug_trap();
      }
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      trap_handler(sig);
      }
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      return (1);
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
int signal_is_trapped(int sig ) 
{ 


  {
  return (sigmodes[sig] & 1);
}
}
int signal_is_special(int sig ) 
{ 


  {
  return (sigmodes[sig] & 4);
}
}
int signal_is_ignored(int sig ) 
{ 


  {
  return (sigmodes[sig] & 64);
}
}
void set_signal_ignored(int sig ) 
{ 


  {
  sigmodes[sig] |= 2;
  original_signals[sig] = (SigHandler *)((void (*)(int  ))1);
  return;
}
}
#pragma merger("0","/tmp/cil-TBQyhWDN.i","-g")
int fd_is_bash_input(int fd ) ;
int set_bash_input_fd(int fd ) ;
int save_bash_input(int fd , int new_fd ) ;
int check_bash_input(int fd ) ;
int duplicate_buffered_stream(int fd1 , int fd2 ) ;
BUFFERED_STREAM *fd_to_buffered_stream(int fd ) ;
BUFFERED_STREAM *open_buffered_stream(char *file ) ;
void free_buffered_stream(BUFFERED_STREAM *bp ) ;
int close_buffered_stream(BUFFERED_STREAM *bp ) ;
int buffered_getchar(void) ;
int buffered_ungetchar(int c ) ;
static unsigned char localbuf[128]  ;
static int local_index  ;
static int local_bufused  ;
int getc_with_restart(FILE *stream ) 
{ 
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  if (local_index == local_bufused) {
    goto _L;
  } else { //Added block
  if (local_bufused == 0) {
    _L: 
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = fileno(stream);
      tmp___0 = read(tmp, (void *)(localbuf), sizeof(localbuf));
      local_bufused = (int )tmp___0;
      }
      if (local_bufused > 0) {
        goto while_break;
      } else { //Added block
      if (local_bufused == 0) {
        local_index = 0;
        return (-1);
      } else {
        {
        tmp___1 = __errno_location();
        }
        if (*tmp___1 != 4) {
          local_index = 0;
          return (-1);
        }
      }
      }
    }
    while_break: /* CIL Label */ ;
    }
    local_index = 0;
  }
  }
  tmp___2 = local_index;
  local_index ++;
  return ((int )localbuf[tmp___2]);
}
}
int ungetc_with_restart(int c , FILE *stream ) 
{ 
  unsigned char tmp ;

  {
  if (local_index == 0) {
    return (-1);
  } else { //Added block
  if (c == -1) {
    return (-1);
  }
  }
  local_index --;
  tmp = (unsigned char )c;
  localbuf[local_index] = tmp;
  return ((int )tmp);
}
}
static BUFFERED_STREAM **buffers  =    (BUFFERED_STREAM **)((void *)0);
static int nbuffers  ;
static void allocate_buffers(int n ) 
{ 
  register int i ;
  register int orig_nbuffers ;
  char *tmp ;

  {
  {
  orig_nbuffers = nbuffers;
  nbuffers = n + 20;
  tmp = xrealloc((void *)buffers, (unsigned long )nbuffers * sizeof(BUFFERED_STREAM *));
  buffers = (BUFFERED_STREAM **)tmp;
  i = orig_nbuffers;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < nbuffers)) {
      goto while_break;
    }
    *(buffers + i) = (BUFFERED_STREAM *)((void *)0);
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static BUFFERED_STREAM *make_buffered_stream(int fd , char *buffer , size_t bufsize ) 
{ 
  BUFFERED_STREAM *bp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = xmalloc(sizeof(BUFFERED_STREAM ));
  bp = (BUFFERED_STREAM *)tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (fd >= nbuffers) {
      {
      allocate_buffers(fd);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  *(buffers + fd) = bp;
  bp->b_fd = fd;
  bp->b_buffer = buffer;
  bp->b_size = bufsize;
  tmp___1 = 0;
  bp->b_flag = tmp___1;
  tmp___0 = tmp___1;
  bp->b_inputp = tmp___0;
  bp->b_used = tmp___0;
  if (bufsize == 1UL) {
    bp->b_flag |= 4;
  }
  return (bp);
}
}
static BUFFERED_STREAM *copy_buffered_stream(BUFFERED_STREAM *bp ) 
{ 
  BUFFERED_STREAM *nbp ;
  char *tmp ;

  {
  if (! bp) {
    return ((BUFFERED_STREAM *)((void *)0));
  }
  {
  tmp = xmalloc(sizeof(BUFFERED_STREAM ));
  nbp = (BUFFERED_STREAM *)tmp;
  xbcopy((char *)bp, (char *)nbp, (int )sizeof(BUFFERED_STREAM ));
  }
  return (nbp);
}
}
int set_bash_input_fd(int fd ) 
{ 


  {
  if ((unsigned int )bash_input.type == 4U) {
    bash_input.location.buffered_fd = fd;
  } else { //Added block
  if (interactive_shell == 0) {
    default_buffered_input = fd;
  }
  }
  return (0);
}
}
int fd_is_bash_input(int fd ) 
{ 


  {
  if ((unsigned int )bash_input.type == 4U) {
    if (bash_input.location.buffered_fd == fd) {
      return (1);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (interactive_shell == 0) {
    if (default_buffered_input == fd) {
      return (1);
    }
  }
  }
  return (0);
}
}
int save_bash_input(int fd , int new_fd ) 
{ 
  int nfd ;
  int tmp ;
  int tmp___0 ;

  {
  if (*(buffers + fd)) {
    {
    sync_buffered_stream(fd);
    }
  }
  if (new_fd == -1) {
    {
    tmp = fcntl(fd, 0, 10);
    nfd = tmp;
    }
  } else {
    nfd = new_fd;
  }
  if (nfd == -1) {
    {
    tmp___0 = fcntl(fd, 1, 0);
    }
    if (tmp___0 == 0) {
      {
      sys_error("cannot allocate new file descriptor for bash input from fd %d", fd);
      }
    }
    return (-1);
  }
  if (*(buffers + nfd)) {
    {
    internal_error("check_bash_input: buffer already exists for new fd %d", nfd);
    free_buffered_stream(*(buffers + nfd));
    }
  }
  if ((unsigned int )bash_input.type == 4U) {
    {
    bash_input.location.buffered_fd = nfd;
    fd_to_buffered_stream(nfd);
    close_buffered_fd(fd);
    }
  } else {
    bash_input_fd_changed ++;
  }
  if (default_buffered_input == fd) {
    default_buffered_input = nfd;
  }
  {
  fcntl(nfd, 2, 1);
  }
  return (nfd);
}
}
int check_bash_input(int fd ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (fd > 0) {
    {
    tmp___2 = fd_is_bash_input(fd);
    }
    if (tmp___2) {
      {
      tmp___1 = save_bash_input(fd, -1);
      }
      if (tmp___1 == -1) {
        tmp___0 = -1;
      } else {
        tmp___0 = 0;
      }
      return (tmp___0);
    }
  }
  return (0);
}
}
int duplicate_buffered_stream(int fd1 , int fd2 ) 
{ 
  int is_bash_input ;
  int m ;
  int tmp ;

  {
  if (fd1 == fd2) {
    return (0);
  }
  if (fd1 > fd2) {
    m = fd1;
  } else {
    m = fd2;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (m >= nbuffers) {
      {
      allocate_buffers(m);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned int )bash_input.type == 4U) {
    if (bash_input.location.buffered_fd == fd2) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  is_bash_input = tmp;
  if (*(buffers + fd2)) {
    {
    free_buffered_stream(*(buffers + fd2));
    }
  }
  {
  *(buffers + fd2) = copy_buffered_stream(*(buffers + fd1));
  }
  if (*(buffers + fd2)) {
    (*(buffers + fd2))->b_fd = fd2;
  }
  if (is_bash_input) {
    if (! *(buffers + fd2)) {
      {
      fd_to_buffered_stream(fd2);
      }
    }
    (*(buffers + fd2))->b_flag |= 8;
  }
  return (fd2);
}
}
BUFFERED_STREAM *fd_to_buffered_stream(int fd ) 
{ 
  char *buffer ;
  size_t size ;
  struct stat sb ;
  int tmp ;
  __off_t tmp___1 ;
  __off_t tmp___2 ;
  char *tmp___3 ;
  BUFFERED_STREAM *tmp___4 ;

  {
  {
  tmp = fstat(fd, & sb);
  }
  if (tmp < 0) {
    {
    close(fd);
    }
    return ((BUFFERED_STREAM *)((void *)0));
  }
  {
  tmp___2 = lseek(fd, 0L, 1);
  }
  if (tmp___2 >= 0L) {
    if (sb.st_size > 8176L) {
      tmp___1 = (__off_t )8176;
    } else {
      tmp___1 = sb.st_size;
    }
    size = (size_t )tmp___1;
  } else {
    size = (size_t )1;
  }
  if (size == 0UL) {
    size = (size_t )1;
  }
  {
  tmp___3 = xmalloc(size);
  buffer = tmp___3;
  tmp___4 = make_buffered_stream(fd, buffer, size);
  }
  return (tmp___4);
}
}
BUFFERED_STREAM *open_buffered_stream(char *file ) 
{ 
  int fd ;
  BUFFERED_STREAM *tmp ;
  BUFFERED_STREAM *tmp___0 ;

  {
  {
  fd = open((char const   *)file, 0);
  }
  if (fd >= 0) {
    {
    tmp = fd_to_buffered_stream(fd);
    tmp___0 = tmp;
    }
  } else {
    tmp___0 = (BUFFERED_STREAM *)((void *)0);
  }
  return (tmp___0);
}
}
void free_buffered_stream(BUFFERED_STREAM *bp ) 
{ 
  int n ;

  {
  if (! bp) {
    return;
  }
  n = bp->b_fd;
  if (bp->b_buffer) {
    {
    free((void *)bp->b_buffer);
    }
  }
  {
  free((void *)bp);
  *(buffers + n) = (BUFFERED_STREAM *)((void *)0);
  }
  return;
}
}
int close_buffered_stream(BUFFERED_STREAM *bp ) 
{ 
  int fd ;
  int tmp ;

  {
  if (! bp) {
    return (0);
  }
  {
  fd = bp->b_fd;
  free_buffered_stream(bp);
  tmp = close(fd);
  }
  return (tmp);
}
}
int close_buffered_fd(int fd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (fd >= nbuffers) {
    {
    tmp = close(fd);
    }
    return (tmp);
  } else { //Added block
  if (! buffers) {
    {
    tmp = close(fd);
    }
    return (tmp);
  } else { //Added block
  if (! *(buffers + fd)) {
    {
    tmp = close(fd);
    }
    return (tmp);
  }
  }
  }
  {
  tmp___0 = close_buffered_stream(*(buffers + fd));
  }
  return (tmp___0);
}
}
BUFFERED_STREAM *set_buffered_stream(int fd , BUFFERED_STREAM *bp ) 
{ 
  BUFFERED_STREAM *ret ;

  {
  ret = *(buffers + fd);
  *(buffers + fd) = bp;
  return (ret);
}
}
static int b_fill_buffer(BUFFERED_STREAM *bp ) 
{ 
  int tmp ;

  {
  {
  bp->b_used = zread(bp->b_fd, bp->b_buffer, bp->b_size);
  }
  if (bp->b_used <= 0) {
    *(bp->b_buffer + 0) = (char)0;
    if (bp->b_used == 0) {
      bp->b_flag |= 1;
    } else {
      bp->b_flag |= 2;
    }
    return (-1);
  }
  bp->b_inputp = 0;
  tmp = bp->b_inputp;
  (bp->b_inputp) ++;
  return ((int )*(bp->b_buffer + tmp) & 255);
}
}
static int bufstream_ungetc(int c , BUFFERED_STREAM *bp ) 
{ 


  {
  if (c == -1) {
    return (-1);
  } else { //Added block
  if (bp->b_inputp == 0) {
    return (-1);
  }
  }
  (bp->b_inputp) --;
  *(bp->b_buffer + bp->b_inputp) = (char )c;
  return (c);
}
}
int sync_buffered_stream(int bfd ) 
{ 
  BUFFERED_STREAM *bp ;
  off_t chars_left ;
  int tmp ;

  {
  if ((unsigned long )buffers == (unsigned long )((BUFFERED_STREAM **)0)) {
    return (-1);
  } else {
    bp = *(buffers + bfd);
    if ((unsigned long )bp == (unsigned long )((BUFFERED_STREAM *)0)) {
      return (-1);
    }
  }
  chars_left = (off_t )(bp->b_used - bp->b_inputp);
  if (chars_left) {
    {
    lseek(bp->b_fd, - chars_left, 1);
    }
  }
  tmp = 0;
  bp->b_inputp = tmp;
  bp->b_used = tmp;
  return (0);
}
}
int buffered_getchar(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((*(buffers + bash_input.location.buffered_fd))->b_inputp == (*(buffers + bash_input.location.buffered_fd))->b_used) {
    {
    tmp = b_fill_buffer(*(buffers + bash_input.location.buffered_fd));
    tmp___1 = tmp;
    }
  } else { //Added block
  if (! (*(buffers + bash_input.location.buffered_fd))->b_used) {
    {
    tmp = b_fill_buffer(*(buffers + bash_input.location.buffered_fd));
    tmp___1 = tmp;
    }
  } else {
    tmp___0 = (*(buffers + bash_input.location.buffered_fd))->b_inputp;
    ((*(buffers + bash_input.location.buffered_fd))->b_inputp) ++;
    tmp___1 = (int )*((*(buffers + bash_input.location.buffered_fd))->b_buffer + tmp___0) & 255;
  }
  }
  return (tmp___1);
}
}
int buffered_ungetchar(int c ) 
{ 
  int tmp ;

  {
  {
  tmp = bufstream_ungetc(c, *(buffers + bash_input.location.buffered_fd));
  }
  return (tmp);
}
}
void with_input_from_buffered_stream(int bfd , char *name ) 
{ 
  INPUT_STREAM location ;
  BUFFERED_STREAM *bp ;
  int (*tmp)() ;

  {
  {
  location.buffered_fd = bfd;
  bp = fd_to_buffered_stream(bfd);
  }
  if ((unsigned long )bp == (unsigned long )((BUFFERED_STREAM *)0)) {
    tmp = & return_EOF;
  } else {
    tmp = & buffered_getchar;
  }
  {
  init_yy_io(tmp, (Function *)(& buffered_ungetchar), (enum stream_type )4, name,
             location);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-UlLEieNL.i","-g")
void run_unwind_protects(void) ;
static void without_interrupts(VFunction *function , char *arg1 , char *arg2 ) ;
static void unwind_frame_discard_internal(char *tag , char *ignore ) ;
static void unwind_frame_run_internal(char *tag , char *ignore ) ;
static void add_unwind_protect_internal(Function *cleanup , char *arg ) ;
static void remove_unwind_protect_internal(char *ignore1 , char *ignore2 ) ;
static void run_unwind_protects_internal(char *ignore1 , char *ignore2 ) ;
static void clear_unwind_protects_internal(char *flag , char *ignore ) ;
static void restore_variable(SAVED_VAR *sv ) ;
static void discard_saved_var(SAVED_VAR *sv ) ;
static UNWIND_ELT *unwind_protect_list  =    (UNWIND_ELT *)((void *)0);
static void without_interrupts(VFunction *function , char *arg1 , char *arg2 ) 
{ 
  int old_interrupt_immediately ;

  {
  {
  old_interrupt_immediately = interrupt_immediately;
  interrupt_immediately = 0;
  (*function)(arg1, arg2);
  interrupt_immediately = old_interrupt_immediately;
  }
  return;
}
}
void begin_unwind_frame(char *tag ) 
{ 


  {
  {
  add_unwind_protect((Function *)((void *)0), tag);
  }
  return;
}
}
void discard_unwind_frame(char *tag ) 
{ 


  {
  if (unwind_protect_list) {
    {
    without_interrupts((VFunction *)(& unwind_frame_discard_internal), tag, (char *)((void *)0));
    }
  }
  return;
}
}
void run_unwind_frame(char *tag ) 
{ 


  {
  if (unwind_protect_list) {
    {
    without_interrupts((VFunction *)(& unwind_frame_run_internal), tag, (char *)((void *)0));
    }
  }
  return;
}
}
void add_unwind_protect(Function *cleanup , char *arg ) 
{ 


  {
  {
  without_interrupts((VFunction *)(& add_unwind_protect_internal), (char *)cleanup,
                     arg);
  }
  return;
}
}
void remove_unwind_protect(void) 
{ 


  {
  if (unwind_protect_list) {
    {
    without_interrupts((VFunction *)(& remove_unwind_protect_internal), (char *)((void *)0),
                       (char *)((void *)0));
    }
  }
  return;
}
}
void run_unwind_protects(void) 
{ 


  {
  if (unwind_protect_list) {
    {
    without_interrupts((VFunction *)(& run_unwind_protects_internal), (char *)((void *)0),
                       (char *)((void *)0));
    }
  }
  return;
}
}
void clear_unwind_protect_list(int flags ) 
{ 


  {
  if (unwind_protect_list) {
    {
    without_interrupts((VFunction *)(& clear_unwind_protects_internal), (char *)flags,
                       (char *)((void *)0));
    }
  }
  return;
}
}
static void add_unwind_protect_internal(Function *cleanup , char *arg ) 
{ 
  UNWIND_ELT *elt ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(UNWIND_ELT ));
  elt = (UNWIND_ELT *)tmp;
  elt->cleanup = cleanup;
  elt->arg = arg;
  elt->next = unwind_protect_list;
  unwind_protect_list = elt;
  }
  return;
}
}
static void remove_unwind_protect_internal(char *ignore1 , char *ignore2 ) 
{ 
  UNWIND_ELT *elt ;

  {
  elt = unwind_protect_list;
  if (elt) {
    unwind_protect_list = unwind_protect_list->next;
    if (elt->cleanup) {
      if ((unsigned long )elt->cleanup == (unsigned long )((Function *)(& restore_variable))) {
        {
        discard_saved_var((SAVED_VAR *)elt->arg);
        }
      }
    }
    {
    free((void *)elt);
    }
  }
  return;
}
}
static void run_unwind_protects_internal(char *ignore1 , char *ignore2 ) 
{ 
  UNWIND_ELT *t ;
  UNWIND_ELT *elt ;

  {
  elt = unwind_protect_list;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! elt) {
      goto while_break;
    }
    if (elt->cleanup) {
      {
      (*(elt->cleanup))(elt->arg);
      }
    }
    {
    t = elt;
    elt = elt->next;
    free((void *)t);
    }
  }
  while_break: /* CIL Label */ ;
  }
  unwind_protect_list = elt;
  return;
}
}
static void clear_unwind_protects_internal(char *flag , char *ignore ) 
{ 
  int free_elts ;

  {
  free_elts = (int )flag;
  if (free_elts != 0) {
    if (unwind_protect_list) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! unwind_protect_list) {
          goto while_break;
        }
        {
        remove_unwind_protect_internal((char *)((void *)0), (char *)((void *)0));
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  unwind_protect_list = (UNWIND_ELT *)((void *)0);
  return;
}
}
static void unwind_frame_discard_internal(char *tag , char *ignore ) 
{ 
  UNWIND_ELT *elt ;
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    elt = unwind_protect_list;
    if (! elt) {
      goto while_break;
    }
    unwind_protect_list = unwind_protect_list->next;
    if ((unsigned long )elt->cleanup == (unsigned long )((Function *)0)) {
      if ((int )*(elt->arg + 0) == (int )*(tag + 0)) {
        {
        tmp = strcmp((char const   *)elt->arg, (char const   *)tag);
        }
        if (tmp == 0) {
          {
          free((void *)elt);
          }
          goto while_break;
        } else {
          goto _L;
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (elt->cleanup) {
      if ((unsigned long )elt->cleanup == (unsigned long )((Function *)(& restore_variable))) {
        {
        discard_saved_var((SAVED_VAR *)elt->arg);
        free((void *)elt);
        }
      } else {
        {
        free((void *)elt);
        }
      }
    } else {
      {
      free((void *)elt);
      }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void unwind_frame_run_internal(char *tag , char *ignore ) 
{ 
  UNWIND_ELT *elt ;
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    elt = unwind_protect_list;
    if (! elt) {
      goto while_break;
    }
    unwind_protect_list = elt->next;
    if (! elt->cleanup) {
      if ((int )*(elt->arg + 0) == (int )*(tag + 0)) {
        {
        tmp = strcmp((char const   *)elt->arg, (char const   *)tag);
        }
        if (tmp == 0) {
          {
          free((void *)elt);
          }
          goto while_break;
        }
      }
      {
      free((void *)elt);
      }
      goto while_continue;
    } else {
      {
      (*(elt->cleanup))(elt->arg);
      free((void *)elt);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void discard_saved_var(SAVED_VAR *sv ) 
{ 


  {
  if ((unsigned long )sv->size != sizeof(int )) {
    {
    free((void *)sv->desired_setting);
    }
  }
  {
  free((void *)sv);
  }
  return;
}
}
static void restore_variable(SAVED_VAR *sv ) 
{ 


  {
  if ((unsigned long )sv->size != sizeof(int )) {
    {
    __builtin_memcpy((void *)((char *)sv->variable), (void const   *)sv->desired_setting,
                     (unsigned long )sv->size);
    free((void *)sv->desired_setting);
    }
  } else {
    *(sv->variable) = (int )sv->desired_setting;
  }
  {
  free((void *)sv);
  }
  return;
}
}
void unwind_protect_var(int *var , char *value , int size ) 
{ 
  SAVED_VAR *s ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = xmalloc(sizeof(SAVED_VAR ));
  s = (SAVED_VAR *)tmp;
  s->variable = var;
  }
  if ((unsigned long )size != sizeof(int )) {
    {
    tmp___0 = xmalloc((size_t )size);
    s->desired_setting = tmp___0;
    __builtin_memcpy((void *)s->desired_setting, (void const   *)value, (unsigned long )size);
    }
  } else {
    s->desired_setting = value;
  }
  {
  s->size = size;
  add_unwind_protect((Function *)(& restore_variable), (char *)s);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-t1VOiyMj.i","-g")
extern void sort_char_array(char ** ) ;
extern int noglob_dot_filenames ;
int glob_dot_filenames  ;
char *quote_globbing_chars(char *string ) ;
void setup_ignore_patterns(struct ignorevar *ivp ) ;
int should_ignore_glob_matches(void) ;
void ignore_glob_matches(char **names ) ;
extern char **glob_filename(char * ) ;
int extended_glob  =    0;
int unquoted_glob_pattern_p(char *string ) 
{ 
  register int c ;
  int open___0 ;
  char *tmp ;
  char *tmp___0 ;

  {
  open___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___0 = string;
    string ++;
    c = (int )*tmp___0;
    if (! c) {
      goto while_break;
    }
    {
    if (c == 63) {
      goto case_63;
    }
    if (c == 42) {
      goto case_63;
    }
    if (c == 91) {
      goto case_91;
    }
    if (c == 93) {
      goto case_93;
    }
    if (c == 43) {
      goto case_43;
    }
    if (c == 64) {
      goto case_43;
    }
    if (c == 33) {
      goto case_43;
    }
    if (c == 1) {
      goto case_1;
    }
    if (c == 92) {
      goto case_1;
    }
    goto switch_break;
    case_63: /* CIL Label */ 
    case_42: /* CIL Label */ 
    return (1);
    case_91: /* CIL Label */ 
    open___0 ++;
    goto while_continue;
    case_93: /* CIL Label */ 
    if (open___0) {
      return (1);
    }
    goto while_continue;
    case_43: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_33: /* CIL Label */ 
    if ((int )*string == 40) {
      return (1);
    }
    goto while_continue;
    case_1: /* CIL Label */ 
    case_92: /* CIL Label */ 
    tmp = string;
    string ++;
    if ((int )*tmp == 0) {
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
char *quote_string_for_globbing(char const   *pathname , int qflags ) 
{ 
  char *temp___0 ;
  register int i ;
  register int j ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = strlen(pathname);
  temp___0 = xmalloc(tmp + 1UL);
  }
  if (qflags & 1) {
    if ((int const   )*(pathname + 0) == 127) {
      if ((int const   )*(pathname + 1) == 0) {
        *(temp___0 + 0) = (char )'\000';
        return (temp___0);
      }
    }
  }
  j = 0;
  i = j;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(pathname + i)) {
      goto while_break;
    }
    if ((int const   )*(pathname + i) == 1) {
      if (qflags & 2) {
        if ((int const   )*(pathname + (i + 1)) == 47) {
          goto __Cont;
        }
      }
      tmp___0 = j;
      j ++;
      *(temp___0 + tmp___0) = (char )'\\';
    } else {
      tmp___1 = j;
      j ++;
      *(temp___0 + tmp___1) = (char )*(pathname + i);
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  *(temp___0 + j) = (char )'\000';
  return (temp___0);
}
}
char *quote_globbing_chars(char *string ) 
{ 
  char *temp___0 ;
  char *s ;
  char *t ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
  tmp = strlen((char const   *)string);
  temp___0 = xmalloc(tmp * 2UL + 1UL);
  t = temp___0;
  s = string;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    if ((int )*s == 42) {
      goto case_42;
    }
    if ((int )*s == 91) {
      goto case_42;
    }
    if ((int )*s == 93) {
      goto case_42;
    }
    if ((int )*s == 63) {
      goto case_42;
    }
    if ((int )*s == 92) {
      goto case_42;
    }
    if ((int )*s == 43) {
      goto case_43;
    }
    if ((int )*s == 64) {
      goto case_43;
    }
    if ((int )*s == 33) {
      goto case_43;
    }
    goto switch_break;
    case_42: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_92: /* CIL Label */ 
    tmp___0 = t;
    t ++;
    *tmp___0 = (char )'\\';
    goto switch_break;
    case_43: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_33: /* CIL Label */ 
    if ((int )*(s + 1) == 40) {
      tmp___1 = t;
      t ++;
      *tmp___1 = (char )'\\';
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    tmp___2 = t;
    t ++;
    tmp___3 = s;
    s ++;
    *tmp___2 = *tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
  *t = (char )'\000';
  return (temp___0);
}
}
char **shell_glob_filename(char const   *pathname ) 
{ 
  char *temp___0 ;
  char **results ;
  int tmp ;

  {
  {
  noglob_dot_filenames = glob_dot_filenames == 0;
  temp___0 = quote_string_for_globbing(pathname, 2);
  results = glob_filename(temp___0);
  free((void *)temp___0);
  }
  if (results) {
    if (((unsigned long )results == (unsigned long )(& glob_error_return)) == 0) {
      {
      tmp = should_ignore_glob_matches();
      }
      if (tmp) {
        {
        ignore_glob_matches(results);
        }
      }
      if (results) {
        if (*(results + 0)) {
          {
          sort_char_array(results);
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (results) {
            {
            free((void *)results);
            }
          }
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        results = & glob_error_return;
      }
    }
  }
  return (results);
}
}
static struct ignorevar globignore  =    {(char *)"GLOBIGNORE", (struct ign *)0, 0, (char *)0, (Function *)0};
void setup_glob_ignore(char *name ) 
{ 
  char *v___0 ;

  {
  {
  v___0 = get_string_value((char const   *)name);
  setup_ignore_patterns(& globignore);
  }
  if (globignore.num_ignores) {
    glob_dot_filenames = 1;
  } else { //Added block
  if ((unsigned long )v___0 == (unsigned long )((char *)0)) {
    glob_dot_filenames = 0;
  }
  }
  return;
}
}
int should_ignore_glob_matches(void) 
{ 


  {
  return (globignore.num_ignores);
}
}
static int glob_name_is_acceptable(char *name ) 
{ 
  struct ign *p ;
  int flags ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )*(name + 0) == 46) {
    if ((int )*(name + 1) == 0) {
      return (0);
    } else { //Added block
    if ((int )*(name + 1) == 46) {
      if ((int )*(name + 2) == 0) {
        return (0);
      }
    }
    }
  }
  if (extended_glob) {
    tmp = 1 << 5;
  } else {
    tmp = 0;
  }
  flags = 1 | tmp;
  p = globignore.ignores;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p->val) {
      goto while_break;
    }
    {
    tmp___0 = fnmatch(p->val, name, flags);
    }
    if (tmp___0 != 1) {
      return (0);
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static void ignore_globbed_names(char **names , Function *name_func ) 
{ 
  char **newnames ;
  int n ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(names + i)) {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  newnames = alloc_array(i + 1);
  i = 0;
  n = i;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *(names + i)) {
      goto while_break___0;
    }
    {
    tmp___0 = (*name_func)(*(names + i));
    }
    if (tmp___0) {
      tmp = n;
      n ++;
      *(newnames + tmp) = *(names + i);
    } else {
      {
      free((void *)*(names + i));
      }
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *(newnames + n) = (char *)((void *)0);
  if (n == 0) {
    {
    *(names + 0) = (char *)((void *)0);
    free((void *)newnames);
    }
    return;
  }
  n = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! *(newnames + n)) {
      goto while_break___1;
    }
    *(names + n) = *(newnames + n);
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  *(names + n) = (char *)((void *)0);
  free((void *)newnames);
  }
  return;
}
}
void ignore_glob_matches(char **names ) 
{ 


  {
  if (globignore.num_ignores == 0) {
    return;
  }
  {
  ignore_globbed_names(names, (Function *)(& glob_name_is_acceptable));
  }
  return;
}
}
void setup_ignore_patterns(struct ignorevar *ivp ) 
{ 
  int numitems ;
  int maxitems ;
  int ptr ;
  char *colon_bit ;
  char *this_ignoreval ;
  struct ign *p ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
  {
  this_ignoreval = get_string_value((char const   *)ivp->varname);
  }
  if (this_ignoreval) {
    if (ivp->last_ignoreval) {
      if ((int )*(this_ignoreval + 0) == (int )*(ivp->last_ignoreval + 0)) {
        {
        tmp = strcmp((char const   *)this_ignoreval, (char const   *)ivp->last_ignoreval);
        }
        if (tmp == 0) {
          return;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (! this_ignoreval) {
    if (! ivp->last_ignoreval) {
      return;
    }
  }
  }
  ivp->num_ignores = 0;
  if (ivp->ignores) {
    p = ivp->ignores;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! p->val) {
        goto while_break;
      }
      {
      free((void *)p->val);
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    free((void *)ivp->ignores);
    ivp->ignores = (struct ign *)((void *)0);
    }
  }
  if (ivp->last_ignoreval) {
    {
    free((void *)ivp->last_ignoreval);
    ivp->last_ignoreval = (char *)((void *)0);
    }
  }
  if ((unsigned long )this_ignoreval == (unsigned long )((char *)0)) {
    return;
  } else { //Added block
  if ((int )*this_ignoreval == 0) {
    return;
  }
  }
  {
  tmp___0 = strlen((char const   *)this_ignoreval);
  tmp___1 = xmalloc(1UL + tmp___0);
  tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )this_ignoreval);
  ivp->last_ignoreval = tmp___2;
  ptr = 0;
  maxitems = ptr;
  numitems = maxitems;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    colon_bit = extract_colon_unit(this_ignoreval, & ptr);
    }
    if (! colon_bit) {
      goto while_break___0;
    }
    if (numitems + 1 >= maxitems) {
      {
      maxitems += 10;
      tmp___3 = xrealloc((void *)ivp->ignores, (unsigned long )maxitems * sizeof(struct ign ));
      ivp->ignores = (struct ign *)tmp___3;
      }
    }
    {
    (ivp->ignores + numitems)->val = colon_bit;
    tmp___4 = strlen((char const   *)colon_bit);
    (ivp->ignores + numitems)->len = (int )tmp___4;
    (ivp->ignores + numitems)->flags = 0;
    }
    if (ivp->item_func) {
      {
      (*(ivp->item_func))(ivp->ignores + numitems);
      }
    }
    numitems ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  (ivp->ignores + numitems)->val = (char *)((void *)0);
  ivp->num_ignores = numitems;
  return;
}
}
#pragma merger("0","/tmp/cil-IsjdQygI.i","-g")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                                                int __signo ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
void reinitialize_signals(void) ;
extern void parse_and_execute_cleanup(void) ;
void bashline_reinitialize(void) ;
extern int parse_and_execute_level ;
int interrupt_immediately  =    0;
static void initialize_shell_signals() ;
void initialize_signals(void) 
{ 


  {
  {
  initialize_shell_signals();
  initialize_job_signals();
  }
  return;
}
}
void reinitialize_signals(void) 
{ 


  {
  {
  initialize_shell_signals(1);
  initialize_job_signals();
  }
  return;
}
}
static struct termsig terminating_signals[17]  = 
  {      {1, (SigHandler *)((void (*)(int  ))0)}, 
        {2, (SigHandler *)((void (*)(int  ))0)}, 
        {4, (SigHandler *)((void (*)(int  ))0)}, 
        {5, (SigHandler *)((void (*)(int  ))0)}, 
        {6, (SigHandler *)((void (*)(int  ))0)}, 
        {8, (SigHandler *)((void (*)(int  ))0)}, 
        {7, (SigHandler *)((void (*)(int  ))0)}, 
        {11, (SigHandler *)((void (*)(int  ))0)}, 
        {31, (SigHandler *)((void (*)(int  ))0)}, 
        {13, (SigHandler *)((void (*)(int  ))0)}, 
        {14, (SigHandler *)((void (*)(int  ))0)}, 
        {15, (SigHandler *)((void (*)(int  ))0)}, 
        {24, (SigHandler *)((void (*)(int  ))0)}, 
        {25, (SigHandler *)((void (*)(int  ))0)}, 
        {26, (SigHandler *)((void (*)(int  ))0)}, 
        {10, (SigHandler *)((void (*)(int  ))0)}, 
        {12, (SigHandler *)((void (*)(int  ))0)}};
static int termsigs_initialized  =    0;
void initialize_terminating_signals(void) 
{ 
  register int i ;
  struct sigaction act ;
  struct sigaction oact ;

  {
  if (termsigs_initialized) {
    return;
  }
  {
  act.__sigaction_handler.sa_handler = & termination_unwind_protect;
  act.sa_flags = 0;
  sigemptyset(& act.sa_mask);
  sigemptyset(& oact.sa_mask);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < sizeof(terminating_signals) / sizeof(struct termsig ))) {
      goto while_break;
    }
    {
    sigaddset(& act.sa_mask, terminating_signals[i].signum);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )i < sizeof(terminating_signals) / sizeof(struct termsig ))) {
      goto while_break___0;
    }
    {
    sigaction(terminating_signals[i].signum, (struct sigaction  const  * __restrict  )(& act),
              (struct sigaction * __restrict  )(& oact));
    terminating_signals[i].orig_handler = (SigHandler *)oact.__sigaction_handler.sa_handler;
    }
    if (! interactive_shell) {
      if ((unsigned long )terminating_signals[i].orig_handler == (unsigned long )((void (*)(int  ))1)) {
        {
        sigaction(terminating_signals[i].signum, (struct sigaction  const  * __restrict  )(& oact),
                  (struct sigaction * __restrict  )(& act));
        set_signal_ignored(terminating_signals[i].signum);
        }
      }
    }
    if (terminating_signals[i].signum == 27) {
      if ((unsigned long )terminating_signals[i].orig_handler != (unsigned long )((void (*)(int  ))0)) {
        if ((unsigned long )terminating_signals[i].orig_handler != (unsigned long )((void (*)(int  ))1)) {
          {
          sigaction(terminating_signals[i].signum, (struct sigaction  const  * __restrict  )(& oact),
                    (struct sigaction * __restrict  )((struct sigaction *)((void *)0)));
          }
        }
      }
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  termsigs_initialized = 1;
  return;
}
}
static void initialize_shell_signals(void) 
{ 


  {
  if (interactive) {
    {
    initialize_terminating_signals();
    }
  }
  {
  sigemptyset(& top_level_mask);
  sigprocmask(0, (sigset_t const   * __restrict  )((sigset_t *)((void *)0)), (sigset_t * __restrict  )(& top_level_mask));
  sigdelset(& top_level_mask, 17);
  set_signal_handler(3, (SigHandler *)((void (*)(int  ))1));
  }
  if (interactive) {
    {
    set_signal_handler(2, (SigHandler *)(& sigint_sighandler));
    set_signal_handler(15, (SigHandler *)((void (*)(int  ))1));
    }
  }
  return;
}
}
void reset_terminating_signals(void) 
{ 
  register int i ;
  struct sigaction act ;
  int tmp ;
  int tmp___0 ;

  {
  if (termsigs_initialized == 0) {
    return;
  }
  {
  act.sa_flags = 0;
  sigemptyset(& act.sa_mask);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < sizeof(terminating_signals) / sizeof(struct termsig ))) {
      goto while_break;
    }
    {
    tmp = signal_is_trapped(terminating_signals[i].signum);
    }
    if (tmp) {
      goto __Cont;
    } else {
      {
      tmp___0 = signal_is_special(terminating_signals[i].signum);
      }
      if (tmp___0) {
        goto __Cont;
      }
    }
    {
    act.__sigaction_handler.sa_handler = (void (*)(int  ))terminating_signals[i].orig_handler;
    sigaction(terminating_signals[i].signum, (struct sigaction  const  * __restrict  )(& act),
              (struct sigaction * __restrict  )((struct sigaction *)((void *)0)));
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void throw_to_top_level(void) 
{ 
  int print_newline ;
  int tmp ;

  {
  print_newline = 0;
  if (interrupt_state) {
    print_newline = 1;
    interrupt_state --;
  }
  if (interrupt_state) {
    return;
  }
  {
  last_command_exit_value |= 128;
  run_interrupt_trap();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! parse_and_execute_level) {
      goto while_break;
    }
    {
    parse_and_execute_cleanup();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  give_terminal_to(shell_pgrp, 0);
  sigprocmask(2, (sigset_t const   * __restrict  )(& top_level_mask), (sigset_t * __restrict  )((sigset_t *)((void *)0)));
  reset_parser();
  }
  if (interactive) {
    {
    bashline_reinitialize();
    }
  }
  {
  unlink_fifo_list();
  run_unwind_protects();
  breaking = 0;
  continuing = breaking;
  loop_level = continuing;
  return_catch_flag = 0;
  }
  if (interactive) {
    if (print_newline) {
      {
      fflush(stdout);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
      fflush(stderr);
      }
    }
  }
  if (interactive) {
    {
    jump_to_top_level(2);
    }
  } else { //Added block
  if (interactive_shell) {
    if (! shell_initialized) {
      {
      jump_to_top_level(2);
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (print_newline) {
    {
    tmp = signal_is_trapped(2);
    }
    if (tmp) {
      {
      jump_to_top_level(2);
      }
    } else {
      {
      jump_to_top_level(3);
      }
    }
  } else {
    {
    jump_to_top_level(3);
    }
  }
  }
  }
  return;
}
}
void jump_to_top_level(int value ) 
{ 


  {
  {
  siglongjmp(top_level, value);
  }
}
}
void termination_unwind_protect(int sig ) 
{ 
  int tmp ;
  __pid_t tmp___0 ;

  {
  if (sig == 2) {
    {
    tmp = signal_is_trapped(2);
    }
    if (tmp) {
      {
      run_interrupt_trap();
      }
    }
  }
  if (interactive_shell) {
    if (sig != 6) {
      {
      maybe_save_shell_history();
      }
    }
  }
  if (interactive) {
    if (sig == 1) {
      {
      hangup_all_jobs();
      }
    }
  }
  {
  end_job_control();
  unlink_fifo_list();
  run_exit_trap();
  set_signal_handler(sig, (SigHandler *)((void (*)(int  ))0));
  tmp___0 = getpid();
  kill(tmp___0, sig);
  }
  return;
}
}
void sigint_sighandler(int sig ) 
{ 


  {
  if (interrupt_state == 0) {
    interrupt_state ++;
  }
  if (interrupt_immediately) {
    {
    interrupt_immediately = 0;
    throw_to_top_level();
    }
  }
  return;
}
}
SigHandler *set_signal_handler(int sig , SigHandler *handler ) 
{ 
  struct sigaction act ;
  struct sigaction oact ;

  {
  {
  act.__sigaction_handler.sa_handler = (void (*)(int  ))handler;
  act.sa_flags = 0;
  sigemptyset(& act.sa_mask);
  sigemptyset(& oact.sa_mask);
  sigaction(sig, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )(& oact));
  }
  return ((SigHandler *)oact.__sigaction_handler.sa_handler);
}
}
#pragma merger("0","/tmp/cil-pCNded3b.i","-g")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
int test_eaccess(char *path___0 , int mode ) ;
int test_command(int margc , char **margv ) ;
extern int minus_o_option_value(char * ) ;
static sigjmp_buf test_exit_buf  ;
static int test_error_return  ;
static int pos  ;
static int argc  ;
static char **argv  ;
static int noeval___0  ;
static int unary_operator(void) ;
static int binary_operator(void) ;
static int two_arguments(void) ;
static int three_arguments(void) ;
static int posixtest(void) ;
static int expr(void) ;
static int term(void) ;
static int and(void) ;
static int or(void) ;
static void beyond(void) ;
static void test_syntax_error(char *format , char *arg ) 
{ 
  char *tmp ;

  {
  if (interactive_shell == 0) {
    {
    tmp = get_name_for_error();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", tmp);
    }
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", *(argv + 0));
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, arg);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  fflush(stderr);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    test_error_return = 2;
    siglongjmp(test_exit_buf, 1);
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void beyond(void) 
{ 


  {
  {
  test_syntax_error((char *)"argument expected", (char *)((void *)0));
  }
  return;
}
}
static void integer_expected_error(char *pch ) 
{ 


  {
  {
  test_syntax_error((char *)"%s: integer expression expected", pch);
  }
  return;
}
}
static int test_stat(char *path___0 , struct stat *finfo ) 
{ 
  int *tmp ;
  char pbuf[32] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((int )*path___0 == 0) {
    {
    tmp = __errno_location();
    *tmp = 2;
    }
    return (-1);
  }
  if ((int )*(path___0 + 0) == 47) {
    if ((int )*(path___0 + 1) == 100) {
      {
      tmp___1 = strncmp((char const   *)path___0, "/dev/fd/", (size_t )8);
      }
      if (tmp___1 == 0) {
        {
        strcpy((char * __restrict  )(pbuf), (char const   * __restrict  )"/dev/fd/");
        strcat((char * __restrict  )(pbuf), (char const   * __restrict  )(path___0 + 8));
        tmp___0 = stat((char const   * __restrict  )(pbuf), (struct stat * __restrict  )finfo);
        }
        return (tmp___0);
      }
    }
  }
  {
  tmp___2 = stat((char const   * __restrict  )path___0, (struct stat * __restrict  )finfo);
  }
  return (tmp___2);
}
}
int test_eaccess(char *path___0 , int mode ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
  tmp = test_stat(path___0, & st);
  }
  if (tmp < 0) {
    return (-1);
  }
  if (current_user.euid == 0U) {
    if (mode != 1) {
      return (0);
    }
    if (st.st_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
      return (0);
    }
  }
  if (st.st_uid == current_user.euid) {
    mode <<= 6;
  } else {
    {
    tmp___0 = group_member(st.st_gid);
    }
    if (tmp___0) {
      mode <<= 3;
    }
  }
  if (st.st_mode & (unsigned int )mode) {
    return (0);
  }
  {
  tmp___1 = __errno_location();
  *tmp___1 = 13;
  }
  return (-1);
}
}
static int expr(void) 
{ 
  int tmp ;

  {
  if (pos >= argc) {
    {
    beyond();
    }
  }
  {
  tmp = or();
  }
  return (tmp);
}
}
static int or(void) 
{ 
  int value ;
  int v2 ;
  int tmp ;

  {
  {
  value = and();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (pos < argc) {
      if ((int )*(*(argv + pos) + 0) == 45) {
        if ((int )*(*(argv + pos) + 1) == 111) {
          if (! (! *(*(argv + pos) + 2))) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      pos ++;
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    v2 = or();
    }
    if (value) {
      tmp = 1;
    } else { //Added block
    if (v2) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
    return (tmp);
  }
  while_break: /* CIL Label */ ;
  }
  return (value);
}
}
static int and(void) 
{ 
  int value ;
  int v2 ;
  int tmp ;

  {
  {
  value = term();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (pos < argc) {
      if ((int )*(*(argv + pos) + 0) == 45) {
        if ((int )*(*(argv + pos) + 1) == 97) {
          if (! (! *(*(argv + pos) + 2))) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      pos ++;
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    v2 = and();
    }
    if (value) {
      if (v2) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    return (tmp);
  }
  while_break: /* CIL Label */ ;
  }
  return (value);
}
}
static int term(void) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (pos >= argc) {
    {
    beyond();
    }
  }
  if ((int )*(*(argv + pos) + 0) == 33) {
    if ((int )*(*(argv + pos) + 1) == 0) {
      value = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (pos < argc) {
          if ((int )*(*(argv + pos) + 0) == 33) {
            if (! ((int )*(*(argv + pos) + 1) == 0)) {
              goto while_break;
            }
          } else {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          pos ++;
          if (pos >= argc) {
            {
            beyond();
            }
          }
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        value = 1 - value;
      }
      while_break: /* CIL Label */ ;
      }
      if (value) {
        {
        tmp = term();
        }
        if (tmp) {
          tmp___0 = 0;
        } else {
          tmp___0 = 1;
        }
        tmp___2 = tmp___0;
      } else {
        {
        tmp___1 = term();
        tmp___2 = tmp___1;
        }
      }
      return (tmp___2);
    }
  }
  if ((int )*(*(argv + pos) + 0) == 40) {
    if ((int )*(*(argv + pos) + 1) == 0) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        pos ++;
        if (pos >= argc) {
          {
          beyond();
          }
        }
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      value = expr();
      }
      if ((unsigned long )*(argv + pos) == (unsigned long )((char *)0)) {
        {
        test_syntax_error((char *)"`)\' expected", (char *)((void *)0));
        }
      } else { //Added block
      if ((int )*(*(argv + pos) + 0) != 41) {
        {
        test_syntax_error((char *)"`)\' expected, found %s", *(argv + pos));
        }
      } else { //Added block
      if (*(*(argv + pos) + 1)) {
        {
        test_syntax_error((char *)"`)\' expected, found %s", *(argv + pos));
        }
      }
      }
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        pos ++;
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      return (value);
    }
  }
  if (pos + 3 <= argc) {
    {
    tmp___4 = test_binop(*(argv + (pos + 1)));
    }
    if (tmp___4) {
      {
      value = binary_operator();
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((int )*(*(argv + pos) + 0) == 45) {
    if ((int )*(*(argv + pos) + 2) == 0) {
      {
      tmp___3 = test_unop(*(argv + pos));
      }
      if (tmp___3) {
        {
        value = unary_operator();
        }
      } else {
        {
        test_syntax_error((char *)"%s: unary operator expected", *(argv + pos));
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    value = (int )*(*(argv + pos) + 0) != 0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      pos ++;
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  }
  return (value);
}
}
static int filecomp(char *s , char *t , int op ) 
{ 
  struct stat st1 ;
  struct stat st2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = test_stat(s, & st1);
  }
  if (tmp < 0) {
    st1.st_mtim.tv_sec = (__time_t )0;
    if (op == 2) {
      return (0);
    }
  }
  {
  tmp___0 = test_stat(t, & st2);
  }
  if (tmp___0 < 0) {
    st2.st_mtim.tv_sec = (__time_t )0;
    if (op == 2) {
      return (0);
    }
  }
  {
  if (op == 1) {
    goto case_1;
  }
  if (op == 0) {
    goto case_0;
  }
  if (op == 2) {
    goto case_2;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  return (st1.st_mtim.tv_sec < st2.st_mtim.tv_sec);
  case_0: /* CIL Label */ 
  return (st1.st_mtim.tv_sec > st2.st_mtim.tv_sec);
  case_2: /* CIL Label */ 
  if (st1.st_dev == st2.st_dev) {
    if (st1.st_ino == st2.st_ino) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int arithcomp(char *s , char *t , int op , int flags ) 
{ 
  long l ;
  long r ;
  int expok ;
  int tmp ;
  int tmp___0 ;

  {
  if (flags & 2) {
    {
    l = evalexp(s, & expok);
    }
    if (expok == 0) {
      return (0);
    }
    {
    r = evalexp(t, & expok);
    }
    if (expok == 0) {
      return (0);
    }
  } else {
    {
    tmp = legal_number(s, & l);
    }
    if (tmp == 0) {
      {
      integer_expected_error(s);
      }
    }
    {
    tmp___0 = legal_number(t, & r);
    }
    if (tmp___0 == 0) {
      {
      integer_expected_error(t);
      }
    }
  }
  {
  if (op == 0) {
    goto case_0;
  }
  if (op == 1) {
    goto case_1;
  }
  if (op == 2) {
    goto case_2;
  }
  if (op == 3) {
    goto case_3;
  }
  if (op == 4) {
    goto case_4;
  }
  if (op == 5) {
    goto case_5;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  return (l == r);
  case_1: /* CIL Label */ 
  return (l != r);
  case_2: /* CIL Label */ 
  return (l < r);
  case_3: /* CIL Label */ 
  return (l > r);
  case_4: /* CIL Label */ 
  return (l <= r);
  case_5: /* CIL Label */ 
  return (l >= r);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int patcomp(char *string , char *pat , int op ) 
{ 
  int m ;
  int tmp ;
  int tmp___0 ;

  {
  if (extended_glob) {
    tmp = 1 << 5;
  } else {
    tmp = 0;
  }
  {
  m = fnmatch(pat, string, tmp);
  }
  if (op == 0) {
    tmp___0 = m == 0;
  } else {
    tmp___0 = m != 0;
  }
  return (tmp___0);
}
}
int binary_test(char *op , char *arg1 , char *arg2 , int flags ) 
{ 
  int patmatch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  patmatch = flags & 1;
  if ((int )*(op + 0) == 61) {
    if ((int )*(op + 1) == 0) {
      goto _L___4;
    } else { //Added block
    if ((int )*(op + 1) == 61) {
      if ((int )*(op + 2) == 0) {
        _L___4: 
        if (patmatch) {
          {
          tmp = patcomp(arg1, arg2, 0);
          tmp___2 = tmp;
          }
        } else {
          if ((int )*(arg1 + 0) == (int )*(arg2 + 0)) {
            {
            tmp___0 = strcmp((char const   *)arg1, (char const   *)arg2);
            }
            if (tmp___0 == 0) {
              tmp___1 = 1;
            } else {
              tmp___1 = 0;
            }
          } else {
            tmp___1 = 0;
          }
          tmp___2 = tmp___1;
        }
        return (tmp___2);
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
    }
  } else { //Added block
  _L___3: 
  if ((int )*(op + 0) == 62) {
    goto _L___2;
  } else { //Added block
  if ((int )*(op + 0) == 60) {
    _L___2: 
    if ((int )*(op + 1) == 0) {
      if ((int )*(op + 0) == 62) {
        {
        tmp___3 = strcmp((char const   *)arg1, (char const   *)arg2);
        tmp___5 = tmp___3 > 0;
        }
      } else {
        {
        tmp___4 = strcmp((char const   *)arg1, (char const   *)arg2);
        tmp___5 = tmp___4 < 0;
        }
      }
      return (tmp___5);
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if ((int )*(op + 0) == 33) {
    if ((int )*(op + 1) == 61) {
      if ((int )*(op + 2) == 0) {
        if (patmatch) {
          {
          tmp___6 = patcomp(arg1, arg2, 1);
          tmp___9 = tmp___6;
          }
        } else {
          if ((int )*(arg1 + 0) == (int )*(arg2 + 0)) {
            {
            tmp___7 = strcmp((char const   *)arg1, (char const   *)arg2);
            }
            if (tmp___7 == 0) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
          } else {
            tmp___8 = 0;
          }
          tmp___9 = tmp___8 == 0;
        }
        return (tmp___9);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((int )*(op + 2) == 116) {
    {
    if ((int )*(op + 1) == 110) {
      goto case_110;
    }
    if ((int )*(op + 1) == 111) {
      goto case_111;
    }
    if ((int )*(op + 1) == 108) {
      goto case_108;
    }
    if ((int )*(op + 1) == 103) {
      goto case_103;
    }
    goto switch_break;
    case_110: /* CIL Label */ 
    {
    tmp___10 = filecomp(arg1, arg2, 0);
    }
    return (tmp___10);
    case_111: /* CIL Label */ 
    {
    tmp___11 = filecomp(arg1, arg2, 1);
    }
    return (tmp___11);
    case_108: /* CIL Label */ 
    {
    tmp___12 = arithcomp(arg1, arg2, 2, flags);
    }
    return (tmp___12);
    case_103: /* CIL Label */ 
    {
    tmp___13 = arithcomp(arg1, arg2, 3, flags);
    }
    return (tmp___13);
    switch_break: /* CIL Label */ ;
    }
  } else { //Added block
  if ((int )*(op + 1) == 101) {
    {
    if ((int )*(op + 2) == 102) {
      goto case_102;
    }
    if ((int )*(op + 2) == 113) {
      goto case_113;
    }
    goto switch_break___0;
    case_102: /* CIL Label */ 
    {
    tmp___14 = filecomp(arg1, arg2, 2);
    }
    return (tmp___14);
    case_113: /* CIL Label */ 
    {
    tmp___15 = arithcomp(arg1, arg2, 0, flags);
    }
    return (tmp___15);
    switch_break___0: /* CIL Label */ ;
    }
  } else { //Added block
  if ((int )*(op + 2) == 101) {
    {
    if ((int )*(op + 1) == 110) {
      goto case_110___0;
    }
    if ((int )*(op + 1) == 103) {
      goto case_103___0;
    }
    if ((int )*(op + 1) == 108) {
      goto case_108___0;
    }
    goto switch_break___1;
    case_110___0: /* CIL Label */ 
    {
    tmp___16 = arithcomp(arg1, arg2, 1, flags);
    }
    return (tmp___16);
    case_103___0: /* CIL Label */ 
    {
    tmp___17 = arithcomp(arg1, arg2, 5, flags);
    }
    return (tmp___17);
    case_108___0: /* CIL Label */ 
    {
    tmp___18 = arithcomp(arg1, arg2, 4, flags);
    }
    return (tmp___18);
    switch_break___1: /* CIL Label */ ;
    }
  }
  }
  }
  }
  }
  }
  }
  return (0);
}
}
static int binary_operator(void) 
{ 
  int value ;
  char *w ;
  int tmp ;

  {
  w = *(argv + (pos + 1));
  if ((int )*(w + 0) == 61) {
    if ((int )*(w + 1) == 0) {
      {
      value = binary_test(w, *(argv + pos), *(argv + (pos + 2)), 0);
      pos += 3;
      }
      return (value);
    } else { //Added block
    if ((int )*(w + 1) == 61) {
      if ((int )*(w + 2) == 0) {
        {
        value = binary_test(w, *(argv + pos), *(argv + (pos + 2)), 0);
        pos += 3;
        }
        return (value);
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
    }
  } else { //Added block
  _L___1: 
  if ((int )*(w + 0) == 62) {
    goto _L___0;
  } else { //Added block
  if ((int )*(w + 0) == 60) {
    _L___0: 
    if ((int )*(w + 1) == 0) {
      {
      value = binary_test(w, *(argv + pos), *(argv + (pos + 2)), 0);
      pos += 3;
      }
      return (value);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(w + 0) == 33) {
    if ((int )*(w + 1) == 61) {
      if ((int )*(w + 2) == 0) {
        {
        value = binary_test(w, *(argv + pos), *(argv + (pos + 2)), 0);
        pos += 3;
        }
        return (value);
      }
    }
  }
  }
  }
  }
  if ((int )*(w + 0) != 45) {
    {
    test_syntax_error((char *)"%s: binary operator expected", w);
    }
    return (0);
  } else { //Added block
  if ((int )*(w + 3) != 0) {
    {
    test_syntax_error((char *)"%s: binary operator expected", w);
    }
    return (0);
  } else {
    {
    tmp = test_binop(w);
    }
    if (tmp == 0) {
      {
      test_syntax_error((char *)"%s: binary operator expected", w);
      }
      return (0);
    }
  }
  }
  {
  value = binary_test(w, *(argv + pos), *(argv + (pos + 2)), 0);
  pos += 3;
  }
  return (value);
}
}
static int unary_operator(void) 
{ 
  char *op ;
  long r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  op = *(argv + pos);
  tmp = test_unop(op);
  }
  if (tmp == 0) {
    return (0);
  }
  if ((int )*(op + 1) == 116) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      pos ++;
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    if (pos < argc) {
      {
      tmp___1 = legal_number(*(argv + pos), & r);
      }
      if (tmp___1) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          pos ++;
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        tmp___0 = unary_test(op, *(argv + (pos - 1)));
        }
        return (tmp___0);
      } else {
        return (0);
      }
    } else {
      {
      tmp___2 = unary_test(op, (char *)"1");
      }
      return (tmp___2);
    }
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      pos ++;
      if (pos >= argc) {
        {
        beyond();
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    pos ++;
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  tmp___3 = unary_test(op, *(argv + (pos - 1)));
  }
  return (tmp___3);
}
}
int unary_test(char *op , char *arg ) 
{ 
  long r ;
  struct stat stat_buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
  {
  if ((int )*(op + 1) == 97) {
    goto case_97;
  }
  if ((int )*(op + 1) == 101) {
    goto case_97;
  }
  if ((int )*(op + 1) == 114) {
    goto case_114;
  }
  if ((int )*(op + 1) == 119) {
    goto case_119;
  }
  if ((int )*(op + 1) == 120) {
    goto case_120;
  }
  if ((int )*(op + 1) == 79) {
    goto case_79;
  }
  if ((int )*(op + 1) == 71) {
    goto case_71;
  }
  if ((int )*(op + 1) == 78) {
    goto case_78;
  }
  if ((int )*(op + 1) == 102) {
    goto case_102;
  }
  if ((int )*(op + 1) == 100) {
    goto case_100;
  }
  if ((int )*(op + 1) == 115) {
    goto case_115;
  }
  if ((int )*(op + 1) == 83) {
    goto case_83;
  }
  if ((int )*(op + 1) == 99) {
    goto case_99;
  }
  if ((int )*(op + 1) == 98) {
    goto case_98;
  }
  if ((int )*(op + 1) == 112) {
    goto case_112;
  }
  if ((int )*(op + 1) == 76) {
    goto case_76;
  }
  if ((int )*(op + 1) == 104) {
    goto case_76;
  }
  if ((int )*(op + 1) == 117) {
    goto case_117;
  }
  if ((int )*(op + 1) == 103) {
    goto case_103;
  }
  if ((int )*(op + 1) == 107) {
    goto case_107;
  }
  if ((int )*(op + 1) == 116) {
    goto case_116;
  }
  if ((int )*(op + 1) == 110) {
    goto case_110;
  }
  if ((int )*(op + 1) == 122) {
    goto case_122;
  }
  if ((int )*(op + 1) == 111) {
    goto case_111;
  }
  goto switch_break;
  case_97: /* CIL Label */ 
  case_101: /* CIL Label */ 
  {
  tmp = test_stat(arg, & stat_buf);
  }
  return (tmp == 0);
  case_114: /* CIL Label */ 
  {
  tmp___0 = test_eaccess(arg, 4);
  }
  return (tmp___0 == 0);
  case_119: /* CIL Label */ 
  {
  tmp___1 = test_eaccess(arg, 2);
  }
  return (tmp___1 == 0);
  case_120: /* CIL Label */ 
  {
  tmp___2 = test_eaccess(arg, 1);
  }
  return (tmp___2 == 0);
  case_79: /* CIL Label */ 
  {
  tmp___3 = test_stat(arg, & stat_buf);
  }
  if (tmp___3 == 0) {
    if (current_user.euid == stat_buf.st_uid) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  return (tmp___4);
  case_71: /* CIL Label */ 
  {
  tmp___5 = test_stat(arg, & stat_buf);
  }
  if (tmp___5 == 0) {
    if (current_user.egid == stat_buf.st_gid) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
  } else {
    tmp___6 = 0;
  }
  return (tmp___6);
  case_78: /* CIL Label */ 
  {
  tmp___7 = test_stat(arg, & stat_buf);
  }
  if (tmp___7 == 0) {
    if (stat_buf.st_atim.tv_sec <= stat_buf.st_mtim.tv_sec) {
      tmp___8 = 1;
    } else {
      tmp___8 = 0;
    }
  } else {
    tmp___8 = 0;
  }
  return (tmp___8);
  case_102: /* CIL Label */ 
  {
  tmp___9 = test_stat(arg, & stat_buf);
  }
  if (tmp___9 < 0) {
    return (0);
  }
  if ((stat_buf.st_mode & 61440U) == 32768U) {
    tmp___10 = 1;
  } else { //Added block
  if ((stat_buf.st_mode & 61440U) == 0U) {
    tmp___10 = 1;
  } else {
    tmp___10 = 0;
  }
  }
  return (tmp___10);
  case_100: /* CIL Label */ 
  {
  tmp___11 = test_stat(arg, & stat_buf);
  }
  if (tmp___11 == 0) {
    if ((stat_buf.st_mode & 61440U) == 16384U) {
      tmp___12 = 1;
    } else {
      tmp___12 = 0;
    }
  } else {
    tmp___12 = 0;
  }
  return (tmp___12);
  case_115: /* CIL Label */ 
  {
  tmp___13 = test_stat(arg, & stat_buf);
  }
  if (tmp___13 == 0) {
    if (stat_buf.st_size > 0L) {
      tmp___14 = 1;
    } else {
      tmp___14 = 0;
    }
  } else {
    tmp___14 = 0;
  }
  return (tmp___14);
  case_83: /* CIL Label */ 
  {
  tmp___15 = test_stat(arg, & stat_buf);
  }
  if (tmp___15 == 0) {
    if ((stat_buf.st_mode & 61440U) == 49152U) {
      tmp___16 = 1;
    } else {
      tmp___16 = 0;
    }
  } else {
    tmp___16 = 0;
  }
  return (tmp___16);
  case_99: /* CIL Label */ 
  {
  tmp___17 = test_stat(arg, & stat_buf);
  }
  if (tmp___17 == 0) {
    if ((stat_buf.st_mode & 61440U) == 8192U) {
      tmp___18 = 1;
    } else {
      tmp___18 = 0;
    }
  } else {
    tmp___18 = 0;
  }
  return (tmp___18);
  case_98: /* CIL Label */ 
  {
  tmp___19 = test_stat(arg, & stat_buf);
  }
  if (tmp___19 == 0) {
    if ((stat_buf.st_mode & 61440U) == 24576U) {
      tmp___20 = 1;
    } else {
      tmp___20 = 0;
    }
  } else {
    tmp___20 = 0;
  }
  return (tmp___20);
  case_112: /* CIL Label */ 
  {
  tmp___21 = test_stat(arg, & stat_buf);
  }
  if (tmp___21 == 0) {
    if ((stat_buf.st_mode & 61440U) == 4096U) {
      tmp___22 = 1;
    } else {
      tmp___22 = 0;
    }
  } else {
    tmp___22 = 0;
  }
  return (tmp___22);
  case_76: /* CIL Label */ 
  case_104: /* CIL Label */ 
  if ((int )*(arg + 0) != 0) {
    {
    tmp___23 = lstat((char const   * __restrict  )arg, (struct stat * __restrict  )(& stat_buf));
    }
    if (tmp___23 == 0) {
      if ((stat_buf.st_mode & 61440U) == 40960U) {
        tmp___24 = 1;
      } else {
        tmp___24 = 0;
      }
    } else {
      tmp___24 = 0;
    }
  } else {
    tmp___24 = 0;
  }
  return (tmp___24);
  case_117: /* CIL Label */ 
  {
  tmp___25 = test_stat(arg, & stat_buf);
  }
  if (tmp___25 == 0) {
    if ((stat_buf.st_mode & 2048U) != 0U) {
      tmp___26 = 1;
    } else {
      tmp___26 = 0;
    }
  } else {
    tmp___26 = 0;
  }
  return (tmp___26);
  case_103: /* CIL Label */ 
  {
  tmp___27 = test_stat(arg, & stat_buf);
  }
  if (tmp___27 == 0) {
    if ((stat_buf.st_mode & 1024U) != 0U) {
      tmp___28 = 1;
    } else {
      tmp___28 = 0;
    }
  } else {
    tmp___28 = 0;
  }
  return (tmp___28);
  case_107: /* CIL Label */ 
  {
  tmp___29 = test_stat(arg, & stat_buf);
  }
  if (tmp___29 == 0) {
    if ((stat_buf.st_mode & 512U) != 0U) {
      tmp___30 = 1;
    } else {
      tmp___30 = 0;
    }
  } else {
    tmp___30 = 0;
  }
  return (tmp___30);
  case_116: /* CIL Label */ 
  {
  tmp___31 = legal_number(arg, & r);
  }
  if (tmp___31 == 0) {
    return (0);
  }
  {
  tmp___32 = isatty((int )r);
  }
  return (tmp___32);
  case_110: /* CIL Label */ 
  return ((int )*(arg + 0) != 0);
  case_122: /* CIL Label */ 
  return ((int )*(arg + 0) == 0);
  case_111: /* CIL Label */ 
  {
  tmp___33 = minus_o_option_value(arg);
  }
  return (tmp___33 == 1);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
int test_binop(char *op ) 
{ 


  {
  if ((int )*(op + 0) == 61) {
    if ((int )*(op + 1) == 0) {
      return (1);
    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: 
  if ((int )*(op + 0) == 60) {
    goto _L___3;
  } else { //Added block
  if ((int )*(op + 0) == 62) {
    _L___3: 
    if ((int )*(op + 1) == 0) {
      return (1);
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if ((int )*(op + 0) == 61) {
    goto _L___1;
  } else { //Added block
  if ((int )*(op + 0) == 33) {
    _L___1: 
    if ((int )*(op + 1) == 61) {
      if ((int )*(op + 2) == 0) {
        return (1);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((int )*(op + 0) != 45) {
    return (0);
  } else { //Added block
  if ((int )*(op + 2) == 0) {
    return (0);
  } else { //Added block
  if ((int )*(op + 3) != 0) {
    return (0);
  } else { //Added block
  if ((int )*(op + 2) == 116) {
    {
    if ((int )*(op + 1) == 110) {
      goto case_110;
    }
    if ((int )*(op + 1) == 111) {
      goto case_110;
    }
    if ((int )*(op + 1) == 108) {
      goto case_110;
    }
    if ((int )*(op + 1) == 103) {
      goto case_110;
    }
    goto switch_default;
    case_110: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_103: /* CIL Label */ 
    return (1);
    switch_default: /* CIL Label */ 
    return (0);
    switch_break: /* CIL Label */ ;
    }
  } else { //Added block
  if ((int )*(op + 1) == 101) {
    {
    if ((int )*(op + 2) == 113) {
      goto case_113;
    }
    if ((int )*(op + 2) == 102) {
      goto case_113;
    }
    goto switch_default___0;
    case_113: /* CIL Label */ 
    case_102: /* CIL Label */ 
    return (1);
    switch_default___0: /* CIL Label */ 
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  } else { //Added block
  if ((int )*(op + 2) == 101) {
    {
    if ((int )*(op + 1) == 110) {
      goto case_110___0;
    }
    if ((int )*(op + 1) == 103) {
      goto case_110___0;
    }
    if ((int )*(op + 1) == 108) {
      goto case_110___0;
    }
    goto switch_default___1;
    case_110___0: /* CIL Label */ 
    case_103___0: /* CIL Label */ 
    case_108___0: /* CIL Label */ 
    return (1);
    switch_default___1: /* CIL Label */ 
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
  } else {
    return (0);
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
}
}
int test_unop(char *op ) 
{ 


  {
  if ((int )*(op + 0) != 45) {
    return (0);
  }
  {
  if ((int )*(op + 1) == 97) {
    goto case_97;
  }
  if ((int )*(op + 1) == 98) {
    goto case_97;
  }
  if ((int )*(op + 1) == 99) {
    goto case_97;
  }
  if ((int )*(op + 1) == 100) {
    goto case_97;
  }
  if ((int )*(op + 1) == 101) {
    goto case_97;
  }
  if ((int )*(op + 1) == 102) {
    goto case_97;
  }
  if ((int )*(op + 1) == 103) {
    goto case_97;
  }
  if ((int )*(op + 1) == 104) {
    goto case_97;
  }
  if ((int )*(op + 1) == 107) {
    goto case_97;
  }
  if ((int )*(op + 1) == 110) {
    goto case_97;
  }
  if ((int )*(op + 1) == 111) {
    goto case_97;
  }
  if ((int )*(op + 1) == 112) {
    goto case_97;
  }
  if ((int )*(op + 1) == 114) {
    goto case_97;
  }
  if ((int )*(op + 1) == 115) {
    goto case_97;
  }
  if ((int )*(op + 1) == 116) {
    goto case_97;
  }
  if ((int )*(op + 1) == 117) {
    goto case_97;
  }
  if ((int )*(op + 1) == 119) {
    goto case_97;
  }
  if ((int )*(op + 1) == 120) {
    goto case_97;
  }
  if ((int )*(op + 1) == 122) {
    goto case_97;
  }
  if ((int )*(op + 1) == 71) {
    goto case_97;
  }
  if ((int )*(op + 1) == 76) {
    goto case_97;
  }
  if ((int )*(op + 1) == 79) {
    goto case_97;
  }
  if ((int )*(op + 1) == 83) {
    goto case_97;
  }
  if ((int )*(op + 1) == 78) {
    goto case_97;
  }
  goto switch_break;
  case_97: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_78: /* CIL Label */ 
  return (1);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int two_arguments(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int )*(*(argv + pos) + 0) == 33) {
    if ((int )*(*(argv + pos) + 1) == 0) {
      return ((int )*(*(argv + (pos + 1)) + 0) == 0);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(*(argv + pos) + 0) == 45) {
    if ((int )*(*(argv + pos) + 2) == 0) {
      {
      tmp___0 = test_unop(*(argv + pos));
      }
      if (tmp___0) {
        {
        tmp = unary_operator();
        }
        return (tmp);
      } else {
        {
        test_syntax_error((char *)"%s: unary operator expected", *(argv + pos));
        }
      }
    } else {
      {
      test_syntax_error((char *)"%s: unary operator expected", *(argv + pos));
      }
    }
  } else {
    {
    test_syntax_error((char *)"%s: unary operator expected", *(argv + pos));
    }
  }
  }
  return (0);
}
}
static int three_arguments(void) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp___3 = test_binop(*(argv + (pos + 1)));
  }
  if (tmp___3) {
    {
    value = binary_operator();
    pos = argc;
    }
  } else { //Added block
  if ((int )*(*(argv + (pos + 1)) + 0) == 45) {
    if (! *(*(argv + (pos + 1)) + 2)) {
      if ((int )*(*(argv + (pos + 1)) + 1) == 97) {
        goto _L___1;
      } else { //Added block
      if ((int )*(*(argv + (pos + 1)) + 1) == 111) {
        _L___1: 
        if ((int )*(*(argv + (pos + 1)) + 1) == 97) {
          if ((int )*(*(argv + pos) + 0) != 0) {
            if ((int )*(*(argv + (pos + 2)) + 0) != 0) {
              tmp = 1;
            } else {
              tmp = 0;
            }
          } else {
            tmp = 0;
          }
          value = tmp;
        } else {
          if ((int )*(*(argv + pos) + 0) != 0) {
            tmp___0 = 1;
          } else { //Added block
          if ((int )*(*(argv + (pos + 2)) + 0) != 0) {
            tmp___0 = 1;
          } else {
            tmp___0 = 0;
          }
          }
          value = tmp___0;
        }
        pos = argc;
      } else {
        goto _L___2;
      }
      }
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if ((int )*(*(argv + pos) + 0) == 33) {
    if ((int )*(*(argv + pos) + 1) == 0) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        pos ++;
        if (pos >= argc) {
          {
          beyond();
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
      tmp___1 = two_arguments();
      }
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      value = tmp___2;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(*(argv + pos) + 0) == 40) {
    if ((int )*(*(argv + (pos + 2)) + 0) == 41) {
      value = (int )*(*(argv + (pos + 1)) + 0) != 0;
      pos = argc;
    } else {
      {
      test_syntax_error((char *)"%s: binary operator expected", *(argv + (pos + 1)));
      }
    }
  } else {
    {
    test_syntax_error((char *)"%s: binary operator expected", *(argv + (pos + 1)));
    }
  }
  }
  }
  }
  return (value);
}
}
static int posixtest(void) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;

  {
  {
  if (argc - 1 == 0) {
    goto case_0;
  }
  if (argc - 1 == 1) {
    goto case_1;
  }
  if (argc - 1 == 2) {
    goto case_2;
  }
  if (argc - 1 == 3) {
    goto case_3;
  }
  if (argc - 1 == 4) {
    goto case_4;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  value = 0;
  pos = argc;
  goto switch_break;
  case_1: /* CIL Label */ 
  value = (int )*(*(argv + 1) + 0) != 0;
  pos = argc;
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  value = two_arguments();
  pos = argc;
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  value = three_arguments();
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  if ((int )*(*(argv + pos) + 0) == 33) {
    if ((int )*(*(argv + pos) + 1) == 0) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        pos ++;
        if (pos >= argc) {
          {
          beyond();
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
      tmp = three_arguments();
      }
      if (tmp) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      value = tmp___0;
      goto switch_break;
    }
  }
  switch_default: /* CIL Label */ 
  {
  value = expr();
  }
  switch_break: /* CIL Label */ ;
  }
  return (value);
}
}
int test_command(int margc , char **margv ) 
{ 
  int value ;
  int code ;

  {
  {
  code = __sigsetjmp(test_exit_buf, 1);
  }
  if (code) {
    return (test_error_return);
  }
  argv = margv;
  if (*(margv + 0)) {
    if ((int )*(*(margv + 0) + 0) == 91) {
      if ((int )*(*(margv + 0) + 1) == 0) {
        margc --;
        if (*(margv + margc)) {
          if ((int )*(*(margv + margc) + 0) != 93) {
            {
            test_syntax_error((char *)"missing `]\'", (char *)((void *)0));
            }
          } else { //Added block
          if (*(*(margv + margc) + 1)) {
            {
            test_syntax_error((char *)"missing `]\'", (char *)((void *)0));
            }
          }
          }
        }
        if (margc < 2) {
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            {
            test_error_return = 1;
            siglongjmp(test_exit_buf, 1);
            }
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  argc = margc;
  pos = 1;
  if (pos >= argc) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      test_error_return = 1;
      siglongjmp(test_exit_buf, 1);
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  noeval___0 = 0;
  value = posixtest();
  }
  if (pos != argc) {
    {
    test_syntax_error((char *)"too many arguments", (char *)((void *)0));
    }
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    test_error_return = ! value;
    siglongjmp(test_exit_buf, 1);
    }
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-M98bTYTZ.i","-g")
char *dist_version  =    (char *)"2.05";
int patch_level  =    0;
int build_version  =    1;
char *release_status  =    (char *)"release";
char *sccs_version  =    (char *)"@(#)Bash version 2.05.0(1) release GNU";
static char tt[32]  = {      (char )'\000'};
char *shell_version_string(void) 
{ 


  {
  if ((int )tt[0] == 0) {
    if (release_status) {
      {
      sprintf((char * __restrict  )(tt), (char const   * __restrict  )"%s.%d(%d)-%s",
              dist_version, patch_level, build_version, release_status);
      }
    } else {
      {
      sprintf((char * __restrict  )(tt), (char const   * __restrict  )"%s.%d(%d)",
              dist_version, patch_level, build_version);
      }
    }
  }
  return (tt);
}
}
void show_shell_version(int extended ) 
{ 
  char *tmp ;

  {
  {
  tmp = shell_version_string();
  printf((char const   * __restrict  )"GNU bash, version %s (%s)\n", tmp, "");
  }
  if (extended) {
    {
    printf((char const   * __restrict  )"Copyright 2000 Free Software Foundation, Inc.\n");
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-WJiMwpTC.i","-g")
HASH_TABLE *aliases ;
void initialize_aliases(void) ;
char *get_alias_value(char *name ) ;
void add_alias(char *name , char *value ) ;
int remove_alias(char *name ) ;
char *alias_expand(char *string ) ;
alias_t **all_aliases(void) ;
char *alias_expand_word(char *s ) ;
ITEMLIST it_aliases ;
static int qsort_alias_compare(alias_t **as1 , alias_t **as2 ) ;
int alias_expand_all  =    0;
HASH_TABLE *aliases  =    (HASH_TABLE *)((void *)0);
void initialize_aliases(void) 
{ 


  {
  if (! aliases) {
    {
    aliases = make_hash_table(0);
    }
  }
  return;
}
}
alias_t *find_alias(char *name ) 
{ 
  BUCKET_CONTENTS *al ;
  alias_t *tmp ;

  {
  if ((unsigned long )aliases == (unsigned long )((HASH_TABLE *)0)) {
    return ((alias_t *)((void *)0));
  }
  {
  al = find_hash_item(name, aliases);
  }
  if (al) {
    tmp = (alias_t *)al->data;
  } else {
    tmp = (alias_t *)((void *)0);
  }
  return (tmp);
}
}
char *get_alias_value(char *name ) 
{ 
  alias_t *alias ;
  char *tmp ;

  {
  if ((unsigned long )aliases == (unsigned long )((HASH_TABLE *)0)) {
    return ((char *)((void *)0));
  }
  {
  alias = find_alias(name);
  }
  if (alias) {
    tmp = alias->value;
  } else {
    tmp = (char *)((void *)0);
  }
  return (tmp);
}
}
void add_alias(char *name , char *value ) 
{ 
  BUCKET_CONTENTS *elt ;
  alias_t *temp___0 ;
  int n ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  if (! aliases) {
    {
    initialize_aliases();
    temp___0 = (alias_t *)((void *)0);
    }
  } else {
    {
    temp___0 = find_alias(name);
    }
  }
  if (temp___0) {
    {
    free((void *)temp___0->value);
    tmp = strlen((char const   *)value);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )value);
    temp___0->value = tmp___1;
    tmp___2 = strlen((char const   *)value);
    n = (int )*(value + (tmp___2 - 1UL));
    }
    if (n == 32) {
      temp___0->flags = (char )((int )temp___0->flags | 1);
    } else { //Added block
    if (n == 9) {
      temp___0->flags = (char )((int )temp___0->flags | 1);
    }
    }
  } else {
    {
    tmp___3 = xmalloc(sizeof(alias_t ));
    temp___0 = (alias_t *)tmp___3;
    tmp___4 = strlen((char const   *)name);
    tmp___5 = xmalloc(1UL + tmp___4);
    tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )name);
    temp___0->name = tmp___6;
    tmp___7 = strlen((char const   *)value);
    tmp___8 = xmalloc(1UL + tmp___7);
    tmp___9 = strcpy((char * __restrict  )tmp___8, (char const   * __restrict  )value);
    temp___0->value = tmp___9;
    temp___0->flags = (char)0;
    tmp___10 = strlen((char const   *)value);
    n = (int )*(value + (tmp___10 - 1UL));
    }
    if (n == 32) {
      temp___0->flags = (char )((int )temp___0->flags | 1);
    } else { //Added block
    if (n == 9) {
      temp___0->flags = (char )((int )temp___0->flags | 1);
    }
    }
    {
    tmp___11 = strlen((char const   *)name);
    tmp___12 = xmalloc(1UL + tmp___11);
    tmp___13 = strcpy((char * __restrict  )tmp___12, (char const   * __restrict  )name);
    elt = add_hash_item(tmp___13, aliases);
    elt->data = (char *)temp___0;
    set_itemlist_dirty(& it_aliases);
    }
  }
  return;
}
}
static void free_alias_data(char *data ) 
{ 
  register alias_t *a ;

  {
  {
  a = (alias_t *)data;
  free((void *)a->value);
  free((void *)a->name);
  free((void *)data);
  }
  return;
}
}
int remove_alias(char *name ) 
{ 
  BUCKET_CONTENTS *elt ;

  {
  if ((unsigned long )aliases == (unsigned long )((HASH_TABLE *)0)) {
    return (-1);
  }
  {
  elt = remove_hash_item(name, aliases);
  }
  if (elt) {
    {
    free_alias_data(elt->data);
    free((void *)elt->key);
    free((void *)elt);
    set_itemlist_dirty(& it_aliases);
    }
    return (aliases->nentries);
  }
  return (-1);
}
}
void delete_all_aliases(void) 
{ 


  {
  if ((unsigned long )aliases == (unsigned long )((HASH_TABLE *)0)) {
    return;
  }
  {
  flush_hash_table(aliases, (VFunction *)(& free_alias_data));
  dispose_hash_table(aliases);
  aliases = (HASH_TABLE *)((void *)0);
  set_itemlist_dirty(& it_aliases);
  }
  return;
}
}
static alias_t **map_over_aliases(Function *function ) 
{ 
  register int i ;
  register BUCKET_CONTENTS *tlist ;
  alias_t *alias ;
  alias_t **list___0 ;
  int list_index___0 ;
  int list_size ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  list___0 = (alias_t **)((void *)0);
  list_size = 0;
  list_index___0 = list_size;
  i = list_index___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < aliases->nbuckets)) {
      goto while_break;
    }
    if (aliases) {
      if (i < aliases->nbuckets) {
        tlist = *(aliases->bucket_array + i);
      } else {
        tlist = (BUCKET_CONTENTS *)((void *)0);
      }
    } else {
      tlist = (BUCKET_CONTENTS *)((void *)0);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! tlist) {
        goto while_break___0;
      }
      alias = (alias_t *)tlist->data;
      if (! function) {
        goto _L;
      } else {
        {
        tmp___1 = (*function)(alias);
        }
        if (tmp___1) {
          _L: 
          if (list_index___0 + 1 >= list_size) {
            {
            list_size += 20;
            tmp = xrealloc((void *)((char *)list___0), (unsigned long )list_size * sizeof(alias_t *));
            list___0 = (alias_t **)tmp;
            }
          }
          tmp___0 = list_index___0;
          list_index___0 ++;
          *(list___0 + tmp___0) = alias;
          *(list___0 + list_index___0) = (alias_t *)((void *)0);
        }
      }
      tlist = tlist->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (list___0);
}
}
static void sort_aliases(alias_t **array ) 
{ 
  int tmp ;

  {
  {
  tmp = array_len((char **)array);
  qsort((void *)array, (size_t )tmp, sizeof(alias_t *), (int (*)(void const   * ,
                                                                 void const   * ))(& qsort_alias_compare));
  }
  return;
}
}
static int qsort_alias_compare(alias_t **as1 , alias_t **as2 ) 
{ 
  int result ;

  {
  result = (int )*((*as1)->name + 0) - (int )*((*as2)->name + 0);
  if (result == 0) {
    {
    result = strcmp((char const   *)(*as1)->name, (char const   *)(*as2)->name);
    }
  }
  return (result);
}
}
alias_t **all_aliases(void) 
{ 
  alias_t **list___0 ;

  {
  if (! aliases) {
    return ((alias_t **)((void *)0));
  }
  {
  list___0 = map_over_aliases((Function *)((void *)0));
  }
  if (list___0) {
    {
    sort_aliases(list___0);
    }
  }
  return (list___0);
}
}
char *alias_expand_word(char *s ) 
{ 
  alias_t *r ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  r = find_alias(s);
  }
  if (r) {
    {
    tmp = strlen((char const   *)r->value);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )r->value);
    tmp___2 = tmp___1;
    }
  } else {
    tmp___2 = (char *)((void *)0);
  }
  return (tmp___2);
}
}
static int command_word  ;
static int skipquotes(char *string , int start ) 
{ 
  register int i ;
  int delimiter ;

  {
  delimiter = (int )*(string + start);
  i = start + 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(string + i)) {
      goto while_break;
    }
    if ((int )*(string + i) == 92) {
      i ++;
      goto __Cont;
    }
    if ((int )*(string + i) == delimiter) {
      return (i);
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (i);
}
}
static int skipws(char *string , int start ) 
{ 
  register int i ;
  int pass_next ;
  int backslash_quoted_word ;
  int peekc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  i = 0;
  pass_next = 0;
  backslash_quoted_word = pass_next;
  i = start;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(string + i)) {
      goto while_break;
    }
    if (pass_next) {
      pass_next = 0;
      goto __Cont;
    }
    if ((int )*(string + i) == 32) {
      backslash_quoted_word = 0;
      goto __Cont;
    } else { //Added block
    if ((int )*(string + i) == 9) {
      backslash_quoted_word = 0;
      goto __Cont;
    }
    }
    if ((int )*(string + i) == 92) {
      {
      peekc = (int )*(string + (i + 1));
      tmp = isalpha(peekc);
      }
      if (tmp) {
        backslash_quoted_word ++;
      } else {
        pass_next ++;
      }
      goto __Cont;
    }
    if ((int )*(string + i) == 39) {
      goto _L;
    } else { //Added block
    if ((int )*(string + i) == 34) {
      _L: 
      {
      i = skipquotes(string, i);
      }
      if ((int )*(string + i) == 0) {
        goto while_break;
      }
      {
      peekc = (int )*(string + (i + 1));
      tmp___0 = isalpha(peekc);
      }
      if (tmp___0) {
        backslash_quoted_word ++;
      }
      goto __Cont;
    }
    }
    if (backslash_quoted_word) {
      goto __Cont;
    }
    if (*(string + i)) {
      {
      tmp___1 = strchr("\r\n;|&(", (int )*(string + i));
      tmp___2 = (unsigned long )tmp___1 != (unsigned long )((char *)((void *)0));
      }
    } else {
      tmp___2 = 0;
    }
    if (tmp___2) {
      command_word ++;
      goto __Cont;
    }
    goto while_break;
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (i);
}
}
static int rd_token(char *string , int start ) 
{ 
  register int i ;
  char *tmp ;
  int tmp___0 ;

  {
  i = start;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(string + i)) {
      if ((int )*(string + i) == 32) {
        goto while_break;
      } else { //Added block
      if ((int )*(string + i) == 9) {
        goto while_break;
      } else {
        if (*(string + i)) {
          {
          tmp = strchr(" \t\n\r;|&()", (int )*(string + i));
          tmp___0 = (unsigned long )tmp != (unsigned long )((char *)((void *)0));
          }
        } else {
          tmp___0 = 0;
        }
        if (tmp___0) {
          goto while_break;
        }
      }
      }
    } else {
      goto while_break;
    }
    if ((int )*(string + i) == 92) {
      i ++;
      goto __Cont;
    }
    if ((int )*(string + i) == 39) {
      goto _L;
    } else { //Added block
    if ((int )*(string + i) == 34) {
      _L: 
      {
      i = skipquotes(string, i);
      }
      if ((int )*(string + i) == 0) {
        goto while_break;
      }
      goto __Cont;
    }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (i);
}
}
char *alias_expand(char *string ) 
{ 
  register int i ;
  register int j ;
  register int start ;
  char *line ;
  char *token___0 ;
  int line_len ;
  int tl ;
  int real_start ;
  int expand_next ;
  int expand_this_token ;
  alias_t *alias ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *v___0 ;
  int vlen ;
  int llen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int llen___0 ;
  int tlen ;
  size_t tmp___8 ;

  {
  {
  tmp = strlen((char const   *)string);
  line_len = (int )(tmp + 1UL);
  line = xmalloc((size_t )line_len);
  token___0 = xmalloc((size_t )line_len);
  i = 0;
  *(line + 0) = (char )i;
  expand_next = 0;
  command_word = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    *(token___0 + 0) = (char)0;
    start = i;
    i = skipws(string, start);
    }
    if (start == i) {
      if ((int )*(string + i) == 0) {
        {
        free((void *)token___0);
        }
        return (line);
      }
    }
    {
    tmp___0 = strlen((char const   *)line);
    j = (int )tmp___0;
    tl = i - start;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (j + (tl + 1) >= line_len) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (j + (tl + 1) >= line_len)) {
            goto while_break___1;
          }
          line_len += tl + 50;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        line = xrealloc((void *)line, (size_t )line_len);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    strncpy((char * __restrict  )(line + j), (char const   * __restrict  )(string + start),
            (size_t )tl);
    *(line + (j + tl)) = (char )'\000';
    real_start = i;
    }
    if (command_word) {
      tmp___3 = 1;
    } else {
      if (*(string + i)) {
        {
        tmp___1 = strchr("\r\n;|&(", (int )*(string + i));
        tmp___2 = (unsigned long )tmp___1 != (unsigned long )((char *)((void *)0));
        }
      } else {
        tmp___2 = 0;
      }
      if (tmp___2) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
    }
    command_word = tmp___3;
    if (command_word) {
      tmp___4 = 1;
    } else { //Added block
    if (expand_next) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
    }
    {
    expand_this_token = tmp___4;
    expand_next = 0;
    start = i;
    i = rd_token(string, start);
    tl = i - start;
    }
    if (tl == 0) {
      if ((int )*(string + i) != 0) {
        tl = 1;
        i ++;
      }
    }
    {
    strncpy((char * __restrict  )token___0, (char const   * __restrict  )(string + start),
            (size_t )tl);
    *(token___0 + tl) = (char )'\000';
    tmp___5 = strchr((char const   *)token___0, '\\');
    }
    if (tmp___5) {
      expand_this_token = 0;
    }
    if (*(token___0 + 0)) {
      if (expand_this_token) {
        goto _L___3;
      } else { //Added block
      if (alias_expand_all) {
        _L___3: 
        {
        alias = find_alias(token___0);
        }
        if (alias) {
          {
          v___0 = alias->value;
          tmp___6 = strlen((char const   *)v___0);
          vlen = (int )tmp___6;
          tmp___7 = strlen((char const   *)line);
          llen = (int )tmp___7;
          }
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (llen + (vlen + 3) >= line_len) {
              {
              while (1) {
                while_continue___3: /* CIL Label */ ;
                if (! (llen + (vlen + 3) >= line_len)) {
                  goto while_break___3;
                }
                line_len += vlen + 50;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
              line = xrealloc((void *)line, (size_t )line_len);
              }
            }
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
          strcpy((char * __restrict  )(line + llen), (char const   * __restrict  )v___0);
          }
          if (expand_this_token) {
            if (vlen) {
              if ((int )*(v___0 + (vlen - 1)) == 32) {
                expand_next = 1;
              } else { //Added block
              if ((int )*(v___0 + (vlen - 1)) == 9) {
                expand_next = 1;
              } else {
                goto _L___0;
              }
              }
            } else {
              goto _L___0;
            }
          } else { //Added block
          _L___0: 
          if (alias_expand_all) {
            expand_next = 1;
          }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
      }
    } else {
      _L___2: 
      {
      tmp___8 = strlen((char const   *)line);
      llen___0 = (int )tmp___8;
      tlen = i - real_start;
      }
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (llen___0 + (tlen + 1) >= line_len) {
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (! (llen___0 + (tlen + 1) >= line_len)) {
              goto while_break___5;
            }
            line_len += (llen___0 + tlen) + 50;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
          line = xrealloc((void *)line, (size_t )line_len);
          }
        }
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      strncpy((char * __restrict  )(line + llen___0), (char const   * __restrict  )(string + real_start),
              (size_t )tlen);
      *(line + (llen___0 + tlen)) = (char )'\000';
      }
    }
    command_word = 0;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#pragma merger("0","/tmp/cil-j0Tjc4TE.i","-g")
ARRAY_ELEMENT *new_array_element(arrayind_t indx , char *value ) ;
ARRAY *dup_array(ARRAY *a ) ;
ARRAY *assign_word_list(ARRAY *array , WORD_LIST *list___0 ) ;
char **array_to_argv(ARRAY *a ) ;
char *array_to_string(ARRAY *a , char *sep , int quoted ) ;
ARRAY *array_quote(ARRAY *array ) ;
extern char *sh_double_quote(char * ) ;
ARRAY_ELEMENT *new_array_element(arrayind_t indx , char *value ) 
{ 
  ARRAY_ELEMENT *r ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct array_element *tmp___3 ;

  {
  {
  tmp = xmalloc(sizeof(ARRAY_ELEMENT ));
  r = (ARRAY_ELEMENT *)tmp;
  r->ind = indx;
  }
  if (value) {
    {
    tmp___0 = strlen((char const   *)value);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )value);
    r->value = tmp___2;
    }
  } else {
    r->value = (char *)((void *)0);
  }
  tmp___3 = (ARRAY_ELEMENT *)((void *)0);
  r->prev = tmp___3;
  r->next = tmp___3;
  return (r);
}
}
void destroy_array_element(ARRAY_ELEMENT *ae ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (ae->value) {
      {
      free((void *)ae->value);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)ae);
  }
  return;
}
}
ARRAY *new_array(void) 
{ 
  ARRAY *r ;
  ARRAY_ELEMENT *head ;
  char *tmp ;
  arrayind_t tmp___0 ;
  struct array_element *tmp___1 ;

  {
  {
  tmp = xmalloc(sizeof(ARRAY ));
  r = (ARRAY *)tmp;
  r->type = (enum atype )0;
  tmp___0 = -1;
  r->max_size = tmp___0;
  r->max_index = tmp___0;
  r->num_elements = 0;
  head = new_array_element(-1, (char *)((void *)0));
  tmp___1 = head;
  head->next = tmp___1;
  head->prev = tmp___1;
  r->head = head;
  }
  return (r);
}
}
void empty_array(ARRAY *a ) 
{ 
  register ARRAY_ELEMENT *r ;
  register ARRAY_ELEMENT *r1 ;
  struct array_element *tmp ;
  arrayind_t tmp___0 ;
  arrayind_t tmp___1 ;

  {
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    return;
  }
  r = (a->head)->next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )r != (unsigned long )a->head)) {
      goto while_break;
    }
    {
    r1 = r->next;
    destroy_array_element(r);
    r = r1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  tmp = a->head;
  (a->head)->prev = tmp;
  (a->head)->next = tmp;
  tmp___0 = -1;
  a->max_size = tmp___0;
  a->max_index = tmp___0;
  tmp___1 = 0;
  a->max_size = tmp___1;
  a->num_elements = tmp___1;
  return;
}
}
void dispose_array(ARRAY *a ) 
{ 


  {
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    return;
  }
  {
  empty_array(a);
  destroy_array_element(a->head);
  free((void *)a);
  }
  return;
}
}
ARRAY *dup_array(ARRAY *a ) 
{ 
  ARRAY *a1 ;
  ARRAY_ELEMENT *ae ;
  ARRAY_ELEMENT *new ;

  {
  if (! a) {
    return ((ARRAY *)((void *)0));
  }
  {
  a1 = new_array();
  a1->type = a->type;
  a1->max_index = a->max_index;
  a1->num_elements = a->num_elements;
  a1->max_size = a->max_size;
  ae = (a->head)->next;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )a->head)) {
      goto while_break;
    }
    {
    new = new_array_element(ae->ind, ae->value);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      ((a1->head)->prev)->next = new;
      new->prev = (a1->head)->prev;
      (a1->head)->prev = new;
      new->next = a1->head;
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    ae = ae->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (a1);
}
}
int array_add_element(ARRAY *a , arrayind_t i , char *v___0 ) 
{ 
  register ARRAY_ELEMENT *new ;
  register ARRAY_ELEMENT *ae ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (! a) {
    return (-1);
  }
  {
  new = new_array_element(i, v___0);
  }
  if (i > a->max_index) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      ((a->head)->prev)->next = new;
      new->prev = (a->head)->prev;
      (a->head)->prev = new;
      new->next = a->head;
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    a->max_index = i;
    (a->num_elements) ++;
    return (0);
  }
  ae = (a->head)->next;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )a->head)) {
      goto while_break___0;
    }
    if (ae->ind == i) {
      {
      destroy_array_element(new);
      free((void *)ae->value);
      tmp = strlen((char const   *)v___0);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )v___0);
      ae->value = tmp___1;
      }
      return (0);
    } else { //Added block
    if (ae->ind > i) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        (ae->prev)->next = new;
        new->prev = ae->prev;
        ae->prev = new;
        new->next = ae;
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      (a->num_elements) ++;
      return (0);
    }
    }
    ae = ae->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (-1);
}
}
ARRAY_ELEMENT *array_delete_element(ARRAY *a , arrayind_t i ) 
{ 
  register ARRAY_ELEMENT *ae ;

  {
  if (! a) {
    return ((ARRAY_ELEMENT *)((void *)0));
  } else { //Added block
  if (a->num_elements == 0) {
    return ((ARRAY_ELEMENT *)((void *)0));
  }
  }
  ae = (a->head)->next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )a->head)) {
      goto while_break;
    }
    if (ae->ind == i) {
      (ae->next)->prev = ae->prev;
      (ae->prev)->next = ae->next;
      (a->num_elements) --;
      if (i == a->max_index) {
        a->max_index = (ae->prev)->ind;
      }
      return (ae);
    }
    ae = ae->next;
  }
  while_break: /* CIL Label */ ;
  }
  return ((ARRAY_ELEMENT *)((void *)0));
}
}
char *array_reference(ARRAY *a , arrayind_t i ) 
{ 
  register ARRAY_ELEMENT *ae ;

  {
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    return ((char *)((void *)0));
  } else { //Added block
  if (a->num_elements == 0) {
    return ((char *)((void *)0));
  }
  }
  ae = (a->head)->next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )a->head)) {
      goto while_break;
    }
    if (ae->ind == i) {
      return (ae->value);
    }
    ae = ae->next;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char *)((void *)0));
}
}
static char *array_to_string_internal(ARRAY_ELEMENT *start , ARRAY_ELEMENT *end ,
                                      char *sep , int quoted ) 
{ 
  char *result ;
  char *t ;
  ARRAY_ELEMENT *ae ;
  int slen ;
  int rsize ;
  int rlen ;
  int reg ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  if ((unsigned long )start == (unsigned long )end) {
    return ((char *)((void *)0));
  }
  {
  tmp = strlen((char const   *)sep);
  slen = (int )tmp;
  rlen = 0;
  rsize = rlen;
  ae = start;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )end)) {
      goto while_break;
    }
    if (rsize == 0) {
      {
      rsize = 64;
      result = xmalloc((size_t )rsize);
      }
    }
    if (ae->value) {
      if (quoted) {
        {
        tmp___0 = quote_string(ae->value);
        t = tmp___0;
        }
      } else {
        t = ae->value;
      }
      {
      tmp___1 = strlen((char const   *)t);
      reg = (int )tmp___1;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (rlen + ((reg + slen) + 2) >= rsize) {
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (rlen + ((reg + slen) + 2) >= rsize)) {
              goto while_break___1;
            }
            rsize += rsize;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
          result = xrealloc((void *)result, (size_t )rsize);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      strcpy((char * __restrict  )(result + rlen), (char const   * __restrict  )t);
      rlen += reg;
      }
      if (quoted) {
        if (t) {
          {
          free((void *)t);
          }
        }
      }
      if ((unsigned long )ae->next != (unsigned long )end) {
        {
        strcpy((char * __restrict  )(result + rlen), (char const   * __restrict  )sep);
        rlen += slen;
        }
      }
    }
    ae = ae->next;
  }
  while_break: /* CIL Label */ ;
  }
  *(result + rlen) = (char )'\000';
  return (result);
}
}
char *array_to_string(ARRAY *a , char *sep , int quoted ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    return ((char *)((void *)0));
  }
  if (a->num_elements == 0) {
    {
    tmp = strlen("");
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )"");
    }
    return (tmp___1);
  }
  {
  tmp___2 = array_to_string_internal((a->head)->next, a->head, sep, quoted);
  }
  return (tmp___2);
}
}
char *array_to_assignment_string(ARRAY *a ) 
{ 
  char *result ;
  char *indstr ;
  char *valstr ;
  ARRAY_ELEMENT *ae ;
  int rsize ;
  int rlen ;
  int elen ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    return ((char *)((void *)0));
  } else { //Added block
  if (a->num_elements == 0) {
    return ((char *)((void *)0));
  }
  }
  {
  rsize = 128;
  result = xmalloc((size_t )rsize);
  *(result + 0) = (char )'(';
  rlen = 1;
  ae = (a->head)->next;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )a->head)) {
      goto while_break;
    }
    {
    indstr = itos(ae->ind);
    }
    if (ae->value) {
      {
      tmp = sh_double_quote(ae->value);
      valstr = tmp;
      }
    } else {
      valstr = (char *)((void *)0);
    }
    if (indstr) {
      if (*(indstr + 0)) {
        if (*(indstr + 1)) {
          if (*(indstr + 2)) {
            {
            tmp___0 = strlen((char const   *)indstr);
            tmp___1 = tmp___0;
            }
          } else {
            tmp___1 = (size_t )2;
          }
          tmp___2 = tmp___1;
        } else {
          tmp___2 = (size_t )1;
        }
        tmp___3 = tmp___2;
      } else {
        tmp___3 = (size_t )0;
      }
    } else {
      tmp___3 = (size_t )0;
    }
    if (valstr) {
      if (*(valstr + 0)) {
        if (*(valstr + 1)) {
          if (*(valstr + 2)) {
            {
            tmp___4 = strlen((char const   *)valstr);
            tmp___5 = tmp___4;
            }
          } else {
            tmp___5 = (size_t )2;
          }
          tmp___6 = tmp___5;
        } else {
          tmp___6 = (size_t )1;
        }
        tmp___7 = tmp___6;
      } else {
        tmp___7 = (size_t )0;
      }
    } else {
      tmp___7 = (size_t )0;
    }
    elen = (int )((tmp___3 + 8UL) + tmp___7);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (rlen + (elen + 1) >= rsize) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (rlen + (elen + 1) >= rsize)) {
            goto while_break___1;
          }
          rsize += rsize;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        result = xrealloc((void *)result, (size_t )rsize);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    tmp___8 = rlen;
    rlen ++;
    *(result + tmp___8) = (char )'[';
    strcpy((char * __restrict  )(result + rlen), (char const   * __restrict  )indstr);
    }
    if (indstr) {
      if (*(indstr + 0)) {
        if (*(indstr + 1)) {
          if (*(indstr + 2)) {
            {
            tmp___9 = strlen((char const   *)indstr);
            tmp___10 = tmp___9;
            }
          } else {
            tmp___10 = (size_t )2;
          }
          tmp___11 = tmp___10;
        } else {
          tmp___11 = (size_t )1;
        }
        tmp___12 = tmp___11;
      } else {
        tmp___12 = (size_t )0;
      }
    } else {
      tmp___12 = (size_t )0;
    }
    rlen = (int )((size_t )rlen + tmp___12);
    tmp___13 = rlen;
    rlen ++;
    *(result + tmp___13) = (char )']';
    tmp___14 = rlen;
    rlen ++;
    *(result + tmp___14) = (char )'=';
    if (valstr) {
      {
      strcpy((char * __restrict  )(result + rlen), (char const   * __restrict  )valstr);
      }
      if (valstr) {
        if (*(valstr + 0)) {
          if (*(valstr + 1)) {
            if (*(valstr + 2)) {
              {
              tmp___15 = strlen((char const   *)valstr);
              tmp___16 = tmp___15;
              }
            } else {
              tmp___16 = (size_t )2;
            }
            tmp___17 = tmp___16;
          } else {
            tmp___17 = (size_t )1;
          }
          tmp___18 = tmp___17;
        } else {
          tmp___18 = (size_t )0;
        }
      } else {
        tmp___18 = (size_t )0;
      }
      rlen = (int )((size_t )rlen + tmp___18);
    }
    if ((unsigned long )ae->next != (unsigned long )a->head) {
      tmp___19 = rlen;
      rlen ++;
      *(result + tmp___19) = (char )' ';
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (indstr) {
        {
        free((void *)indstr);
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (valstr) {
        {
        free((void *)valstr);
        }
      }
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    ae = ae->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    if (rlen + 1 >= rsize) {
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! (rlen + 1 >= rsize)) {
          goto while_break___5;
        }
        rsize += 8;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
      result = xrealloc((void *)result, (size_t )rsize);
      }
    }
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  tmp___20 = rlen;
  rlen ++;
  *(result + tmp___20) = (char )')';
  *(result + rlen) = (char )'\000';
  return (result);
}
}
char *quoted_array_assignment_string(ARRAY *a ) 
{ 
  char *vstr ;
  char *sv ;

  {
  {
  sv = array_to_assignment_string(a);
  }
  if ((unsigned long )sv == (unsigned long )((char *)0)) {
    return ((char *)((void *)0));
  }
  {
  vstr = sh_single_quote(sv);
  free((void *)sv);
  }
  return (vstr);
}
}
WORD_LIST *array_to_word_list(ARRAY *a ) 
{ 
  WORD_LIST *list___0 ;
  ARRAY_ELEMENT *ae ;
  WORD_DESC *tmp ;
  GENERIC_LIST *tmp___0 ;
  WORD_LIST *tmp___1 ;

  {
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if (a->num_elements == 0) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  list___0 = (WORD_LIST *)((void *)0);
  ae = (a->head)->next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )a->head)) {
      goto while_break;
    }
    {
    tmp = make_bare_word(ae->value);
    list___0 = make_word_list(tmp, list___0);
    ae = ae->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (list___0) {
    if (list___0->next) {
      {
      tmp___0 = reverse_list((GENERIC_LIST *)list___0);
      tmp___1 = (WORD_LIST *)tmp___0;
      }
    } else {
      tmp___1 = list___0;
    }
  } else {
    tmp___1 = list___0;
  }
  return (tmp___1);
}
}
char **array_to_argv(ARRAY *a ) 
{ 
  char **ret ;
  char *t ;
  int i ;
  ARRAY_ELEMENT *ae ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    return ((char **)((void *)0));
  } else { //Added block
  if (a->num_elements == 0) {
    return ((char **)((void *)0));
  }
  }
  {
  ret = alloc_array(a->num_elements + 1);
  i = 0;
  ae = (a->head)->next;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ae != (unsigned long )a->head)) {
      goto while_break;
    }
    t = ae->value;
    tmp = i;
    i ++;
    if (t) {
      {
      tmp___0 = strlen((char const   *)t);
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )t);
      *(ret + tmp) = tmp___2;
      }
    } else {
      *(ret + tmp) = (char *)((void *)0);
    }
    ae = ae->next;
  }
  while_break: /* CIL Label */ ;
  }
  *(ret + i) = (char *)((void *)0);
  return (ret);
}
}
ARRAY *assign_word_list(ARRAY *array , WORD_LIST *list___0 ) 
{ 
  register WORD_LIST *l ;
  register arrayind_t i ;

  {
  l = list___0;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! l) {
      goto while_break;
    }
    {
    array_add_element(array, i, (l->word)->word);
    l = l->next;
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (array);
}
}
ARRAY *word_list_to_array(WORD_LIST *list___0 ) 
{ 
  ARRAY *a ;
  ARRAY *tmp ;

  {
  if ((unsigned long )list___0 == (unsigned long )((WORD_LIST *)0)) {
    return ((ARRAY *)((void *)0));
  }
  {
  a = new_array();
  tmp = assign_word_list(a, list___0);
  }
  return (tmp);
}
}
ARRAY *array_quote(ARRAY *array ) 
{ 
  ARRAY_ELEMENT *a ;
  char *t ;

  {
  if ((unsigned long )array == (unsigned long )((ARRAY *)0)) {
    return ((ARRAY *)((void *)0));
  } else { //Added block
  if ((unsigned long )array->head == (unsigned long )((struct array_element *)0)) {
    return ((ARRAY *)((void *)0));
  } else { //Added block
  if (array->num_elements == 0) {
    return ((ARRAY *)((void *)0));
  }
  }
  }
  a = (array->head)->next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )a != (unsigned long )array->head)) {
      goto while_break;
    }
    {
    t = quote_string(a->value);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (a->value) {
        {
        free((void *)a->value);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    a->value = t;
    a = a->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (array);
}
}
char *array_subrange(ARRAY *a , int start , int end , int quoted ) 
{ 
  ARRAY_ELEMENT *h ;
  ARRAY_ELEMENT *p ;
  int i ;
  char *tmp ;

  {
  p = a->head;
  if ((unsigned long )p == (unsigned long )((ARRAY_ELEMENT *)0)) {
    return ((char *)((void *)0));
  } else { //Added block
  if (a->num_elements == 0) {
    return ((char *)((void *)0));
  } else { //Added block
  if (start > a->num_elements) {
    return ((char *)((void *)0));
  }
  }
  }
  i = 0;
  p = p->next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )p != (unsigned long )a->head) {
      if (! (i < start)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    i ++;
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )p == (unsigned long )a->head) {
    return ((char *)((void *)0));
  }
  h = p;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if ((unsigned long )p != (unsigned long )a->head) {
      if (! (i < end)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    i ++;
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp = array_to_string_internal(h, p, (char *)" ", quoted);
  }
  return (tmp);
}
}
char *array_pat_subst(ARRAY *a , char *pat , char *rep , int mflags ) 
{ 
  ARRAY *a2 ;
  ARRAY_ELEMENT *e ;
  char *t ;

  {
  if ((unsigned long )a->head == (unsigned long )((struct array_element *)0)) {
    return ((char *)((void *)0));
  } else { //Added block
  if (a->num_elements == 0) {
    return ((char *)((void *)0));
  }
  }
  {
  a2 = dup_array(a);
  e = (a2->head)->next;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )e != (unsigned long )a2->head)) {
      goto while_break;
    }
    {
    t = pat_subst(e->value, pat, rep, mflags);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (e->value) {
        {
        free((void *)e->value);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    e->value = t;
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
  if (mflags & 32) {
    {
    array_quote(a2);
    }
  }
  {
  t = array_to_string(a2, (char *)" ", 0);
  dispose_array(a2);
  }
  return (t);
}
}
#pragma merger("0","/tmp/cil-sxJ2U48d.i","-g")
int brace_arg_separator  =    ',';
static int brace_gobbler(char *text___0 , int *indx , int satisfy ) ;
static char **expand_amble(char *text___0 ) ;
static char **array_concat(char **arr1 , char **arr2 ) ;
char **brace_expand(char *text___0 ) 
{ 
  register int start ;
  char *preamble ;
  char *postamble ;
  char *amble ;
  char **tack ;
  char **result ;
  int i ;
  int j ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
  i = 0;
  c = brace_gobbler(text___0, & i, '{');
  tmp = xmalloc((size_t )(i + 1));
  preamble = tmp;
  strncpy((char * __restrict  )preamble, (char const   * __restrict  )text___0, (size_t )i);
  *(preamble + i) = (char )'\000';
  tmp___0 = xmalloc(2UL * sizeof(char *));
  result = (char **)tmp___0;
  *(result + 0) = preamble;
  *(result + 1) = (char *)((void *)0);
  }
  if (c != 123) {
    return (result);
  }
  {
  i ++;
  start = i;
  c = brace_gobbler(text___0, & i, '}');
  }
  if (c == 0) {
    {
    free((void *)preamble);
    tmp___1 = strlen((char const   *)text___0);
    tmp___2 = xmalloc(1UL + tmp___1);
    tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )text___0);
    *(result + 0) = tmp___3;
    }
    return (result);
  }
  {
  amble = substring(text___0, start, i);
  j = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(amble + j)) {
      goto while_break;
    }
    if ((int )*(amble + j) == 92) {
      j ++;
      goto __Cont;
    }
    if ((int )*(amble + j) == brace_arg_separator) {
      goto while_break;
    }
    __Cont: 
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (! *(amble + j)) {
    {
    free((void *)amble);
    free((void *)preamble);
    tmp___4 = strlen((char const   *)text___0);
    tmp___5 = xmalloc(1UL + tmp___4);
    tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )text___0);
    *(result + 0) = tmp___6;
    }
    return (result);
  }
  {
  postamble = text___0 + (i + 1);
  tack = expand_amble(amble);
  result = array_concat(result, tack);
  free((void *)amble);
  free_array(tack);
  tack = brace_expand(postamble);
  result = array_concat(result, tack);
  free_array(tack);
  }
  return (result);
}
}
static char **expand_amble(char *text___0 ) 
{ 
  char **result ;
  char **partial ;
  char *tem ;
  int start ;
  int i ;
  int c ;
  register int lr ;
  int tmp ;
  register int lp ;
  int tmp___0 ;
  register int j ;
  char *tmp___1 ;

  {
  result = (char **)((void *)0);
  start = 0;
  i = 0;
  c = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! c) {
      goto while_break;
    }
    {
    c = brace_gobbler(text___0, & i, brace_arg_separator);
    tem = substring(text___0, start, i);
    partial = brace_expand(tem);
    }
    if (! result) {
      result = partial;
    } else {
      {
      tmp = array_len(result);
      lr = tmp;
      tmp___0 = array_len(partial);
      lp = tmp___0;
      tmp___1 = xrealloc((void *)result, (unsigned long )((1 + lp) + lr) * sizeof(char *));
      result = (char **)tmp___1;
      j = 0;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (j < lp)) {
          goto while_break___0;
        }
        *(result + (lr + j)) = *(partial + j);
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      *(result + (lr + j)) = (char *)((void *)0);
      free((void *)partial);
      }
    }
    {
    free((void *)tem);
    i ++;
    start = i;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (result);
}
}
static int brace_gobbler(char *text___0 , int *indx , int satisfy ) 
{ 
  register int i ;
  register int c ;
  register int quoted ;
  register int level ;
  register int pass_next ;
  int si ;
  char *t ;

  {
  pass_next = 0;
  quoted = pass_next;
  level = quoted;
  i = *indx;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*(text___0 + i);
    if (! c) {
      goto while_break;
    }
    if (pass_next) {
      pass_next = 0;
      goto __Cont;
    }
    if (c == 92) {
      if (quoted == 0) {
        pass_next = 1;
        goto __Cont;
      } else { //Added block
      if (quoted == 34) {
        pass_next = 1;
        goto __Cont;
      } else { //Added block
      if (quoted == 96) {
        pass_next = 1;
        goto __Cont;
      }
      }
      }
    }
    if (quoted) {
      if (c == quoted) {
        quoted = 0;
      }
      goto __Cont;
    }
    if (c == 34) {
      quoted = c;
      goto __Cont;
    } else { //Added block
    if (c == 39) {
      quoted = c;
      goto __Cont;
    } else { //Added block
    if (c == 96) {
      quoted = c;
      goto __Cont;
    }
    }
    }
    if (c == 36) {
      if ((int )*(text___0 + (i + 1)) == 40) {
        {
        si = i + 2;
        t = extract_command_subst(text___0, & si);
        i = si;
        free((void *)t);
        }
        goto __Cont;
      }
    }
    if (c == satisfy) {
      if (level == 0) {
        if (quoted == 0) {
          if (c == 123) {
            if (! i) {
              goto _L___0;
            } else { //Added block
            if (! *(text___0 + (i - 1))) {
              goto _L___0;
            } else { //Added block
            if ((int )*(text___0 + (i - 1)) == 32) {
              goto _L___0;
            } else { //Added block
            if ((int )*(text___0 + (i - 1)) == 9) {
              goto _L___0;
            } else { //Added block
            if ((int )*(text___0 + (i - 1)) == 10) {
              _L___0: 
              if (! *(text___0 + (i + 1))) {
                goto __Cont;
              } else { //Added block
              if ((int )*(text___0 + (i + 1)) == 32) {
                goto __Cont;
              } else { //Added block
              if ((int )*(text___0 + (i + 1)) == 9) {
                goto __Cont;
              } else { //Added block
              if ((int )*(text___0 + (i + 1)) == 10) {
                goto __Cont;
              } else { //Added block
              if ((int )*(text___0 + (i + 1)) == 125) {
                goto __Cont;
              }
              }
              }
              }
              }
            }
            }
            }
            }
            }
          }
          if (c != 123) {
            goto while_break;
          } else { //Added block
          if (i == 0) {
            goto while_break;
          } else { //Added block
          if ((int )*(text___0 + (i - 1)) != 36) {
            goto while_break;
          }
          }
          }
        }
      }
    }
    if (c == 123) {
      level ++;
    } else { //Added block
    if (c == 125) {
      if (level) {
        level --;
      }
    }
    }
    __Cont: 
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  *indx = i;
  return (c);
}
}
static char **array_concat(char **arr1 , char **arr2 ) 
{ 
  register int i ;
  register int j ;
  register int len___0 ;
  register int len1 ;
  register int len2 ;
  register char **result ;
  char **tmp ;
  char **tmp___0 ;
  char *tmp___1 ;
  int strlen_1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  if ((unsigned long )arr1 == (unsigned long )((char **)0)) {
    {
    tmp = copy_array(arr2);
    }
    return (tmp);
  }
  if ((unsigned long )arr2 == (unsigned long )((char **)0)) {
    {
    tmp___0 = copy_array(arr1);
    }
    return (tmp___0);
  }
  {
  len1 = array_len(arr1);
  len2 = array_len(arr2);
  tmp___1 = xmalloc((unsigned long )(1 + len1 * len2) * sizeof(char *));
  result = (char **)tmp___1;
  len___0 = 0;
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < len1)) {
      goto while_break;
    }
    {
    tmp___2 = strlen((char const   *)*(arr1 + i));
    strlen_1 = (int )tmp___2;
    j = 0;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (j < len2)) {
        goto while_break___0;
      }
      {
      tmp___3 = strlen((char const   *)*(arr2 + j));
      tmp___4 = xmalloc((size_t )(1 + strlen_1) + tmp___3);
      *(result + len___0) = tmp___4;
      strcpy((char * __restrict  )*(result + len___0), (char const   * __restrict  )*(arr1 + i));
      strcpy((char * __restrict  )(*(result + len___0) + strlen_1), (char const   * __restrict  )*(arr2 + j));
      len___0 ++;
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    free((void *)*(arr1 + i));
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  free((void *)arr1);
  *(result + len___0) = (char *)((void *)0);
  }
  return (result);
}
}
#pragma merger("0","/tmp/cil-371szN0b.i","-g")
extern char *sh_backslash_quote(char * ) ;
extern int rl_complete_internal(int  ) ;
extern char *rl_filename_completion_function(char const   * , int  ) ;
extern rl_compentry_func_t *rl_completion_entry_function ;
extern rl_compignore_func_t *rl_ignore_some_completions_function ;
extern rl_completion_func_t *rl_attempted_completion_function ;
extern int rl_filename_quoting_desired ;
extern rl_quote_func_t *rl_filename_quoting_function ;
static int string_gcd(char *s1 , char *s2 ) 
{ 
  register int i ;

  {
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
    return (0);
  } else { //Added block
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    return (0);
  }
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*s1) {
      if (! *s2) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*s1 != (int )*s2) {
      goto while_break;
    }
    s1 ++;
    s2 ++;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (i);
}
}
static char *really_munge_braces(char **array , int real_start , int real_end , int gcd_zero ) 
{ 
  int start ;
  int end ;
  int gcd ;
  char *result ;
  char *subterm ;
  char *x ;
  int result_size ;
  int flag ;
  int tlen ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int temp___0 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  flag = 0;
  if (real_start == real_end) {
    if (*(array + real_start)) {
      {
      tmp = sh_backslash_quote(*(array + real_start) + gcd_zero);
      x = tmp;
      }
    } else {
      {
      tmp___0 = sh_backslash_quote(*(array + 0));
      x = tmp___0;
      }
    }
    return (x);
  }
  {
  result_size = 16;
  result = xmalloc((size_t )result_size);
  *result = (char )'\000';
  start = real_start;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (start < real_end)) {
      goto while_break;
    }
    {
    tmp___1 = strlen((char const   *)*(array + start));
    gcd = (int )tmp___1;
    end = start + 1;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (end < real_end)) {
        goto while_break___0;
      }
      {
      temp___0 = string_gcd(*(array + start), *(array + end));
      }
      if (temp___0 <= gcd_zero) {
        goto while_break___0;
      }
      gcd = temp___0;
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    end --;
    if (gcd_zero == 0) {
      if (start == real_start) {
        if (end != real_end - 1) {
          {
          result_size ++;
          result = xrealloc((void *)result, (size_t )result_size);
          *(result + 0) = (char )'{';
          *(result + 1) = (char )'\000';
          flag ++;
          }
        }
      }
    }
    if (start == end) {
      {
      tmp___2 = strlen((char const   *)(*(array + start) + gcd_zero));
      tmp___3 = xmalloc(1UL + tmp___2);
      tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )(*(array + start) + gcd_zero));
      x = tmp___4;
      subterm = sh_backslash_quote(x);
      free((void *)x);
      }
    } else {
      {
      tlen = gcd - gcd_zero;
      x = xmalloc((size_t )(tlen + 1));
      strncpy((char * __restrict  )x, (char const   * __restrict  )(*(array + start) + gcd_zero),
              (size_t )tlen);
      *(x + tlen) = (char )'\000';
      subterm = sh_backslash_quote(x);
      free((void *)x);
      tmp___5 = strlen((char const   *)subterm);
      result_size = (int )((size_t )result_size + (tmp___5 + 1UL));
      result = xrealloc((void *)result, (size_t )result_size);
      strcat((char * __restrict  )result, (char const   * __restrict  )subterm);
      free((void *)subterm);
      strcat((char * __restrict  )result, (char const   * __restrict  )"{");
      subterm = really_munge_braces(array, start, end + 1, gcd);
      tmp___6 = strlen((char const   *)subterm);
      *(subterm + (tmp___6 - 1UL)) = (char )'}';
      }
    }
    {
    tmp___7 = strlen((char const   *)subterm);
    result_size = (int )((size_t )result_size + (tmp___7 + 1UL));
    result = xrealloc((void *)result, (size_t )result_size);
    strcat((char * __restrict  )result, (char const   * __restrict  )subterm);
    strcat((char * __restrict  )result, (char const   * __restrict  )",");
    free((void *)subterm);
    start = end + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (gcd_zero == 0) {
    {
    tmp___8 = strlen((char const   *)result);
    }
    if (flag) {
      *(result + (tmp___8 - 1UL)) = (char )'}';
    } else {
      *(result + (tmp___8 - 1UL)) = (char )'\000';
    }
  }
  return (result);
}
}
static int hack_braces_completion(char **names ) 
{ 
  register int i ;
  char *temp___0 ;
  int tmp ;

  {
  {
  tmp = array_len(names);
  temp___0 = really_munge_braces(names, 1, tmp, 0);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(names + i)) {
      goto while_break;
    }
    {
    free((void *)*(names + i));
    *(names + i) = (char *)((void *)0);
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  *(names + 0) = temp___0;
  return (0);
}
}
int bash_brace_completion(int count , int ignore ) 
{ 
  rl_compignore_func_t *orig_ignore_func ;
  rl_compentry_func_t *orig_entry_func ;
  rl_quote_func_t *orig_quoting_func ;
  rl_completion_func_t *orig_attempt_func ;
  int orig_quoting_desired ;
  int r ;

  {
  {
  orig_ignore_func = rl_ignore_some_completions_function;
  orig_attempt_func = rl_attempted_completion_function;
  orig_entry_func = rl_completion_entry_function;
  orig_quoting_func = rl_filename_quoting_function;
  orig_quoting_desired = rl_filename_quoting_desired;
  rl_completion_entry_function = & rl_filename_completion_function;
  rl_attempted_completion_function = (rl_completion_func_t *)((void *)0);
  rl_ignore_some_completions_function = & hack_braces_completion;
  rl_filename_quoting_function = (rl_quote_func_t *)((void *)0);
  rl_filename_quoting_desired = 0;
  r = rl_complete_internal('\t');
  rl_ignore_some_completions_function = orig_ignore_func;
  rl_attempted_completion_function = orig_attempt_func;
  rl_completion_entry_function = orig_entry_func;
  rl_filename_quoting_function = orig_quoting_func;
  rl_filename_quoting_desired = orig_quoting_desired;
  }
  return (r);
}
}
#pragma merger("0","/tmp/cil-pgpvZkud.i","-g")
char *strcreplace(char *string , int c , char *text___0 , int do_glob ) ;
extern void using_history(void) ;
extern void add_history(char const   * ) ;
extern HIST_ENTRY *replace_history_entry(int  , char const   * , histdata_t  ) ;
extern HIST_ENTRY *previous_history(void) ;
extern int read_history(char const   * ) ;
extern int write_history(char const   * ) ;
extern int append_history(int  , char const   * ) ;
extern int history_expand(char * , char ** ) ;
extern int history_base ;
extern char *history_search_delimiter_chars ;
extern int history_quotes_inhibit_expansion ;
extern rl_linebuf_func_t *history_inhibit_expansion_function ;
int bash_re_edit(char *line ) ;
static int histignore_item_func(struct ign *ign ) ;
static struct ignorevar histignore  =    {(char *)"HISTIGNORE", (struct ign *)0, 0, (char *)0, (Function *)(& histignore_item_func)};
int remember_on_history  =    1;
int command_oriented_history  =    1;
int literal_history  ;
int force_append_history  ;
int hist_last_line_added  ;
int history_reediting  ;
int hist_verify  ;
void bash_add_history(char *line ) ;
static int history_should_ignore(char *line ) ;
static int bash_history_inhibit_expansion(char *string , int i ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (i > 0) {
    if ((int )*(string + (i - 1)) == 91) {
      {
      tmp___1 = strchr((char const   *)((string + i) + 1), ']');
      }
      if ((unsigned long )tmp___1 != (unsigned long )((char *)((void *)0))) {
        return (1);
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else { //Added block
  _L___3: 
  if (i > 1) {
    if ((int )*(string + (i - 1)) == 123) {
      if ((int )*(string + (i - 2)) == 36) {
        {
        tmp___0 = strchr((char const   *)((string + i) + 1), '}');
        }
        if ((unsigned long )tmp___0 != (unsigned long )((char *)((void *)0))) {
          return (1);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (extended_glob) {
    if (i > 1) {
      if ((int )*(string + (i + 1)) == 40) {
        {
        tmp = strchr((char const   *)((string + i) + 2), ')');
        }
        if ((unsigned long )tmp != (unsigned long )((char *)((void *)0))) {
          return (1);
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  }
  }
}
}
void bash_initialize_history(void) 
{ 


  {
  history_quotes_inhibit_expansion = 1;
  history_search_delimiter_chars = (char *)";&()|<>";
  history_inhibit_expansion_function = & bash_history_inhibit_expansion;
  return;
}
}
void bash_history_reinit(int interact ) 
{ 


  {
  history_expansion = interact != 0;
  history_expansion_inhibited = 1;
  remember_on_history = interact != 0;
  history_inhibit_expansion_function = & bash_history_inhibit_expansion;
  return;
}
}
void bash_history_disable(void) 
{ 


  {
  remember_on_history = 0;
  history_expansion_inhibited = 1;
  return;
}
}
void bash_history_enable(void) 
{ 


  {
  {
  remember_on_history = 1;
  history_expansion_inhibited = 0;
  history_inhibit_expansion_function = & bash_history_inhibit_expansion;
  sv_history_control((char *)"HISTCONTROL");
  sv_histignore((char *)"HISTIGNORE");
  }
  return;
}
}
void load_history(void) 
{ 
  char *hf ;
  struct stat buf ;
  char *tmp ;
  int tmp___0 ;

  {
  {
  tmp = get_string_value("HISTSIZE");
  set_if_not((char *)"HISTFILESIZE", tmp);
  sv_histsize((char *)"HISTFILESIZE");
  hf = get_string_value("HISTFILE");
  }
  if (hf) {
    if (*hf) {
      {
      tmp___0 = stat((char const   * __restrict  )hf, (struct stat * __restrict  )(& buf));
      }
      if (tmp___0 == 0) {
        {
        read_history((char const   *)hf);
        using_history();
        history_lines_in_file = where_history();
        }
      }
    }
  }
  return;
}
}
int maybe_append_history(char *filename ) 
{ 
  int fd ;
  int result ;
  struct stat buf ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  result = 0;
  if (history_lines_this_session) {
    {
    tmp___3 = where_history();
    }
    if (history_lines_this_session < tmp___3) {
      {
      tmp___1 = stat((char const   * __restrict  )filename, (struct stat * __restrict  )(& buf));
      }
      if (tmp___1 == -1) {
        {
        tmp___2 = __errno_location();
        }
        if (*tmp___2 == 2) {
          {
          fd = open((char const   *)filename, 65, 384);
          }
          if (fd < 0) {
            {
            tmp = __errno_location();
            tmp___0 = strerror(*tmp);
            builtin_error("%s: cannot create: %s", filename, tmp___0);
            }
            return (1);
          }
          {
          close(fd);
          }
        }
      }
      {
      result = append_history(history_lines_this_session, (char const   *)filename);
      history_lines_in_file += history_lines_this_session;
      history_lines_this_session = 0;
      }
    }
  }
  return (result);
}
}
int maybe_save_shell_history(void) 
{ 
  int result ;
  char *hf ;
  struct stat buf ;
  int file ;
  int tmp ;
  int tmp___0 ;

  {
  result = 0;
  if (history_lines_this_session) {
    {
    hf = get_string_value("HISTFILE");
    }
    if (hf) {
      if (*hf) {
        {
        tmp = stat((char const   * __restrict  )hf, (struct stat * __restrict  )(& buf));
        }
        if (tmp == -1) {
          {
          file = open((char const   *)hf, 577, 384);
          }
          if (file != -1) {
            {
            close(file);
            }
          }
        }
        {
        using_history();
        tmp___0 = where_history();
        }
        if (history_lines_this_session <= tmp___0) {
          {
          result = append_history(history_lines_this_session, (char const   *)hf);
          history_lines_in_file += history_lines_this_session;
          }
        } else { //Added block
        if (force_append_history) {
          {
          result = append_history(history_lines_this_session, (char const   *)hf);
          history_lines_in_file += history_lines_this_session;
          }
        } else {
          {
          result = write_history((char const   *)hf);
          history_lines_in_file = history_lines_this_session;
          }
        }
        }
        {
        history_lines_this_session = 0;
        sv_histsize((char *)"HISTFILESIZE");
        }
      }
    }
  }
  return (result);
}
}
static void re_edit(char *text___0 ) 
{ 


  {
  if ((unsigned int )bash_input.type == 1U) {
    {
    bash_re_edit(text___0);
    }
  }
  return;
}
}
static int history_expansion_p(char *line ) 
{ 
  register char *s ;

  {
  s = line;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    if ((int )*s == (int )history_expansion_char) {
      return (1);
    } else { //Added block
    if ((int )*s == (int )history_subst_char) {
      return (1);
    }
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
char *pre_process_line(char *line , int print_changes , int addit ) 
{ 
  char *history_value ;
  char *return_value ;
  int expanded ;
  int tmp ;

  {
  return_value = line;
  expanded = 0;
  if (! history_expansion_inhibited) {
    if (history_expansion) {
      {
      tmp = history_expansion_p(line);
      }
      if (tmp) {
        {
        expanded = history_expand(line, & history_value);
        }
        if (expanded) {
          if (print_changes) {
            if (expanded < 0) {
              {
              internal_error("%s", history_value);
              }
            } else { //Added block
            if (hist_verify == 0) {
              {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                      history_value);
              }
            } else { //Added block
            if (expanded == 2) {
              {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                      history_value);
              }
            }
            }
            }
          }
          if (expanded < 0) {
            goto _L;
          } else { //Added block
          if (expanded == 2) {
            _L: 
            {
            free((void *)history_value);
            }
            if (history_reediting) {
              if (expanded < 0) {
                {
                re_edit(line);
                }
              }
            }
            return ((char *)((void *)0));
          }
          }
          if (hist_verify) {
            if (expanded == 1) {
              {
              re_edit(history_value);
              }
              return ((char *)((void *)0));
            }
          }
        }
        expanded = 1;
        return_value = history_value;
      }
    }
  }
  if (addit) {
    if (remember_on_history) {
      if (*return_value) {
        {
        maybe_add_history(return_value);
        }
      }
    }
  }
  return (return_value);
}
}
static int shell_comment(char *line ) 
{ 
  char *p ;
  int tmp ;

  {
  p = line;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (p) {
      if (*p) {
        if (! ((int )*p == 32)) {
          if (! ((int )*p == 9)) {
            goto while_break;
          }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (p) {
    if ((int )*p == 35) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int first_line_saved  =    0;
void maybe_add_history(char *line ) 
{ 
  HIST_ENTRY *temp___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  hist_last_line_added = 0;
  if (current_command_line_count > 1) {
    if (first_line_saved) {
      if (literal_history) {
        {
        bash_add_history(line);
        }
      } else { //Added block
      if (dstack.delimiter_depth != 0) {
        {
        bash_add_history(line);
        }
      } else {
        {
        tmp = shell_comment(line);
        }
        if (tmp == 0) {
          {
          bash_add_history(line);
          }
        }
      }
      }
    }
    return;
  }
  first_line_saved = 0;
  {
  if (history_control == 0) {
    goto case_0;
  }
  if (history_control == 1) {
    goto case_1;
  }
  if (history_control == 3) {
    goto case_3;
  }
  if (history_control == 2) {
    goto case_2;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  first_line_saved = 1;
  goto switch_break;
  case_1: /* CIL Label */ 
  if ((int )*line != 32) {
    first_line_saved = 1;
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  if ((int )*line == 32) {
    goto switch_break;
  }
  case_2: /* CIL Label */ 
  {
  using_history();
  temp___0 = previous_history();
  }
  if ((unsigned long )temp___0 == (unsigned long )((HIST_ENTRY *)0)) {
    first_line_saved = 1;
  } else {
    if ((int )*(temp___0->line + 0) == (int )*(line + 0)) {
      {
      tmp___0 = strcmp((char const   *)temp___0->line, (char const   *)line);
      }
      if (tmp___0 == 0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    if (tmp___1 == 0) {
      first_line_saved = 1;
    }
  }
  {
  using_history();
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (first_line_saved) {
    {
    tmp___2 = history_should_ignore(line);
    }
    if (tmp___2 == 0) {
      {
      bash_add_history(line);
      }
    } else {
      first_line_saved = 0;
    }
  } else {
    first_line_saved = 0;
  }
  return;
}
}
void bash_add_history(char *line ) 
{ 
  int add_it ;
  int offset ;
  int curlen ;
  HIST_ENTRY *current ;
  HIST_ENTRY *old ;
  char *chars_to_add ;
  char *new_line ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  add_it = 1;
  if (command_oriented_history) {
    if (current_command_line_count > 1) {
      if (literal_history) {
        chars_to_add = (char *)"\n";
      } else {
        {
        tmp = history_delimiting_chars();
        chars_to_add = tmp;
        }
      }
      {
      using_history();
      current = previous_history();
      }
      if (current) {
        {
        tmp___0 = strlen((char const   *)current->line);
        curlen = (int )tmp___0;
        }
        if (dstack.delimiter_depth == 0) {
          if ((int )*(current->line + (curlen - 1)) == 92) {
            if ((int )*(current->line + (curlen - 2)) != 92) {
              *(current->line + (curlen - 1)) = (char )'\000';
              curlen --;
              chars_to_add = (char *)"";
            }
          }
        }
        {
        tmp___1 = strlen((char const   *)line);
        tmp___2 = strlen((char const   *)chars_to_add);
        tmp___3 = xmalloc(((size_t )(1 + curlen) + tmp___1) + tmp___2);
        new_line = tmp___3;
        sprintf((char * __restrict  )new_line, (char const   * __restrict  )"%s%s%s",
                current->line, chars_to_add, line);
        offset = where_history();
        old = replace_history_entry(offset, (char const   *)new_line, current->data);
        free((void *)new_line);
        }
        if (old) {
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (old->line) {
              {
              free((void *)old->line);
              }
            }
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
          {
          free((void *)old);
          }
        }
        add_it = 0;
      }
    }
  }
  if (add_it) {
    {
    hist_last_line_added = 1;
    add_history((char const   *)line);
    history_lines_this_session ++;
    }
  }
  {
  using_history();
  }
  return;
}
}
int history_number(void) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
  using_history();
  tmp___2 = get_string_value("HISTSIZE");
  }
  if (tmp___2) {
    {
    tmp___0 = where_history();
    tmp___1 = history_base + tmp___0;
    }
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static int should_expand(char *s ) 
{ 
  char *p ;

  {
  p = s;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (p) {
      if (! *p) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p == 92) {
      p ++;
    } else { //Added block
    if ((int )*p == 38) {
      return (1);
    }
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int histignore_item_func(struct ign *ign ) 
{ 
  int tmp ;

  {
  {
  tmp = should_expand(ign->val);
  }
  if (tmp) {
    ign->flags |= 1;
  }
  return (0);
}
}
void setup_history_ignore(char *varname___0 ) 
{ 


  {
  {
  setup_ignore_patterns(& histignore);
  }
  return;
}
}
static HIST_ENTRY *last_history_entry(void) 
{ 
  HIST_ENTRY *he ;

  {
  {
  using_history();
  he = previous_history();
  using_history();
  }
  return (he);
}
}
char *last_history_line(void) 
{ 
  HIST_ENTRY *he ;

  {
  {
  he = last_history_entry();
  }
  if ((unsigned long )he == (unsigned long )((HIST_ENTRY *)0)) {
    return ((char *)((void *)0));
  }
  return (he->line);
}
}
static char *expand_histignore_pattern(char *pat ) 
{ 
  HIST_ENTRY *phe ;
  char *ret ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  phe = last_history_entry();
  }
  if ((unsigned long )phe == (unsigned long )((HIST_ENTRY *)0)) {
    {
    tmp = strlen((char const   *)pat);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )pat);
    }
    return (tmp___1);
  }
  {
  ret = strcreplace(pat, '&', phe->line, 1);
  }
  return (ret);
}
}
static int history_should_ignore(char *line ) 
{ 
  register int i ;
  register int match ;
  char *npat ;
  int tmp ;
  int tmp___0 ;

  {
  if (histignore.num_ignores == 0) {
    return (0);
  }
  match = 0;
  i = match;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < histignore.num_ignores)) {
      goto while_break;
    }
    if ((histignore.ignores + i)->flags & 1) {
      {
      npat = expand_histignore_pattern((histignore.ignores + i)->val);
      }
    } else {
      npat = (histignore.ignores + i)->val;
    }
    if (extended_glob) {
      tmp = 1 << 5;
    } else {
      tmp = 0;
    }
    {
    tmp___0 = fnmatch(npat, line, tmp);
    match = tmp___0 != 1;
    }
    if ((histignore.ignores + i)->flags & 1) {
      {
      free((void *)npat);
      }
    }
    if (match) {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (match);
}
}
#pragma merger("0","/tmp/cil-8zEnwb2A.i","-g")
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern int qsort_string_compare() ;
extern int num_shell_builtins ;
int bind_keyseq_to_unix_command(char *line ) ;
char *command_word_completion_function(char const   *hint_text , int state ) ;
char **get_hostname_list(void) ;
char **bash_directory_completion_matches(char const   *text___0 ) ;
int executable_or_directory(char *file ) ;
extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap ;
extern KEYMAP_ENTRY_ARRAY emacs_meta_keymap ;
extern KEYMAP_ENTRY_ARRAY emacs_ctlx_keymap ;
extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap ;
extern KEYMAP_ENTRY_ARRAY vi_movement_keymap ;
extern Keymap rl_make_bare_keymap(void) ;
extern Keymap rl_get_keymap(void) ;
extern int rl_forward_word(int  , int  ) ;
extern int rl_insert(int  , int  ) ;
extern int rl_newline(int  , int  ) ;
extern int rl_get_previous_history(int  , int  ) ;
extern int rl_complete(int  , int  ) ;
extern int rl_yank_last_arg(int  , int  ) ;
extern int rl_initialize(void) ;
extern int rl_add_defun(char const   * , rl_command_func_t * , int  ) ;
extern int rl_bind_key_in_map(int  , rl_command_func_t * , Keymap  ) ;
extern int rl_unbind_key_in_map(int  , Keymap  ) ;
extern int rl_set_key(char const   * , rl_command_func_t * , Keymap  ) ;
extern int rl_generic_bind(int  , char const   * , char * , Keymap  ) ;
extern int rl_variable_bind(char const   * , char const   * ) ;
extern void rl_push_macro_input(char * ) ;
extern void rl_add_undo(enum undo_code  , int  , int  , char * ) ;
extern void rl_redisplay(void) ;
extern int rl_on_new_line(void) ;
extern int rl_forced_update_display(void) ;
extern int rl_crlf(void) ;
extern int rl_insert_text(char const   * ) ;
extern int rl_delete_text(int  , int  ) ;
extern int rl_read_key(void) ;
extern int rl_ding(void) ;
extern char **rl_completion_matches(char const   * , rl_compentry_func_t * ) ;
extern char *rl_username_completion_function(char const   * , int  ) ;
extern int rl_readline_state ;
extern char const   *rl_readline_name ;
extern char *rl_line_buffer ;
extern int rl_point ;
extern int rl_end ;
extern int rl_explicit_arg ;
extern rl_command_func_t *rl_last_func ;
extern char const   *rl_terminal_name ;
extern FILE *rl_instream ;
extern FILE *rl_outstream ;
extern rl_hook_func_t *rl_startup_hook ;
extern Keymap rl_executing_keymap ;
extern char const   *rl_completer_word_break_characters ;
extern char const   *rl_completer_quote_characters ;
extern char const   *rl_filename_quote_characters ;
extern char const   *rl_special_prefixes ;
extern rl_icppfunc_t *rl_directory_completion_hook ;
extern int rl_filename_completion_desired ;
extern rl_dequote_func_t *rl_filename_dequoting_function ;
extern rl_linebuf_func_t *rl_char_is_quoted_p ;
extern int rl_attempted_completion_over ;
extern int history_is_stifled(void) ;
extern HIST_ENTRY **history_list(void) ;
extern char **history_tokenize(char const   * ) ;
extern int history_length ;
extern int history_max_entries ;
extern int glob_pattern_p(char * ) ;
int prog_completion_enabled ;
int num_progcomps(void) ;
char **programmable_completions(char const   *cmd , char const   *word , int start ,
                                int end , int *foundp ) ;
static int shell_expand_line(int count , int ignore ) ;
static int display_shell_version(int count , int c ) ;
static int operate_and_get_next(int count , int c ) ;
static int bash_ignore_filenames(char **names ) ;
static int bash_ignore_everything(char **names ) ;
static void cleanup_expansion_error(void) ;
static void set_up_new_line(char *new_line ) ;
static int history_expand_line(int count , int ignore ) ;
static int tcsh_magic_space(int count , int ignore ) ;
static int alias_expand_line(int count , int ignore ) ;
static int history_and_alias_expand_line(int count , int ignore ) ;
static int bash_directory_completion_hook(char **dirname ) ;
static int filename_completion_ignore(char **names ) ;
static int bash_push_line(void) ;
static char **attempt_shell_completion(char const   *text___0 , int start , int end ) ;
static char *variable_completion_function(char const   *text___0 , int state ) ;
static char *hostname_completion_function(char const   *text___0 , int state ) ;
static char *command_subst_completion_function(char const   *text___0 , int state ) ;
static int dynamic_complete_history(int count , int key ) ;
static char *glob_complete_word(char const   *text___0 , int state ) ;
static int bash_glob_expand_word(int count , int key ) ;
static int bash_glob_list_expansions(int count , int key ) ;
static void snarf_hosts_from_file(char *filename ) ;
static void add_host_name(char *name ) ;
static char *bash_dequote_filename(char *text___0 , int quote_char ) ;
static char *bash_quote_filename(char *s , int rtype , char *qcp ) ;
static int posix_edit_macros(int count , int key ) ;
static char **prog_complete_matches  ;
static int bash_specific_completion(int what_to_do , rl_compentry_func_t *generator ) ;
static int bash_complete_filename_internal(int what_to_do ) ;
static int bash_complete_username_internal(int what_to_do ) ;
static int bash_complete_hostname_internal(int what_to_do ) ;
static int bash_complete_variable_internal(int what_to_do ) ;
static int bash_complete_command_internal(int what_to_do ) ;
static int bash_complete_filename(int ignore , int ignore2 ) ;
static int bash_possible_filename_completions(int ignore , int ignore2 ) ;
static int bash_complete_username(int ignore , int ignore2 ) ;
static int bash_possible_username_completions(int ignore , int ignore2 ) ;
static int bash_complete_hostname(int ignore , int ignore2 ) ;
static int bash_possible_hostname_completions(int ignore , int ignore2 ) ;
static int bash_complete_variable(int ignore , int ignore2 ) ;
static int bash_possible_variable_completions(int ignore , int ignore2 ) ;
static int bash_complete_command(int ignore , int ignore2 ) ;
static int bash_possible_command_completions(int ignore , int ignore2 ) ;
static int vi_edit_and_execute_command(int count , int c ) ;
int bash_readline_initialized  =    0;
int perform_hostname_completion  =    1;
int no_empty_command_completion  ;
static char *bash_completer_word_break_characters  =    (char *)" \t\n\"\'@><=;|&(:";
static char *bash_nohostname_word_break_characters  =    (char *)" \t\n\"\'><=;|&(:";
static rl_hook_func_t *old_rl_startup_hook  =    (rl_hook_func_t *)((void *)0);
static int completion_quoting_style  =    3;
void posix_readline_initialize(int on_or_off ) 
{ 
  int (*tmp)(int  , int  ) ;

  {
  if (on_or_off) {
    {
    rl_variable_bind("comment-begin", "#");
    }
  }
  if (on_or_off) {
    tmp = & rl_insert;
  } else {
    tmp = & rl_complete;
  }
  {
  rl_bind_key_in_map(9, tmp, vi_insertion_keymap);
  }
  return;
}
}
void enable_hostname_completion(int on_or_off ) 
{ 


  {
  if (on_or_off) {
    perform_hostname_completion = 1;
    rl_special_prefixes = "$@";
    rl_completer_word_break_characters = (char const   *)bash_completer_word_break_characters;
  } else {
    perform_hostname_completion = 0;
    rl_special_prefixes = "$";
    rl_completer_word_break_characters = (char const   *)bash_nohostname_word_break_characters;
  }
  return;
}
}
void initialize_readline(void) 
{ 
  char *tmp ;

  {
  if (bash_readline_initialized) {
    return;
  }
  {
  tmp = get_string_value("TERM");
  rl_terminal_name = (char const   *)tmp;
  rl_instream = stdin;
  rl_outstream = stderr;
  rl_readline_name = "Bash";
  rl_add_defun("shell-expand-line", & shell_expand_line, -1);
  rl_add_defun("history-expand-line", & history_expand_line, -1);
  rl_add_defun("magic-space", & tcsh_magic_space, -1);
  rl_add_defun("alias-expand-line", & alias_expand_line, -1);
  rl_add_defun("history-and-alias-expand-line", & history_and_alias_expand_line, -1);
  rl_add_defun("insert-last-argument", & rl_yank_last_arg, -1);
  rl_add_defun("operate-and-get-next", & operate_and_get_next, -1);
  rl_add_defun("display-shell-version", & display_shell_version, -1);
  rl_add_defun("complete-into-braces", & bash_brace_completion, -1);
  rl_add_defun("complete-filename", & bash_complete_filename, -1);
  rl_add_defun("possible-filename-completions", & bash_possible_filename_completions,
               -1);
  rl_add_defun("complete-username", & bash_complete_username, -1);
  rl_add_defun("possible-username-completions", & bash_possible_username_completions,
               -1);
  rl_add_defun("complete-hostname", & bash_complete_hostname, -1);
  rl_add_defun("possible-hostname-completions", & bash_possible_hostname_completions,
               -1);
  rl_add_defun("complete-variable", & bash_complete_variable, -1);
  rl_add_defun("possible-variable-completions", & bash_possible_variable_completions,
               -1);
  rl_add_defun("complete-command", & bash_complete_command, -1);
  rl_add_defun("possible-command-completions", & bash_possible_command_completions,
               -1);
  rl_add_defun("glob-expand-word", & bash_glob_expand_word, -1);
  rl_add_defun("glob-list-expansions", & bash_glob_list_expansions, -1);
  rl_add_defun("dynamic-complete-history", & dynamic_complete_history, -1);
  }
  if ((rl_readline_state & 2) == 0) {
    {
    rl_initialize();
    }
  }
  {
  rl_bind_key_in_map(5, & shell_expand_line, emacs_meta_keymap);
  rl_bind_key_in_map('^', & history_expand_line, emacs_meta_keymap);
  rl_bind_key_in_map(15, & operate_and_get_next, emacs_standard_keymap);
  rl_bind_key_in_map(22, & display_shell_version, emacs_ctlx_keymap);
  rl_unbind_key_in_map(10, emacs_meta_keymap);
  rl_unbind_key_in_map(13, emacs_meta_keymap);
  rl_unbind_key_in_map(5, vi_movement_keymap);
  rl_bind_key_in_map('{', & bash_brace_completion, emacs_meta_keymap);
  rl_bind_key_in_map('/', & bash_complete_filename, emacs_meta_keymap);
  rl_bind_key_in_map('/', & bash_possible_filename_completions, emacs_ctlx_keymap);
  rl_bind_key_in_map('~', & bash_complete_username, emacs_meta_keymap);
  rl_bind_key_in_map('~', & bash_possible_username_completions, emacs_ctlx_keymap);
  rl_bind_key_in_map('@', & bash_complete_hostname, emacs_meta_keymap);
  rl_bind_key_in_map('@', & bash_possible_hostname_completions, emacs_ctlx_keymap);
  rl_bind_key_in_map('$', & bash_complete_variable, emacs_meta_keymap);
  rl_bind_key_in_map('$', & bash_possible_variable_completions, emacs_ctlx_keymap);
  rl_bind_key_in_map('!', & bash_complete_command, emacs_meta_keymap);
  rl_bind_key_in_map('!', & bash_possible_command_completions, emacs_ctlx_keymap);
  rl_bind_key_in_map('*', & bash_glob_expand_word, emacs_ctlx_keymap);
  rl_bind_key_in_map('g', & bash_glob_list_expansions, emacs_ctlx_keymap);
  rl_bind_key_in_map('\t', & dynamic_complete_history, emacs_meta_keymap);
  rl_attempted_completion_function = & attempt_shell_completion;
  rl_directory_completion_hook = & bash_directory_completion_hook;
  rl_ignore_some_completions_function = & filename_completion_ignore;
  rl_bind_key_in_map('v', & vi_edit_and_execute_command, vi_movement_keymap);
  rl_bind_key_in_map('@', & posix_edit_macros, vi_movement_keymap);
  rl_completer_quote_characters = "\'\"";
  enable_hostname_completion(perform_hostname_completion);
  rl_filename_quote_characters = " \t\n\\\"\'@<>=;|&()#$`?*[!:{";
  rl_filename_quoting_function = & bash_quote_filename;
  rl_filename_dequoting_function = & bash_dequote_filename;
  rl_char_is_quoted_p = & char_is_quoted;
  }
  if (posixly_correct) {
    {
    posix_readline_initialize(1);
    }
  }
  bash_readline_initialized = 1;
  return;
}
}
void bashline_reinitialize(void) 
{ 


  {
  {
  tilde_initialize();
  rl_attempted_completion_function = & attempt_shell_completion;
  rl_completion_entry_function = (rl_compentry_func_t *)((void *)0);
  rl_directory_completion_hook = & bash_directory_completion_hook;
  rl_ignore_some_completions_function = & filename_completion_ignore;
  }
  return;
}
}
static char *push_to_readline  =    (char *)((void *)0);
static int bash_push_line(void) 
{ 


  {
  if (push_to_readline) {
    {
    rl_insert_text((char const   *)push_to_readline);
    free((void *)push_to_readline);
    push_to_readline = (char *)((void *)0);
    rl_startup_hook = old_rl_startup_hook;
    }
  }
  return (0);
}
}
int bash_re_edit(char *line ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (push_to_readline) {
      {
      free((void *)push_to_readline);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp = strlen((char const   *)line);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )line);
  push_to_readline = tmp___1;
  old_rl_startup_hook = rl_startup_hook;
  rl_startup_hook = & bash_push_line;
  }
  return (0);
}
}
static int display_shell_version(int count , int c ) 
{ 


  {
  {
  rl_crlf();
  show_shell_version(0);
  _IO_putc('\r', rl_outstream);
  fflush(rl_outstream);
  rl_on_new_line();
  rl_redisplay();
  }
  return (0);
}
}
static char **hostname_list  =    (char **)((void *)0);
static int hostname_list_size  ;
static int hostname_list_length  ;
int hostname_list_initialized  =    0;
static void initialize_hostname_list(void) 
{ 
  char *temp___0 ;

  {
  {
  temp___0 = get_string_value("HOSTFILE");
  }
  if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
    {
    temp___0 = get_string_value("hostname_completion_file");
    }
  }
  if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
    temp___0 = (char *)"/etc/hosts";
  }
  {
  snarf_hosts_from_file(temp___0);
  }
  if (hostname_list) {
    hostname_list_initialized ++;
  }
  return;
}
}
static void add_host_name(char *name ) 
{ 
  long size ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  if (hostname_list_length + 2 > hostname_list_size) {
    {
    hostname_list_size = (hostname_list_size + 32) - hostname_list_size % 32;
    size = (long )((unsigned long )hostname_list_size * sizeof(char *));
    tmp = xrealloc((void *)hostname_list, (size_t )size);
    hostname_list = (char **)tmp;
    }
  }
  {
  tmp___0 = hostname_list_length;
  hostname_list_length ++;
  tmp___1 = strlen((char const   *)name);
  tmp___2 = xmalloc(1UL + tmp___1);
  tmp___3 = strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )name);
  *(hostname_list + tmp___0) = tmp___3;
  *(hostname_list + hostname_list_length) = (char *)((void *)0);
  }
  return;
}
}
static void snarf_hosts_from_file(char *filename ) 
{ 
  FILE *file ;
  char *temp___0 ;
  char buffer[256] ;
  char name[256] ;
  register int i ;
  register int start ;
  char *incfile ;
  char *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  {
  file = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  }
  if ((unsigned long )file == (unsigned long )((FILE *)0)) {
    return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    temp___0 = fgets((char * __restrict  )(buffer), 255, (FILE * __restrict  )file);
    }
    if (! temp___0) {
      goto while_break;
    }
    i = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (buffer[i]) {
        if (! ((int )buffer[i] == 13)) {
          if (! ((int )buffer[i] == 10)) {
            if (! ((int )buffer[i] == 32)) {
              if (! ((int )buffer[i] == 9)) {
                goto while_break___0;
              }
            }
          }
        }
      } else {
        goto while_break___0;
      }
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((int )buffer[i] == 0) {
      goto while_continue;
    } else { //Added block
    if ((int )buffer[i] == 35) {
      goto while_continue;
    }
    }
    {
    tmp___0 = strncmp((char const   *)(buffer + i), "$include ", (size_t )9);
    }
    if (tmp___0 == 0) {
      incfile = (buffer + i) + 9;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (*incfile) {
          if (! ((int )*incfile == 32)) {
            if (! ((int )*incfile == 9)) {
              goto while_break___1;
            }
          }
        } else {
          goto while_break___1;
        }
        incfile ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      t = incfile;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (*t) {
          if ((int )*t == 13) {
            tmp = 1;
          } else { //Added block
          if ((int )*t == 10) {
            tmp = 1;
          } else { //Added block
          if ((int )*t == 32) {
            tmp = 1;
          } else { //Added block
          if ((int )*t == 9) {
            tmp = 1;
          } else {
            tmp = 0;
          }
          }
          }
          }
          if (! (tmp == 0)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        t ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      *t = (char )'\000';
      snarf_hosts_from_file(incfile);
      }
      goto while_continue;
    }
    {
    tmp___2 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___2 + (int )buffer[i]) & 2048) {
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (buffer[i]) {
          if ((int )buffer[i] == 13) {
            tmp___1 = 1;
          } else { //Added block
          if ((int )buffer[i] == 10) {
            tmp___1 = 1;
          } else { //Added block
          if ((int )buffer[i] == 32) {
            tmp___1 = 1;
          } else { //Added block
          if ((int )buffer[i] == 9) {
            tmp___1 = 1;
          } else {
            tmp___1 = 0;
          }
          }
          }
          }
          if (! (tmp___1 == 0)) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! buffer[i]) {
        goto while_break___4;
      }
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! ((int )buffer[i] == 13)) {
          if (! ((int )buffer[i] == 10)) {
            if (! ((int )buffer[i] == 32)) {
              if (! ((int )buffer[i] == 9)) {
                goto while_break___5;
              }
            }
          }
        }
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      if ((int )buffer[i] == 0) {
        goto while_break___4;
      } else { //Added block
      if ((int )buffer[i] == 35) {
        goto while_break___4;
      }
      }
      start = i;
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        if (buffer[i]) {
          if ((int )buffer[i] == 13) {
            tmp___3 = 1;
          } else { //Added block
          if ((int )buffer[i] == 10) {
            tmp___3 = 1;
          } else { //Added block
          if ((int )buffer[i] == 32) {
            tmp___3 = 1;
          } else { //Added block
          if ((int )buffer[i] == 9) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
          }
          }
          }
          if (! (tmp___3 == 0)) {
            goto while_break___6;
          }
        } else {
          goto while_break___6;
        }
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      if (i == start) {
        goto while_continue___4;
      }
      {
      strncpy((char * __restrict  )(name), (char const   * __restrict  )(buffer + start),
              (size_t )(i - start));
      name[i - start] = (char )'\000';
      add_host_name(name);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  fclose(file);
  }
  return;
}
}
char **get_hostname_list(void) 
{ 


  {
  if (hostname_list_initialized == 0) {
    {
    initialize_hostname_list();
    }
  }
  return (hostname_list);
}
}
void clear_hostname_list(void) 
{ 
  register int i ;

  {
  if (hostname_list_initialized == 0) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < hostname_list_length)) {
      goto while_break;
    }
    {
    free((void *)*(hostname_list + i));
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  hostname_list_length = 0;
  return;
}
}
static char **hostnames_matching(char *text___0 ) 
{ 
  register int i ;
  register int len___0 ;
  register int nmatch ;
  register int rsize ;
  char **result ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  if (hostname_list_initialized == 0) {
    {
    initialize_hostname_list();
    }
  }
  if (hostname_list_initialized == 0) {
    return ((char **)((void *)0));
  }
  if ((int )*text___0 == 0) {
    {
    result = alloc_array(1 + hostname_list_length);
    i = 0;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < hostname_list_length)) {
        goto while_break;
      }
      *(result + i) = *(hostname_list + i);
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    *(result + i) = (char *)((void *)0);
    return (result);
  }
  {
  tmp = strlen((char const   *)text___0);
  len___0 = (int )tmp;
  result = (char **)((void *)0);
  rsize = 0;
  nmatch = rsize;
  i = nmatch;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < hostname_list_length)) {
      goto while_break___0;
    }
    if (len___0 == 0) {
      tmp___2 = 1;
    } else {
      if ((int )*(text___0 + 0) == (int )*(*(hostname_list + i) + 0)) {
        {
        tmp___0 = strncmp((char const   *)text___0, (char const   *)*(hostname_list + i),
                          (size_t )len___0);
        }
        if (tmp___0 == 0) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
      tmp___2 = tmp___1;
    }
    if (tmp___2 == 0) {
      goto __Cont;
    }
    if (nmatch >= rsize - 1) {
      {
      rsize = (rsize + 16) - rsize % 16;
      tmp___3 = xrealloc((void *)result, (unsigned long )rsize * sizeof(char *));
      result = (char **)tmp___3;
      }
    }
    tmp___4 = nmatch;
    nmatch ++;
    *(result + tmp___4) = *(hostname_list + i);
    __Cont: 
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (nmatch) {
    *(result + nmatch) = (char *)((void *)0);
  }
  return (result);
}
}
static int saved_history_line_to_use  =    -1;
static int set_saved_history(void) 
{ 


  {
  if (saved_history_line_to_use >= 0) {
    {
    rl_get_previous_history(history_length - saved_history_line_to_use, 0);
    }
  }
  saved_history_line_to_use = -1;
  rl_startup_hook = old_rl_startup_hook;
  return (0);
}
}
static int operate_and_get_next(int count , int c ) 
{ 
  int where ;
  int tmp ;

  {
  {
  rl_newline(1, c);
  where = where_history();
  tmp = history_is_stifled();
  }
  if (tmp) {
    if (history_length >= history_max_entries) {
      saved_history_line_to_use = where;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (where >= history_length - 1) {
    saved_history_line_to_use = where;
  } else {
    saved_history_line_to_use = where + 1;
  }
  }
  old_rl_startup_hook = rl_startup_hook;
  rl_startup_hook = & set_saved_history;
  return (0);
}
}
static int vi_edit_and_execute_command(int count , int c ) 
{ 
  char *command ;
  int r ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  rl_newline(1, c);
  }
  if (rl_explicit_arg) {
    {
    tmp = strlen("fc -e ${VISUAL:-${EDITOR:-vi}}");
    command = xmalloc(tmp + 8UL);
    sprintf((char * __restrict  )command, (char const   * __restrict  )"%s %d", "fc -e ${VISUAL:-${EDITOR:-vi}}",
            count);
    }
  } else {
    {
    using_history();
    bash_add_history(rl_line_buffer);
    bash_add_history((char *)"");
    history_lines_this_session ++;
    using_history();
    tmp___0 = strlen("fc -e ${VISUAL:-${EDITOR:-vi}}");
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )"fc -e ${VISUAL:-${EDITOR:-vi}}");
    command = tmp___2;
    }
  }
  {
  r = parse_and_execute(command, (char *)"v", 4);
  *(rl_line_buffer + 0) = (char )'\000';
  }
  return (r);
}
}
static int posix_edit_macros(int count , int key ) 
{ 
  int c ;
  char alias_name[3] ;
  char *alias_value ;
  char *macro ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  c = rl_read_key();
  alias_name[0] = (char )'_';
  alias_name[1] = (char )c;
  alias_name[2] = (char )'\000';
  alias_value = get_alias_value(alias_name);
  }
  if (alias_value) {
    if (*alias_value) {
      {
      tmp = strlen((char const   *)alias_value);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )alias_value);
      macro = tmp___1;
      rl_push_macro_input(macro);
      }
    }
  }
  return (0);
}
}
static int check_redir(int ti ) 
{ 
  register int this_char ;
  register int prev_char ;
  int tmp ;

  {
  this_char = (int )*(rl_line_buffer + ti);
  prev_char = (int )*(rl_line_buffer + (ti - 1));
  if (this_char == 38) {
    if (prev_char == 60) {
      return (1);
    } else { //Added block
    if (prev_char == 62) {
      return (1);
    } else {
      goto _L___1;
    }
    }
  } else { //Added block
  _L___1: 
  if (this_char == 124) {
    if (prev_char == 62) {
      return (1);
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (this_char == 123) {
    if (prev_char == 36) {
      return (1);
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    tmp = char_is_quoted(rl_line_buffer, ti);
    }
    if (tmp) {
      return (1);
    }
  }
  }
  }
  return (0);
}
}
static int find_cmd_start(int start ) 
{ 
  register int s ;
  register int os ;

  {
  os = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    s = skip_to_delim(rl_line_buffer, os, (char *)";|&{(`");
    }
    if (s <= start) {
      if (! *(rl_line_buffer + s)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    os = s + 1;
  }
  while_break: /* CIL Label */ ;
  }
  return (os);
}
}
static int find_cmd_end(int end ) 
{ 
  register int e ;

  {
  {
  e = skip_to_delim(rl_line_buffer, end, (char *)";|&{(`");
  }
  return (e);
}
}
static char *find_cmd_name(int start ) 
{ 
  char *name ;
  register int s ;
  register int e ;

  {
  s = start;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*(rl_line_buffer + s) == 32)) {
      if (! ((int )*(rl_line_buffer + s) == 9)) {
        goto while_break;
      }
    }
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  e = skip_to_delim(rl_line_buffer, s, (char *)"()<>;&| \t\n");
  name = substring(rl_line_buffer, s, e);
  }
  return (name);
}
}
static int ind  ;
static char *prog_complete_return(char *text___0 , int matchnum ) 
{ 
  int tmp ;

  {
  if (matchnum == 0) {
    ind = 0;
  }
  if ((unsigned long )prog_complete_matches == (unsigned long )((char **)0)) {
    return ((char *)((void *)0));
  } else { //Added block
  if ((unsigned long )*(prog_complete_matches + ind) == (unsigned long )((char *)0)) {
    return ((char *)((void *)0));
  }
  }
  tmp = ind;
  ind ++;
  return (*(prog_complete_matches + tmp));
}
}
static char **attempt_shell_completion(char const   *text___0 , int start , int end ) 
{ 
  int in_command_position ;
  int ti ;
  int saveti ;
  int qc ;
  char **matches___1 ;
  char *command_separator_chars ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int s ;
  int e ;
  int foundcs ;
  char *n ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  command_separator_chars = (char *)";|&{(`";
  matches___1 = (char **)((void *)0);
  rl_ignore_some_completions_function = & filename_completion_ignore;
  ti = start - 1;
  qc = -1;
  saveti = qc;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (ti > -1) {
      if (! ((int )*(rl_line_buffer + ti) == 32)) {
        if (! ((int )*(rl_line_buffer + ti) == 9)) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
    ti --;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*(rl_line_buffer + ti) == 34) {
    goto _L;
  } else { //Added block
  if ((int )*(rl_line_buffer + ti) == 39) {
    _L: 
    qc = (int )*(rl_line_buffer + ti);
    tmp = ti;
    ti --;
    saveti = tmp;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (ti > -1) {
        if (! ((int )*(rl_line_buffer + ti) == 32)) {
          if (! ((int )*(rl_line_buffer + ti) == 9)) {
            goto while_break___0;
          }
        }
      } else {
        goto while_break___0;
      }
      ti --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  }
  in_command_position = 0;
  if (ti < 0) {
    if ((unsigned long )current_prompt_string == (unsigned long )ps1_prompt) {
      in_command_position ++;
    }
  } else {
    if (*(rl_line_buffer + ti)) {
      {
      tmp___1 = strchr((char const   *)command_separator_chars, (int )*(rl_line_buffer + ti));
      tmp___2 = (unsigned long )tmp___1 != (unsigned long )((char *)((void *)0));
      }
    } else {
      tmp___2 = 0;
    }
    if (tmp___2) {
      {
      in_command_position ++;
      tmp___0 = check_redir(ti);
      }
      if (tmp___0 == 1) {
        in_command_position = 0;
      }
    }
  }
  if (in_command_position) {
    if (ti >= 0) {
      if ((int )*(rl_line_buffer + ti) == 96) {
        if ((int const   )*text___0 != 96) {
          {
          tmp___3 = unclosed_pair(rl_line_buffer, end, (char *)"`");
          }
          if (tmp___3 == 0) {
            in_command_position = 0;
          }
        }
      }
    }
  }
  if ((int const   )*text___0 == 96) {
    if (in_command_position) {
      {
      matches___1 = rl_completion_matches(text___0, & command_subst_completion_function);
      }
    } else {
      {
      tmp___4 = unclosed_pair(rl_line_buffer, start, (char *)"`");
      }
      if (tmp___4) {
        {
        tmp___5 = unclosed_pair(rl_line_buffer, end, (char *)"`");
        }
        if (tmp___5) {
          {
          matches___1 = rl_completion_matches(text___0, & command_subst_completion_function);
          }
        }
      }
    }
  }
  if (! matches___1) {
    if (in_command_position == 0) {
      if (prog_completion_enabled) {
        {
        tmp___6 = num_progcomps();
        }
        if (tmp___6 > 0) {
          if ((unsigned long )current_prompt_string == (unsigned long )ps1_prompt) {
            if (prog_complete_matches) {
              {
              free((void *)prog_complete_matches);
              }
            }
            {
            prog_complete_matches = (char **)((void *)0);
            s = find_cmd_start(start);
            e = find_cmd_end(end);
            n = find_cmd_name(s);
            prog_complete_matches = programmable_completions((char const   *)n, text___0,
                                                             s, e, & foundcs);
            }
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (n) {
                {
                free((void *)n);
                }
              }
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
            if (foundcs) {
              {
              matches___1 = rl_completion_matches(text___0, (rl_compentry_func_t *)(& prog_complete_return));
              }
              if ((foundcs & (1 << 1)) == 0) {
                rl_attempted_completion_over = 1;
              }
              return (matches___1);
            }
          }
        }
      }
    }
  }
  if (! matches___1) {
    if ((int const   )*text___0 == 36) {
      if (qc != 39) {
        if ((int const   )*(text___0 + 1) == 40) {
          {
          matches___1 = rl_completion_matches(text___0, & command_subst_completion_function);
          }
        } else {
          {
          matches___1 = rl_completion_matches(text___0, & variable_completion_function);
          }
        }
      } else {
        {
        matches___1 = rl_completion_matches(text___0, & variable_completion_function);
        }
      }
    }
  }
  if (! matches___1) {
    if ((int const   )*text___0 == 126) {
      {
      tmp___7 = strchr(text___0, '/');
      }
      if (! tmp___7) {
        {
        matches___1 = rl_completion_matches(text___0, & rl_username_completion_function);
        }
      }
    }
  }
  if (! matches___1) {
    if (perform_hostname_completion) {
      if ((int const   )*text___0 == 64) {
        {
        matches___1 = rl_completion_matches(text___0, & hostname_completion_function);
        }
      }
    }
  }
  if (! matches___1) {
    if (in_command_position) {
      if (start == 0) {
        if (end == 0) {
          if ((int const   )*(text___0 + 0) == 0) {
            if (no_empty_command_completion) {
              matches___1 = (char **)((void *)0);
              rl_ignore_some_completions_function = & bash_ignore_everything;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        {
        matches___1 = rl_completion_matches(text___0, & command_word_completion_function);
        }
        if ((unsigned long )matches___1 == (unsigned long )((char **)((void *)0))) {
          rl_ignore_some_completions_function = & bash_ignore_filenames;
        }
      }
    }
  }
  if (! matches___1) {
    {
    tmp___8 = glob_pattern_p((char *)text___0);
    }
    if (tmp___8) {
      {
      matches___1 = rl_completion_matches(text___0, & glob_complete_word);
      }
      if (matches___1) {
        if (*(matches___1 + 1)) {
          {
          free_array(matches___1);
          matches___1 = (char **)0;
          }
        }
      }
    }
  }
  return (matches___1);
}
}
static char *hint  =    (char *)((void *)0);
static char *path  =    (char *)((void *)0);
static char *val  =    (char *)((void *)0);
static char *filename_hint  =    (char *)((void *)0);
static int path_index  ;
static int hint_len  ;
static int istate  ;
static int mapping_over  ;
static int local_index___0  ;
static SHELL_VAR **varlist  =    (SHELL_VAR **)((void *)0);
static alias_t **alias_list  =    (alias_t **)((void *)0);
char *command_word_completion_function(char const   *hint_text , int state ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  register char *alias ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  register char *reserved_word ;
  int tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  register char *varname___0 ;
  int tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int i ;
  int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  char *current_path ;
  size_t tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *t ;
  size_t tmp___42 ;
  int tmp___43 ;
  int match ;
  int freetemp ;
  char *temp___0 ;
  int tmp___44 ;
  int l ;
  int tl ;
  int vl ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  size_t tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;

  {
  if (! state) {
    if (hint) {
      {
      free((void *)hint);
      }
    }
    {
    mapping_over = 0;
    val = (char *)((void *)0);
    tmp___6 = absolute_program((char *)hint_text);
    }
    if (tmp___6) {
      if ((int const   )*hint_text == 126) {
        {
        hint = bash_tilde_expand((char *)hint_text);
        }
      } else {
        {
        tmp = strlen(hint_text);
        tmp___0 = xmalloc(1UL + tmp);
        tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )hint_text);
        hint = tmp___1;
        }
      }
      {
      tmp___2 = strlen((char const   *)hint);
      hint_len = (int )tmp___2;
      }
      if (filename_hint) {
        {
        free((void *)filename_hint);
        }
      }
      {
      tmp___3 = strlen((char const   *)hint);
      tmp___4 = xmalloc(1UL + tmp___3);
      tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )hint);
      filename_hint = tmp___5;
      mapping_over = 4;
      istate = 0;
      }
      goto inner;
    }
    {
    tmp___7 = strlen(hint_text);
    tmp___8 = xmalloc(1UL + tmp___7);
    tmp___9 = strcpy((char * __restrict  )tmp___8, (char const   * __restrict  )hint_text);
    hint = tmp___9;
    tmp___10 = strlen((char const   *)hint);
    hint_len = (int )tmp___10;
    path = get_string_value("PATH");
    path_index = 0;
    local_index___0 = 0;
    }
    if (varlist) {
      {
      free((void *)varlist);
      }
    }
    {
    varlist = all_visible_functions();
    }
    if (alias_list) {
      {
      free((void *)alias_list);
      }
    }
    {
    alias_list = all_aliases();
    }
  }
  {
  if (mapping_over == 0) {
    goto case_0;
  }
  if (mapping_over == 1) {
    goto case_1;
  }
  if (mapping_over == 2) {
    goto case_2;
  }
  if (mapping_over == 3) {
    goto case_3;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (alias_list) {
      if (! *(alias_list + local_index___0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    tmp___11 = local_index___0;
    local_index___0 ++;
    alias = (*(alias_list + tmp___11))->name;
    if (hint_len == 0) {
      tmp___17 = 1;
    } else {
      if ((int )*(alias + 0) == (int )*(hint + 0)) {
        {
        tmp___15 = strncmp((char const   *)alias, (char const   *)hint, (size_t )hint_len);
        }
        if (tmp___15 == 0) {
          tmp___16 = 1;
        } else {
          tmp___16 = 0;
        }
      } else {
        tmp___16 = 0;
      }
      tmp___17 = tmp___16;
    }
    if (tmp___17) {
      {
      tmp___12 = strlen((char const   *)alias);
      tmp___13 = xmalloc(1UL + tmp___12);
      tmp___14 = strcpy((char * __restrict  )tmp___13, (char const   * __restrict  )alias);
      }
      return (tmp___14);
    }
  }
  while_break: /* CIL Label */ ;
  }
  local_index___0 = 0;
  mapping_over ++;
  case_1: /* CIL Label */ 
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! word_token_alist[local_index___0].word) {
      goto while_break___0;
    }
    tmp___18 = local_index___0;
    local_index___0 ++;
    reserved_word = word_token_alist[tmp___18].word;
    if (hint_len == 0) {
      tmp___24 = 1;
    } else {
      if ((int )*(reserved_word + 0) == (int )*(hint + 0)) {
        {
        tmp___22 = strncmp((char const   *)reserved_word, (char const   *)hint, (size_t )hint_len);
        }
        if (tmp___22 == 0) {
          tmp___23 = 1;
        } else {
          tmp___23 = 0;
        }
      } else {
        tmp___23 = 0;
      }
      tmp___24 = tmp___23;
    }
    if (tmp___24) {
      {
      tmp___19 = strlen((char const   *)reserved_word);
      tmp___20 = xmalloc(1UL + tmp___19);
      tmp___21 = strcpy((char * __restrict  )tmp___20, (char const   * __restrict  )reserved_word);
      }
      return (tmp___21);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  local_index___0 = 0;
  mapping_over ++;
  case_2: /* CIL Label */ 
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (varlist) {
      if (! *(varlist + local_index___0)) {
        goto while_break___1;
      }
    } else {
      goto while_break___1;
    }
    tmp___25 = local_index___0;
    local_index___0 ++;
    varname___0 = (*(varlist + tmp___25))->name;
    if (hint_len == 0) {
      tmp___31 = 1;
    } else {
      if ((int )*(varname___0 + 0) == (int )*(hint + 0)) {
        {
        tmp___29 = strncmp((char const   *)varname___0, (char const   *)hint, (size_t )hint_len);
        }
        if (tmp___29 == 0) {
          tmp___30 = 1;
        } else {
          tmp___30 = 0;
        }
      } else {
        tmp___30 = 0;
      }
      tmp___31 = tmp___30;
    }
    if (tmp___31) {
      {
      tmp___26 = strlen((char const   *)varname___0);
      tmp___27 = xmalloc(1UL + tmp___26);
      tmp___28 = strcpy((char * __restrict  )tmp___27, (char const   * __restrict  )varname___0);
      }
      return (tmp___28);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  local_index___0 = 0;
  mapping_over ++;
  case_3: /* CIL Label */ 
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (local_index___0 < num_shell_builtins)) {
      goto while_break___2;
    }
    if (! (shell_builtins + local_index___0)->function) {
      goto __Cont;
    } else { //Added block
    if (((shell_builtins + local_index___0)->flags & 1) == 0) {
      goto __Cont;
    }
    }
    if (hint_len == 0) {
      tmp___38 = 1;
    } else {
      if ((int )*((shell_builtins + local_index___0)->name + 0) == (int )*(hint + 0)) {
        {
        tmp___36 = strncmp((char const   *)(shell_builtins + local_index___0)->name,
                           (char const   *)hint, (size_t )hint_len);
        }
        if (tmp___36 == 0) {
          tmp___37 = 1;
        } else {
          tmp___37 = 0;
        }
      } else {
        tmp___37 = 0;
      }
      tmp___38 = tmp___37;
    }
    if (tmp___38) {
      {
      tmp___32 = local_index___0;
      local_index___0 ++;
      i = tmp___32;
      tmp___33 = strlen((char const   *)(shell_builtins + i)->name);
      tmp___34 = xmalloc(1UL + tmp___33);
      tmp___35 = strcpy((char * __restrict  )tmp___34, (char const   * __restrict  )(shell_builtins + i)->name);
      }
      return (tmp___35);
    }
    __Cont: 
    local_index___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  local_index___0 = 0;
  mapping_over ++;
  switch_break: /* CIL Label */ ;
  }
  outer: 
  istate = (unsigned long )val != (unsigned long )((char *)((void *)0));
  if (! istate) {
    if (! path) {
      return ((char *)((void *)0));
    } else { //Added block
    if (! *(path + path_index)) {
      return ((char *)((void *)0));
    } else {
      {
      current_path = extract_colon_unit(path, & path_index);
      }
      if ((unsigned long )current_path == (unsigned long )((char *)0)) {
        return ((char *)((void *)0));
      }
    }
    }
    if ((int )*current_path == 0) {
      {
      free((void *)current_path);
      tmp___39 = strlen(".");
      tmp___40 = xmalloc(1UL + tmp___39);
      tmp___41 = strcpy((char * __restrict  )tmp___40, (char const   * __restrict  )".");
      current_path = tmp___41;
      }
    }
    if ((int )*current_path == 126) {
      {
      t = bash_tilde_expand(current_path);
      free((void *)current_path);
      current_path = t;
      }
    }
    if (filename_hint) {
      {
      free((void *)filename_hint);
      }
    }
    {
    tmp___42 = strlen((char const   *)current_path);
    filename_hint = xmalloc((2UL + tmp___42) + (size_t )hint_len);
    sprintf((char * __restrict  )filename_hint, (char const   * __restrict  )"%s/%s",
            current_path, hint);
    free((void *)current_path);
    }
  }
  inner: 
  {
  val = rl_filename_completion_function((char const   *)filename_hint, istate);
  istate = 1;
  }
  if ((unsigned long )val == (unsigned long )((char *)0)) {
    {
    tmp___43 = absolute_program(hint);
    }
    if (tmp___43) {
      return ((char *)((void *)0));
    }
    goto outer;
  } else {
    {
    tmp___54 = absolute_program(hint);
    }
    if (tmp___54) {
      {
      tmp___44 = strncmp((char const   *)val, (char const   *)hint, (size_t )hint_len);
      match = tmp___44 == 0;
      }
      if ((int const   )*hint_text == 126) {
        {
        tmp___45 = strlen((char const   *)val);
        vl = (int )tmp___45;
        tmp___46 = strlen(hint_text);
        tl = (int )tmp___46;
        l = vl - hint_len;
        temp___0 = xmalloc((size_t )((l + 2) + tl));
        strcpy((char * __restrict  )temp___0, (char const   * __restrict  )hint_text);
        strcpy((char * __restrict  )(temp___0 + tl), (char const   * __restrict  )((val + vl) - l));
        }
      } else {
        {
        tmp___47 = strlen((char const   *)val);
        tmp___48 = xmalloc(1UL + tmp___47);
        tmp___49 = strcpy((char * __restrict  )tmp___48, (char const   * __restrict  )val);
        temp___0 = tmp___49;
        }
      }
      freetemp = 1;
    } else {
      {
      temp___0 = strrchr((char const   *)val, '/');
      }
      if (temp___0) {
        {
        temp___0 ++;
        tmp___50 = strncmp((char const   *)temp___0, (char const   *)hint, (size_t )hint_len);
        match = tmp___50 == 0;
        freetemp = match;
        }
        if (match) {
          {
          tmp___51 = strlen((char const   *)temp___0);
          tmp___52 = xmalloc(1UL + tmp___51);
          tmp___53 = strcpy((char * __restrict  )tmp___52, (char const   * __restrict  )temp___0);
          temp___0 = tmp___53;
          }
        }
      } else {
        match = 0;
        freetemp = match;
      }
    }
    if (match) {
      {
      tmp___55 = executable_or_directory(val);
      }
      if (tmp___55) {
        {
        free((void *)val);
        val = (char *)"";
        }
        return (temp___0);
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (freetemp) {
        {
        free((void *)temp___0);
        }
      }
      {
      free((void *)val);
      }
      goto inner;
    }
  }
}
}
static char **matches  =    (char **)((void *)0);
static char const   *orig_start  ;
static char *filename_text  =    (char *)((void *)0);
static int cmd_index  ;
static int start_len  ;
static char *command_subst_completion_function(char const   *text___0 , int state ) 
{ 
  char *value ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  if (state == 0) {
    if (filename_text) {
      {
      free((void *)filename_text);
      }
    }
    orig_start = text___0;
    if ((int const   )*text___0 == 96) {
      text___0 ++;
    } else { //Added block
    if ((int const   )*text___0 == 36) {
      if ((int const   )*(text___0 + 1) == 40) {
        text___0 += 2;
      }
    }
    }
    {
    start_len = (int )(text___0 - orig_start);
    tmp = strlen(text___0);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )text___0);
    filename_text = tmp___1;
    }
    if (matches) {
      {
      free((void *)matches);
      }
    }
    {
    matches = rl_completion_matches((char const   *)filename_text, & command_word_completion_function);
    cmd_index = 0;
    }
  }
  if (! matches) {
    rl_filename_quoting_desired = 0;
    return ((char *)((void *)0));
  } else { //Added block
  if (! *(matches + cmd_index)) {
    rl_filename_quoting_desired = 0;
    return ((char *)((void *)0));
  } else {
    {
    tmp___2 = strlen((char const   *)*(matches + cmd_index));
    value = xmalloc((size_t )(1 + start_len) + tmp___2);
    }
    if (start_len == 1) {
      *(value + 0) = (char )*orig_start;
    } else {
      {
      strncpy((char * __restrict  )value, (char const   * __restrict  )orig_start,
              (size_t )start_len);
      }
    }
    {
    strcpy((char * __restrict  )(value + start_len), (char const   * __restrict  )*(matches + cmd_index));
    cmd_index ++;
    }
    return (value);
  }
  }
}
}
static char **varlist___0  =    (char **)((void *)0);
static int varlist_index  ;
static char *varname  =    (char *)((void *)0);
static int namelen  ;
static int first_char  ;
static int first_char_loc  ;
static char *variable_completion_function(char const   *text___0 , int state ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *value ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  if (! state) {
    if (varname) {
      {
      free((void *)varname);
      }
    }
    first_char_loc = 0;
    first_char = (int )*(text___0 + 0);
    if (first_char == 36) {
      first_char_loc ++;
    }
    if ((int const   )*(text___0 + first_char_loc) == 123) {
      first_char_loc ++;
    }
    {
    tmp = strlen(text___0 + first_char_loc);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )(text___0 + first_char_loc));
    varname = tmp___1;
    tmp___2 = strlen((char const   *)varname);
    namelen = (int )tmp___2;
    }
    if (varlist___0) {
      {
      free_array(varlist___0);
      }
    }
    {
    varlist___0 = all_variables_matching_prefix(varname);
    varlist_index = 0;
    }
  }
  if (! varlist___0) {
    return ((char *)((void *)0));
  } else { //Added block
  if (! *(varlist___0 + varlist_index)) {
    return ((char *)((void *)0));
  } else {
    {
    tmp___3 = strlen((char const   *)*(varlist___0 + varlist_index));
    tmp___4 = xmalloc(4UL + tmp___3);
    value = tmp___4;
    }
    if (first_char_loc) {
      *(value + 0) = (char )first_char;
      if (first_char_loc == 2) {
        *(value + 1) = (char )'{';
      }
    }
    {
    strcpy((char * __restrict  )(value + first_char_loc), (char const   * __restrict  )*(varlist___0 + varlist_index));
    }
    if (first_char_loc == 2) {
      {
      strcat((char * __restrict  )value, (char const   * __restrict  )"}");
      }
    }
    varlist_index ++;
    return (value);
  }
  }
}
}
static char **list  =    (char **)((void *)0);
static int list_index  =    0;
static int first_char___0  ;
static int first_char_loc___0  ;
static char *hostname_completion_function(char const   *text___0 , int state ) 
{ 
  char *t ;
  size_t tmp ;

  {
  if (state == 0) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (list) {
        {
        free((void *)list);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    list = (char **)((void *)0);
    first_char_loc___0 = 0;
    first_char___0 = (int )*text___0;
    if (first_char___0 == 64) {
      first_char_loc___0 ++;
    }
    {
    list = hostnames_matching((char *)(text___0 + first_char_loc___0));
    list_index = 0;
    }
  }
  if (list) {
    if (*(list + list_index)) {
      {
      tmp = strlen((char const   *)*(list + list_index));
      t = xmalloc(2UL + tmp);
      *t = (char )first_char___0;
      strcpy((char * __restrict  )(t + first_char_loc___0), (char const   * __restrict  )*(list + list_index));
      list_index ++;
      }
      return (t);
    }
  }
  return ((char *)((void *)0));
}
}
static char *history_expand_line_internal(char *line ) 
{ 
  char *new_line ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  new_line = pre_process_line(line, 0, 0);
  }
  if ((unsigned long )new_line == (unsigned long )line) {
    {
    tmp = strlen((char const   *)line);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )line);
    tmp___2 = tmp___1;
    }
  } else {
    tmp___2 = new_line;
  }
  return (tmp___2);
}
}
static void cleanup_expansion_error(void) 
{ 
  char *to_free ;

  {
  {
  fprintf((FILE * __restrict  )rl_outstream, (char const   * __restrict  )"\r\n");
  to_free = pre_process_line(rl_line_buffer, 1, 0);
  }
  if ((unsigned long )to_free != (unsigned long )rl_line_buffer) {
    {
    free((void *)to_free);
    }
  }
  {
  _IO_putc('\r', rl_outstream);
  rl_forced_update_display();
  }
  return;
}
}
static void maybe_make_readline_line(char *new_line ) 
{ 
  int tmp ;

  {
  {
  tmp = strcmp((char const   *)new_line, (char const   *)rl_line_buffer);
  }
  if (tmp != 0) {
    {
    rl_point = rl_end;
    rl_add_undo((enum undo_code )2, 0, 0, (char *)0);
    rl_delete_text(0, rl_point);
    rl_end = 0;
    rl_point = rl_end;
    rl_insert_text((char const   *)new_line);
    rl_add_undo((enum undo_code )3, 0, 0, (char *)0);
    }
  }
  return;
}
}
static void set_up_new_line(char *new_line ) 
{ 
  int old_point ;
  int at_end ;

  {
  {
  old_point = rl_point;
  at_end = rl_point == rl_end;
  maybe_make_readline_line(new_line);
  free((void *)new_line);
  }
  if (at_end) {
    rl_point = rl_end;
  } else { //Added block
  if (old_point < rl_end) {
    rl_point = old_point;
    if (! ((int )*(rl_line_buffer + rl_point) == 32)) {
      if (! ((int )*(rl_line_buffer + rl_point) == 9)) {
        {
        rl_forward_word(1, 0);
        }
      }
    }
  }
  }
  return;
}
}
static int alias_expand_line(int count , int ignore ) 
{ 
  char *new_line ;

  {
  {
  new_line = alias_expand(rl_line_buffer);
  }
  if (new_line) {
    {
    set_up_new_line(new_line);
    }
    return (0);
  } else {
    {
    cleanup_expansion_error();
    }
    return (1);
  }
}
}
static int history_expand_line(int count , int ignore ) 
{ 
  char *new_line ;

  {
  {
  new_line = history_expand_line_internal(rl_line_buffer);
  }
  if (new_line) {
    {
    set_up_new_line(new_line);
    }
    return (0);
  } else {
    {
    cleanup_expansion_error();
    }
    return (1);
  }
}
}
static int tcsh_magic_space(int count , int ignore ) 
{ 
  int dist_from_end ;
  int old_point ;
  int tmp ;

  {
  {
  old_point = rl_point;
  dist_from_end = rl_end - rl_point;
  tmp = history_expand_line(count, ignore);
  }
  if (tmp == 0) {
    if (old_point == 0) {
      rl_point = old_point;
    } else {
      rl_point = rl_end - dist_from_end;
    }
    {
    rl_insert(1, ' ');
    }
    return (0);
  } else {
    return (1);
  }
}
}
static int history_and_alias_expand_line(int count , int ignore ) 
{ 
  char *new_line ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *alias_line ;

  {
  {
  new_line = pre_process_line(rl_line_buffer, 0, 0);
  }
  if ((unsigned long )new_line == (unsigned long )rl_line_buffer) {
    {
    tmp = strlen((char const   *)new_line);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )new_line);
    new_line = tmp___1;
    }
  }
  if (new_line) {
    {
    alias_line = alias_expand(new_line);
    free((void *)new_line);
    new_line = alias_line;
    }
  }
  if (new_line) {
    {
    set_up_new_line(new_line);
    }
    return (0);
  } else {
    {
    cleanup_expansion_error();
    }
    return (1);
  }
}
}
static int shell_expand_line(int count , int ignore ) 
{ 
  char *new_line ;
  WORD_LIST *expanded_string ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *alias_line ;
  int old_point ;
  int at_end ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
  new_line = pre_process_line(rl_line_buffer, 0, 0);
  }
  if ((unsigned long )new_line == (unsigned long )rl_line_buffer) {
    {
    tmp = strlen((char const   *)new_line);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )new_line);
    new_line = tmp___1;
    }
  }
  if (new_line) {
    {
    alias_line = alias_expand(new_line);
    free((void *)new_line);
    new_line = alias_line;
    }
  }
  if (new_line) {
    {
    old_point = rl_point;
    at_end = rl_point == rl_end;
    maybe_make_readline_line(new_line);
    free((void *)new_line);
    tmp___2 = strlen((char const   *)rl_line_buffer);
    tmp___3 = xmalloc(1UL + tmp___2);
    tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )rl_line_buffer);
    new_line = tmp___4;
    expanded_string = expand_string(new_line, 0);
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (new_line) {
        {
        free((void *)new_line);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    if ((unsigned long )expanded_string == (unsigned long )((WORD_LIST *)0)) {
      {
      new_line = xmalloc((size_t )1);
      *(new_line + 0) = (char )'\000';
      }
    } else {
      {
      new_line = string_list(expanded_string);
      dispose_words(expanded_string);
      }
    }
    {
    maybe_make_readline_line(new_line);
    free((void *)new_line);
    }
    if (at_end) {
      rl_point = rl_end;
    } else { //Added block
    if (old_point < rl_end) {
      rl_point = old_point;
      if (! ((int )*(rl_line_buffer + rl_point) == 32)) {
        if (! ((int )*(rl_line_buffer + rl_point) == 9)) {
          {
          rl_forward_word(1, 0);
          }
        }
      }
    }
    }
    return (0);
  } else {
    {
    cleanup_expansion_error();
    }
    return (1);
  }
}
}
static struct ignorevar fignore  =    {(char *)"FIGNORE", (struct ign *)0, 0, (char *)0, (Function *)0};
static void _ignore_completion_names(char **names , Function *name_func ) 
{ 
  char **newnames ;
  int idx ;
  int nidx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )*(names + 1) == (unsigned long )((char *)0)) {
    {
    tmp = (*name_func)(*(names + 0));
    }
    if (tmp == 0) {
      {
      free((void *)*(names + 0));
      *(names + 0) = (char *)((void *)0);
      }
    }
    return;
  }
  nidx = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(names + nidx)) {
      goto while_break;
    }
    nidx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  newnames = alloc_array(nidx + 1);
  *(newnames + 0) = *(names + 0);
  nidx = 1;
  idx = nidx;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *(names + idx)) {
      goto while_break___0;
    }
    {
    tmp___1 = (*name_func)(*(names + idx));
    }
    if (tmp___1) {
      tmp___0 = nidx;
      nidx ++;
      *(newnames + tmp___0) = *(names + idx);
    } else {
      {
      free((void *)*(names + idx));
      }
    }
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *(newnames + nidx) = (char *)((void *)0);
  if (nidx == 1) {
    {
    free((void *)*(names + 0));
    *(names + 0) = (char *)((void *)0);
    free((void *)newnames);
    }
    return;
  }
  if (nidx == 2) {
    {
    free((void *)*(names + 0));
    *(names + 0) = *(newnames + 1);
    *(names + 1) = (char *)((void *)0);
    free((void *)newnames);
    }
    return;
  }
  nidx = 1;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! *(newnames + nidx)) {
      goto while_break___1;
    }
    *(names + nidx) = *(newnames + nidx);
    nidx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  *(names + nidx) = (char *)((void *)0);
  free((void *)newnames);
  }
  return;
}
}
static int name_is_acceptable(char *name ) 
{ 
  struct ign *p ;
  int nlen ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen((char const   *)name);
  nlen = (int )tmp;
  p = fignore.ignores;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! p->val) {
      goto while_break;
    }
    if (nlen > p->len) {
      if (p->len > 0) {
        if ((int )*(p->val + 0) == (int )*((name + (nlen - p->len)) + 0)) {
          {
          tmp___0 = strcmp((char const   *)p->val, (char const   *)(name + (nlen - p->len)));
          }
          if (tmp___0 == 0) {
            return (0);
          }
        }
      }
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int filename_completion_ignore(char **names ) 
{ 


  {
  {
  setup_ignore_patterns(& fignore);
  }
  if (fignore.num_ignores == 0) {
    return (0);
  }
  {
  _ignore_completion_names(names, (Function *)(& name_is_acceptable));
  }
  return (0);
}
}
static int test_for_directory(char *name ) 
{ 
  struct stat finfo ;
  char *fn ;
  int tmp ;

  {
  {
  fn = bash_tilde_expand(name);
  tmp = stat((char const   * __restrict  )fn, (struct stat * __restrict  )(& finfo));
  }
  if (tmp != 0) {
    {
    free((void *)fn);
    }
    return (0);
  }
  {
  free((void *)fn);
  }
  return ((finfo.st_mode & 61440U) == 16384U);
}
}
static int bash_ignore_filenames(char **names ) 
{ 


  {
  {
  _ignore_completion_names(names, (Function *)(& test_for_directory));
  }
  return (0);
}
}
static int return_zero(char *name ) 
{ 


  {
  return (0);
}
}
static int bash_ignore_everything(char **names ) 
{ 


  {
  {
  _ignore_completion_names(names, (Function *)(& return_zero));
  }
  return (0);
}
}
static int bash_directory_completion_hook(char **dirname ) 
{ 
  char *local_dirname ;
  char *new_dirname ;
  char *t ;
  int return_value ;
  int should_expand_dirname ;
  WORD_LIST *wl ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *temp1 ;
  char *temp2 ;
  int len1 ;
  int len2 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
  should_expand_dirname = 0;
  return_value = should_expand_dirname;
  local_dirname = *dirname;
  tmp___1 = strchr((char const   *)local_dirname, '$');
  }
  if (tmp___1) {
    should_expand_dirname = 1;
  } else {
    {
    t = strchr((char const   *)local_dirname, '`');
    }
    if (t) {
      {
      tmp = strlen((char const   *)local_dirname);
      tmp___0 = unclosed_pair(local_dirname, (int )tmp, (char *)"`");
      }
      if (tmp___0 == 0) {
        should_expand_dirname = 1;
      }
    }
  }
  if (should_expand_dirname) {
    {
    tmp___2 = strlen((char const   *)local_dirname);
    tmp___3 = xmalloc(1UL + tmp___2);
    tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )local_dirname);
    new_dirname = tmp___4;
    wl = expand_string(new_dirname, 0);
    }
    if (wl) {
      {
      *dirname = string_list(wl);
      }
      if ((int )*(local_dirname + 0) == (int )*(*dirname + 0)) {
        {
        tmp___5 = strcmp((char const   *)local_dirname, (char const   *)*dirname);
        }
        if (tmp___5 == 0) {
          tmp___6 = 1;
        } else {
          tmp___6 = 0;
        }
      } else {
        tmp___6 = 0;
      }
      {
      return_value = tmp___6 == 0;
      free((void *)local_dirname);
      free((void *)new_dirname);
      dispose_words(wl);
      local_dirname = *dirname;
      }
    } else {
      {
      free((void *)new_dirname);
      free((void *)local_dirname);
      *dirname = xmalloc((size_t )1);
      *(*dirname) = (char )'\000';
      }
      return (1);
    }
  }
  if (! no_symbolic_links) {
    if ((int )*(local_dirname + 0) != 46) {
      goto _L;
    } else { //Added block
    if (*(local_dirname + 1)) {
      _L: 
      {
      t = get_working_directory((char *)"symlink-hook");
      temp1 = make_absolute(local_dirname, t);
      free((void *)t);
      temp2 = sh_canonpath(temp1, 3);
      }
      if ((unsigned long )temp2 == (unsigned long )((char *)0)) {
        {
        free((void *)temp1);
        }
        return (1);
      }
      {
      tmp___7 = strlen((char const   *)temp1);
      len1 = (int )tmp___7;
      }
      if ((int )*(temp1 + (len1 - 1)) == 47) {
        {
        tmp___8 = strlen((char const   *)temp2);
        len2 = (int )tmp___8;
        temp2 = xrealloc((void *)temp2, (size_t )(len2 + 2));
        *(temp2 + len2) = (char )'/';
        *(temp2 + (len2 + 1)) = (char )'\000';
        }
      }
      {
      free((void *)local_dirname);
      *dirname = temp2;
      free((void *)temp1);
      }
    }
    }
  }
  return (return_value);
}
}
static char **history_completion_array  =    (char **)((void *)0);
static int harry_size  ;
static int harry_len  ;
static void build_history_completion_array(void) 
{ 
  register int i ;
  register int j ;
  HIST_ENTRY **hlist ;
  char **tokens ;
  char *tmp ;
  int tmp___0 ;

  {
  if (harry_size) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *(history_completion_array + i)) {
        goto while_break;
      }
      {
      free((void *)*(history_completion_array + i));
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    free((void *)history_completion_array);
    history_completion_array = (char **)((void *)0);
    harry_size = 0;
    harry_len = 0;
    }
  }
  {
  hlist = history_list();
  }
  if (hlist) {
    i = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *(hlist + i)) {
        goto while_break___0;
      }
      {
      tokens = history_tokenize((char const   *)(*(hlist + i))->line);
      j = 0;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (tokens) {
          if (! *(tokens + j)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        if (harry_len + 2 > harry_size) {
          {
          harry_size += 10;
          tmp = xrealloc((void *)history_completion_array, (unsigned long )harry_size * sizeof(char *));
          history_completion_array = (char **)tmp;
          }
        }
        tmp___0 = harry_len;
        harry_len ++;
        *(history_completion_array + tmp___0) = *(tokens + j);
        *(history_completion_array + harry_len) = (char *)((void *)0);
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      free((void *)tokens);
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    qsort((void *)history_completion_array, (size_t )harry_len, sizeof(char *), (int (*)(void const   * ,
                                                                                         void const   * ))(& qsort_string_compare));
    }
  }
  return;
}
}
static int local_index___1  ;
static int len  ;
static char *text  ;
static char *history_completion_generator(char *hint_text , int state ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (state == 0) {
    {
    local_index___1 = 0;
    build_history_completion_array();
    text = hint_text;
    tmp = strlen((char const   *)text);
    len = (int )tmp;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (history_completion_array) {
      if (! *(history_completion_array + local_index___1)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp___3 = local_index___1;
    local_index___1 ++;
    tmp___4 = strncmp((char const   *)text, (char const   *)*(history_completion_array + tmp___3),
                      (size_t )len);
    }
    if (tmp___4 == 0) {
      {
      tmp___0 = strlen((char const   *)*(history_completion_array + (local_index___1 - 1)));
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )*(history_completion_array + (local_index___1 - 1)));
      }
      return (tmp___2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((char *)((void *)0));
}
}
static int dynamic_complete_history(int count , int key ) 
{ 
  rl_compentry_func_t *orig_func ;
  rl_completion_func_t *orig_attempt_func ;

  {
  orig_func = rl_completion_entry_function;
  orig_attempt_func = rl_attempted_completion_function;
  rl_completion_entry_function = (rl_compentry_func_t *)(& history_completion_generator);
  rl_attempted_completion_function = (rl_completion_func_t *)((void *)0);
  if ((unsigned long )rl_last_func == (unsigned long )(& dynamic_complete_history)) {
    {
    rl_complete_internal('?');
    }
  } else {
    {
    rl_complete_internal('\t');
    }
  }
  rl_completion_entry_function = orig_func;
  rl_attempted_completion_function = orig_attempt_func;
  return (0);
}
}
static int bash_complete_username(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_username_internal('\t');
  }
  return (tmp);
}
}
static int bash_possible_username_completions(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_username_internal('?');
  }
  return (tmp);
}
}
static int bash_complete_username_internal(int what_to_do ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_specific_completion(what_to_do, & rl_username_completion_function);
  }
  return (tmp);
}
}
static int bash_complete_filename(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_filename_internal('\t');
  }
  return (tmp);
}
}
static int bash_possible_filename_completions(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_filename_internal('?');
  }
  return (tmp);
}
}
static int bash_complete_filename_internal(int what_to_do ) 
{ 
  rl_compentry_func_t *orig_func ;
  rl_completion_func_t *orig_attempt_func ;
  rl_icppfunc_t *orig_dir_func ;
  char const   *orig_rl_completer_word_break_characters ;
  int r ;

  {
  {
  orig_func = rl_completion_entry_function;
  orig_attempt_func = rl_attempted_completion_function;
  orig_dir_func = rl_directory_completion_hook;
  orig_rl_completer_word_break_characters = rl_completer_word_break_characters;
  rl_completion_entry_function = & rl_filename_completion_function;
  rl_attempted_completion_function = (rl_completion_func_t *)((void *)0);
  rl_directory_completion_hook = (rl_icppfunc_t *)((void *)0);
  rl_completer_word_break_characters = " \t\n\"\'";
  r = rl_complete_internal(what_to_do);
  rl_completion_entry_function = orig_func;
  rl_attempted_completion_function = orig_attempt_func;
  rl_directory_completion_hook = orig_dir_func;
  rl_completer_word_break_characters = orig_rl_completer_word_break_characters;
  }
  return (r);
}
}
static int bash_complete_hostname(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_hostname_internal('\t');
  }
  return (tmp);
}
}
static int bash_possible_hostname_completions(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_hostname_internal('?');
  }
  return (tmp);
}
}
static int bash_complete_variable(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_variable_internal('\t');
  }
  return (tmp);
}
}
static int bash_possible_variable_completions(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_variable_internal('?');
  }
  return (tmp);
}
}
static int bash_complete_command(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_command_internal('\t');
  }
  return (tmp);
}
}
static int bash_possible_command_completions(int ignore , int ignore2 ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_complete_command_internal('?');
  }
  return (tmp);
}
}
static int bash_complete_hostname_internal(int what_to_do ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_specific_completion(what_to_do, & hostname_completion_function);
  }
  return (tmp);
}
}
static int bash_complete_variable_internal(int what_to_do ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_specific_completion(what_to_do, & variable_completion_function);
  }
  return (tmp);
}
}
static int bash_complete_command_internal(int what_to_do ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_specific_completion(what_to_do, & command_word_completion_function);
  }
  return (tmp);
}
}
static char **matches___0  =    (char **)((void *)0);
static int ind___0  ;
static char *glob_complete_word(char const   *text___0 , int state ) 
{ 
  char *ret ;

  {
  if (state == 0) {
    rl_filename_completion_desired = 1;
    if (matches___0) {
      {
      free((void *)matches___0);
      }
    }
    {
    matches___0 = shell_glob_filename(text___0);
    }
    if ((unsigned long )matches___0 == (unsigned long )(& glob_error_return)) {
      matches___0 = (char **)((void *)0);
    }
    ind___0 = 0;
  }
  if (matches___0) {
    ret = *(matches___0 + ind___0);
  } else {
    ret = (char *)((void *)0);
  }
  ind___0 ++;
  return (ret);
}
}
static int bash_glob_completion_internal(int what_to_do ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_specific_completion(what_to_do, & glob_complete_word);
  }
  return (tmp);
}
}
static int bash_glob_expand_word(int count , int key ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_glob_completion_internal('*');
  }
  return (tmp);
}
}
static int bash_glob_list_expansions(int count , int key ) 
{ 
  int tmp ;

  {
  {
  tmp = bash_glob_completion_internal('?');
  }
  return (tmp);
}
}
static int bash_specific_completion(int what_to_do , rl_compentry_func_t *generator ) 
{ 
  rl_compentry_func_t *orig_func ;
  rl_completion_func_t *orig_attempt_func ;
  int r ;

  {
  {
  orig_func = rl_completion_entry_function;
  orig_attempt_func = rl_attempted_completion_function;
  rl_completion_entry_function = generator;
  rl_attempted_completion_function = (rl_completion_func_t *)((void *)0);
  r = rl_complete_internal(what_to_do);
  rl_completion_entry_function = orig_func;
  rl_attempted_completion_function = orig_attempt_func;
  }
  return (r);
}
}
static char *bash_dequote_filename(char *text___0 , int quote_char ) 
{ 
  char *ret ;
  char *p ;
  char *r ;
  int l ;
  int quoted ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp = strlen((char const   *)text___0);
  l = (int )tmp;
  ret = xmalloc((size_t )(l + 1));
  quoted = quote_char;
  p = text___0;
  r = ret;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (p) {
      if (! *p) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p == 92) {
      tmp___0 = r;
      r ++;
      p ++;
      *tmp___0 = *p;
      if ((int )*p == 0) {
        goto while_break;
      }
      goto __Cont;
    }
    if (quoted) {
      if ((int )*p == quoted) {
        quoted = 0;
        goto __Cont;
      }
    }
    if (quoted == 0) {
      if ((int )*p == 39) {
        quoted = (int )*p;
        goto __Cont;
      } else { //Added block
      if ((int )*p == 34) {
        quoted = (int )*p;
        goto __Cont;
      }
      }
    }
    tmp___1 = r;
    r ++;
    *tmp___1 = *p;
    __Cont: 
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  *r = (char )'\000';
  return (ret);
}
}
static char *quote_word_break_chars(char *text___0 ) 
{ 
  char *ret ;
  char *r ;
  char *s ;
  int l ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
  tmp = strlen((char const   *)text___0);
  l = (int )tmp;
  ret = xmalloc((size_t )(2 * l + 1));
  s = text___0;
  r = ret;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    if ((int )*s == 92) {
      tmp___0 = r;
      r ++;
      *tmp___0 = (char )'\\';
      tmp___1 = r;
      r ++;
      s ++;
      *tmp___1 = *s;
      if ((int )*s == 0) {
        goto while_break;
      }
      goto __Cont;
    }
    {
    tmp___3 = strchr(rl_completer_word_break_characters, (int )*s);
    }
    if (tmp___3) {
      tmp___2 = r;
      r ++;
      *tmp___2 = (char )'\\';
    }
    tmp___4 = r;
    r ++;
    *tmp___4 = *s;
    __Cont: 
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  *r = (char )'\000';
  return (ret);
}
}
static char *bash_quote_filename(char *s , int rtype , char *qcp ) 
{ 
  char *rtext ;
  char *mtext ;
  char *ret ;
  int rlen ;
  int cs ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  rtext = (char *)((void *)0);
  mtext = s;
  if ((int )*(mtext + 0) == 126) {
    if (rtype == 1) {
      {
      mtext = bash_tilde_expand(s);
      }
    }
  }
  cs = completion_quoting_style;
  if ((int )*qcp == 0) {
    if (cs == 3) {
      {
      tmp___0 = strchr((char const   *)mtext, '\n');
      }
      if (tmp___0) {
        cs = 2;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((int )*qcp == 34) {
    cs = 1;
  } else { //Added block
  if ((int )*qcp == 39) {
    cs = 2;
  } else { //Added block
  if ((int )*qcp == 0) {
    if (history_expansion) {
      if (cs == 1) {
        if (history_expansion_inhibited == 0) {
          {
          tmp = strchr((char const   *)mtext, '!');
          }
          if (tmp) {
            cs = 3;
          }
        }
      }
    }
  }
  }
  }
  }
  if ((int )*qcp == 34) {
    if (history_expansion) {
      if (cs == 1) {
        if (history_expansion_inhibited == 0) {
          {
          tmp___1 = strchr((char const   *)mtext, '!');
          }
          if (tmp___1) {
            cs = 3;
            *qcp = (char )'\000';
          }
        }
      }
    }
  }
  {
  if (cs == 1) {
    goto case_1;
  }
  if (cs == 2) {
    goto case_2;
  }
  if (cs == 3) {
    goto case_3;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  rtext = sh_double_quote(mtext);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  rtext = sh_single_quote(mtext);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  rtext = sh_backslash_quote(mtext);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if ((unsigned long )mtext != (unsigned long )s) {
    {
    free((void *)mtext);
    }
  }
  if (rtext) {
    if (cs == 3) {
      {
      mtext = quote_word_break_chars(rtext);
      free((void *)rtext);
      rtext = mtext;
      }
    }
  }
  {
  tmp___2 = strlen((char const   *)rtext);
  rlen = (int )tmp___2;
  ret = xmalloc((size_t )(rlen + 1));
  strcpy((char * __restrict  )ret, (char const   * __restrict  )rtext);
  }
  if (rtype == 2) {
    if (cs != 3) {
      *(ret + (rlen - 1)) = (char )'\000';
    }
  }
  {
  free((void *)rtext);
  }
  return (ret);
}
}
static Keymap cmd_xmap  ;
static int bash_execute_unix_command(int count , int key ) 
{ 
  Keymap ckmap ;
  Keymap xkmap ;
  register int i ;
  char *cmd ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  ckmap = rl_get_keymap();
  }
  if ((unsigned long )ckmap != (unsigned long )rl_executing_keymap) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < 256)) {
        goto while_break;
      }
      if ((int )(ckmap + i)->type == 1) {
        if ((unsigned long )((Keymap )(ckmap + i)->function) == (unsigned long )rl_executing_keymap) {
          goto while_break;
        }
      }
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (i < 256) {
      xkmap = (Keymap )(cmd_xmap + i)->function;
    } else {
      {
      rl_crlf();
      internal_error("bash_execute_unix_command: cannot find keymap for command");
      rl_forced_update_display();
      }
      return (1);
    }
  } else {
    xkmap = cmd_xmap;
  }
  cmd = (char *)(xkmap + key)->function;
  if ((unsigned long )cmd == (unsigned long )((char *)0)) {
    {
    rl_ding();
    }
    return (1);
  }
  {
  rl_crlf();
  tmp = strlen((char const   *)cmd);
  tmp___0 = xmalloc(1UL + tmp);
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )cmd);
  cmd = tmp___1;
  parse_and_execute(cmd, (char *)"bash_execute_unix_command", 0);
  rl_forced_update_display();
  }
  return (0);
}
}
static void init_unix_command_map(void) 
{ 


  {
  {
  cmd_xmap = rl_make_bare_keymap();
  }
  return;
}
}
static int isolate_sequence(char *string , int ind___1 , int need_dquote , int *startp ) 
{ 
  register int i ;
  int c ;
  int passc ;
  int delim ;

  {
  i = ind___1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(string + i)) {
      if (! ((int )*(string + i) == 32)) {
        if (! ((int )*(string + i) == 9)) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (need_dquote) {
    if ((int )*(string + i) != 34) {
      {
      builtin_error("%s: first non-whitespace character is not `\"\'", string);
      }
      return (-1);
    }
  }
  if ((int )*(string + i) == 34) {
    delim = (int )*(string + i);
  } else { //Added block
  if ((int )*(string + i) == 39) {
    delim = (int )*(string + i);
  } else {
    delim = 0;
  }
  }
  if (startp) {
    if (delim) {
      i ++;
      *startp = i;
    } else {
      *startp = i;
    }
  }
  passc = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    c = (int )*(string + i);
    if (! c) {
      goto while_break___0;
    }
    if (passc) {
      passc = 0;
      goto __Cont;
    }
    if (c == 92) {
      passc ++;
      goto __Cont;
    }
    if (c == delim) {
      goto while_break___0;
    }
    __Cont: 
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (delim) {
    if ((int )*(string + i) != delim) {
      {
      builtin_error("%s: no closing `%c\'", string, delim);
      }
      return (-1);
    }
  }
  return (i);
}
}
int bind_keyseq_to_unix_command(char *line ) 
{ 
  Keymap kmap ;
  char *kseq ;
  char *value ;
  int i ;
  int kstart ;

  {
  if ((unsigned long )cmd_xmap == (unsigned long )((Keymap )0)) {
    {
    init_unix_command_map();
    }
  }
  {
  kmap = rl_get_keymap();
  i = isolate_sequence(line, 0, 1, & kstart);
  }
  if (i < 0) {
    return (-1);
  }
  {
  kseq = substring(line, kstart, i);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(line + i)) {
      if (! ((int )*(line + i) != 58)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*(line + i) != 58) {
    {
    builtin_error("%s: missing colon separator", line);
    }
    return (-1);
  }
  {
  i = isolate_sequence(line, i + 1, 0, & kstart);
  }
  if (i < 0) {
    return (-1);
  }
  {
  value = substring(line, kstart, i);
  rl_generic_bind(2, (char const   *)kseq, value, cmd_xmap);
  rl_set_key((char const   *)kseq, & bash_execute_unix_command, kmap);
  }
  return (0);
}
}
char **bash_directory_completion_matches(char const   *text___0 ) 
{ 
  char **m1 ;
  char *dfn___0 ;
  int qc ;

  {
  if ((int const   )*(text___0 + 0) == 34) {
    qc = (int )*(text___0 + 0);
  } else { //Added block
  if ((int const   )*(text___0 + 0) == 39) {
    qc = (int )*(text___0 + 0);
  } else {
    qc = 0;
  }
  }
  {
  dfn___0 = bash_dequote_filename((char *)text___0, qc);
  m1 = rl_completion_matches((char const   *)dfn___0, & rl_filename_completion_function);
  free((void *)dfn___0);
  }
  if ((unsigned long )m1 == (unsigned long )((char **)0)) {
    return (m1);
  } else { //Added block
  if ((unsigned long )*(m1 + 0) == (unsigned long )((char *)0)) {
    return (m1);
  }
  }
  {
  bash_ignore_filenames(m1);
  }
  return (m1);
}
}
#pragma merger("0","/tmp/cil-aBb1FvZS.i","-g")
#pragma merger("0","/tmp/cil-60sDR9BX.i","-g")
GENERIC_LIST global_error_list  ;
GENERIC_LIST *reverse_list(GENERIC_LIST *list___0 ) 
{ 
  register GENERIC_LIST *next ;
  register GENERIC_LIST *prev ;

  {
  prev = (GENERIC_LIST *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    next = list___0->next;
    list___0->next = prev;
    prev = list___0;
    list___0 = next;
  }
  while_break: /* CIL Label */ ;
  }
  return (prev);
}
}
int list_length(GENERIC_LIST *list___0 ) 
{ 
  register int i ;

  {
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! list___0) {
      goto while_break;
    }
    list___0 = list___0->next;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (i);
}
}
GENERIC_LIST *list_append(GENERIC_LIST *head , GENERIC_LIST *tail ) 
{ 
  register GENERIC_LIST *t_head ;

  {
  if ((unsigned long )head == (unsigned long )((GENERIC_LIST *)0)) {
    return (tail);
  }
  t_head = head;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! t_head->next) {
      goto while_break;
    }
    t_head = t_head->next;
  }
  while_break: /* CIL Label */ ;
  }
  t_head->next = tail;
  return (head);
}
}
#pragma merger("0","/tmp/cil-qAaCltbs.i","-g")
int find_string_in_alist(char *string , STRING_INT_ALIST *alist , int flags ) ;
char *strsub(char *string , char *pat , char *rep , int global ) ;
char **word_list_to_argv(WORD_LIST *list___0 , int copy , int starting_index , int *ip ) 
{ 
  int count ;
  char **array ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  count = list_length((GENERIC_LIST *)list___0);
  tmp = xmalloc((unsigned long )((1 + count) + starting_index) * sizeof(char *));
  array = (char **)tmp;
  count = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (count < starting_index)) {
      goto while_break;
    }
    *(array + count) = (char *)((void *)0);
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  count = starting_index;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! list___0) {
      goto while_break___0;
    }
    if (copy) {
      {
      tmp___0 = strlen((char const   *)(list___0->word)->word);
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )(list___0->word)->word);
      *(array + count) = tmp___2;
      }
    } else {
      *(array + count) = (list___0->word)->word;
    }
    count ++;
    list___0 = list___0->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  *(array + count) = (char *)((void *)0);
  if (ip) {
    *ip = count;
  }
  return (array);
}
}
WORD_LIST *argv_to_word_list(char **array , int copy , int starting_index ) 
{ 
  WORD_LIST *list___0 ;
  WORD_DESC *w ;
  int i ;
  int count ;
  char const   *tmp ;
  GENERIC_LIST *tmp___0 ;
  WORD_LIST *tmp___1 ;

  {
  if ((unsigned long )array == (unsigned long )((char **)0)) {
    return ((WORD_LIST *)((void *)0));
  } else { //Added block
  if ((unsigned long )*(array + 0) == (unsigned long )((char *)0)) {
    return ((WORD_LIST *)((void *)0));
  }
  }
  count = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(array + count)) {
      goto while_break;
    }
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  i = starting_index;
  list___0 = (WORD_LIST *)((void *)0);
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < count)) {
      goto while_break___0;
    }
    if (copy) {
      tmp = "";
    } else {
      tmp = (char const   *)*(array + i);
    }
    {
    w = make_bare_word((char *)tmp);
    }
    if (copy) {
      {
      free((void *)w->word);
      w->word = *(array + i);
      }
    }
    {
    list___0 = make_word_list(w, list___0);
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (list___0) {
    if (list___0->next) {
      {
      tmp___0 = reverse_list((GENERIC_LIST *)list___0);
      tmp___1 = (WORD_LIST *)tmp___0;
      }
    } else {
      tmp___1 = list___0;
    }
  } else {
    tmp___1 = list___0;
  }
  return (tmp___1);
}
}
int find_string_in_alist(char *string , STRING_INT_ALIST *alist , int flags ) 
{ 
  register int i ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  r = 0;
  i = r;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (alist + i)->word) {
      goto while_break;
    }
    if (flags) {
      {
      tmp = fnmatch((alist + i)->word, string, 1 << 5);
      r = tmp != 1;
      }
    } else {
      if ((int )*(string + 0) == (int )*((alist + i)->word + 0)) {
        {
        tmp___0 = strcmp((char const   *)string, (char const   *)(alist + i)->word);
        }
        if (tmp___0 == 0) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
      r = tmp___1;
    }
    if (r) {
      return ((alist + i)->token);
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
char *strsub(char *string , char *pat , char *rep , int global ) 
{ 
  int patlen ;
  int replen ;
  int templen ;
  int tempsize ;
  int repl ;
  int i ;
  char *temp___0 ;
  char *r ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
  tmp = strlen((char const   *)pat);
  patlen = (int )tmp;
  tmp___0 = strlen((char const   *)rep);
  replen = (int )tmp___0;
  temp___0 = (char *)((void *)0);
  tempsize = 0;
  templen = tempsize;
  i = templen;
  repl = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(string + i)) {
      goto while_break;
    }
    if (repl) {
      if (patlen == 0) {
        tmp___7 = 1;
      } else {
        if ((int )*((string + i) + 0) == (int )*(pat + 0)) {
          {
          tmp___5 = strncmp((char const   *)(string + i), (char const   *)pat, (size_t )patlen);
          }
          if (tmp___5 == 0) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        tmp___7 = tmp___6;
      }
      if (tmp___7) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (templen + replen >= tempsize) {
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (! (templen + replen >= tempsize)) {
                goto while_break___1;
              }
              tempsize += replen * 2;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
            temp___0 = xrealloc((void *)temp___0, (size_t )tempsize);
            }
          }
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        r = rep;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! *r) {
            goto while_break___2;
          }
          tmp___1 = templen;
          templen ++;
          tmp___2 = r;
          r ++;
          *(temp___0 + tmp___1) = *tmp___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        i += patlen;
        repl = global != 0;
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (templen + 1 >= tempsize) {
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (! (templen + 1 >= tempsize)) {
              goto while_break___4;
            }
            tempsize += 16;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
          temp___0 = xrealloc((void *)temp___0, (size_t )tempsize);
          }
        }
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      tmp___3 = templen;
      templen ++;
      tmp___4 = i;
      i ++;
      *(temp___0 + tmp___3) = *(string + tmp___4);
    }
  }
  while_break: /* CIL Label */ ;
  }
  *(temp___0 + templen) = (char)0;
  return (temp___0);
}
}
char *strcreplace(char *string , int c , char *text___0 , int do_glob ) 
{ 
  char *ret ;
  char *p ;
  char *r ;
  char *t ;
  int len___0 ;
  int rlen ;
  int ind___1 ;
  int tlen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  if (text___0) {
    if (*(text___0 + 0)) {
      if (*(text___0 + 1)) {
        if (*(text___0 + 2)) {
          {
          tmp = strlen((char const   *)text___0);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      len___0 = (int )tmp___1;
    } else {
      len___0 = 0;
    }
  } else {
    len___0 = 0;
  }
  {
  tmp___2 = strlen((char const   *)string);
  rlen = (int )(((size_t )len___0 + tmp___2) + 2UL);
  ret = xmalloc((size_t )rlen);
  p = string;
  r = ret;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (p) {
      if (! *p) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p == c) {
      if (len___0) {
        ind___1 = (int )(r - ret);
        if (do_glob) {
          {
          tmp___4 = glob_pattern_p(text___0);
          }
          if (tmp___4) {
            goto _L___0;
          } else {
            {
            tmp___5 = strchr((char const   *)text___0, '\\');
            }
            if (tmp___5) {
              _L___0: 
              {
              t = quote_globbing_chars(text___0);
              tmp___3 = strlen((char const   *)t);
              tlen = (int )tmp___3;
              }
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (ind___1 + tlen >= rlen) {
                  {
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    if (! (ind___1 + tlen >= rlen)) {
                      goto while_break___1;
                    }
                    rlen += rlen;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                  {
                  ret = xrealloc((void *)ret, (size_t )rlen);
                  }
                }
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              r = ret + ind___1;
              strcpy((char * __restrict  )r, (char const   * __restrict  )t);
              r += tlen;
              free((void *)t);
              }
            } else {
              goto _L;
            }
          }
        } else {
          _L: 
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (ind___1 + len___0 >= rlen) {
              {
              while (1) {
                while_continue___3: /* CIL Label */ ;
                if (! (ind___1 + len___0 >= rlen)) {
                  goto while_break___3;
                }
                rlen += rlen;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
              ret = xrealloc((void *)ret, (size_t )rlen);
              }
            }
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
          r = ret + ind___1;
          strcpy((char * __restrict  )r, (char const   * __restrict  )text___0);
          r += len___0;
          }
        }
      }
      p ++;
      goto __Cont;
    }
    if ((int )*p == 92) {
      if ((int )*(p + 1) == c) {
        p ++;
      }
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (ind___1 + 2 >= rlen) {
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          if (! (ind___1 + 2 >= rlen)) {
            goto while_break___5;
          }
          rlen += rlen;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
        ret = xrealloc((void *)ret, (size_t )rlen);
        }
      }
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    r = ret + ind___1;
    tmp___6 = r;
    r ++;
    tmp___7 = p;
    p ++;
    *tmp___6 = *tmp___7;
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  *r = (char )'\000';
  return (ret);
}
}
void strip_trailing(char *string , int len___0 , int newlines_only ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (len___0 >= 0)) {
      goto while_break;
    }
    if (newlines_only) {
      if ((int )*(string + len___0) == 10) {
        len___0 --;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (! newlines_only) {
      if ((int )*(string + len___0) == 32) {
        len___0 --;
      } else { //Added block
      if ((int )*(string + len___0) == 9) {
        len___0 --;
      } else {
        goto while_break;
      }
      }
    } else {
      goto while_break;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  *(string + (len___0 + 1)) = (char )'\000';
  return;
}
}
void xbcopy(char *s , char *d___0 , int n ) 
{ 


  {
  {
  __builtin_memcpy((void *)d___0, (void const   *)s, (unsigned long )n);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-1g6tIg4N.i","-g")
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
char *get_locale_var(char *var ) ;
static char *default_locale  ;
static char *default_domain  ;
static char *default_dir  ;
static char *lc_all  ;
void set_default_locale(void) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  default_locale = setlocale(6, "");
  }
  if (default_locale) {
    {
    tmp = strlen((char const   *)default_locale);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )default_locale);
    default_locale = tmp___1;
    }
  }
  return;
}
}
void set_default_locale_vars(void) 
{ 
  char *val___0 ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
  val___0 = get_string_value("LC_CTYPE");
  }
  if ((unsigned long )val___0 == (unsigned long )((char *)0)) {
    if (lc_all) {
      if (*lc_all) {
        {
        setlocale(0, (char const   *)lc_all);
        }
      }
    }
  }
  {
  val___0 = get_string_value("LC_COLLATE");
  }
  if ((unsigned long )val___0 == (unsigned long )((char *)0)) {
    if (lc_all) {
      if (*lc_all) {
        {
        setlocale(3, (char const   *)lc_all);
        }
      }
    }
  }
  {
  val___0 = get_string_value("LC_MESSAGES");
  }
  if ((unsigned long )val___0 == (unsigned long )((char *)0)) {
    if (lc_all) {
      if (*lc_all) {
        {
        setlocale(5, (char const   *)lc_all);
        }
      }
    }
  }
  {
  val___0 = get_string_value("LC_NUMERIC");
  }
  if ((unsigned long )val___0 == (unsigned long )((char *)0)) {
    if (lc_all) {
      if (*lc_all) {
        {
        setlocale(1, (char const   *)lc_all);
        }
      }
    }
  }
  {
  val___0 = get_string_value("TEXTDOMAIN");
  }
  if (val___0) {
    if (*val___0) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (default_domain) {
          {
          free((void *)default_domain);
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
      tmp = strlen((char const   *)val___0);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )val___0);
      default_domain = tmp___1;
      textdomain((char const   *)default_domain);
      }
    }
  }
  {
  val___0 = get_string_value("TEXTDOMAINDIR");
  }
  if (val___0) {
    if (*val___0) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (default_dir) {
          {
          free((void *)default_dir);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      tmp___2 = strlen((char const   *)val___0);
      tmp___3 = xmalloc(1UL + tmp___2);
      tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )val___0);
      default_dir = tmp___4;
      bindtextdomain((char const   *)default_domain, (char const   *)default_dir);
      }
    }
  }
  return;
}
}
int set_locale_var(char *var , char *value ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  char tmp___20 ;

  {
  if ((int )*(var + 0) == 84) {
    if ((int )*(var + 10) == 0) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (default_domain) {
          {
          free((void *)default_domain);
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      if (value) {
        {
        tmp = strlen((char const   *)value);
        tmp___0 = xmalloc(1UL + tmp);
        tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )value);
        default_domain = tmp___1;
        }
      } else {
        default_domain = (char *)((void *)0);
      }
      {
      textdomain((char const   *)default_domain);
      }
      return (1);
    } else {
      goto _L___6;
    }
  } else { //Added block
  _L___6: 
  if ((int )*(var + 0) == 84) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (default_dir) {
        {
        free((void *)default_dir);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (value) {
      {
      tmp___2 = strlen((char const   *)value);
      tmp___3 = xmalloc(1UL + tmp___2);
      tmp___4 = strcpy((char * __restrict  )tmp___3, (char const   * __restrict  )value);
      default_dir = tmp___4;
      }
    } else {
      default_dir = (char *)((void *)0);
    }
    {
    bindtextdomain((char const   *)default_domain, (char const   *)default_dir);
    }
    return (1);
  } else { //Added block
  if ((int )*(var + 3) == 65) {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (lc_all) {
        {
        free((void *)lc_all);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (value) {
      {
      tmp___5 = strlen((char const   *)value);
      tmp___6 = xmalloc(1UL + tmp___5);
      tmp___7 = strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )value);
      lc_all = tmp___7;
      }
    } else { //Added block
    if (default_locale) {
      {
      tmp___8 = strlen((char const   *)default_locale);
      tmp___9 = xmalloc(1UL + tmp___8);
      tmp___10 = strcpy((char * __restrict  )tmp___9, (char const   * __restrict  )default_locale);
      lc_all = tmp___10;
      }
    } else {
      {
      lc_all = xmalloc((size_t )1);
      *(lc_all + 0) = (char )'\000';
      }
    }
    }
    {
    tmp___11 = setlocale(6, (char const   *)lc_all);
    }
    return ((unsigned long )tmp___11 != (unsigned long )((char *)0));
  } else { //Added block
  if ((int )*(var + 3) == 67) {
    if ((int )*(var + 4) == 84) {
      if ((unsigned long )lc_all == (unsigned long )((char *)0)) {
        goto _L;
      } else { //Added block
      if ((int )*lc_all == 0) {
        _L: 
        if (value) {
          tmp___12 = (char const   *)value;
        } else {
          tmp___12 = "";
        }
        {
        tmp___13 = setlocale(0, tmp___12);
        }
        return ((unsigned long )tmp___13 != (unsigned long )((char *)0));
      }
      }
    } else {
      goto _L___5;
    }
  } else { //Added block
  _L___5: 
  if ((int )*(var + 3) == 67) {
    if ((int )*(var + 4) == 79) {
      if ((unsigned long )lc_all == (unsigned long )((char *)0)) {
        goto _L___0;
      } else { //Added block
      if ((int )*lc_all == 0) {
        _L___0: 
        if (value) {
          tmp___14 = (char const   *)value;
        } else {
          tmp___14 = "";
        }
        {
        tmp___15 = setlocale(3, tmp___14);
        }
        return ((unsigned long )tmp___15 != (unsigned long )((char *)0));
      }
      }
    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: 
  if ((int )*(var + 3) == 77) {
    if ((int )*(var + 4) == 69) {
      if ((unsigned long )lc_all == (unsigned long )((char *)0)) {
        goto _L___1;
      } else { //Added block
      if ((int )*lc_all == 0) {
        _L___1: 
        if (value) {
          tmp___16 = (char const   *)value;
        } else {
          tmp___16 = "";
        }
        {
        tmp___17 = setlocale(5, tmp___16);
        }
        return ((unsigned long )tmp___17 != (unsigned long )((char *)0));
      }
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    tmp___20 = (char )((int )*(var + 4) == 85);
    *(var + 3) = tmp___20;
    if (tmp___20) {
      if ((unsigned long )lc_all == (unsigned long )((char *)0)) {
        goto _L___2;
      } else { //Added block
      if ((int )*lc_all == 0) {
        _L___2: 
        if (value) {
          tmp___18 = (char const   *)value;
        } else {
          tmp___18 = "";
        }
        {
        tmp___19 = setlocale(1, tmp___18);
        }
        return ((unsigned long )tmp___19 != (unsigned long )((char *)0));
      }
      }
    }
  }
  }
  }
  }
  }
  }
  return (0);
}
}
int set_lang(char *var , char *value ) 
{ 


  {
  return (0);
}
}
char *get_locale_var(char *var ) 
{ 
  char *locale ;

  {
  locale = lc_all;
  if ((unsigned long )locale == (unsigned long )((char *)0)) {
    {
    locale = get_string_value((char const   *)var);
    }
  }
  if ((unsigned long )locale == (unsigned long )((char *)0)) {
    locale = default_locale;
  }
  return (locale);
}
}
char *localetrans(char *string , int len___0 , int *lenp ) 
{ 
  char *locale ;
  char *t ;
  char *translated ;
  int tlen ;
  int tmp ;
  size_t tmp___0 ;

  {
  if ((unsigned long )string == (unsigned long )((char *)0)) {
    goto _L;
  } else { //Added block
  if ((int )*string == 0) {
    _L: 
    if (lenp) {
      *lenp = 0;
    }
    return ((char *)((void *)0));
  }
  }
  {
  locale = get_locale_var((char *)"LC_MESSAGES");
  }
  if ((unsigned long )locale == (unsigned long )((char *)0)) {
    goto _L___0;
  } else { //Added block
  if ((int )*(locale + 0) == 0) {
    goto _L___0;
  } else { //Added block
  if ((int )*(locale + 0) == 67) {
    if ((int )*(locale + 1) == 0) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if ((int )*(locale + 0) == (int )*("POSIX" + 0)) {
    {
    tmp = strcmp((char const   *)locale, "POSIX");
    }
    if (tmp == 0) {
      _L___0: 
      {
      t = xmalloc((size_t )(len___0 + 1));
      strcpy((char * __restrict  )t, (char const   * __restrict  )string);
      }
      if (lenp) {
        *lenp = len___0;
      }
      return (t);
    }
  }
  }
  }
  }
  {
  translated = gettext((char const   *)string);
  }
  if ((unsigned long )translated == (unsigned long )string) {
    {
    t = xmalloc((size_t )(len___0 + 1));
    strcpy((char * __restrict  )t, (char const   * __restrict  )string);
    }
    if (lenp) {
      *lenp = len___0;
    }
  } else {
    {
    tmp___0 = strlen((char const   *)translated);
    tlen = (int )tmp___0;
    t = xmalloc((size_t )(tlen + 1));
    strcpy((char * __restrict  )t, (char const   * __restrict  )translated);
    }
    if (lenp) {
      *lenp = tlen;
    }
  }
  return (t);
}
}
#pragma merger("0","/tmp/cil-7nr8BxfW.i","-g")
static char *find_user_command_internal(char *name , int flags ) ;
static char *find_user_command_in_path(char *name , char *path_list , int flags ) ;
static char *find_in_path_element(char *name , char *path___0 , int flags , int name_len ,
                                  struct stat *dotinfop ) ;
static char *find_absolute_program(char *name , int flags ) ;
static char *file_to_lose_on  ;
int check_hashed_filenames  ;
int dot_found_in_search  =    0;
int file_status(char *name ) 
{ 
  struct stat finfo ;
  int tmp ;
  int bits ;
  int tmp___0 ;

  {
  {
  tmp = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& finfo));
  }
  if (tmp < 0) {
    return (0);
  }
  if ((finfo.st_mode & 61440U) == 16384U) {
    return (17);
  }
  if (current_user.euid == 0U) {
    bits = (int )((((finfo.st_mode & 448U) >> 6) | ((finfo.st_mode & 56U) >> 3)) | (finfo.st_mode & 7U));
    if (bits & 1) {
      return (3);
    }
  }
  if (current_user.euid == finfo.st_uid) {
    if (((finfo.st_mode & 448U) >> 6) & 1U) {
      return (3);
    }
  }
  {
  tmp___0 = group_member(finfo.st_gid);
  }
  if (tmp___0) {
    if (((finfo.st_mode & 56U) >> 3) & 1U) {
      return (3);
    }
  }
  if ((finfo.st_mode & 7U) & 1U) {
    return (3);
  }
  return (1);
}
}
int executable_file(char *file ) 
{ 
  int s ;
  int tmp ;

  {
  {
  s = file_status(file);
  }
  if (s & 2) {
    if ((s & 16) == 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int is_directory(char *file ) 
{ 
  int tmp ;

  {
  {
  tmp = file_status(file);
  }
  return (tmp & 16);
}
}
int executable_or_directory(char *file ) 
{ 
  int s ;
  int tmp ;

  {
  {
  s = file_status(file);
  }
  if (s & 2) {
    tmp = 1;
  } else { //Added block
  if (s & 16) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
char *find_user_command(char *name ) 
{ 
  char *tmp ;

  {
  {
  tmp = find_user_command_internal(name, 36);
  }
  return (tmp);
}
}
char *find_path_file(char *name ) 
{ 
  char *tmp ;

  {
  {
  tmp = find_user_command_internal(name, 1);
  }
  return (tmp);
}
}
static char *_find_user_command_internal(char *name , int flags ) 
{ 
  char *path_list ;
  char *cmd ;
  SHELL_VAR *var ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  var = find_variable_internal((char *)"PATH", 1);
  }
  if (var) {
    path_list = var->value;
  } else {
    path_list = (char *)((void *)0);
  }
  if ((unsigned long )path_list == (unsigned long )((char *)0)) {
    {
    tmp = strlen((char const   *)name);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )name);
    }
    return (tmp___1);
  } else { //Added block
  if ((int )*path_list == 0) {
    {
    tmp = strlen((char const   *)name);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )name);
    }
    return (tmp___1);
  }
  }
  {
  cmd = find_user_command_in_path(name, path_list, flags);
  }
  if (var) {
    if (var->attributes & 512) {
      {
      dispose_variable(var);
      }
    }
  }
  return (cmd);
}
}
static char *find_user_command_internal(char *name , int flags ) 
{ 
  char *tmp ;

  {
  {
  tmp = _find_user_command_internal(name, flags);
  }
  return (tmp);
}
}
static char *get_next_path_element(char *path_list , int *path_index_pointer ) 
{ 
  char *path___0 ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  path___0 = extract_colon_unit(path_list, path_index_pointer);
  }
  if ((unsigned long )path___0 == (unsigned long )((char *)0)) {
    return (path___0);
  }
  if ((int )*path___0 == 0) {
    {
    free((void *)path___0);
    tmp = strlen(".");
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )".");
    path___0 = tmp___1;
    }
  }
  return (path___0);
}
}
char *search_for_command(char *pathname ) 
{ 
  char *hashed_file ;
  char *command ;
  int temp_path ;
  int st ;
  SHELL_VAR *path___0 ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
  command = (char *)((void *)0);
  hashed_file = command;
  path___0 = find_tempenv_variable((char *)"PATH");
  temp_path = (unsigned long )path___0 != (unsigned long )((SHELL_VAR *)0);
  }
  if ((unsigned long )path___0 == (unsigned long )((SHELL_VAR *)0)) {
    {
    tmp = absolute_program(pathname);
    }
    if (tmp == 0) {
      {
      hashed_file = find_hashed_filename(pathname);
      }
    }
  }
  if (hashed_file) {
    if (posixly_correct) {
      goto _L;
    } else { //Added block
    if (check_hashed_filenames) {
      _L: 
      {
      st = file_status(hashed_file);
      }
      if ((st ^ 3) != 0) {
        {
        remove_hashed_filename(pathname);
        free((void *)hashed_file);
        hashed_file = (char *)((void *)0);
        }
      }
    }
    }
  }
  if (hashed_file) {
    command = hashed_file;
  } else {
    {
    tmp___3 = absolute_program(pathname);
    }
    if (tmp___3) {
      {
      tmp___0 = strlen((char const   *)pathname);
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )pathname);
      command = tmp___2;
      }
    } else {
      if (temp_path) {
        {
        command = find_user_command_in_path(pathname, path___0->value, 36);
        }
        if (path___0->attributes & 512) {
          {
          dispose_variable(path___0);
          }
        }
      } else {
        {
        command = find_user_command(pathname);
        }
      }
      if (command) {
        if (hashing_enabled) {
          if (temp_path == 0) {
            {
            remember_filename(pathname, command, dot_found_in_search, 1);
            }
          }
        }
      }
    }
  }
  return (command);
}
}
char *user_command_matches(char *name , int flags , int state ) ;
static char **match_list  =    (char **)((void *)0);
static int match_list_size  =    0;
static int match_index  =    0;
char *user_command_matches(char *name , int flags , int state ) 
{ 
  register int i ;
  int path_index___0 ;
  int name_len ;
  char *path_list ;
  char *path_element ;
  char *match ;
  struct stat dotinfo ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  if (state == 0) {
    if ((unsigned long )match_list == (unsigned long )((char **)0)) {
      {
      match_list_size = 5;
      match_list = alloc_array(match_list_size);
      }
    }
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < match_list_size)) {
        goto while_break;
      }
      *(match_list + i) = (char *)0;
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    match_index = 0;
    tmp___0 = absolute_program(name);
    }
    if (tmp___0) {
      {
      *(match_list + 0) = find_absolute_program(name, flags);
      *(match_list + 1) = (char *)((void *)0);
      path_list = (char *)((void *)0);
      }
    } else {
      {
      tmp = strlen((char const   *)name);
      name_len = (int )tmp;
      file_to_lose_on = (char *)((void *)0);
      dot_found_in_search = 0;
      stat((char const   * __restrict  )".", (struct stat * __restrict  )(& dotinfo));
      path_list = get_string_value("PATH");
      path_index___0 = 0;
      }
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (path_list) {
        if (! *(path_list + path_index___0)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      {
      path_element = get_next_path_element(path_list, & path_index___0);
      }
      if ((unsigned long )path_element == (unsigned long )((char *)0)) {
        goto while_break___0;
      }
      {
      match = find_in_path_element(name, path_element, flags, name_len, & dotinfo);
      free((void *)path_element);
      }
      if ((unsigned long )match == (unsigned long )((char *)0)) {
        goto while_continue___0;
      }
      if (match_index + 1 == match_list_size) {
        {
        match_list_size += 10;
        tmp___1 = xrealloc((void *)match_list, (unsigned long )(match_list_size + 1) * sizeof(char *));
        match_list = (char **)tmp___1;
        }
      }
      tmp___2 = match_index;
      match_index ++;
      *(match_list + tmp___2) = match;
      *(match_list + match_index) = (char *)((void *)0);
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (file_to_lose_on) {
          {
          free((void *)file_to_lose_on);
          }
        }
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      file_to_lose_on = (char *)((void *)0);
    }
    while_break___0: /* CIL Label */ ;
    }
    match_index = 0;
  }
  match = *(match_list + match_index);
  if (match) {
    match_index ++;
  }
  return (match);
}
}
static char *find_absolute_program(char *name , int flags ) 
{ 
  int st ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  st = file_status(name);
  }
  if ((st & 1) == 0) {
    return ((char *)((void *)0));
  }
  if (flags & 1) {
    {
    tmp = strlen((char const   *)name);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )name);
    }
    return (tmp___1);
  } else { //Added block
  if (flags & 8) {
    if (st & 2) {
      {
      tmp = strlen((char const   *)name);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )name);
      }
      return (tmp___1);
    }
  }
  }
  return ((char *)((void *)0));
}
}
static char *find_in_path_element(char *name , char *path___0 , int flags , int name_len ,
                                  struct stat *dotinfop ) 
{ 
  int status ;
  char *full_path ;
  char *xpath ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if ((int )*path___0 == 126) {
    {
    tmp = bash_tilde_expand(path___0);
    xpath = tmp;
    }
  } else {
    xpath = path___0;
  }
  if (dot_found_in_search == 0) {
    if ((int )*xpath == 46) {
      {
      dot_found_in_search = same_file((char *)".", xpath, dotinfop, (struct stat *)((void *)0));
      }
    }
  }
  {
  full_path = sh_makepath(xpath, name, 0);
  status = file_status(full_path);
  }
  if ((unsigned long )xpath != (unsigned long )path___0) {
    {
    free((void *)xpath);
    }
  }
  if ((status & 1) == 0) {
    {
    free((void *)full_path);
    }
    return ((char *)((void *)0));
  }
  if (flags & 1) {
    return (full_path);
  }
  if (status & 2) {
    if ((flags & 32) == 0) {
      goto _L;
    } else { //Added block
    if ((status & 16) == 0) {
      _L: 
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (file_to_lose_on) {
          {
          free((void *)file_to_lose_on);
          }
        }
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      file_to_lose_on = (char *)((void *)0);
      return (full_path);
    }
    }
  }
  if (flags & 4) {
    if ((unsigned long )file_to_lose_on == (unsigned long )((char *)0)) {
      {
      tmp___0 = strlen((char const   *)full_path);
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )full_path);
      file_to_lose_on = tmp___2;
      }
    }
  }
  if (flags & 8) {
    {
    free((void *)full_path);
    }
    return ((char *)((void *)0));
  } else { //Added block
  if (flags & 4) {
    {
    free((void *)full_path);
    }
    return ((char *)((void *)0));
  } else { //Added block
  if (flags & 32) {
    if (status & 16) {
      {
      free((void *)full_path);
      }
      return ((char *)((void *)0));
    } else {
      return (full_path);
    }
  } else {
    return (full_path);
  }
  }
  }
}
}
static char *find_user_command_in_path(char *name , char *path_list , int flags ) 
{ 
  char *full_path ;
  char *path___0 ;
  int path_index___0 ;
  int name_len ;
  struct stat dotinfo ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  dot_found_in_search = 0;
  tmp = absolute_program(name);
  }
  if (tmp) {
    {
    full_path = find_absolute_program(name, flags);
    }
    return (full_path);
  }
  if ((unsigned long )path_list == (unsigned long )((char *)0)) {
    {
    tmp___0 = strlen((char const   *)name);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )name);
    }
    return (tmp___2);
  } else { //Added block
  if ((int )*path_list == 0) {
    {
    tmp___0 = strlen((char const   *)name);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )name);
    }
    return (tmp___2);
  }
  }
  {
  file_to_lose_on = (char *)((void *)0);
  tmp___3 = strlen((char const   *)name);
  name_len = (int )tmp___3;
  stat((char const   * __restrict  )".", (struct stat * __restrict  )(& dotinfo));
  path_index___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(path_list + path_index___0)) {
      goto while_break;
    }
    if (interrupt_state) {
      {
      throw_to_top_level();
      }
    }
    {
    path___0 = get_next_path_element(path_list, & path_index___0);
    }
    if ((unsigned long )path___0 == (unsigned long )((char *)0)) {
      goto while_break;
    }
    {
    full_path = find_in_path_element(name, path___0, flags, name_len, & dotinfo);
    free((void *)path___0);
    }
    if (full_path) {
      {
      tmp___4 = is_directory(full_path);
      }
      if (tmp___4) {
        {
        free((void *)full_path);
        }
        goto while_continue;
      }
    }
    if (full_path) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (file_to_lose_on) {
          {
          free((void *)file_to_lose_on);
          }
        }
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      return (full_path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (file_to_lose_on) {
    if (flags & 32) {
      {
      tmp___5 = is_directory(file_to_lose_on);
      }
      if (tmp___5) {
        {
        free((void *)file_to_lose_on);
        file_to_lose_on = (char *)((void *)0);
        }
      }
    }
  }
  return (file_to_lose_on);
}
}
#pragma merger("0","/tmp/cil-55bFTYTj.i","-g")
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
extern int netopen(char * ) ;
extern int sh_mktmpfd(char * , int  , char ** ) ;
void redirection_error(REDIRECT *temp___0 , int error ) ;
char *redirection_expand(WORD_DESC *word ) ;
static void add_undo_close_redirect(int fd ) ;
static void add_exec_redirect(REDIRECT *dummy_redirect ) ;
static int add_undo_redirect(int fd ) ;
static int do_redirection_internal(REDIRECT *redirect , int for_real , int remembering ,
                                   int set_clexec ) ;
static int expandable_redirection_filename(REDIRECT *redirect ) ;
static int stdin_redirection(enum r_instruction ri , int redirector ) ;
static REDIRECTEE rd  ;
static int heredoc_errno  ;
void redirection_error(REDIRECT *temp___0 , int error ) 
{ 
  char *filename ;
  int oflags ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
  tmp___2 = expandable_redirection_filename(temp___0);
  }
  if (tmp___2) {
    if (posixly_correct) {
      if (interactive_shell == 0) {
        oflags = (temp___0->redirectee.filename)->flags;
        (temp___0->redirectee.filename)->flags |= 32;
      }
    }
    {
    filename = redirection_expand(temp___0->redirectee.filename);
    }
    if (posixly_correct) {
      if (interactive_shell == 0) {
        (temp___0->redirectee.filename)->flags = oflags;
      }
    }
    if ((unsigned long )filename == (unsigned long )((char *)0)) {
      {
      tmp = strlen((char const   *)(temp___0->redirectee.filename)->word);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )(temp___0->redirectee.filename)->word);
      filename = tmp___1;
      }
    }
    if ((unsigned long )filename == (unsigned long )((char *)0)) {
      {
      filename = xmalloc((size_t )1);
      *(filename + 0) = (char )'\000';
      }
    }
  } else {
    {
    filename = itos((int )temp___0->redirectee.dest);
    }
  }
  {
  if (error == -1) {
    goto case_neg_1;
  }
  if (error == -2) {
    goto case_neg_2;
  }
  if (error == -3) {
    goto case_neg_3;
  }
  if (error == -4) {
    goto case_neg_4;
  }
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
  internal_error("%s: ambiguous redirect", filename);
  }
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
  internal_error("%s: cannot overwrite existing file", filename);
  }
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
  internal_error("%s: restricted: cannot redirect output", filename);
  }
  goto switch_break;
  case_neg_4: /* CIL Label */ 
  {
  tmp___3 = strerror(heredoc_errno);
  internal_error("cannot create temp file for here document: %s", tmp___3);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  tmp___4 = strerror(error);
  internal_error("%s: %s", filename, tmp___4);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (filename) {
      {
      free((void *)filename);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int do_redirections(REDIRECT *list___0 , int for_real , int internal , int set_clexec ) 
{ 
  int error ;
  REDIRECT *temp___0 ;

  {
  if (internal) {
    if (redirection_undo_list) {
      {
      dispose_redirects(redirection_undo_list);
      redirection_undo_list = (REDIRECT *)((void *)0);
      }
    }
    if (exec_redirection_undo_list) {
      {
      dispose_exec_redirects();
      }
    }
  }
  temp___0 = list___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! temp___0) {
      goto while_break;
    }
    {
    error = do_redirection_internal(temp___0, for_real, internal, set_clexec);
    }
    if (error) {
      {
      redirection_error(temp___0, error);
      }
      return (error);
    }
    temp___0 = temp___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int expandable_redirection_filename(REDIRECT *redirect ) 
{ 


  {
  {
  if ((unsigned int )redirect->instruction == 0U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 3U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 1U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 2U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 9U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 10U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 11U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 12U) {
    goto case_0;
  }
  if ((unsigned int )redirect->instruction == 13U) {
    goto case_0;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
  return (1);
  switch_default: /* CIL Label */ 
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
char *redirection_expand(WORD_DESC *word ) 
{ 
  char *result ;
  WORD_LIST *tlist1 ;
  WORD_LIST *tlist2 ;
  WORD_DESC *w ;

  {
  {
  w = copy_word(word);
  }
  if (posixly_correct) {
    w->flags |= 16;
  }
  {
  tlist1 = make_word_list(w, (WORD_LIST *)((void *)0));
  tlist2 = expand_words_no_vars(tlist1);
  dispose_words(tlist1);
  }
  if (! tlist2) {
    goto _L;
  } else { //Added block
  if (tlist2->next) {
    _L: 
    if (tlist2) {
      {
      dispose_words(tlist2);
      }
    }
    return ((char *)((void *)0));
  }
  }
  {
  result = string_list(tlist2);
  dispose_words(tlist2);
  }
  return (result);
}
}
static int write_here_document(int fd , WORD_DESC *redirectee ) 
{ 
  char *document ;
  int document_len ;
  int fd2 ;
  FILE *fp ;
  register WORD_LIST *t ;
  register WORD_LIST *tlist ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  if (redirectee->flags & 2) {
    {
    document = redirectee->word;
    tmp = strlen((char const   *)document);
    document_len = (int )tmp;
    tmp___3 = write(fd, (void const   *)document, (size_t )document_len);
    }
    if (tmp___3 < (ssize_t )document_len) {
      {
      tmp___1 = __errno_location();
      }
      if (*tmp___1 == 0) {
        {
        tmp___0 = __errno_location();
        *tmp___0 = 28;
        }
      }
      {
      tmp___2 = __errno_location();
      }
      return (*tmp___2);
    } else {
      return (0);
    }
  }
  {
  tlist = expand_string(redirectee->word, 2);
  }
  if (tlist) {
    {
    fd2 = dup(fd);
    }
    if (fd2 < 0) {
      goto _L;
    } else {
      {
      fp = fdopen(fd2, "w");
      }
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        _L: 
        if (fd2 >= 0) {
          {
          close(fd2);
          }
        }
        {
        tmp___4 = __errno_location();
        }
        return (*tmp___4);
      }
    }
    {
    tmp___5 = __errno_location();
    *tmp___5 = 0;
    t = tlist;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! t) {
        goto while_break;
      }
      {
      document = (t->word)->word;
      tmp___6 = strlen((char const   *)document);
      document_len = (int )tmp___6;
      }
      if ((unsigned long )t != (unsigned long )tlist) {
        {
        _IO_putc(' ', fp);
        }
      }
      {
      fwrite((void const   * __restrict  )document, (size_t )document_len, (size_t )1,
             (FILE * __restrict  )fp);
      tmp___10 = ferror(fp);
      }
      if (tmp___10) {
        {
        tmp___8 = __errno_location();
        }
        if (*tmp___8 == 0) {
          {
          tmp___7 = __errno_location();
          *tmp___7 = 28;
          }
        }
        {
        tmp___9 = __errno_location();
        fd2 = *tmp___9;
        fclose(fp);
        dispose_words(tlist);
        }
        return (fd2);
      }
      t = t->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
    fclose(fp);
    dispose_words(tlist);
    }
  }
  return (0);
}
}
static int here_document_to_fd(WORD_DESC *redirectee ) ;
static int here_document_to_fd(WORD_DESC *redirectee ) 
{ 
  char *filename ;
  int r ;
  int fd ;
  int fd2 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
  fd = sh_mktmpfd((char *)"sh-thd", 4, & filename);
  }
  if (fd < 0) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (filename) {
        {
        free((void *)filename);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    return (fd);
  }
  {
  tmp = __errno_location();
  r = 0;
  *tmp = r;
  }
  if (redirectee->word) {
    {
    r = write_here_document(fd, redirectee);
    }
  }
  if (r) {
    {
    close(fd);
    unlink((char const   *)filename);
    free((void *)filename);
    tmp___0 = __errno_location();
    *tmp___0 = r;
    }
    return (-1);
  }
  {
  fd2 = open((char const   *)filename, 0, 384);
  }
  if (fd2 < 0) {
    {
    tmp___1 = __errno_location();
    r = *tmp___1;
    unlink((char const   *)filename);
    free((void *)filename);
    close(fd);
    tmp___2 = __errno_location();
    *tmp___2 = r;
    }
    return (-1);
  }
  {
  close(fd);
  tmp___5 = unlink((char const   *)filename);
  }
  if (tmp___5 < 0) {
    {
    tmp___3 = __errno_location();
    r = *tmp___3;
    close(fd2);
    free((void *)filename);
    tmp___4 = __errno_location();
    *tmp___4 = r;
    }
    return (-1);
  }
  {
  free((void *)filename);
  }
  return (fd2);
}
}
static STRING_INT_ALIST _redir_special_filenames[3]  = {      {(char *)"/dev/tcp/*/*", 5}, 
        {(char *)"/dev/udp/*/*", 6}, 
        {(char *)((void *)0), -1}};
static int redir_special_open(int spec , char *filename , int flags , int mode , enum r_instruction ri ) 
{ 
  int fd ;

  {
  fd = -1;
  {
  if (spec == 5) {
    goto case_5;
  }
  if (spec == 6) {
    goto case_5;
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
  fd = netopen(filename);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (fd);
}
}
static int noclobber_open(char *filename , int flags , int mode , enum r_instruction ri ) 
{ 
  int r ;
  int fd ;
  struct stat finfo ;
  struct stat finfo2 ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
  {
  r = stat((char const   * __restrict  )filename, (struct stat * __restrict  )(& finfo));
  }
  if (r == 0) {
    if ((finfo.st_mode & 61440U) == 32768U) {
      return (-2);
    }
  }
  flags &= -513;
  if (r != 0) {
    {
    fd = open((char const   *)filename, flags | 128, mode);
    }
    if (fd < 0) {
      {
      tmp___1 = __errno_location();
      }
      if (*tmp___1 == 17) {
        tmp___0 = -2;
      } else {
        tmp___0 = fd;
      }
    } else {
      tmp___0 = fd;
    }
    return (tmp___0);
  }
  {
  fd = open((char const   *)filename, flags, mode);
  }
  if (fd < 0) {
    {
    tmp___4 = __errno_location();
    }
    if (*tmp___4 == 17) {
      tmp___3 = -2;
    } else {
      tmp___3 = fd;
    }
    return (tmp___3);
  }
  {
  tmp___5 = fstat(fd, & finfo2);
  }
  if (tmp___5 == 0) {
    if (((finfo2.st_mode & 61440U) == 32768U) == 0) {
      if (r == 0) {
        if (((finfo.st_mode & 61440U) == 32768U) == 0) {
          {
          tmp___6 = same_file(filename, filename, & finfo, & finfo2);
          }
          if (tmp___6) {
            return (fd);
          }
        }
      }
    }
  }
  {
  close(fd);
  tmp___7 = __errno_location();
  *tmp___7 = 17;
  }
  return (-2);
}
}
static int redir_open(char *filename , int flags , int mode , enum r_instruction ri ) 
{ 
  int fd ;
  int r ;
  int tmp ;

  {
  {
  r = find_string_in_alist(filename, _redir_special_filenames, 1);
  }
  if (r >= 0) {
    {
    tmp = redir_special_open(r, filename, flags, mode, ri);
    }
    return (tmp);
  }
  if (noclobber) {
    if ((unsigned int )ri == 0U) {
      goto _L;
    } else { //Added block
    if ((unsigned int )ri == 9U) {
      _L: 
      {
      fd = noclobber_open(filename, flags, mode, ri);
      }
      if (fd == -2) {
        return (-2);
      }
    } else {
      {
      fd = open((char const   *)filename, flags, mode);
      }
    }
    }
  } else {
    {
    fd = open((char const   *)filename, flags, mode);
    }
  }
  return (fd);
}
}
static int do_redirection_internal(REDIRECT *redirect , int for_real , int remembering ,
                                   int set_clexec ) 
{ 
  WORD_DESC *redirectee ;
  int redir_fd ;
  int fd ;
  int redirector ;
  int r ;
  int oflags ;
  char *redirectee_word ;
  enum r_instruction ri ;
  REDIRECT *new_redirect ;
  int tmp ;
  char *alloca_hack ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  redirectee = redirect->redirectee.filename;
  redir_fd = (int )redirect->redirectee.dest;
  redirector = redirect->redirector;
  ri = redirect->instruction;
  if ((unsigned int )ri == 12U) {
    goto _L___0;
  } else { //Added block
  if ((unsigned int )ri == 13U) {
    _L___0: 
    {
    redirectee_word = redirection_expand(redirectee);
    }
    if ((unsigned long )redirectee_word == (unsigned long )((char *)0)) {
      return (-1);
    } else { //Added block
    if ((int )*(redirectee_word + 0) == 45) {
      if ((int )*(redirectee_word + 1) == 0) {
        {
        rd.dest = 0L;
        new_redirect = make_redirection(redirector, (enum r_instruction )8, rd);
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
      tmp = all_digits(redirectee_word);
      }
      if (tmp) {
        if ((unsigned int )ri == 12U) {
          {
          rd.dest = atol((char const   *)redirectee_word);
          new_redirect = make_redirection(redirector, (enum r_instruction )5, rd);
          }
        } else {
          {
          rd.dest = atol((char const   *)redirectee_word);
          new_redirect = make_redirection(redirector, (enum r_instruction )6, rd);
          }
        }
      } else { //Added block
      if ((unsigned int )ri == 13U) {
        if (redirector == 1) {
          {
          rd.filename = make_bare_word(redirectee_word);
          new_redirect = make_redirection(1, (enum r_instruction )9, rd);
          }
        } else {
          {
          free((void *)redirectee_word);
          }
          return (-1);
        }
      } else {
        {
        free((void *)redirectee_word);
        }
        return (-1);
      }
      }
    }
    }
    {
    free((void *)redirectee_word);
    }
    if ((unsigned int )new_redirect->instruction == 9U) {
      {
      tmp___0 = __builtin_alloca(sizeof(WORD_DESC ));
      redirectee = (WORD_DESC *)tmp___0;
      xbcopy((char *)new_redirect->redirectee.filename, (char *)redirectee, (int )sizeof(WORD_DESC ));
      tmp___1 = strlen((char const   *)(new_redirect->redirectee.filename)->word);
      tmp___2 = __builtin_alloca(1UL + tmp___1);
      alloca_hack = (char *)tmp___2;
      redirectee->word = alloca_hack;
      strcpy((char * __restrict  )redirectee->word, (char const   * __restrict  )(new_redirect->redirectee.filename)->word);
      }
    } else {
      redirectee = new_redirect->redirectee.filename;
    }
    {
    redir_fd = (int )new_redirect->redirectee.dest;
    redirector = new_redirect->redirector;
    ri = new_redirect->instruction;
    redirect->flags = new_redirect->flags;
    dispose_redirects(new_redirect);
    }
  }
  }
  {
  if ((unsigned int )ri == 0U) {
    goto case_0;
  }
  if ((unsigned int )ri == 3U) {
    goto case_0;
  }
  if ((unsigned int )ri == 1U) {
    goto case_0;
  }
  if ((unsigned int )ri == 2U) {
    goto case_0;
  }
  if ((unsigned int )ri == 9U) {
    goto case_0;
  }
  if ((unsigned int )ri == 10U) {
    goto case_0;
  }
  if ((unsigned int )ri == 11U) {
    goto case_0;
  }
  if ((unsigned int )ri == 4U) {
    goto case_4;
  }
  if ((unsigned int )ri == 7U) {
    goto case_4;
  }
  if ((unsigned int )ri == 5U) {
    goto case_5;
  }
  if ((unsigned int )ri == 6U) {
    goto case_5;
  }
  if ((unsigned int )ri == 8U) {
    goto case_8;
  }
  if ((unsigned int )ri == 12U) {
    goto case_12;
  }
  if ((unsigned int )ri == 13U) {
    goto case_12;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
  if (posixly_correct) {
    if (interactive_shell == 0) {
      oflags = redirectee->flags;
      redirectee->flags |= 32;
    }
  }
  {
  redirectee_word = redirection_expand(redirectee);
  }
  if (posixly_correct) {
    if (interactive_shell == 0) {
      redirectee->flags = oflags;
    }
  }
  if ((unsigned long )redirectee_word == (unsigned long )((char *)0)) {
    return (-1);
  }
  if (restricted) {
    if ((unsigned int )ri == 0U) {
      {
      free((void *)redirectee_word);
      }
      return (-3);
    } else { //Added block
    if ((unsigned int )ri == 10U) {
      {
      free((void *)redirectee_word);
      }
      return (-3);
    } else { //Added block
    if ((unsigned int )ri == 9U) {
      {
      free((void *)redirectee_word);
      }
      return (-3);
    } else { //Added block
    if ((unsigned int )ri == 3U) {
      {
      free((void *)redirectee_word);
      }
      return (-3);
    } else { //Added block
    if ((unsigned int )ri == 11U) {
      {
      free((void *)redirectee_word);
      }
      return (-3);
    }
    }
    }
    }
    }
  }
  {
  fd = redir_open(redirectee_word, redirect->flags, 438, ri);
  free((void *)redirectee_word);
  }
  if (fd == -2) {
    return (fd);
  }
  if (fd < 0) {
    {
    tmp___3 = __errno_location();
    }
    return (*tmp___3);
  }
  if (for_real) {
    if (remembering) {
      if (fd != redirector) {
        {
        tmp___4 = fcntl(redirector, 1, 0);
        }
        if (tmp___4 != -1) {
          {
          add_undo_redirect(redirector);
          }
        } else {
          {
          add_undo_close_redirect(redirector);
          }
        }
      } else {
        {
        add_undo_close_redirect(redirector);
        }
      }
    }
    {
    check_bash_input(redirector);
    }
    if (fd != redirector) {
      {
      tmp___6 = dup2(fd, redirector);
      }
      if (tmp___6 < 0) {
        {
        tmp___5 = __errno_location();
        }
        return (*tmp___5);
      }
    }
    if ((unsigned int )ri == 1U) {
      {
      duplicate_buffered_stream(fd, redirector);
      }
    } else { //Added block
    if ((unsigned int )ri == 10U) {
      {
      duplicate_buffered_stream(fd, redirector);
      }
    }
    }
    if (set_clexec) {
      if (redirector > 2) {
        {
        fcntl(redirector, 2, 1);
        }
      }
    }
  }
  if (fd != redirector) {
    if ((unsigned int )ri == 1U) {
      {
      close_buffered_fd(fd);
      }
    } else { //Added block
    if ((unsigned int )ri == 2U) {
      {
      close_buffered_fd(fd);
      }
    } else { //Added block
    if ((unsigned int )ri == 10U) {
      {
      close_buffered_fd(fd);
      }
    } else {
      {
      close(fd);
      }
    }
    }
    }
  }
  if ((unsigned int )ri == 9U) {
    if (for_real) {
      if (remembering) {
        {
        add_undo_redirect(2);
        }
      }
      {
      tmp___8 = dup2(1, 2);
      }
      if (tmp___8 < 0) {
        {
        tmp___7 = __errno_location();
        }
        return (*tmp___7);
      }
    }
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  case_7: /* CIL Label */ 
  if (redirectee) {
    {
    fd = here_document_to_fd(redirectee);
    }
    if (fd < 0) {
      {
      tmp___9 = __errno_location();
      heredoc_errno = *tmp___9;
      }
      return (-4);
    }
    if (for_real) {
      if (remembering) {
        if (fd != redirector) {
          {
          tmp___10 = fcntl(redirector, 1, 0);
          }
          if (tmp___10 != -1) {
            {
            add_undo_redirect(redirector);
            }
          } else {
            {
            add_undo_close_redirect(redirector);
            }
          }
        } else {
          {
          add_undo_close_redirect(redirector);
          }
        }
      }
      {
      check_bash_input(redirector);
      }
      if (fd != redirector) {
        {
        tmp___12 = dup2(fd, redirector);
        }
        if (tmp___12 < 0) {
          {
          tmp___11 = __errno_location();
          r = *tmp___11;
          close(fd);
          }
          return (r);
        }
      }
      {
      duplicate_buffered_stream(fd, redirector);
      }
      if (set_clexec) {
        if (redirector > 2) {
          {
          fcntl(redirector, 2, 1);
          }
        }
      }
    }
    if (fd != redirector) {
      {
      close_buffered_fd(fd);
      }
    }
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  if (for_real) {
    if (redir_fd != redirector) {
      if (remembering) {
        {
        tmp___13 = fcntl(redirector, 1, 0);
        }
        if (tmp___13 != -1) {
          {
          add_undo_redirect(redirector);
          }
        } else {
          {
          add_undo_close_redirect(redirector);
          }
        }
      }
      {
      check_bash_input(redirector);
      tmp___15 = dup2(redir_fd, redirector);
      }
      if (tmp___15 < 0) {
        {
        tmp___14 = __errno_location();
        }
        return (*tmp___14);
      }
      if ((unsigned int )ri == 5U) {
        {
        duplicate_buffered_stream(redir_fd, redirector);
        }
      }
      {
      tmp___16 = fcntl(redir_fd, 1, 0);
      }
      if (tmp___16 == 1) {
        goto _L___1;
      } else { //Added block
      if (set_clexec) {
        _L___1: 
        if (redirector > 2) {
          {
          fcntl(redirector, 2, 1);
          }
        }
      }
      }
    }
  }
  goto switch_break;
  case_8: /* CIL Label */ 
  if (for_real) {
    if (remembering) {
      {
      tmp___17 = fcntl(redirector, 1, 0);
      }
      if (tmp___17 != -1) {
        {
        add_undo_redirect(redirector);
        }
      }
    }
    {
    check_bash_input(redirector);
    close_buffered_fd(redirector);
    }
  }
  goto switch_break;
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int add_undo_redirect(int fd ) 
{ 
  int new_fd ;
  int clexec_flag ;
  REDIRECT *new_redirect ;
  REDIRECT *closer ;
  REDIRECT *dummy_redirect ;

  {
  {
  new_fd = fcntl(fd, 0, 10);
  }
  if (new_fd < 0) {
    {
    sys_error("redirection error: cannot duplicate fd");
    }
    return (-1);
  }
  {
  clexec_flag = fcntl(fd, 1, 0);
  rd.dest = 0L;
  closer = make_redirection(new_fd, (enum r_instruction )8, rd);
  dummy_redirect = copy_redirects(closer);
  rd.dest = (long )new_fd;
  }
  if (fd == 0) {
    {
    new_redirect = make_redirection(fd, (enum r_instruction )5, rd);
    }
  } else {
    {
    new_redirect = make_redirection(fd, (enum r_instruction )6, rd);
    }
  }
  {
  new_redirect->next = closer;
  closer->next = redirection_undo_list;
  redirection_undo_list = new_redirect;
  add_exec_redirect(dummy_redirect);
  }
  if (clexec_flag) {
    {
    fcntl(new_fd, 2, 1);
    }
  } else { //Added block
  if (fd < 3) {
    {
    fcntl(new_fd, 2, 1);
    }
  }
  }
  return (0);
}
}
static void add_undo_close_redirect(int fd ) 
{ 
  REDIRECT *closer ;

  {
  {
  rd.dest = 0L;
  closer = make_redirection(fd, (enum r_instruction )8, rd);
  closer->next = redirection_undo_list;
  redirection_undo_list = closer;
  }
  return;
}
}
static void add_exec_redirect(REDIRECT *dummy_redirect ) 
{ 


  {
  dummy_redirect->next = exec_redirection_undo_list;
  exec_redirection_undo_list = dummy_redirect;
  return;
}
}
static int stdin_redirection(enum r_instruction ri , int redirector ) 
{ 


  {
  {
  if ((unsigned int )ri == 1U) {
    goto case_1;
  }
  if ((unsigned int )ri == 2U) {
    goto case_1;
  }
  if ((unsigned int )ri == 10U) {
    goto case_1;
  }
  if ((unsigned int )ri == 4U) {
    goto case_1;
  }
  if ((unsigned int )ri == 7U) {
    goto case_1;
  }
  if ((unsigned int )ri == 5U) {
    goto case_5;
  }
  if ((unsigned int )ri == 12U) {
    goto case_5;
  }
  if ((unsigned int )ri == 8U) {
    goto case_5;
  }
  if ((unsigned int )ri == 0U) {
    goto case_0;
  }
  if ((unsigned int )ri == 3U) {
    goto case_0;
  }
  if ((unsigned int )ri == 6U) {
    goto case_0;
  }
  if ((unsigned int )ri == 9U) {
    goto case_0;
  }
  if ((unsigned int )ri == 11U) {
    goto case_0;
  }
  if ((unsigned int )ri == 13U) {
    goto case_0;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_7: /* CIL Label */ 
  return (1);
  case_5: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  return (redirector == 0);
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_13: /* CIL Label */ 
  return (0);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
int stdin_redirects(REDIRECT *redirs ) 
{ 
  REDIRECT *rp ;
  int n ;
  int tmp ;

  {
  n = 0;
  rp = redirs;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! rp) {
      goto while_break;
    }
    {
    tmp = stdin_redirection(rp->instruction, rp->redirector);
    n += tmp;
    rp = rp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (n);
}
}
#pragma merger("0","/tmp/cil-RzldDuEE.i","-g")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
extern STRINGLIST *alloc_stringlist(int  ) ;
extern STRINGLIST *realloc_stringlist(STRINGLIST * , int  ) ;
extern void free_stringlist(STRINGLIST * ) ;
extern STRINGLIST *append_stringlist(STRINGLIST * , STRINGLIST * ) ;
extern STRINGLIST *prefix_suffix_stringlist(STRINGLIST * , char * , char * ) ;
extern void print_stringlist(STRINGLIST * , char * ) ;
ITEMLIST it_arrayvars ;
ITEMLIST it_bindings ;
ITEMLIST it_builtins ;
ITEMLIST it_commands ;
ITEMLIST it_directories ;
ITEMLIST it_disabled ;
ITEMLIST it_enabled ;
ITEMLIST it_exports ;
ITEMLIST it_files ;
ITEMLIST it_hostnames ;
ITEMLIST it_jobs ;
ITEMLIST it_keywords ;
ITEMLIST it_running ;
ITEMLIST it_setopts ;
ITEMLIST it_shopts ;
ITEMLIST it_signals ;
ITEMLIST it_stopped ;
ITEMLIST it_users ;
ITEMLIST it_variables ;
COMPSPEC *alloc_compspec(void) ;
void free_compspec(COMPSPEC *cs ) ;
COMPSPEC *find_compspec(char const   *cmd ) ;
STRINGLIST *gen_compspec_completions(COMPSPEC *cs , char const   *cmd , char const   *word ,
                                     int start , int end ) ;
extern char **get_minus_o_opts(void) ;
extern char **get_shopt_options(void) ;
extern char const   **rl_funmap_names(void) ;
static int it_init_aliases(ITEMLIST *itp ) ;
static int it_init_arrayvars(ITEMLIST *itp ) ;
static int it_init_bindings(ITEMLIST *itp ) ;
static int it_init_builtins(ITEMLIST *itp ) ;
static int it_init_disabled(ITEMLIST *itp ) ;
static int it_init_enabled(ITEMLIST *itp ) ;
static int it_init_exported(ITEMLIST *itp ) ;
static int it_init_functions(ITEMLIST *itp ) ;
static int it_init_hostnames(ITEMLIST *itp ) ;
static int it_init_jobs(ITEMLIST *itp ) ;
static int it_init_running(ITEMLIST *itp ) ;
static int it_init_stopped(ITEMLIST *itp ) ;
static int it_init_keywords(ITEMLIST *itp ) ;
static int it_init_signals(ITEMLIST *itp ) ;
static int it_init_variables(ITEMLIST *itp ) ;
static int it_init_setopts(ITEMLIST *itp ) ;
static int it_init_shopts(ITEMLIST *itp ) ;
static int progcomp_debug  =    0;
int prog_completion_enabled  =    1;
ITEMLIST it_aliases  =    {0, (Function *)(& it_init_aliases), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_arrayvars  =    {1, (Function *)(& it_init_arrayvars), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_bindings  =    {0, (Function *)(& it_init_bindings), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_builtins  =    {0, (Function *)(& it_init_builtins), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_commands  =    {1, (Function *)0, (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_directories  =    {1, (Function *)0, (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_disabled  =    {0, (Function *)(& it_init_disabled), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_enabled  =    {0, (Function *)(& it_init_enabled), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_exports  =    {1, (Function *)(& it_init_exported), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_files  =    {1, (Function *)0, (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_functions  =    {0, (Function *)(& it_init_functions), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_hostnames  =    {1, (Function *)(& it_init_hostnames), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_jobs  =    {1, (Function *)(& it_init_jobs), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_keywords  =    {0, (Function *)(& it_init_keywords), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_running  =    {1, (Function *)(& it_init_running), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_setopts  =    {0, (Function *)(& it_init_setopts), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_shopts  =    {0, (Function *)(& it_init_shopts), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_signals  =    {0, (Function *)(& it_init_signals), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_stopped  =    {1, (Function *)(& it_init_stopped), (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_users  =    {1, (Function *)0, (STRINGLIST *)0, (STRINGLIST *)0, 0};
ITEMLIST it_variables  =    {1, (Function *)(& it_init_variables), (STRINGLIST *)0, (STRINGLIST *)0, 0};
static void debug_printf(char const   *format  , ...) 
{ 
  va_list args ;

  {
  if (progcomp_debug == 0) {
    return;
  }
  {
  __builtin_va_start(args, format);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"DEBUG: ");
  vfprintf((FILE * __restrict  )stdout, (char const   * __restrict  )format, args);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  rl_on_new_line();
  __builtin_va_end(args);
  }
  return;
}
}
void set_itemlist_dirty(ITEMLIST *it ) 
{ 


  {
  it->flags |= 2;
  return;
}
}
void initialize_itemlist(ITEMLIST *itp ) 
{ 


  {
  {
  (*(itp->list_getter))(itp);
  itp->flags |= 4;
  itp->flags &= -3;
  }
  return;
}
}
void clean_itemlist(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;

  {
  sl = itp->slist;
  if (sl) {
    if ((itp->flags & 48) == 0) {
      {
      free_array_members(sl->list);
      }
    }
    if ((itp->flags & 16) == 0) {
      {
      free((void *)sl->list);
      }
    }
    {
    free((void *)sl);
    }
  }
  itp->slist = (STRINGLIST *)((void *)0);
  itp->flags &= -55;
  return;
}
}
static int shouldexp_filterpat(char *s ) 
{ 
  register char *p ;

  {
  p = s;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (p) {
      if (! *p) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p == 92) {
      p ++;
    } else { //Added block
    if ((int )*p == 38) {
      return (1);
    }
    }
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static char *preproc_filterpat(char *pat , char *text___0 ) 
{ 
  char *ret ;

  {
  {
  ret = strcreplace(pat, '&', text___0, 1);
  }
  return (ret);
}
}
STRINGLIST *filter_stringlist(STRINGLIST *sl , char *filterpat , char *text___0 ) 
{ 
  int i ;
  int m ;
  int not ;
  STRINGLIST *ret ;
  char *npat ;
  char *t ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned long )sl == (unsigned long )((STRINGLIST *)0)) {
    return (sl);
  } else { //Added block
  if ((unsigned long )sl->list == (unsigned long )((char **)0)) {
    return (sl);
  } else { //Added block
  if (sl->list_len == 0) {
    return (sl);
  }
  }
  }
  {
  tmp___1 = shouldexp_filterpat(filterpat);
  }
  if (tmp___1) {
    {
    tmp___0 = preproc_filterpat(filterpat, text___0);
    npat = tmp___0;
    }
  } else {
    npat = filterpat;
  }
  not = (int )*(npat + 0) == 33;
  if (not) {
    t = npat + 1;
  } else {
    t = npat;
  }
  {
  ret = alloc_stringlist(sl->list_size);
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < sl->list_len)) {
      goto while_break;
    }
    if (extended_glob) {
      tmp___2 = 1 << 5;
    } else {
      tmp___2 = 0;
    }
    {
    m = fnmatch(t, *(sl->list + i), tmp___2);
    }
    if (not) {
      if (m == 1) {
        {
        free((void *)*(sl->list + i));
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (not == 0) {
      if (m != 1) {
        {
        free((void *)*(sl->list + i));
        }
      } else {
        tmp___3 = ret->list_len;
        (ret->list_len) ++;
        *(ret->list + tmp___3) = *(sl->list + i);
      }
    } else {
      tmp___3 = ret->list_len;
      (ret->list_len) ++;
      *(ret->list + tmp___3) = *(sl->list + i);
    }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  *(ret->list + ret->list_len) = (char *)((void *)0);
  if ((unsigned long )npat != (unsigned long )filterpat) {
    {
    free((void *)npat);
    }
  }
  return (ret);
}
}
STRINGLIST *completions_to_stringlist(char **matches___1 ) 
{ 
  STRINGLIST *sl ;
  int mlen ;
  int i ;
  int n ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  if ((unsigned long )matches___1 == (unsigned long )((char **)0)) {
    mlen = 0;
  } else {
    {
    tmp = array_len(matches___1);
    mlen = tmp;
    }
  }
  {
  sl = alloc_stringlist(mlen + 1);
  }
  if ((unsigned long )matches___1 == (unsigned long )((char **)0)) {
    return (sl);
  } else { //Added block
  if ((unsigned long )*(matches___1 + 0) == (unsigned long )((char *)0)) {
    return (sl);
  }
  }
  if ((unsigned long )*(matches___1 + 1) == (unsigned long )((char *)0)) {
    if (*(matches___1 + 0)) {
      {
      tmp___0 = strlen((char const   *)*(matches___1 + 0));
      tmp___1 = xmalloc(1UL + tmp___0);
      tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )*(matches___1 + 0));
      *(sl->list + 0) = tmp___2;
      }
    } else {
      *(sl->list + 0) = (char *)((void *)0);
    }
    tmp___3 = 1;
    sl->list_len = tmp___3;
    *(sl->list + tmp___3) = (char *)((void *)0);
    return (sl);
  }
  i = 1;
  n = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < mlen)) {
      goto while_break;
    }
    if (*(matches___1 + i)) {
      {
      tmp___4 = strlen((char const   *)*(matches___1 + i));
      tmp___5 = xmalloc(1UL + tmp___4);
      tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )*(matches___1 + i));
      *(sl->list + n) = tmp___6;
      }
    } else {
      *(sl->list + n) = (char *)((void *)0);
    }
    i ++;
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  sl->list_len = n;
  *(sl->list + n) = (char *)((void *)0);
  return (sl);
}
}
static int it_init_aliases(ITEMLIST *itp ) 
{ 
  alias_t **aliases___0 ;
  register int i ;
  register int n ;
  STRINGLIST *sl ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
  aliases___0 = all_aliases();
  }
  if ((unsigned long )aliases___0 == (unsigned long )((alias_t **)0)) {
    itp->slist = (STRINGLIST *)((void *)0);
    return (0);
  }
  n = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(aliases___0 + n)) {
      goto while_break;
    }
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sl = alloc_stringlist(n + 1);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < n)) {
      goto while_break___0;
    }
    if ((*(aliases___0 + i))->name) {
      {
      tmp = strlen((char const   *)(*(aliases___0 + i))->name);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )(*(aliases___0 + i))->name);
      *(sl->list + i) = tmp___1;
      }
    } else {
      *(sl->list + i) = (char *)((void *)0);
    }
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *(sl->list + n) = (char *)((void *)0);
  tmp___2 = n;
  sl->list_len = tmp___2;
  sl->list_size = tmp___2;
  itp->slist = sl;
  return (1);
}
}
static void init_itemlist_from_varlist(ITEMLIST *itp , SVFUNC *svfunc ) 
{ 
  SHELL_VAR **vlist ;
  STRINGLIST *sl ;
  register int i ;
  register int n ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
  vlist = (*svfunc)();
  n = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(vlist + n)) {
      goto while_break;
    }
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sl = alloc_stringlist(n + 1);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < n)) {
      goto while_break___0;
    }
    {
    tmp = strlen((char const   *)(*(vlist + i))->name);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )(*(vlist + i))->name);
    *(sl->list + i) = tmp___1;
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  tmp___2 = n;
  sl->list_len = tmp___2;
  *(sl->list + tmp___2) = (char *)((void *)0);
  itp->slist = sl;
  return;
}
}
static int it_init_arrayvars(ITEMLIST *itp ) 
{ 


  {
  {
  init_itemlist_from_varlist(itp, & all_array_variables);
  }
  return (1);
}
}
static int it_init_bindings(ITEMLIST *itp ) 
{ 
  char **blist ;
  STRINGLIST *sl ;
  char const   **tmp ;

  {
  {
  tmp = rl_funmap_names();
  blist = (char **)tmp;
  sl = alloc_stringlist(0);
  sl->list = blist;
  sl->list_size = 0;
  sl->list_len = array_len(sl->list);
  itp->flags |= 32;
  itp->slist = sl;
  }
  return (0);
}
}
static int it_init_builtins(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;
  register int i ;
  register int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
  sl = alloc_stringlist(num_shell_builtins);
  n = 0;
  i = n;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < num_shell_builtins)) {
      goto while_break;
    }
    if ((shell_builtins + i)->function) {
      tmp = n;
      n ++;
      *(sl->list + tmp) = (shell_builtins + i)->name;
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  tmp___0 = n;
  sl->list_len = tmp___0;
  *(sl->list + tmp___0) = (char *)((void *)0);
  itp->flags |= 32;
  itp->slist = sl;
  return (0);
}
}
static int it_init_enabled(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;
  register int i ;
  register int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
  sl = alloc_stringlist(num_shell_builtins);
  n = 0;
  i = n;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < num_shell_builtins)) {
      goto while_break;
    }
    if ((shell_builtins + i)->function) {
      if ((shell_builtins + i)->flags & 1) {
        tmp = n;
        n ++;
        *(sl->list + tmp) = (shell_builtins + i)->name;
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  tmp___0 = n;
  sl->list_len = tmp___0;
  *(sl->list + tmp___0) = (char *)((void *)0);
  itp->flags |= 32;
  itp->slist = sl;
  return (0);
}
}
static int it_init_disabled(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;
  register int i ;
  register int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
  sl = alloc_stringlist(num_shell_builtins);
  n = 0;
  i = n;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < num_shell_builtins)) {
      goto while_break;
    }
    if ((shell_builtins + i)->function) {
      if (((shell_builtins + i)->flags & 1) == 0) {
        tmp = n;
        n ++;
        *(sl->list + tmp) = (shell_builtins + i)->name;
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  tmp___0 = n;
  sl->list_len = tmp___0;
  *(sl->list + tmp___0) = (char *)((void *)0);
  itp->flags |= 32;
  itp->slist = sl;
  return (0);
}
}
static int it_init_exported(ITEMLIST *itp ) 
{ 


  {
  {
  init_itemlist_from_varlist(itp, & all_exported_variables);
  }
  return (0);
}
}
static int it_init_functions(ITEMLIST *itp ) 
{ 


  {
  {
  init_itemlist_from_varlist(itp, & all_visible_functions);
  }
  return (0);
}
}
static int it_init_hostnames(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;
  int tmp ;

  {
  {
  sl = alloc_stringlist(0);
  sl->list = get_hostname_list();
  }
  if (sl->list) {
    {
    tmp = array_len(sl->list);
    sl->list_len = tmp;
    }
  } else {
    sl->list_len = 0;
  }
  sl->list_size = sl->list_len;
  itp->slist = sl;
  itp->flags |= 48;
  return (0);
}
}
static int it_init_joblist(ITEMLIST *itp , int jstate ) 
{ 
  STRINGLIST *sl ;
  register int i ;
  register PROCESS *p ;
  char *s ;
  char *t ;
  JOB_STATE js ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  if (jstate == 0) {
    js = (JOB_STATE )0;
  } else { //Added block
  if (jstate == 1) {
    js = (JOB_STATE )1;
  }
  }
  {
  sl = alloc_stringlist(job_slots);
  i = job_slots - 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i >= 0)) {
      goto while_break;
    }
    if ((unsigned long )*(jobs + i) == (unsigned long )((JOB *)0)) {
      goto __Cont;
    }
    p = (*(jobs + i))->pipe;
    if (jstate == -1) {
      goto _L;
    } else { //Added block
    if ((unsigned int )(*(jobs + i))->state == (unsigned int )js) {
      _L: 
      {
      tmp = strlen((char const   *)p->command);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )p->command);
      s = tmp___1;
      t = strpbrk((char const   *)s, " \t\n");
      }
      if (t) {
        *t = (char )'\000';
      }
      tmp___2 = sl->list_len;
      (sl->list_len) ++;
      *(sl->list + tmp___2) = s;
    }
    }
    __Cont: 
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  itp->slist = sl;
  return (0);
}
}
static int it_init_jobs(ITEMLIST *itp ) 
{ 
  int tmp ;

  {
  {
  tmp = it_init_joblist(itp, -1);
  }
  return (tmp);
}
}
static int it_init_running(ITEMLIST *itp ) 
{ 
  int tmp ;

  {
  {
  tmp = it_init_joblist(itp, 0);
  }
  return (tmp);
}
}
static int it_init_stopped(ITEMLIST *itp ) 
{ 
  int tmp ;

  {
  {
  tmp = it_init_joblist(itp, 1);
  }
  return (tmp);
}
}
static int it_init_keywords(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;
  register int i ;
  register int n ;
  int tmp ;

  {
  n = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! word_token_alist[n].word) {
      goto while_break;
    }
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  sl = alloc_stringlist(n);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < n)) {
      goto while_break___0;
    }
    *(sl->list + i) = word_token_alist[i].word;
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  tmp = i;
  sl->list_len = tmp;
  *(sl->list + tmp) = (char *)((void *)0);
  itp->flags |= 32;
  itp->slist = sl;
  return (0);
}
}
static int it_init_signals(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;

  {
  {
  sl = alloc_stringlist(0);
  sl->list = signal_names;
  sl->list_len = array_len(sl->list);
  itp->flags |= 16;
  itp->slist = sl;
  }
  return (0);
}
}
static int it_init_variables(ITEMLIST *itp ) 
{ 


  {
  {
  init_itemlist_from_varlist(itp, & all_visible_variables);
  }
  return (0);
}
}
static int it_init_setopts(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;

  {
  {
  sl = alloc_stringlist(0);
  sl->list = get_minus_o_opts();
  sl->list_len = array_len(sl->list);
  itp->slist = sl;
  itp->flags |= 32;
  }
  return (0);
}
}
static int it_init_shopts(ITEMLIST *itp ) 
{ 
  STRINGLIST *sl ;

  {
  {
  sl = alloc_stringlist(0);
  sl->list = get_shopt_options();
  sl->list_len = array_len(sl->list);
  itp->slist = sl;
  itp->flags |= 32;
  }
  return (0);
}
}
static STRINGLIST *gen_matches_from_itemlist(ITEMLIST *itp , char const   *text___0 ) 
{ 
  STRINGLIST *ret ;
  STRINGLIST *sl ;
  int tlen ;
  int i ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  if (itp->flags & 3) {
    goto _L;
  } else { //Added block
  if ((itp->flags & 4) == 0) {
    _L: 
    if (itp->flags & 3) {
      {
      clean_itemlist(itp);
      }
    }
    if ((itp->flags & 4) == 0) {
      {
      initialize_itemlist(itp);
      }
    }
  }
  }
  {
  ret = alloc_stringlist((itp->slist)->list_len + 1);
  sl = itp->slist;
  }
  if (text___0) {
    if (*(text___0 + 0)) {
      if (*(text___0 + 1)) {
        if (*(text___0 + 2)) {
          {
          tmp = strlen(text___0);
          tmp___0 = tmp;
          }
        } else {
          tmp___0 = (size_t )2;
        }
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (size_t )1;
      }
      tlen = (int )tmp___1;
    } else {
      tlen = 0;
    }
  } else {
    tlen = 0;
  }
  n = 0;
  i = n;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < sl->list_len)) {
      goto while_break;
    }
    if (tlen == 0) {
      goto _L___0;
    } else {
      if (tlen == 0) {
        tmp___8 = 1;
      } else {
        if ((int )*(*(sl->list + i) + 0) == (int )*(text___0 + 0)) {
          {
          tmp___6 = strncmp((char const   *)*(sl->list + i), text___0, (size_t )tlen);
          }
          if (tmp___6 == 0) {
            tmp___7 = 1;
          } else {
            tmp___7 = 0;
          }
        } else {
          tmp___7 = 0;
        }
        tmp___8 = tmp___7;
      }
      if (tmp___8) {
        _L___0: 
        tmp___2 = n;
        n ++;
        if (*(sl->list + i)) {
          {
          tmp___3 = strlen((char const   *)*(sl->list + i));
          tmp___4 = xmalloc(1UL + tmp___3);
          tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )*(sl->list + i));
          *(ret->list + tmp___2) = tmp___5;
          }
        } else {
          *(ret->list + tmp___2) = (char *)((void *)0);
        }
      }
    }
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  tmp___9 = n;
  ret->list_len = tmp___9;
  *(ret->list + tmp___9) = (char *)((void *)0);
  return (ret);
}
}
static char *dfn  ;
static char *pcomp_filename_completion_function(char const   *text___0 , int state ) 
{ 
  int qc ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if (state == 0) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (dfn) {
        {
        free((void *)dfn);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    if (rl_filename_dequoting_function) {
      if ((int const   )*(text___0 + 0) == 34) {
        qc = (int )*(text___0 + 0);
      } else { //Added block
      if ((int const   )*(text___0 + 0) == 39) {
        qc = (int )*(text___0 + 0);
      } else {
        qc = 0;
      }
      }
      {
      dfn = (*rl_filename_dequoting_function)((char *)text___0, qc);
      }
    } else {
      {
      tmp = strlen(text___0);
      tmp___0 = xmalloc(1UL + tmp);
      tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )text___0);
      dfn = tmp___1;
      }
    }
  }
  {
  tmp___2 = rl_filename_completion_function((char const   *)dfn, state);
  }
  return (tmp___2);
}
}
static STRINGLIST *gen_action_completions(COMPSPEC *cs , char const   *text___0 ) 
{ 
  STRINGLIST *ret ;
  STRINGLIST *tmatches ;
  char **cmatches ;
  unsigned long flags ;

  {
  tmatches = (STRINGLIST *)((void *)0);
  ret = tmatches;
  flags = cs->actions;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (flags & 1UL) {
      {
      tmatches = gen_matches_from_itemlist(& it_aliases, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 1)) {
      {
      tmatches = gen_matches_from_itemlist(& it_arrayvars, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 2)) {
      {
      tmatches = gen_matches_from_itemlist(& it_bindings, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 3)) {
      {
      tmatches = gen_matches_from_itemlist(& it_builtins, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 6)) {
      {
      tmatches = gen_matches_from_itemlist(& it_disabled, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 7)) {
      {
      tmatches = gen_matches_from_itemlist(& it_enabled, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 8)) {
      {
      tmatches = gen_matches_from_itemlist(& it_exports, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___6: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 10)) {
      {
      tmatches = gen_matches_from_itemlist(& it_functions, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___7: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 12)) {
      {
      tmatches = gen_matches_from_itemlist(& it_hostnames, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___8: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 13)) {
      {
      tmatches = gen_matches_from_itemlist(& it_jobs, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___9: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 14)) {
      {
      tmatches = gen_matches_from_itemlist(& it_keywords, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___10: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 15)) {
      {
      tmatches = gen_matches_from_itemlist(& it_running, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___11: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 16)) {
      {
      tmatches = gen_matches_from_itemlist(& it_setopts, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___12: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 17)) {
      {
      tmatches = gen_matches_from_itemlist(& it_shopts, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___13: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 18)) {
      {
      tmatches = gen_matches_from_itemlist(& it_signals, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___14: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 19)) {
      {
      tmatches = gen_matches_from_itemlist(& it_stopped, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___15: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 21)) {
      {
      tmatches = gen_matches_from_itemlist(& it_variables, text___0);
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___16: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 4)) {
      {
      cmatches = rl_completion_matches(text___0, & command_word_completion_function);
      tmatches = completions_to_stringlist(cmatches);
      ret = append_stringlist(ret, tmatches);
      free_array(cmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___17: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 9)) {
      {
      cmatches = rl_completion_matches(text___0, & pcomp_filename_completion_function);
      tmatches = completions_to_stringlist(cmatches);
      ret = append_stringlist(ret, tmatches);
      free_array(cmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___18: /* CIL Label */ ;
    if (flags & (unsigned long )(1 << 20)) {
      {
      cmatches = rl_completion_matches(text___0, & rl_username_completion_function);
      tmatches = completions_to_stringlist(cmatches);
      ret = append_stringlist(ret, tmatches);
      free_array(cmatches);
      free_stringlist(tmatches);
      }
    }
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
  if (flags & (unsigned long )(1 << 5)) {
    {
    cmatches = bash_directory_completion_matches(text___0);
    tmatches = completions_to_stringlist(cmatches);
    ret = append_stringlist(ret, tmatches);
    free_array(cmatches);
    free_stringlist(tmatches);
    }
  }
  return (ret);
}
}
static STRINGLIST *gen_globpat_matches(COMPSPEC *cs , char const   *text___0 ) 
{ 
  STRINGLIST *sl ;
  int tmp ;

  {
  {
  sl = alloc_stringlist(0);
  sl->list = glob_filename(cs->globpat);
  }
  if ((unsigned long )sl->list == (unsigned long )(& glob_error_return)) {
    sl->list = (char **)((void *)0);
  }
  if (sl->list) {
    {
    tmp = array_len(sl->list);
    sl->list_size = tmp;
    sl->list_len = tmp;
    }
  }
  return (sl);
}
}
static STRINGLIST *gen_wordlist_matches(COMPSPEC *cs , char const   *text___0 ) 
{ 
  WORD_LIST *l ;
  WORD_LIST *l2 ;
  STRINGLIST *sl ;
  int nw ;
  int tlen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  if ((unsigned long )cs->words == (unsigned long )((char *)0)) {
    return ((STRINGLIST *)((void *)0));
  } else { //Added block
  if ((int )*(cs->words + 0) == 0) {
    return ((STRINGLIST *)((void *)0));
  }
  }
  {
  tmp = strlen((char const   *)cs->words);
  l = split_at_delims(cs->words, (int )tmp, (char *)((void *)0), -1, (int *)((void *)0),
                      (int *)((void *)0));
  }
  if ((unsigned long )l == (unsigned long )((WORD_LIST *)0)) {
    return ((STRINGLIST *)((void *)0));
  }
  {
  l2 = expand_words_shellexp(l);
  dispose_words(l);
  nw = list_length((GENERIC_LIST *)l2);
  sl = alloc_stringlist(nw + 1);
  }
  if (text___0) {
    if (*(text___0 + 0)) {
      if (*(text___0 + 1)) {
        if (*(text___0 + 2)) {
          {
          tmp___0 = strlen(text___0);
          tmp___1 = tmp___0;
          }
        } else {
          tmp___1 = (size_t )2;
        }
        tmp___2 = tmp___1;
      } else {
        tmp___2 = (size_t )1;
      }
      tlen = (int )tmp___2;
    } else {
      tlen = 0;
    }
  } else {
    tlen = 0;
  }
  nw = 0;
  l = l2;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! l) {
      goto while_break;
    }
    if (tlen == 0) {
      goto _L;
    } else {
      if (tlen == 0) {
        tmp___9 = 1;
      } else {
        if ((int )*((l->word)->word + 0) == (int )*(text___0 + 0)) {
          {
          tmp___7 = strncmp((char const   *)(l->word)->word, text___0, (size_t )tlen);
          }
          if (tmp___7 == 0) {
            tmp___8 = 1;
          } else {
            tmp___8 = 0;
          }
        } else {
          tmp___8 = 0;
        }
        tmp___9 = tmp___8;
      }
      if (tmp___9) {
        _L: 
        tmp___3 = nw;
        nw ++;
        if ((l->word)->word) {
          {
          tmp___4 = strlen((char const   *)(l->word)->word);
          tmp___5 = xmalloc(1UL + tmp___4);
          tmp___6 = strcpy((char * __restrict  )tmp___5, (char const   * __restrict  )(l->word)->word);
          *(sl->list + tmp___3) = tmp___6;
          }
        } else {
          *(sl->list + tmp___3) = (char *)((void *)0);
        }
      }
    }
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  tmp___10 = nw;
  sl->list_len = tmp___10;
  *(sl->list + tmp___10) = (char *)((void *)0);
  return (sl);
}
}
static SHELL_VAR *bind_comp_words(WORD_LIST *lwords ) 
{ 
  SHELL_VAR *v___0 ;

  {
  {
  v___0 = find_variable((char *)"COMP_WORDS");
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    {
    v___0 = make_new_array_variable((char *)"COMP_WORDS");
    }
  }
  if (v___0->attributes & 2) {
    v___0->attributes &= -3;
  }
  if ((v___0->attributes & 8) == 0) {
    {
    v___0 = convert_var_to_array(v___0);
    }
  }
  {
  v___0 = assign_array_var_from_word_list(v___0, lwords);
  }
  return (v___0);
}
}
static void bind_compfunc_variables(char *line , int ind___1 , WORD_LIST *lwords ,
                                    int cw , int exported ) 
{ 
  char ibuf[32] ;
  char *value ;
  SHELL_VAR *v___0 ;

  {
  {
  v___0 = bind_variable((char *)"COMP_LINE", line);
  }
  if (v___0) {
    if (exported) {
      v___0->attributes |= 1;
    }
  }
  {
  value = inttostr(ind___1, ibuf, 32);
  v___0 = bind_int_variable((char *)"COMP_POINT", value);
  }
  if (v___0) {
    if (exported) {
      v___0->attributes |= 1;
    }
  }
  if (exported == 0) {
    {
    v___0 = bind_comp_words(lwords);
    value = inttostr(cw, ibuf, 32);
    bind_int_variable((char *)"COMP_CWORD", value);
    }
  } else {
    array_needs_making = 1;
  }
  return;
}
}
static void unbind_compfunc_variables(int exported ) 
{ 


  {
  {
  makunbound((char *)"COMP_LINE", shell_variables);
  makunbound((char *)"COMP_POINT", shell_variables);
  makunbound((char *)"COMP_WORDS", shell_variables);
  makunbound((char *)"COMP_CWORD", shell_variables);
  }
  if (exported) {
    array_needs_making = 1;
  }
  return;
}
}
static WORD_LIST *build_arg_list(char *cmd , char *text___0 , WORD_LIST *lwords ,
                                 int ind___1 ) 
{ 
  WORD_LIST *ret ;
  WORD_LIST *cl ;
  WORD_LIST *l ;
  WORD_DESC *w ;
  int i ;
  WORD_DESC *tmp ;
  WORD_DESC *tmp___0 ;
  struct word_list *tmp___1 ;
  WORD_DESC *tmp___2 ;
  WORD_DESC *tmp___3 ;

  {
  {
  ret = (WORD_LIST *)((void *)0);
  w = make_word(cmd);
  ret = make_word_list(w, (WORD_LIST *)((void *)0));
  }
  if (lwords) {
    if (lwords->word) {
      {
      tmp = copy_word(lwords->word);
      w = tmp;
      }
    } else {
      {
      tmp___0 = make_word((char *)"");
      w = tmp___0;
      }
    }
  } else {
    {
    tmp___0 = make_word((char *)"");
    w = tmp___0;
    }
  }
  {
  tmp___1 = make_word_list(w, (WORD_LIST *)((void *)0));
  ret->next = tmp___1;
  cl = tmp___1;
  w = make_word(text___0);
  cl->next = make_word_list(w, (WORD_LIST *)((void *)0));
  cl = cl->next;
  l = lwords;
  i = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (l) {
      if (! (i < ind___1 - 1)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    l = l->next;
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (l) {
    if (l->word) {
      {
      tmp___2 = copy_word(l->word);
      w = tmp___2;
      }
    } else {
      {
      tmp___3 = make_word((char *)"");
      w = tmp___3;
      }
    }
  } else {
    {
    tmp___3 = make_word((char *)"");
    w = tmp___3;
    }
  }
  {
  cl->next = make_word_list(w, (WORD_LIST *)((void *)0));
  }
  return (ret);
}
}
static STRINGLIST *gen_shell_function_matches(COMPSPEC *cs , char *text___0 , char *line ,
                                              int ind___1 , WORD_LIST *lwords , int nw ,
                                              int cw ) 
{ 
  char *funcname ;
  STRINGLIST *sl ;
  SHELL_VAR *f ;
  SHELL_VAR *v___0 ;
  WORD_LIST *cmdlist ;
  int fval ;
  ARRAY *a ;
  int tmp ;

  {
  {
  funcname = cs->funcname;
  f = find_function(funcname);
  }
  if ((unsigned long )f == (unsigned long )((SHELL_VAR *)0)) {
    {
    internal_error("completion: function `%s\' not found", funcname);
    rl_ding();
    rl_on_new_line();
    }
    return ((STRINGLIST *)((void *)0));
  }
  {
  bind_compfunc_variables(line, ind___1, lwords, cw - 1, 0);
  cmdlist = build_arg_list(funcname, text___0, lwords, cw);
  fval = execute_shell_function(f, cmdlist);
  dispose_words(cmdlist);
  unbind_compfunc_variables(0);
  v___0 = find_variable((char *)"COMPREPLY");
  }
  if ((unsigned long )v___0 == (unsigned long )((SHELL_VAR *)0)) {
    return ((STRINGLIST *)((void *)0));
  }
  if ((v___0->attributes & 8) == 0) {
    {
    v___0 = convert_var_to_array(v___0);
    }
  }
  a = (ARRAY *)v___0->value;
  if ((unsigned long )a == (unsigned long )((ARRAY *)0)) {
    sl = (STRINGLIST *)((void *)0);
  } else { //Added block
  if (a->num_elements == 0) {
    sl = (STRINGLIST *)((void *)0);
  } else {
    {
    sl = alloc_stringlist(0);
    sl->list = array_to_argv(a);
    tmp = a->num_elements;
    sl->list_size = tmp;
    sl->list_len = tmp;
    }
  }
  }
  {
  makunbound((char *)"COMPREPLY", shell_variables);
  }
  return (sl);
}
}
static STRINGLIST *gen_command_matches(COMPSPEC *cs , char *text___0 , char *line ,
                                       int ind___1 , WORD_LIST *lwords , int nw ,
                                       int cw ) 
{ 
  char *csbuf ;
  char *cscmd ;
  char *t ;
  int cmdlen ;
  int cmdsize ;
  int n ;
  int ws ;
  int we ;
  WORD_LIST *cmdlist ;
  WORD_LIST *cl ;
  STRINGLIST *sl ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
  bind_compfunc_variables(line, ind___1, lwords, cw, 1);
  cmdlist = build_arg_list(cs->command, text___0, lwords, cw);
  tmp = strlen((char const   *)cs->command);
  n = (int )tmp;
  cmdsize = n + 1;
  cl = cmdlist->next;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! cl) {
      goto while_break;
    }
    if ((cl->word)->word) {
      if (*((cl->word)->word + 0)) {
        if (*((cl->word)->word + 1)) {
          if (*((cl->word)->word + 2)) {
            {
            tmp___0 = strlen((char const   *)(cl->word)->word);
            tmp___1 = tmp___0;
            }
          } else {
            tmp___1 = (size_t )2;
          }
          tmp___2 = tmp___1;
        } else {
          tmp___2 = (size_t )1;
        }
        tmp___3 = tmp___2;
      } else {
        tmp___3 = (size_t )0;
      }
    } else {
      tmp___3 = (size_t )0;
    }
    cmdsize = (int )((size_t )cmdsize + (tmp___3 + 3UL));
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  cmdsize += 2;
  cscmd = xmalloc((size_t )(cmdsize + 1));
  strcpy((char * __restrict  )cscmd, (char const   * __restrict  )cs->command);
  cmdlen = n;
  tmp___4 = cmdlen;
  cmdlen ++;
  *(cscmd + tmp___4) = (char )' ';
  cl = cmdlist->next;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! cl) {
      goto while_break___0;
    }
    if ((cl->word)->word) {
      tmp___5 = (char const   *)(cl->word)->word;
    } else {
      tmp___5 = "";
    }
    {
    t = sh_single_quote((char *)tmp___5);
    tmp___6 = strlen((char const   *)t);
    n = (int )tmp___6;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (cmdlen + (n + 2) >= cmdsize) {
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (cmdlen + (n + 2) >= cmdsize)) {
            goto while_break___2;
          }
          cmdsize += 64;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        cscmd = xrealloc((void *)cscmd, (size_t )cmdsize);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    strcpy((char * __restrict  )(cscmd + cmdlen), (char const   * __restrict  )t);
    cmdlen += n;
    }
    if (cl->next) {
      tmp___7 = cmdlen;
      cmdlen ++;
      *(cscmd + tmp___7) = (char )' ';
    }
    {
    free((void *)t);
    cl = cl->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  *(cscmd + cmdlen) = (char )'\000';
  csbuf = command_substitute(cscmd, 0);
  dispose_words(cmdlist);
  free((void *)cscmd);
  unbind_compfunc_variables(1);
  }
  if ((unsigned long )csbuf == (unsigned long )((char *)0)) {
    goto _L;
  } else { //Added block
  if ((int )*csbuf == 0) {
    _L: 
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (csbuf) {
        {
        free((void *)csbuf);
        }
      }
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    return ((STRINGLIST *)((void *)0));
  }
  }
  {
  sl = alloc_stringlist(16);
  ws = 0;
  }
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    if (! *(csbuf + ws)) {
      goto while_break___4;
    }
    we = ws;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (*(csbuf + we)) {
        if (! ((int )*(csbuf + we) != 10)) {
          goto while_break___5;
        }
      } else {
        goto while_break___5;
      }
      if ((int )*(csbuf + we) == 92) {
        if ((int )*(csbuf + (we + 1)) == 10) {
          we ++;
        }
      }
      we ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
    t = substring(csbuf, ws, we);
    }
    if (sl->list_len >= sl->list_size - 1) {
      {
      realloc_stringlist(sl, sl->list_size + 16);
      }
    }
    tmp___8 = sl->list_len;
    (sl->list_len) ++;
    *(sl->list + tmp___8) = t;
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (! ((int )*(csbuf + we) == 10)) {
        goto while_break___6;
      }
      we ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    ws = we;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
  *(sl->list + sl->list_len) = (char *)((void *)0);
  free((void *)csbuf);
  }
  return (sl);
}
}
static WORD_LIST *command_line_to_word_list(char *line , int llen , int sentinel ,
                                            int *nwp , int *cwp ) 
{ 
  WORD_LIST *ret ;
  char *delims ;

  {
  {
  delims = (char *)"()<>;&| \t\n";
  ret = split_at_delims(line, llen, delims, sentinel, nwp, cwp);
  }
  return (ret);
}
}
STRINGLIST *gen_compspec_completions(COMPSPEC *cs , char const   *cmd , char const   *word ,
                                     int start , int end ) 
{ 
  STRINGLIST *ret ;
  STRINGLIST *tmatches ;
  char *line ;
  int llen ;
  int nw ;
  int cw ;
  WORD_LIST *lwords ;
  COMPSPEC *dummy ;

  {
  {
  debug_printf("programmable_completions (%s, %s, %d, %d)", cmd, word, start, end);
  debug_printf("programmable_completions: %s -> 0x%x", cmd, (int )cs);
  ret = gen_action_completions(cs, word);
  }
  if (ret) {
    if (progcomp_debug) {
      {
      debug_printf("gen_action_completions (0x%x, %s) -->", (int )cs, word);
      print_stringlist(ret, (char *)"\t");
      rl_on_new_line();
      }
    }
  }
  if (cs->globpat) {
    {
    tmatches = gen_globpat_matches(cs, word);
    }
    if (tmatches) {
      if (progcomp_debug) {
        {
        debug_printf("gen_globpat_matches (0x%x, %s) -->", (int )cs, word);
        print_stringlist(tmatches, (char *)"\t");
        rl_on_new_line();
        }
      }
      {
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      rl_filename_completion_desired = 1;
      }
    }
  }
  if (cs->words) {
    {
    tmatches = gen_wordlist_matches(cs, word);
    }
    if (tmatches) {
      if (progcomp_debug) {
        {
        debug_printf("gen_wordlist_matches (0x%x, %s) -->", (int )cs, word);
        print_stringlist(tmatches, (char *)"\t");
        rl_on_new_line();
        }
      }
      {
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
  }
  lwords = (WORD_LIST *)((void *)0);
  line = (char *)((void *)0);
  if (cs->command) {
    goto _L___0;
  } else { //Added block
  if (cs->funcname) {
    _L___0: 
    {
    line = substring(rl_line_buffer, start, end);
    llen = end - start;
    debug_printf("command_line_to_word_list (%s, %d, %d, 0x%x, 0x%x)", line, llen,
                 rl_point - start, & nw, & cw);
    lwords = command_line_to_word_list(line, llen, rl_point - start, & nw, & cw);
    }
    if ((unsigned long )lwords == (unsigned long )((WORD_LIST *)0)) {
      if (llen > 0) {
        {
        debug_printf("ERROR: command_line_to_word_list returns NULL");
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (progcomp_debug) {
      {
      debug_printf("command_line_to_word_list -->");
      printf((char const   * __restrict  )"\t");
      print_word_list(lwords, (char *)"!");
      printf((char const   * __restrict  )"\n");
      fflush(stdout);
      rl_on_new_line();
      }
    }
    }
  }
  }
  if (cs->funcname) {
    {
    tmatches = gen_shell_function_matches(cs, (char *)word, line, rl_point - start,
                                          lwords, nw, cw);
    }
    if (tmatches) {
      if (progcomp_debug) {
        {
        debug_printf("gen_shell_function_matches (0x%x, %s, 0x%x, %d, %d) -->", (int )cs,
                     word, lwords, nw, cw);
        print_stringlist(tmatches, (char *)"\t");
        rl_on_new_line();
        }
      }
      {
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
  }
  if (cs->command) {
    {
    tmatches = gen_command_matches(cs, (char *)word, line, rl_point - start, lwords,
                                   nw, cw);
    }
    if (tmatches) {
      if (progcomp_debug) {
        {
        debug_printf("gen_command_matches (0x%x, %s, 0x%x, %d, %d) -->", (int )cs,
                     word, lwords, nw, cw);
        print_stringlist(tmatches, (char *)"\t");
        rl_on_new_line();
        }
      }
      {
      ret = append_stringlist(ret, tmatches);
      free_stringlist(tmatches);
      }
    }
  }
  if (cs->command) {
    goto _L___1;
  } else { //Added block
  if (cs->funcname) {
    _L___1: 
    if (lwords) {
      {
      dispose_words(lwords);
      }
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (line) {
        {
        free((void *)line);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  }
  if (cs->filterpat) {
    {
    tmatches = filter_stringlist(ret, cs->filterpat, (char *)word);
    }
    if (progcomp_debug) {
      {
      debug_printf("filter_stringlist (0x%x, %s, %s) -->", ret, cs->filterpat, word);
      print_stringlist(tmatches, (char *)"\t");
      rl_on_new_line();
      }
    }
    if (ret) {
      if ((unsigned long )ret != (unsigned long )tmatches) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (ret->list) {
            {
            free((void *)ret->list);
            }
          }
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        free((void *)ret);
        }
      }
    }
    ret = tmatches;
  }
  if (cs->prefix) {
    {
    ret = prefix_suffix_stringlist(ret, cs->prefix, cs->suffix);
    }
  } else { //Added block
  if (cs->suffix) {
    {
    ret = prefix_suffix_stringlist(ret, cs->prefix, cs->suffix);
    }
  }
  }
  if ((unsigned long )ret == (unsigned long )((STRINGLIST *)0)) {
    goto _L___2;
  } else { //Added block
  if (ret->list_len == 0) {
    _L___2: 
    if (cs->options & (unsigned long )(1 << 3)) {
      {
      dummy = alloc_compspec();
      dummy->actions = (unsigned long )(1 << 5);
      ret = gen_action_completions(dummy, word);
      free_compspec(dummy);
      }
    }
  }
  }
  return (ret);
}
}
char **programmable_completions(char const   *cmd , char const   *word , int start ,
                                int end , int *foundp ) 
{ 
  COMPSPEC *cs ;
  STRINGLIST *ret ;
  char **rmatches ;
  char *t ;

  {
  {
  cs = find_compspec(cmd);
  }
  if ((unsigned long )cs == (unsigned long )((COMPSPEC *)0)) {
    {
    t = strrchr(cmd, '/');
    }
    if (t) {
      {
      t ++;
      cs = find_compspec((char const   *)t);
      }
    }
  }
  if ((unsigned long )cs == (unsigned long )((COMPSPEC *)0)) {
    if (foundp) {
      *foundp = 0;
    }
    return ((char **)((void *)0));
  }
  if (foundp) {
    *foundp = (int )(1UL | cs->options);
  }
  {
  ret = gen_compspec_completions(cs, cmd, word, start, end);
  }
  if (ret) {
    {
    rmatches = ret->list;
    free((void *)ret);
    }
  } else {
    rmatches = (char **)((void *)0);
  }
  return (rmatches);
}
}
#pragma merger("0","/tmp/cil-mxaIGlA8.i","-g")
HASH_TABLE *prog_completes ;
COMPSPEC *copy_compspec(COMPSPEC *cs ) ;
void initialize_progcomp(void) ;
void clear_progcomps(void) ;
int remove_progcomp(char *cmd ) ;
int add_progcomp(char *cmd , COMPSPEC *cs ) ;
void print_all_compspecs(VFunction *pfunc ) ;
HASH_TABLE *prog_completes  =    (HASH_TABLE *)((void *)0);
static int progcomp_initialized  =    0;
COMPSPEC *alloc_compspec(void) 
{ 
  COMPSPEC *ret ;
  char *tmp ;

  {
  {
  tmp = xmalloc(sizeof(COMPSPEC ));
  ret = (COMPSPEC *)tmp;
  ret->refcount = 0;
  ret->actions = 0UL;
  ret->options = 0UL;
  ret->globpat = (char *)((void *)0);
  ret->words = (char *)((void *)0);
  ret->prefix = (char *)((void *)0);
  ret->suffix = (char *)((void *)0);
  ret->funcname = (char *)((void *)0);
  ret->command = (char *)((void *)0);
  ret->filterpat = (char *)((void *)0);
  }
  return (ret);
}
}
void free_compspec(COMPSPEC *cs ) 
{ 


  {
  (cs->refcount) --;
  if (cs->refcount == 0) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (cs->globpat) {
        {
        free((void *)cs->globpat);
        }
      }
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (cs->words) {
        {
        free((void *)cs->words);
        }
      }
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (cs->prefix) {
        {
        free((void *)cs->prefix);
        }
      }
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (cs->suffix) {
        {
        free((void *)cs->suffix);
        }
      }
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (cs->funcname) {
        {
        free((void *)cs->funcname);
        }
      }
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (cs->command) {
        {
        free((void *)cs->command);
        }
      }
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (cs->filterpat) {
        {
        free((void *)cs->filterpat);
        }
      }
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
    free((void *)cs);
    }
  }
  return;
}
}
COMPSPEC *copy_compspec(COMPSPEC *cs ) 
{ 
  COMPSPEC *new ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  {
  tmp = xmalloc(sizeof(COMPSPEC ));
  new = (COMPSPEC *)tmp;
  new->refcount = cs->refcount;
  new->actions = cs->actions;
  new->options = cs->options;
  }
  if (cs->globpat) {
    {
    tmp___0 = strlen((char const   *)cs->globpat);
    tmp___1 = xmalloc(1UL + tmp___0);
    tmp___2 = strcpy((char * __restrict  )tmp___1, (char const   * __restrict  )cs->globpat);
    new->globpat = tmp___2;
    }
  } else {
    new->globpat = (char *)((void *)0);
  }
  if (cs->words) {
    {
    tmp___3 = strlen((char const   *)cs->words);
    tmp___4 = xmalloc(1UL + tmp___3);
    tmp___5 = strcpy((char * __restrict  )tmp___4, (char const   * __restrict  )cs->words);
    new->words = tmp___5;
    }
  } else {
    new->words = (char *)((void *)0);
  }
  if (cs->prefix) {
    {
    tmp___6 = strlen((char const   *)cs->prefix);
    tmp___7 = xmalloc(1UL + tmp___6);
    tmp___8 = strcpy((char * __restrict  )tmp___7, (char const   * __restrict  )cs->prefix);
    new->prefix = tmp___8;
    }
  } else {
    new->prefix = (char *)((void *)0);
  }
  if (cs->suffix) {
    {
    tmp___9 = strlen((char const   *)cs->suffix);
    tmp___10 = xmalloc(1UL + tmp___9);
    tmp___11 = strcpy((char * __restrict  )tmp___10, (char const   * __restrict  )cs->suffix);
    new->suffix = tmp___11;
    }
  } else {
    new->suffix = (char *)((void *)0);
  }
  if (cs->funcname) {
    {
    tmp___12 = strlen((char const   *)cs->funcname);
    tmp___13 = xmalloc(1UL + tmp___12);
    tmp___14 = strcpy((char * __restrict  )tmp___13, (char const   * __restrict  )cs->funcname);
    new->funcname = tmp___14;
    }
  } else {
    new->funcname = (char *)((void *)0);
  }
  if (cs->command) {
    {
    tmp___15 = strlen((char const   *)cs->command);
    tmp___16 = xmalloc(1UL + tmp___15);
    tmp___17 = strcpy((char * __restrict  )tmp___16, (char const   * __restrict  )cs->command);
    new->command = tmp___17;
    }
  } else {
    new->command = (char *)((void *)0);
  }
  if (cs->filterpat) {
    {
    tmp___18 = strlen((char const   *)cs->filterpat);
    tmp___19 = xmalloc(1UL + tmp___18);
    tmp___20 = strcpy((char * __restrict  )tmp___19, (char const   * __restrict  )cs->filterpat);
    new->filterpat = tmp___20;
    }
  } else {
    new->filterpat = (char *)((void *)0);
  }
  return (new);
}
}
void initialize_progcomp(void) 
{ 


  {
  if (progcomp_initialized == 0) {
    {
    prog_completes = make_hash_table(29);
    progcomp_initialized = 1;
    }
  }
  return;
}
}
int num_progcomps(void) 
{ 


  {
  if (progcomp_initialized == 0) {
    return (0);
  } else { //Added block
  if ((unsigned long )prog_completes == (unsigned long )((HASH_TABLE *)0)) {
    return (0);
  }
  }
  return (prog_completes->nentries);
}
}
static void free_progcomp(char *data ) 
{ 
  COMPSPEC *cs ;

  {
  {
  cs = (COMPSPEC *)data;
  free_compspec(cs);
  }
  return;
}
}
void clear_progcomps(void) 
{ 


  {
  if (prog_completes) {
    {
    flush_hash_table(prog_completes, (VFunction *)(& free_progcomp));
    }
  }
  return;
}
}
int remove_progcomp(char *cmd ) 
{ 
  register BUCKET_CONTENTS *item ;

  {
  if ((unsigned long )prog_completes == (unsigned long )((HASH_TABLE *)0)) {
    return (1);
  }
  {
  item = remove_hash_item(cmd, prog_completes);
  }
  if (item) {
    {
    free_progcomp(item->data);
    free((void *)item->key);
    free((void *)item);
    }
    return (1);
  }
  return (0);
}
}
int add_progcomp(char *cmd , COMPSPEC *cs ) 
{ 
  register BUCKET_CONTENTS *item ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (progcomp_initialized == 0) {
    {
    initialize_progcomp();
    }
  } else { //Added block
  if ((unsigned long )prog_completes == (unsigned long )((HASH_TABLE *)0)) {
    {
    initialize_progcomp();
    }
  }
  }
  if ((unsigned long )cs == (unsigned long )((void *)0)) {
    {
    programming_error("add_progcomp: %s: NULL COMPSPEC", cmd);
    }
  }
  {
  item = add_hash_item(cmd, prog_completes);
  }
  if (item->data) {
    {
    free_progcomp(item->data);
    }
  } else {
    {
    tmp = strlen((char const   *)cmd);
    tmp___0 = xmalloc(1UL + tmp);
    tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )cmd);
    item->key = tmp___1;
    }
  }
  item->data = (char *)cs;
  (cs->refcount) ++;
  return (1);
}
}
COMPSPEC *find_compspec(char const   *cmd ) 
{ 
  register BUCKET_CONTENTS *item ;
  COMPSPEC *cs ;

  {
  if ((unsigned long )prog_completes == (unsigned long )((HASH_TABLE *)0)) {
    return ((COMPSPEC *)((void *)0));
  }
  {
  item = find_hash_item((char *)cmd, prog_completes);
  }
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    return ((COMPSPEC *)((void *)0));
  }
  cs = (COMPSPEC *)item->data;
  return (cs);
}
}
void print_all_compspecs(VFunction *pfunc ) 
{ 
  BUCKET_CONTENTS *item_list ;
  int bucket ;
  COMPSPEC *cs ;

  {
  if ((unsigned long )prog_completes == (unsigned long )((HASH_TABLE *)0)) {
    return;
  } else { //Added block
  if ((unsigned long )pfunc == (unsigned long )((VFunction *)0)) {
    return;
  }
  }
  bucket = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (bucket < prog_completes->nbuckets)) {
      goto while_break;
    }
    if (prog_completes) {
      if (bucket < prog_completes->nbuckets) {
        item_list = *(prog_completes->bucket_array + bucket);
      } else {
        item_list = (BUCKET_CONTENTS *)((void *)0);
      }
    } else {
      item_list = (BUCKET_CONTENTS *)((void *)0);
    }
    if ((unsigned long )item_list == (unsigned long )((BUCKET_CONTENTS *)0)) {
      goto __Cont;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! item_list) {
        goto while_break___0;
      }
      {
      cs = (COMPSPEC *)item_list->data;
      (*pfunc)(item_list->key, cs);
      item_list = item_list->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: 
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-tzrrFomP.i","-g")
int const   sh_syntaxtab[256]  = 
  {      (int const   )0,      (int const   )16,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )2,      (int const   )66,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )2,      (int const   )2560,      (int const   )1096,      (int const   )2048, 
        (int const   )2272,      (int const   )0,      (int const   )3,      (int const   )1032, 
        (int const   )3,      (int const   )3,      (int const   )2816,      (int const   )512, 
        (int const   )0,      (int const   )2048,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )3, 
        (int const   )35,      (int const   )0,      (int const   )35,      (int const   )2816, 
        (int const   )2560,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )256, 
        (int const   )1216,      (int const   )256,      (int const   )256,      (int const   )0, 
        (int const   )1228,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )3,      (int const   )0,      (int const   )0,      (int const   )16, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#pragma merger("0","/tmp/cil-kswh11rO.i","-g")
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) sbrk)(intptr_t __delta ) ;
static void *lbreak  ;
static int brkfound  ;
static size_t allocated  ;
static size_t findbrk(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  if (brkfound == 0) {
    {
    tmp = sbrk((intptr_t )0);
    lbreak = tmp;
    brkfound ++;
    }
  }
  {
  tmp___0 = sbrk((intptr_t )0);
  }
  return ((size_t )((char *)tmp___0 - (char *)lbreak));
}
}
char *xmalloc(size_t bytes ) 
{ 
  char *temp___0 ;
  void *tmp ;

  {
  {
  tmp = malloc(bytes);
  temp___0 = (char *)tmp;
  }
  if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
    {
    allocated = findbrk();
    fatal_error("xmalloc: cannot allocate %lu bytes (%lu bytes allocated)", bytes,
                allocated);
    }
  }
  return (temp___0);
}
}
char *xrealloc(void *pointer , size_t bytes ) 
{ 
  char *temp___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (pointer) {
    {
    tmp = realloc(pointer, bytes);
    temp___0 = (char *)tmp;
    }
  } else {
    {
    tmp___0 = malloc(bytes);
    temp___0 = (char *)tmp___0;
    }
  }
  if ((unsigned long )temp___0 == (unsigned long )((char *)0)) {
    {
    allocated = findbrk();
    fatal_error("xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)", bytes,
                allocated);
    }
  }
  return (temp___0);
}
}
void xfree(void *string ) 
{ 


  {
  if (string) {
    {
    free(string);
    }
  }
  return;
}
}
