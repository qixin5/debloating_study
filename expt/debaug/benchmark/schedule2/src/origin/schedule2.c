/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct process;
struct process;
struct process {
   unsigned int pid ;
   int priority ;
   struct process *next ;
};
struct queue {
   int length ;
   struct process *head ;
};
#pragma merger("0","/tmp/cil-FHBQY5Ym.i","")
#pragma merger("0","/tmp/cil-7pjGEbiZ.i","")
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
int get_command(int *command , int *prio , float *ratio ) ;
int exit_here(int status ) ;
int enqueue(int prio , struct process *new_process ) ;
int new_job(int prio ) ;
int schedule(int command , int prio , float ratio ) ;
struct process *get_current(void) ;
int reschedule(int prio ) ;
int put_end(int prio , struct process *process ) ;
int get_process(int prio , float ratio , struct process **job ) ;
static struct process *current_job  ;
static int next_pid  =    0;
int enqueue(int prio , struct process *new_process ) 
{ 
  int status ;
  int tmp ;

  {
  {
  status = put_end(prio, new_process);
  }
  if (status) {
    return (status);
  }
  {
  tmp = reschedule(prio);
  }
  return (tmp);
}
}
static struct queue prio_queue[4]  ;
extern int atoi() ;
int main(int argc , char **argv ) 
{ 
  int command ;
  int prio ;
  float ratio ;
  int nprocs ;
  int status ;

  {
  if (argc != 4) {
    {
    exit_here(-1);
    }
  }
  prio = 3;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (prio > 0)) {
      goto while_break;
    }
    {
    nprocs = atoi(*(argv + (4 - prio)));
    }
    if (nprocs < 0) {
      {
      exit_here(-2);
      }
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (nprocs > 0)) {
        goto while_break___0;
      }
      {
      status = new_job(prio);
      }
      if (status) {
        {
        exit_here(status);
        }
      }
      nprocs --;
    }
    while_break___0: /* CIL Label */ ;
    }
    prio --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    status = get_command(& command, & prio, & ratio);
    }
    if (! (status > 0)) {
      goto while_break___1;
    }
    {
    schedule(command, prio, (float )((double )ratio));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  if (status < 0) {
    {
    exit_here(status);
    }
  }
  {
  exit_here(0);
  }
  return (0);
}
}
extern int strlen() ;
int get_command(int *command , int *prio , float *ratio ) 
{ 
  int status ;
  char buf[20] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
  status = 0;
  tmp___2 = fgets((char * __restrict  )(buf), 20, (FILE * __restrict  )stdin);
  }
  if (tmp___2) {
    {
    tmp = -1;
    *command = tmp;
    *prio = tmp;
    *ratio = (float )(- 1.0);
    sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%d",
           command);
    }
    {
    if (*command == 1) {
      goto case_1;
    }
    if (*command == 4) {
      goto case_4;
    }
    if (*command == 2) {
      goto case_2;
    }
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%*s%d",
           prio);
    }
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%*s%f",
           ratio);
    }
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%*s%d%f",
           prio, ratio);
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp___0 = strlen(buf);
      }
      if ((int )buf[tmp___0 - 1] != 10) {
        {
        tmp___1 = fgets((char * __restrict  )(buf), 20, (FILE * __restrict  )stdin);
        }
        if (! tmp___1) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    return (1);
  } else {
    return (0);
  }
}
}
extern int exit() ;
extern int abs() ;
int exit_here(int status ) 
{ 
  int tmp ;

  {
  {
  tmp = abs(status);
  exit(tmp);
  }
}
}
extern int malloc() ;
extern int free() ;
int new_job(int prio ) 
{ 
  int pid ;
  int status ;
  struct process *new_process ;
  int tmp ;
  int tmp___0 ;

  {
  {
  status = 0;
  tmp = next_pid;
  next_pid ++;
  pid = tmp;
  tmp___0 = malloc(sizeof(struct process ));
  new_process = (struct process *)tmp___0;
  }
  if (! new_process) {
    status = -3;
  } else {
    {
    new_process->pid = (unsigned int )pid;
    new_process->priority = prio;
    new_process->next = (struct process *)0;
    status = enqueue(prio, new_process);
    }
    if (status) {
      {
      free(new_process);
      }
    }
  }
  if (status) {
    next_pid --;
  }
  return (status);
}
}
int upgrade_prio(int prio , float ratio ) 
{ 
  int status ;
  struct process *job ;
  int tmp ;

  {
  if (prio < 1) {
    return (-4);
  } else { //Added block
  if (prio > 2) {
    return (-4);
  }
  }
  {
  status = get_process(prio, (float )((double )ratio), & job);
  }
  if (status <= 0) {
    return (status);
  }
  {
  job->priority = prio + 1;
  tmp = enqueue(prio + 1, job);
  }
  return (tmp);
}
}
int block(void) 
{ 
  struct process *job ;
  int tmp ;

  {
  {
  job = get_current();
  }
  if (job) {
    {
    current_job = (struct process *)0;
    tmp = enqueue(0, job);
    }
    return (tmp);
  }
  return (0);
}
}
int unblock(float ratio ) 
{ 
  int status ;
  struct process *job ;
  int tmp ;

  {
  {
  status = get_process(0, (float )((double )ratio), & job);
  }
  if (status <= 0) {
    return (status);
  }
  {
  tmp = enqueue(job->priority, job);
  }
  return (tmp);
}
}
int quantum_expire(void) 
{ 
  struct process *job ;
  int tmp ;

  {
  {
  job = get_current();
  }
  if (job) {
    {
    current_job = (struct process *)0;
    tmp = enqueue(job->priority, job);
    }
    return (tmp);
  }
  return (0);
}
}
int finish(void) 
{ 
  struct process *job ;

  {
  {
  job = get_current();
  }
  if (job) {
    {
    current_job = (struct process *)0;
    reschedule(0);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" %d", job->pid);
    free(job);
    }
    return (0);
  } else {
    return (1);
  }
}
}
int flush(void) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = finish();
    }
    if (tmp) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  return (0);
}
}
struct process *get_current(void) 
{ 
  int prio ;
  int tmp ;

  {
  if (! current_job) {
    prio = 3;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (prio > 0)) {
        goto while_break;
      }
      {
      tmp = get_process(prio, (float )0.0, & current_job);
      }
      if (tmp > 0) {
        goto while_break;
      }
      prio --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (current_job);
}
}
int reschedule(int prio ) 
{ 


  {
  if (current_job) {
    if (prio > current_job->priority) {
      {
      put_end(current_job->priority, current_job);
      current_job = (struct process *)0;
      }
    }
  }
  {
  get_current();
  }
  return (0);
}
}
int schedule(int command , int prio , float ratio ) 
{ 
  int status ;

  {
  status = 0;
  {
  if (command == 1) {
    goto case_1;
  }
  if (command == 5) {
    goto case_5;
  }
  if (command == 2) {
    goto case_2;
  }
  if (command == 3) {
    goto case_3;
  }
  if (command == 4) {
    goto case_4;
  }
  if (command == 6) {
    goto case_6;
  }
  if (command == 7) {
    goto case_7;
  }
  goto switch_default;
  case_1: /* CIL Label */ 
  {
  status = new_job(prio);
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  status = quantum_expire();
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  status = upgrade_prio(prio, ratio);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  status = block();
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  status = unblock(ratio);
  }
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  finish();
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  goto switch_break;
  case_7: /* CIL Label */ 
  {
  status = flush();
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  status = -6;
  switch_break: /* CIL Label */ ;
  }
  return (status);
}
}
int put_end(int prio , struct process *process ) 
{ 
  struct process **next ;

  {
  if (prio > 3) {
    return (-4);
  } else { //Added block
  if (prio < 0) {
    return (-4);
  }
  }
  next = & prio_queue[prio].head;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *next) {
      goto while_break;
    }
    next = & (*next)->next;
  }
  while_break: /* CIL Label */ ;
  }
  *next = process;
  (prio_queue[prio].length) ++;
  return (0);
}
}
int get_process(int prio , float ratio , struct process **job ) 
{ 
  int length ;
  int index ;
  struct process **next ;

  {
  if (prio > 3) {
    return (-4);
  } else { //Added block
  if (prio < 0) {
    return (-4);
  }
  }
  if ((double )ratio < 0.0) {
    return (-5);
  } else { //Added block
  if ((double )ratio > 1.0) {
    return (-5);
  }
  }
  length = prio_queue[prio].length;
  index = (int )(ratio * (float )length);
  if (index >= length) {
    index = length - 1;
  } else {
    index = index;
  }
  next = & prio_queue[prio].head;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (index) {
      if (! *next) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    next = & (*next)->next;
    index --;
  }
  while_break: /* CIL Label */ ;
  }
  *job = *next;
  if (*job) {
    *next = (*next)->next;
    (*job)->next = (struct process *)0;
    (prio_queue[prio].length) --;
    return (1);
  } else {
    return (0);
  }
}
}
