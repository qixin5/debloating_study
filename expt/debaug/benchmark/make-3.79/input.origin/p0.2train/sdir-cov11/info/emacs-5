This is ../info/emacs, produced by makeinfo version 4.0 from emacs.texi.

   This is the thirteenth edition of the `GNU Emacs Manual', updated
for Emacs version 20.7.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999    Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: emacs,  Node: Yanking,  Next: Accumulating Text,  Prev: Killing,  Up: Top

Yanking
=======

   "Yanking" means reinserting text previously killed.  This is what
some systems call "pasting."  The usual way to move or copy text is to
kill it and then yank it elsewhere one or more times.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace text just yanked with an earlier batch of killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`kill-ring-save').

`C-M-w'
     Append next kill to last batch of killed text (`append-next-kill').

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.


File: emacs,  Node: Kill Ring,  Next: Appending Kills,  Up: Yanking

The Kill Ring
-------------

   All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, shared by all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

   The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text.  It sets the mark at
the beginning of the text.  *Note Mark::.

   `C-u C-y' leaves the cursor in front of the text, and sets the mark
after it.  This happens only if the argument is specified with just a
`C-u', precisely.  Any other sort of argument, including `C-u' and
digits, specifies an earlier kill to yank (*note Earlier Kills::).

   To copy a block of text, you can use `M-w' (`kill-ring-save'), which
copies the region into the kill ring without removing it from the
buffer.  This is approximately equivalent to `C-w' followed by `C-x u',
except that `M-w' does not alter the undo history and does not
temporarily change the screen.


File: emacs,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

Appending Kills
---------------

   Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' yanks all the text as a unit, just
as it was before it was killed.

   Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add text
onto the beginning.  This way, any sequence of mixed forward and
backward kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains this text:

     This is a line -!-of sample text.

with point shown by -!-.  If you type `M-d M-<DEL> M-d M-<DEL>',
killing alternately forward and backward, you end up with `a line of
sample' as one entry in the kill ring, and `This is  text.' in the
buffer.  (Note the double space, which you can clean up with `M-<SPC>'
or `M-q'.)

   Another way to kill the same text is to move back two words with
`M-b M-b', then kill all four words forward with `C-u M-d'.  This
produces exactly the same results in the buffer and in the kill ring.
`M-f M-f C-u M-<DEL>' kills the same text, all going backward; once
again, the result is the same.  The text in the kill ring entry always
has the same order that it had in the buffer before you killed it.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to append by first typing the command
`C-M-w' (`append-next-kill') right before it.  The `C-M-w' tells the
following command, if it is a kill command, to append the text it kills
to the last killed text, instead of starting a new entry.  With
`C-M-w', you can kill several separated pieces of text and accumulate
them to be yanked back in one place.

   A kill command following `M-w' does not append to the text that
`M-w' copied into the kill ring.


File: emacs,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

Yanking Earlier Kills
---------------------

   To recover killed text that is no longer the most recent kill, use
the `M-y' command (`yank-pop').  It takes the text previously yanked
and replaces it with the text from an earlier kill.  So, to recover the
text of the next-to-the-last kill, first use `C-y' to yank the last
kill, and then use `M-y' to replace it with the previous kill.  `M-y'
is allowed only after a `C-y' or another `M-y'.

   You can understand `M-y' in terms of a "last yank" pointer which
points at an entry in the kill ring.  Each time you kill, the "last
yank" pointer moves to the newly made entry at the front of the ring.
`C-y' yanks the entry which the "last yank" pointer points to.  `M-y'
moves the "last yank" pointer to a different entry, and the text in the
buffer changes to match.  Enough `M-y' commands can move the pointer to
any entry in the ring, so you can get any entry into the buffer.
Eventually the pointer reaches the end of the ring; the next `M-y'
moves it to the first entry again.

   `M-y' moves the "last yank" pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   `M-y' can take a numeric argument, which tells it how many entries
to advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves "around" to the last entry and continues forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and it will stay there.  It's just a copy of
the kill ring entry, so editing it in the buffer does not change what's
in the ring.  As long as no new killing is done, the "last yank"
pointer remains at the same place in the kill ring, so repeating `C-y'
will yank another copy of the same previous kill.

   If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a numeric
argument.  `C-y' with an argument restores the text the specified
number of entries back in the kill ring.  Thus, `C-u 2 C-y' gets the
next-to-the-last block of killed text.  It is equivalent to `C-y M-y'.
`C-y' with a numeric argument starts counting from the "last yank"
pointer, and sets the "last yank" pointer to the entry that it yanks.

   The length of the kill ring is controlled by the variable
`kill-ring-max'; no more than that many blocks of killed text are saved.

   The actual contents of the kill ring are stored in a variable named
`kill-ring'; you can view the entire contents of the kill ring with the
command `C-h v kill-ring'.


File: emacs,  Node: Accumulating Text,  Next: Rectangles,  Prev: Yanking,  Up: Top

Accumulating Text
=================

   Usually we copy or move text by killing it and yanking it, but there
are other methods convenient for copying one block of text in many
places, or for copying many scattered blocks of text into one place.  To
copy one block to many places, store it in a register (*note
Registers::).  Here we describe the commands to accumulate scattered
pieces of text into a buffer or into a file.

`M-x append-to-buffer'
     Append region to contents of specified buffer.

`M-x prepend-to-buffer'
     Prepend region to contents of specified buffer.

`M-x copy-to-buffer'
     Copy region into specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert contents of specified buffer into current buffer at point.

`M-x append-to-file'
     Append region to contents of specified file, at the end.

   To accumulate text into a buffer, use `M-x append-to-buffer'.  This
reads a buffer name, then inserts a copy of the region into the buffer
specified.  If you specify a nonexistent buffer, `append-to-buffer'
creates the buffer.  The text is inserted wherever point is in that
buffer.  If you have been using the buffer for editing, the copied text
goes into the middle of the text of the buffer, wherever point happens
to be in it.

   Point in that buffer is left at the end of the copied text, so
successive uses of `append-to-buffer' accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, `append-to-buffer' does not always append to the text already
in the buffer--it appends only if point in that buffer is at the end.
However, if `append-to-buffer' is the only command you use to alter a
buffer, then point is always at the end.

   `M-x prepend-to-buffer' is just like `append-to-buffer' except that
point in the other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is similar
except that any existing text in the other buffer is deleted, so the
buffer is left containing just the text newly copied into it.

   To retrieve the accumulated text from another buffer, use the command
`M-x insert-buffer'; this too takes BUFFERNAME as an argument.  It
inserts a copy of the text in buffer BUFFERNAME into the selected
buffer.  You can alternatively select the other buffer for editing,
then optionally move text from it by killing.  *Note Buffers::, for
background information on buffers.

   Instead of accumulating text within Emacs, in a buffer, you can
append text directly into a file with `M-x append-to-file', which takes
FILENAME as an argument.  It adds the text of the region to the end of
the specified file.  The file is changed immediately on disk.

   You should use `append-to-file' only with files that are _not_ being
visited in Emacs.  Using it on a file that you are editing in Emacs
would change the file behind Emacs's back, which can lead to losing
some of your editing.


File: emacs,  Node: Rectangles,  Next: Registers,  Prev: Accumulating Text,  Up: Top

Rectangles
==========

   The rectangle commands operate on rectangular areas of the text: all
the characters between a certain pair of columns, in a certain range of
lines.  Commands are provided to kill rectangles, yank killed
rectangles, clear them out, fill them with blanks or text, or delete
them.  Rectangle commands are useful with text in multicolumn formats,
and for changing text into or out of such formats.

   When you must specify a rectangle for a command to work on, you do it
by putting the mark at one corner and point at the opposite corner.  The
rectangle thus specified is called the "region-rectangle" because you
control it in about the same way the region is controlled.  But
remember that a given combination of point and mark values can be
interpreted either as a region or as a rectangle, depending on the
command that uses them.

   If point and the mark are in the same column, the rectangle they
delimit is empty.  If they are in the same line, the rectangle is one
line high.  This asymmetry between lines and columns comes about
because point (and likewise the mark) is between two columns, but within
a line.

`C-x r k'
     Kill the text of the region-rectangle, saving its contents as the
     "last killed rectangle" (`kill-rectangle').

`C-x r d'
     Delete the text of the region-rectangle (`delete-rectangle').

`C-x r y'
     Yank the last killed rectangle with its upper left corner at point
     (`yank-rectangle').

`C-x r o'
     Insert blank space to fill the space of the region-rectangle
     (`open-rectangle').  This pushes the previous contents of the
     region-rectangle rightward.

`M-x clear-rectangle'
     Clear the region-rectangle by replacing its contents with spaces.

`M-x delete-whitespace-rectangle'
     Delete whitespace in each of the lines on the specified rectangle,
     starting from the left edge column of the rectangle.

`C-x r t STRING <RET>'
     Insert STRING on each line of the region-rectangle
     (`string-rectangle').

   The rectangle operations fall into two classes: commands deleting and
inserting rectangles, and commands for blank rectangles.

   There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed" rectangle.
The commands for these two ways are `C-x r d' (`delete-rectangle') and
`C-x r k' (`kill-rectangle').  In either case, the portion of each line
that falls inside the rectangle's boundaries is deleted, causing
following text (if any) on the line to move left into the gap.

   Note that "killing" a rectangle is not killing in the usual sense;
the rectangle is not stored in the kill ring, but in a special place
that can only record the most recent rectangle killed.  This is because
yanking a rectangle is so different from yanking linear text that
different yank commands have to be used and yank-popping is hard to
make sense of.

   To yank the last killed rectangle, type `C-x r y'
(`yank-rectangle').  Yanking a rectangle is the opposite of killing
one.  Point specifies where to put the rectangle's upper left corner.
The rectangle's first line is inserted there, the rectangle's second
line is inserted at a position one line vertically down, and so on.  The
number of lines affected is determined by the height of the saved
rectangle.

   You can convert single-column lists into double-column lists using
rectangle killing and yanking; kill the second half of the list as a
rectangle and then yank it beside the first line of the list.  *Note
Two-Column::, for another way to edit multi-column text.

   You can also copy rectangles into and out of registers with `C-x r r
R' and `C-x r i R'.  *Note Rectangle Registers: RegRect.

   There are two commands you can use for making blank rectangles: `M-x
clear-rectangle' which blanks out existing text, and `C-x r o'
(`open-rectangle') which inserts a blank rectangle.  Clearing a
rectangle is equivalent to deleting it and then inserting a blank
rectangle of the same size.

   The command `M-x delete-whitespace-rectangle' deletes horizontal
whitespace starting from a particular column.  This applies to each of
the lines in the rectangle, and the column is specified by the left
edge of the rectangle.  The right edge of the rectangle does not make
any difference to this command.

   The command `C-x r t' (`M-x string-rectangle') replaces the
rectangle with a specified string (inserted once on each line).  The
string's width need not be the same as the width of the rectangle.  If
the string's width is less, the text after the rectangle shifts left; if
the string is wider than the rectangle, the text after the rectangle
shifts right.


File: emacs,  Node: Registers,  Next: Display,  Prev: Rectangles,  Up: Top

Registers
*********

   Emacs "registers" are places you can save text or positions for
later use.  Once you save text or a rectangle in a register, you can
copy it into the buffer once or many times; you can move point to a
position saved in a register once or many times.

   Each register has a name which is a single character.  A register can
store a piece of text, a rectangle, a position, a window configuration,
or a file name, but only one thing at any given time.  Whatever you
store in a register remains there until you store something else in that
register.  To see what a register R contains, use `M-x view-register'.

`M-x view-register <RET> R'
     Display a description of what register R contains.

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.


File: emacs,  Node: RegPos,  Next: RegText,  Up: Registers

Saving Positions in Registers
=============================

   Saving a position records a place in a buffer so that you can move
back there later.  Moving to a saved position switches to that buffer
and moves point to that place in it.

`C-x r <SPC> R'
     Save position of point in register R (`point-to-register').

`C-x r j R'
     Jump to the position saved in register R (`jump-to-register').

   To save the current position of point in a register, choose a name R
and type `C-x r <SPC> R'.  The register R retains the position thus
saved until you store something else in that register.

   The command `C-x r j R' moves point to the position recorded in
register R.  The register is not affected; it continues to record the
same position.  You can jump to the saved position any number of times.

   If you use `C-x r j' to go to a saved position, but the buffer it
was saved from has been killed, `C-x r j' tries to create the buffer
again by visiting the same file.  Of course, this works only for buffers
that were visiting files.


File: emacs,  Node: RegText,  Next: RegRect,  Prev: RegPos,  Up: Registers

Saving Text in Registers
========================

   When you want to insert a copy of the same piece of text several
times, it may be inconvenient to yank it from the kill ring, since each
subsequent kill moves that entry further down the ring.  An alternative
is to store the text in a register and later retrieve it.

`C-x r s R'
     Copy region into register R (`copy-to-register').

`C-x r i R'
     Insert text from register R (`insert-register').

   `C-x r s R' stores a copy of the text of the region into the
register named R.  Given a numeric argument, `C-x r s R' deletes the
text from the buffer as well.

   `C-x r i R' inserts in the buffer the text from register R.
Normally it leaves point before the text and places the mark after, but
with a numeric argument (`C-u') it puts point after the text and the
mark before.


File: emacs,  Node: RegRect,  Next: RegConfig,  Prev: RegText,  Up: Registers

Saving Rectangles in Registers
==============================

   A register can contain a rectangle instead of linear text.  The
rectangle is represented as a list of strings.  *Note Rectangles::, for
basic information on how to specify a rectangle in the buffer.

`C-x r r R'
     Copy the region-rectangle into register R
     (`copy-rectangle-to-register').  With numeric argument, delete it
     as well.

`C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

   The `C-x r i R' command inserts a text string if the register
contains one, and inserts a rectangle if the register contains one.

   See also the command `sort-columns', which you can think of as
sorting a rectangle.  *Note Sorting::.


File: emacs,  Node: RegConfig,  Next: RegFiles,  Prev: RegRect,  Up: Registers

Saving Window Configurations in Registers
=========================================

   You can save the window configuration of the selected frame in a
register, or even the configuration of all windows in all frames, and
restore the configuration later.

`C-x r w R'
     Save the state of the selected frame's windows in register R
     (`window-configuration-to-register').

`C-x r f R'
     Save the state of all frames, including all their windows, in
     register R (`frame-configuration-to-register').

   Use `C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use `C-u C-x r j R'.


File: emacs,  Node: RegNumbers,  Next: Bookmarks,  Prev: RegFiles,  Up: Registers

Keeping Numbers in Registers
============================

   There are commands to store a number in a register, to insert the
number in the buffer in decimal, and to increment it.  These commands
can be useful in keyboard macros (*note Keyboard Macros::).

`C-u NUMBER C-x r n REG'
     Store NUMBER into register REG (`number-to-register').

`C-u NUMBER C-x r + REG'
     Increment the number in register REG by NUMBER
     (`increment-register').

`C-x r g REG'
     Insert the number from register REG into the buffer.

   `C-x r g' is the same command used to insert any other sort of
register contents into the buffer.


File: emacs,  Node: RegFiles,  Next: RegNumbers,  Prev: RegConfig,  Up: Registers

Keeping File Names in Registers
===============================

   If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file name in a register:

     (set-register ?R '(file . NAME))

For example,

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

puts the file name shown in register `z'.

   To visit the file whose name is in register R, type `C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)


File: emacs,  Node: Bookmarks,  Prev: RegNumbers,  Up: Registers

Bookmarks
=========

   "Bookmarks" are somewhat like registers in that they record
positions you can jump to.  Unlike registers, they have long names, and
they persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record "where you were reading" in
various files.

`C-x r m <RET>'
     Set the bookmark for the visited file, at point.

`C-x r m BOOKMARK <RET>'
     Set the bookmark named BOOKMARK at point (`bookmark-set').

`C-x r b BOOKMARK <RET>'
     Jump to the bookmark named BOOKMARK (`bookmark-jump').

`C-x r l'
     List all bookmarks (`list-bookmarks').

`M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   The prototypical use for bookmarks is to record one current position
in each of several files.  So the command `C-x r m', which sets a
bookmark, uses the visited file name as the default for the bookmark
name.  If you name each bookmark after the file it points to, then you
can conveniently revisit any of those files with `C-x r b', and move to
the position of the bookmark at the same time.

   To display a list of all your bookmarks in a separate buffer, type
`C-x r l' (`list-bookmarks').  If you switch to that buffer, you can
use it to edit your bookmark definitions or annotate the bookmarks.
Type `C-h m' in that buffer for more information about its special
editing commands.

   When you kill Emacs, Emacs offers to save your bookmark values in
your default bookmark file, `~/.emacs.bmk', if you have changed any
bookmark values.  You can also save the bookmarks at any time with the
`M-x bookmark-save' command.  The bookmark commands load your default
bookmark file automatically.  This saving and loading is how bookmarks
persist from one Emacs session to the next.

   If you set the variable `bookmark-save-flag' to 1, then each command
that sets a bookmark will also save your bookmarks; this way, you don't
lose any bookmark values even if Emacs crashes.  (The value, if a
number, says how many bookmark modifications should go by between
saving.)

   Bookmark position values are saved with surrounding context, so that
`bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable `bookmark-search-size' says how many
characters of context to record, on each side of the bookmark's
position.

   Here are some additional commands for working with bookmarks:

`M-x bookmark-load <RET> FILENAME <RET>'
     Load a file named FILENAME that contains a list of bookmark
     values.  You can use this command, as well as `bookmark-write', to
     work with other files of bookmark values in addition to your
     default bookmark file.

`M-x bookmark-write <RET> FILENAME <RET>'
     Save all the current bookmark values in the file FILENAME.

`M-x bookmark-delete <RET> BOOKMARK <RET>'
     Delete the bookmark named BOOKMARK.

`M-x bookmark-insert-location <RET> BOOKMARK <RET>'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

`M-x bookmark-insert <RET> BOOKMARK <RET>'
     Insert in the buffer the _contents_ of the file that bookmark
     BOOKMARK points to.


File: emacs,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

Controlling the Display
***********************

   Since only part of a large buffer fits in the window, Emacs tries to
show a part that is likely to be interesting.  Display-control commands
allow you to specify which part of the text you want to see, and how to
display it.

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Display Vars::           Information on variables for customizing display.


File: emacs,  Node: Scrolling,  Next: Horizontal Scrolling,  Up: Display

Scrolling
=========

   If a buffer contains text that is too large to fit entirely within a
window that is displaying the buffer, Emacs shows a contiguous portion
of the text.  The portion shown always contains point.

   "Scrolling" means moving text up or down in the window so that
different parts of the text are visible.  Scrolling forward means that
text moves up, and new text appears at the bottom.  Scrolling backward
moves text down and new text appears at the top.

   Scrolling happens automatically if you move point past the bottom or
top of the window.  You can also explicitly request scrolling with the
commands in this section.

`C-l'
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`<NEXT>'
     Likewise, scroll forward.

`M-v'
     Scroll backward (`scroll-down').

`<PRIOR>'
     Likewise, scroll backward.

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-M-l'
     Scroll heuristically to bring useful information onto the screen
     (`reposition-window').

   The most basic scrolling command is `C-l' (`recenter') with no
argument.  It clears the entire screen and redisplays all windows.  In
addition, it scrolls the selected window so that point is halfway down
from the top of the window.

   The scrolling commands `C-v' and `M-v' let you move all the text in
the window up or down a few lines.  `C-v' (`scroll-up') with an
argument shows you that many more lines at the bottom of the window,
moving the text and point up together as `C-l' might.  `C-v' with a
negative argument shows you more lines at the top of the window.  `M-v'
(`scroll-down') is like `C-v', but moves in the opposite direction.
The function keys <NEXT> and <PRIOR> are equivalent to `C-v' and `M-v'.

   The names of scroll commands are based on the direction that the text
moves in the window.  Thus, the command to scroll forward is called
`scroll-up' because it moves the text upward on the screen.

   To read the buffer a windowful at a time, use `C-v' with no argument.
It takes the last two lines at the bottom of the window and puts them at
the top, followed by nearly a whole windowful of lines not previously
visible.  If point was in the text scrolled off the top, it moves to the
new top of the window.  `M-v' with no argument moves backward with
overlap similarly.  The number of lines of overlap across a `C-v' or
`M-v' is controlled by the variable `next-screen-context-lines'; by
default, it is 2.

   Some users like the full-screen scroll commands to keep point at the
same screen line.  To enable this behavior, set the variable
`scroll-preserve-screen-position' to a non-`nil' value.  This mode is
convenient for browsing through a file by scrolling by screenfuls; if
you come back to the screen where you started, point goes back to the
line where it started.  However, this mode is inconvenient when you
move to the next screen in order to move point to the text there.

   Another way to do scrolling is with `C-l' with a numeric argument.
`C-l' does not clear the screen when given an argument; it only scrolls
the selected window.  With a positive argument N, it repositions text
to put point N lines down from the top.  An argument of zero puts point
on the very top line.  Point does not move with respect to the text;
rather, the text and point move rigidly on the screen.  `C-l' with a
negative argument puts point that many lines from the bottom of the
window.  For example, `C-u - 1 C-l' puts point on the bottom line, and
`C-u - 5 C-l' puts it five lines from the bottom.  Just `C-u' as
argument, as in `C-u C-l', scrolls point to the center of the selected
window.

   The `C-M-l' command (`reposition-window') scrolls the current window
heuristically in a way designed to get useful information onto the
screen.  For example, in a Lisp file, this command tries to get the
entire current defun onto the screen if possible.

   Scrolling happens automatically if point has moved out of the visible
portion of the text when it is time to display.  Normally, automatic
scrolling centers point vertically within the window.  However, if you
set `scroll-conservatively' to a small number N, then if you move point
just a little off the screen--less than N lines--then Emacs scrolls the
text just far enough to bring point back on screen.  By default,
`scroll-conservatively' is 0.

   The variable `scroll-margin' restricts how close point can come to
the top or bottom of a window.  Its value is a number of screen lines;
if point comes within that many lines of the top or bottom of the
window, Emacs recenters the window.  By default, `scroll-margin' is 0.


File: emacs,  Node: Horizontal Scrolling,  Next: Follow Mode,  Prev: Scrolling,  Up: Display

Horizontal Scrolling
====================

   "Horizontal scrolling" means shifting all the lines sideways within
a window--so that some of the text near the left margin is not
displayed at all.

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

   When a window has been scrolled horizontally, text lines are
truncated rather than continued (*note Continuation Lines::), with a `$'
appearing in the first column when there is text truncated to the left,
and in the last column when there is text truncated to the right.

   The command `C-x <' (`scroll-left') scrolls the selected window to
the left by N columns with argument N.  This moves part of the
beginning of each line off the left edge of the window.  With no
argument, it scrolls by almost the full width of the window (two
columns less, to be precise).

   `C-x >' (`scroll-right') scrolls similarly to the right.  The window
cannot be scrolled any farther to the right once it is displayed
normally (with each line starting at the window's left margin);
attempting to do so has no effect.  This means that you don't have to
calculate the argument precisely for `C-x >'; any sufficiently large
argument will restore the normal display.

   You can request automatic horizontal scrolling by enabling Hscroll
mode.  When this mode is enabled, Emacs scrolls a window horizontally
whenever that is necessary to keep point visible and not too far from
the left or right edge.  The command to enable or disable this mode is
`M-x hscroll-mode'.


File: emacs,  Node: Follow Mode,  Next: Selective Display,  Prev: Horizontal Scrolling,  Up: Display

Follow Mode
===========

   "Follow mode" is a minor mode that makes two windows showing the
same buffer scroll as one tall "virtual window."  To use Follow mode,
go to a frame with just one window, split it into two side-by-side
windows using `C-x 3', and then type `M-x follow-mode'.  From then on,
you can edit the buffer in either of the two windows, or scroll either
one; the other window follows it.

   To turn off Follow mode, type `M-x follow-mode' a second time.


File: emacs,  Node: Selective Display,  Next: Optional Mode Line,  Prev: Follow Mode,  Up: Display

Selective Display
=================

   Emacs has the ability to hide lines indented more than a certain
number of columns (you specify how many columns).  You can use this to
get an overview of a part of a program.

   To hide lines, type `C-x $' (`set-selective-display') with a numeric
argument N.  Then lines with at least N columns of indentation
disappear from the screen.  The only indication of their presence is
that three dots (`...') appear at the end of each visible line that is
followed by one or more hidden ones.

   The commands `C-n' and `C-p' move across the hidden lines as if they
were not there.

   The hidden lines are still present in the buffer, and most editing
commands see them as usual, so you may find point in the middle of the
hidden text.  When this happens, the cursor appears at the end of the
previous line, after the three dots.  If point is at the end of the
visible line, before the newline that ends it, the cursor appears before
the three dots.

   To make all lines visible again, type `C-x $' with no argument.

   If you set the variable `selective-display-ellipses' to `nil', the
three dots do not appear at the end of a line that precedes hidden
lines.  Then there is no visible indication of the hidden lines.  This
variable becomes local automatically when set.


File: emacs,  Node: Optional Mode Line,  Next: Text Display,  Prev: Selective Display,  Up: Display

Optional Mode Line Features
===========================

   The current line number of point appears in the mode line when Line
Number mode is enabled.  Use the command `M-x line-number-mode' to turn
this mode on and off; normally it is on.  The line number appears
before the buffer percentage POS, with the letter `L' to indicate what
it is.  *Note Minor Modes::, for more information about minor modes and
about how to use this command.

   If the buffer is very large (larger than the value of
`line-number-display-limit'), then the line number doesn't appear.
Emacs doesn't compute the line number when the buffer is large, because
that would be too slow.  If you have narrowed the buffer (*note
Narrowing::), the displayed line number is relative to the accessible
portion of the buffer.

   You can also display the current column number by turning on Column
Number mode.  It displays the current column number preceded by the
letter `C'.  Type `M-x column-number-mode' to toggle this mode.

   Emacs can optionally display the time and system load in all mode
lines.  To enable this feature, type `M-x display-time'.  The
information added to the mode line usually appears after the buffer
name, before the mode names and their parentheses.  It looks like this:

     HH:MMpm L.LL

Here HH and MM are the hour and minute, followed always by `am' or
`pm'.  L.LL is the average number of running processes in the whole
system recently.  (Some fields may be missing if your operating system
cannot support them.)  If you prefer time display in 24-hour format,
set the variable `display-time-24hr-format' to `t'.

   The word `Mail' appears after the load level if there is mail for
you that you have not read yet.


File: emacs,  Node: Text Display,  Next: Display Vars,  Prev: Optional Mode Line,  Up: Display

How Text Is Displayed
=====================

   ASCII printing characters (octal codes 040 through 0176) in Emacs
buffers are displayed with their graphics.  So are non-ASCII multibyte
printing characters (octal codes above 0400).

   Some ASCII control characters are displayed in special ways.  The
newline character (octal code 012) is displayed by starting a new line.
The tab character (octal code 011) is displayed by moving to the next
tab stop column (normally every 8 columns).

   Other ASCII control characters are normally displayed as a caret
(`^') followed by the non-control version of the character; thus,
control-A is displayed as `^A'.

   Non-ASCII characters 0200 through 0377 are displayed with octal
escape sequences; thus, character code 0243 (octal) is displayed as
`\243'.  However, if you enable European display, most of these
characters become non-ASCII printing characters, and are displayed using
their graphics (assuming your terminal supports them).  *Note
Single-Byte European Support::.


File: emacs,  Node: Display Vars,  Prev: Text Display,  Up: Display

Variables Controlling Display
=============================

   This section contains information for customization only.  Beginning
users should skip it.

   The variable `mode-line-inverse-video' controls whether the mode
line is displayed in inverse video (assuming the terminal supports it);
`nil' means don't do so.  *Note Mode Line::.  If you specify the
foreground color for the `modeline' face, and `mode-line-inverse-video'
is non-`nil', then the default background color for that face is the
usual foreground color.  *Note Faces::.

   If the variable `inverse-video' is non-`nil', Emacs attempts to
invert all the lines of the display from what they normally are.

   If the variable `visible-bell' is non-`nil', Emacs attempts to make
the whole screen blink when it would normally make an audible bell
sound.  This variable has no effect if your terminal does not have a way
to make the screen blink.

   When you reenter Emacs after suspending, Emacs normally clears the
screen and redraws the entire display.  On some terminals with more than
one page of memory, it is possible to arrange the termcap entry so that
the `ti' and `te' strings (output to the terminal when Emacs is entered
and exited, respectively) switch between pages of memory so as to use
one page for Emacs and another page for other output.  Then you might
want to set the variable `no-redraw-on-reenter' non-`nil'; this tells
Emacs to assume, when resumed, that the screen page it is using still
contains what Emacs last wrote there.

   The variable `echo-keystrokes' controls the echoing of
multi-character keys; its value is the number of seconds of pause
required to cause echoing to start, or zero meaning don't echo at all.
*Note Echo Area::.

   If the variable `ctl-arrow' is `nil', control characters in the
buffer are displayed with octal escape sequences, except for newline
and tab.  Altering the value of `ctl-arrow' makes it local to the
current buffer; until that time, the default value is in effect.  The
default is initially `t'.  *Note Display Tables: (elisp)Display Tables.

   Normally, a tab character in the buffer is displayed as whitespace
which extends to the next display tab stop position, and display tab
stops come at intervals equal to eight spaces.  The number of spaces
per tab is controlled by the variable `tab-width', which is made local
by changing it, just like `ctl-arrow'.  Note that how the tab character
in the buffer is displayed has nothing to do with the definition of
<TAB> as a command.  The variable `tab-width' must have an integer
value between 1 and 1000, inclusive.

   If the variable `truncate-lines' is non-`nil', then each line of
text gets just one screen line for display; if the text line is too
long, display shows only the part that fits.  If `truncate-lines' is
`nil', then long text lines display as more than one screen line,
enough to show the whole text of the line.  *Note Continuation Lines::.
Altering the value of `truncate-lines' makes it local to the current
buffer; until that time, the default value is in effect.  The default
is initially `nil'.

   If the variable `truncate-partial-width-windows' is non-`nil', it
forces truncation rather than continuation in any window less than the
full width of the screen or frame, regardless of the value of
`truncate-lines'.  For information about side-by-side windows, see
*Note Split Window::.  See also *Note Display: (elisp)Display.

   The variable `baud-rate' holds the output speed of the terminal, as
far as Emacs knows.  Setting this variable does not change the speed of
actual data transmission, but the value is used for calculations such
as padding.  It also affects decisions about whether to scroll part of
the screen or redraw it instead--even when using a window system.  (We
designed it this way, despite the fact that a window system has no true
"output speed," to give you a way to tune these decisions.)

   You can customize the way any particular character code is displayed
by means of a display table.  *Note Display Tables: (elisp)Display
Tables.


File: emacs,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

Searching and Replacement
*************************

   Like other editors, Emacs has commands for searching for occurrences
of a string.  The principal search command is unusual in that it is
"incremental"; it begins to search before you have finished typing the
search string.  There are also nonincremental search commands more like
those of other editors.

   Besides the usual `replace-string' command that finds all
occurrences of one string and replaces them with another, Emacs has a
fancy replacement command called `query-replace' which asks
interactively which occurrences to replace.

* Menu:

* Incremental Search::	   Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::		   Search for sequence of words.
* Regexp Search::	   Search for match for a regexp.
* Regexps::		   Syntax of regular expressions.
* Search Case::		   To ignore case while searching, or not.
* Replace::		   Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.

