This is ../info/ccmode, produced by makeinfo version 4.0 from
cc-mode.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* CC mode: (ccmode).	The GNU Emacs mode for editing C, C++, Objective-C
			  and Java code.
END-INFO-DIR-ENTRY

   Copyright (C) 1995,96,97,98 Free Software Foundation, Inc.


File: ccmode,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

* Menu:

* Introduction::
* Getting Connected::
* New Indentation Engine::
* Minor Modes::
* Commands::
* Customizing Indentation::
* Syntactic Symbols::
* Performance Issues::
* Frequently Asked Questions::
* Getting the latest CC Mode release::
* Sample .emacs File::
* Limitations and Known Bugs::
* Mailing Lists and Submitting Bug Reports::
* Concept Index::
* Command Index::               Command Index
* Key Index::                   Key Index
* Variable Index::              Variable Index


File: ccmode,  Node: Introduction,  Next: Getting Connected,  Prev: Top,  Up: Top

Introduction
************

   Welcome to CC Mode.  This is a GNU Emacs mode for editing files
containing C, C++, Objective-C, Java, and CORBA IDL code.  This
incarnation of the mode is descendant from `c-mode.el' (also called
"Boring Old C Mode" or BOCM `:-)', and `c++-mode.el' version 2, which I
have been maintaining since 1992.  CC Mode represents a significant
milestone in the mode's life.  It has been fully merged back with Emacs
19's `c-mode.el'. Also a new, more intuitive and flexible mechanism for
controlling indentation has been developed.

   CC Mode supports the editing of K&R and ANSI C, "ARM" (1) C++,
Objective-C, Java and CORBA's Interface Definition Language files.  In
this way, you can easily set up consistent coding styles for use in
editing all C, C++, Objective-C, Java and IDL programs. CC Mode does
_not_ handle font-locking (a.k.a. syntax coloring, keyword
highlighting) or anything of that nature, for any of these modes.
Font-locking is handled by other Emacs packages.

   This manual will describe the following:

   * How to get started using CC Mode.

   * How the new indentation engine works.

   * How to customize the new indentation engine.


   Note that the name of this package is "CC Mode", but there is no top
level `cc-mode' entry point.  All of the variables, commands, and
functions in CC Mode are prefixed with `c-<THING>', and `c-mode',
`c++-mode', `objc-mode', `java-mode', and `idl-mode' entry points are
provided.  This file is intended to be a replacement for `c-mode.el'
and `c++-mode.el'.

   This distribution also contains a file called `cc-compat.el' which
should ease your transition from BOCM to CC Mode.  If you have a BOCM
configuration you are really happy with, and want to postpone learning
how to configure CC Mode, take a look at that file.  It maps BOCM
configuration variables to CC Mode's new indentation model.  It is not
actively supported so for the long run, you should learn how to
customize CC Mode to support your coding style.

   A special word of thanks goes to Krishna Padmasola for his work in
converting the original `README' file to Texinfo format.  I'd also like
to thank all the CC Mode victims who help enormously during the early
beta stages of CC Mode's development.

   ---------- Footnotes ----------

   (1) "The Annotated C++ Reference Manual", by Ellis and Stroustrup.


File: ccmode,  Node: Getting Connected,  Next: New Indentation Engine,  Prev: Introduction,  Up: Top

Getting Connected
*****************

   If you got this version of CC Mode with Emacs or XEmacs, it should
work just fine right out of the box.  Note however that you may not have
the latest CC Mode release and may want to upgrade your copy.

   If you are upgrading an existing CC Mode installation, please see the
`README' file for installation details.  CC Mode may not work with
older versions of Emacs or XEmacs.  See the CC Mode release notes Web
pages for the latest information on Emacs version and package
compatibility (see *Note Getting the latest CC Mode release::).

   _Note that CC Mode no longer works with Emacs 18!_  The
`cc-mode-18.el' file is no longer distributed with CC Mode.  If you
haven't upgraded from Emacs 18 by now, you are out of luck.

   You can find out what version of CC Mode you are using by visiting a
C file and entering `M-x c-version RET'.  You should see this message in
the echo area:

     Using CC Mode version 5.XX

where `XX' is the minor release number.


File: ccmode,  Node: New Indentation Engine,  Next: Minor Modes,  Prev: Getting Connected,  Up: Top

New Indentation Engine
**********************

   CC Mode has a new indentation engine, providing a simplified, yet
flexible and general mechanism for customizing indentation. It separates
indentation calculation into two steps: first, CC Mode analyzes the
line of code being indented to determine the kind of language construct
it's looking at, then it applies user defined offsets to the current
line based on this analysis.

   This section will briefly cover how indentation is calculated in CC
Mode. It is important to understand the indentation model being used so
that you will know how to customize CC Mode for your personal coding
style.

* Menu:

* Syntactic Analysis::
* Indentation Calculation::


File: ccmode,  Node: Syntactic Analysis,  Next: Indentation Calculation,  Up: New Indentation Engine

Syntactic Analysis
==================

   The first thing CC Mode does when indenting a line of code, is to
analyze the line, determining the "syntactic component list" of the
construct on that line.  A syntactic component consists of a pair of
information (in lisp parlance, a _cons cell_), where the first part is
a "syntactic symbol", and the second part is a "relative buffer
position".  Syntactic symbols describe elements of C code (1), e.g.
`statement', `substatement', `class-open', `class-close', etc.  *Note
Syntactic Symbols::, for a complete list of currently recognized
syntactic symbols and their semantics.  The variable `c-offsets-alist'
also contains the list of currently supported syntactic symbols.

   Conceptually, a line of C code is always indented relative to the
indentation of some line higher up in the buffer.  This is represented
by the relative buffer position in the syntactic component.

   Here is an example.  Suppose we had the following code as the only
thing in a `c++-mode' buffer (2):

       1: void swap( int& a, int& b )
       2: {
       3:     int tmp = a;
       4:     a = b;
       5:     b = tmp;
       6: }

   We can use the command `C-c C-s' (`c-show-syntactic-information') to
simply report what the syntactic analysis is for the current line.
Running this command on line 4 of this example, we'd see in the echo
area(3):

     ((statement . 35))

   This tells us that the line is a statement and it is indented
relative to buffer position 35, which happens to be the `i' in `int' on
line 3.  If you were to move point to line 3 and hit `C-c C-s', you
would see:

     ((defun-block-intro . 29))

   This indicates that the `int' line is the first statement in a top
level function block, and is indented relative to buffer position 29,
which is the brace just after the function header.

   Here's another example:

       1: int add( int val, int incr, int doit )
       2: {
       3:     if( doit )
       4:         {
       5:             return( val + incr );
       6:         }
       7:     return( val );
       8: }

Hitting `C-c C-s' on line 4 gives us:

     ((substatement-open . 46))

which tells us that this is a brace that _opens_ a substatement block.
(4)

   Syntactic component lists can contain more than one component, and
individual syntactic components need not have relative buffer positions.
The most common example of this is a line that contains a "comment only
line".

       1: void draw_list( List<Drawables>& drawables )
       2: {
       3:         // call the virtual draw() method on each element in list
       4:     for( int i=0; i < drawables.count(), ++i )
       5:     {
       6:         drawables[i].draw();
       7:     }
       8: }

Hitting `C-c C-s' on line 3 of this example gives:

     ((comment-intro) (defun-block-intro . 46))

and you can see that the syntactic component list contains two syntactic
components.  Also notice that the first component, `(comment-intro)'
has no relative buffer position.

   ---------- Footnotes ----------

   (1) or C++, Objective-C, Java or IDL code.  In general, for the rest
of this manual I'll use the term "C code" to refer to all the C-like
dialects, unless otherwise noted.

   (2) The line numbers in this and future examples don't actually
appear in the buffer, of course!

   (3) With a universal argument (i.e. `C-u C-c C-s') the analysis is
inserted into the buffer as a comment on the current line.

   (4) A "substatement" is the line after a conditional statement, such
as `if', `else', `while', `do', `switch', etc.  A "substatement block"
is a brace block following one of these conditional statements.


File: ccmode,  Node: Indentation Calculation,  Prev: Syntactic Analysis,  Up: New Indentation Engine

Indentation Calculation
=======================

   Indentation for a line is calculated using the syntactic component
list derived in step 1 above (see *Note Syntactic Analysis::).  Each
component contributes to the final total indentation of the line in two
ways.

   First, the syntactic symbols are looked up in the `c-offsets-alist'
variable, which is an association list of syntactic symbols and the
offsets to apply for those symbols.  These offsets are added to a
running total.

   Second, if the component has a relative buffer position, CC Mode
adds the column number of that position to the running total.  By adding
up the offsets and columns for every syntactic component on the list,
the final total indentation for the current line is computed.

   Let's use our two code examples above to see how this works.  Here is
our first example again:

         1: void swap( int& a, int& b )
         2: {
         3:     int tmp = a;
         4:     a = b;
         5:     b = tmp;
         6: }

   Let's say point is on line 3 and we hit the `TAB' key to re-indent
the line.  Remember that the syntactic component list for that line is:

     ((defun-block-intro . 29))

CC Mode looks up `defun-block-intro' in the `c-offsets-alist' variable.
Let's say it finds the value `4'; it adds this to the running total
(initialized to zero), yielding a running total indentation of 4 spaces.

   Next CC Mode goes to buffer position 29 and asks for the current
column.  This brace is in column zero, so CC Mode adds `0' to the
running total.  Since there is only one syntactic component on the list
for this line, indentation calculation is complete, and the total
indentation for the line is 4 spaces.

   Here's another example:

         1: int add( int val, int incr, int doit )
         2: {
         3:     if( doit )
         4:         {
         5:             return( val + incr );
         6:         }
         7:     return( val );
         8: }

   If we were to hit `TAB' on line 4 in the above example, the same
basic process is performed, despite the differences in the syntactic
component list.  Remember that the list for this line is:

     ((substatement-open . 46))

   Here, CC Mode first looks up the `substatement-open' symbol in
`c-offsets-alist'. Let's say it finds the value `4'.  This yields a
running total of 4.  CC Mode then goes to buffer position 46, which is
the `i' in `if' on line 3.  This character is in the fourth column on
that line so adding this to the running total yields an indentation for
the line of 8 spaces.

   Simple, huh?

   Actually, the mode usually just does The Right Thing without you
having to think about it in this much detail.  But when customizing
indentation, it's helpful to understand the general indentation model
being used.

   As you configure CC Mode, you might want to set the variable
`c-echo-syntactic-information-p' to non-`nil' so that the syntactic
component list and calculated offset will always be echoed in the
minibuffer when you hit `TAB'.


File: ccmode,  Node: Minor Modes,  Next: Commands,  Prev: New Indentation Engine,  Up: Top

Minor Modes
***********

   CC Mode contains two minor-mode-like features that you should find
useful while you enter new C code.  The first is called "auto-newline"
mode, and the second is called "hungry-delete" mode.  These minor modes
can be toggled on and off independently, and CC Mode can be configured
so that it starts up with any combination of these minor modes.  By
default, both of these minor modes are turned off.

   The state of the minor modes is always reflected in the minor mode
list on the modeline of the CC Mode buffer.  When auto-newline mode is
enabled, you will see `C/a' on the mode line (1).  When hungry delete
mode is enabled you would see `C/h' and when both modes are enabled,
you'd see `C/ah'.

   CC Mode provides keybindings which allow you to toggle the minor
modes on the fly while editing code.  To toggle just the auto-newline
state, hit `C-c C-a' (`c-toggle-auto-state').  When you do this, you
should see the `a' indicator either appear or disappear on the
modeline.  Similarly, to toggle just the hungry-delete state, use `C-c
C-d' (`c-toggle-hungry-state'), and to toggle both states, use `C-c
C-t' (`c-toggle-auto-hungry-state').

   To set up the auto-newline and hungry-delete states to your preferred
values, you would need to add some lisp to your `.emacs' file that
called one of the `c-toggle-*-state' functions directly.  When called
programmatically, each function takes a numeric value, where a positive
number enables the minor mode, a negative number disables the mode, and
zero toggles the current state of the mode.

   So for example, if you wanted to enable both auto-newline and
hungry-delete for all your C file editing, you could add the following
to your `.emacs' file:

     (add-hook 'c-mode-common-hook
     	  '(lambda () (c-toggle-auto-hungry-state 1)))

* Menu:

* Auto-newline insertion::
* Hungry-deletion of whitespace::
* Auto-fill mode interaction::

   ---------- Footnotes ----------

   (1) Remember that the `C' could be replaced with `C++', `ObjC',
`Java' or `IDL'.


File: ccmode,  Node: Auto-newline insertion,  Next: Hungry-deletion of whitespace,  Up: Minor Modes

Auto-newline insertion
======================

   Auto-newline minor mode works by enabling certain "electric
commands".  Electric commands are typically bound to special characters
such as the left and right braces, colons, semi-colons, etc., which when
typed, perform some magic formatting in addition to inserting the typed
character.  As a general rule, electric commands are only electric when
the following conditions apply:

   * Auto-newline minor mode is enabled, as evidenced by a `C/a' or
     `C/ah' indicator on the modeline.

   * The character was not typed inside of a literal (1).

   * No numeric argument was supplied to the command (i.e. it was typed
     as normal, with no `C-u' prefix).


* Menu:

* Hanging Braces::
* Hanging Colons::
* Hanging Semi-colons and commas::
* Other electric commands::
* Clean-ups::

   ---------- Footnotes ----------

   (1) A "literal" is defined as any comment, string, or C preprocessor
macro definition.  These constructs are also known as "syntactic
whitespace" since they are usually ignored when scanning C code.


File: ccmode,  Node: Hanging Braces,  Next: Hanging Colons,  Up: Auto-newline insertion

Hanging Braces
--------------

   When you type either an open or close brace (i.e. `{' or `}'), the
electric command `c-electric-brace' gets run.  This command has two
electric formatting behaviors.  First, it will perform some
re-indentation of the line the brace was typed on, and second, it will
add various newlines before and/or after the typed brace.
Re-indentation occurs automatically whenever the electric behavior is
enabled.  If the brace ends up on a line other than the one it was typed
on, then that line is also re-indented.

   The insertion of newlines is controlled by the
`c-hanging-braces-alist' variable.  This variable contains a mapping
between syntactic symbols related to braces, and a list of places to
insert a newline.  The syntactic symbols that are useful for this list
are: `class-open', `class-close', `defun-open', `defun-close',
`inline-open', `inline-close', `brace-list-open', `brace-list-close',
`brace-list-intro', `brace-list-entry', `block-open', `block-close',
`substatement-open', `statement-case-open', `extern-lang-open',
`extern-lang-close', `namespace-open', and `namespace-close'.  *Note
Syntactic Symbols::, for a more detailed description of these syntactic
symbols.

   The value associated with each syntactic symbol in this association
list is called an ACTION which can be either a function or a list.
*Note Custom Brace and Colon Hanging::, for a more detailed discussion
of using a function as a brace hanging ACTION.

   When the ACTION is a list, it can contain any combination of the
symbols `before' and `after', directing CC Mode where to put newlines
in relationship to the brace being inserted.  Thus, if the list
contains only the symbol `after', then the brace is said to "hang" on
the right side of the line, as in:

     // here, open braces always `hang'
     void spam( int i ) {
         if( i == 7 ) {
             dosomething(i);
         }
     }

   When the list contains both `after' and `before', the braces will
appear on a line by themselves, as shown by the close braces in the
above example.  The list can also be empty, in which case no newlines
are added either before or after the brace.

   For example, the default value of `c-hanging-braces-alist' is:

     (defvar c-hanging-braces-alist '((brace-list-open)
                                      (substatement-open after)
                                      (block-close . c-snug-do-while)
                                      (extern-lang-open after)))

which says that `brace-list-open' braces should both hang on the right
side, and allow subsequent text to follow on the same line as the
brace.  Also, `substatement-open' and `extern-lang-open' braces should
hang on the right side, but subsequent text should follow on the next
line.  Here, in the `block-close' entry, you also see an example of
using a function as an ACTION.

   A word of caution: it is not a good idea to hang top-level construct
introducing braces, such as `class-open' or `defun-open'.  Emacs makes
an assumption that such braces will always appear in column zero,
hanging such braces can introduce performance problems.  *Note
Performance Issues::, for more information.


File: ccmode,  Node: Hanging Colons,  Next: Hanging Semi-colons and commas,  Prev: Hanging Braces,  Up: Auto-newline insertion

Hanging Colons
--------------

   Using a mechanism similar to brace hanging (see *Note Hanging
Braces::), colons can also be made to hang using the variable
`c-hanging-colons-alist'.  The syntactic symbols appropriate for this
assocation list are: `case-label', `label', `access-label',
`member-init-intro', and `inher-intro'.  Note however that for
`c-hanging-colons-alist', ACTIONs as functions are not supported. See
also *Note Custom Brace and Colon Hanging:: for details.

   In C++, double-colons are used as a scope operator but because these
colons always appear right next to each other, newlines before and after
them are controlled by a different mechanism, called "clean-ups" in CC
Mode.  *Note Clean-ups::, for details.


File: ccmode,  Node: Hanging Semi-colons and commas,  Next: Other electric commands,  Prev: Hanging Colons,  Up: Auto-newline insertion

Hanging Semi-colons and commas
------------------------------

   Semicolons and commas are also electric in CC Mode, but since these
characters do not correspond directly to syntactic symbols, a different
mechanism is used to determine whether newlines should be automatically
inserted after these characters.  *Note Customizing Semi-colons and
Commas::, for details.


File: ccmode,  Node: Other electric commands,  Next: Clean-ups,  Prev: Hanging Semi-colons and commas,  Up: Auto-newline insertion

Other electric commands
-----------------------

   A few other keys also provide electric behavior.  For example `#'
(`c-electric-pound') is electric when typed as the first non-whitespace
character on a line.  In this case, the variable
`c-electric-pound-behavior' is consulted for the electric behavior.
This variable takes a list value, although the only element currently
defined is `alignleft', which tells this command to force the `#'
character into column zero.  This is useful for entering C preprocessor
macro definitions.

   Stars and slashes (i.e. `*' and `/', `c-electric-star' and
`c-electric-slash' respectively) are also electric under certain
circumstances.  If a star is inserted as the second character of a C
style block comment on a "comment-only" line, then the comment
delimiter is indented as defined by `c-offsets-alist'.  A comment-only
line is defined as a line which contains only a comment, as in:

     void spam( int i )
     {
             // this is a comment-only line...
         if( i == 7 )                             // but this is not
         {
             dosomething(i);
         }
     }

   Likewise, if a slash is inserted as the second slash in a C++ style
line comment (also only on a comment-only line), then the line is
indented as defined by `c-offsets-alist'.

   Less-than and greater-than signs (`c-electric-lt-gt') are also
electric, but only in C++ mode.  Hitting the second of two `<' or `>'
keys re-indents the line if it is a C++ style stream operator.


File: ccmode,  Node: Clean-ups,  Prev: Other electric commands,  Up: Auto-newline insertion

Clean-ups
---------

   "Clean-ups" are a mechanism complementary to colon and brace
hanging.  On the surface, it would seem that clean-ups overlap the
functionality provided by the `c-hanging-*-alist' variables, and
similarly, clean-ups are only enabled when auto-newline minor mode is
enabled.  Clean-ups are used however to adjust code "after-the-fact",
i.e. to eliminate some whitespace that is inserted by electric
commands, or whitespace that contains intervening constructs.

   You can configure CC Mode's clean-ups by setting the variable
`c-cleanup-list', which is a list of clean-up symbols.  By default, CC
Mode cleans up only the `scope-operator' construct, which is necessary
for proper C++ support.  Note that clean-ups are only performed when
the construct does not occur within a literal (see *Note Auto-newline
insertion::), and when there is nothing but whitespace appearing
between the individual components of the construct.

   There are currently only five specific constructs that CC Mode can
clean up, as indicated by these symbols:

   * `brace-else-brace' -- cleans up `} else {' constructs by placing
     the entire construct on a single line.  Clean-up occurs when the
     open brace after the `else' is typed.  So for example, this:

          void spam(int i)
          {
              if( i==7 )
              {
                  dosomething();
              }
              else
              {

     appears like this after the open brace is typed:

          void spam(int i)
          {
              if( i==7 ) {
                  dosomething();
              } else {

   * `brace-elseif-brace' -- similar to the `brace-else-brace'
     clean-up, but this cleans up `} else if (...) {' constructs.  For
     example:

          void spam(int i)
          {
              if( i==7 )
              {
                  dosomething();
              }
              else if( i==3 ) {

     appears like this after the open brace is typed:

          void spam(int i)
          {
              if( i==7 ) {
                  dosomething();
              } else if( i==3 ) {

   * `empty-defun-braces' -- cleans up braces following a top-level
     function or class definition that contains no body.  Clean up
     occurs when the closing brace is typed.  Thus the following:

          class Spam
          {
          }

     is transformed into this when the close brace is typed:

          class Spam
          {}

   * `defun-close-semi' -- cleans up the terminating semi-colon on
     top-level function or class definitions when they follow a close
     brace. Clean up occurs when the semi-colon is typed.  So for
     example, the following:

          class Spam
          {
          }
          ;

     is transformed into this when the semi-colon is typed:


          class Spam
          {
          };

   * `list-close-comma' -- cleans up commas following braces in array
     and aggregate initializers.  Clean up occurs when the comma is
     typed.

   * `scope-operator' -- cleans up double colons which may designate a
     C++ scope operator split across multiple lines(1).  Clean up
     occurs when the second colon is typed.  You will always want
     `scope-operator' in the `c-cleanup-list' when you are editing C++
     code.


   ---------- Footnotes ----------

   (1) Certain C++ constructs introduce ambiguous situations, so
`scope-operator' clean-ups may not always be correct.  This usually
only occurs when scoped identifiers appear in switch label tags.


File: ccmode,  Node: Hungry-deletion of whitespace,  Next: Auto-fill mode interaction,  Prev: Auto-newline insertion,  Up: Minor Modes

Hungry-deletion of whitespace
=============================

   Hungry deletion of whitespace, or as it more commonly called,
"hungry-delete mode", is a simple feature that some people find
extremely useful.  In fact, you might find yourself wanting
hungry-delete in *all* your editing modes!

   In a nutshell, when hungry-delete mode is enabled, hitting the
<Backspace> key(1) will consume all preceding whitespace, including
newlines and tabs.  This can really cut down on the number of
<Backspace>'s you have to type if, for example you made a mistake on
the preceding line.

   By default, when you hit the <Backspace> key CC Mode runs the
command `c-electric-backspace', which deletes text in the backwards
direction.  When deleting a single character, or when <Backspace> is
hit in a literal (see *Note Auto-newline insertion::), or when
hungry-delete mode is disabled, the function contained in the
`c-backspace-function' variable is called with one argument (the number
of characters to delete).  This variable is set to
`backward-delete-char-untabify' by default.

   Similarly, hitting the <Delete> key runs the command
`c-electric-delete'.  When deleting a single character, or when
<Delete> is hit in a literal, or when hungry-delete mode is disabled,
the function contained in the `c-delete-function' variable is called
with one argument (the number of characters to delete).  This variable
is set to `delete-char' by default.

   However, if `delete-key-deletes-forward' is `nil', or your Emacs
does not support separation of <Backspace> and <DEL>, then
`c-electric-delete' simply calls `c-electric-backspace'.

   ---------- Footnotes ----------

   (1) I say "hit the <Backspace> key" but what I really mean is "when
Emacs receives the `BackSpace' key event".  The difference usually
isn't significant to most users, but advanced users will realize that
under window systems such as X, any physical key (keycap) on the
keyboard can be configured to generate any keysym, and thus any Emacs
key event.  Also, the use of Emacs on TTYs will affect which keycap
generates which key event.  From a pedantic point of view, here we are
only concerned with the key event that Emacs receives.


File: ccmode,  Node: Auto-fill mode interaction,  Prev: Hungry-deletion of whitespace,  Up: Minor Modes

Auto-fill mode interaction
==========================

   One other note about minor modes is worth mentioning here.  CC Mode
now works much better with auto-fill mode (a standard Emacs minor mode)
by correctly auto-filling both line (e.g. C++ style) and block (e.g. C
style) oriented comments.  When `auto-fill-mode' is enabled, line
oriented comments will also be auto-filled by inserting a newline at the
line break, and inserting `//' at the start of the next line.

   When auto-filling block oriented comments, the behavior is dependent
on the value of the variable `c-comment-continuation-stars'.  When this
variable is `nil', the old behavior for auto-filling C comments is in
effect.  In this case, the line is broken by closing the comment and
starting a new comment on the next line.

   If you set `c-comment-continuation-stars' to a string, then a long C
block comment line is broken by inserting a newline at the line break
position, and inserting this string at the beginning of the next comment
line.  The default value for `c-comment-continuation-stars' is `* ' (a
star followed by a single space)(1).

   ---------- Footnotes ----------

   (1) To get block comment continuation lines indented under the block
comment starter (e.g. the `/*'), it is not enough to set
`c-comment-continuation-stars' to the empty string.  You need to do
this, but you also need to set the offset for the `c' syntactic symbol
to be zero.


File: ccmode,  Node: Commands,  Next: Customizing Indentation,  Prev: Minor Modes,  Up: Top

Commands
********

* Menu:

* Indentation Commands::
* Other Commands::


File: ccmode,  Node: Indentation Commands,  Next: Other Commands,  Up: Commands

Indentation Commands
====================

   Various commands are provided which allow you to conveniently
re-indent C constructs.  There are several things to note about these
indentation commands.  First, when you change your programming style,
either interactively or through some other means, your file does _not_
automatically get re-indented.  When you change style parameters, you
will typically need to reformat the line, expression, or buffer to see
the effects of your changes.

   Second, changing some variables have no effect on existing code, even
when you do re-indent.  For example, the `c-hanging-*' variables and
`c-cleanup-list' only affect new code as it is typed in on-the-fly, so
changing `c-hanging-braces-alist' and re-indenting the buffer will not
adjust placement of braces already in the file.

   Third, re-indenting large portions of code is currently rather
inefficient.  Improvements have been made since previous releases of CC
Mode, and much more radical improvements are planned, but for now you
need to be aware of this (1).  Some provision has been made to at least
inform you as to the progress of the re-indentation.  The variable
`c-progress-interval' controls how often a progress message is
displayed.  Set this variable to `nil' to inhibit progress messages,
including messages normally printed when indentation is started and
completed.

   Also, except as noted below, re-indentation is always driven by the
same mechanisms that control on-the-fly indentation of code.  *Note New
Indentation Engine::, for details.

   To indent a single line of code, use `TAB' (`c-indent-command').
The behavior of this command is controlled by the variable
`c-tab-always-indent'.  When this variable is `t', `TAB' always just
indents the current line.  When `nil', the line is indented only if
point is at the left margin, or on or before the first non-whitespace
character on the line, otherwise _something else happens_(2).  If the
value of `c-tab-always-indent' is something other than `t' or `nil'
(e.g. `'other'), then a real tab character(3)  is inserted only when
point is inside a literal (see *Note Auto-newline insertion::),
otherwise the line is indented.

   To indent an entire balanced brace or parenthesis expression, use
`M-C-q' (`c-indent-exp').  Note that point should be on the opening
brace or parenthesis of the expression you want to indent.

   Another very convenient keystroke is `C-c C-q' (`c-indent-defun')
when re-indents the entire top-level function or class definition that
encompasses point.  It leaves point at the same position within the
buffer.

   To indent any arbitrary region of code, use `M-C-\'
(`indent-region').   This is a standard Emacs command, specially
tailored for C code in a CC Mode buffer.  Note that of course, point
and mark must delineate the region you want to indent.

   While not strictly an indentation function, `M-C-h'
(`c-mark-function') is useful for marking the current top-level
function or class definition as the current region.

   ---------- Footnotes ----------

   (1) In particular, I have had people complain about the speed with
which `lex(1)' output is re-indented.  Lex, yacc, and other code
generators usually output some pretty perversely formatted code.
_Don't_ try to indent this stuff!

   (2) Actually what happens is that the function stored in
`c-insert-tab-function' is called.  Normally this just inserts a real
tab character, or the equivalent number of spaces, depending on the
setting of the variable `indent-tabs-mode'.  If you preferred, you
could set `c-insert-tab-function' to `tab-to-tab-stop' for example.

   (3) The caveat about `indent-tabs-mode' in the previous footnote
also applies here.


File: ccmode,  Node: Other Commands,  Prev: Indentation Commands,  Up: Commands

Other Commands
==============

   CC Mode contains other useful command for moving around in C code.

`M-x c-beginning-of-defun'
     Moves point back to the least-enclosing brace.  This function is
     analogous to the Emacs built-in command `beginning-of-defun',
     except it eliminates the constraint that the top-level opening
     brace must be in column zero.  See `beginning-of-defun' for more
     information.

     Depending on the coding style being used, you might prefer
     `c-beginning-of-defun' to `beginning-of-defun'.  If so, consider
     binding `C-M-a' to the former instead.  For backwards
     compatibility reasons, the default binding remains in effect.

`M-x c-end-of-defun'
     Moves point to the end of the current top-level definition.  This
     function is analogous to the Emacs built-in command `end-of-defun',
     except it eliminates the constraint that the top-level opening
     brace of the defun must be in column zero.  See
     `beginning-of-defun' for more information.

     Depending on the coding style being used, you might prefer
     `c-end-of-defun' to `end-of-defun'.  If so, consider binding
     `C-M-e' to the former instead.  For backwards compatibility
     reasons, the default binding remains in effect.

`C-c C-u (c-up-conditional)'
     Move point back to the containing preprocessor conditional,
     leaving the mark behind.  A prefix argument acts as a repeat
     count.  With a negative argument, move point forward to the end of
     the containing preprocessor conditional.  When going backwards,
     `#elif' is treated like `#else' followed by `#if'.  When going
     forwards, `#elif' is ignored.

`C-c C-p (c-backward-conditional)'
     Move point back over a preprocessor conditional, leaving the mark
     behind.  A prefix argument acts as a repeat count.  With a negative
     argument, move forward.

`C-c C-n (c-forward-conditional)'
     Move point forward across a preprocessor conditional, leaving the
     mark behind.  A prefix argument acts as a repeat count.  With a
     negative argument, move backward.

`M-a (c-beginning-of-statement)'
     Move point to the beginning of the innermost C statement.  If
     point is already at the beginning of a statement, it moves to the
     beginning of the closest preceding statement, even if that means
     moving into a block (you can use `M-C-b' to move over a balanced
     block).  With prefix argument N, move back N - 1 statements.

     If point is within a comment, or next to a comment, this command
     moves by sentences instead of statements.

     When called from a program, this function takes three optional
     arguments: the numeric prefix argument, a buffer position limit
     (used as a starting point for syntactic parsing and as a limit for
     backward movement), and a flag to indicate whether movement should
     be by statements (if `nil') or sentence (if non-`nil').

`M-e (c-end-of-statement)'
     Move point to the end of the innermost C statement.  If point is
     at the end of a statement, move to the end of the next statement,
     even if it's inside a nested block (use `M-C-f' to move to the
     other side of the block).  With prefix argument N, move forward N
     - 1 statements.

     If point is within a comment, or next to a comment, this command
     moves by sentences instead of statements.

     When called from a program, this function takes three optional
     arguments: the numeric prefix argument, a buffer position limit
     (used as a starting point for syntactic parsing and as a limit for
     backward movement), and a flag to indicate whether movement should
     be by statements (if `nil') or sentence (if non-`nil').

`M-x c-forward-into-nomenclature'
     A popular programming style, especially for object-oriented
     languages such as C++ is to write symbols in a mixed case format,
     where the first letter of each word is capitalized, and not
     separated by underscores.  E.g.
     `SymbolsWithMixedCaseAndNoUnderlines'.

     This command moves point forward to next capitalized word.  With
     prefix argument N, move N times.

`M-x c-backward-into-nomenclature'
     Move point backward to beginning of the next capitalized word.
     With prefix argument N, move N times.  If N is negative, move
     forward.

`C-c : (c-scope-operator)'
     In C++, it is also sometimes desirable to insert the double-colon
     scope operator without performing the electric behavior of colon
     insertion.  `C-c :' does just this.

`M-q (fill-paragraph)'
     The command is used to fill a block style (C) or line style (C++)
     comment, in much the same way that text in the various text modes
     can be filled(1).  You should never attempt to fill non-comment
     code sections; you'll end up with garbage!  Two variables control
     how C style block comments are filled, specifically how the
     comment start and end delimiters are handled.

     The variable `c-hanging-comment-starter-p' controls whether comment
     start delimiters which appear on a line by themselves, end up on a
     line by themselves after the fill.  When the value is `nil', the
     comment starter will remain on its own line(2).  Otherwise, text
     on the next line will be put on the same line as the comment
     starter.  This is called "hanging" because the following text hangs
     on the line with the comment starter(3)

     The variable `c-hanging-comment-ender-p' controls the analogous
     behavior for the block comment end delimiter.  When the value is
     `nil', the comment ender will remain on its own line after the
     file(4).  Otherwise, the comment end delimiter will be placed at
     the end of the previous line.

   ---------- Footnotes ----------

   (1) You should not use specialized filling packages such as
`filladapt' with CC Mode.  They don't work as well for filling as
`c-fill-paragraph'

   (2) It will not be placed on a separate line if it is not already on
a separate line.

   (3) This variable is `t' by default, except in `java-mode'.  Hanging
comment starters mess up Javadoc style comments.

   (4) The same caveat as above holds true.


File: ccmode,  Node: Customizing Indentation,  Next: Syntactic Symbols,  Prev: Commands,  Up: Top

Customizing Indentation
***********************

   The variable `c-offsets-alist' contains the mappings between
syntactic symbols and the offsets to apply for those symbols.  You
should never modify this variable directly though.  Use the function
`c-set-offset' instead (see below for details).

   The `c-offsets-alist' variable is where you customize all your
indentations.  You simply need to decide what additional offset you want
to add for every syntactic symbol.  You can use the command `C-c C-o'
(`c-set-offset') as the way to set offsets, both interactively and from
your mode hook.  Also, you can set up _styles_ of indentatio.  Most
likely, you'll find one of the pre-defined styles will suit your needs,
but if not, this section will describe how to set up basic editing
configurations.  *Note Styles::, for an explanation of how to set up
named styles.

   As mentioned previously, the variable `c-offsets-alist' is an
association list of syntactic symbols and the offsets to be applied for
those symbols.  In fact, these offset values can be any of an integer, a
function or lambda expression, a variable name, or one of the following
symbols: `+', `-', `++', `--', `*', or `/'.  These symbols describe
offset in multiples of the value of the variable `c-basic-offset'.  By
defining a style's indentation in terms of this fundamental variable,
you can change the amount of whitespace given to an indentation level
while leaving the same relationship between levels.  Here are the
values that the special symbols correspond to:

`+'
     `c-basic-offset' times 1

`-'
     `c-basic-offset' times -1

`++'
     `c-basic-offset' times 2

`--'
     `c-basic-offset' times -2

`*'
     `c-basic-offset' times 0.5

`/'
     `c-basic-offset' times -0.5

So, for example, because most of the default offsets are defined in
terms of `+', `-', and `0', if you like the general indentation style,
but you use 4 spaces instead of 2 spaces per level, you can probably
achieve your style just by changing `c-basic-offset' like so (in your
`.emacs' file):

     (setq c-basic-offset 4)

This would change

     int add( int val, int incr, int doit )
     {
       if( doit )
         {
           return( val + incr );
         }
       return( val );
     }

to

     int add( int val, int incr, int doit )
     {
         if( doit )
             {
                 return( val + incr );
             }
         return( val );
     }

   To change indentation styles more radically, you will want to change
the value associated with the syntactic symbols in the
`c-offsets-alist' variable.  First, I'll show you how to do that
interactively, then I'll describe how to make changes to your `.emacs'
file so that your changes are more permanent.

* Menu:

* Interactive Customization::
* Permanent Customization::
* Styles::
* Advanced Customizations::


File: ccmode,  Node: Interactive Customization,  Next: Permanent Customization,  Up: Customizing Indentation

Interactive Customization
=========================

   As an example of how to customize indentation, let's change the
style of this example(1):

     1: int add( int val, int incr, int doit )
     2: {
     3:   if( doit )
     4:     {
     5:       return( val + incr );
     6:     }
     7:   return( val );
     8: }

to:

     1: int add( int val, int incr, int doit )
     2: {
     3:   if( doit )
     4:   {
     5:     return( val + incr );
     6:   }
     7:   return( val );
     8: }

   In other words, we want to change the indentation of braces that
open a block following a condition so that the braces line up under the
conditional, instead of being indented.  Notice that the construct we
want to change starts on line 4.  To change the indentation of a line,
we need to see which syntactic components affect the offset calculations
for that line.  Hitting `C-c C-s' on line 4 yields:

     ((substatement-open . 44))

so we know that to change the offset of the open brace, we need to
change the indentation for the `substatement-open' syntactic symbol.
To do this interactively, just hit `C-c C-o' (`c-set-offset').  This
prompts you for the syntactic symbol to change, providing a reasonable
default.  In this case, the default is `substatement-open', which is
just the syntactic symbol we want to change!

   After you hit return, CC Mode will then prompt you for the new
offset value, with the old value as the default.  The default in this
case is `+', but we want no extra indentation so enter `0' and `RET'.
This will associate the offset 0 with the syntactic symbol
`substatement-open' in the `c-offsets-alist' variable.

   To check your changes quickly, just hit `C-c C-q' (`c-indent-defun')
to reindent the entire function.  The example should now look like:

     1: int add( int val, int incr, int doit )
     2: {
     3:   if( doit )
     4:   {
     5:     return( val + incr );
     6:   }
     7:   return( val );
     8: }

   Notice how just changing the open brace offset on line 4 is all we
needed to do.  Since the other affected lines are indented relative to
line 4, they are automatically indented the way you'd expect.  For more
complicated examples, this may not always work.  The general approach to
take is to always start adjusting offsets for lines higher up in the
file, then re-indent and see if any following lines need further
adjustments.

   ---------- Footnotes ----------

   (1) In this an subsequent examples, the original code is formatted
using the `gnu' style unless otherwise indicated. *Note Styles::.


File: ccmode,  Node: Permanent Customization,  Next: Styles,  Prev: Interactive Customization,  Up: Customizing Indentation

Permanent Customization
=======================

   To make your changes permanent, you need to add some lisp code to
your `.emacs' file, but first you need to decide whether your styles
should be global in every buffer, or local to each specific buffer.

   If you edit primarily one style of code, you may want to make the CC
Mode style variables have global values so that every buffer will share
the style settings.  This will allow you to set the CC Mode variables
at the top level of your `.emacs' file, and is the way CC Mode works by
default.

   If you edit many different styles of code at the same time, you
might want to make the CC Mode style variables have buffer local
values.  If you do this, then you will need to set any CC Mode style
variables in a hook function (e.g. off of `c-mode-common-hook' instead
of at the top level of your `.emacs' file).  The recommended way to do
this is to set the variable `c-style-variables-are-local-p' to `t'
*before* CC Mode is loaded into your Emacs session.

   CC Mode provides several hooks that you can use to customize the
mode according to your coding style.  Each language mode has its own
hook, adhering to standard Emacs major mode conventions.  There is also
one general hook and one package initialization hook:

   * `c-mode-hook' -- for C buffers only

   * `c++-mode-hook' -- for C++ buffers only

   * `objc-mode-hook' -- for Objective-C buffers only

   * `java-mode-hook' -- for Java buffers only

   * `idl-mode-hook' -- for IDL buffers only

   * `c-mode-common-hook' -- common across all languages

   * `c-initialization-hook' -- hook run only once per Emacs session,
     when CC Mode is initialized.


   The language hooks get run as the last thing when you enter that
language mode.  The `c-mode-common-hook' is run by all supported modes
_before_ the language specific hook, and thus can contain
customizations that are common across all languages.  Most of the
examples in this section will assume you are using the common hook(1).

   Here's a simplified example of what you can add to your `.emacs'
file to make the changes described in the previous section (*Note
Interactive Customization::) more permanent.  See the Emacs manuals for
more information on customizing Emacs via hooks.  *Note Sample .emacs
File::, for a more complete sample `.emacs' file.

     (defun my-c-mode-common-hook ()
       ;; my customizations for all of c-mode and related modes
       (c-set-offset 'substatement-open 0)
       ;; other customizations can go here
       )
     (add-hook 'c-mode-common-hook 'my-c-mode-common-hook)

   For complex customizations, you will probably want to set up a
_style_ that groups all your customizations under a single name.

   ---------- Footnotes ----------

   (1) The interaction between `java-mode' and the hook variables is
slightly different than for the other modes.  `java-mode' sets the
style (see *Note Styles::) of the buffer to `java' _before_ running the
`c-mode-common-hook' or `java-mode-hook'.  You need to be aware of this
so that style settings in `c-mode-common-hook' don't clobber your Java
style.


File: ccmode,  Node: Styles,  Next: Advanced Customizations,  Prev: Permanent Customization,  Up: Customizing Indentation

Styles
======

   Most people only need to edit code formatted in just a few
well-defined and consistent styles.  For example, their organization
might impose a "blessed" style that all its programmers must conform
to.  Similarly, people who work on GNU software will have to use the
GNU coding style on C code.  Some shops are more lenient, allowing a
variety of coding styles, and as programmers come and go, there could
be a number of styles in use.  For this reason, CC Mode makes it
convenient for you to set up logical groupings of customizations called
"styles", associate a single name for any particular style, and pretty
easily start editing new or existing code using these styles.

* Menu:

* Built-in Styles::
* Adding Styles::
* File Styles::

