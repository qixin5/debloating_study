/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
typedef __ino_t ino_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef unsigned char char_u;
typedef unsigned long long_u;
enum auto_event {
    EVENT_BUFCREATE = 0,
    EVENT_BUFDELETE = 1,
    EVENT_BUFENTER = 2,
    EVENT_BUFFILEPOST = 3,
    EVENT_BUFFILEPRE = 4,
    EVENT_BUFLEAVE = 5,
    EVENT_BUFNEWFILE = 6,
    EVENT_BUFREADPOST = 7,
    EVENT_BUFREADPRE = 8,
    EVENT_BUFUNLOAD = 9,
    EVENT_BUFHIDDEN = 10,
    EVENT_BUFWRITEPOST = 11,
    EVENT_BUFWRITEPRE = 12,
    EVENT_FILEAPPENDPOST = 13,
    EVENT_FILEAPPENDPRE = 14,
    EVENT_FILECHANGEDSHELL = 15,
    EVENT_FILEREADPOST = 16,
    EVENT_FILEREADPRE = 17,
    EVENT_FILETYPE = 18,
    EVENT_FILEWRITEPOST = 19,
    EVENT_FILEWRITEPRE = 20,
    EVENT_FILTERREADPOST = 21,
    EVENT_FILTERREADPRE = 22,
    EVENT_FILTERWRITEPOST = 23,
    EVENT_FILTERWRITEPRE = 24,
    EVENT_FOCUSGAINED = 25,
    EVENT_FOCUSLOST = 26,
    EVENT_GUIENTER = 27,
    EVENT_STDINREADPOST = 28,
    EVENT_STDINREADPRE = 29,
    EVENT_SYNTAX = 30,
    EVENT_TERMCHANGED = 31,
    EVENT_USER = 32,
    EVENT_VIMENTER = 33,
    EVENT_VIMLEAVE = 34,
    EVENT_VIMLEAVEPRE = 35,
    EVENT_WINENTER = 36,
    EVENT_WINLEAVE = 37,
    EVENT_FILEENCODING = 38,
    EVENT_CURSORHOLD = 39,
    NUM_EVENTS = 40
} ;
typedef enum auto_event EVENT_T;
typedef long linenr_t;
typedef unsigned int colnr_t;
struct __anonstruct_vim_regexp_55 {
   char_u *startp[10] ;
   char_u *endp[10] ;
   char_u regstart ;
   char_u reganch ;
   char_u *regmust ;
   int regmlen ;
   char_u program[1] ;
};
typedef struct __anonstruct_vim_regexp_55 vim_regexp;
struct fpos;
struct fpos;
typedef struct fpos FPOS;
struct fpos {
   linenr_t lnum ;
   colnr_t col ;
};
struct filemark {
   FPOS mark ;
   int fnum ;
};
struct taggy {
   char_u *tagname ;
   struct filemark fmark ;
   int cur_match ;
};
struct window;
struct window;
typedef struct window WIN;
struct winfpos;
struct winfpos;
typedef struct winfpos WINFPOS;
struct winfpos {
   WINFPOS *wl_next ;
   WINFPOS *wl_prev ;
   WIN *wl_win ;
   FPOS wl_fpos ;
};
struct u_entry {
   struct u_entry *ue_next ;
   linenr_t ue_top ;
   linenr_t ue_bot ;
   linenr_t ue_lcount ;
   char_u **ue_array ;
   long ue_size ;
};
struct u_header {
   struct u_header *uh_next ;
   struct u_header *uh_prev ;
   struct u_entry *uh_entry ;
   FPOS uh_cursor ;
   int uh_flags ;
   FPOS uh_namedm[26] ;
};
struct m_info;
struct m_info;
typedef struct m_info info_t;
struct m_info {
   long_u m_size ;
   info_t *m_next ;
};
struct m_block {
   struct m_block *mb_next ;
   info_t mb_info ;
};
struct growarray {
   int ga_len ;
   int ga_room ;
   int ga_itemsize ;
   int ga_growsize ;
   void *ga_data ;
};
struct block_hdr;
struct block_hdr;
typedef struct block_hdr BHDR;
struct memfile;
struct memfile;
typedef struct memfile MEMFILE;
typedef long blocknr_t;
struct block_hdr {
   BHDR *bh_next ;
   BHDR *bh_prev ;
   BHDR *bh_hash_next ;
   BHDR *bh_hash_prev ;
   blocknr_t bh_bnum ;
   char_u *bh_data ;
   int bh_page_count ;
   char bh_flags ;
};
struct nr_trans;
struct nr_trans;
typedef struct nr_trans NR_TRANS;
struct nr_trans {
   NR_TRANS *nt_next ;
   NR_TRANS *nt_prev ;
   blocknr_t nt_old_bnum ;
   blocknr_t nt_new_bnum ;
};
struct memfile {
   char_u *mf_fname ;
   char_u *mf_ffname ;
   int mf_fd ;
   BHDR *mf_free_first ;
   BHDR *mf_used_first ;
   BHDR *mf_used_last ;
   unsigned int mf_used_count ;
   unsigned int mf_used_count_max ;
   BHDR *mf_hash[64] ;
   NR_TRANS *mf_trans[64] ;
   blocknr_t mf_blocknr_max ;
   blocknr_t mf_blocknr_min ;
   blocknr_t mf_neg_count ;
   blocknr_t mf_infile_count ;
   unsigned int mf_page_size ;
   int mf_dirty ;
};
struct info_pointer;
struct info_pointer;
typedef struct info_pointer IPTR;
struct info_pointer {
   blocknr_t ip_bnum ;
   linenr_t ip_low ;
   linenr_t ip_high ;
   int ip_index ;
};
struct ml_chunksize {
   int mlcs_numlines ;
   int mlcs_totalsize ;
};
typedef struct ml_chunksize ML_CHUNKSIZE;
struct memline;
struct memline;
typedef struct memline MEMLINE;
struct memline {
   linenr_t ml_line_count ;
   MEMFILE *ml_mfp ;
   int ml_flags ;
   IPTR *ml_stack ;
   int ml_stack_top ;
   int ml_stack_size ;
   linenr_t ml_line_lnum ;
   char_u *ml_line_ptr ;
   BHDR *ml_locked ;
   linenr_t ml_locked_low ;
   linenr_t ml_locked_high ;
   int ml_locked_lineadd ;
   ML_CHUNKSIZE *ml_chunksize ;
   int ml_numchunks ;
   int ml_usedchunks ;
};
struct keyentry {
   struct keyentry *next ;
   int syn_inc_tag ;
   short syn_id ;
   short *next_list ;
   short flags ;
   char_u keyword[1] ;
};
struct syn_state {
   struct growarray sst_ga ;
   short *sst_next_list ;
   int sst_next_flags ;
};
struct buffer;
struct buffer;
typedef struct buffer BUF;
struct buffer {
   MEMLINE b_ml ;
   BUF *b_next ;
   BUF *b_prev ;
   int b_changed ;
   int b_nwindows ;
   int b_flags ;
   char_u *b_ffname ;
   char_u *b_sfname ;
   char_u *b_fname ;
   int b_dev ;
   ino_t b_ino ;
   int b_fnum ;
   WINFPOS *b_winfpos ;
   long b_mtime ;
   long b_mtime_read ;
   FPOS b_namedm[26] ;
   FPOS b_visual_start ;
   FPOS b_visual_end ;
   int b_visual_mode ;
   FPOS b_last_cursor ;
   char b_chartab[256] ;
   FPOS b_op_start ;
   FPOS b_op_end ;
   int b_marks_read ;
   struct u_header *b_u_oldhead ;
   struct u_header *b_u_newhead ;
   struct u_header *b_u_curhead ;
   int b_u_numhead ;
   int b_u_synced ;
   char_u *b_u_line_ptr ;
   linenr_t b_u_line_lnum ;
   colnr_t b_u_line_colnr ;
   struct m_block b_block_head ;
   info_t *b_m_search ;
   struct m_block *b_mb_current ;
   int b_scanned ;
   int b_p_initialized ;
   int b_p_ai ;
   int b_p_ro ;
   int b_p_lisp ;
   int b_p_inf ;
   char_u *b_p_cpt ;
   int b_p_bin ;
   int b_p_eol ;
   int b_p_et ;
   int b_p_ml ;
   int b_p_tx ;
   int b_p_swf ;
   int b_p_sn ;
   long b_p_sw ;
   long b_p_sts ;
   long b_p_ts ;
   long b_p_tw ;
   long b_p_wm ;
   char_u *b_p_ff ;
   char_u *b_p_fo ;
   char_u *b_p_com ;
   char_u *b_p_isk ;
   char_u *b_p_key ;
   char_u *b_p_nf ;
   char_u *b_p_mps ;
   long b_p_wm_nobin ;
   long b_p_tw_nobin ;
   int b_p_ml_nobin ;
   int b_p_et_nobin ;
   int b_p_ai_save ;
   int b_p_lisp_save ;
   long b_p_tw_save ;
   long b_p_wm_save ;
   long b_p_sts_save ;
   int b_p_si ;
   int b_p_si_save ;
   int b_p_cin ;
   int b_p_cin_save ;
   char_u *b_p_cino ;
   char_u *b_p_cink ;
   char_u *b_p_cinw ;
   char_u *b_p_syn ;
   char_u *b_p_ft ;
   int b_start_ffc ;
   struct growarray b_vars ;
   int b_may_swap ;
   int b_did_warn ;
   int b_help ;
   int b_shortname ;
   struct keyentry **b_keywtab ;
   struct keyentry **b_keywtab_ic ;
   int b_syn_ic ;
   struct growarray b_syn_patterns ;
   struct growarray b_syn_clusters ;
   int b_syn_sync_flags ;
   short b_syn_sync_id ;
   long b_syn_sync_minlines ;
   long b_syn_sync_maxlines ;
   char_u *b_syn_linecont_pat ;
   vim_regexp *b_syn_linecont_prog ;
   int b_syn_linecont_ic ;
   int b_syn_topgrp ;
   struct syn_state *b_syn_states ;
   int b_syn_states_len ;
   linenr_t b_syn_states_lnum ;
   linenr_t b_syn_change_lnum ;
};
struct window {
   BUF *w_buffer ;
   WIN *w_prev ;
   WIN *w_next ;
   FPOS w_cursor ;
   int w_valid ;
   FPOS w_valid_cursor ;
   colnr_t w_valid_leftcol ;
   int w_wrow ;
   int w_wcol ;
   int w_cline_height ;
   int w_cline_row ;
   colnr_t w_virtcol ;
   colnr_t w_curswant ;
   int w_set_curswant ;
   linenr_t w_old_cursor_lnum ;
   colnr_t w_old_cursor_fcol ;
   colnr_t w_old_cursor_lcol ;
   linenr_t w_old_visual_lnum ;
   colnr_t w_old_curswant ;
   linenr_t w_topline ;
   linenr_t w_botline ;
   int w_empty_rows ;
   int w_winpos ;
   int w_height ;
   int w_status_height ;
   int w_redr_status ;
   int w_redr_type ;
   FPOS w_ru_cursor ;
   colnr_t w_ru_virtcol ;
   linenr_t w_ru_topline ;
   char w_ru_empty ;
   colnr_t w_leftcol ;
   colnr_t w_skipcol ;
   int w_lsize_valid ;
   linenr_t *w_lsize_lnum ;
   char_u *w_lsize ;
   int w_alt_fnum ;
   int w_arg_idx ;
   int w_arg_idx_invalid ;
   int w_p_list ;
   int w_p_nu ;
   int w_p_wrap ;
   int w_p_lbr ;
   long w_p_scroll ;
   int w_p_scb ;
   long w_scbind_pos ;
   int w_preview ;
   struct growarray w_vars ;
   FPOS w_pcmark ;
   FPOS w_prev_pcmark ;
   struct filemark w_jumplist[50] ;
   int w_jumplistlen ;
   int w_jumplistidx ;
   struct taggy w_tagstack[20] ;
   int w_tagstackidx ;
   int w_tagstacklen ;
   int w_fraction ;
   int w_prev_fraction_row ;
};
enum hlf_value {
    HLF_8 = 0,
    HLF_AT = 1,
    HLF_D = 2,
    HLF_E = 3,
    HLF_H = 4,
    HLF_I = 5,
    HLF_L = 6,
    HLF_M = 7,
    HLF_CM = 8,
    HLF_N = 9,
    HLF_R = 10,
    HLF_S = 11,
    HLF_SNC = 12,
    HLF_T = 13,
    HLF_V = 14,
    HLF_VNC = 15,
    HLF_W = 16,
    HLF_WM = 17,
    HLF_COUNT = 18
} ;
struct oparg {
   int op_type ;
   int regname ;
   int motion_type ;
   int inclusive ;
   int end_adjusted ;
   FPOS start ;
   FPOS end ;
   long line_count ;
   int empty ;
   int is_VIsual ;
   int block_mode ;
   colnr_t start_vcol ;
   colnr_t end_vcol ;
};
typedef struct oparg OPARG;
struct Completion {
   struct Completion *next ;
   struct Completion *prev ;
   char_u *str ;
   char_u *fname ;
   int original ;
};
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
enum CMD_index {
    CMD_append = 0,
    CMD_abbreviate = 1,
    CMD_abclear = 2,
    CMD_all = 3,
    CMD_amenu = 4,
    CMD_anoremenu = 5,
    CMD_args = 6,
    CMD_argument = 7,
    CMD_ascii = 8,
    CMD_autocmd = 9,
    CMD_augroup = 10,
    CMD_aunmenu = 11,
    CMD_buffer = 12,
    CMD_bNext = 13,
    CMD_ball = 14,
    CMD_badd = 15,
    CMD_bdelete = 16,
    CMD_behave = 17,
    CMD_blast = 18,
    CMD_bmodified = 19,
    CMD_bnext = 20,
    CMD_bprevious = 21,
    CMD_brewind = 22,
    CMD_break = 23,
    CMD_browse = 24,
    CMD_buffers = 25,
    CMD_bunload = 26,
    CMD_change = 27,
    CMD_cNext = 28,
    CMD_cabbrev = 29,
    CMD_cabclear = 30,
    CMD_call = 31,
    CMD_cc = 32,
    CMD_cd = 33,
    CMD_center = 34,
    CMD_cfile = 35,
    CMD_chdir = 36,
    CMD_checkpath = 37,
    CMD_clist = 38,
    CMD_clast = 39,
    CMD_close = 40,
    CMD_cmap = 41,
    CMD_cmapclear = 42,
    CMD_cmenu = 43,
    CMD_cnext = 44,
    CMD_cnewer = 45,
    CMD_cnfile = 46,
    CMD_cnoremap = 47,
    CMD_cnoreabbrev = 48,
    CMD_cnoremenu = 49,
    CMD_copy = 50,
    CMD_colder = 51,
    CMD_command = 52,
    CMD_comclear = 53,
    CMD_continue = 54,
    CMD_confirm = 55,
    CMD_cprevious = 56,
    CMD_cquit = 57,
    CMD_crewind = 58,
    CMD_cscope = 59,
    CMD_cstag = 60,
    CMD_cunmap = 61,
    CMD_cunabbrev = 62,
    CMD_cunmenu = 63,
    CMD_delete = 64,
    CMD_delcommand = 65,
    CMD_delfunction = 66,
    CMD_display = 67,
    CMD_digraphs = 68,
    CMD_djump = 69,
    CMD_dlist = 70,
    CMD_doautocmd = 71,
    CMD_doautoall = 72,
    CMD_dsearch = 73,
    CMD_dsplit = 74,
    CMD_edit = 75,
    CMD_echo = 76,
    CMD_echohl = 77,
    CMD_echon = 78,
    CMD_else = 79,
    CMD_elseif = 80,
    CMD_exemenu = 81,
    CMD_endif = 82,
    CMD_endfunction = 83,
    CMD_endwhile = 84,
    CMD_ex = 85,
    CMD_execute = 86,
    CMD_exit = 87,
    CMD_file = 88,
    CMD_files = 89,
    CMD_filetype = 90,
    CMD_find = 91,
    CMD_fixdel = 92,
    CMD_function = 93,
    CMD_global = 94,
    CMD_goto = 95,
    CMD_grep = 96,
    CMD_gui = 97,
    CMD_gvim = 98,
    CMD_help = 99,
    CMD_helpfind = 100,
    CMD_highlight = 101,
    CMD_hide = 102,
    CMD_history = 103,
    CMD_insert = 104,
    CMD_iabbrev = 105,
    CMD_iabclear = 106,
    CMD_if = 107,
    CMD_ijump = 108,
    CMD_ilist = 109,
    CMD_imap = 110,
    CMD_imapclear = 111,
    CMD_imenu = 112,
    CMD_inoremap = 113,
    CMD_inoreabbrev = 114,
    CMD_inoremenu = 115,
    CMD_intro = 116,
    CMD_isearch = 117,
    CMD_isplit = 118,
    CMD_iunmap = 119,
    CMD_iunabbrev = 120,
    CMD_iunmenu = 121,
    CMD_join = 122,
    CMD_jumps = 123,
    CMD_k = 124,
    CMD_list = 125,
    CMD_last = 126,
    CMD_left = 127,
    CMD_let = 128,
    CMD_ls = 129,
    CMD_move = 130,
    CMD_mark = 131,
    CMD_make = 132,
    CMD_map = 133,
    CMD_mapclear = 134,
    CMD_marks = 135,
    CMD_menu = 136,
    CMD_messages = 137,
    CMD_mkexrc = 138,
    CMD_mksession = 139,
    CMD_mkvimrc = 140,
    CMD_mode = 141,
    CMD_next = 142,
    CMD_new = 143,
    CMD_nmap = 144,
    CMD_nmapclear = 145,
    CMD_nmenu = 146,
    CMD_nnoremap = 147,
    CMD_nnoremenu = 148,
    CMD_noremap = 149,
    CMD_nohlsearch = 150,
    CMD_noreabbrev = 151,
    CMD_noremenu = 152,
    CMD_normal = 153,
    CMD_number = 154,
    CMD_nunmap = 155,
    CMD_nunmenu = 156,
    CMD_open = 157,
    CMD_omap = 158,
    CMD_omapclear = 159,
    CMD_omenu = 160,
    CMD_only = 161,
    CMD_onoremap = 162,
    CMD_onoremenu = 163,
    CMD_options = 164,
    CMD_ounmap = 165,
    CMD_ounmenu = 166,
    CMD_print = 167,
    CMD_pclose = 168,
    CMD_perl = 169,
    CMD_perldo = 170,
    CMD_pop = 171,
    CMD_ppop = 172,
    CMD_preserve = 173,
    CMD_previous = 174,
    CMD_promptfind = 175,
    CMD_promptrepl = 176,
    CMD_ptag = 177,
    CMD_ptNext = 178,
    CMD_ptjump = 179,
    CMD_ptlast = 180,
    CMD_ptnext = 181,
    CMD_ptprevious = 182,
    CMD_ptrewind = 183,
    CMD_ptselect = 184,
    CMD_put = 185,
    CMD_pwd = 186,
    CMD_python = 187,
    CMD_pyfile = 188,
    CMD_quit = 189,
    CMD_qall = 190,
    CMD_read = 191,
    CMD_recover = 192,
    CMD_redo = 193,
    CMD_redir = 194,
    CMD_registers = 195,
    CMD_resize = 196,
    CMD_retab = 197,
    CMD_return = 198,
    CMD_rewind = 199,
    CMD_right = 200,
    CMD_rviminfo = 201,
    CMD_substitute = 202,
    CMD_sNext = 203,
    CMD_sargument = 204,
    CMD_sall = 205,
    CMD_sbuffer = 206,
    CMD_sbNext = 207,
    CMD_sball = 208,
    CMD_sblast = 209,
    CMD_sbmodified = 210,
    CMD_sbnext = 211,
    CMD_sbprevious = 212,
    CMD_sbrewind = 213,
    CMD_set = 214,
    CMD_sfind = 215,
    CMD_shell = 216,
    CMD_sleep = 217,
    CMD_slast = 218,
    CMD_smagic = 219,
    CMD_snext = 220,
    CMD_sniff = 221,
    CMD_snomagic = 222,
    CMD_source = 223,
    CMD_split = 224,
    CMD_sprevious = 225,
    CMD_srewind = 226,
    CMD_stop = 227,
    CMD_stag = 228,
    CMD_startinsert = 229,
    CMD_stjump = 230,
    CMD_stselect = 231,
    CMD_sunhide = 232,
    CMD_suspend = 233,
    CMD_sview = 234,
    CMD_swapname = 235,
    CMD_syntax = 236,
    CMD_syncbind = 237,
    CMD_t = 238,
    CMD_tNext = 239,
    CMD_tag = 240,
    CMD_tags = 241,
    CMD_tcl = 242,
    CMD_tcldo = 243,
    CMD_tclfile = 244,
    CMD_tearoff = 245,
    CMD_tjump = 246,
    CMD_tlast = 247,
    CMD_tmenu = 248,
    CMD_tnext = 249,
    CMD_tprevious = 250,
    CMD_trewind = 251,
    CMD_tselect = 252,
    CMD_tunmenu = 253,
    CMD_undo = 254,
    CMD_unabbreviate = 255,
    CMD_unhide = 256,
    CMD_unlet = 257,
    CMD_unmap = 258,
    CMD_unmenu = 259,
    CMD_update = 260,
    CMD_vglobal = 261,
    CMD_version = 262,
    CMD_visual = 263,
    CMD_view = 264,
    CMD_vmap = 265,
    CMD_vmapclear = 266,
    CMD_vmenu = 267,
    CMD_vnoremap = 268,
    CMD_vnoremenu = 269,
    CMD_vunmap = 270,
    CMD_vunmenu = 271,
    CMD_write = 272,
    CMD_wNext = 273,
    CMD_wall = 274,
    CMD_while = 275,
    CMD_winsize = 276,
    CMD_winpos = 277,
    CMD_wnext = 278,
    CMD_wprevious = 279,
    CMD_wq = 280,
    CMD_wqall = 281,
    CMD_wviminfo = 282,
    CMD_xit = 283,
    CMD_xall = 284,
    CMD_yank = 285,
    CMD_z = 286,
    CMD_bang = 287,
    CMD_pound = 288,
    CMD_and = 289,
    CMD_star = 290,
    CMD_lshift = 291,
    CMD_equal = 292,
    CMD_rshift = 293,
    CMD_at = 294,
    CMD_Next = 295,
    CMD_Print = 296,
    CMD_X = 297,
    CMD_tilde = 298,
    CMD_SIZE = 299,
    CMD_USER = -1
} ;
typedef enum CMD_index CMDIDX;
struct exarg {
   char_u *arg ;
   char_u *nextcmd ;
   char_u *cmd ;
   CMDIDX cmdidx ;
   long argt ;
   int skip ;
   int forceit ;
   int addr_count ;
   linenr_t line1 ;
   linenr_t line2 ;
   char_u *do_ecmd_cmd ;
   linenr_t do_ecmd_lnum ;
   int append ;
   int usefilter ;
   int amount ;
   int regname ;
   int useridx ;
};
typedef struct exarg EXARG;
typedef int var_number_type;
union __anonunion_var_val_170 {
   var_number_type var_number ;
   char_u *var_string ;
};
struct __anonstruct_var_169 {
   char_u *var_name ;
   char var_type ;
   union __anonunion_var_val_170 var_val ;
};
typedef struct __anonstruct_var_169 var;
typedef var *VAR;
struct ufunc {
   struct ufunc *next ;
   char_u *name ;
   int varargs ;
   int flags ;
   int calls ;
   struct growarray args ;
   struct growarray lines ;
};
struct funccall {
   struct ufunc *func ;
   int linenr ;
   int argcount ;
   VAR argvars ;
   var a0_var ;
   var firstline ;
   var lastline ;
   struct growarray l_vars ;
   VAR retvar ;
};
struct vimvar {
   char *name ;
   int len ;
   char_u *val ;
   char type ;
   char flags ;
};
enum exp_type {
    TYPE_UNKNOWN = 0,
    TYPE_EQUAL = 1,
    TYPE_NEQUAL = 2,
    TYPE_GREATER = 3,
    TYPE_GEQUAL = 4,
    TYPE_SMALLER = 5,
    TYPE_SEQUAL = 6,
    TYPE_MATCH = 7,
    TYPE_NOMATCH = 8
} ;
struct fst {
   char *f_name ;
   char f_min_argc ;
   char f_max_argc ;
   void (*f_func)(VAR args , VAR rvar ) ;
};
enum __anonenum_VAR_FLAVOUR_171 {
    VAR_FLAVOUR_DEFAULT = 0,
    VAR_FLAVOUR_SESSION = 1,
    VAR_FLAVOUR_VIMINFO = 2
} ;
typedef enum __anonenum_VAR_FLAVOUR_171 VAR_FLAVOUR;
typedef __mode_t mode_t;
struct cmdname {
   char_u *cmd_name ;
   long_u cmd_argt ;
};
struct condstack {
   char cs_flags[50] ;
   int cs_line[50] ;
   int cs_idx ;
   int cs_whilelevel ;
   char cs_had_while ;
   char cs_had_continue ;
   char cs_had_endwhile ;
};
struct ucmd {
   char_u *uc_name ;
   long uc_argt ;
   char_u *uc_rep ;
   long uc_def ;
   int uc_compl ;
};
typedef struct ucmd UCMD;
struct source_cookie {
   FILE *fp ;
   char_u *nextline ;
};
enum __anonenum_type_169 {
    ct_ARGS = 0,
    ct_BANG = 1,
    ct_COUNT = 2,
    ct_LINE1 = 3,
    ct_LINE2 = 4,
    ct_REGISTER = 5,
    ct_LT = 6,
    ct_NONE = 7
} ;
struct cmdline_info {
   char_u *cmdbuff ;
   int cmdbufflen ;
   int cmdlen ;
   int cmdpos ;
   int cmdspos ;
   int cmdfirstc ;
   int cmdindent ;
   char_u *cmdprompt ;
   int cmdattr ;
   int overstrike ;
};
struct hist_entry {
   int hisnum ;
   char_u *hisstr ;
};
typedef long __ssize_t;
typedef __ssize_t ssize_t;
typedef __uid_t uid_t;
struct aco_save {
   WIN *save_curwin ;
   BUF *save_buf ;
   FPOS save_cursor ;
   linenr_t save_topline ;
};
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
struct AutoCmd {
   char_u *cmd ;
   char nested ;
   char last ;
   struct AutoCmd *next ;
};
typedef struct AutoCmd AutoCmd;
struct AutoPat {
   int group ;
   char_u *pat ;
   int patlen ;
   char_u *reg_pat ;
   char allow_dirs ;
   char last ;
   AutoCmd *cmds ;
   struct AutoPat *next ;
};
typedef struct AutoPat AutoPat;
struct event_name {
   char *name ;
   EVENT_T event ;
};
struct AutoPatCmd {
   AutoPat *curpat ;
   AutoCmd *nextcmd ;
   int group ;
   char_u *fname ;
   char_u *sfname ;
   char_u *tail ;
   EVENT_T event ;
};
typedef struct AutoPatCmd AutoPatCmd;
struct bufblock {
   struct bufblock *b_next ;
   char_u b_str[1] ;
};
struct buffheader {
   struct bufblock bh_first ;
   struct bufblock *bh_curr ;
   int bh_index ;
   int bh_space ;
};
struct mapblock {
   struct mapblock *m_next ;
   char_u *m_keys ;
   int m_keylen ;
   char_u *m_str ;
   int m_mode ;
   int m_noremap ;
};
struct initmap {
   char_u *arg ;
   int mode ;
};
typedef unsigned short short_u;
typedef unsigned long Atom;
struct _XDisplay;
struct _XDisplay;
typedef struct _XDisplay Display;
struct _XtAppStruct;
struct _XtAppStruct;
typedef struct _XtAppStruct *XtAppContext;
struct VimMenu {
   int modes ;
   char_u *name ;
   char_u *dname ;
   int mnemonic ;
   char_u *actext ;
   int priority ;
   char_u *strings[6] ;
   int noremap[6] ;
   struct VimMenu *children ;
   struct VimMenu *next ;
};
typedef struct VimMenu VimMenu;
struct VimClipboard {
   int available ;
   int owned ;
   FPOS start ;
   FPOS end ;
   int vmode ;
   short_u origin_row ;
   short_u origin_start_col ;
   short_u origin_end_col ;
   short_u word_start_col ;
   short_u word_end_col ;
   FPOS prev ;
   short_u state ;
   short_u mode ;
   Atom xatom ;
   Atom xa_targets ;
   Atom xa_text ;
   Atom xa_compound_text ;
};
typedef struct VimClipboard VimClipboard;
typedef __off_t off_t;
typedef int __pid_t;
typedef __pid_t pid_t;
struct block0;
struct block0;
typedef struct block0 ZERO_BL;
struct pointer_block;
struct pointer_block;
typedef struct pointer_block PTR_BL;
struct data_block;
struct data_block;
typedef struct data_block DATA_BL;
struct pointer_entry;
struct pointer_entry;
typedef struct pointer_entry PTR_EN;
struct pointer_entry {
   blocknr_t pe_bnum ;
   linenr_t pe_line_count ;
   linenr_t pe_old_lnum ;
   int pe_page_count ;
};
struct pointer_block {
   short_u pb_id ;
   short_u pb_count ;
   short_u pb_count_max ;
   PTR_EN pb_pointer[1] ;
};
struct data_block {
   short_u db_id ;
   unsigned int db_free ;
   unsigned int db_txt_start ;
   unsigned int db_txt_end ;
   linenr_t db_line_count ;
   unsigned int db_index[1] ;
};
struct block0 {
   char_u b0_id[2] ;
   char_u b0_version[10] ;
   char_u b0_page_size[4] ;
   char_u b0_mtime[4] ;
   char_u b0_ino[4] ;
   char_u b0_pid[4] ;
   char_u b0_uname[40] ;
   char_u b0_hname[40] ;
   char_u b0_fname[900] ;
   long b0_magic_long ;
   int b0_magic_int ;
   short b0_magic_short ;
   char_u b0_magic_char ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct msg_hist {
   struct msg_hist *next ;
   char_u *msg ;
   int attr ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct modmasktable {
   int mod_mask ;
   char_u name ;
};
struct key_name_entry {
   int key ;
   char_u *name ;
};
struct mousetable {
   int pseudo_code ;
   int button ;
   int is_click ;
   int is_drag ;
};
typedef unsigned short ush;
typedef unsigned long ulg;
struct cmdarg {
   OPARG *oap ;
   int prechar ;
   int cmdchar ;
   int nchar ;
   int extra_char ;
   long count0 ;
   long count1 ;
};
typedef struct cmdarg CMDARG;
typedef unsigned int int_u;
struct yankreg {
   char_u **y_array ;
   linenr_t y_size ;
   char_u y_type ;
};
struct block_def {
   int startspaces ;
   int endspaces ;
   int textlen ;
   char_u *textstart ;
   colnr_t textcol ;
   colnr_t start_vcol ;
   colnr_t end_vcol ;
   int is_short ;
   int is_MAX ;
   int is_EOL ;
   int is_oneChar ;
   int pre_whitesp ;
   int pre_whitesp_c ;
   colnr_t end_char_vcols ;
   colnr_t start_char_vcols ;
};
struct vimoption {
   char *fullname ;
   char *shortname ;
   short_u flags ;
   char_u *var ;
   char_u *def_val[2] ;
};
struct lcstab {
   int *lcsp ;
   char *name ;
};
typedef long __suseconds_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_8 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_8 fd_set;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
struct __dirstream;
typedef struct __dirstream DIR;
typedef unsigned long XID;
typedef unsigned long VisualID;
typedef XID Window;
typedef XID Colormap;
typedef char *XPointer;
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
typedef struct _XExtData XExtData;
struct _XGC;
struct _XGC;
typedef struct _XGC *GC;
struct __anonstruct_Visual_60 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
typedef struct __anonstruct_Visual_60 Visual;
struct __anonstruct_Depth_61 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
typedef struct __anonstruct_Depth_61 Depth;
struct __anonstruct_Screen_62 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
typedef struct __anonstruct_Screen_62 Screen;
struct __anonstruct_ScreenFormat_63 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
typedef struct __anonstruct_ScreenFormat_63 ScreenFormat;
struct _XPrivate;
struct _XPrivate;
struct _XrmHashBucketRec;
struct _XrmHashBucketRec;
struct __anonstruct__XPrivDisplay_78 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
typedef struct __anonstruct__XPrivDisplay_78 *_XPrivDisplay;
struct __anonstruct_XErrorEvent_109 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
typedef struct __anonstruct_XErrorEvent_109 XErrorEvent;
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
struct __anonstruct_min_aspect_138 {
   int x ;
   int y ;
};
struct __anonstruct_XSizeHints_137 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_138 min_aspect ;
   struct __anonstruct_min_aspect_138 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
typedef struct __anonstruct_XSizeHints_137 XSizeHints;
struct __anonstruct_XTextProperty_140 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
typedef struct __anonstruct_XTextProperty_140 XTextProperty;
enum __anonenum_XrmOptionKind_148 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
typedef enum __anonenum_XrmOptionKind_148 XrmOptionKind;
struct __anonstruct_XrmOptionDescRec_149 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
typedef struct __anonstruct_XrmOptionDescRec_149 XrmOptionDescRec;
struct _WidgetRec;
struct _WidgetRec;
typedef struct _WidgetRec *Widget;
struct _WidgetClassRec;
struct _WidgetClassRec;
typedef struct _WidgetClassRec *WidgetClass;
typedef unsigned int Cardinal;
typedef unsigned long XtInputMask;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct signalinfo {
   int sig ;
   char *name ;
   char deadly ;
};
struct dir_stack_t {
   struct dir_stack_t *next ;
   char_u *dirname ;
};
struct qf_line {
   struct qf_line *qf_next ;
   struct qf_line *qf_prev ;
   linenr_t qf_lnum ;
   int qf_fnum ;
   int qf_col ;
   int qf_nr ;
   char_u *qf_text ;
   char_u qf_cleared ;
   char_u qf_type ;
   char_u qf_valid ;
};
struct qf_list {
   struct qf_line *qf_start ;
   struct qf_line *qf_ptr ;
   int qf_count ;
   int qf_index ;
   int qf_nonevalid ;
};
struct eformat {
   vim_regexp *prog ;
   struct eformat *next ;
   char_u addr[7] ;
   char_u prefix ;
   char_u flags ;
};
struct fmtpattern {
   char_u convchar ;
   char *pattern ;
};
struct __anonstruct_namedata_t_169 {
   size_t len ;
   int (*func)(int  ) ;
   char_u name[sizeof("backspace:]")] ;
};
typedef struct __anonstruct_namedata_t_169 namedata_t;
typedef void (*(*fptr)(char_u * , int  ))();
struct __anonstruct_term_167 {
   char_u *start ;
   char_u *stop ;
};
struct __anonstruct_cterm_168 {
   char_u fg_color ;
   char_u bg_color ;
};
union __anonunion_ae_u_166 {
   struct __anonstruct_term_167 term ;
   struct __anonstruct_cterm_168 cterm ;
};
struct attr_entry {
   short ae_attr ;
   union __anonunion_ae_u_166 ae_u ;
};
struct stl_hlrec {
   char_u *start ;
   int userhl ;
};
enum __anonenum_type_169___0 {
    Normal = 0,
    Empty = 1,
    Group = 2,
    Middle = 3,
    Highlight = 4,
    Trunc = 5
} ;
struct stl_item {
   char_u *start ;
   int minwid ;
   int maxwid ;
   enum __anonenum_type_169___0 type ;
};
struct soffset {
   int dir ;
   int line ;
   int end ;
   long off ;
};
struct spat {
   char_u *pat ;
   int magic ;
   int no_scs ;
   struct soffset off ;
};
struct SearchedFile {
   FILE *fp ;
   char_u *name ;
   linenr_t lnum ;
   int matched ;
};
typedef struct SearchedFile SearchedFile;
struct hl_group {
   char_u *sg_name ;
   char_u *sg_name_u ;
   int sg_term ;
   char_u *sg_start ;
   char_u *sg_stop ;
   int sg_term_attr ;
   int sg_cterm ;
   int sg_cterm_bold ;
   int sg_cterm_fg ;
   int sg_cterm_bg ;
   int sg_cterm_attr ;
   int sg_link ;
   int sg_set ;
};
struct syn_pattern {
   char sp_type ;
   char sp_syncing ;
   short sp_flags ;
   int sp_syn_inc_tag ;
   short sp_syn_id ;
   short sp_syn_match_id ;
   char_u *sp_pattern ;
   vim_regexp *sp_prog ;
   int sp_ic ;
   short sp_off_flags ;
   int sp_offsets[7] ;
   short *sp_cont_list ;
   short *sp_next_list ;
   int sp_sync_idx ;
   int sp_line_id ;
   int sp_startcol ;
};
struct buf_state {
   int bs_idx ;
   int bs_flags ;
};
struct syn_cluster {
   char_u *scl_name ;
   char_u *scl_name_u ;
   short *scl_list ;
};
struct state_item {
   int si_idx ;
   int si_id ;
   int si_trans_id ;
   int si_m_lnum ;
   int si_m_startcol ;
   int si_m_endcol ;
   int si_h_startcol ;
   int si_h_endcol ;
   int si_eoe_col ;
   int si_end_idx ;
   int si_ends ;
   int si_attr ;
   int si_flags ;
   short *si_cont_list ;
   short *si_next_list ;
};
struct flag {
   char *name ;
   int len ;
   int val ;
};
struct pat_ptr {
   struct syn_pattern *pp_synp ;
   int pp_matchgroup_id ;
   struct pat_ptr *pp_next ;
};
struct subcommand {
   char *name ;
   void (*func)(EXARG * , int  ) ;
};
enum __anonenum_expand_what_169 {
    EXP_SUBCMD = 0,
    EXP_CASE = 1
} ;
struct tag_pointers {
   char_u *tagname ;
   char_u *tagname_end ;
   char_u *fname ;
   char_u *fname_end ;
   char_u *command ;
   char_u *command_end ;
   char_u *tag_fname ;
   char_u *tagkind ;
   char_u *tagkind_end ;
};
struct tag_search_info {
   off_t low_offset ;
   off_t high_offset ;
   off_t curr_offset ;
   off_t match_offset ;
   int low_char ;
   int high_char ;
};
enum __anonenum_state_169 {
    TS_START = 0,
    TS_LINEAR = 1,
    TS_BINARY = 2,
    TS_SKIP_BACK = 3,
    TS_STEP_FORWARD = 4
} ;
struct visited {
   struct visited *v_next ;
   struct stat v_st ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
enum SpecialKey {
    KS_NAME = 0,
    KS_CE = 1,
    KS_AL = 2,
    KS_CAL = 3,
    KS_DL = 4,
    KS_CDL = 5,
    KS_CS = 6,
    KS_CL = 7,
    KS_CD = 8,
    KS_DA = 9,
    KS_DB = 10,
    KS_VI = 11,
    KS_VE = 12,
    KS_VS = 13,
    KS_ME = 14,
    KS_MR = 15,
    KS_MD = 16,
    KS_SE = 17,
    KS_SO = 18,
    KS_CZH = 19,
    KS_CZR = 20,
    KS_UE = 21,
    KS_US = 22,
    KS_MS = 23,
    KS_CM = 24,
    KS_SR = 25,
    KS_CRI = 26,
    KS_VB = 27,
    KS_KS = 28,
    KS_KE = 29,
    KS_TI = 30,
    KS_TE = 31,
    KS_BC = 32,
    KS_CCS = 33,
    KS_CCO = 34,
    KS_CSF = 35,
    KS_CSB = 36,
    KS_XS = 37,
    KS_MB = 38,
    KS_CAF = 39,
    KS_CAB = 40,
    KS_LE = 41,
    KS_ND = 42,
    KS_CIS = 43,
    KS_CIE = 44,
    KS_TS = 45,
    KS_FS = 46,
    KS_CWP = 47,
    KS_CWS = 48,
    KS_CRV = 49,
    KS_OP = 50
} ;
struct builtin_term {
   int bt_entry ;
   char *bt_string ;
};
struct __anonstruct_string_names_169 {
   enum SpecialKey dest ;
   char *name ;
};
struct termcode {
   char_u name[2] ;
   char_u *code ;
   int len ;
};
typedef unsigned long Time;
typedef XID Drawable;
struct __anonstruct_XKeyEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
typedef struct __anonstruct_XKeyEvent_79 XKeyEvent;
struct __anonstruct_XButtonEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
typedef struct __anonstruct_XButtonEvent_80 XButtonEvent;
struct __anonstruct_XMotionEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
typedef struct __anonstruct_XMotionEvent_81 XMotionEvent;
struct __anonstruct_XCrossingEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
typedef struct __anonstruct_XCrossingEvent_82 XCrossingEvent;
struct __anonstruct_XFocusChangeEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
typedef struct __anonstruct_XFocusChangeEvent_83 XFocusChangeEvent;
struct __anonstruct_XKeymapEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
typedef struct __anonstruct_XKeymapEvent_84 XKeymapEvent;
struct __anonstruct_XExposeEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
typedef struct __anonstruct_XExposeEvent_85 XExposeEvent;
struct __anonstruct_XGraphicsExposeEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
typedef struct __anonstruct_XGraphicsExposeEvent_86 XGraphicsExposeEvent;
struct __anonstruct_XNoExposeEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
typedef struct __anonstruct_XNoExposeEvent_87 XNoExposeEvent;
struct __anonstruct_XVisibilityEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
typedef struct __anonstruct_XVisibilityEvent_88 XVisibilityEvent;
struct __anonstruct_XCreateWindowEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
typedef struct __anonstruct_XCreateWindowEvent_89 XCreateWindowEvent;
struct __anonstruct_XDestroyWindowEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
typedef struct __anonstruct_XDestroyWindowEvent_90 XDestroyWindowEvent;
struct __anonstruct_XUnmapEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
typedef struct __anonstruct_XUnmapEvent_91 XUnmapEvent;
struct __anonstruct_XMapEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
typedef struct __anonstruct_XMapEvent_92 XMapEvent;
struct __anonstruct_XMapRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
typedef struct __anonstruct_XMapRequestEvent_93 XMapRequestEvent;
struct __anonstruct_XReparentEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
typedef struct __anonstruct_XReparentEvent_94 XReparentEvent;
struct __anonstruct_XConfigureEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
typedef struct __anonstruct_XConfigureEvent_95 XConfigureEvent;
struct __anonstruct_XGravityEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
typedef struct __anonstruct_XGravityEvent_96 XGravityEvent;
struct __anonstruct_XResizeRequestEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
typedef struct __anonstruct_XResizeRequestEvent_97 XResizeRequestEvent;
struct __anonstruct_XConfigureRequestEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
typedef struct __anonstruct_XConfigureRequestEvent_98 XConfigureRequestEvent;
struct __anonstruct_XCirculateEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
typedef struct __anonstruct_XCirculateEvent_99 XCirculateEvent;
struct __anonstruct_XCirculateRequestEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
typedef struct __anonstruct_XCirculateRequestEvent_100 XCirculateRequestEvent;
struct __anonstruct_XPropertyEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
typedef struct __anonstruct_XPropertyEvent_101 XPropertyEvent;
struct __anonstruct_XSelectionClearEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
typedef struct __anonstruct_XSelectionClearEvent_102 XSelectionClearEvent;
struct __anonstruct_XSelectionRequestEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
typedef struct __anonstruct_XSelectionRequestEvent_103 XSelectionRequestEvent;
struct __anonstruct_XSelectionEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
typedef struct __anonstruct_XSelectionEvent_104 XSelectionEvent;
struct __anonstruct_XColormapEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
typedef struct __anonstruct_XColormapEvent_105 XColormapEvent;
union __anonunion_data_107 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
struct __anonstruct_XClientMessageEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_107 data ;
};
typedef struct __anonstruct_XClientMessageEvent_106 XClientMessageEvent;
struct __anonstruct_XMappingEvent_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
typedef struct __anonstruct_XMappingEvent_108 XMappingEvent;
struct __anonstruct_XAnyEvent_110 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
typedef struct __anonstruct_XAnyEvent_110 XAnyEvent;
struct __anonstruct_XGenericEvent_111 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
typedef struct __anonstruct_XGenericEvent_111 XGenericEvent;
struct __anonstruct_XGenericEventCookie_112 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
typedef struct __anonstruct_XGenericEventCookie_112 XGenericEventCookie;
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
typedef union _XEvent XEvent;
enum __anonenum_XICCEncodingStyle_141 {
    XStringStyle = 0,
    XCompoundTextStyle = 1,
    XTextStyle = 2,
    XStdICCTextStyle = 3,
    XUTF8StringStyle = 4
} ;
typedef enum __anonenum_XICCEncodingStyle_141 XICCEncodingStyle;
typedef char Boolean;
typedef void *XtPointer;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-iFTblII1.i","-O0")
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
long Columns ;
int cmdline_row  ;
int msg_row  ;
int need_fileinfo ;
int msg_scroll ;
char_u *sourcing_name ;
linenr_t sourcing_lnum ;
int autocmd_no_enter ;
int autocmd_no_leave ;
int modified_was_set  ;
BUF *au_new_curbuf ;
WIN *firstwin  ;
WIN *lastwin  ;
WIN *curwin  ;
BUF *firstbuf ;
BUF *lastbuf ;
BUF *curbuf ;
char_u **arg_files  ;
int arg_file_count  ;
int arg_had_last ;
int swap_exists_action ;
char_u *IObuff  ;
char_u *NameBuff  ;
int RedrawingDisabled ;
int readonlymode ;
int got_int ;
int reg_ic ;
char_u no_lines_msg[23] ;
int stl_syntax ;
char_u e_noalt[18] ;
char_u e_nowrtmsg[47] ;
char_u e_trailing[20] ;
int p_ea  ;
int p_hid  ;
int p_icon  ;
char_u *p_iconstring  ;
int p_magic  ;
long p_mls  ;
int p_ru  ;
int p_sb  ;
int p_sol  ;
char_u *p_swb  ;
int p_title  ;
long p_titlelen  ;
char_u *p_titlestring  ;
void mch_settitle(char_u *title , char_u *icon ) ;
int mch_dirname(char_u *buf___3 , int len___0 ) ;
int open_buffer(int read_stdin ) ;
int buf_valid(BUF *buf___3 ) ;
void close_buffer(WIN *win , BUF *buf___3 , int free_buf , int del_buf ) ;
void buf_clear(BUF *buf___3 ) ;
void buf_freeall(BUF *buf___3 , int del_buf ) ;
char_u *do_bufdel(int command , char_u *arg , int addr_count , int start_bnr , int end_bnr ,
                  int forceit ) ;
int do_buffer(int action , int start___0 , int dir , int count___2 , int forceit ) ;
void enter_buffer(BUF *buf___3 ) ;
BUF *buflist_new(char_u *ffname , char_u *sfname , linenr_t lnum , int use_curbuf ) ;
void free_buf_options(BUF *buf___3 , int free_p_ff ) ;
int buflist_getfile(int n , linenr_t lnum , int options___0 , int forceit ) ;
void buflist_getfpos(void) ;
BUF *buflist_findname(char_u *ffname ) ;
int buflist_findpat(char_u *pattern , char_u *pattern_end ) ;
int ExpandBufnames(char_u *pat , int *num_file , char_u ***file , int options___0 ) ;
BUF *buflist_findnr(int nr ) ;
char_u *buflist_nr2name(int n , int fullname , int helptail ) ;
FPOS *buflist_findfpos(BUF *buf___3 ) ;
linenr_t buflist_findlnum(BUF *buf___3 ) ;
void buflist_list(void) ;
int buflist_name_nr(int fnum , char_u **fname , linenr_t *lnum ) ;
int setfname(char_u *ffname , char_u *sfname , int message ) ;
void setaltfname(char_u *ffname , char_u *sfname , linenr_t lnum ) ;
char_u *getaltfname(int errmsg ) ;
int buflist_add(char_u *fname ) ;
void buflist_altfpos(void) ;
int otherfile(char_u *ffname ) ;
void fileinfo(int fullname , int shorthelp , int dont_truncate ) ;
void cursor_pos_info(void) ;
void col_print(char_u *buf___3 , int col , int vcol ) ;
void maketitle(void) ;
void resettitle(void) ;
int append_arg_number(WIN *wp , char_u *buf___3 , int add_file , int maxlen ) ;
char_u *fix_fname(char_u *fname ) ;
void fname_expand(char_u **ffname , char_u **sfname ) ;
void do_arg_all(int count___2 , int forceit ) ;
void do_buffer_all(int count___2 , int all ) ;
void do_modelines(void) ;
int read_viminfo_bufferlist(char_u *line , FILE *fp___0 , int writing ) ;
void write_viminfo_bufferlist(FILE *fp___0 ) ;
int init_chartab(void) ;
char_u *transchar(int c ) ;
int vim_strsize(char_u *s ) ;
int linetabsize(char_u *s ) ;
char_u *skipwhite(char_u *p___0 ) ;
char_u *skiptowhite_esc(char_u *p___0 ) ;
long getdigits(char_u **pp ) ;
void var_init(struct growarray *gap ) ;
void var_clear(struct growarray *gap ) ;
char_u *viminfo_readstring(char_u *p___0 , FILE *fp___0 ) ;
void viminfo_writestring(FILE *fd , char_u *p___0 ) ;
int getfile(int fnum , char_u *ffname , char_u *sfname , int setpm , linenr_t lnum ,
            int forceit ) ;
int do_ecmd(int fnum , char_u *ffname , char_u *sfname , char_u *command , linenr_t newlnum ,
            int flags___0 ) ;
int autowrite(BUF *buf___3 , int forceit ) ;
int can_abandon(BUF *buf___3 , int forceit ) ;
void check_arg_idx(WIN *win ) ;
int readfile(char_u *fname , char_u *sfname , linenr_t from , linenr_t lines_to_skip ,
             linenr_t lines_to_read , int flags___0 ) ;
char_u *shorten_fname(char_u *full_path , char_u *dir_name ) ;
int vim_fgets(char_u *buf___3 , int size , FILE *fp___0 ) ;
int buf_check_timestamp(BUF *buf___3 , int focus ) ;
int apply_autocmds(EVENT_T event , char_u *fname , char_u *fname_io , int force ,
                   BUF *buf___3 ) ;
char_u *file_pat_to_reg_pat(char_u *pat , char_u *pat_end , char *allow_dirs , int no_bslash ) ;
int vgetc(void) ;
void getout(int r ) ;
void setpcmark(void) ;
void fmarks_check_names(BUF *buf___3 ) ;
void clrallmarks(BUF *buf___3 ) ;
void set_last_cursor(WIN *win ) ;
int removable(char_u *name___1 ) ;
int smsg(char_u *s  , ...) ;
int ml_open(void) ;
void ml_setname(void) ;
void ml_close(BUF *buf___3 , int del_file ) ;
void ml_timestamp(BUF *buf___3 ) ;
void ml_recover(void) ;
char_u *ml_get(linenr_t lnum ) ;
char_u *ml_get_curline(void) ;
int msg(char_u *s ) ;
int emsg(char_u *s ) ;
int emsg2(char_u *s , char_u *a1 ) ;
int emsgn(char_u *s , long n ) ;
char_u *msg_trunc_attr(char_u *s , int force , int attr ) ;
void msg_putchar(int c ) ;
int msg_outtrans(char_u *str___1 ) ;
void msg_puts(char_u *s ) ;
char *plural(long n ) ;
void changed(void) ;
void unchanged(BUF *buf___3 , int ff ) ;
void expand_env(char_u *src , char_u *dst , int dstlen ) ;
void home_replace(BUF *buf___3 , char_u *src , char_u *dst , int dstlen , int one ) ;
char_u *home_replace_save(BUF *buf___3 , char_u *src ) ;
int fullpathcmp(char_u *s1 , char_u *s2 , int checkname ) ;
char_u *gettail(char_u *fname ) ;
char_u *FullName_save(char_u *fname , int force ) ;
void check_cursor_lnum(void) ;
void check_cursor_col(void) ;
char_u *alloc(unsigned int size ) ;
char_u *alloc_clear(unsigned int size ) ;
char_u *vim_strsave(char_u *string___0 ) ;
void vim_free(void *x___0 ) ;
char_u *vim_strchr(char_u *string___0 , int n ) ;
char_u *vim_strrchr(char_u *string___0 , int n ) ;
int vim_isspace(int x___0 ) ;
int get_fileformat(BUF *buf___3 ) ;
int do_set(char_u *arg , int modeline ) ;
char_u *find_viminfo_parameter(int type ) ;
void free_string_option(char_u *p___0 ) ;
void buf_copy_options(BUF *bp_from , BUF *bp_to , int flags___0 ) ;
int shortmess(int x___0 ) ;
vim_regexp *vim_regcomp(char_u *expr , int magic ) ;
int vim_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) ;
void update_screen(int type ) ;
void status_redraw_all(void) ;
int build_stl_str(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ) ;
void scroll_cursor_halfway(int atend ) ;
void validate_virtcol(void) ;
void syntax_clear(BUF *buf___3 ) ;
void out_flush(void) ;
void ui_delay(long msec , int ignoreinput ) ;
void ui_breakcheck(void) ;
void u_sync(void) ;
void u_clearall(BUF *buf___3 ) ;
void u_blockfree(BUF *buf___3 ) ;
int buf_changed(BUF *buf___3 ) ;
int curbuf_changed(void) ;
int win_split(int new_height , int redraw , int req_room ) ;
int win_valid(WIN *win ) ;
void win_move_after(WIN *win1 , WIN *win2 ) ;
void close_windows(BUF *buf___3 ) ;
void close_window(WIN *win , int free_buf ) ;
void close_others(int message , int forceit ) ;
void win_enter(WIN *wp , int undo_sync ) ;
WIN *buf_jump_open_win(BUF *buf___3 ) ;
static char_u *buflist_match(vim_regexp *prog , BUF *buf___3 ) ;
static char_u *buflist_match_try(vim_regexp *prog , char_u *name___1 ) ;
static void buflist_setfpos(BUF *buf___3 , linenr_t lnum , colnr_t col ) ;
static BUF *buflist_findname_stat(char_u *ffname , struct stat *stp ) ;
static int otherfile_buf(BUF *buf___3 , char_u *ffname , struct stat *stp ) ;
static void buf_setino(BUF *buf___3 ) ;
static int buf_same_ino(BUF *buf___3 , struct stat *stp ) ;
static int ti_change(char_u *str___1 , char_u **last ) ;
static void free_buffer(BUF *buf___3 ) ;
int open_buffer(int read_stdin ) 
{ 
  int retval ;
  BUF *old_curbuf ;
  BUF *new_curbuf ;
  int tmp ;
  int tmp___0 ;

  {
  retval = 1;
  if (readonlymode) {
    if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
      if (curbuf->b_flags & 4) {
        curbuf->b_p_ro = 1;
      }
    }
  }
  {
  tmp = ml_open();
  }
  if (tmp == 0) {
    {
    close_buffer((WIN *)((void *)0), curbuf, 0, 0);
    curbuf = firstbuf;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )curbuf != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if ((unsigned long )curbuf->b_ml.ml_mfp != (unsigned long )((void *)0)) {
        goto while_break;
      }
      curbuf = curbuf->b_next;
    }
    while_break: /* CIL Label */ ;
    }
    if ((unsigned long )curbuf == (unsigned long )((void *)0)) {
      {
      emsg((char_u *)"Cannot allocate buffer, exiting...");
      getout(2);
      }
    }
    {
    emsg((char_u *)"Cannot allocate buffer, using other one...");
    enter_buffer(curbuf);
    }
    return (0);
  }
  old_curbuf = curbuf;
  modified_was_set = 0;
  if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
    {
    retval = readfile(curbuf->b_ffname, curbuf->b_fname, (linenr_t )0, (linenr_t )0,
                      (linenr_t )2147483647, 1);
    }
  } else { //Added block
  if (read_stdin) {
    {
    retval = readfile((char_u *)((void *)0), (char_u *)((void *)0), (linenr_t )0,
                      (linenr_t )0, (linenr_t )2147483647, 5);
    }
  }
  }
  if (curbuf->b_flags & 4) {
    {
    init_chartab();
    }
  }
  if (read_stdin) {
    if (! readonlymode) {
      {
      changed();
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (modified_was_set) {
    {
    changed();
    }
  } else { //Added block
  if (retval != 0) {
    {
    unchanged(curbuf, 0);
    }
  }
  }
  }
  curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
  if (got_int) {
    curbuf->b_flags |= 64;
  }
  {
  curwin->w_topline = (linenr_t )1;
  apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if (retval != 0) {
    {
    tmp___0 = buf_valid(old_curbuf);
    }
    if (tmp___0) {
      {
      new_curbuf = curbuf;
      curbuf = old_curbuf;
      curwin->w_buffer = old_curbuf;
      do_modelines();
      curbuf->b_flags &= -7;
      curbuf = new_curbuf;
      curwin->w_buffer = new_curbuf;
      }
    }
  }
  return (retval);
}
}
int buf_valid(BUF *buf___3 ) 
{ 
  BUF *bp___0 ;

  {
  bp___0 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )bp___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )bp___0 == (unsigned long )buf___3) {
      return (1);
    }
    bp___0 = bp___0->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
void close_buffer(WIN *win , BUF *buf___3 , int free_buf , int del_buf ) 
{ 
  int is_curbuf ;
  int tmp ;
  int tmp___0 ;

  {
  if (buf___3->b_nwindows > 0) {
    (buf___3->b_nwindows) --;
  }
  if (buf___3->b_nwindows == 0) {
    if ((unsigned long )win != (unsigned long )((void *)0)) {
      {
      set_last_cursor(win);
      }
      if ((unsigned long )win == (unsigned long )curwin) {
        if (curwin->w_cursor.lnum != 1L) {
          {
          buflist_setfpos(buf___3, curwin->w_cursor.lnum, curwin->w_cursor.col);
          }
        }
      }
    }
  }
  if (buf___3->b_nwindows == 0) {
    if (! free_buf) {
      {
      apply_autocmds((EVENT_T )10, buf___3->b_fname, buf___3->b_fname, 0, buf___3);
      tmp = buf_valid(buf___3);
      }
      if (! tmp) {
        return;
      }
    }
  }
  if (buf___3->b_nwindows > 0) {
    goto _L;
  } else { //Added block
  if (! free_buf) {
    _L: 
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      {
      u_sync();
      }
    }
    return;
  }
  }
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    del_buf = 1;
  }
  {
  is_curbuf = (unsigned long )buf___3 == (unsigned long )curbuf;
  buf_freeall(buf___3, del_buf);
  tmp___0 = buf_valid(buf___3);
  }
  if (tmp___0) {
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      if (! is_curbuf) {
        return;
      }
    }
  } else {
    return;
  }
  if (del_buf) {
    {
    vim_free((void *)buf___3->b_ffname);
    vim_free((void *)buf___3->b_sfname);
    }
    if ((unsigned long )buf___3->b_prev == (unsigned long )((void *)0)) {
      firstbuf = buf___3->b_next;
    } else {
      (buf___3->b_prev)->b_next = buf___3->b_next;
    }
    if ((unsigned long )buf___3->b_next == (unsigned long )((void *)0)) {
      lastbuf = buf___3->b_prev;
    } else {
      (buf___3->b_next)->b_prev = buf___3->b_prev;
    }
    {
    free_buffer(buf___3);
    }
  } else {
    {
    buf_clear(buf___3);
    }
  }
  return;
}
}
void buf_clear(BUF *buf___3 ) 
{ 


  {
  {
  buf___3->b_ml.ml_line_count = (linenr_t )1;
  unchanged(buf___3, 1);
  buf___3->b_shortname = 0;
  buf___3->b_p_eol = 1;
  buf___3->b_ml.ml_mfp = (MEMFILE *)((void *)0);
  buf___3->b_ml.ml_flags = 1;
  }
  return;
}
}
void buf_freeall(BUF *buf___3 , int del_buf ) 
{ 
  int is_curbuf ;
  int tmp ;
  int tmp___0 ;

  {
  {
  is_curbuf = (unsigned long )buf___3 == (unsigned long )curbuf;
  apply_autocmds((EVENT_T )9, buf___3->b_fname, buf___3->b_fname, 0, buf___3);
  tmp = buf_valid(buf___3);
  }
  if (! tmp) {
    return;
  }
  if (del_buf) {
    {
    apply_autocmds((EVENT_T )1, buf___3->b_fname, buf___3->b_fname, 0, buf___3);
    tmp___0 = buf_valid(buf___3);
    }
    if (! tmp___0) {
      return;
    }
  }
  if ((unsigned long )buf___3 == (unsigned long )curbuf) {
    if (! is_curbuf) {
      return;
    }
  }
  {
  u_blockfree(buf___3);
  ml_close(buf___3, 1);
  buf___3->b_ml.ml_line_count = (linenr_t )0;
  u_clearall(buf___3);
  syntax_clear(buf___3);
  }
  return;
}
}
static void free_buffer(BUF *buf___3 ) 
{ 
  WINFPOS *wlp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3->b_winfpos != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    wlp = buf___3->b_winfpos;
    buf___3->b_winfpos = wlp->wl_next;
    vim_free((void *)wlp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  var_clear(& buf___3->b_vars);
  free_buf_options(buf___3, 1);
  vim_free((void *)buf___3);
  }
  return;
}
}
char_u *do_bufdel(int command , char_u *arg , int addr_count , int start_bnr , int end_bnr ,
                  int forceit ) 
{ 
  int do_current ;
  int deleted ;
  char_u *errormsg ;
  int bnr ;
  char_u *p___0 ;
  int tmp ;
  long tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;

  {
  do_current = 0;
  deleted = 0;
  errormsg = (char_u *)((void *)0);
  if (addr_count == 0) {
    {
    do_buffer(command, 0, 1, 0, forceit);
    }
  } else {
    if (addr_count == 2) {
      if (*arg) {
        return (e_trailing);
      }
      bnr = start_bnr;
    } else {
      bnr = end_bnr;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (! got_int)) {
        goto while_break;
      }
      if (bnr == curbuf->b_fnum) {
        do_current = bnr;
      } else {
        {
        tmp = do_buffer(command, 1, 1, bnr, forceit);
        }
        if (tmp == 1) {
          deleted ++;
        }
      }
      if (addr_count == 2) {
        bnr ++;
        if (bnr > end_bnr) {
          goto while_break;
        }
      } else {
        {
        arg = skipwhite(arg);
        }
        if ((int )*arg == 0) {
          goto while_break;
        }
        {
        tmp___1 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___1 + (int )*arg) & 2048) {
          {
          tmp___0 = getdigits(& arg);
          bnr = (int )tmp___0;
          }
        } else {
          {
          p___0 = skiptowhite_esc(arg);
          bnr = buflist_findpat(arg, p___0);
          }
          if (bnr < 0) {
            goto while_break;
          }
          arg = p___0;
        }
      }
      {
      ui_breakcheck();
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (! got_int) {
      if (do_current) {
        {
        tmp___2 = do_buffer(command, 1, 1, do_current, forceit);
        }
        if (tmp___2 == 1) {
          deleted ++;
        }
      }
    }
    if (deleted == 0) {
      if (command == 2) {
        tmp___3 = "unloaded";
      } else {
        tmp___3 = "deleted";
      }
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"No buffers were %s",
              tmp___3);
      errormsg = IObuff;
      }
    } else {
      if (command == 2) {
        tmp___4 = "unloaded";
      } else {
        tmp___4 = "deleted";
      }
      {
      tmp___5 = plural((long )deleted);
      smsg((char_u *)"%d buffer%s %s", deleted, tmp___5, tmp___4);
      }
    }
  }
  return (errormsg);
}
}
int do_buffer(int action , int start___0 , int dir , int count___2 , int forceit ) 
{ 
  BUF *buf___3 ;
  BUF *delbuf ;
  int retval ;
  int forward ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  BUF *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int jumpidx ;
  int tmp___8 ;
  char_u *tmp___9 ;
  WIN *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  WIN *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
  if (start___0 == 1) {
    goto case_1;
  }
  if (start___0 == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1: /* CIL Label */ 
  buf___3 = firstbuf;
  goto switch_break;
  case_2: /* CIL Label */ 
  buf___3 = lastbuf;
  goto switch_break;
  switch_default: /* CIL Label */ 
  buf___3 = curbuf;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (start___0 == 3) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp___0 = count___2;
      count___2 --;
      if (! (tmp___0 > 0)) {
        goto while_break;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        buf___3 = buf___3->b_next;
        if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
          buf___3 = firstbuf;
        }
        if ((unsigned long )buf___3 != (unsigned long )curbuf) {
          {
          tmp = buf_changed(buf___3);
          }
          if (tmp) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    tmp___1 = buf_changed(buf___3);
    }
    if (! tmp___1) {
      {
      emsg((char_u *)"No modified buffer found");
      }
      return (0);
    }
  } else { //Added block
  if (start___0 == 1) {
    if (count___2) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
          if (! (buf___3->b_fnum != count___2)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        buf___3 = buf___3->b_next;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      tmp___3 = count___2;
      count___2 --;
      if (! (tmp___3 > 0)) {
        goto while_break___2;
      }
      if (dir == 1) {
        buf___3 = buf___3->b_next;
        if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
          buf___3 = firstbuf;
        }
      } else {
        buf___3 = buf___3->b_prev;
        if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
          buf___3 = lastbuf;
        }
      }
      if (start___0 == 2) {
        tmp___2 = lastbuf;
      } else {
        tmp___2 = curbuf;
      }
      if (buf___3->b_help != tmp___2->b_help) {
        count___2 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    if (start___0 == 1) {
      if (action != 2) {
        if (action != 3) {
          {
          emsgn((char_u *)"Cannot go to buffer %ld", (long )count___2);
          }
        }
      }
    } else { //Added block
    if (dir == 1) {
      {
      emsg((char_u *)"Cannot go beyond last buffer");
      }
    } else {
      {
      emsg((char_u *)"Cannot go before first buffer");
      }
    }
    }
    return (0);
  }
  if (action == 2) {
    goto _L___1;
  } else { //Added block
  if (action == 3) {
    _L___1: 
    if (! forceit) {
      {
      tmp___4 = buf_changed(buf___3);
      }
      if (tmp___4) {
        {
        emsgn((char_u *)"No write since last change for buffer %ld (use ! to override)",
              (long )buf___3->b_fnum);
        }
        return (0);
      }
    }
    if ((unsigned long )firstbuf->b_next == (unsigned long )((void *)0)) {
      if (action == 2) {
        {
        emsg((char_u *)"Cannot unload last buffer");
        }
        return (0);
      }
      {
      close_others(0, 1);
      buf___3 = curbuf;
      setpcmark();
      }
      if (forceit) {
        tmp___5 = 8;
      } else {
        tmp___5 = 0;
      }
      {
      retval = do_ecmd(0, (char_u *)((void *)0), (char_u *)((void *)0), (char_u *)((void *)0),
                       (linenr_t )1, tmp___5);
      }
      if ((unsigned long )buf___3 != (unsigned long )curbuf) {
        {
        tmp___6 = buf_valid(buf___3);
        }
        if (tmp___6) {
          {
          close_buffer((WIN *)((void *)0), buf___3, 1, 1);
          }
        }
      }
      return (retval);
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if ((unsigned long )buf___3 == (unsigned long )curbuf) {
        if (! ((unsigned long )firstwin != (unsigned long )lastwin)) {
          goto while_break___3;
        }
      } else {
        goto while_break___3;
      }
      {
      close_window(curwin, 0);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    if ((unsigned long )buf___3 != (unsigned long )curbuf) {
      {
      close_windows(buf___3);
      tmp___7 = buf_valid(buf___3);
      }
      if (tmp___7) {
        {
        close_buffer((WIN *)((void *)0), buf___3, 1, action == 3);
        }
      }
      return (1);
    }
    buf___3 = (BUF *)((void *)0);
    if ((unsigned long )au_new_curbuf != (unsigned long )((void *)0)) {
      {
      tmp___8 = buf_valid(au_new_curbuf);
      }
      if (tmp___8) {
        buf___3 = au_new_curbuf;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (curwin->w_jumplistlen > 0) {
      jumpidx = curwin->w_jumplistidx - 1;
      if (jumpidx < 0) {
        jumpidx = curwin->w_jumplistlen - 1;
      }
      forward = jumpidx;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! (jumpidx != curwin->w_jumplistidx)) {
          goto while_break___4;
        }
        {
        buf___3 = buflist_findnr(curwin->w_jumplist[jumpidx].fnum);
        }
        if ((unsigned long )buf___3 == (unsigned long )curbuf) {
          buf___3 = (BUF *)((void *)0);
        } else { //Added block
        if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
          if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
            buf___3 = (BUF *)((void *)0);
          }
        }
        }
        if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
          goto while_break___4;
        }
        if (! jumpidx) {
          if (curwin->w_jumplistidx == curwin->w_jumplistlen) {
            goto while_break___4;
          }
        }
        jumpidx --;
        if (jumpidx < 0) {
          jumpidx = curwin->w_jumplistlen - 1;
        }
        if (jumpidx == forward) {
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      forward = 1;
      buf___3 = curbuf->b_next;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
          if (! forward) {
            goto while_break___5;
          }
          buf___3 = curbuf->b_prev;
          forward = 0;
          goto __Cont;
        }
        if ((unsigned long )buf___3->b_ml.ml_mfp != (unsigned long )((void *)0)) {
          if (buf___3->b_help == curbuf->b_help) {
            goto while_break___5;
          }
        }
        if (forward) {
          buf___3 = buf___3->b_next;
        } else {
          buf___3 = buf___3->b_prev;
        }
        __Cont: ;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      if ((unsigned long )curbuf->b_next != (unsigned long )((void *)0)) {
        buf___3 = curbuf->b_next;
      } else {
        buf___3 = curbuf->b_prev;
      }
    }
  }
  }
  if (action == 1) {
    {
    tmp___9 = vim_strchr(p_swb, 'u');
    }
    if (tmp___9) {
      {
      tmp___10 = buf_jump_open_win(buf___3);
      }
      if (tmp___10) {
        return (1);
      }
    }
    {
    tmp___11 = win_split(0, 0, 0);
    }
    if (tmp___11 == 0) {
      return (0);
    }
  }
  if ((unsigned long )buf___3 == (unsigned long )curbuf) {
    return (1);
  }
  if (action == 0) {
    {
    tmp___12 = can_abandon(curbuf, forceit);
    }
    if (! tmp___12) {
      {
      emsg(e_nowrtmsg);
      }
      return (0);
    }
  }
  {
  setpcmark();
  curwin->w_alt_fnum = curbuf->b_fnum;
  buflist_altfpos();
  delbuf = curbuf;
  apply_autocmds((EVENT_T )5, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  tmp___17 = buf_valid(delbuf);
  }
  if (tmp___17) {
    if (action == 2) {
      {
      close_windows(delbuf);
      }
    } else { //Added block
    if (action == 3) {
      {
      close_windows(delbuf);
      }
    }
    }
    {
    tmp___16 = buf_valid(delbuf);
    }
    if (tmp___16) {
      if (action == 0) {
        if (! p_hid) {
          {
          tmp___13 = buf_changed(delbuf);
          }
          if (tmp___13) {
            goto _L___3;
          } else {
            tmp___14 = 1;
          }
        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: 
      if (action == 2) {
        tmp___14 = 1;
      } else { //Added block
      if (action == 3) {
        tmp___14 = 1;
      } else {
        tmp___14 = 0;
      }
      }
      }
      if ((unsigned long )delbuf == (unsigned long )curwin->w_buffer) {
        tmp___15 = curwin;
      } else {
        tmp___15 = (WIN *)((void *)0);
      }
      {
      close_buffer(tmp___15, delbuf, tmp___14, action == 3);
      }
    }
  }
  {
  tmp___18 = buf_valid(buf___3);
  }
  if (tmp___18) {
    {
    enter_buffer(buf___3);
    }
  }
  return (1);
}
}
void enter_buffer(BUF *buf___3 ) 
{ 


  {
  {
  buf_copy_options(curbuf, buf___3, 5);
  curwin->w_buffer = buf___3;
  curbuf = buf___3;
  (curbuf->b_nwindows) ++;
  }
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    {
    open_buffer(0);
    }
  } else {
    {
    need_fileinfo = 1;
    buf_check_timestamp(curbuf, 0);
    curwin->w_topline = (linenr_t )1;
    apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
    }
  }
  {
  buflist_getfpos();
  check_arg_idx(curwin);
  maketitle();
  }
  if (curwin->w_topline == 1L) {
    {
    scroll_cursor_halfway(0);
    }
  }
  {
  update_screen(40);
  }
  return;
}
}
static int top_file_num  =    1;
BUF *buflist_new(char_u *ffname , char_u *sfname , linenr_t lnum , int use_curbuf ) 
{ 
  BUF *buf___3 ;
  struct stat st ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  {
  fname_expand(& ffname, & sfname);
  }
  if ((unsigned long )sfname == (unsigned long )((void *)0)) {
    st.st_dev = (__dev_t )4294967295U;
  } else {
    {
    tmp = stat((char const   * __restrict  )((char *)sfname), (struct stat * __restrict  )(& st));
    }
    if (tmp < 0) {
      st.st_dev = (__dev_t )4294967295U;
    }
  }
  if ((unsigned long )ffname != (unsigned long )((void *)0)) {
    {
    buf___3 = buflist_findname_stat(ffname, & st);
    }
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      {
      vim_free((void *)ffname);
      }
      if (lnum != 0L) {
        {
        buflist_setfpos(buf___3, lnum, (colnr_t )0);
        }
      }
      {
      buf_copy_options(curbuf, buf___3, 0);
      }
      return (buf___3);
    }
  }
  if (use_curbuf) {
    if ((unsigned long )curbuf != (unsigned long )((void *)0)) {
      if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
        if (curbuf->b_nwindows <= 1) {
          if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
            {
            buf___3 = curbuf;
            apply_autocmds((EVENT_T )1, (char_u *)((void *)0), (char_u *)((void *)0),
                           0, curbuf);
            }
          } else { //Added block
          if (curbuf->b_ml.ml_line_count == 1L) {
            {
            tmp___1 = ml_get((linenr_t )1);
            }
            if ((int )*tmp___1 == 0) {
              {
              buf___3 = curbuf;
              apply_autocmds((EVENT_T )1, (char_u *)((void *)0), (char_u *)((void *)0),
                             0, curbuf);
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
    {
    tmp___0 = alloc_clear((unsigned int )sizeof(BUF ));
    buf___3 = (BUF *)tmp___0;
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      {
      vim_free((void *)ffname);
      }
      return ((BUF *)((void *)0));
    }
  }
  if ((unsigned long )ffname != (unsigned long )((void *)0)) {
    {
    buf___3->b_ffname = ffname;
    buf___3->b_sfname = vim_strsave(sfname);
    }
  }
  if ((unsigned long )buf___3->b_winfpos == (unsigned long )((void *)0)) {
    {
    tmp___2 = alloc((unsigned int )sizeof(WINFPOS ));
    buf___3->b_winfpos = (WINFPOS *)tmp___2;
    }
  }
  if ((unsigned long )ffname != (unsigned long )((void *)0)) {
    if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
      goto _L___3;
    } else { //Added block
    if ((unsigned long )buf___3->b_sfname == (unsigned long )((void *)0)) {
      goto _L___3;
    } else {
      goto _L___4;
    }
    }
  } else { //Added block
  _L___4: 
  if ((unsigned long )buf___3->b_winfpos == (unsigned long )((void *)0)) {
    _L___3: 
    {
    vim_free((void *)buf___3->b_ffname);
    buf___3->b_ffname = (char_u *)((void *)0);
    vim_free((void *)buf___3->b_sfname);
    buf___3->b_sfname = (char_u *)((void *)0);
    }
    if ((unsigned long )buf___3 != (unsigned long )curbuf) {
      {
      free_buffer(buf___3);
      }
    }
    return ((BUF *)((void *)0));
  }
  }
  if ((unsigned long )buf___3 == (unsigned long )curbuf) {
    {
    buf_freeall(buf___3, 0);
    }
    if ((unsigned long )buf___3 != (unsigned long )curbuf) {
      return ((BUF *)((void *)0));
    }
    buf___3->b_nwindows = 0;
  } else {
    buf___3->b_next = (BUF *)((void *)0);
    if ((unsigned long )firstbuf == (unsigned long )((void *)0)) {
      buf___3->b_prev = (BUF *)((void *)0);
      firstbuf = buf___3;
    } else {
      lastbuf->b_next = buf___3;
      buf___3->b_prev = lastbuf;
    }
    lastbuf = buf___3;
    tmp___3 = top_file_num;
    top_file_num ++;
    buf___3->b_fnum = tmp___3;
    if (top_file_num < 0) {
      {
      emsg((char_u *)"Warning: List of file names overflow");
      out_flush();
      ui_delay(3000L, 1);
      top_file_num = 1;
      }
    }
    {
    (buf___3->b_winfpos)->wl_fpos.lnum = lnum;
    (buf___3->b_winfpos)->wl_fpos.col = (colnr_t )0;
    (buf___3->b_winfpos)->wl_next = (WINFPOS *)((void *)0);
    (buf___3->b_winfpos)->wl_prev = (WINFPOS *)((void *)0);
    (buf___3->b_winfpos)->wl_win = curwin;
    var_init(& buf___3->b_vars);
    buf_copy_options(curbuf, buf___3, 2);
    }
  }
  buf___3->b_fname = buf___3->b_sfname;
  if (st.st_dev == 4294967295UL) {
    buf___3->b_dev = -1;
  } else {
    buf___3->b_dev = (int )st.st_dev;
    buf___3->b_ino = st.st_ino;
  }
  {
  buf___3->b_u_synced = 1;
  buf___3->b_flags = 6;
  buf_clear(buf___3);
  clrallmarks(buf___3);
  fmarks_check_names(buf___3);
  apply_autocmds((EVENT_T )0, (char_u *)((void *)0), (char_u *)((void *)0), 0, buf___3);
  }
  return (buf___3);
}
}
void free_buf_options(BUF *buf___3 , int free_p_ff ) 
{ 


  {
  if (free_p_ff) {
    {
    free_string_option(buf___3->b_p_ff);
    }
  }
  {
  free_string_option(buf___3->b_p_key);
  free_string_option(buf___3->b_p_mps);
  free_string_option(buf___3->b_p_fo);
  free_string_option(buf___3->b_p_isk);
  free_string_option(buf___3->b_p_com);
  free_string_option(buf___3->b_p_nf);
  free_string_option(buf___3->b_p_syn);
  free_string_option(buf___3->b_p_ft);
  free_string_option(buf___3->b_p_cink);
  free_string_option(buf___3->b_p_cino);
  free_string_option(buf___3->b_p_cinw);
  free_string_option(buf___3->b_p_cpt);
  }
  return;
}
}
int buflist_getfile(int n , linenr_t lnum , int options___0 , int forceit ) 
{ 
  BUF *buf___3 ;
  WIN *wp ;
  FPOS *fpos ;
  colnr_t col ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  wp = (WIN *)((void *)0);
  buf___3 = buflist_findnr(n);
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    if (options___0 & 2) {
      if (n == 0) {
        {
        emsg(e_noalt);
        }
      } else {
        {
        emsgn((char_u *)"buffer %ld not found", (long )n);
        }
      }
    } else {
      {
      emsgn((char_u *)"buffer %ld not found", (long )n);
      }
    }
    return (0);
  }
  if ((unsigned long )buf___3 == (unsigned long )curbuf) {
    return (1);
  }
  if (lnum == 0L) {
    {
    fpos = buflist_findfpos(buf___3);
    lnum = fpos->lnum;
    col = fpos->col;
    }
  } else {
    col = (colnr_t )0;
  }
  if (options___0 & 4) {
    {
    tmp = vim_strchr(p_swb, 'u');
    }
    if (tmp) {
      {
      wp = buf_jump_open_win(buf___3);
      }
    }
    if ((unsigned long )wp == (unsigned long )((void *)0)) {
      {
      tmp___0 = vim_strchr(p_swb, 't');
      }
      if (tmp___0) {
        {
        tmp___1 = win_split(0, 0, 0);
        }
        if (! tmp___1) {
          return (0);
        }
      }
    }
  }
  {
  RedrawingDisabled ++;
  tmp___2 = getfile(buf___3->b_fnum, (char_u *)((void *)0), (char_u *)((void *)0),
                    options___0 & 1, lnum, forceit);
  }
  if (tmp___2 <= 0) {
    RedrawingDisabled --;
    if (! p_sol) {
      if (col != 0U) {
        {
        curwin->w_cursor.col = col;
        check_cursor_col();
        }
      }
    }
    return (1);
  }
  RedrawingDisabled --;
  return (0);
}
}
void buflist_getfpos(void) 
{ 
  FPOS *fpos ;

  {
  {
  fpos = buflist_findfpos(curbuf);
  curwin->w_cursor.lnum = fpos->lnum;
  check_cursor_lnum();
  }
  if (p_sol) {
    curwin->w_cursor.col = (colnr_t )0;
  } else {
    {
    curwin->w_cursor.col = fpos->col;
    check_cursor_col();
    }
  }
  return;
}
}
BUF *buflist_findname(char_u *ffname ) 
{ 
  struct stat st ;
  int tmp ;
  BUF *tmp___0 ;

  {
  {
  tmp = stat((char const   * __restrict  )((char *)ffname), (struct stat * __restrict  )(& st));
  }
  if (tmp < 0) {
    st.st_dev = (__dev_t )4294967295U;
  }
  {
  tmp___0 = buflist_findname_stat(ffname, & st);
  }
  return (tmp___0);
}
}
static BUF *buflist_findname_stat(char_u *ffname , struct stat *stp ) 
{ 
  BUF *buf___3 ;
  int tmp ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = otherfile_buf(buf___3, ffname, stp);
    }
    if (! tmp) {
      return (buf___3);
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  return ((BUF *)((void *)0));
}
}
int buflist_findpat(char_u *pattern , char_u *pattern_end ) 
{ 
  BUF *buf___3 ;
  vim_regexp *prog ;
  int fnum ;
  char_u *pat ;
  char_u *patend ;
  char_u *match ;
  int attempt ;
  char_u *p___0 ;
  int toggledollar ;
  size_t tmp ;
  int tmp___0 ;

  {
  fnum = -1;
  if ((unsigned long )pattern_end == (unsigned long )(pattern + 1)) {
    if ((int )*pattern == 37) {
      goto _L___0;
    } else { //Added block
    if ((int )*pattern == 35) {
      _L___0: 
      if ((int )*pattern == 37) {
        fnum = curbuf->b_fnum;
      } else {
        fnum = curwin->w_alt_fnum;
      }
    } else {
      goto _L;
    }
    }
  } else {
    _L: 
    {
    pat = file_pat_to_reg_pat(pattern, pattern_end, (char *)((void *)0), 0);
    }
    if ((unsigned long )pat == (unsigned long )((void *)0)) {
      return (-1);
    }
    {
    tmp = strlen((char const   *)((char *)pat));
    patend = (pat + tmp) - 1;
    }
    if ((unsigned long )patend > (unsigned long )pat) {
      if ((int )*patend == 36) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    toggledollar = tmp___0;
    attempt = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (attempt <= 3)) {
        goto while_break;
      }
      if (toggledollar) {
        if (attempt < 2) {
          *patend = (char_u )'\000';
        } else {
          *patend = (char_u )'$';
        }
      }
      p___0 = pat;
      if ((int )*p___0 == 94) {
        if (! (attempt & 1)) {
          p___0 ++;
        }
      }
      {
      prog = vim_regcomp(p___0, p_magic);
      }
      if ((unsigned long )prog == (unsigned long )((void *)0)) {
        {
        vim_free((void *)pat);
        }
        return (-1);
      }
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
        {
        match = buflist_match(prog, buf___3);
        }
        if ((unsigned long )match != (unsigned long )((void *)0)) {
          if (fnum >= 0) {
            fnum = -2;
            goto while_break___0;
          }
          fnum = buf___3->b_fnum;
        }
        buf___3 = buf___3->b_next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      vim_free((void *)prog);
      }
      if (fnum >= 0) {
        goto while_break;
      }
      attempt ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)pat);
    }
  }
  if (fnum == -2) {
    {
    emsg2((char_u *)"More than one match for %s", pattern);
    }
  } else { //Added block
  if (fnum < 1) {
    {
    emsg2((char_u *)"No matching buffer for %s", pattern);
    }
  }
  }
  return (fnum);
}
}
int ExpandBufnames(char_u *pat , int *num_file , char_u ***file , int options___0 ) 
{ 
  int count___2 ;
  BUF *buf___3 ;
  int round ;
  char_u *p___0 ;
  int attempt ;
  vim_regexp *prog ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  count___2 = 0;
  *num_file = 0;
  *file = (char_u **)((void *)0);
  attempt = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (attempt <= 2)) {
      goto while_break;
    }
    if (attempt == 2) {
      if ((int )*pat != 94) {
        goto while_break;
      }
      pat ++;
    }
    {
    prog = vim_regcomp(pat, p_magic);
    }
    if ((unsigned long )prog == (unsigned long )((void *)0)) {
      return (0);
    }
    round = 1;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (round <= 2)) {
        goto while_break___0;
      }
      count___2 = 0;
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
          goto while_break___1;
        }
        {
        p___0 = buflist_match(prog, buf___3);
        }
        if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
          if (round == 1) {
            count___2 ++;
          } else {
            if (options___0 & 2) {
              {
              p___0 = home_replace_save(buf___3, p___0);
              }
            } else {
              {
              p___0 = vim_strsave(p___0);
              }
            }
            tmp = count___2;
            count___2 ++;
            *(*file + tmp) = p___0;
          }
        }
        buf___3 = buf___3->b_next;
      }
      while_break___1: /* CIL Label */ ;
      }
      if (count___2 == 0) {
        goto while_break___0;
      }
      if (round == 1) {
        {
        tmp___0 = alloc((unsigned int )((unsigned long )count___2 * sizeof(char_u *)));
        *file = (char_u **)tmp___0;
        }
        if ((unsigned long )*file == (unsigned long )((void *)0)) {
          {
          vim_free((void *)prog);
          }
          return (0);
        }
      }
      round ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    vim_free((void *)prog);
    }
    if (count___2) {
      goto while_break;
    }
    attempt ++;
  }
  while_break: /* CIL Label */ ;
  }
  *num_file = count___2;
  if (count___2 == 0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static char_u *buflist_match(vim_regexp *prog , BUF *buf___3 ) 
{ 
  char_u *match ;
  int save_reg_ic ;

  {
  {
  save_reg_ic = reg_ic;
  reg_ic = 0;
  match = buflist_match_try(prog, buf___3->b_sfname);
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    {
    match = buflist_match_try(prog, buf___3->b_ffname);
    }
  }
  reg_ic = save_reg_ic;
  return (match);
}
}
static char_u *buflist_match_try(vim_regexp *prog , char_u *name___1 ) 
{ 
  char_u *match ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;

  {
  match = (char_u *)((void *)0);
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    {
    tmp___0 = vim_regexec(prog, name___1, 1);
    }
    if (tmp___0 != 0) {
      match = name___1;
    } else {
      {
      p___0 = home_replace_save((BUF *)((void *)0), name___1);
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        {
        tmp = vim_regexec(prog, p___0, 1);
        }
        if (tmp != 0) {
          match = name___1;
        }
      }
      {
      vim_free((void *)p___0);
      }
    }
  }
  return (match);
}
}
BUF *buflist_findnr(int nr ) 
{ 
  BUF *buf___3 ;
  WIN *wp ;
  char_u *tmp ;

  {
  if (nr == 0) {
    nr = curwin->w_alt_fnum;
  }
  {
  tmp = vim_strchr(p_swb, 'u');
  }
  if (tmp) {
    wp = firstwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! wp) {
        goto while_break;
      }
      if ((wp->w_buffer)->b_fnum == nr) {
        return (wp->w_buffer);
      }
      wp = wp->w_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    if (buf___3->b_fnum == nr) {
      return (buf___3);
    }
    buf___3 = buf___3->b_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((BUF *)((void *)0));
}
}
char_u *buflist_nr2name(int n , int fullname , int helptail ) 
{ 
  BUF *buf___3 ;
  char_u *tmp ;
  BUF *tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  buf___3 = buflist_findnr(n);
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  if (fullname) {
    tmp = buf___3->b_ffname;
  } else {
    tmp = buf___3->b_fname;
  }
  if (helptail) {
    tmp___0 = buf___3;
  } else {
    tmp___0 = (BUF *)((void *)0);
  }
  {
  tmp___1 = home_replace_save(tmp___0, tmp);
  }
  return (tmp___1);
}
}
static void buflist_setfpos(BUF *buf___3 , linenr_t lnum , colnr_t col ) 
{ 
  WINFPOS *wlp ;
  char_u *tmp ;

  {
  wlp = buf___3->b_winfpos;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wlp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )wlp->wl_win == (unsigned long )curwin) {
      goto while_break;
    }
    wlp = wlp->wl_next;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )wlp == (unsigned long )((void *)0)) {
    {
    tmp = alloc((unsigned int )sizeof(WINFPOS ));
    wlp = (WINFPOS *)tmp;
    }
    if ((unsigned long )wlp == (unsigned long )((void *)0)) {
      return;
    }
    wlp->wl_win = curwin;
  } else {
    if (wlp->wl_prev) {
      (wlp->wl_prev)->wl_next = wlp->wl_next;
    } else {
      buf___3->b_winfpos = wlp->wl_next;
    }
    if (wlp->wl_next) {
      (wlp->wl_next)->wl_prev = wlp->wl_prev;
    }
  }
  wlp->wl_fpos.lnum = lnum;
  wlp->wl_fpos.col = col;
  wlp->wl_next = buf___3->b_winfpos;
  buf___3->b_winfpos = wlp;
  wlp->wl_prev = (WINFPOS *)((void *)0);
  if (wlp->wl_next) {
    (wlp->wl_next)->wl_prev = wlp;
  }
  return;
}
}
static FPOS no_position  =    {(linenr_t )1, (colnr_t )0};
FPOS *buflist_findfpos(BUF *buf___3 ) 
{ 
  WINFPOS *wlp ;

  {
  wlp = buf___3->b_winfpos;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wlp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )wlp->wl_win == (unsigned long )curwin) {
      goto while_break;
    }
    wlp = wlp->wl_next;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )wlp == (unsigned long )((void *)0)) {
    wlp = buf___3->b_winfpos;
  }
  if ((unsigned long )wlp != (unsigned long )((void *)0)) {
    return (& wlp->wl_fpos);
  } else {
    return (& no_position);
  }
}
}
linenr_t buflist_findlnum(BUF *buf___3 ) 
{ 
  FPOS *tmp ;

  {
  {
  tmp = buflist_findfpos(buf___3);
  }
  return (tmp->lnum);
}
}
void buflist_list(void) 
{ 
  BUF *buf___3 ;
  int len___0 ;
  int i___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  linenr_t tmp___11 ;
  linenr_t tmp___12 ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    msg_putchar('\n');
    }
    if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)"No File"));
      }
    } else {
      {
      home_replace(buf___3, buf___3->b_fname, NameBuff, 1024, 1);
      }
    }
    {
    tmp___1 = buf_changed(buf___3);
    }
    if (tmp___1) {
      tmp___0 = '+';
    } else {
      tmp___0 = ' ';
    }
    if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      tmp___3 = '-';
    } else {
      if (buf___3->b_nwindows == 0) {
        tmp___2 = 'h';
      } else {
        tmp___2 = ' ';
      }
      tmp___3 = tmp___2;
    }
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      tmp___5 = '%';
    } else {
      if (curwin->w_alt_fnum == buf___3->b_fnum) {
        tmp___4 = '#';
      } else {
        tmp___4 = ' ';
      }
      tmp___5 = tmp___4;
    }
    {
    sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%3d %c%c%c \"",
            buf___3->b_fnum, tmp___5, tmp___3, tmp___0);
    tmp___6 = strlen((char const   *)((char *)IObuff));
    len___0 = (int )tmp___6;
    strncpy((char * __restrict  )((char *)(IObuff + len___0)), (char const   * __restrict  )((char *)NameBuff),
            (size_t )(1005 - len___0));
    tmp___7 = strlen((char const   *)((char *)IObuff));
    len___0 = (int )tmp___7;
    tmp___8 = len___0;
    len___0 ++;
    *(IObuff + tmp___8) = (char_u )'\"';
    *(IObuff + len___0) = (char_u )'\000';
    tmp___9 = vim_strsize(IObuff);
    i___0 = 40 - tmp___9;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      tmp___10 = len___0;
      len___0 ++;
      *(IObuff + tmp___10) = (char_u )' ';
      i___0 --;
      if (i___0 > 0) {
        if (! (len___0 < 1007)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      tmp___12 = curwin->w_cursor.lnum;
    } else {
      {
      tmp___11 = buflist_findlnum(buf___3);
      tmp___12 = tmp___11;
      }
    }
    {
    sprintf((char * __restrict  )((char *)IObuff + len___0), (char const   * __restrict  )"line %ld",
            tmp___12);
    msg_outtrans(IObuff);
    out_flush();
    ui_breakcheck();
    buf___3 = buf___3->b_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int buflist_name_nr(int fnum , char_u **fname , linenr_t *lnum ) 
{ 
  BUF *buf___3 ;

  {
  {
  buf___3 = buflist_findnr(fnum);
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    return (0);
  } else { //Added block
  if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
    return (0);
  }
  }
  {
  *fname = buf___3->b_fname;
  *lnum = buflist_findlnum(buf___3);
  }
  return (1);
}
}
int setfname(char_u *ffname , char_u *sfname , int message ) 
{ 
  BUF *buf___3 ;
  struct stat st ;
  int tmp ;

  {
  if ((unsigned long )ffname == (unsigned long )((void *)0)) {
    {
    vim_free((void *)curbuf->b_ffname);
    vim_free((void *)curbuf->b_sfname);
    curbuf->b_ffname = (char_u *)((void *)0);
    curbuf->b_sfname = (char_u *)((void *)0);
    st.st_dev = (__dev_t )4294967295U;
    }
  } else { //Added block
  if ((int )*ffname == 0) {
    {
    vim_free((void *)curbuf->b_ffname);
    vim_free((void *)curbuf->b_sfname);
    curbuf->b_ffname = (char_u *)((void *)0);
    curbuf->b_sfname = (char_u *)((void *)0);
    st.st_dev = (__dev_t )4294967295U;
    }
  } else {
    {
    fname_expand(& ffname, & sfname);
    }
    if ((unsigned long )ffname == (unsigned long )((void *)0)) {
      return (0);
    }
    {
    tmp = stat((char const   * __restrict  )((char *)ffname), (struct stat * __restrict  )(& st));
    }
    if (tmp < 0) {
      st.st_dev = (__dev_t )4294967295U;
    }
    {
    buf___3 = buflist_findname_stat(ffname, & st);
    }
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      if ((unsigned long )buf___3 != (unsigned long )curbuf) {
        if ((unsigned long )buf___3->b_ml.ml_mfp != (unsigned long )((void *)0)) {
          if (message) {
            {
            emsg((char_u *)"Buffer with this name already exists");
            }
          }
          {
          vim_free((void *)ffname);
          }
          return (0);
        }
        {
        close_buffer((WIN *)((void *)0), buf___3, 1, 1);
        }
      }
    }
    {
    sfname = vim_strsave(sfname);
    }
    if ((unsigned long )ffname == (unsigned long )((void *)0)) {
      {
      vim_free((void *)sfname);
      vim_free((void *)ffname);
      }
      return (0);
    } else { //Added block
    if ((unsigned long )sfname == (unsigned long )((void *)0)) {
      {
      vim_free((void *)sfname);
      vim_free((void *)ffname);
      }
      return (0);
    }
    }
    {
    vim_free((void *)curbuf->b_ffname);
    vim_free((void *)curbuf->b_sfname);
    curbuf->b_ffname = ffname;
    curbuf->b_sfname = sfname;
    }
  }
  }
  curbuf->b_fname = curbuf->b_sfname;
  if (st.st_dev == 4294967295UL) {
    curbuf->b_dev = -1;
  } else {
    curbuf->b_dev = (int )st.st_dev;
    curbuf->b_ino = st.st_ino;
  }
  curbuf->b_shortname = 0;
  if ((unsigned long )curbuf->b_ml.ml_mfp != (unsigned long )((void *)0)) {
    {
    ml_setname();
    }
  }
  {
  check_arg_idx(curwin);
  maketitle();
  status_redraw_all();
  fmarks_check_names(curbuf);
  ml_timestamp(curbuf);
  }
  return (1);
}
}
void setaltfname(char_u *ffname , char_u *sfname , linenr_t lnum ) 
{ 
  BUF *buf___3 ;

  {
  {
  buf___3 = buflist_new(ffname, sfname, lnum, 0);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    curwin->w_alt_fnum = buf___3->b_fnum;
  }
  return;
}
}
char_u *getaltfname(int errmsg ) 
{ 
  char_u *fname ;
  linenr_t dummy ;
  int tmp ;

  {
  {
  tmp = buflist_name_nr(0, & fname, & dummy);
  }
  if (tmp == 0) {
    if (errmsg) {
      {
      emsg(e_noalt);
      }
    }
    return ((char_u *)((void *)0));
  }
  return (fname);
}
}
int buflist_add(char_u *fname ) 
{ 
  BUF *buf___3 ;

  {
  {
  buf___3 = buflist_new(fname, (char_u *)((void *)0), (linenr_t )0, 0);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    return (buf___3->b_fnum);
  }
  return (0);
}
}
void buflist_altfpos(void) 
{ 


  {
  {
  buflist_setfpos(curbuf, curwin->w_cursor.lnum, curwin->w_cursor.col);
  }
  return;
}
}
int otherfile(char_u *ffname ) 
{ 
  int tmp ;

  {
  {
  tmp = otherfile_buf(curbuf, ffname, (struct stat *)((void *)0));
  }
  return (tmp);
}
}
static int otherfile_buf(BUF *buf___3 , char_u *ffname , struct stat *stp ) 
{ 
  int tmp ;
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )ffname == (unsigned long )((void *)0)) {
    return (1);
  } else { //Added block
  if ((int )*ffname == 0) {
    return (1);
  } else { //Added block
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    return (1);
  }
  }
  }
  {
  tmp = strcmp((char const   *)((char *)ffname), (char const   *)((char *)buf___3->b_ffname));
  }
  if (tmp == 0) {
    return (0);
  }
  if ((unsigned long )stp == (unsigned long )((void *)0)) {
    if (buf___3->b_dev < 0) {
      st.st_dev = (__dev_t )4294967295U;
    } else {
      {
      tmp___0 = stat((char const   * __restrict  )((char *)ffname), (struct stat * __restrict  )(& st));
      }
      if (tmp___0 < 0) {
        st.st_dev = (__dev_t )4294967295U;
      }
    }
    stp = & st;
  }
  {
  tmp___2 = buf_same_ino(buf___3, stp);
  }
  if (tmp___2) {
    {
    buf_setino(buf___3);
    tmp___1 = buf_same_ino(buf___3, stp);
    }
    if (tmp___1) {
      return (0);
    }
  }
  return (1);
}
}
static void buf_setino(BUF *buf___3 ) 
{ 
  struct stat st ;
  int tmp ;

  {
  if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
    {
    tmp = stat((char const   * __restrict  )((char *)buf___3->b_fname), (struct stat * __restrict  )(& st));
    }
    if (tmp >= 0) {
      buf___3->b_dev = (int )st.st_dev;
      buf___3->b_ino = st.st_ino;
    } else {
      buf___3->b_dev = -1;
    }
  } else {
    buf___3->b_dev = -1;
  }
  return;
}
}
static int buf_same_ino(BUF *buf___3 , struct stat *stp ) 
{ 
  int tmp ;

  {
  if (buf___3->b_dev >= 0) {
    if (stp->st_dev == (__dev_t )buf___3->b_dev) {
      if (stp->st_ino == buf___3->b_ino) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void fileinfo(int fullname , int shorthelp , int dont_truncate ) 
{ 
  char_u *name___1 ;
  int n ;
  char_u *p___0 ;
  char_u *buffer ;
  size_t tmp ;
  char_u *tmp___0 ;
  BUF *tmp___1 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
  buffer = alloc(1025U);
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    return;
  }
  if (fullname > 1) {
    {
    sprintf((char * __restrict  )((char *)buffer), (char const   * __restrict  )"buf %d: ",
            curbuf->b_fnum);
    tmp = strlen((char const   *)((char *)buffer));
    p___0 = buffer + tmp;
    }
  } else {
    p___0 = buffer;
  }
  tmp___0 = p___0;
  p___0 ++;
  *tmp___0 = (char_u )'\"';
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    {
    strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)"No File"));
    }
  } else {
    if (! fullname) {
      if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
        name___1 = curbuf->b_fname;
      } else {
        name___1 = curbuf->b_ffname;
      }
    } else {
      name___1 = curbuf->b_ffname;
    }
    if (shorthelp) {
      tmp___1 = curbuf;
    } else {
      tmp___1 = (BUF *)((void *)0);
    }
    {
    home_replace(tmp___1, name___1, p___0, (int )(1025L - (p___0 - buffer)), 1);
    }
  }
  {
  tmp___4 = curbuf_changed();
  }
  if (tmp___4) {
    tmp___3 = " ";
  } else { //Added block
  if (curbuf->b_flags & 88) {
    tmp___3 = " ";
  } else { //Added block
  if (curbuf->b_p_ro) {
    tmp___3 = " ";
  } else {
    tmp___3 = "";
  }
  }
  }
  if (curbuf->b_p_ro) {
    {
    tmp___7 = shortmess('r');
    }
    if (tmp___7) {
      tmp___6 = "[RO]";
    } else {
      tmp___6 = "[readonly]";
    }
    tmp___8 = tmp___6;
  } else {
    tmp___8 = "";
  }
  if (curbuf->b_flags & 64) {
    tmp___9 = "[Read errors]";
  } else {
    tmp___9 = "";
  }
  if (curbuf->b_flags & 16) {
    tmp___10 = "[New file]";
  } else {
    tmp___10 = "";
  }
  if (curbuf->b_flags & 8) {
    tmp___11 = "[Not edited]";
  } else {
    tmp___11 = "";
  }
  {
  tmp___17 = curbuf_changed();
  }
  if (tmp___17) {
    {
    tmp___15 = shortmess('m');
    }
    if (tmp___15) {
      tmp___14 = " [+]";
    } else {
      tmp___14 = " [Modified]";
    }
    tmp___16 = tmp___14;
  } else {
    tmp___16 = " ";
  }
  {
  tmp___18 = strlen((char const   *)((char *)buffer));
  sprintf((char * __restrict  )((char *)buffer + tmp___18), (char const   * __restrict  )"\"%s%s%s%s%s%s",
          tmp___16, tmp___11, tmp___10, tmp___9, tmp___8, tmp___3);
  n = (int )((curwin->w_cursor.lnum * 100L) / curbuf->b_ml.ml_line_count);
  }
  if (curbuf->b_ml.ml_flags & 1) {
    {
    tmp___19 = strlen((char const   *)((char *)buffer));
    strcpy((char * __restrict  )((char *)(buffer + tmp___19)), (char const   * __restrict  )((char *)(no_lines_msg)));
    }
  } else { //Added block
  if (p_ru) {
    {
    tmp___20 = plural(curbuf->b_ml.ml_line_count);
    tmp___21 = strlen((char const   *)((char *)buffer));
    sprintf((char * __restrict  )((char *)buffer + tmp___21), (char const   * __restrict  )"%ld line%s --%d%%--",
            curbuf->b_ml.ml_line_count, tmp___20, n);
    }
  } else {
    {
    tmp___22 = strlen((char const   *)((char *)buffer));
    sprintf((char * __restrict  )((char *)buffer + tmp___22), (char const   * __restrict  )"line %ld of %ld --%d%%-- col ",
            curwin->w_cursor.lnum, curbuf->b_ml.ml_line_count, n);
    validate_virtcol();
    tmp___23 = strlen((char const   *)((char *)buffer));
    col_print(buffer + tmp___23, (int )curwin->w_cursor.col + 1, (int )curwin->w_virtcol + 1);
    }
  }
  }
  {
  tmp___24 = shortmess('f');
  }
  if (tmp___24) {
    tmp___25 = 0;
  } else {
    tmp___25 = 1;
  }
  {
  append_arg_number(curwin, buffer, tmp___25, 1025);
  }
  if (dont_truncate) {
    {
    n = msg_scroll;
    msg_scroll = 1;
    msg(buffer);
    msg_scroll = n;
    }
  } else {
    {
    msg_trunc_attr(buffer, 0, 0);
    }
  }
  {
  vim_free((void *)buffer);
  }
  return;
}
}
void cursor_pos_info(void) 
{ 
  char_u *p___0 ;
  char_u buf1[20] ;
  char_u buf2[20] ;
  linenr_t lnum ;
  long char_count ;
  long char_count_cursor ;
  int eol_size ;
  long last_check ;
  int tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  char_count = 0L;
  char_count_cursor = 0L;
  last_check = 100000L;
  if (curbuf->b_ml.ml_flags & 1) {
    {
    msg(no_lines_msg);
    }
  } else {
    {
    tmp = get_fileformat(curbuf);
    }
    if (tmp == 1) {
      eol_size = 2;
    } else {
      eol_size = 1;
    }
    lnum = (linenr_t )1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (lnum <= curbuf->b_ml.ml_line_count)) {
        goto while_break;
      }
      if (lnum == curwin->w_cursor.lnum) {
        char_count_cursor = (char_count + (long )curwin->w_cursor.col) + 1L;
      }
      {
      tmp___0 = ml_get(lnum);
      tmp___1 = strlen((char const   *)((char *)tmp___0));
      char_count = (long )((size_t )char_count + (tmp___1 + (size_t )eol_size));
      }
      if (char_count > last_check) {
        {
        ui_breakcheck();
        }
        if (got_int) {
          return;
        }
        last_check = char_count + 100000L;
      }
      lnum ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (! curbuf->b_p_eol) {
      if (curbuf->b_p_bin) {
        char_count -= (long )eol_size;
      }
    }
    {
    p___0 = ml_get_curline();
    validate_virtcol();
    col_print(buf1, (int )curwin->w_cursor.col + 1, (int )curwin->w_virtcol + 1);
    tmp___2 = linetabsize(p___0);
    tmp___3 = strlen((char const   *)((char *)p___0));
    col_print(buf2, (int )tmp___3, tmp___2);
    sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Col %s of %s; Line %ld of %ld; Char %ld of %ld",
            (char *)(buf1), (char *)(buf2), curwin->w_cursor.lnum, curbuf->b_ml.ml_line_count,
            char_count_cursor, char_count);
    msg(IObuff);
    }
  }
  return;
}
}
void col_print(char_u *buf___3 , int col , int vcol ) 
{ 


  {
  if (col == vcol) {
    {
    sprintf((char * __restrict  )((char *)buf___3), (char const   * __restrict  )"%d",
            col);
    }
  } else {
    {
    sprintf((char * __restrict  )((char *)buf___3), (char const   * __restrict  )"%d-%d",
            col, vcol);
    }
  }
  return;
}
}
static char_u *lasttitle  =    (char_u *)((void *)0);
static char_u *lasticon  =    (char_u *)((void *)0);
void maketitle(void) 
{ 
  char_u *t_name ;
  char_u *t_str ;
  char_u *i_name ;
  char_u *i_str ;
  char_u *p___0 ;
  int maxlen ;
  int len___0 ;
  int mustset ;
  char_u buf___3[1025] ;
  size_t tmp ;
  size_t tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  int tmp___6 ;

  {
  t_str = (char_u *)((void *)0);
  i_str = (char_u *)((void *)0);
  maxlen = 0;
  if (p_title) {
    if (p_titlelen > 0L) {
      maxlen = (int )((p_titlelen * Columns) / 100L);
      if (maxlen < 10) {
        maxlen = 10;
      }
    }
    t_str = buf___3;
    if ((int )*p_titlestring != 0) {
      if (stl_syntax & 2) {
        {
        build_stl_str(curwin, t_str, p_titlestring, 0, maxlen);
        }
      } else {
        t_str = p_titlestring;
      }
    } else {
      if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
        t_name = (char_u *)"VIM -";
      } else {
        {
        t_name = buf___3 + 100;
        strcpy((char * __restrict  )((char *)t_name), (char const   * __restrict  )((char *)"VIM - "));
        home_replace(curbuf, curbuf->b_ffname, t_name + 6, 919, 1);
        append_arg_number(curwin, t_name, 0, 925);
        }
        if (maxlen) {
          {
          tmp = strlen((char const   *)((char *)t_name));
          len___0 = (int )tmp;
          }
          if (len___0 > maxlen) {
            {
            memmove((void *)((char *)(t_name + 6)), (void const   *)((char *)(((t_name + 6) + len___0) - maxlen)),
                    (size_t )maxlen - 5UL);
            *(t_name + 5) = (char_u )'<';
            }
          }
        }
      }
      p___0 = buf___3;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (*t_name) {
          if (! ((unsigned long )p___0 < (unsigned long )((buf___3 + 1025) - 5))) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        {
        tmp___1 = t_name;
        t_name ++;
        tmp___2 = transchar((int )*tmp___1);
        strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)tmp___2));
        tmp___0 = strlen((char const   *)((char *)p___0));
        p___0 += tmp___0;
        }
      }
      while_break: /* CIL Label */ ;
      }
      *p___0 = (char_u )'\000';
    }
  }
  {
  mustset = ti_change(t_str, & lasttitle);
  }
  if (p_icon) {
    i_str = buf___3;
    if ((int )*p_iconstring != 0) {
      if (stl_syntax & 1) {
        {
        build_stl_str(curwin, i_str, p_iconstring, 0, 0);
        }
      } else {
        i_str = p_iconstring;
      }
    } else {
      if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
        i_name = (char_u *)"No File";
      } else {
        {
        i_name = gettail(curbuf->b_ffname);
        }
      }
      p___0 = buf___3;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (*i_name) {
          if (! ((unsigned long )p___0 < (unsigned long )((buf___3 + 1025) - 5))) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        {
        tmp___4 = i_name;
        i_name ++;
        tmp___5 = transchar((int )*tmp___4);
        strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)tmp___5));
        tmp___3 = strlen((char const   *)((char *)p___0));
        p___0 += tmp___3;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      *p___0 = (char_u )'\000';
    }
  }
  {
  tmp___6 = ti_change(i_str, & lasticon);
  mustset |= tmp___6;
  }
  if (mustset) {
    {
    resettitle();
    }
  }
  return;
}
}
static int ti_change(char_u *str___1 , char_u **last ) 
{ 
  int tmp ;

  {
  if (((unsigned long )str___1 == (unsigned long )((void *)0)) != ((unsigned long )*last == (unsigned long )((void *)0))) {
    goto _L;
  } else { //Added block
  if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
    if ((unsigned long )*last != (unsigned long )((void *)0)) {
      {
      tmp = strcmp((char const   *)((char *)str___1), (char const   *)((char *)*last));
      }
      if (tmp != 0) {
        _L: 
        {
        vim_free((void *)*last);
        }
        if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
          *last = (char_u *)((void *)0);
        } else {
          {
          *last = vim_strsave(str___1);
          }
        }
        return (1);
      }
    }
  }
  }
  return (0);
}
}
void resettitle(void) 
{ 


  {
  {
  mch_settitle(lasttitle, lasticon);
  }
  return;
}
}
int append_arg_number(WIN *wp , char_u *buf___3 , int add_file , int maxlen ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char const   *tmp___2 ;

  {
  if (arg_file_count <= 1) {
    return (0);
  }
  {
  tmp = strlen((char const   *)((char *)buf___3));
  p___0 = buf___3 + tmp;
  }
  if (maxlen) {
    if ((p___0 - buf___3) + 35L >= (long )maxlen) {
      return (0);
    }
  }
  tmp___0 = p___0;
  p___0 ++;
  *tmp___0 = (char_u )' ';
  tmp___1 = p___0;
  p___0 ++;
  *tmp___1 = (char_u )'(';
  if (add_file) {
    {
    strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)"file "));
    p___0 += 5;
    }
  }
  if (wp->w_arg_idx_invalid) {
    tmp___2 = "(%d) of %d)";
  } else {
    tmp___2 = "%d of %d)";
  }
  {
  sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )tmp___2,
          wp->w_arg_idx + 1, arg_file_count);
  }
  return (1);
}
}
char_u *fix_fname(char_u *fname ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = FullName_save(fname, 1);
  }
  return (tmp);
}
}
void fname_expand(char_u **ffname , char_u **sfname ) 
{ 


  {
  if ((unsigned long )*ffname == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )*sfname == (unsigned long )((void *)0)) {
    *sfname = *ffname;
  }
  {
  *ffname = fix_fname(*ffname);
  }
  return;
}
}
void do_arg_all(int count___2 , int forceit ) 
{ 
  int i___0 ;
  WIN *wp ;
  WIN *wpnext ;
  char_u *opened ;
  int opened_len ;
  int use_firstwin ;
  int split_ret ;
  int p_sb_save ;
  int p_ea_save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  use_firstwin = 0;
  split_ret = 1;
  if (arg_file_count <= 0) {
    return;
  }
  {
  setpcmark();
  opened_len = arg_file_count;
  opened = alloc_clear((unsigned int )opened_len);
  }
  if ((unsigned long )opened == (unsigned long )((void *)0)) {
    return;
  }
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    wpnext = wp->w_next;
    if ((unsigned long )(wp->w_buffer)->b_ffname == (unsigned long )((void *)0)) {
      i___0 = arg_file_count;
    } else { //Added block
    if ((wp->w_buffer)->b_nwindows > 1) {
      i___0 = arg_file_count;
    } else {
      i___0 = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i___0 < arg_file_count)) {
          goto while_break___0;
        }
        {
        tmp = fullpathcmp(*(arg_files + i___0), (wp->w_buffer)->b_ffname, 1);
        }
        if (tmp & 1) {
          if (i___0 < opened_len) {
            *(opened + i___0) = (char_u )1;
          }
          goto while_break___0;
        }
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    }
    wp->w_arg_idx = i___0;
    if (i___0 == arg_file_count) {
      if (p_hid) {
        goto _L;
      } else { //Added block
      if (forceit) {
        goto _L;
      } else { //Added block
      if ((wp->w_buffer)->b_nwindows > 1) {
        goto _L;
      } else {
        {
        tmp___5 = buf_changed(wp->w_buffer);
        }
        if (! tmp___5) {
          _L: 
          if (! p_hid) {
            if ((wp->w_buffer)->b_nwindows <= 1) {
              {
              tmp___1 = buf_changed(wp->w_buffer);
              }
              if (tmp___1) {
                {
                autowrite(wp->w_buffer, 0);
                tmp___0 = win_valid(wp);
                }
                if (! tmp___0) {
                  wpnext = firstwin;
                  goto __Cont;
                }
              }
            }
          }
          if ((unsigned long )firstwin == (unsigned long )lastwin) {
            use_firstwin = 1;
          } else {
            if (! p_hid) {
              {
              tmp___2 = buf_changed(wp->w_buffer);
              }
              if (tmp___2) {
                tmp___3 = 0;
              } else {
                tmp___3 = 1;
              }
            } else {
              tmp___3 = 0;
            }
            {
            close_window(wp, tmp___3);
            tmp___4 = win_valid(wpnext);
            }
            if (! tmp___4) {
              wpnext = firstwin;
            }
          }
        }
      }
      }
      }
    }
    __Cont: 
    wp = wpnext;
  }
  while_break: /* CIL Label */ ;
  }
  if (count___2 > arg_file_count) {
    count___2 = arg_file_count;
  } else { //Added block
  if (count___2 <= 0) {
    count___2 = arg_file_count;
  }
  }
  {
  autocmd_no_enter ++;
  autocmd_no_leave ++;
  win_enter(lastwin, 0);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (i___0 < count___2) {
      if (i___0 < arg_file_count) {
        if (! (! got_int)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
    } else {
      goto while_break___1;
    }
    if (i___0 == arg_file_count - 1) {
      arg_had_last = 1;
    }
    if (i___0 < opened_len) {
      if (*(opened + i___0)) {
        if (curwin->w_arg_idx != i___0) {
          wpnext = firstwin;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! ((unsigned long )wpnext != (unsigned long )((void *)0))) {
              goto while_break___2;
            }
            if (wpnext->w_arg_idx == i___0) {
              {
              win_move_after(wpnext, curwin);
              }
              goto while_break___2;
            }
            wpnext = wpnext->w_next;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (split_ret == 1) {
      if (! use_firstwin) {
        {
        p_sb_save = p_sb;
        p_ea_save = p_ea;
        p_sb = 1;
        p_ea = 1;
        split_ret = win_split(0, 0, 1);
        p_sb = p_sb_save;
        p_ea = p_ea_save;
        }
        if (split_ret == 0) {
          goto __Cont___0;
        }
      } else {
        autocmd_no_leave --;
      }
      curwin->w_arg_idx = i___0;
      if (p_hid) {
        tmp___7 = 1;
      } else {
        {
        tmp___8 = buf_changed(curwin->w_buffer);
        }
        if (tmp___8) {
          tmp___7 = 1;
        } else {
          tmp___7 = 0;
        }
      }
      {
      do_ecmd(0, *(arg_files + i___0), (char_u *)((void *)0), (char_u *)((void *)0),
              (linenr_t )1, tmp___7 + 4);
      }
      if (use_firstwin) {
        autocmd_no_leave ++;
      }
      use_firstwin = 0;
    }
    }
    {
    ui_breakcheck();
    }
    __Cont___0: 
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  autocmd_no_enter --;
  win_enter(firstwin, 0);
  autocmd_no_leave --;
  }
  return;
}
}
void do_buffer_all(int count___2 , int all ) 
{ 
  BUF *buf___3 ;
  WIN *wp ;
  WIN *wpnext ;
  int split_ret ;
  int p_sb_save ;
  int p_ea_save ;
  int open_wins ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  split_ret = 1;
  open_wins = 0;
  setpcmark();
  wp = firstwin;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    wpnext = wp->w_next;
    if ((wp->w_buffer)->b_nwindows > 1) {
      {
      close_window(wp, 0);
      wpnext = firstwin;
      open_wins = 0;
      }
    } else {
      open_wins ++;
    }
    wp = wpnext;
  }
  while_break: /* CIL Label */ ;
  }
  {
  autocmd_no_enter ++;
  win_enter(lastwin, 0);
  autocmd_no_leave ++;
  buf___3 = firstbuf;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      if (! (open_wins < count___2)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    if (! all) {
      if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
        goto __Cont;
      }
    }
    wp = firstwin;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
        goto while_break___1;
      }
      if ((unsigned long )wp->w_buffer == (unsigned long )buf___3) {
        goto while_break___1;
      }
      wp = wp->w_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((unsigned long )wp != (unsigned long )((void *)0)) {
      {
      win_move_after(wp, curwin);
      }
    } else { //Added block
    if (split_ret == 1) {
      {
      p_sb_save = p_sb;
      p_ea_save = p_ea;
      p_sb = 1;
      p_ea = 1;
      split_ret = win_split(0, 0, 1);
      open_wins ++;
      p_sb = p_sb_save;
      p_ea = p_ea_save;
      }
      if (split_ret == 0) {
        goto __Cont;
      }
      {
      swap_exists_action = 1;
      do_buffer(0, 1, 1, buf___3->b_fnum, 0);
      tmp = buf_valid(buf___3);
      }
      if (! tmp) {
        swap_exists_action = 0;
        goto while_break___0;
      }
      if (swap_exists_action == 2) {
        {
        close_window(curwin, 1);
        open_wins --;
        }
      } else { //Added block
      if (swap_exists_action == 3) {
        {
        ml_recover();
        msg_puts((char_u *)"\n");
        cmdline_row = msg_row;
        do_modelines();
        }
      }
      }
      swap_exists_action = 0;
    }
    }
    {
    ui_breakcheck();
    }
    if (got_int) {
      {
      vgetc();
      }
      goto while_break___0;
    }
    __Cont: 
    buf___3 = buf___3->b_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  autocmd_no_enter --;
  win_enter(firstwin, 0);
  autocmd_no_leave --;
  wp = lastwin;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (open_wins > count___2)) {
      goto while_break___2;
    }
    if (p_hid) {
      {
      close_window(wp, ! p_hid);
      open_wins --;
      wp = lastwin;
      }
    } else {
      {
      tmp___0 = buf_changed(wp->w_buffer);
      }
      if (tmp___0) {
        {
        tmp___1 = autowrite(wp->w_buffer, 0);
        }
        if (tmp___1 == 1) {
          {
          close_window(wp, ! p_hid);
          open_wins --;
          wp = lastwin;
          }
        } else {
          wp = wp->w_prev;
          if ((unsigned long )wp == (unsigned long )((void *)0)) {
            goto while_break___2;
          }
        }
      } else {
        {
        close_window(wp, ! p_hid);
        open_wins --;
        wp = lastwin;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
static int chk_modeline(linenr_t lnum ) ;
static int entered  =    0;
void do_modelines(void) 
{ 
  linenr_t lnum ;
  int nmlines ;
  int tmp ;
  int tmp___0 ;

  {
  if (! curbuf->b_p_ml) {
    return;
  } else {
    nmlines = (int )p_mls;
    if (nmlines == 0) {
      return;
    }
  }
  if (entered) {
    return;
  }
  entered ++;
  lnum = (linenr_t )1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (lnum <= curbuf->b_ml.ml_line_count) {
      if (! (lnum <= (linenr_t )nmlines)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = chk_modeline(lnum);
    }
    if (tmp == 0) {
      nmlines = 0;
    }
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  lnum = curbuf->b_ml.ml_line_count;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (lnum > 0L) {
      if (lnum > (linenr_t )nmlines) {
        if (! (lnum > curbuf->b_ml.ml_line_count - (linenr_t )nmlines)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    tmp___0 = chk_modeline(lnum);
    }
    if (tmp___0 == 0) {
      nmlines = 0;
    }
    lnum --;
  }
  while_break___0: /* CIL Label */ ;
  }
  entered --;
  return;
}
}
static int chk_modeline(linenr_t lnum ) 
{ 
  char_u *s ;
  char_u *e ;
  char_u *linecopy ;
  int prev ;
  int end ;
  int retval ;
  char_u *save_sourcing_name ;
  linenr_t save_sourcing_lnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  retval = 1;
  prev = -1;
  s = ml_get(lnum);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*s != 0)) {
      goto while_break;
    }
    if (prev == -1) {
      goto _L___0;
    } else {
      {
      tmp___2 = vim_isspace(prev);
      }
      if (tmp___2) {
        _L___0: 
        if (prev != -1) {
          {
          tmp = strncmp((char const   *)((char *)s), (char const   *)((char *)"ex:"),
                        (size_t )3);
          }
          if (tmp == 0) {
            goto while_break;
          } else {
            goto _L;
          }
        } else {
          _L: 
          {
          tmp___0 = strncmp((char const   *)((char *)s), (char const   *)((char *)"vi:"),
                            (size_t )3);
          }
          if (tmp___0 == 0) {
            goto while_break;
          } else {
            {
            tmp___1 = strncmp((char const   *)((char *)s), (char const   *)((char *)"vim:"),
                              (size_t )4);
            }
            if (tmp___1 == 0) {
              goto while_break;
            }
          }
        }
      }
    }
    prev = (int )*s;
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (*s) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      s ++;
      if (! ((int )*(s + -1) != 58)) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    linecopy = vim_strsave(s);
    s = linecopy;
    }
    if ((unsigned long )linecopy == (unsigned long )((void *)0)) {
      return (0);
    }
    save_sourcing_lnum = sourcing_lnum;
    save_sourcing_name = sourcing_name;
    sourcing_lnum = lnum;
    sourcing_name = (char_u *)"modelines";
    end = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (end == 0)) {
        goto while_break___1;
      }
      {
      s = skipwhite(s);
      }
      if ((int )*s == 0) {
        goto while_break___1;
      }
      e = s;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if ((int )*e != 58) {
          if (! ((int )*e != 0)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        if ((int )*(e + 0) == 92) {
          if ((int )*(e + 1) == 58) {
            {
            strcpy((char * __restrict  )((char *)e), (char const   * __restrict  )((char *)(e + 1)));
            }
          }
        }
        e ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      if ((int )*e == 0) {
        end = 1;
      }
      {
      tmp___3 = strncmp((char const   *)((char *)s), (char const   *)((char *)"set "),
                        (size_t )4);
      }
      if (tmp___3 == 0) {
        if ((int )*e != 58) {
          goto while_break___1;
        }
        end = 1;
        s += 4;
      }
      {
      *e = (char_u )'\000';
      tmp___4 = do_set(s, 1);
      }
      if (tmp___4 == 0) {
        retval = 0;
        goto while_break___1;
      }
      s = e + 1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    sourcing_lnum = save_sourcing_lnum;
    sourcing_name = save_sourcing_name;
    vim_free((void *)linecopy);
    }
  }
  return (retval);
}
}
int read_viminfo_bufferlist(char_u *line , FILE *fp___0 , int writing ) 
{ 
  char_u *tab ;
  linenr_t lnum ;
  colnr_t col ;
  BUF *buf___3 ;
  char_u *sfname ;
  char_u *xline ;
  char_u *tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  {
  xline = viminfo_readstring(line + 1, fp___0);
  }
  if ((unsigned long )xline != (unsigned long )((void *)0)) {
    if (! writing) {
      if (arg_file_count == 0) {
        {
        tmp___2 = find_viminfo_parameter('%');
        }
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
          {
          lnum = (linenr_t )0;
          col = (colnr_t )0;
          tab = vim_strrchr(xline, '\t');
          }
          if ((unsigned long )tab != (unsigned long )((void *)0)) {
            {
            tmp = tab;
            tab ++;
            *tmp = (char_u )'\000';
            tmp___0 = atoi((char const   *)((char *)tab));
            col = (colnr_t )tmp___0;
            tab = vim_strrchr(xline, '\t');
            }
            if ((unsigned long )tab != (unsigned long )((void *)0)) {
              {
              tmp___1 = tab;
              tab ++;
              *tmp___1 = (char_u )'\000';
              lnum = atol((char const   *)((char *)tab));
              }
            }
          }
          {
          expand_env(xline, NameBuff, 1024);
          mch_dirname(IObuff, 1025);
          sfname = shorten_fname(NameBuff, IObuff);
          }
          if ((unsigned long )sfname == (unsigned long )((void *)0)) {
            sfname = NameBuff;
          }
          {
          buf___3 = buflist_new(NameBuff, sfname, (linenr_t )0, 0);
          }
          if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
            {
            buf___3->b_last_cursor.lnum = lnum;
            buf___3->b_last_cursor.col = col;
            buflist_setfpos(buf___3, lnum, col);
            }
          }
        }
      }
    }
  }
  {
  vim_free((void *)xline);
  tmp___3 = vim_fgets(line, 512, fp___0);
  }
  return (tmp___3);
}
}
void write_viminfo_bufferlist(FILE *fp___0 ) 
{ 
  BUF *buf___3 ;
  WIN *win ;
  char_u *line ;
  char_u *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
  tmp = find_viminfo_parameter('%');
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return;
  }
  {
  line = alloc(1054U);
  }
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    return;
  }
  win = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    set_last_cursor(win);
    win = win->w_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# Buffer list:\n");
  buf___3 = firstbuf;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
      goto __Cont;
    } else { //Added block
    if (buf___3->b_help) {
      goto __Cont;
    } else {
      {
      tmp___0 = removable(buf___3->b_ffname);
      }
      if (tmp___0) {
        goto __Cont;
      }
    }
    }
    {
    _IO_putc('%', fp___0);
    home_replace((BUF *)((void *)0), buf___3->b_ffname, line, 1024, 1);
    tmp___1 = strlen((char const   *)((char *)line));
    sprintf((char * __restrict  )((char *)line + tmp___1), (char const   * __restrict  )"\t%ld\t%d",
            buf___3->b_last_cursor.lnum, buf___3->b_last_cursor.col);
    viminfo_writestring(fp___0, line);
    }
    __Cont: 
    buf___3 = buf___3->b_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  vim_free((void *)line);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-TCvMZy5O.i","-O0")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
int VIsual_active ;
int State ;
char_u chartab[256]  ;
char breakat_flags[256]  ;
int lcs_tab1 ;
char_u *p_isf  ;
char_u *p_isi  ;
char_u *p_isp  ;
char_u *p_sel  ;
char_u *p_sbr  ;
void trans_characters(char_u *buf___3 , int bufsize ) ;
char_u *transstr(char_u *s ) ;
void transchar_nonprint(char_u *buf___3 , int c ) ;
int charsize(int c ) ;
int chartabsize(int c , colnr_t col ) ;
int win_linetabsize(WIN *wp , char_u *s ) ;
int vim_isIDc(int c ) ;
int vim_iswordc(int c ) ;
int vim_iswordc_buf(int c , BUF *buf___3 ) ;
int vim_isfilec(int c ) ;
int vim_isprintc(int c ) ;
int safe_vim_isprintc(int c ) ;
int lbr_chartabsize(unsigned char *s , colnr_t col ) ;
int win_lbr_chartabsize(WIN *wp , unsigned char *s , colnr_t col , int *head ) ;
void getvcol(WIN *wp , FPOS *pos___0 , colnr_t *start___0 , colnr_t *cursor , colnr_t *end ) ;
void getvcols(FPOS *pos1 , FPOS *pos2 , colnr_t *left , colnr_t *right ) ;
char_u *skipdigits(char_u *p___0 ) ;
int vim_isdigit(int c ) ;
char_u *skiptowhite(char_u *p___0 ) ;
int vim_isblankline(char_u *lbuf ) ;
void vim_str2nr(char_u *start___0 , int *hexp , int *len___0 , int dooct , int dohex ,
                long *nptr , unsigned long *unptr ) ;
int hex2nr(int c ) ;
char_u *ml_get_buf(BUF *buf___3 , linenr_t lnum , int will_change ) ;
char_u *skip_to_option_part(char_u *p___0 ) ;
static int win_chartabsize(WIN *wp , int c , colnr_t col ) ;
static int chartab_initialized  =    0;
int init_chartab(void) 
{ 
  int c ;
  int c2 ;
  char_u *p___0 ;
  int i___0 ;
  int tilde ;
  int do_isalpha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char_u *tmp___3 ;
  unsigned short const   **tmp___4 ;
  long tmp___5 ;
  char_u *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  c = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (c < 32)) {
      goto while_break;
    }
    tmp = c;
    c ++;
    chartab[tmp] = (char_u )2;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (c <= 126)) {
      goto while_break___0;
    }
    tmp___0 = c;
    c ++;
    chartab[tmp___0] = (char_u )5;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (c < 256)) {
      goto while_break___1;
    }
    tmp___1 = c;
    c ++;
    chartab[tmp___1] = (char_u )2;
  }
  while_break___1: /* CIL Label */ ;
  }
  if ((unsigned long )curbuf != (unsigned long )((void *)0)) {
    c = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (c < 256)) {
        goto while_break___2;
      }
      curbuf->b_chartab[c] = (char)0;
      c ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  if (curbuf->b_p_lisp) {
    curbuf->b_chartab['-'] = (char)1;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (i___0 < 4)) {
      goto while_break___3;
    }
    if (i___0 == 0) {
      p___0 = p_isi;
    } else { //Added block
    if (i___0 == 1) {
      p___0 = p_isp;
    } else { //Added block
    if (i___0 == 2) {
      p___0 = p_isf;
    } else {
      p___0 = curbuf->b_p_isk;
    }
    }
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break___4;
      }
      tilde = 0;
      do_isalpha = 0;
      if ((int )*p___0 == 94) {
        if ((int )*(p___0 + 1) != 0) {
          tilde = 1;
          p___0 ++;
        }
      }
      {
      tmp___4 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___4 + (int )*p___0) & 2048) {
        {
        tmp___2 = getdigits(& p___0);
        c = (int )tmp___2;
        }
      } else {
        tmp___3 = p___0;
        p___0 ++;
        c = (int )*tmp___3;
      }
      c2 = -1;
      if ((int )*p___0 == 45) {
        if ((int )*(p___0 + 1) != 0) {
          {
          p___0 ++;
          tmp___7 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___7 + (int )*p___0) & 2048) {
            {
            tmp___5 = getdigits(& p___0);
            c2 = (int )tmp___5;
            }
          } else {
            tmp___6 = p___0;
            p___0 ++;
            c2 = (int )*tmp___6;
          }
        }
      }
      if (c <= 0) {
        return (0);
      } else { //Added block
      if (c2 < c) {
        if (c2 != -1) {
          return (0);
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (c2 >= 256) {
        return (0);
      } else { //Added block
      if (! ((int )*p___0 == 0)) {
        if (! ((int )*p___0 == 44)) {
          return (0);
        }
      }
      }
      }
      }
      if (c2 == -1) {
        if (c == 64) {
          do_isalpha = 1;
          c = 1;
          c2 = 255;
        } else {
          c2 = c;
        }
      }
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! (c <= c2)) {
          goto while_break___5;
        }
        if (! do_isalpha) {
          goto _L___1;
        } else {
          {
          tmp___8 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___8 + c) & 1024) {
            _L___1: 
            if (i___0 == 0) {
              if (tilde) {
                chartab[c] = (char_u )((int )chartab[c] & -9);
              } else {
                chartab[c] = (char_u )((int )chartab[c] | 8);
              }
            } else { //Added block
            if (i___0 == 1) {
              if (c < 32) {
                goto _L___0;
              } else { //Added block
              if (c > 126) {
                _L___0: 
                if (tilde) {
                  chartab[c] = (char_u )(((int )chartab[c] & -4) + 2);
                  chartab[c] = (char_u )((int )chartab[c] & -5);
                } else {
                  chartab[c] = (char_u )(((int )chartab[c] & -4) + 1);
                  chartab[c] = (char_u )((int )chartab[c] | 4);
                }
              }
              }
            } else { //Added block
            if (i___0 == 2) {
              if (tilde) {
                chartab[c] = (char_u )((int )chartab[c] & -17);
              } else {
                chartab[c] = (char_u )((int )chartab[c] | 16);
              }
            } else {
              curbuf->b_chartab[c] = (char )(! tilde);
            }
            }
            }
          }
        }
        c ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
      p___0 = skip_to_option_part(p___0);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  chartab_initialized = 1;
  return (1);
}
}
void trans_characters(char_u *buf___3 , int bufsize ) 
{ 
  int len___0 ;
  int room ;
  char_u *new ;
  int new_len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)buf___3));
  len___0 = (int )tmp;
  room = bufsize - len___0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *buf___3) {
      goto while_break;
    }
    {
    new = transchar((int )*buf___3);
    tmp___0 = strlen((char const   *)((char *)new));
    new_len = (int )tmp___0;
    }
    if (new_len > 1) {
      room -= new_len - 1;
      if (room <= 0) {
        return;
      }
      {
      memmove((void *)((char *)(buf___3 + new_len)), (void const   *)((char *)(buf___3 + 1)),
              (size_t )len___0);
      }
    }
    {
    memmove((void *)((char *)buf___3), (void const   *)((char *)new), (size_t )new_len);
    buf___3 += new_len;
    len___0 --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
char_u *transstr(char_u *s ) 
{ 
  char_u *res ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  tmp = vim_strsize(s);
  res = alloc((unsigned int )(tmp + 1));
  }
  if ((unsigned long )res != (unsigned long )((void *)0)) {
    *res = (char_u )'\000';
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *s) {
        goto while_break;
      }
      {
      tmp___0 = s;
      s ++;
      tmp___1 = transchar((int )*tmp___0);
      strcat((char * __restrict  )((char *)res), (char const   * __restrict  )((char *)tmp___1));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (res);
}
}
static char_u buf[5]  ;
char_u *transchar(int c ) 
{ 
  int i___0 ;
  int tmp ;

  {
  i___0 = 0;
  if (c >= 512) {
    buf[0] = (char_u )'~';
    buf[1] = (char_u )'@';
    i___0 = 2;
    if (c == 128) {
      c = 254;
    } else {
      if (c == 0) {
        tmp = 255;
      } else {
        tmp = c & 255;
      }
      c = tmp;
    }
  }
  if (! chartab_initialized) {
    if (c >= 32) {
      if (c <= 126) {
        buf[i___0] = (char_u )c;
        buf[i___0 + 1] = (char_u )'\000';
      } else {
        goto _L;
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )chartab[c] & 4) {
    buf[i___0] = (char_u )c;
    buf[i___0 + 1] = (char_u )'\000';
  } else {
    {
    transchar_nonprint(buf + i___0, c);
    }
  }
  }
  return (buf);
}
}
void transchar_nonprint(char_u *buf___3 , int c ) 
{ 
  int tmp ;

  {
  if (c <= 127) {
    if (c == 10) {
      c = '\000';
    } else { //Added block
    if (c == 13) {
      {
      tmp = get_fileformat(curbuf);
      }
      if (tmp == 2) {
        c = '\n';
      }
    }
    }
    *(buf___3 + 0) = (char_u )'^';
    *(buf___3 + 1) = (char_u )(c ^ 64);
    *(buf___3 + 2) = (char_u )'\000';
  } else { //Added block
  if (c >= 160) {
    if (c <= 254) {
      *(buf___3 + 0) = (char_u )'|';
      *(buf___3 + 1) = (char_u )(c - 128);
      *(buf___3 + 2) = (char_u )'\000';
    } else {
      *(buf___3 + 0) = (char_u )'~';
      *(buf___3 + 1) = (char_u )((c - 128) ^ 64);
      *(buf___3 + 2) = (char_u )'\000';
    }
  } else {
    *(buf___3 + 0) = (char_u )'~';
    *(buf___3 + 1) = (char_u )((c - 128) ^ 64);
    *(buf___3 + 2) = (char_u )'\000';
  }
  }
  return;
}
}
int charsize(int c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (c >= 512) {
    if (c == 128) {
      tmp___0 = 254;
    } else {
      if (c == 0) {
        tmp = 255;
      } else {
        tmp = c & 255;
      }
      tmp___0 = tmp;
    }
    return (((int )chartab[tmp___0] & 3) + 2);
  }
  return ((int )chartab[c] & 3);
}
}
int vim_strsize(char_u *s ) 
{ 
  int len___0 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  len___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    tmp___0 = charsize((int )*tmp);
    len___0 += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (len___0);
}
}
int chartabsize(int c , colnr_t col ) 
{ 
  int ts ;
  int tmp ;

  {
  if (c == 9) {
    if (! curwin->w_p_list) {
      ts = (int )curbuf->b_p_ts;
      return ((int )((unsigned int )ts - col % (unsigned int )ts));
    } else { //Added block
    if (lcs_tab1) {
      ts = (int )curbuf->b_p_ts;
      return ((int )((unsigned int )ts - col % (unsigned int )ts));
    } else {
      {
      tmp = charsize(c);
      }
      return (tmp);
    }
    }
  } else {
    {
    tmp = charsize(c);
    }
    return (tmp);
  }
}
}
static int win_chartabsize(WIN *wp , int c , colnr_t col ) 
{ 
  int ts ;
  int tmp ;

  {
  if (c == 9) {
    if (! wp->w_p_list) {
      ts = (int )(wp->w_buffer)->b_p_ts;
      return ((int )((unsigned int )ts - col % (unsigned int )ts));
    } else { //Added block
    if (lcs_tab1) {
      ts = (int )(wp->w_buffer)->b_p_ts;
      return ((int )((unsigned int )ts - col % (unsigned int )ts));
    } else {
      {
      tmp = charsize(c);
      }
      return (tmp);
    }
    }
  } else {
    {
    tmp = charsize(c);
    }
    return (tmp);
  }
}
}
int linetabsize(char_u *s ) 
{ 
  colnr_t col ;
  char_u *tmp ;
  int tmp___0 ;

  {
  col = (colnr_t )0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*s != 0)) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    tmp___0 = lbr_chartabsize(tmp, col);
    col += (colnr_t )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((int )col);
}
}
int win_linetabsize(WIN *wp , char_u *s ) 
{ 
  colnr_t col ;
  char_u *tmp ;
  int tmp___0 ;

  {
  col = (colnr_t )0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*s != 0)) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    tmp___0 = win_lbr_chartabsize(wp, tmp, col, (int *)((void *)0));
    col += (colnr_t )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((int )col);
}
}
int vim_isIDc(int c ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if ((int )chartab[c] & 8) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int vim_iswordc(int c ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if (curbuf->b_chartab[c]) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int vim_iswordc_buf(int c , BUF *buf___3 ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if (buf___3->b_chartab[c]) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int vim_isfilec(int c ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if ((int )chartab[c] & 16) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int vim_isprintc(int c ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if ((int )chartab[c] & 4) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int safe_vim_isprintc(int c ) 
{ 


  {
  return ((int )chartab[c] & 4);
}
}
int lbr_chartabsize(unsigned char *s , colnr_t col ) 
{ 
  int ts ;
  int tmp ;
  int tmp___0 ;

  {
  if (! curwin->w_p_lbr) {
    if ((int )*p_sbr == 0) {
      if ((int )*s == 9) {
        if (! curwin->w_p_list) {
          ts = (int )curbuf->b_p_ts;
          return ((int )((unsigned int )ts - col % (unsigned int )ts));
        } else { //Added block
        if (lcs_tab1) {
          ts = (int )curbuf->b_p_ts;
          return ((int )((unsigned int )ts - col % (unsigned int )ts));
        } else {
          {
          tmp = charsize((int )*s);
          }
          return (tmp);
        }
        }
      } else {
        {
        tmp = charsize((int )*s);
        }
        return (tmp);
      }
    }
  }
  {
  tmp___0 = win_lbr_chartabsize(curwin, s, col, (int *)((void *)0));
  }
  return (tmp___0);
}
}
int win_lbr_chartabsize(WIN *wp , unsigned char *s , colnr_t col , int *head ) 
{ 
  int c ;
  int size ;
  colnr_t col2 ;
  colnr_t colmax ;
  int added ;
  int numberextra ;
  int ts ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  c = (int )*s;
  if (! wp->w_p_lbr) {
    if ((int )*p_sbr == 0) {
      if (c == 9) {
        if (! wp->w_p_list) {
          ts = (int )(wp->w_buffer)->b_p_ts;
          return ((int )((unsigned int )ts - col % (unsigned int )ts));
        } else { //Added block
        if (lcs_tab1) {
          ts = (int )(wp->w_buffer)->b_p_ts;
          return ((int )((unsigned int )ts - col % (unsigned int )ts));
        } else {
          {
          tmp = charsize(c);
          }
          return (tmp);
        }
        }
      } else {
        {
        tmp = charsize(c);
        }
        return (tmp);
      }
    }
  }
  {
  size = win_chartabsize(wp, c, col);
  }
  if (wp->w_p_lbr) {
    if (breakat_flags[(char_u )c]) {
      if (! breakat_flags[*(s + 1)]) {
        if (! wp->w_p_list) {
          if (wp->w_p_wrap) {
            if (wp->w_p_nu) {
              numberextra = 8;
            } else {
              numberextra = 0;
            }
            col2 = col;
            colmax = (colnr_t )(((long )(col + (colnr_t )numberextra) / Columns + 1L) * Columns);
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              s ++;
              c = (int )*s;
              if (c != 0) {
                if (! breakat_flags[(char_u )c]) {
                  if (! breakat_flags[(char_u )c]) {
                    if (! (col2 == col)) {
                      if (! (! breakat_flags[*(s + -1)])) {
                        goto while_break;
                      }
                    }
                  } else {
                    goto while_break;
                  }
                }
              } else {
                goto while_break;
              }
              {
              tmp___0 = win_chartabsize(wp, c, col2);
              col2 += (colnr_t )tmp___0;
              }
              if (col2 + (colnr_t )numberextra >= colmax) {
                size = (int )(Columns - (long )(col + (colnr_t )numberextra) % Columns);
                goto while_break;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  added = 0;
  if ((int )*p_sbr != 0) {
    if (wp->w_p_wrap) {
      if (col) {
        if (wp->w_p_nu) {
          numberextra = 8;
        } else {
          numberextra = 0;
        }
        col = (colnr_t )((long )(col + (colnr_t )numberextra) % Columns);
        if (col == 0U) {
          goto _L;
        } else { //Added block
        if (col + (colnr_t )size > (colnr_t )Columns) {
          _L: 
          {
          tmp___1 = strlen((char const   *)((char *)p_sbr));
          added = (int )tmp___1;
          size += added;
          }
          if (col != 0U) {
            added = 0;
          }
        }
        }
      }
    }
  }
  if ((unsigned long )head != (unsigned long )((void *)0)) {
    *head = added;
  }
  return (size);
}
}
void getvcol(WIN *wp , FPOS *pos___0 , colnr_t *start___0 , colnr_t *cursor , colnr_t *end ) 
{ 
  int col ;
  colnr_t vcol ;
  char_u *ptr ;
  int incr ;
  int head ;
  int ts ;
  int c ;

  {
  {
  ts = (int )(wp->w_buffer)->b_p_ts;
  vcol = (colnr_t )0;
  ptr = ml_get_buf(wp->w_buffer, pos___0->lnum, 0);
  }
  if (! wp->w_p_list) {
    goto _L___1;
  } else { //Added block
  if (lcs_tab1) {
    _L___1: 
    if (! wp->w_p_lbr) {
      if ((int )*p_sbr == 0) {
        head = 0;
        col = (int )pos___0->col;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          c = (int )*ptr;
          if (c == 0) {
            incr = 1;
            goto while_break;
          }
          if (c == 9) {
            incr = (int )((unsigned int )ts - vcol % (unsigned int )ts);
          } else {
            incr = (int )chartab[c] & 3;
          }
          if (col == 0) {
            goto while_break;
          }
          vcol += (colnr_t )incr;
          col --;
          ptr ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    col = (int )pos___0->col;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      head = 0;
      incr = win_lbr_chartabsize(wp, ptr, vcol, & head);
      }
      if ((int )*ptr == 0) {
        incr = 1;
        goto while_break___0;
      }
      if (col == 0) {
        goto while_break___0;
      }
      vcol += (colnr_t )incr;
      col --;
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  }
  if ((unsigned long )start___0 != (unsigned long )((void *)0)) {
    *start___0 = vcol + (colnr_t )head;
  }
  if ((unsigned long )end != (unsigned long )((void *)0)) {
    *end = (vcol + (colnr_t )incr) - 1U;
  }
  if ((unsigned long )cursor != (unsigned long )((void *)0)) {
    if ((int )*ptr == 9) {
      if (State & 1) {
        if (! wp->w_p_list) {
          if (VIsual_active) {
            if ((int )*p_sel == 101) {
              *cursor = vcol + (colnr_t )head;
            } else {
              *cursor = (vcol + (colnr_t )incr) - 1U;
            }
          } else {
            *cursor = (vcol + (colnr_t )incr) - 1U;
          }
        } else {
          *cursor = vcol + (colnr_t )head;
        }
      } else {
        *cursor = vcol + (colnr_t )head;
      }
    } else {
      *cursor = vcol + (colnr_t )head;
    }
  }
  return;
}
}
void getvcols(FPOS *pos1 , FPOS *pos2 , colnr_t *left , colnr_t *right ) 
{ 
  colnr_t l1 ;
  colnr_t l2 ;
  colnr_t r1 ;
  colnr_t r2 ;

  {
  {
  getvcol(curwin, pos1, & l1, (colnr_t *)((void *)0), & r1);
  getvcol(curwin, pos2, & l2, (colnr_t *)((void *)0), & r2);
  }
  if (l1 < l2) {
    *left = l1;
  } else {
    *left = l2;
  }
  if (r1 > r2) {
    *right = r1;
  } else {
    *right = r2;
  }
  return;
}
}
char_u *skipwhite(char_u *p___0 ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*p___0 == 32)) {
      if (! ((int )*p___0 == 9)) {
        goto while_break;
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
char_u *skipdigits(char_u *p___0 ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp + (int )*p___0) & 2048)) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
int vim_isdigit(int c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  if (c > 0) {
    if (c < 256) {
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + c) & 2048) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
char_u *skiptowhite(char_u *p___0 ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*p___0 != 32) {
      if ((int )*p___0 != 9) {
        if (! ((int )*p___0 != 0)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
char_u *skiptowhite_esc(char_u *p___0 ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*p___0 != 32) {
      if ((int )*p___0 != 9) {
        if (! ((int )*p___0 != 0)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 92) {
      goto _L;
    } else { //Added block
    if ((int )*p___0 == 22) {
      _L: 
      if ((int )*(p___0 + 1) != 0) {
        p___0 ++;
      }
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
long getdigits(char_u **pp ) 
{ 
  char_u *p___0 ;
  long retval ;

  {
  {
  p___0 = *pp;
  retval = atol((char const   *)((char *)p___0));
  }
  if ((int )*p___0 == 45) {
    p___0 ++;
  }
  {
  p___0 = skipdigits(p___0);
  *pp = p___0;
  }
  return (retval);
}
}
int vim_isblankline(char_u *lbuf ) 
{ 
  char_u *p___0 ;
  int tmp ;

  {
  {
  p___0 = skipwhite(lbuf);
  }
  if ((int )*p___0 == 0) {
    tmp = 1;
  } else { //Added block
  if ((int )*p___0 == 13) {
    tmp = 1;
  } else { //Added block
  if ((int )*p___0 == 10) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  return (tmp);
}
}
void vim_str2nr(char_u *start___0 , int *hexp , int *len___0 , int dooct , int dohex ,
                long *nptr , unsigned long *unptr ) 
{ 
  char_u *ptr ;
  int hex ;
  int negative ;
  long n ;
  unsigned long un ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  ptr = start___0;
  hex = 0;
  negative = 0;
  n = 0L;
  un = 0UL;
  if ((int )*(ptr + 0) == 45) {
    negative = 1;
    ptr ++;
  }
  if ((int )*(ptr + 0) == 48) {
    hex = (int )*(ptr + 1);
    if (dohex) {
      if (hex == 88) {
        goto _L___1;
      } else { //Added block
      if (hex == 120) {
        _L___1: 
        {
        tmp___0 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___0 + (int )*(ptr + 2)) & 4096) {
          ptr += 2;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
      }
    } else { //Added block
    _L___0: 
    if (dooct) {
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + hex) & 2048) {
        hex = '0';
      } else {
        hex = 0;
      }
    } else {
      hex = 0;
    }
    }
  }
  if (hex) {
    if (hex == 48) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (48 <= (int )*ptr) {
          if (! ((int )*ptr <= 55)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        n = 8L * n + (long )((int )*ptr - 48);
        un = 8UL * un + (unsigned long )((int )*ptr - 48);
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp___3 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___3 + (int )*ptr) & 4096)) {
          goto while_break___0;
        }
        {
        tmp___1 = hex2nr((int )*ptr);
        n = 16L * n + (long )tmp___1;
        tmp___2 = hex2nr((int )*ptr);
        un = 16UL * un + (unsigned long )tmp___2;
        ptr ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___4 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___4 + (int )*ptr) & 2048)) {
        goto while_break___1;
      }
      n = 10L * n + (long )((int )*ptr - 48);
      un = 10UL * un + (unsigned long )((int )*ptr - 48);
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  if (! hex) {
    if (negative) {
      n = - n;
    }
  }
  if ((unsigned long )hexp != (unsigned long )((void *)0)) {
    *hexp = hex;
  }
  if ((unsigned long )len___0 != (unsigned long )((void *)0)) {
    *len___0 = (int )(ptr - start___0);
  }
  if ((unsigned long )nptr != (unsigned long )((void *)0)) {
    *nptr = n;
  }
  if ((unsigned long )unptr != (unsigned long )((void *)0)) {
    *unptr = un;
  }
  return;
}
}
int hex2nr(int c ) 
{ 


  {
  if (c >= 97) {
    return ((c - 97) + 10);
  }
  if (c >= 65) {
    return ((c - 65) + 10);
  }
  return (c - 48);
}
}
#pragma merger("0","/tmp/cil-_1DEHuqF.i","-O0")
int must_redraw ;
char_u e_number[16] ;
int p_dg  ;
int do_digraph(int c ) ;
int getdigraph(int char1 , int char2 , int meta ) ;
void putdigraph(char_u *str___1 ) ;
void listdigraphs(void) ;
static int getexactdigraph(int char1 , int char2 , int meta ) ;
static void printdigraph(char_u *p___0 ) ;
static char_u (*digraphnew)[3]  ;
static int digraphcount  =    0;
char_u digraphdefault[101][3]  = 
  { {        (char_u )'~',        (char_u )'!',        (char_u )161}, 
   {        (char_u )'c',        (char_u )'|',        (char_u )162}, 
   {        (char_u )'$',        (char_u )'$',        (char_u )163}, 
   {        (char_u )'o',        (char_u )'x',        (char_u )164}, 
   {        (char_u )'e',        (char_u )'=',        (char_u )164}, 
   {        (char_u )'Y',        (char_u )'-',        (char_u )165}, 
   {        (char_u )'|',        (char_u )'|',        (char_u )166}, 
   {        (char_u )'p',        (char_u )'a',        (char_u )167}, 
   {        (char_u )'\"',        (char_u )'\"',        (char_u )168}, 
   {        (char_u )'c',        (char_u )'O',        (char_u )169}, 
   {        (char_u )'a',        (char_u )'-',        (char_u )170}, 
   {        (char_u )'<',        (char_u )'<',        (char_u )171}, 
   {        (char_u )'-',        (char_u )',',        (char_u )172}, 
   {        (char_u )'-',        (char_u )'-',        (char_u )173}, 
   {        (char_u )'r',        (char_u )'O',        (char_u )174}, 
   {        (char_u )'-',        (char_u )'=',        (char_u )175}, 
   {        (char_u )'~',        (char_u )'o',        (char_u )176}, 
   {        (char_u )'+',        (char_u )'-',        (char_u )177}, 
   {        (char_u )'2',        (char_u )'2',        (char_u )178}, 
   {        (char_u )'3',        (char_u )'3',        (char_u )179}, 
   {        (char_u )'\'',        (char_u )'\'',        (char_u )180}, 
   {        (char_u )'j',        (char_u )'u',        (char_u )181}, 
   {        (char_u )'p',        (char_u )'p',        (char_u )182}, 
   {        (char_u )'~',        (char_u )'.',        (char_u )183}, 
   {        (char_u )',',        (char_u )',',        (char_u )184}, 
   {        (char_u )'1',        (char_u )'1',        (char_u )185}, 
   {        (char_u )'o',        (char_u )'-',        (char_u )186}, 
   {        (char_u )'>',        (char_u )'>',        (char_u )187}, 
   {        (char_u )'1',        (char_u )'4',        (char_u )188}, 
   {        (char_u )'1',        (char_u )'2',        (char_u )189}, 
   {        (char_u )'3',        (char_u )'4',        (char_u )190}, 
   {        (char_u )'~',        (char_u )'?',        (char_u )191}, 
   {        (char_u )'A',        (char_u )'`',        (char_u )192}, 
   {        (char_u )'A',        (char_u )'\'',        (char_u )193}, 
   {        (char_u )'A',        (char_u )'^',        (char_u )194}, 
   {        (char_u )'A',        (char_u )'~',        (char_u )195}, 
   {        (char_u )'A',        (char_u )'\"',        (char_u )196}, 
   {        (char_u )'A',        (char_u )'@',        (char_u )197}, 
   {        (char_u )'A',        (char_u )'A',        (char_u )197}, 
   {        (char_u )'A',        (char_u )'E',        (char_u )198}, 
   {        (char_u )'C',        (char_u )',',        (char_u )199}, 
   {        (char_u )'E',        (char_u )'`',        (char_u )200}, 
   {        (char_u )'E',        (char_u )'\'',        (char_u )201}, 
   {        (char_u )'E',        (char_u )'^',        (char_u )202}, 
   {        (char_u )'E',        (char_u )'\"',        (char_u )203}, 
   {        (char_u )'I',        (char_u )'`',        (char_u )204}, 
   {        (char_u )'I',        (char_u )'\'',        (char_u )205}, 
   {        (char_u )'I',        (char_u )'^',        (char_u )206}, 
   {        (char_u )'I',        (char_u )'\"',        (char_u )207}, 
   {        (char_u )'D',        (char_u )'-',        (char_u )208}, 
   {        (char_u )'N',        (char_u )'~',        (char_u )209}, 
   {        (char_u )'O',        (char_u )'`',        (char_u )210}, 
   {        (char_u )'O',        (char_u )'\'',        (char_u )211}, 
   {        (char_u )'O',        (char_u )'^',        (char_u )212}, 
   {        (char_u )'O',        (char_u )'~',        (char_u )213}, 
   {        (char_u )'O',        (char_u )'\"',        (char_u )214}, 
   {        (char_u )'/',        (char_u )'\\',        (char_u )215}, 
   {        (char_u )'O',        (char_u )'E',        (char_u )215}, 
   {        (char_u )'O',        (char_u )'/',        (char_u )216}, 
   {        (char_u )'U',        (char_u )'`',        (char_u )217}, 
   {        (char_u )'U',        (char_u )'\'',        (char_u )218}, 
   {        (char_u )'U',        (char_u )'^',        (char_u )219}, 
   {        (char_u )'U',        (char_u )'\"',        (char_u )220}, 
   {        (char_u )'Y',        (char_u )'\'',        (char_u )221}, 
   {        (char_u )'I',        (char_u )'p',        (char_u )222}, 
   {        (char_u )'s',        (char_u )'s',        (char_u )223}, 
   {        (char_u )'a',        (char_u )'`',        (char_u )224}, 
   {        (char_u )'a',        (char_u )'\'',        (char_u )225}, 
   {        (char_u )'a',        (char_u )'^',        (char_u )226}, 
   {        (char_u )'a',        (char_u )'~',        (char_u )227}, 
   {        (char_u )'a',        (char_u )'\"',        (char_u )228}, 
   {        (char_u )'a',        (char_u )'@',        (char_u )229}, 
   {        (char_u )'a',        (char_u )'a',        (char_u )229}, 
   {        (char_u )'a',        (char_u )'e',        (char_u )230}, 
   {        (char_u )'c',        (char_u )',',        (char_u )231}, 
   {        (char_u )'e',        (char_u )'`',        (char_u )232}, 
   {        (char_u )'e',        (char_u )'\'',        (char_u )233}, 
   {        (char_u )'e',        (char_u )'^',        (char_u )234}, 
   {        (char_u )'e',        (char_u )'\"',        (char_u )235}, 
   {        (char_u )'i',        (char_u )'`',        (char_u )236}, 
   {        (char_u )'i',        (char_u )'\'',        (char_u )237}, 
   {        (char_u )'i',        (char_u )'^',        (char_u )238}, 
   {        (char_u )'i',        (char_u )'\"',        (char_u )239}, 
   {        (char_u )'d',        (char_u )'-',        (char_u )240}, 
   {        (char_u )'n',        (char_u )'~',        (char_u )241}, 
   {        (char_u )'o',        (char_u )'`',        (char_u )242}, 
   {        (char_u )'o',        (char_u )'\'',        (char_u )243}, 
   {        (char_u )'o',        (char_u )'^',        (char_u )244}, 
   {        (char_u )'o',        (char_u )'~',        (char_u )245}, 
   {        (char_u )'o',        (char_u )'\"',        (char_u )246}, 
   {        (char_u )':',        (char_u )'-',        (char_u )247}, 
   {        (char_u )'o',        (char_u )'e',        (char_u )247}, 
   {        (char_u )'o',        (char_u )'/',        (char_u )248}, 
   {        (char_u )'u',        (char_u )'`',        (char_u )249}, 
   {        (char_u )'u',        (char_u )'\'',        (char_u )250}, 
   {        (char_u )'u',        (char_u )'^',        (char_u )251}, 
   {        (char_u )'u',        (char_u )'\"',        (char_u )252}, 
   {        (char_u )'y',        (char_u )'\'',        (char_u )253}, 
   {        (char_u )'i',        (char_u )'p',        (char_u )254}, 
   {        (char_u )'y',        (char_u )'\"',        (char_u )255}, 
   {        (char_u )'\000',        (char_u )'\000',        (char_u )'\000'}};
static int backspaced  ;
static int lastchar  ;
int do_digraph(int c ) 
{ 


  {
  if (c == -1) {
    backspaced = -1;
  } else { //Added block
  if (p_dg) {
    if (backspaced >= 0) {
      {
      c = getdigraph(backspaced, c, 0);
      }
    }
    backspaced = -1;
    if (c == 107 + (98 << 8)) {
      goto _L;
    } else { //Added block
    if (c == 8) {
      _L: 
      if (lastchar >= 0) {
        backspaced = lastchar;
      }
    }
    }
  }
  }
  lastchar = c;
  return (c);
}
}
static int getexactdigraph(int char1 , int char2 , int meta ) 
{ 
  int i___0 ;
  int retval ;

  {
  if (char1 >= 512) {
    return (char2);
  } else { //Added block
  if (char2 >= 512) {
    return (char2);
  }
  }
  retval = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i___0 == digraphcount) {
      i___0 = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((int )digraphdefault[i___0][0] != 0)) {
          goto while_break___0;
        }
        if ((int )digraphdefault[i___0][0] == char1) {
          if ((int )digraphdefault[i___0][1] == char2) {
            retval = (int )digraphdefault[i___0][2];
            goto while_break___0;
          }
        }
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      goto while_break;
    }
    if ((int )(*(digraphnew + i___0))[0] == char1) {
      if ((int )(*(digraphnew + i___0))[1] == char2) {
        retval = (int )(*(digraphnew + i___0))[2];
        goto while_break;
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (retval == 0) {
    if (char1 == 32) {
      if (meta) {
        return (char2 | 128);
      }
    }
    return (char2);
  }
  return (retval);
}
}
int getdigraph(int char1 , int char2 , int meta ) 
{ 
  int retval ;

  {
  {
  retval = getexactdigraph(char1, char2, meta);
  }
  if (retval == char2) {
    if (char1 != char2) {
      {
      retval = getexactdigraph(char2, char1, meta);
      }
      if (retval == char1) {
        return (char2);
      }
    }
  }
  return (retval);
}
}
void putdigraph(char_u *str___1 ) 
{ 
  int char1 ;
  int char2 ;
  int n ;
  char_u (*newtab)[3] ;
  int i___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  unsigned short const   **tmp___1 ;
  long tmp___2 ;
  char_u *tmp___3 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *str___1) {
      goto while_break;
    }
    {
    str___1 = skipwhite(str___1);
    tmp = str___1;
    str___1 ++;
    char1 = (int )*tmp;
    }
    if (char1 == 0) {
      return;
    } else {
      tmp___0 = str___1;
      str___1 ++;
      char2 = (int )*tmp___0;
      if (char2 == 0) {
        return;
      }
    }
    if (char1 == 27) {
      {
      emsg((char_u *)"Escape not allowed in digraph");
      }
      return;
    } else { //Added block
    if (char2 == 27) {
      {
      emsg((char_u *)"Escape not allowed in digraph");
      }
      return;
    }
    }
    {
    str___1 = skipwhite(str___1);
    tmp___1 = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp___1 + (int )*str___1) & 2048)) {
      {
      emsg(e_number);
      }
      return;
    }
    {
    tmp___2 = getdigits(& str___1);
    n = (int )tmp___2;
    }
    if (digraphnew) {
      i___0 = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i___0 < digraphcount)) {
          goto while_break___0;
        }
        if ((int )(*(digraphnew + i___0))[0] == char1) {
          if ((int )(*(digraphnew + i___0))[1] == char2) {
            (*(digraphnew + i___0))[2] = (char_u )n;
            goto while_break___0;
          }
        }
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (i___0 < digraphcount) {
        goto while_continue;
      }
    }
    {
    tmp___3 = alloc((unsigned int )(digraphcount * 3 + 3));
    newtab = (char_u (*)[3])tmp___3;
    }
    if (newtab) {
      {
      memmove((void *)((char *)newtab), (void const   *)((char *)digraphnew), (size_t )(digraphcount * 3));
      vim_free((void *)digraphnew);
      digraphnew = newtab;
      (*(digraphnew + digraphcount))[0] = (char_u )char1;
      (*(digraphnew + digraphcount))[1] = (char_u )char2;
      (*(digraphnew + digraphcount))[2] = (char_u )n;
      digraphcount ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void listdigraphs(void) 
{ 
  int i___0 ;
  int tmp ;

  {
  {
  msg_putchar('\n');
  printdigraph((char_u *)((void *)0));
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (digraphdefault[i___0][0]) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = getexactdigraph((int )digraphdefault[i___0][0], (int )digraphdefault[i___0][1],
                          0);
    }
    if (tmp == (int )digraphdefault[i___0][2]) {
      {
      printdigraph(digraphdefault[i___0]);
      }
    }
    {
    ui_breakcheck();
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (i___0 < digraphcount) {
      if (! (! got_int)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    printdigraph(*(digraphnew + i___0));
    ui_breakcheck();
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  must_redraw = 50;
  return;
}
}
static int len  ;
static void printdigraph(char_u *p___0 ) 
{ 
  char_u buf___3[9] ;

  {
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    len = 0;
  } else { //Added block
  if ((int )*(p___0 + 2) != 0) {
    if ((long )len > Columns - 11L) {
      {
      msg_putchar('\n');
      len = 0;
      }
    }
    if (len) {
      {
      msg_puts((char_u *)"   ");
      }
    }
    {
    sprintf((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )"%c%c %c %3d",
            (int )*(p___0 + 0), (int )*(p___0 + 1), (int )*(p___0 + 2), (int )*(p___0 + 2));
    msg_puts(buf___3);
    len += 11;
    }
  }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-oAbd5Qx5.i","-O0")
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
char_u *NextScreen ;
int mod_mask ;
int redraw_cmdline ;
int clear_cmdline ;
colnr_t dollar_vcol ;
int completion_length ;
int continue_status ;
int completion_interrupted ;
int emsg_on_display ;
int intr_char ;
int highlight_attr[18]  ;
int sc_col  ;
int sandbox ;
FPOS where_paste_started  ;
int did_ai ;
colnr_t ai_col ;
int end_comment_pending ;
int did_si ;
int can_si ;
int can_si_back ;
FPOS Insstart  ;
int orig_line_count ;
int vr_lines_changed ;
colnr_t vr_virtcol ;
int Recording ;
int no_mapping ;
int allow_keys ;
int no_u_sync ;
int restart_edit ;
int arrow_used  ;
char_u *edit_submode ;
char_u *edit_submode_extra ;
enum hlf_value edit_submode_highl  ;
int ctrl_x_mode ;
int no_abbr ;
int fo_do_comments ;
int typelen  ;
int global_busy ;
int replace_offset ;
int no_hlsearch ;
char_u e_internal[15] ;
char_u e_noinstext[21] ;
char_u e_patnotf[18] ;
char_u e_sandbox[23] ;
char_u *p_cpo  ;
char_u *p_dict  ;
int p_hls  ;
int p_ic  ;
int p_im  ;
int p_js  ;
char_u *p_km  ;
int p_paste  ;
long p_so  ;
int p_sm  ;
int p_smd  ;
int p_scs  ;
int p_sta  ;
char_u *p_ww  ;
int p_ws  ;
int edit(int cmdchar , int startln , long count___2 ) ;
void display_dollar(colnr_t col ) ;
void change_indent(int type , int amount , int round , int replaced ) ;
void truncate_spaces(char_u *line ) ;
void backspace_until_column(int col ) ;
int vim_is_ctrl_x_key(int c ) ;
int ins_compl_add_infercase(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                            int reuse ) ;
void ins_compl_check_keys(void) ;
int get_literal(void) ;
void insertchar(unsigned int c , int force_formatting , int second_indent , int ctrlv ) ;
int comp_textwidth(int ff ) ;
void stop_arrow(void) ;
void set_last_insert(int c ) ;
void beginline(int flags___0 ) ;
int oneright(void) ;
int oneleft(void) ;
int cursor_up(long n , int upd_topline ) ;
int cursor_down(long n , int upd_topline ) ;
int stuff_inserted(int c , long count___2 , int no_esc ) ;
char_u *get_last_insert(void) ;
char_u *get_last_insert_save(void) ;
void replace_push(int c ) ;
int get_replace_stack_virtcol(void) ;
void fixthisline(int (*get_the_indent)(void) ) ;
int in_cinkeys(int keytyped , int when , int line_is_empty ) ;
void tilde_replace(char_u *orig_pat , int num_files , char_u **files ) ;
char_u *addstar(char_u *fname , int len___0 , int context ) ;
char_u *get_inserted(void) ;
int stuff_empty(void) ;
void ResetRedobuff(void) ;
void AppendToRedobuff(char_u *s ) ;
void AppendCharToRedobuff(int c ) ;
void AppendNumberToRedobuff(long n ) ;
void stuffReadbuff(char_u *s ) ;
void stuffcharReadbuff(int c ) ;
int start_redo_ins(void) ;
void stop_redo_ins(void) ;
int using_script(void) ;
int safe_vgetc(void) ;
int vpeekc(void) ;
int char_avail(void) ;
void vungetc(int c ) ;
int check_abbr(int c , char_u *ptr , int col , int mincol ) ;
char_u *ml_get_cursor(void) ;
int ml_replace(linenr_t lnum , char_u *line , int copy ) ;
int msg_attr(char_u *s , int attr ) ;
int get_indent(void) ;
void set_indent(int size , int del_first ) ;
int open_line(int dir , int redraw , int del_spaces , int old_indent___0 ) ;
int get_leader_len(char_u *line , char_u **flags___0 , int backward ) ;
void ins_char(int c ) ;
void ins_str(char_u *s ) ;
int del_char(int fixpos ) ;
int gchar_cursor(void) ;
void pchar_cursor(int c ) ;
int inindent(int extra ) ;
void change_warning(int col ) ;
void vim_beep(void) ;
int cin_islabel(int ind_maxcomment ) ;
int cin_iscase(char_u *s ) ;
int cin_isscopedecl(char_u *s ) ;
int get_c_indent(void) ;
void line_breakcheck(void) ;
int expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                     int flags___0 ) ;
void FreeWild(int num , char_u **file ) ;
int goto_im(void) ;
int coladvance(colnr_t wcol ) ;
int inc_cursor(void) ;
int dec_cursor(void) ;
int dec(FPOS *lp ) ;
char_u *lalloc(long_u size , int message ) ;
char_u *vim_strnsave(char_u *string___0 , int len___0 ) ;
int copy_option_part(char_u **option , char_u *buf___3 , int maxlen , char *sep_chars ) ;
char_u *get_special_key_name(int c , int modifiers ) ;
int get_special_key_code(char_u *name___1 ) ;
int do_mouse(OPARG *oap , int c , int dir , long count___2 , int fix_indent ) ;
void clear_showcmd(void) ;
int add_to_showcmd(int c ) ;
void add_to_showcmd_c(int c ) ;
void do_check_scrollbind(int check ) ;
void scroll_redraw(int up , long count___2 ) ;
void start_selection(void) ;
void shift_line(int left , int round , int amount ) ;
int get_expr_register(void) ;
int insert_reg(int regname___0 , int literally ) ;
void do_put(int regname___0 , int dir , long count___2 , int flags___0 ) ;
int do_join(int insert_space , int redraw ) ;
int has_format_option(int x___0 ) ;
int can_bs(int what ) ;
void update_screenline(void) ;
void redraw_later(int type ) ;
void redraw_statuslines(void) ;
void win_redr_status(WIN *wp ) ;
void screen_putchar(int c , int row , int col , int attr ) ;
void update_topline(void) ;
void update_curswant(void) ;
void setcursor(void) ;
void changed_cline_bef_curs(void) ;
void set_topline(WIN *wp , linenr_t lnum ) ;
void validate_cursor(void) ;
void validate_cursor_col(void) ;
void curs_columns(int scroll ) ;
void scrolldown_clamp(void) ;
void scrollup_clamp(void) ;
int showmode(void) ;
void showruler(int always ) ;
void check_for_delay(int check_msg_scroll ) ;
int redrawing(void) ;
int onepage(int dir , long count___2 ) ;
void set_reg_ic(char_u *pat ) ;
int searchit(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *str___1 , long count___2 ,
             int options___0 , int pat_use ) ;
int search_for_exact_line(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *pat ) ;
FPOS *findmatch(OPARG *oap , int initc ) ;
int fwd_word(long count___2 , int type , int eol ) ;
int bck_word(long count___2 , int type , int stop ) ;
int linewhite(linenr_t lnum ) ;
void find_pattern_in_path(char_u *ptr , int dir , int len___0 , int whole , int skip_comments ,
                          int type , long count___2 , int action , linenr_t start_lnum ,
                          linenr_t end_lnum ) ;
void syn_changed(linenr_t lnum ) ;
int syntax_present(BUF *buf___3 ) ;
int find_tags(char_u *pat , int *num_matches___0 , char_u ***matchesp , int flags___0 ,
              int mincount ) ;
void setmouse(void) ;
int mouse_has(int c ) ;
void cursor_off(void) ;
int u_save_cursor(void) ;
int u_save(linenr_t top , linenr_t bot ) ;
static char *ctrl_x_msgs[10]  = 
  {      (char *)" Adding Keyword completion (^N/^P)",      (char *)" ^X mode (^E/^Y/^L/^]/^F/^I/^K/^D/^N/^P)",      (char *)" Adding Keyword Local completion (^N/^P)",      (char *)" Adding Whole line completion (^L/^N/^P)", 
        (char *)" Adding File name completion (^F/^N/^P)",      (char *)" Adding Tag completion (^]/^N/^P)",      (char *)" Adding Path pattern completion (^N/^P)",      (char *)" Adding Definition completion (^D/^N/^P)", 
        (char *)((void *)0),      (char *)" Adding Dictionary completion (^K/^N/^P)"};
static char_u e_hitend[21]  = 
  {      (char_u )'H',      (char_u )'i',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'o',      (char_u )'f',      (char_u )' ',      (char_u )'p', 
        (char_u )'a',      (char_u )'r',      (char_u )'a',      (char_u )'g', 
        (char_u )'r',      (char_u )'a',      (char_u )'p',      (char_u )'h', 
        (char_u )'\000'};
static struct Completion *first_match  =    (struct Completion *)((void *)0);
static struct Completion *curr_match  =    (struct Completion *)((void *)0);
static struct Completion *shown_match  =    (struct Completion *)((void *)0);
static int started_completion  =    0;
static char_u *complete_pat  =    (char_u *)((void *)0);
static int complete_direction  =    1;
static int shown_direction  =    1;
static int completion_pending  =    0;
static FPOS initial_pos  ;
static colnr_t complete_col  =    (colnr_t )0;
static int save_sm  ;
static char_u *original_text  =    (char_u *)((void *)0);
static int continue_mode  =    0;
static int ins_compl_add(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                         int reuse ) ;
static int ins_compl_make_cyclic(void) ;
static void ins_compl_dictionaries(char_u *dict , char_u *pat , int dir , int flags___0 ) ;
static void ins_compl_free(void) ;
static void ins_compl_clear(void) ;
static int ins_compl_prep(int c ) ;
static BUF *ins_compl_next_buf(BUF *buf___3 , int flag ) ;
static int ins_compl_get_exp(FPOS *ini , int dir ) ;
static void ins_compl_delete(void) ;
static void ins_compl_insert(void) ;
static int ins_compl_next(int allow_get_expansion ) ;
static int ins_complete(int c ) ;
static int quote_meta(char_u *dest , char_u *src , int len___0 ) ;
static void edit_putchar(int c , int highlight ) ;
static void undisplay_dollar(void) ;
static void insert_special(int c , int allow_modmask , int ctrlv ) ;
static void redo_literal(int c ) ;
static void start_arrow(FPOS *end_insert_pos ) ;
static void stop_insert(FPOS *end_insert_pos ) ;
static int echeck_abbr(int c ) ;
static void replace_push_off(int c ) ;
static int replace_pop(void) ;
static void replace_join(int off___0 ) ;
static void replace_pop_ins(void) ;
static void replace_flush(void) ;
static void replace_do_bs(void) ;
static int ins_reg(void) ;
static int ins_esc(long *count___2 , int need_redraw , int cmdchar ) ;
static void ins_shift(int c , int lastc___1 ) ;
static void ins_del(void) ;
static int ins_bs(int c , int mode , int *inserted_space_p ) ;
static void ins_mouse(int c ) ;
static void ins_mousescroll(int up ) ;
static void ins_left(void) ;
static void ins_home(void) ;
static void ins_end(void) ;
static void ins_s_left(void) ;
static void ins_right(void) ;
static void ins_s_right(void) ;
static void ins_up(void) ;
static void ins_pageup(void) ;
static void ins_down(void) ;
static void ins_pagedown(void) ;
static int ins_tab(void) ;
static int ins_eol(int c ) ;
static int ins_digraph(void) ;
static int ins_copychar(linenr_t lnum ) ;
static void ins_try_si(int c ) ;
static colnr_t get_nolist_virtcol(void) ;
static colnr_t Insstart_textlen  ;
static colnr_t Insstart_blank_vcol  ;
static char_u *last_insert  =    (char_u *)((void *)0);
static int last_insert_skip  ;
static int new_insert_skip  ;
static int can_cindent  ;
static int old_indent  =    0;
static linenr_t o_lnum  =    (linenr_t )0;
static int o_eol  =    0;
int edit(int cmdchar , int startln , long count___2 ) 
{ 
  int c ;
  char_u *ptr ;
  int lastc___1 ;
  colnr_t mincol ;
  int need_redraw ;
  int i___0 ;
  int did_backspace ;
  int line_is_white ;
  linenr_t old_topline___0 ;
  int inserted_space ;
  int has_startsel ;
  int replaceState ;
  int did_restart_edit ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char_u buf___3[4] ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  long tw_save ;
  unsigned short const   **tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
  {
  c = 0;
  need_redraw = 0;
  did_backspace = 1;
  line_is_white = 0;
  old_topline___0 = (linenr_t )0;
  inserted_space = 0;
  replaceState = 528;
  did_restart_edit = restart_edit;
  check_for_delay(1);
  }
  if (sandbox != 0) {
    {
    emsg(e_sandbox);
    }
    return (0);
  }
  {
  ins_compl_clear();
  }
  if (where_paste_started.lnum != 0L) {
    Insstart = where_paste_started;
  } else {
    Insstart = curwin->w_cursor;
    if (startln) {
      Insstart.col = (colnr_t )0;
    }
  }
  {
  tmp = ml_get_curline();
  tmp___0 = linetabsize(tmp);
  Insstart_textlen = (colnr_t )tmp___0;
  Insstart_blank_vcol = (colnr_t )2147483647;
  }
  if (! did_ai) {
    ai_col = (colnr_t )0;
  }
  if (cmdchar != 0) {
    if (! restart_edit) {
      {
      ResetRedobuff();
      AppendNumberToRedobuff(count___2);
      }
      if (cmdchar == 86) {
        goto _L;
      } else { //Added block
      if (cmdchar == 118) {
        _L: 
        {
        AppendCharToRedobuff('g');
        }
        if (cmdchar == 118) {
          tmp___1 = 'r';
        } else {
          tmp___1 = 'R';
        }
        {
        AppendCharToRedobuff(tmp___1);
        }
      } else {
        {
        AppendCharToRedobuff(cmdchar);
        }
        if (cmdchar == 103) {
          {
          AppendCharToRedobuff('I');
          }
        } else { //Added block
        if (cmdchar == 114) {
          count___2 = 1L;
        }
        }
      }
      }
    }
  }
  if (cmdchar == 82) {
    State = 528;
  } else { //Added block
  if (cmdchar == 86) {
    State = 784;
    replaceState = 784;
    orig_line_count = (int )curbuf->b_ml.ml_line_count;
    vr_lines_changed = 1;
    vr_virtcol = (colnr_t )2147483647;
  } else { //Added block
  if (cmdchar == 118) {
    State = 784;
    replaceState = 784;
    orig_line_count = (int )curbuf->b_ml.ml_line_count;
    vr_lines_changed = 1;
    vr_virtcol = (colnr_t )2147483647;
  } else {
    State = 16;
  }
  }
  }
  {
  curs_columns(1);
  setmouse();
  clear_showcmd();
  tmp___2 = vim_strchr(p_km, 'a');
  has_startsel = (unsigned long )tmp___2 != (unsigned long )((void *)0);
  }
  if (restart_edit) {
    {
    tmp___4 = stuff_empty();
    }
    if (tmp___4) {
      if (where_paste_started.lnum) {
        arrow_used = 0;
      } else {
        arrow_used = 1;
      }
      {
      restart_edit = 0;
      validate_virtcol();
      update_curswant();
      }
      if (o_eol) {
        if (curwin->w_cursor.lnum == o_lnum) {
          goto _L___0;
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (curwin->w_curswant > curwin->w_virtcol) {
        _L___0: 
        {
        tmp___3 = ml_get_curline();
        ptr = tmp___3 + curwin->w_cursor.col;
        }
        if ((int )*ptr != 0) {
          if ((int )*(ptr + 1) == 0) {
            (curwin->w_cursor.col) ++;
          }
        }
      }
      }
    } else {
      arrow_used = 0;
      o_eol = 0;
    }
  } else {
    arrow_used = 0;
    o_eol = 0;
  }
  where_paste_started.lnum = (linenr_t )0;
  can_cindent = 1;
  i___0 = 0;
  if (p_smd) {
    {
    i___0 = showmode();
    }
  }
  if (! p_im) {
    if (! did_restart_edit) {
      {
      change_warning(i___0 + 1);
      }
    }
  }
  {
  do_digraph(-1);
  ptr = get_inserted();
  }
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    new_insert_skip = 0;
  } else {
    {
    tmp___5 = strlen((char const   *)((char *)ptr));
    new_insert_skip = (int )tmp___5;
    vim_free((void *)ptr);
    }
  }
  old_indent = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (arrow_used) {
      count___2 = 0L;
    }
    if (! arrow_used) {
      curwin->w_set_curswant = 1;
    }
    msg_scroll = 0;
    if (need_redraw) {
      if (curwin->w_p_wrap) {
        if (! did_backspace) {
          if (curwin->w_topline == old_topline___0) {
            {
            mincol = (colnr_t )curwin->w_wcol;
            validate_cursor_col();
            }
            if ((long )curwin->w_wcol < (long )((int )mincol) - curbuf->b_p_ts) {
              if ((long )curwin->w_wrow == (long )((curwin->w_winpos + curwin->w_height) - 1) - p_so) {
                if (curwin->w_cursor.lnum != curwin->w_topline) {
                  {
                  set_topline(curwin, curwin->w_topline + 1L);
                  update_topline();
                  syn_changed(curwin->w_cursor.lnum);
                  update_screen(30);
                  need_redraw = 0;
                  }
                } else {
                  {
                  update_topline();
                  }
                }
              } else {
                {
                update_topline();
                }
              }
            } else {
              {
              update_topline();
              }
            }
          } else {
            {
            update_topline();
            }
          }
        } else {
          {
          update_topline();
          }
        }
      } else {
        {
        update_topline();
        }
      }
    } else {
      {
      update_topline();
      }
    }
    {
    did_backspace = 0;
    validate_cursor();
    }
    if (need_redraw) {
      goto _L___2;
    } else { //Added block
    if (must_redraw) {
      _L___2: 
      {
      update_screenline();
      }
      if (curwin->w_redr_status == 1) {
        {
        win_redr_status(curwin);
        }
      }
      need_redraw = 0;
    } else { //Added block
    if (clear_cmdline) {
      {
      showmode();
      }
    } else { //Added block
    if (redraw_cmdline) {
      {
      showmode();
      }
    }
    }
    }
    }
    if (curwin->w_p_scb) {
      {
      do_check_scrollbind(1);
      }
    }
    {
    showruler(0);
    setcursor();
    update_curswant();
    emsg_on_display = 0;
    old_topline___0 = curwin->w_topline;
    lastc___1 = c;
    c = safe_vgetc();
    tmp___6 = ins_compl_prep(c);
    need_redraw |= tmp___6;
    }
    if (c == 28) {
      {
      c = safe_vgetc();
      }
      if (c != 14) {
        {
        vungetc(c);
        c = 28;
        }
      } else {
        count___2 = 0L;
        goto doESCkey;
      }
    }
    {
    c = do_digraph(c);
    }
    if (c == 22) {
      goto _L___3;
    } else { //Added block
    if (c == 17) {
      _L___3: 
      {
      tmp___7 = redrawing();
      }
      if (tmp___7) {
        {
        tmp___8 = char_avail();
        }
        if (! tmp___8) {
          {
          edit_putchar('^', 1);
          }
        }
      }
      {
      AppendToRedobuff((char_u *)"\026");
      add_to_showcmd_c(c);
      c = get_literal();
      clear_showcmd();
      insert_special(c, 0, 1);
      need_redraw = 1;
      c = 22;
      }
      goto __Cont;
    }
    }
    if (curbuf->b_p_cin) {
      if (! ctrl_x_mode) {
        {
        line_is_white = inindent(0);
        tmp___9 = in_cinkeys(c, '!', line_is_white);
        }
        if (tmp___9) {
          goto force_cindent;
        }
        if (can_cindent) {
          {
          tmp___10 = in_cinkeys(c, '*', line_is_white);
          }
          if (tmp___10) {
            {
            stop_arrow();
            fixthisline(& get_c_indent);
            need_redraw = 1;
            }
          }
        }
      }
    }
    if (has_startsel) {
      {
      if (c == 75 + (49 << 8)) {
        goto case_exp;
      }
      if (c == 253 + (60 << 8)) {
        goto case_exp;
      }
      if (c == 75 + (52 << 8)) {
        goto case_exp;
      }
      if (c == 253 + (59 << 8)) {
        goto case_exp;
      }
      if (c == 107 + (80 << 8)) {
        goto case_exp;
      }
      if (c == 75 + (51 << 8)) {
        goto case_exp;
      }
      if (c == 107 + (78 << 8)) {
        goto case_exp;
      }
      if (c == 75 + (53 << 8)) {
        goto case_exp;
      }
      if (c == 35 + (52 << 8)) {
        goto case_exp___7;
      }
      if (c == 37 + (105 << 8)) {
        goto case_exp___7;
      }
      if (c == 253 + (4 << 8)) {
        goto case_exp___7;
      }
      if (c == 253 + (5 << 8)) {
        goto case_exp___7;
      }
      if (c == 42 + (55 << 8)) {
        goto case_exp___7;
      }
      if (c == 35 + (50 << 8)) {
        goto case_exp___7;
      }
      goto switch_break;
      case_exp: /* CIL Label */ 
      case_exp___0: /* CIL Label */ 
      case_exp___1: /* CIL Label */ 
      case_exp___2: /* CIL Label */ 
      case_exp___3: /* CIL Label */ 
      case_exp___4: /* CIL Label */ 
      case_exp___5: /* CIL Label */ 
      case_exp___6: /* CIL Label */ 
      if (! (mod_mask & 2)) {
        goto switch_break;
      }
      case_exp___7: /* CIL Label */ 
      case_exp___8: /* CIL Label */ 
      case_exp___9: /* CIL Label */ 
      case_exp___10: /* CIL Label */ 
      case_exp___11: /* CIL Label */ 
      case_exp___12: /* CIL Label */ 
      {
      start_selection();
      stuffcharReadbuff(15);
      }
      if (c != 35 + (52 << 8)) {
        goto _L___4;
      } else {
        {
        tmp___11 = gchar_cursor();
        }
        if (tmp___11 != 0) {
          _L___4: 
          if (mod_mask) {
            {
            buf___3[0] = (char_u )128;
            buf___3[1] = (char_u )252;
            buf___3[2] = (char_u )mod_mask;
            buf___3[3] = (char_u )'\000';
            stuffReadbuff(buf___3);
            }
          }
          {
          stuffcharReadbuff(c);
          }
        }
      }
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
    }
    {
    if (c == 107 + (73 << 8)) {
      goto case_exp___13;
    }
    if (c == 253 + (69 << 8)) {
      goto case_exp___13;
    }
    if (c == 24) {
      goto case_24;
    }
    if (c == 245 + (88 << 8)) {
      goto case_exp___15;
    }
    if (c == 26) {
      goto case_26;
    }
    if (c == 15) {
      goto case_15;
    }
    if (c == 37 + (49 << 8)) {
      goto case_exp___16;
    }
    if (c == 107 + (49 << 8)) {
      goto case_exp___16;
    }
    if (c == 253 + (55 << 8)) {
      goto case_exp___16;
    }
    if (c == 27) {
      goto case_27;
    }
    if (c == 3) {
      goto do_intr;
    }
    if (c == 255 + (88 << 8)) {
      goto case_exp___19;
    }
    if (c == 0) {
      goto case_exp___19;
    }
    if (c == 1) {
      goto case_exp___19;
    }
    if (c == 18) {
      goto case_18;
    }
    if (c == 4) {
      goto case_4;
    }
    if (c == 20) {
      goto case_20;
    }
    if (c == 107 + (68 << 8)) {
      goto case_exp___20;
    }
    if (c == 253 + (70 << 8)) {
      goto case_exp___20;
    }
    if (c == 107 + (98 << 8)) {
      goto case_exp___22;
    }
    if (c == 8) {
      goto case_exp___22;
    }
    if (c == 23) {
      goto case_23;
    }
    if (c == 21) {
      goto case_21;
    }
    if (c == 253 + (42 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (61 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (43 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (44 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (62 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (45 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (46 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (47 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (48 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (49 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (50 << 8)) {
      goto case_exp___23;
    }
    if (c == 253 + (51 << 8)) {
      goto case_exp___34;
    }
    if (c == 253 + (67 << 8)) {
      goto case_exp___35;
    }
    if (c == 253 + (68 << 8)) {
      goto case_exp___36;
    }
    if (c == 107 + (104 << 8)) {
      goto case_exp___37;
    }
    if (c == 75 + (49 << 8)) {
      goto case_exp___37;
    }
    if (c == 253 + (60 << 8)) {
      goto case_exp___37;
    }
    if (c == 35 + (50 << 8)) {
      goto case_exp___37;
    }
    if (c == 64 + (55 << 8)) {
      goto case_exp___41;
    }
    if (c == 75 + (52 << 8)) {
      goto case_exp___41;
    }
    if (c == 253 + (59 << 8)) {
      goto case_exp___41;
    }
    if (c == 42 + (55 << 8)) {
      goto case_exp___41;
    }
    if (c == 107 + (108 << 8)) {
      goto case_exp___45;
    }
    if (c == 35 + (52 << 8)) {
      goto case_exp___46;
    }
    if (c == 107 + (114 << 8)) {
      goto case_exp___47;
    }
    if (c == 37 + (105 << 8)) {
      goto case_exp___48;
    }
    if (c == 107 + (117 << 8)) {
      goto case_exp___49;
    }
    if (c == 253 + (4 << 8)) {
      goto case_exp___50;
    }
    if (c == 107 + (80 << 8)) {
      goto case_exp___50;
    }
    if (c == 75 + (51 << 8)) {
      goto case_exp___50;
    }
    if (c == 107 + (100 << 8)) {
      goto case_exp___53;
    }
    if (c == 253 + (5 << 8)) {
      goto case_exp___54;
    }
    if (c == 107 + (78 << 8)) {
      goto case_exp___54;
    }
    if (c == 75 + (53 << 8)) {
      goto case_exp___54;
    }
    if (c == 75 + (54 << 8)) {
      goto case_exp___57;
    }
    if (c == 75 + (55 << 8)) {
      goto case_exp___58;
    }
    if (c == 75 + (56 << 8)) {
      goto case_exp___59;
    }
    if (c == 75 + (57 << 8)) {
      goto case_exp___60;
    }
    if (c == 253 + (53 << 8)) {
      goto case_exp___61;
    }
    if (c == 9) {
      goto case_9;
    }
    if (c == 75 + (65 << 8)) {
      goto case_exp___62;
    }
    if (c == 13) {
      goto case_13;
    }
    if (c == 10) {
      goto case_13;
    }
    if (c == 11) {
      goto case_11;
    }
    if (c == 29) {
      goto case_29;
    }
    if (c == 6) {
      goto case_6;
    }
    if (c == 12) {
      goto case_12;
    }
    if (c == 16) {
      goto case_16;
    }
    if (c == 14) {
      goto case_16;
    }
    if (c == 25) {
      goto case_25;
    }
    if (c == 5) {
      goto case_25;
    }
    goto switch_default;
    case_exp___13: /* CIL Label */ 
    case_exp___14: /* CIL Label */ 
    if (State == replaceState) {
      State = 16;
    } else {
      State = replaceState;
    }
    {
    AppendCharToRedobuff(107 + (73 << 8));
    showmode();
    }
    goto switch_break___0;
    case_24: /* CIL Label */ 
    if (continue_status & 4) {
      continue_status |= 6;
    } else {
      continue_status = 0;
    }
    {
    ctrl_x_mode = 1;
    edit_submode = (char_u *)ctrl_x_msgs[ctrl_x_mode & 15];
    showmode();
    }
    goto switch_break___0;
    case_exp___15: /* CIL Label */ 
    goto switch_break___0;
    case_26: /* CIL Label */ 
    if (! p_im) {
      goto normalchar;
    }
    {
    stuffReadbuff((char_u *)":st\r");
    c = 15;
    }
    case_15: /* CIL Label */ 
    {
    tmp___12 = echeck_abbr(271);
    }
    if (tmp___12) {
      goto switch_break___0;
    }
    count___2 = 0L;
    if (State == 16) {
      restart_edit = 'I';
    } else { //Added block
    if (State == 784) {
      restart_edit = 'V';
    } else {
      restart_edit = 'R';
    }
    }
    {
    o_lnum = curwin->w_cursor.lnum;
    tmp___13 = gchar_cursor();
    o_eol = tmp___13 == 0;
    }
    goto doESCkey;
    case_exp___16: /* CIL Label */ 
    case_exp___17: /* CIL Label */ 
    case_exp___18: /* CIL Label */ 
    {
    stuffcharReadbuff(37 + (49 << 8));
    }
    if (p_im) {
      {
      stuffcharReadbuff('i');
      }
    }
    goto doESCkey;
    case_27: /* CIL Label */ 
    {
    tmp___14 = echeck_abbr(283);
    }
    if (tmp___14) {
      goto switch_break___0;
    }
    do_intr: 
    case_3: /* CIL Label */ 
    {
    tmp___15 = goto_im();
    }
    if (tmp___15) {
      if (got_int) {
        {
        vgetc();
        got_int = 0;
        }
      } else {
        {
        vim_beep();
        }
      }
      goto switch_break___0;
    }
    doESCkey: 
    {
    tmp___16 = ins_esc(& count___2, need_redraw, cmdchar);
    }
    if (tmp___16) {
      return (c == 15);
    }
    goto __Cont;
    case_exp___19: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
    tmp___17 = stuff_inserted('\000', 1L, c == 1);
    }
    if (tmp___17 == 0) {
      if (c != 1) {
        if (! p_im) {
          goto doESCkey;
        }
      }
    }
    inserted_space = 0;
    goto switch_break___0;
    case_18: /* CIL Label */ 
    {
    tmp___18 = ins_reg();
    need_redraw |= tmp___18;
    inserted_space = 0;
    }
    goto switch_break___0;
    case_4: /* CIL Label */ 
    if (ctrl_x_mode == 263) {
      goto docomplete;
    }
    case_20: /* CIL Label */ 
    {
    ins_shift(c, lastc___1);
    need_redraw = 1;
    inserted_space = 0;
    }
    goto switch_break___0;
    case_exp___20: /* CIL Label */ 
    case_exp___21: /* CIL Label */ 
    {
    ins_del();
    need_redraw = 1;
    }
    goto switch_break___0;
    case_exp___22: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
    did_backspace = ins_bs(c, 1, & inserted_space);
    need_redraw = 1;
    }
    goto switch_break___0;
    case_23: /* CIL Label */ 
    {
    did_backspace = ins_bs(c, 2, & inserted_space);
    need_redraw = 1;
    }
    goto switch_break___0;
    case_21: /* CIL Label */ 
    {
    did_backspace = ins_bs(c, 4, & inserted_space);
    need_redraw = 1;
    inserted_space = 0;
    }
    goto switch_break___0;
    case_exp___23: /* CIL Label */ 
    case_exp___24: /* CIL Label */ 
    case_exp___25: /* CIL Label */ 
    case_exp___26: /* CIL Label */ 
    case_exp___27: /* CIL Label */ 
    case_exp___28: /* CIL Label */ 
    case_exp___29: /* CIL Label */ 
    case_exp___30: /* CIL Label */ 
    case_exp___31: /* CIL Label */ 
    case_exp___32: /* CIL Label */ 
    case_exp___33: /* CIL Label */ 
    {
    ins_mouse(c);
    }
    goto switch_break___0;
    case_exp___34: /* CIL Label */ 
    goto switch_break___0;
    case_exp___35: /* CIL Label */ 
    {
    ins_mousescroll(0);
    }
    goto switch_break___0;
    case_exp___36: /* CIL Label */ 
    {
    ins_mousescroll(1);
    }
    goto switch_break___0;
    case_exp___37: /* CIL Label */ 
    case_exp___38: /* CIL Label */ 
    case_exp___39: /* CIL Label */ 
    case_exp___40: /* CIL Label */ 
    {
    ins_home();
    }
    goto switch_break___0;
    case_exp___41: /* CIL Label */ 
    case_exp___42: /* CIL Label */ 
    case_exp___43: /* CIL Label */ 
    case_exp___44: /* CIL Label */ 
    {
    ins_end();
    }
    goto switch_break___0;
    case_exp___45: /* CIL Label */ 
    if (mod_mask & 4) {
      {
      ins_s_left();
      }
    } else {
      {
      ins_left();
      }
    }
    goto switch_break___0;
    case_exp___46: /* CIL Label */ 
    {
    ins_s_left();
    }
    goto switch_break___0;
    case_exp___47: /* CIL Label */ 
    if (mod_mask & 4) {
      {
      ins_s_right();
      }
    } else {
      {
      ins_right();
      }
    }
    goto switch_break___0;
    case_exp___48: /* CIL Label */ 
    {
    ins_s_right();
    }
    goto switch_break___0;
    case_exp___49: /* CIL Label */ 
    {
    ins_up();
    }
    goto switch_break___0;
    case_exp___50: /* CIL Label */ 
    case_exp___51: /* CIL Label */ 
    case_exp___52: /* CIL Label */ 
    {
    ins_pageup();
    }
    goto switch_break___0;
    case_exp___53: /* CIL Label */ 
    {
    ins_down();
    }
    goto switch_break___0;
    case_exp___54: /* CIL Label */ 
    case_exp___55: /* CIL Label */ 
    case_exp___56: /* CIL Label */ 
    {
    ins_pagedown();
    }
    goto switch_break___0;
    case_exp___57: /* CIL Label */ 
    c = '+';
    goto normalchar;
    case_exp___58: /* CIL Label */ 
    c = '-';
    goto normalchar;
    case_exp___59: /* CIL Label */ 
    c = '/';
    goto normalchar;
    case_exp___60: /* CIL Label */ 
    c = '*';
    goto normalchar;
    case_exp___61: /* CIL Label */ 
    c = '\t';
    case_9: /* CIL Label */ 
    if (ctrl_x_mode == 262) {
      goto docomplete;
    }
    {
    inserted_space = 0;
    tmp___19 = ins_tab();
    }
    if (tmp___19) {
      goto normalchar;
    }
    need_redraw = 1;
    goto switch_break___0;
    case_exp___62: /* CIL Label */ 
    c = '\r';
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
    tmp___20 = ins_eol(c);
    }
    if (tmp___20) {
      if (! p_im) {
        goto doESCkey;
      }
    }
    inserted_space = 0;
    goto switch_break___0;
    case_11: /* CIL Label */ 
    if (ctrl_x_mode == 265) {
      if ((int )*p_dict == 0) {
        {
        ctrl_x_mode = 0;
        msg_attr((char_u *)"\'dictionary\' option is empty", highlight_attr[3]);
        vim_beep();
        setcursor();
        out_flush();
        ui_delay(2000L, 0);
        }
        goto switch_break___0;
      }
      goto docomplete;
    }
    {
    c = ins_digraph();
    }
    if (c == 0) {
      need_redraw = 1;
      goto switch_break___0;
    }
    goto normalchar;
    case_29: /* CIL Label */ 
    if (ctrl_x_mode != 261) {
      goto normalchar;
    }
    goto docomplete;
    case_6: /* CIL Label */ 
    if (ctrl_x_mode != 4) {
      goto normalchar;
    }
    goto docomplete;
    case_12: /* CIL Label */ 
    if (ctrl_x_mode != 3) {
      if (p_im) {
        {
        tmp___21 = echeck_abbr(268);
        }
        if (tmp___21) {
          goto switch_break___0;
        }
        goto doESCkey;
      }
      goto normalchar;
    }
    case_16: /* CIL Label */ 
    case_14: /* CIL Label */ 
    if ((int )*(curbuf->b_p_cpt) == 0) {
      if (! ctrl_x_mode) {
        if (! (continue_status & 32)) {
          goto normalchar;
        }
      }
    }
    docomplete: 
    {
    i___0 = ins_complete(c);
    }
    if (i___0) {
      need_redraw |= i___0;
    } else {
      continue_status = 0;
    }
    goto switch_break___0;
    case_25: /* CIL Label */ 
    case_5: /* CIL Label */ 
    if (ctrl_x_mode == 2) {
      if (c == 25) {
        {
        scrolldown_clamp();
        }
      } else {
        {
        scrollup_clamp();
        }
      }
      {
      update_screen(10);
      }
    } else {
      if (c == 25) {
        tmp___22 = -1;
      } else {
        tmp___22 = 1;
      }
      {
      c = ins_copychar(curwin->w_cursor.lnum + (linenr_t )tmp___22);
      }
      if (c != 0) {
        {
        tmp___23 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___23 + c) & 8)) {
          {
          AppendToRedobuff((char_u *)"\026");
          }
        }
        {
        tw_save = curbuf->b_p_tw;
        curbuf->b_p_tw = -1L;
        insert_special(c, 1, 0);
        curbuf->b_p_tw = tw_save;
        need_redraw = 1;
        c = 22;
        }
      }
    }
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    if (c == intr_char) {
      goto do_intr;
    }
    normalchar: 
    {
    ins_try_si(c);
    }
    if (c == 32) {
      {
      inserted_space = 1;
      tmp___24 = inindent(0);
      }
      if (tmp___24) {
        can_cindent = 0;
      }
      if (Insstart_blank_vcol == 2147483647U) {
        if (curwin->w_cursor.lnum == Insstart.lnum) {
          {
          Insstart_blank_vcol = get_nolist_virtcol();
          }
        }
      }
    }
    {
    tmp___25 = vim_iswordc(c);
    }
    if (tmp___25) {
      {
      insert_special(c, 0, 0);
      need_redraw = 1;
      }
    } else {
      {
      tmp___26 = echeck_abbr(c);
      }
      if (! tmp___26) {
        {
        insert_special(c, 0, 0);
        need_redraw = 1;
        }
      }
    }
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    if (arrow_used) {
      inserted_space = 0;
    }
    if (curbuf->b_p_cin) {
      if (can_cindent) {
        if (! ctrl_x_mode) {
          force_cindent: 
          {
          tmp___27 = in_cinkeys(c, ' ', line_is_white);
          }
          if (tmp___27) {
            {
            stop_arrow();
            fixthisline(& get_c_indent);
            need_redraw = 1;
            }
          }
        }
      }
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
static void edit_putchar(int c , int highlight ) 
{ 
  int attr ;

  {
  if ((unsigned long )NextScreen != (unsigned long )((void *)0)) {
    {
    update_topline();
    validate_cursor();
    }
    if (highlight) {
      attr = highlight_attr[0];
    } else {
      attr = 0;
    }
    {
    screen_putchar(c, curwin->w_winpos + curwin->w_wrow, curwin->w_wcol, attr);
    }
  }
  return;
}
}
void display_dollar(colnr_t col ) 
{ 
  colnr_t save_col ;
  int tmp ;

  {
  {
  tmp = redrawing();
  }
  if (! tmp) {
    return;
  }
  {
  cursor_off();
  save_col = curwin->w_cursor.col;
  curwin->w_cursor.col = col;
  curs_columns(0);
  }
  if ((long )curwin->w_wcol < Columns) {
    {
    edit_putchar('$', 0);
    dollar_vcol = curwin->w_virtcol;
    }
  }
  curwin->w_cursor.col = save_col;
  return;
}
}
static void undisplay_dollar(void) 
{ 


  {
  if (dollar_vcol) {
    {
    dollar_vcol = (colnr_t )0;
    update_screenline();
    }
  }
  return;
}
}
void change_indent(int type , int amount , int round , int replaced ) 
{ 
  int vcol ;
  int last_vcol ;
  int insstart_less ;
  int new_cursor_col ;
  int i___0 ;
  char_u *ptr ;
  int save_p_list ;
  int start_col ;
  colnr_t vc ;
  colnr_t orig_col ;
  char_u *new_line ;
  char_u *orig_line ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;

  {
  orig_col = (colnr_t )0;
  orig_line = (char_u *)((void *)0);
  if (State == 784) {
    {
    tmp = ml_get_curline();
    orig_line = vim_strsave(tmp);
    orig_col = curwin->w_cursor.col;
    }
  }
  {
  save_p_list = curwin->w_p_list;
  curwin->w_p_list = 0;
  getvcol(curwin, & curwin->w_cursor, (colnr_t *)((void *)0), & vc, (colnr_t *)((void *)0));
  vcol = (int )vc;
  start_col = (int )curwin->w_cursor.col;
  new_cursor_col = (int )curwin->w_cursor.col;
  beginline(1);
  new_cursor_col = (int )((colnr_t )new_cursor_col - curwin->w_cursor.col);
  insstart_less = (int )curwin->w_cursor.col;
  }
  if (new_cursor_col < 0) {
    {
    tmp___0 = get_indent();
    vcol = tmp___0 - vcol;
    }
  }
  if (new_cursor_col > 0) {
    start_col = -1;
  }
  if (type == 1) {
    {
    set_indent(amount, 1);
    }
  } else {
    {
    shift_line(type == 3, round, 1);
    }
  }
  insstart_less = (int )((colnr_t )insstart_less - curwin->w_cursor.col);
  if (new_cursor_col >= 0) {
    if (new_cursor_col == 0) {
      insstart_less = 2147483647;
    }
    new_cursor_col = (int )((colnr_t )new_cursor_col + curwin->w_cursor.col);
  } else { //Added block
  if (! (State & 16)) {
    new_cursor_col = (int )curwin->w_cursor.col;
  } else {
    {
    tmp___1 = get_indent();
    vcol = tmp___1 - vcol;
    }
    if (vcol < 0) {
      curwin->w_virtcol = (colnr_t )0;
    } else {
      curwin->w_virtcol = (colnr_t )vcol;
    }
    {
    last_vcol = 0;
    vcol = last_vcol;
    new_cursor_col = -1;
    ptr = ml_get_curline();
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (vcol <= (int )curwin->w_virtcol)) {
        goto while_break;
      }
      {
      last_vcol = vcol;
      new_cursor_col ++;
      tmp___2 = lbr_chartabsize(ptr + new_cursor_col, (colnr_t )vcol);
      vcol += tmp___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
    vcol = last_vcol;
    if (vcol != (int )curwin->w_virtcol) {
      {
      curwin->w_cursor.col = (colnr_t )new_cursor_col;
      i___0 = (int )curwin->w_virtcol - vcol;
      ptr = alloc((unsigned int )(i___0 + 1));
      }
      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
        new_cursor_col += i___0;
        *(ptr + i___0) = (char_u )'\000';
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          i___0 --;
          if (! (i___0 >= 0)) {
            goto while_break___0;
          }
          *(ptr + i___0) = (char_u )' ';
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        ins_str(ptr);
        vim_free((void *)ptr);
        }
      }
    }
    insstart_less = 2147483647;
  }
  }
  curwin->w_p_list = save_p_list;
  if (new_cursor_col <= 0) {
    curwin->w_cursor.col = (colnr_t )0;
  } else {
    curwin->w_cursor.col = (colnr_t )new_cursor_col;
  }
  {
  curwin->w_set_curswant = 1;
  changed_cline_bef_curs();
  }
  if (State & 16) {
    if (curwin->w_cursor.lnum == Insstart.lnum) {
      if (Insstart.col != 0U) {
        if ((int )Insstart.col <= insstart_less) {
          Insstart.col = (colnr_t )0;
        } else {
          Insstart.col -= (colnr_t )insstart_less;
        }
      }
    }
    if ((int )ai_col <= insstart_less) {
      ai_col = (colnr_t )0;
    } else {
      ai_col -= (colnr_t )insstart_less;
    }
  }
  if (State == 528) {
    if (start_col >= 0) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (start_col > (int )curwin->w_cursor.col)) {
          goto while_break___1;
        }
        {
        replace_join(0);
        start_col --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (start_col < (int )curwin->w_cursor.col)) {
          if (! replaced) {
            goto while_break___2;
          }
        }
        {
        replace_push('\000');
        }
        if (replaced) {
          {
          replace_push(replaced);
          replaced = '\000';
          }
        }
        start_col ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  if (State == 784) {
    if ((unsigned long )orig_line == (unsigned long )((void *)0)) {
      return;
    }
    {
    tmp___3 = ml_get_curline();
    new_line = vim_strsave(tmp___3);
    }
    if ((unsigned long )new_line == (unsigned long )((void *)0)) {
      return;
    }
    {
    *(new_line + curwin->w_cursor.col) = (char_u )'\000';
    ml_replace(curwin->w_cursor.lnum, orig_line, 0);
    curwin->w_cursor.col = orig_col;
    backspace_until_column(0);
    vr_virtcol = (colnr_t )2147483647;
    ptr = new_line;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! ((int )*ptr != 0)) {
        goto while_break___3;
      }
      {
      tmp___4 = ptr;
      ptr ++;
      ins_char((int )*tmp___4);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    vim_free((void *)new_line);
    }
  }
  return;
}
}
void truncate_spaces(char_u *line ) 
{ 
  int i___0 ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)line));
  i___0 = (int )(tmp - 1UL);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i___0 >= 0) {
      if (! ((int )*(line + i___0) == 32)) {
        if (! ((int )*(line + i___0) == 9)) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
    if (State == 528) {
      {
      replace_join(0);
      }
    } else { //Added block
    if (State == 784) {
      {
      replace_join(0);
      }
    }
    }
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  *(line + (i___0 + 1)) = (char_u )'\000';
  return;
}
}
void backspace_until_column(int col ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )curwin->w_cursor.col > col)) {
      goto while_break;
    }
    (curwin->w_cursor.col) --;
    if (State == 528) {
      {
      replace_do_bs();
      }
    } else { //Added block
    if (State == 784) {
      {
      replace_do_bs();
      }
    } else {
      {
      del_char(0);
      }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int vim_is_ctrl_x_key(int c ) 
{ 


  {
  {
  if (ctrl_x_mode == 0) {
    goto case_0;
  }
  if (ctrl_x_mode == 1) {
    goto case_1;
  }
  if (ctrl_x_mode == 2) {
    goto case_2;
  }
  if (ctrl_x_mode == 3) {
    goto case_3;
  }
  if (ctrl_x_mode == 4) {
    goto case_4;
  }
  if (ctrl_x_mode == 265) {
    goto case_265;
  }
  if (ctrl_x_mode == 261) {
    goto case_261;
  }
  if (ctrl_x_mode == 262) {
    goto case_262;
  }
  if (ctrl_x_mode == 263) {
    goto case_263;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  if (c == 14) {
    return (1);
  } else { //Added block
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 24) {
    return (1);
  }
  }
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  if (c == 24) {
    return (1);
  } else { //Added block
  if (c == 25) {
    return (1);
  } else { //Added block
  if (c == 5) {
    return (1);
  } else { //Added block
  if (c == 12) {
    return (1);
  } else { //Added block
  if (c == 6) {
    return (1);
  } else { //Added block
  if (c == 29) {
    return (1);
  } else { //Added block
  if (c == 9) {
    return (1);
  } else { //Added block
  if (c == 4) {
    return (1);
  } else { //Added block
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 14) {
    return (1);
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  if (c == 25) {
    return (1);
  } else { //Added block
  if (c == 5) {
    return (1);
  }
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  if (c == 12) {
    return (1);
  } else { //Added block
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 14) {
    return (1);
  }
  }
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  if (c == 6) {
    return (1);
  } else { //Added block
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 14) {
    return (1);
  }
  }
  }
  goto switch_break;
  case_265: /* CIL Label */ 
  if (c == 11) {
    return (1);
  } else { //Added block
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 14) {
    return (1);
  }
  }
  }
  goto switch_break;
  case_261: /* CIL Label */ 
  if (c == 29) {
    return (1);
  } else { //Added block
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 14) {
    return (1);
  }
  }
  }
  goto switch_break;
  case_262: /* CIL Label */ 
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 14) {
    return (1);
  }
  }
  goto switch_break;
  case_263: /* CIL Label */ 
  if (c == 4) {
    return (1);
  } else { //Added block
  if (c == 16) {
    return (1);
  } else { //Added block
  if (c == 14) {
    return (1);
  }
  }
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  emsg(e_internal);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
int ins_compl_add_infercase(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                            int reuse ) 
{ 
  int has_lower ;
  int was_letter ;
  int idx ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  has_lower = 0;
  was_letter = 0;
  if (p_ic) {
    if (curbuf->b_p_inf) {
      if (len___0 < 1025) {
        {
        strncpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)str___1),
                (size_t )len___0);
        *(IObuff + len___0) = (char_u )'\000';
        idx = 0;
        }
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (idx < completion_length)) {
            goto while_break;
          }
          {
          tmp___1 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___1 + (int )*(original_text + idx)) & 512) {
            {
            has_lower = 1;
            tmp___0 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___0 + (int )*(IObuff + idx)) & 256) {
              idx = completion_length;
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (! (idx < len___0)) {
                  goto while_break___0;
                }
                {
                tmp = tolower((int )*(IObuff + idx));
                *(IObuff + idx) = (char_u )tmp;
                idx ++;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              goto while_break;
            }
          }
          idx ++;
        }
        while_break: /* CIL Label */ ;
        }
        if (! has_lower) {
          idx = 0;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (idx < completion_length)) {
              goto while_break___1;
            }
            if (was_letter) {
              {
              tmp___3 = __ctype_b_loc();
              }
              if ((int const   )*(*tmp___3 + (int )*(original_text + idx)) & 256) {
                {
                tmp___4 = __ctype_b_loc();
                }
                if ((int const   )*(*tmp___4 + (int )*(IObuff + idx)) & 512) {
                  idx = completion_length;
                  {
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
                    if (! (idx < len___0)) {
                      goto while_break___2;
                    }
                    {
                    tmp___2 = toupper((int )*(IObuff + idx));
                    *(IObuff + idx) = (char_u )tmp___2;
                    idx ++;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
                  goto while_break___1;
                }
              }
            }
            {
            tmp___5 = __ctype_b_loc();
            was_letter = (int )((int const   )*(*tmp___5 + (int )*(original_text + idx)) & 1024);
            idx ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
        {
        strncpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)original_text),
                (size_t )completion_length);
        tmp___6 = ins_compl_add(IObuff, len___0, fname, dir, reuse);
        }
        return (tmp___6);
      }
    }
  }
  {
  tmp___7 = ins_compl_add(str___1, len___0, fname, dir, reuse);
  }
  return (tmp___7);
}
}
static int ins_compl_add(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                         int reuse ) 
{ 
  struct Completion *match ;
  size_t tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  struct Completion *tmp___5 ;

  {
  {
  ui_breakcheck();
  }
  if (got_int) {
    return (-1);
  }
  if (len___0 < 0) {
    {
    tmp = strlen((char const   *)((char *)str___1));
    len___0 = (int )tmp;
    }
  }
  if ((unsigned long )first_match != (unsigned long )((void *)0)) {
    match = first_match;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (match->original & 1)) {
        {
        tmp___0 = strncmp((char const   *)((char *)match->str), (char const   *)((char *)str___1),
                          (size_t )len___0);
        }
        if (tmp___0 == 0) {
          if ((int )*(match->str + len___0) == 0) {
            return (0);
          }
        }
      }
      match = match->next;
      if ((unsigned long )match != (unsigned long )((void *)0)) {
        if (! ((unsigned long )match != (unsigned long )first_match)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  tmp___1 = alloc((unsigned int )sizeof(struct Completion ));
  match = (struct Completion *)tmp___1;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (reuse & 1) {
    match->str = original_text;
  } else {
    {
    tmp___2 = vim_strnsave(str___1, len___0);
    match->str = tmp___2;
    }
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
      vim_free((void *)match);
      }
      return (-1);
    }
  }
  if (fname) {
    if (curr_match) {
      if (curr_match->fname) {
        {
        tmp___4 = strcmp((char const   *)((char *)fname), (char const   *)((char *)curr_match->fname));
        }
        if (tmp___4 == 0) {
          match->fname = curr_match->fname;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (fname) {
    {
    tmp___3 = vim_strsave(fname);
    match->fname = tmp___3;
    }
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      reuse |= 2;
    } else {
      match->fname = (char_u *)((void *)0);
    }
  } else {
    match->fname = (char_u *)((void *)0);
  }
  }
  match->original = reuse;
  if ((unsigned long )first_match == (unsigned long )((void *)0)) {
    tmp___5 = (struct Completion *)((void *)0);
    match->prev = tmp___5;
    match->next = tmp___5;
  } else { //Added block
  if (dir == 1) {
    match->next = curr_match->next;
    match->prev = curr_match;
  } else {
    match->next = curr_match;
    match->prev = curr_match->prev;
  }
  }
  if (match->next) {
    (match->next)->prev = match;
  }
  if (match->prev) {
    (match->prev)->next = match;
  } else {
    first_match = match;
  }
  curr_match = match;
  return (1);
}
}
static int ins_compl_make_cyclic(void) 
{ 
  struct Completion *match ;
  int count___2 ;

  {
  count___2 = 0;
  if ((unsigned long )first_match != (unsigned long )((void *)0)) {
    match = first_match;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if ((unsigned long )match->next != (unsigned long )((void *)0)) {
        if (! ((unsigned long )match->next != (unsigned long )first_match)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      match = match->next;
      count___2 ++;
    }
    while_break: /* CIL Label */ ;
    }
    match->next = first_match;
    first_match->prev = match;
  }
  return (count___2);
}
}
static void ins_compl_dictionaries(char_u *dict , char_u *pat , int dir , int flags___0 ) 
{ 
  char_u *ptr ;
  char_u *buf___3 ;
  int at_start___0 ;
  FILE *fp___0 ;
  vim_regexp *prog ;
  int add_r ;
  char_u **files ;
  int count___2 ;
  int i___0 ;
  int save_p_scs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  buf___3 = alloc(512U);
  save_p_scs = p_scs;
  }
  if (curbuf->b_p_inf) {
    p_scs = 0;
  }
  {
  set_reg_ic(pat);
  prog = vim_regcomp(pat, p_magic);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      if ((unsigned long )prog != (unsigned long )((void *)0)) {
        if ((int )*dict != 0) {
          if (! got_int) {
            if (! (! completion_interrupted)) {
              goto while_break;
            }
          } else {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (flags___0 == 2) {
      count___2 = 1;
      files = & dict;
    } else {
      {
      copy_option_part(& dict, buf___3, 512, (char *)",");
      tmp = expand_wildcards(1, & buf___3, & count___2, & files, 34);
      }
      if (tmp != 1) {
        count___2 = 0;
      }
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (i___0 < count___2) {
        if (! got_int) {
          if (! (! completion_interrupted)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      {
      fp___0 = fopen((char const   * __restrict  )((char *)*(files + i___0)), (char const   * __restrict  )"r");
      }
      if (flags___0 != 2) {
        {
        sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Scanning dictionary: %s",
                (char *)*(files + i___0));
        msg_trunc_attr(IObuff, 1, highlight_attr[10]);
        }
      }
      if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! got_int) {
            if (! completion_interrupted) {
              {
              tmp___2 = vim_fgets(buf___3, 512, fp___0);
              }
              if (tmp___2) {
                goto while_break___1;
              }
            } else {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
          ptr = buf___3;
          at_start___0 = 1;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
            tmp___1 = vim_regexec(prog, ptr, at_start___0);
            }
            if (! tmp___1) {
              goto while_break___2;
            }
            at_start___0 = 0;
            ptr = prog->startp[0];
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
              tmp___0 = vim_iswordc((int )*ptr);
              }
              if (! tmp___0) {
                goto while_break___3;
              }
              ptr ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
            add_r = ins_compl_add_infercase(prog->startp[0], (int )(ptr - prog->startp[0]),
                                            *(files + i___0), dir, 0);
            }
            if (add_r == 1) {
              dir = 1;
            } else { //Added block
            if (add_r == -1) {
              goto while_break___2;
            }
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
          line_breakcheck();
          ins_compl_check_keys();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        fclose(fp___0);
        }
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (flags___0 != 2) {
      {
      FreeWild(count___2, files);
      }
    }
    if (flags___0) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  p_scs = save_p_scs;
  vim_free((void *)prog);
  vim_free((void *)buf___3);
  }
  return;
}
}
static void ins_compl_free(void) 
{ 
  struct Completion *match ;

  {
  if ((unsigned long )first_match == (unsigned long )((void *)0)) {
    return;
  }
  curr_match = first_match;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    match = curr_match;
    curr_match = curr_match->next;
    vim_free((void *)match->str);
    }
    if (match->original & 2) {
      {
      vim_free((void *)match->fname);
      }
    }
    {
    vim_free((void *)match);
    }
    if ((unsigned long )curr_match != (unsigned long )((void *)0)) {
      if (! ((unsigned long )curr_match != (unsigned long )first_match)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  curr_match = (struct Completion *)((void *)0);
  first_match = curr_match;
  return;
}
}
static void ins_compl_clear(void) 
{ 


  {
  continue_status = 0;
  started_completion = 0;
  complete_pat = (char_u *)((void *)0);
  save_sm = -1;
  return;
}
}
static int ins_compl_prep(int c ) 
{ 
  char_u *ptr ;
  char_u *tmp_ptr ;
  int temp ;
  linenr_t lnum ;
  int need_redraw ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  need_redraw = 0;
  if (c == 245 + (88 << 8)) {
    return (0);
  }
  if (ctrl_x_mode == 1) {
    {
    if (c == 5) {
      goto case_5;
    }
    if (c == 25) {
      goto case_5;
    }
    if (c == 12) {
      goto case_12;
    }
    if (c == 6) {
      goto case_6;
    }
    if (c == 11) {
      goto case_11;
    }
    if (c == 29) {
      goto case_29;
    }
    if (c == 9) {
      goto case_9;
    }
    if (c == 253 + (53 << 8)) {
      goto case_9;
    }
    if (c == 4) {
      goto case_4;
    }
    if (c == 16) {
      goto case_16;
    }
    if (c == 14) {
      goto case_16;
    }
    goto switch_default;
    case_5: /* CIL Label */ 
    case_25: /* CIL Label */ 
    ctrl_x_mode = 2;
    if (State == 16) {
      edit_submode = (char_u *)" (insert) Scroll (^E/^Y)";
    } else {
      edit_submode = (char_u *)" (replace) Scroll (^E/^Y)";
    }
    {
    showmode();
    }
    goto switch_break;
    case_12: /* CIL Label */ 
    ctrl_x_mode = 3;
    goto switch_break;
    case_6: /* CIL Label */ 
    ctrl_x_mode = 4;
    goto switch_break;
    case_11: /* CIL Label */ 
    ctrl_x_mode = 265;
    goto switch_break;
    case_29: /* CIL Label */ 
    ctrl_x_mode = 261;
    goto switch_break;
    case_9: /* CIL Label */ 
    case_exp: /* CIL Label */ 
    ctrl_x_mode = 262;
    goto switch_break;
    case_4: /* CIL Label */ 
    ctrl_x_mode = 263;
    goto switch_break;
    case_16: /* CIL Label */ 
    case_14: /* CIL Label */ 
    if (! (continue_status & 6)) {
      continue_status |= 32;
    } else { //Added block
    if (continue_mode) {
      continue_status &= -33;
    }
    }
    switch_default: /* CIL Label */ 
    if (c == 24) {
      if (continue_mode) {
        continue_status = 0;
      } else {
        continue_mode = 1;
      }
    }
    {
    ctrl_x_mode = 0;
    edit_submode = (char_u *)((void *)0);
    showmode();
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else { //Added block
  if (ctrl_x_mode) {
    {
    tmp = vim_is_ctrl_x_key(c);
    }
    if (! tmp) {
      if (ctrl_x_mode == 2) {
        ctrl_x_mode = 0;
      } else {
        ctrl_x_mode = 8;
      }
      edit_submode = (char_u *)((void *)0);
    }
    {
    showmode();
    }
  }
  }
  if (started_completion) {
    goto _L___2;
  } else { //Added block
  if (ctrl_x_mode == 8) {
    _L___2: 
    {
    showmode();
    }
    if (ctrl_x_mode == 0) {
      if (c != 14) {
        if (c != 16) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (ctrl_x_mode == 8) {
      _L: 
      if ((unsigned long )curr_match != (unsigned long )((void *)0)) {
        ptr = curr_match->str;
        tmp_ptr = original_text;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (*tmp_ptr) {
            if (! ((int )*tmp_ptr == (int )*ptr)) {
              goto while_break;
            }
          } else {
            goto while_break;
          }
          tmp_ptr ++;
          ptr ++;
        }
        while_break: /* CIL Label */ ;
        }
        temp = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! *(tmp_ptr + temp)) {
            goto while_break___0;
          }
          {
          AppendCharToRedobuff(107 + (98 << 8));
          temp ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! *ptr) {
            goto while_break___1;
          }
          tmp_ptr = ptr;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if ((int )*ptr >= 32) {
              if (! ((int )*ptr < 127)) {
                goto while_break___2;
              }
            } else {
              goto while_break___2;
            }
            ptr ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          if ((int )*ptr == 0) {
            if ((int )*(ptr + -1) == 48) {
              ptr --;
            } else { //Added block
            if ((int )*(ptr + -1) == 94) {
              ptr --;
            }
            }
          }
          if ((unsigned long )ptr > (unsigned long )tmp_ptr) {
            {
            temp = (int )*ptr;
            *ptr = (char_u )'\000';
            AppendToRedobuff(tmp_ptr);
            *ptr = (char_u )temp;
            }
          }
          if (*ptr) {
            {
            AppendCharToRedobuff(22);
            AppendCharToRedobuff((int )*ptr);
            tmp___0 = ptr;
            ptr ++;
            }
            if ((int )*tmp___0 == 48) {
              {
              AppendToRedobuff((char_u *)"48");
              }
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      lnum = curwin->w_cursor.lnum;
      if (continue_mode == 3) {
        if (can_cindent) {
          if (curbuf->b_p_cin) {
            {
            fixthisline(& get_c_indent);
            }
          }
        }
      } else {
        {
        (curwin->w_cursor.col) --;
        insertchar((unsigned int )'\000', 0, -1, 0);
        (curwin->w_cursor.col) ++;
        }
      }
      if (lnum != curwin->w_cursor.lnum) {
        {
        update_topline();
        update_screen(40);
        }
      } else {
        need_redraw = 1;
      }
      {
      vim_free((void *)complete_pat);
      complete_pat = (char_u *)((void *)0);
      ins_compl_free();
      started_completion = 0;
      ctrl_x_mode = 0;
      p_sm = save_sm;
      }
      if ((unsigned long )edit_submode != (unsigned long )((void *)0)) {
        {
        edit_submode = (char_u *)((void *)0);
        showmode();
        }
      }
    }
    }
  }
  }
  {
  tmp___1 = vim_is_ctrl_x_key(c);
  }
  if (! tmp___1) {
    continue_mode = 0;
    continue_status = continue_mode;
  }
  return (need_redraw);
}
}
static WIN *w  ;
static BUF *ins_compl_next_buf(BUF *buf___3 , int flag ) 
{ 


  {
  if (flag == 119) {
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      w = curwin;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (w->w_next) {
        w = w->w_next;
      } else {
        w = firstwin;
      }
      if ((unsigned long )w != (unsigned long )curwin) {
        if (! (w->w_buffer)->b_scanned) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    buf___3 = w->w_buffer;
  } else {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (buf___3->b_next) {
        buf___3 = buf___3->b_next;
      } else {
        buf___3 = firstbuf;
      }
      if ((unsigned long )buf___3 != (unsigned long )curbuf) {
        if (! (((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) != (flag == 117))) {
          if (! buf___3->b_scanned) {
            goto while_break___0;
          }
        }
      } else {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return (buf___3);
}
}
static FPOS first_match_pos  ;
static FPOS last_match_pos  ;
static char_u *e_cpt  =    (char_u *)"";
static int found_all  =    0;
static BUF *ins_buf  =    (BUF *)((void *)0);
static int ins_compl_get_exp(FPOS *ini , int dir ) 
{ 
  FPOS *pos___0 ;
  char_u **matches___0 ;
  int save_p_scs ;
  int save_p_ws ;
  int save_p_ic ;
  int i___0 ;
  int num_matches___0 ;
  int len___0 ;
  int found_new_match ;
  int type ;
  char_u *ptr ;
  char_u *tmp_ptr ;
  char_u *dict ;
  int dict_f ;
  struct Completion *old_match ;
  char const   *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int add_r ;
  int ldir ;
  int tmp___5 ;
  int tmp___6 ;
  int add_r___0 ;
  int ldir___0 ;
  int tmp___7 ;
  int reuse ;
  char_u *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char_u *tmp___19 ;
  char_u *tmp___20 ;
  int tmp___21 ;

  {
  type = ctrl_x_mode;
  dict = (char_u *)((void *)0);
  dict_f = 0;
  if (! started_completion) {
    ins_buf = firstbuf;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )ins_buf != (unsigned long )((void *)0))) {
        goto while_break;
      }
      ins_buf->b_scanned = 0;
      ins_buf = ins_buf->b_next;
    }
    while_break: /* CIL Label */ ;
    }
    found_all = 0;
    ins_buf = curbuf;
    if (continue_status & 32) {
      e_cpt = (char_u *)".";
    } else {
      e_cpt = curbuf->b_p_cpt;
    }
    first_match_pos = *ini;
    last_match_pos = first_match_pos;
  }
  old_match = curr_match;
  if (dir == 1) {
    pos___0 = & last_match_pos;
  } else {
    pos___0 = & first_match_pos;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    found_new_match = 0;
    if (! ctrl_x_mode) {
      if (! started_completion) {
        goto _L___1;
      } else { //Added block
      if (found_all) {
        _L___1: 
        found_all = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((int )*e_cpt == 44)) {
            if (! ((int )*e_cpt == 32)) {
              goto while_break___1;
            }
          }
          e_cpt ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        if ((int )*e_cpt == 46) {
          if (! curbuf->b_scanned) {
            ins_buf = curbuf;
            first_match_pos = *ini;
            if (ctrl_x_mode == 0) {
              {
              dec(& first_match_pos);
              }
            }
            last_match_pos = first_match_pos;
            type = 0;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          {
          tmp___0 = vim_strchr((char_u *)"buw", (int )*e_cpt);
          }
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
            {
            ins_buf = ins_compl_next_buf(ins_buf, (int )*e_cpt);
            }
            if ((unsigned long )ins_buf != (unsigned long )curbuf) {
              if ((int )*e_cpt != 117) {
                started_completion = 1;
                last_match_pos.col = (colnr_t )0;
                first_match_pos.col = last_match_pos.col;
                first_match_pos.lnum = ins_buf->b_ml.ml_line_count + 1L;
                last_match_pos.lnum = (linenr_t )0;
                type = 0;
              } else {
                found_all = 1;
                if ((unsigned long )ins_buf->b_fname == (unsigned long )((void *)0)) {
                  goto __Cont;
                }
                type = 265;
                dict = ins_buf->b_fname;
                dict_f = 2;
              }
              if ((unsigned long )ins_buf->b_sfname == (unsigned long )((void *)0)) {
                tmp = "No File";
              } else {
                tmp = (char const   *)((char *)ins_buf->b_sfname);
              }
              {
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Scanning: %s",
                      tmp);
              msg_trunc_attr(IObuff, 1, highlight_attr[10]);
              }
            } else {
              goto _L;
            }
          } else { //Added block
          _L: 
          if ((int )*e_cpt == 0) {
            goto while_break___0;
          } else {
            if ((int )*e_cpt == 107) {
              type = 265;
              e_cpt ++;
              if ((int )*e_cpt != 44) {
                if ((int )*e_cpt != 0) {
                  dict = e_cpt;
                  dict_f = 1;
                }
              }
            } else { //Added block
            if ((int )*e_cpt == 105) {
              type = 262;
            } else { //Added block
            if ((int )*e_cpt == 100) {
              type = 263;
            } else { //Added block
            if ((int )*e_cpt == 93) {
              {
              type = 261;
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Scanning tags.");
              msg_trunc_attr(IObuff, 1, highlight_attr[10]);
              }
            } else { //Added block
            if ((int )*e_cpt == 116) {
              {
              type = 261;
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Scanning tags.");
              msg_trunc_attr(IObuff, 1, highlight_attr[10]);
              }
            } else {
              type = -1;
            }
            }
            }
            }
            }
            {
            copy_option_part(& e_cpt, IObuff, 1025, (char *)",");
            found_all = 1;
            }
            if (type == -1) {
              goto __Cont;
            }
          }
          }
        }
      }
      }
    }
    {
    if (type == -1) {
      goto case_neg_1;
    }
    if (type == 262) {
      goto case_262;
    }
    if (type == 263) {
      goto case_262;
    }
    if (type == 265) {
      goto case_265;
    }
    if (type == 261) {
      goto case_261;
    }
    if (type == 4) {
      goto case_4;
    }
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    goto switch_break;
    case_262: /* CIL Label */ 
    case_263: /* CIL Label */ 
    if (type == 263) {
      if (! (continue_status & 16)) {
        tmp___1 = 2;
      } else {
        tmp___1 = 1;
      }
    } else {
      tmp___1 = 1;
    }
    {
    tmp___2 = strlen((char const   *)((char *)complete_pat));
    find_pattern_in_path(complete_pat, dir, (int )tmp___2, 0, 0, tmp___1, 1L, 5, (linenr_t )1,
                         (linenr_t )2147483647);
    }
    goto switch_break;
    case_265: /* CIL Label */ 
    if (dict) {
      tmp___3 = dict_f;
    } else {
      tmp___3 = 0;
    }
    if (dict) {
      tmp___4 = dict;
    } else {
      tmp___4 = p_dict;
    }
    {
    ins_compl_dictionaries(tmp___4, complete_pat, dir, tmp___3);
    dict = (char_u *)((void *)0);
    }
    goto switch_break;
    case_261: /* CIL Label */ 
    {
    set_reg_ic(complete_pat);
    save_p_ic = p_ic;
    p_ic = reg_ic;
    }
    if (ctrl_x_mode) {
      tmp___5 = 32;
    } else {
      tmp___5 = 0;
    }
    {
    tmp___6 = find_tags(complete_pat, & num_matches___0, & matches___0, 78 | tmp___5,
                        200);
    }
    if (tmp___6 == 1) {
      if (num_matches___0 > 0) {
        add_r = 1;
        ldir = dir;
        i___0 = 0;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (i___0 < num_matches___0) {
            if (! (add_r != -1)) {
              goto while_break___2;
            }
          } else {
            goto while_break___2;
          }
          {
          add_r = ins_compl_add(*(matches___0 + i___0), -1, (char_u *)((void *)0),
                                ldir, 0);
          }
          if (add_r == 1) {
            ldir = 1;
          }
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        FreeWild(num_matches___0, matches___0);
        }
      }
    }
    p_ic = save_p_ic;
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    tmp___7 = expand_wildcards(1, & complete_pat, & num_matches___0, & matches___0,
                               43);
    }
    if (tmp___7 == 1) {
      {
      add_r___0 = 1;
      ldir___0 = dir;
      tilde_replace(complete_pat, num_matches___0, matches___0);
      i___0 = 0;
      }
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (i___0 < num_matches___0) {
          if (! (add_r___0 != -1)) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
        {
        add_r___0 = ins_compl_add(*(matches___0 + i___0), -1, (char_u *)((void *)0),
                                  ldir___0, 0);
        }
        if (add_r___0 == 1) {
          ldir___0 = 1;
        }
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      FreeWild(num_matches___0, matches___0);
      }
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    save_p_scs = p_scs;
    if (ins_buf->b_p_inf) {
      p_scs = 0;
    }
    save_p_ws = p_ws;
    if ((unsigned long )ins_buf != (unsigned long )curbuf) {
      p_ws = 0;
    } else { //Added block
    if ((int )*e_cpt == 46) {
      p_ws = 1;
    }
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      reuse = 0;
      if (ctrl_x_mode == 3) {
        {
        found_new_match = search_for_exact_line(ins_buf, pos___0, dir, complete_pat);
        }
      } else { //Added block
      if (continue_status & 16) {
        {
        found_new_match = search_for_exact_line(ins_buf, pos___0, dir, complete_pat);
        }
      } else {
        {
        found_new_match = searchit(ins_buf, pos___0, dir, complete_pat, 1L, 1032,
                                   2);
        }
      }
      }
      if (! started_completion) {
        started_completion = 1;
        first_match_pos = *pos___0;
        last_match_pos = *pos___0;
      } else { //Added block
      if (first_match_pos.lnum == last_match_pos.lnum) {
        if (first_match_pos.col == last_match_pos.col) {
          found_new_match = 0;
        }
      }
      }
      if (! found_new_match) {
        if ((unsigned long )ins_buf == (unsigned long )curbuf) {
          found_all = 1;
        }
        goto while_break___4;
      }
      if (continue_status & 1) {
        if ((unsigned long )ins_buf == (unsigned long )curbuf) {
          if (ini->lnum == pos___0->lnum) {
            if (ini->col == pos___0->col) {
              goto __Cont___0;
            }
          }
        }
      }
      {
      tmp___8 = ml_get_buf(ins_buf, pos___0->lnum, 0);
      ptr = tmp___8 + pos___0->col;
      }
      if (ctrl_x_mode == 3) {
        if (continue_status & 1) {
          if (pos___0->lnum >= ins_buf->b_ml.ml_line_count) {
            goto __Cont___0;
          }
          {
          ptr = ml_get_buf(ins_buf, pos___0->lnum + 1L, 0);
          }
          if (! p_paste) {
            {
            ptr = skipwhite(ptr);
            }
          }
        }
        {
        tmp___9 = strlen((char const   *)((char *)ptr));
        len___0 = (int )tmp___9;
        }
      } else {
        tmp_ptr = ptr;
        if (continue_status & 1) {
          {
          tmp_ptr += completion_length;
          tmp___10 = vim_iswordc((int )*tmp_ptr);
          }
          if (tmp___10) {
            goto __Cont___0;
          }
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (*tmp_ptr) {
              {
              tmp___11 = tmp_ptr;
              tmp_ptr ++;
              tmp___12 = vim_iswordc((int )*tmp___11);
              }
              if (tmp___12) {
                goto while_break___5;
              }
            } else {
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
        }
        {
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
          tmp___13 = vim_iswordc((int )*tmp_ptr);
          }
          if (! tmp___13) {
            goto while_break___6;
          }
          tmp_ptr ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        len___0 = (int )(tmp_ptr - ptr);
        if (continue_status & 1) {
          if (len___0 == completion_length) {
            if (pos___0->lnum < ins_buf->b_ml.ml_line_count) {
              {
              strncpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)ptr),
                      (size_t )len___0);
              ptr = ml_get_buf(ins_buf, pos___0->lnum + 1L, 0);
              ptr = skipwhite(ptr);
              tmp_ptr = ptr;
              }
              {
              while (1) {
                while_continue___7: /* CIL Label */ ;
                if (*tmp_ptr) {
                  {
                  tmp___14 = tmp_ptr;
                  tmp_ptr ++;
                  tmp___15 = vim_iswordc((int )*tmp___14);
                  }
                  if (tmp___15) {
                    goto while_break___7;
                  }
                } else {
                  goto while_break___7;
                }
              }
              while_break___7: /* CIL Label */ ;
              }
              {
              while (1) {
                while_continue___8: /* CIL Label */ ;
                {
                tmp___16 = vim_iswordc((int )*tmp_ptr);
                }
                if (! tmp___16) {
                  goto while_break___8;
                }
                tmp_ptr ++;
              }
              while_break___8: /* CIL Label */ ;
              }
              if ((unsigned long )tmp_ptr > (unsigned long )ptr) {
                if ((int )*ptr != 41) {
                  if ((int )*(IObuff + (len___0 - 1)) != 9) {
                    if ((int )*(IObuff + (len___0 - 1)) != 32) {
                      tmp___17 = len___0;
                      len___0 ++;
                      *(IObuff + tmp___17) = (char_u )' ';
                    }
                    if (p_js) {
                      if ((int )*(IObuff + (len___0 - 2)) == 46) {
                        tmp___18 = len___0;
                        len___0 ++;
                        *(IObuff + tmp___18) = (char_u )' ';
                      } else {
                        {
                        tmp___19 = vim_strchr(p_cpo, 'j');
                        }
                        if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
                          if ((int )*(IObuff + (len___0 - 2)) == 63) {
                            tmp___18 = len___0;
                            len___0 ++;
                            *(IObuff + tmp___18) = (char_u )' ';
                          } else { //Added block
                          if ((int )*(IObuff + (len___0 - 2)) == 33) {
                            tmp___18 = len___0;
                            len___0 ++;
                            *(IObuff + tmp___18) = (char_u )' ';
                          }
                          }
                        }
                      }
                    }
                  }
                }
                if (tmp_ptr - ptr >= (long )(1025 - len___0)) {
                  tmp_ptr = ((ptr + 1025) - len___0) - 1;
                }
                {
                strncpy((char * __restrict  )((char *)(IObuff + len___0)), (char const   * __restrict  )((char *)ptr),
                        (size_t )(tmp_ptr - ptr));
                len___0 = (int )((long )len___0 + (tmp_ptr - ptr));
                reuse |= 8;
                }
              }
              *(IObuff + len___0) = (char_u )'\000';
              ptr = IObuff;
            }
            if (len___0 == completion_length) {
              goto __Cont___0;
            }
          }
        }
      }
      if ((unsigned long )ins_buf == (unsigned long )curbuf) {
        tmp___20 = (char_u *)((void *)0);
      } else {
        tmp___20 = ins_buf->b_sfname;
      }
      {
      tmp___21 = ins_compl_add_infercase(ptr, len___0, tmp___20, dir, reuse);
      }
      if (tmp___21 != 0) {
        found_new_match = 1;
        goto while_break___4;
      }
      __Cont___0: ;
    }
    while_break___4: /* CIL Label */ ;
    }
    p_scs = save_p_scs;
    p_ws = save_p_ws;
    switch_break: /* CIL Label */ ;
    }
    if ((unsigned long )curr_match != (unsigned long )old_match) {
      found_new_match = 1;
    }
    if (ctrl_x_mode) {
      goto while_break___0;
    } else { //Added block
    if (found_new_match) {
      goto while_break___0;
    }
    }
    if (type == 0) {
      ins_buf->b_scanned = 1;
    } else { //Added block
    if (type == 262) {
      ins_buf->b_scanned = 1;
    }
    }
    started_completion = 0;
    __Cont: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  started_completion = 1;
  if (! ctrl_x_mode) {
    if ((int )*e_cpt == 0) {
      found_new_match = 0;
    }
  }
  i___0 = -1;
  if (! found_new_match) {
    {
    i___0 = ins_compl_make_cyclic();
    }
  } else { //Added block
  if (ctrl_x_mode != 0) {
    if (ctrl_x_mode != 3) {
      {
      i___0 = ins_compl_make_cyclic();
      }
    }
  }
  }
  if (dir == 1) {
    curr_match = old_match->next;
  } else {
    curr_match = old_match->prev;
  }
  if ((unsigned long )curr_match == (unsigned long )((void *)0)) {
    curr_match = old_match;
  }
  return (i___0);
}
}
static void ins_compl_delete(void) 
{ 
  int i___0 ;
  int tmp ;

  {
  if (continue_status & 1) {
    tmp = completion_length;
  } else {
    tmp = 0;
  }
  {
  i___0 = (int )(complete_col + (colnr_t )tmp);
  backspace_until_column(i___0);
  changed_cline_bef_curs();
  }
  return;
}
}
static void ins_compl_insert(void) 
{ 
  char_u *ptr ;
  char_u *tmp ;

  {
  ptr = (shown_match->str + curwin->w_cursor.col) - complete_col;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *ptr) {
      goto while_break;
    }
    {
    tmp = ptr;
    ptr ++;
    ins_char((int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  update_screenline();
  }
  return;
}
}
static int ins_compl_next(int allow_get_expansion ) 
{ 
  int num_matches___0 ;
  int i___0 ;
  int tmp ;

  {
  num_matches___0 = -1;
  if (allow_get_expansion) {
    {
    ins_compl_delete();
    }
  }
  completion_pending = 0;
  if (shown_direction == 1) {
    if ((unsigned long )shown_match->next != (unsigned long )((void *)0)) {
      shown_match = shown_match->next;
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (shown_direction == -1) {
    if ((unsigned long )shown_match->prev != (unsigned long )((void *)0)) {
      shown_match = shown_match->prev;
    } else {
      goto _L;
    }
  } else {
    _L: 
    completion_pending = 1;
    if (allow_get_expansion) {
      {
      num_matches___0 = ins_compl_get_exp(& initial_pos, complete_direction);
      }
      if (completion_pending) {
        if (complete_direction == shown_direction) {
          shown_match = curr_match;
        }
      }
    } else {
      return (-1);
    }
  }
  }
  {
  ins_compl_insert();
  }
  if (! allow_get_expansion) {
    {
    ins_compl_delete();
    }
  }
  if ((unsigned long )shown_match->fname != (unsigned long )((void *)0)) {
    {
    strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"match in file "));
    tmp = vim_strsize(shown_match->fname);
    i___0 = (tmp + 16) - sc_col;
    }
    if (i___0 <= 0) {
      i___0 = 0;
    } else {
      {
      strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"<"));
      }
    }
    {
    strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)(shown_match->fname + i___0)));
    msg(IObuff);
    redraw_cmdline = 0;
    }
  }
  return (num_matches___0);
}
}
static int count  =    0;
void ins_compl_check_keys(void) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = using_script();
  }
  if (tmp) {
    return;
  }
  count ++;
  if (count < 30) {
    return;
  }
  {
  count = 0;
  c = vpeekc();
  }
  if (c == 0) {
    if (typelen) {
      c = '\033';
    }
  }
  if (c != 0) {
    {
    tmp___0 = vim_is_ctrl_x_key(c);
    }
    if (tmp___0) {
      if (c != 24) {
        {
        c = safe_vgetc();
        }
        if (c == 16) {
          shown_direction = -1;
        } else { //Added block
        if (c == 12) {
          shown_direction = -1;
        } else {
          shown_direction = 1;
        }
        }
        {
        ins_compl_next(0);
        }
      } else {
        completion_interrupted = 1;
      }
    } else {
      completion_interrupted = 1;
    }
  }
  if (completion_pending) {
    if (! got_int) {
      {
      ins_compl_next(0);
      }
    }
  }
  return;
}
}
static int ins_complete(int c ) 
{ 
  char_u *ptr ;
  char_u *tmp_ptr ;
  int temp ;
  int i___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *prefix ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char_u *old ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  tmp_ptr = (char_u *)((void *)0);
  temp = 0;
  if (c == 16) {
    complete_direction = -1;
  } else { //Added block
  if (c == 12) {
    complete_direction = -1;
  } else {
    complete_direction = 1;
  }
  }
  if (! started_completion) {
    {
    save_sm = p_sm;
    p_sm = 0;
    did_ai = 0;
    did_si = 0;
    can_si = 0;
    can_si_back = 0;
    stop_arrow();
    ptr = ml_get(curwin->w_cursor.lnum);
    complete_col = curwin->w_cursor.col;
    }
    if (continue_status & 6) {
      if (continue_mode == ctrl_x_mode) {
        continue_status &= -7;
        if (ctrl_x_mode == 0) {
          goto _L;
        } else { //Added block
        if (ctrl_x_mode == 262) {
          goto _L;
        } else { //Added block
        if (ctrl_x_mode == 263) {
          _L: 
          if (initial_pos.lnum != curwin->w_cursor.lnum) {
            {
            tmp_ptr = skipwhite(ptr);
            initial_pos.col = (colnr_t )(tmp_ptr - ptr);
            initial_pos.lnum = curwin->w_cursor.lnum;
            continue_status &= -17;
            }
          } else {
            if (continue_status & 8) {
              {
              continue_status |= 16;
              tmp = skipwhite((ptr + completion_length) + initial_pos.col);
              initial_pos.col = (colnr_t )(tmp - ptr);
              }
            }
            tmp_ptr = ptr + initial_pos.col;
          }
          temp = (int )((long )curwin->w_cursor.col - (tmp_ptr - ptr));
          if (temp > 950) {
            continue_status &= -17;
            temp = 950;
            tmp_ptr = ptr + (curwin->w_cursor.col - (colnr_t )temp);
          }
          continue_status |= 5;
          if (temp < 1) {
            continue_status &= 32;
          }
        } else { //Added block
        if (ctrl_x_mode == 3) {
          continue_status = 5;
        } else {
          continue_status = 0;
        }
        }
        }
        }
      } else {
        continue_status &= 32;
      }
    } else {
      continue_status &= 32;
    }
    if (! (continue_status & 1)) {
      continue_mode = ctrl_x_mode;
      if (ctrl_x_mode) {
        continue_status = 0;
      }
      continue_status |= 4;
      initial_pos = curwin->w_cursor;
      temp = (int )complete_col;
      tmp_ptr = ptr;
    }
    if (ctrl_x_mode == 0) {
      goto _L___2;
    } else { //Added block
    if (ctrl_x_mode & 256) {
      _L___2: 
      if (continue_status & 16) {
        goto _L___1;
      } else { //Added block
      if (ctrl_x_mode == 263) {
        _L___1: 
        if (! (continue_status & 1)) {
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            temp --;
            if (temp >= 0) {
              {
              tmp___0 = vim_isIDc((int )*(ptr + temp));
              }
              if (! tmp___0) {
                goto while_break;
              }
            } else {
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
          temp ++;
          tmp_ptr += temp;
          temp = (int )(complete_col - (colnr_t )temp);
        }
        {
        complete_pat = vim_strnsave(tmp_ptr, temp);
        }
        if ((unsigned long )complete_pat == (unsigned long )((void *)0)) {
          return (0);
        }
        if (p_ic) {
          i___0 = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (i___0 < temp)) {
              goto while_break___0;
            }
            {
            tmp___1 = tolower((int )*(complete_pat + i___0));
            *(complete_pat + i___0) = (char_u )tmp___1;
            i___0 ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else { //Added block
      if (continue_status & 1) {
        {
        prefix = (char_u *)"\\<";
        tmp___2 = quote_meta((char_u *)((void *)0), tmp_ptr, temp);
        complete_pat = alloc((unsigned int )(tmp___2 + 3));
        }
        if ((unsigned long )complete_pat == (unsigned long )((void *)0)) {
          return (0);
        }
        {
        tmp___3 = vim_iswordc((int )*tmp_ptr);
        }
        if (tmp___3) {
          if ((unsigned long )tmp_ptr > (unsigned long )ptr) {
            {
            tmp___4 = vim_iswordc((int )*(tmp_ptr - 1));
            }
            if (tmp___4) {
              prefix = (char_u *)"";
            }
          }
        } else {
          prefix = (char_u *)"";
        }
        {
        strcpy((char * __restrict  )((char *)complete_pat), (char const   * __restrict  )((char *)prefix));
        tmp___5 = strlen((char const   *)((char *)prefix));
        quote_meta(complete_pat + tmp___5, tmp_ptr, temp);
        }
      } else {
        temp --;
        if (temp < 0) {
          goto _L___0;
        } else {
          {
          tmp___8 = vim_iswordc((int )*(ptr + temp));
          }
          if (tmp___8) {
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              temp --;
              if (temp >= 0) {
                {
                tmp___6 = vim_iswordc((int )*(ptr + temp));
                }
                if (! tmp___6) {
                  goto while_break___1;
                }
              } else {
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            temp ++;
            tmp_ptr += temp;
            temp = (int )complete_col - temp;
            if (temp == 1) {
              {
              complete_pat = alloc(7U);
              }
              if ((unsigned long )complete_pat == (unsigned long )((void *)0)) {
                return (0);
              }
              {
              strcpy((char * __restrict  )((char *)complete_pat), (char const   * __restrict  )((char *)"\\<"));
              quote_meta(complete_pat + 2, tmp_ptr, 1);
              strcat((char * __restrict  )((char *)complete_pat), (char const   * __restrict  )((char *)"\\k"));
              }
            } else {
              {
              tmp___7 = quote_meta((char_u *)((void *)0), tmp_ptr, temp);
              complete_pat = alloc((unsigned int )(tmp___7 + 3));
              }
              if ((unsigned long )complete_pat == (unsigned long )((void *)0)) {
                return (0);
              }
              {
              strcpy((char * __restrict  )((char *)complete_pat), (char const   * __restrict  )((char *)"\\<"));
              quote_meta(complete_pat + 2, tmp_ptr, temp);
              }
            }
          } else {
            _L___0: 
            {
            complete_pat = vim_strsave((char_u *)"\\<\\k\\k");
            }
            if ((unsigned long )complete_pat == (unsigned long )((void *)0)) {
              return (0);
            }
            tmp_ptr += complete_col;
            temp = 0;
          }
        }
      }
      }
      }
    } else { //Added block
    if (ctrl_x_mode == 3) {
      {
      tmp_ptr = skipwhite(ptr);
      temp = (int )((long )((int )complete_col) - (tmp_ptr - ptr));
      }
      if (temp < 0) {
        temp = 0;
      }
      {
      complete_pat = vim_strnsave(tmp_ptr, temp);
      }
      if ((unsigned long )complete_pat == (unsigned long )((void *)0)) {
        return (0);
      }
      if (p_ic) {
        i___0 = 0;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (i___0 < temp)) {
            goto while_break___2;
          }
          {
          tmp___9 = tolower((int )*(complete_pat + i___0));
          *(complete_pat + i___0) = (char_u )tmp___9;
          i___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else { //Added block
    if (ctrl_x_mode == 4) {
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        temp --;
        if (temp >= 0) {
          {
          tmp___10 = vim_isfilec((int )*(ptr + temp));
          }
          if (! tmp___10) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      temp ++;
      tmp_ptr += temp;
      temp = (int )complete_col - temp;
      complete_pat = addstar(tmp_ptr, temp, 2);
      }
      if ((unsigned long )complete_pat == (unsigned long )((void *)0)) {
        return (0);
      }
    }
    }
    }
    }
    complete_col = (colnr_t )(tmp_ptr - ptr);
    if (continue_status & 1) {
      if (continue_status & 32) {
        edit_submode = (char_u *)ctrl_x_msgs[2];
      } else {
        edit_submode = (char_u *)ctrl_x_msgs[ctrl_x_mode & 15];
      }
      if (ctrl_x_mode == 3) {
        {
        old = curbuf->b_p_com;
        curbuf->b_p_com = (char_u *)"";
        initial_pos.lnum = curwin->w_cursor.lnum;
        initial_pos.col = complete_col;
        ins_eol('\r');
        curbuf->b_p_com = old;
        tmp_ptr = (char_u *)"";
        temp = 0;
        complete_col = curwin->w_cursor.col;
        }
      }
    } else {
      if (continue_status & 32) {
        edit_submode = (char_u *)ctrl_x_msgs[2] + 7;
      } else {
        edit_submode = (char_u *)ctrl_x_msgs[ctrl_x_mode & 15] + 7;
      }
      initial_pos.col = complete_col;
    }
    {
    completion_length = temp;
    original_text = vim_strnsave(tmp_ptr, temp);
    }
    if ((unsigned long )original_text == (unsigned long )((void *)0)) {
      {
      vim_free((void *)complete_pat);
      complete_pat = (char_u *)((void *)0);
      }
      return (0);
    } else {
      {
      tmp___11 = ins_compl_add(original_text, -1, (char_u *)((void *)0), 0, 1);
      }
      if (tmp___11 != 1) {
        {
        vim_free((void *)complete_pat);
        complete_pat = (char_u *)((void *)0);
        }
        return (0);
      }
    }
    {
    edit_submode_extra = (char_u *)"-- Searching...";
    edit_submode_highl = (enum hlf_value )18;
    showmode();
    edit_submode_extra = (char_u *)((void *)0);
    out_flush();
    }
  }
  {
  shown_match = curr_match;
  shown_direction = complete_direction;
  temp = ins_compl_next(1);
  curr_match = shown_match;
  complete_direction = shown_direction;
  completion_interrupted = 0;
  }
  if (got_int) {
    if (! global_busy) {
      {
      vgetc();
      got_int = 0;
      }
    }
  }
  if ((unsigned long )first_match == (unsigned long )first_match->next) {
    if (continue_status & 1) {
      if (completion_length > 1) {
        edit_submode_extra = e_hitend;
      } else {
        edit_submode_extra = e_patnotf;
      }
    } else {
      edit_submode_extra = e_patnotf;
    }
    edit_submode_highl = (enum hlf_value )3;
    if (completion_length > 1) {
      continue_status &= -5;
    } else { //Added block
    if (continue_status & 1) {
      continue_status &= -5;
    } else { //Added block
    if (ctrl_x_mode != 0) {
      if (ctrl_x_mode != 262) {
        if (ctrl_x_mode != 263) {
          continue_status &= -5;
        }
      }
    }
    }
    }
  }
  if (curr_match->original & 8) {
    continue_status |= 8;
  } else {
    continue_status &= -9;
  }
  if ((unsigned long )edit_submode_extra == (unsigned long )((void *)0)) {
    if (curr_match->original & 1) {
      edit_submode_extra = (char_u *)"Back at original";
      edit_submode_highl = (enum hlf_value )16;
    } else { //Added block
    if (continue_status & 8) {
      edit_submode_extra = (char_u *)"Word from other line";
      edit_submode_highl = (enum hlf_value )18;
    } else { //Added block
    if ((unsigned long )curr_match->next == (unsigned long )curr_match->prev) {
      edit_submode_extra = (char_u *)"The only match";
      edit_submode_highl = (enum hlf_value )18;
    }
    }
    }
  }
  if (temp > 1) {
    if (ctrl_x_mode == 0) {
      ptr = (char_u *)"All %d matches have now been found";
    } else { //Added block
    if (ctrl_x_mode == 3) {
      ptr = (char_u *)"All %d matches have now been found";
    } else { //Added block
    if (ctrl_x_mode == 4) {
      ptr = (char_u *)"There are %d matching file names";
    } else { //Added block
    if (ctrl_x_mode == 261) {
      ptr = (char_u *)"There are %d matching tags";
    } else {
      ptr = (char_u *)"There are %d matches";
    }
    }
    }
    }
    {
    sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)ptr),
            temp);
    }
    if (dollar_vcol) {
      {
      curs_columns(0);
      }
    }
    {
    msg_attr(IObuff, highlight_attr[10]);
    tmp___12 = char_avail();
    }
    if (! tmp___12) {
      {
      setcursor();
      out_flush();
      ui_delay(1500L, 0);
      }
    }
  }
  {
  showmode();
  }
  if ((unsigned long )edit_submode_extra != (unsigned long )((void *)0)) {
    if (! p_smd) {
      if ((unsigned int )edit_submode_highl < 18U) {
        tmp___13 = highlight_attr[(int )edit_submode_highl];
      } else {
        tmp___13 = 0;
      }
      {
      msg_attr(edit_submode_extra, tmp___13);
      }
    }
    {
    tmp___14 = char_avail();
    }
    if (! tmp___14) {
      {
      setcursor();
      out_flush();
      ui_delay(1500L, 0);
      }
    }
    edit_submode_extra = (char_u *)((void *)0);
  }
  return (1);
}
}
static int quote_meta(char_u *dest , char_u *src , int len___0 ) 
{ 
  int m ;
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  m = len___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    len___0 --;
    if (! (len___0 >= 0)) {
      goto while_break;
    }
    {
    if ((int )*src == 46) {
      goto case_46;
    }
    if ((int )*src == 42) {
      goto case_46;
    }
    if ((int )*src == 91) {
      goto case_46;
    }
    if ((int )*src == 126) {
      goto case_126;
    }
    if ((int )*src == 92) {
      goto case_92;
    }
    if ((int )*src == 94) {
      goto case_94;
    }
    if ((int )*src == 36) {
      goto case_94;
    }
    goto switch_break;
    case_46: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_91: /* CIL Label */ 
    if (ctrl_x_mode == 265) {
      goto switch_break;
    }
    case_126: /* CIL Label */ 
    if (! p_magic) {
      goto switch_break;
    }
    case_92: /* CIL Label */ 
    if (ctrl_x_mode == 265) {
      goto switch_break;
    }
    case_94: /* CIL Label */ 
    case_36: /* CIL Label */ 
    m ++;
    if (dest) {
      tmp = dest;
      dest ++;
      *tmp = (char_u )'\\';
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    if (dest) {
      tmp___0 = dest;
      dest ++;
      *tmp___0 = *src;
    }
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (dest) {
    *dest = (char_u )'\000';
  }
  return (m);
}
}
int get_literal(void) 
{ 
  int cc___0 ;
  int nc ;
  int i___0 ;
  int hexmode ;
  int octalmode ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  hexmode = 0;
  octalmode = 0;
  if (got_int) {
    return (3);
  }
  no_mapping ++;
  cc___0 = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      nc = safe_vgetc();
      }
      if (! (nc == 253 + (51 << 8))) {
        if (! (nc == 249 + (88 << 8))) {
          if (! (nc == 248 + (88 << 8))) {
            goto while_break___0;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (! (State & 8)) {
      {
      add_to_showcmd(nc);
      }
    }
    if (nc == 120) {
      hexmode ++;
    } else { //Added block
    if (nc == 88) {
      hexmode ++;
    } else { //Added block
    if (nc == 111) {
      octalmode ++;
    } else { //Added block
    if (nc == 79) {
      octalmode ++;
    } else {
      if (hexmode) {
        {
        tmp = vim_isdigit(nc);
        }
        if (! tmp) {
          {
          tmp___0 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___0 + nc) & 4096)) {
            goto while_break;
          }
        }
        {
        nc = tolower(nc);
        }
        if (nc >= 97) {
          nc = (10 + nc) - 97;
        } else {
          nc -= 48;
        }
        cc___0 = cc___0 * 16 + nc;
      } else { //Added block
      if (octalmode) {
        {
        tmp___1 = vim_isdigit(nc);
        }
        if (tmp___1) {
          if (nc > 55) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        cc___0 = (cc___0 * 8 + nc) - 48;
      } else {
        {
        tmp___2 = vim_isdigit(nc);
        }
        if (! tmp___2) {
          goto while_break;
        }
        cc___0 = (cc___0 * 10 + nc) - 48;
      }
      }
      i___0 ++;
    }
    }
    }
    }
    if (cc___0 > 255) {
      cc___0 = 255;
    }
    nc = 0;
    if (hexmode) {
      if (i___0 >= 2) {
        goto while_break;
      }
    }
    if (! hexmode) {
      if (i___0 >= 3) {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (i___0 == 0) {
    if (nc == 255 + (88 << 8)) {
      cc___0 = '\n';
      nc = 0;
    } else {
      cc___0 = nc;
      nc = 0;
    }
  }
  if (cc___0 == 0) {
    cc___0 = '\n';
  }
  no_mapping --;
  if (nc) {
    {
    vungetc(nc);
    }
  }
  got_int = 0;
  return (cc___0);
}
}
static void insert_special(int c , int allow_modmask , int ctrlv ) 
{ 
  char_u *p___0 ;
  int len___0 ;
  size_t tmp ;

  {
  if (c >= 512) {
    goto _L;
  } else { //Added block
  if (mod_mask) {
    if (allow_modmask) {
      _L: 
      {
      p___0 = get_special_key_name(c, mod_mask);
      tmp = strlen((char const   *)((char *)p___0));
      len___0 = (int )tmp;
      c = (int )*(p___0 + (len___0 - 1));
      }
      if (len___0 > 2) {
        {
        *(p___0 + (len___0 - 1)) = (char_u )'\000';
        ins_str(p___0);
        AppendToRedobuff(p___0);
        ctrlv = 0;
        }
      }
    }
  }
  }
  {
  insertchar((unsigned int )c, 0, -1, ctrlv);
  }
  return;
}
}
void insertchar(unsigned int c , int force_formatting , int second_indent , int ctrlv ) 
{ 
  int haveto_redraw ;
  int textwidth ;
  colnr_t leader_len ;
  int first_line ;
  int fo_ins_blank ;
  int save_char ;
  int cc___0 ;
  char_u *p___0 ;
  int startcol ;
  int wantcol ;
  int foundcol ;
  int end_foundcol ;
  int orig_col ;
  colnr_t len___0 ;
  colnr_t virtcol ;
  char_u *saved_text ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  size_t tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  char_u *line ;
  char_u lead_end[50] ;
  int middle_len ;
  int end_len ;
  int i___0 ;
  int old_fo_do_comments ;
  char_u *tmp___13 ;
  char_u buf___3[101] ;
  int i___1 ;
  colnr_t virtcol___0 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
  haveto_redraw = 0;
  first_line = 1;
  save_char = '\000';
  stop_arrow();
  textwidth = comp_textwidth(force_formatting);
  fo_ins_blank = has_format_option('b');
  }
  if (textwidth) {
    if (force_formatting) {
      goto _L___3;
    } else { //Added block
    if (! (c == 32U)) {
      if (! (c == 9U)) {
        if (State == 528) {
          {
          tmp___11 = ml_get_cursor();
          }
          if (! ((int )*tmp___11 != 0)) {
            goto _L___5;
          }
        } else { //Added block
        _L___5: 
        if (curwin->w_cursor.lnum != Insstart.lnum) {
          goto _L___3;
        } else {
          {
          tmp___12 = has_format_option('l');
          }
          if (tmp___12) {
            if (Insstart_textlen <= (colnr_t )textwidth) {
              _L___4: 
              if (! fo_ins_blank) {
                goto _L___3;
              } else { //Added block
              if (Insstart_blank_vcol <= (colnr_t )textwidth) {
                _L___3: 
                if (! curbuf->b_p_ai) {
                  {
                  cc___0 = gchar_cursor();
                  }
                  if (cc___0 == 32) {
                    {
                    save_char = cc___0;
                    pchar_cursor('x');
                    }
                  } else { //Added block
                  if (cc___0 == 9) {
                    {
                    save_char = cc___0;
                    pchar_cursor('x');
                    }
                  }
                  }
                }
                {
                while (1) {
                  while_continue: /* CIL Label */ ;
                  if (! (! got_int)) {
                    goto while_break;
                  }
                  {
                  end_foundcol = 0;
                  orig_col = 0;
                  saved_text = (char_u *)((void *)0);
                  virtcol = get_nolist_virtcol();
                  }
                  if (virtcol < (colnr_t )textwidth) {
                    goto while_break;
                  }
                  if (! force_formatting) {
                    {
                    tmp = has_format_option('c');
                    }
                    if (tmp) {
                      fo_do_comments = 1;
                    }
                  }
                  {
                  tmp___0 = ml_get_curline();
                  tmp___1 = get_leader_len(tmp___0, (char_u **)((void *)0), 0);
                  leader_len = (colnr_t )tmp___1;
                  }
                  if (! force_formatting) {
                    if (leader_len == 0U) {
                      {
                      tmp___2 = has_format_option('t');
                      }
                      if (! tmp___2) {
                        textwidth = 0;
                        goto while_break;
                      }
                    }
                  }
                  startcol = (int )curwin->w_cursor.col;
                  if (startcol == 0) {
                    goto while_break;
                  }
                  {
                  coladvance((colnr_t )textwidth);
                  wantcol = (int )curwin->w_cursor.col;
                  curwin->w_cursor.col = (colnr_t )(startcol - 1);
                  foundcol = 0;
                  }
                  {
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
                    if (curwin->w_cursor.col > 0U) {
                      if (! fo_ins_blank) {
                        {
                        tmp___3 = has_format_option('v');
                        }
                        if (tmp___3) {
                          goto _L___0;
                        }
                      } else { //Added block
                      _L___0: 
                      if (! (curwin->w_cursor.lnum != Insstart.lnum)) {
                        if (! (curwin->w_cursor.col >= Insstart.col)) {
                          goto while_break___0;
                        }
                      }
                      }
                    } else {
                      goto while_break___0;
                    }
                    {
                    cc___0 = gchar_cursor();
                    }
                    if (cc___0 == 32) {
                      goto _L;
                    } else { //Added block
                    if (cc___0 == 9) {
                      _L: 
                      end_foundcol = (int )curwin->w_cursor.col;
                      {
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
                        if (curwin->w_cursor.col > 0U) {
                          if (! (cc___0 == 32)) {
                            if (! (cc___0 == 9)) {
                              goto while_break___1;
                            }
                          }
                        } else {
                          goto while_break___1;
                        }
                        {
                        (curwin->w_cursor.col) --;
                        cc___0 = gchar_cursor();
                        }
                      }
                      while_break___1: /* CIL Label */ ;
                      }
                      if (curwin->w_cursor.col == 0U) {
                        if (cc___0 == 32) {
                          goto while_break___0;
                        } else { //Added block
                        if (cc___0 == 9) {
                          goto while_break___0;
                        }
                        }
                      }
                      if (curwin->w_cursor.col < leader_len) {
                        goto while_break___0;
                      }
                      foundcol = (int )(curwin->w_cursor.col + 1U);
                      if (curwin->w_cursor.col < (colnr_t )wantcol) {
                        goto while_break___0;
                      }
                    }
                    }
                    (curwin->w_cursor.col) --;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                  if (foundcol == 0) {
                    curwin->w_cursor.col = (colnr_t )startcol;
                    goto while_break;
                  }
                  if (State == 784) {
                    orig_col = startcol;
                  } else {
                    replace_offset = (startcol - end_foundcol) - 1;
                  }
                  curwin->w_cursor.col = (colnr_t )foundcol;
                  {
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
                    {
                    cc___0 = gchar_cursor();
                    }
                    if (cc___0 == 32) {
                      tmp___4 = 1;
                    } else { //Added block
                    if (cc___0 == 9) {
                      tmp___4 = 1;
                    } else {
                      tmp___4 = 0;
                    }
                    }
                    if (! tmp___4) {
                      goto while_break___2;
                    }
                    (curwin->w_cursor.col) ++;
                    startcol --;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
                  startcol -= foundcol;
                  if (startcol < 0) {
                    startcol = 0;
                  }
                  if (State == 784) {
                    {
                    tmp___5 = ml_get_cursor();
                    saved_text = vim_strsave(tmp___5);
                    curwin->w_cursor.col = (colnr_t )orig_col;
                    }
                    if ((unsigned long )saved_text == (unsigned long )((void *)0)) {
                      goto while_break;
                    }
                    {
                    *(saved_text + startcol) = (char_u )'\000';
                    backspace_until_column(foundcol);
                    }
                  } else {
                    curwin->w_cursor.col = (colnr_t )foundcol;
                  }
                  {
                  tmp___8 = redrawing();
                  }
                  if (tmp___8) {
                    if (! force_formatting) {
                      tmp___7 = -1;
                    } else {
                      tmp___7 = 0;
                    }
                  } else {
                    tmp___7 = 0;
                  }
                  {
                  open_line(1, tmp___7, 1, old_indent);
                  old_indent = 0;
                  replace_offset = 0;
                  }
                  if (second_indent >= 0) {
                    if (first_line) {
                      if (State == 784) {
                        {
                        change_indent(1, second_indent, 0, '\000');
                        }
                      } else {
                        {
                        set_indent(second_indent, 1);
                        }
                      }
                    }
                  }
                  first_line = 0;
                  if (State == 784) {
                    p___0 = saved_text;
                    {
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
                      if (! ((int )*p___0 != 0)) {
                        goto while_break___3;
                      }
                      {
                      ins_char((int )*p___0);
                      p___0 ++;
                      }
                    }
                    while_break___3: /* CIL Label */ ;
                    }
                    {
                    vim_free((void *)saved_text);
                    }
                  } else {
                    {
                    curwin->w_cursor.col += (colnr_t )startcol;
                    tmp___9 = ml_get_curline();
                    tmp___10 = strlen((char const   *)((char *)tmp___9));
                    len___0 = (colnr_t )tmp___10;
                    }
                    if (curwin->w_cursor.col > len___0) {
                      curwin->w_cursor.col = len___0;
                    }
                  }
                  {
                  haveto_redraw = 1;
                  can_cindent = 1;
                  did_ai = 0;
                  did_si = 0;
                  can_si = 0;
                  can_si_back = 0;
                  line_breakcheck();
                  }
                }
                while_break: /* CIL Label */ ;
                }
                if (save_char) {
                  {
                  pchar_cursor(save_char);
                  }
                }
                if (c == 0U) {
                  return;
                }
                fo_do_comments = 0;
                if (haveto_redraw) {
                  {
                  update_topline();
                  update_screen(40);
                  }
                }
              }
              }
            }
          } else {
            goto _L___4;
          }
        }
        }
      }
    }
    }
  }
  if (c == 0U) {
    return;
  }
  if (did_ai) {
    if ((int )c == end_comment_pending) {
      {
      old_fo_do_comments = fo_do_comments;
      fo_do_comments = 1;
      line = ml_get_curline();
      i___0 = get_leader_len(line, & p___0, 0);
      }
      if (i___0 > 0) {
        {
        tmp___13 = vim_strchr(p___0, 'm');
        }
        if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (*p___0) {
              if (! ((int )*(p___0 + -1) != 58)) {
                goto while_break___4;
              }
            } else {
              goto while_break___4;
            }
            p___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
          middle_len = copy_option_part(& p___0, lead_end, 50, (char *)",");
          }
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (middle_len > 0) {
              if (! ((int )lead_end[middle_len - 1] == 32)) {
                if (! ((int )lead_end[middle_len - 1] == 9)) {
                  goto while_break___5;
                }
              }
            } else {
              goto while_break___5;
            }
            middle_len --;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
          while (1) {
            while_continue___6: /* CIL Label */ ;
            if (*p___0) {
              if (! ((int )*(p___0 + -1) != 58)) {
                goto while_break___6;
              }
            } else {
              goto while_break___6;
            }
            p___0 ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
          end_len = copy_option_part(& p___0, lead_end, 50, (char *)",");
          i___0 = (int )curwin->w_cursor.col;
          }
          {
          while (1) {
            while_continue___7: /* CIL Label */ ;
            i___0 --;
            if (i___0 >= 0) {
              if (! ((int )*(line + i___0) == 32)) {
                if (! ((int )*(line + i___0) == 9)) {
                  goto while_break___7;
                }
              }
            } else {
              goto while_break___7;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
          i___0 ++;
          i___0 -= middle_len;
          if (i___0 >= 0) {
            if ((int )lead_end[end_len - 1] == end_comment_pending) {
              {
              backspace_until_column(i___0);
              i___0 = 0;
              }
              {
              while (1) {
                while_continue___8: /* CIL Label */ ;
                if (! (i___0 < end_len - 1)) {
                  goto while_break___8;
                }
                {
                ins_char((int )lead_end[i___0]);
                i___0 ++;
                }
              }
              while_break___8: /* CIL Label */ ;
              }
            }
          }
        }
      }
      fo_do_comments = old_fo_do_comments;
    }
  }
  end_comment_pending = '\000';
  did_ai = 0;
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  if (c < 32U) {
    goto _L___11;
  } else { //Added block
  if (c >= 127U) {
    goto _L___11;
  } else { //Added block
  if (c == 48U) {
    goto _L___11;
  } else { //Added block
  if (c == 94U) {
    _L___11: 
    {
    ins_char((int )c);
    }
    if (ctrlv) {
      {
      redo_literal((int )c);
      }
    } else {
      {
      AppendCharToRedobuff((int )c);
      }
    }
  } else {
    {
    tmp___20 = vpeekc();
    }
    if (tmp___20 != 0) {
      if (State != 528) {
        if (State != 784) {
          if (! curbuf->b_p_cin) {
            virtcol___0 = (colnr_t )0;
            buf___3[0] = (char_u )c;
            i___1 = 1;
            if (textwidth) {
              {
              virtcol___0 = get_nolist_virtcol();
              }
            }
            {
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
              tmp___16 = vpeekc();
              c = (unsigned int )tmp___16;
              }
              if (c != 0U) {
                if (c < 32U) {
                  goto while_break___9;
                } else { //Added block
                if (c >= 127U) {
                  goto while_break___9;
                } else { //Added block
                if (c == 48U) {
                  goto while_break___9;
                } else { //Added block
                if (c == 94U) {
                  goto while_break___9;
                } else { //Added block
                if (i___1 < 100) {
                  if (textwidth == 0) {
                    goto _L___6;
                  } else {
                    {
                    tmp___17 = charsize((int )buf___3[i___1 - 1]);
                    virtcol___0 += (colnr_t )tmp___17;
                    }
                    if (virtcol___0 < (colnr_t )textwidth) {
                      _L___6: 
                      if (! no_abbr) {
                        {
                        tmp___18 = vim_iswordc((int )c);
                        }
                        if (! tmp___18) {
                          {
                          tmp___19 = vim_iswordc((int )buf___3[i___1 - 1]);
                          }
                          if (tmp___19) {
                            goto while_break___9;
                          }
                        }
                      }
                    } else {
                      goto while_break___9;
                    }
                  }
                } else {
                  goto while_break___9;
                }
                }
                }
                }
                }
              } else {
                goto while_break___9;
              }
              {
              tmp___14 = i___1;
              i___1 ++;
              tmp___15 = vgetc();
              buf___3[tmp___14] = (char_u )tmp___15;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
            {
            do_digraph(-1);
            do_digraph((int )buf___3[i___1 - 1]);
            buf___3[i___1] = (char_u )'\000';
            ins_str(buf___3);
            }
            if (ctrlv) {
              {
              redo_literal((int )buf___3[0]);
              i___1 = 1;
              }
            } else {
              i___1 = 0;
            }
            if ((int )buf___3[i___1] != 0) {
              {
              AppendToRedobuff(buf___3 + i___1);
              }
            }
          } else {
            goto _L___11;
          }
        } else {
          goto _L___11;
        }
      } else {
        goto _L___11;
      }
    } else {
      goto _L___11;
    }
  }
  }
  }
  }
  return;
}
}
int comp_textwidth(int ff ) 
{ 
  int textwidth ;

  {
  textwidth = (int )curbuf->b_p_tw;
  if (textwidth == 0) {
    if (curbuf->b_p_wm) {
      textwidth = (int )(Columns - curbuf->b_p_wm);
    }
  }
  if (textwidth < 0) {
    textwidth = 0;
  }
  if (ff) {
    if (textwidth == 0) {
      textwidth = (int )(Columns - 1L);
      if (textwidth > 79) {
        textwidth = 79;
      }
    }
  }
  return (textwidth);
}
}
static void redo_literal(int c ) 
{ 
  char_u buf___3[10] ;
  int tmp ;

  {
  {
  tmp = vim_isdigit(c);
  }
  if (tmp) {
    {
    sprintf((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )"%03d",
            c);
    AppendToRedobuff(buf___3);
    }
  } else {
    {
    AppendCharToRedobuff(c);
    }
  }
  return;
}
}
static void start_arrow(FPOS *end_insert_pos ) 
{ 


  {
  if (! arrow_used) {
    {
    AppendToRedobuff((char_u *)"\033");
    arrow_used = 1;
    stop_insert(end_insert_pos);
    }
  }
  return;
}
}
void stop_arrow(void) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  if (arrow_used) {
    {
    u_save_cursor();
    Insstart = curwin->w_cursor;
    tmp = ml_get_curline();
    tmp___0 = linetabsize(tmp);
    Insstart_textlen = (colnr_t )tmp___0;
    ai_col = (colnr_t )0;
    }
    if (State == 784) {
      orig_line_count = (int )curbuf->b_ml.ml_line_count;
      vr_lines_changed = 1;
      vr_virtcol = (colnr_t )2147483647;
    }
    {
    ResetRedobuff();
    AppendToRedobuff((char_u *)"1i");
    arrow_used = 0;
    }
  }
  return;
}
}
static void stop_insert(FPOS *end_insert_pos ) 
{ 
  int cc___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  stop_redo_ins();
  replace_flush();
  vim_free((void *)last_insert);
  last_insert = get_inserted();
  last_insert_skip = new_insert_skip;
  }
  if (did_ai) {
    if (! arrow_used) {
      {
      tmp = gchar_cursor();
      }
      if (tmp == 0) {
        if (curwin->w_cursor.col > 0U) {
          (curwin->w_cursor.col) --;
        }
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        cc___0 = gchar_cursor();
        }
        if (cc___0 == 32) {
          tmp___0 = 1;
        } else { //Added block
        if (cc___0 == 9) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
        }
        if (! tmp___0) {
          goto while_break;
        }
        {
        del_char(1);
        }
      }
      while_break: /* CIL Label */ ;
      }
      if (cc___0 != 0) {
        (curwin->w_cursor.col) ++;
      }
      if (curwin->w_p_list) {
        {
        update_screenline();
        }
      } else { //Added block
      if (p_hls) {
        if (! no_hlsearch) {
          {
          update_screenline();
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
        {
        tmp___1 = syntax_present(curbuf);
        }
        if (tmp___1) {
          {
          update_screenline();
          }
        }
      }
      }
    }
  }
  did_ai = 0;
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  curbuf->b_op_start = Insstart;
  curbuf->b_op_end = *end_insert_pos;
  return;
}
}
void set_last_insert(int c ) 
{ 
  unsigned short const   **tmp___0 ;

  {
  {
  vim_free((void *)last_insert);
  last_insert = alloc(4U);
  }
  if ((unsigned long )last_insert != (unsigned long )((void *)0)) {
    {
    *(last_insert + 0) = (char_u )22;
    *(last_insert + 1) = (char_u )c;
    *(last_insert + 2) = (char_u )'\033';
    *(last_insert + 3) = (char_u )'\000';
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + c) & 2048) {
      last_insert_skip = 1;
    } else {
      last_insert_skip = 0;
    }
  }
  return;
}
}
void beginline(int flags___0 ) 
{ 
  char_u *ptr ;

  {
  if (flags___0 & 2) {
    if (! p_sol) {
      {
      coladvance(curwin->w_curswant);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    curwin->w_cursor.col = (colnr_t )0;
    if (flags___0 & 3) {
      {
      ptr = ml_get_curline();
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if ((int )*ptr == 32) {
          goto _L;
        } else { //Added block
        if ((int )*ptr == 9) {
          _L: 
          if (flags___0 & 4) {
            if ((int )*(ptr + 1) == 0) {
              goto while_break;
            }
          }
        } else {
          goto while_break;
        }
        }
        (curwin->w_cursor.col) ++;
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    curwin->w_set_curswant = 1;
  }
  return;
}
}
int oneright(void) 
{ 
  char_u *ptr ;
  char_u *tmp ;

  {
  {
  ptr = ml_get_cursor();
  tmp = ptr;
  ptr ++;
  }
  if ((int )*tmp == 0) {
    return (0);
  } else { //Added block
  if ((int )*ptr == 0) {
    return (0);
  }
  }
  curwin->w_set_curswant = 1;
  (curwin->w_cursor.col) ++;
  return (1);
}
}
int oneleft(void) 
{ 


  {
  if (curwin->w_cursor.col == 0U) {
    return (0);
  }
  curwin->w_set_curswant = 1;
  (curwin->w_cursor.col) --;
  return (1);
}
}
int cursor_up(long n , int upd_topline ) 
{ 


  {
  if (n != 0L) {
    if (curwin->w_cursor.lnum <= 1L) {
      return (0);
    }
    if (n >= curwin->w_cursor.lnum) {
      curwin->w_cursor.lnum = (linenr_t )1;
    } else {
      curwin->w_cursor.lnum -= n;
    }
  }
  {
  coladvance(curwin->w_curswant);
  }
  if (upd_topline) {
    {
    update_topline();
    }
  }
  return (1);
}
}
int cursor_down(long n , int upd_topline ) 
{ 


  {
  if (n != 0L) {
    if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count) {
      return (0);
    }
    curwin->w_cursor.lnum += n;
    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
    }
  }
  {
  coladvance(curwin->w_curswant);
  }
  if (upd_topline) {
    {
    update_topline();
    }
  }
  return (1);
}
}
int stuff_inserted(int c , long count___2 , int no_esc ) 
{ 
  char_u *esc_ptr ;
  char_u *ptr ;
  char_u *last_ptr ;
  char_u last ;
  char_u *tmp ;
  size_t tmp___0 ;
  char_u *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  last = (char_u )'\000';
  ptr = get_last_insert();
  }
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
    emsg(e_noinstext);
    }
    return (0);
  }
  if (c) {
    {
    stuffcharReadbuff(c);
    }
  }
  {
  tmp = vim_strrchr(ptr, '\033');
  esc_ptr = tmp;
  }
  if ((unsigned long )esc_ptr != (unsigned long )((void *)0)) {
    *esc_ptr = (char_u )'\000';
  }
  if (esc_ptr) {
    tmp___1 = esc_ptr;
  } else {
    {
    tmp___0 = strlen((char const   *)((char *)ptr));
    tmp___1 = ptr + tmp___0;
    }
  }
  last_ptr = tmp___1 - 1;
  if ((unsigned long )last_ptr >= (unsigned long )ptr) {
    if ((int )*last_ptr == 48) {
      goto _L;
    } else { //Added block
    if ((int )*last_ptr == 94) {
      _L: 
      if (no_esc) {
        last = *last_ptr;
        *last_ptr = (char_u )'\000';
      } else { //Added block
      if ((int )*ptr == 4) {
        if (count___2 > 1L) {
          last = *last_ptr;
          *last_ptr = (char_u )'\000';
        }
      }
      }
    }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    stuffReadbuff(ptr);
    }
    if (last) {
      if ((int )last == 48) {
        tmp___2 = "\026048";
      } else {
        tmp___2 = "\026^";
      }
      {
      stuffReadbuff((char_u *)tmp___2);
      }
    }
    count___2 --;
    if (! (count___2 > 0L)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (last) {
    *last_ptr = last;
  }
  if ((unsigned long )esc_ptr != (unsigned long )((void *)0)) {
    *esc_ptr = (char_u )'\033';
  }
  if (! no_esc) {
    {
    stuffcharReadbuff('\033');
    }
  }
  return (1);
}
}
char_u *get_last_insert(void) 
{ 


  {
  if ((unsigned long )last_insert == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  return (last_insert + last_insert_skip);
}
}
char_u *get_last_insert_save(void) 
{ 
  char_u *s ;
  int len___0 ;
  size_t tmp ;

  {
  if ((unsigned long )last_insert == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  s = vim_strsave(last_insert + last_insert_skip);
  }
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    tmp = strlen((char const   *)((char *)s));
    len___0 = (int )tmp;
    }
    if (len___0 > 0) {
      if ((int )*(s + (len___0 - 1)) == 27) {
        *(s + (len___0 - 1)) = (char_u )'\000';
      }
    }
  }
  return (s);
}
}
static int echeck_abbr(int c ) 
{ 
  colnr_t tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  if (p_paste) {
    return (0);
  } else { //Added block
  if (no_abbr) {
    return (0);
  } else { //Added block
  if (arrow_used) {
    return (0);
  }
  }
  }
  if (curwin->w_cursor.lnum == Insstart.lnum) {
    tmp = Insstart.col;
  } else {
    tmp = (colnr_t )0;
  }
  {
  tmp___0 = ml_get_curline();
  tmp___1 = check_abbr(c, tmp___0, (int )curwin->w_cursor.col, (int )tmp);
  }
  return (tmp___1);
}
}
char_u *replace_stack  =    (char_u *)((void *)0);
long replace_stack_nr  =    0L;
long replace_stack_len  =    0L;
void replace_push(int c ) 
{ 
  char_u *p___0 ;

  {
  if (replace_stack_nr < (long )replace_offset) {
    return;
  }
  if (replace_stack_len <= replace_stack_nr) {
    {
    replace_stack_len += 50L;
    p___0 = lalloc(sizeof(char_u ) * (unsigned long )replace_stack_len, 1);
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      replace_stack_len -= 50L;
      return;
    }
    if ((unsigned long )replace_stack != (unsigned long )((void *)0)) {
      {
      memmove((void *)((char *)p___0), (void const   *)((char *)replace_stack), (unsigned long )replace_stack_nr * sizeof(char_u ));
      vim_free((void *)replace_stack);
      }
    }
    replace_stack = p___0;
  }
  p___0 = (replace_stack + replace_stack_nr) - replace_offset;
  if (replace_offset) {
    {
    memmove((void *)((char *)(p___0 + 1)), (void const   *)((char *)p___0), (unsigned long )replace_offset * sizeof(char_u ));
    }
  }
  *p___0 = (char_u )c;
  replace_stack_nr ++;
  return;
}
}
static void replace_push_off(int c ) 
{ 
  char_u *p___0 ;

  {
  p___0 = replace_stack + replace_stack_nr;
  replace_offset = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((long )replace_offset < replace_stack_nr)) {
      goto while_break;
    }
    p___0 --;
    if ((int )*p___0 == 0) {
      goto while_break;
    }
    replace_offset ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  replace_push(c);
  replace_offset = 0;
  }
  return;
}
}
static int replace_pop(void) 
{ 


  {
  vr_virtcol = (colnr_t )2147483647;
  if (replace_stack_nr == 0L) {
    return (-1);
  }
  replace_stack_nr --;
  return ((int )*(replace_stack + replace_stack_nr));
}
}
static void replace_join(int off___0 ) 
{ 
  int i___0 ;
  int tmp ;

  {
  i___0 = (int )replace_stack_nr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    if ((int )*(replace_stack + i___0) == 0) {
      tmp = off___0;
      off___0 --;
      if (tmp <= 0) {
        {
        replace_stack_nr --;
        memmove((void *)((char *)(replace_stack + i___0)), (void const   *)((char *)((replace_stack + i___0) + 1)),
                (size_t )(replace_stack_nr - (long )i___0));
        }
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void replace_pop_ins(void) 
{ 
  int cc___0 ;
  int oldState ;

  {
  oldState = State;
  State = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    cc___0 = replace_pop();
    }
    if (! (cc___0 > 0)) {
      goto while_break;
    }
    {
    ins_char(cc___0);
    dec_cursor();
    }
  }
  while_break: /* CIL Label */ ;
  }
  State = oldState;
  return;
}
}
static void replace_flush(void) 
{ 


  {
  {
  vim_free((void *)replace_stack);
  replace_stack = (char_u *)((void *)0);
  replace_stack_len = 0L;
  replace_stack_nr = 0L;
  }
  return;
}
}
static void replace_do_bs(void) 
{ 
  int cc___0 ;

  {
  {
  cc___0 = replace_pop();
  }
  if (cc___0 > 0) {
    {
    pchar_cursor(cc___0);
    replace_pop_ins();
    }
  } else { //Added block
  if (cc___0 == 0) {
    {
    del_char(0);
    }
  }
  }
  return;
}
}
int get_replace_stack_virtcol(void) 
{ 
  int col ;
  colnr_t vcol ;
  int i___0 ;
  FPOS pos___0 ;
  int tmp ;
  int tmp___0 ;

  {
  col = (int )curwin->w_cursor.col;
  vcol = (colnr_t )0;
  i___0 = (int )replace_stack_nr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i___0 >= 0) {
      tmp = col;
      col --;
      if (! tmp) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      i___0 --;
      if (i___0 >= 0) {
        if (! ((int )*(replace_stack + i___0) != 0)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (col >= 0) {
    {
    pos___0.lnum = curwin->w_cursor.lnum;
    pos___0.col = (colnr_t )(col + 1);
    getvcol(curwin, & pos___0, (colnr_t *)((void *)0), & vcol, (colnr_t *)((void *)0));
    i___0 ++;
    }
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! ((long )i___0 < replace_stack_nr)) {
      goto while_break___1;
    }
    if ((int )*(replace_stack + i___0) != 0) {
      {
      tmp___0 = chartabsize((int )*(replace_stack + i___0), vcol);
      vcol += (colnr_t )tmp___0;
      }
    }
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return ((int )vcol);
}
}
void fixthisline(int (*get_the_indent)(void) ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = (*get_the_indent)();
  change_indent(1, tmp, 0, 0);
  tmp___0 = linewhite(curwin->w_cursor.lnum);
  }
  if (tmp___0) {
    did_ai = 1;
  }
  return;
}
}
int in_cinkeys(int keytyped , int when , int line_is_empty ) 
{ 
  char_u *look ;
  int try_match ;
  char_u *p___0 ;
  int i___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;

  {
  look = curbuf->b_p_cink;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *look) {
      goto while_break;
    }
    {
    if (when == 42) {
      goto case_42;
    }
    if (when == 33) {
      goto case_33;
    }
    goto switch_default;
    case_42: /* CIL Label */ 
    try_match = (int )*look == 42;
    goto switch_break;
    case_33: /* CIL Label */ 
    try_match = (int )*look == 33;
    goto switch_break;
    switch_default: /* CIL Label */ 
    try_match = (int )*look != 42;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    if ((int )*look == 42) {
      look ++;
    } else { //Added block
    if ((int )*look == 33) {
      look ++;
    }
    }
    if ((int )*look == 48) {
      if (! line_is_empty) {
        try_match = 0;
      }
      look ++;
    }
    if ((int )*look == 94) {
      if ((int )*(look + 1) >= 64) {
        if ((int )*(look + 1) <= 95) {
          if (try_match) {
            if (keytyped == ((int )*(look + 1) & 31)) {
              return (1);
            }
          }
          look += 2;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((int )*look == 111) {
      if (try_match) {
        if (keytyped == 257) {
          return (1);
        }
      }
      look ++;
    } else { //Added block
    if ((int )*look == 79) {
      if (try_match) {
        if (keytyped == 258) {
          return (1);
        }
      }
      look ++;
    } else { //Added block
    if ((int )*look == 101) {
      if (try_match) {
        if (keytyped == 101) {
          if (curwin->w_cursor.col >= 4U) {
            {
            p___0 = ml_get_curline();
            tmp = skipwhite(p___0);
            }
            if ((unsigned long )tmp == (unsigned long )((p___0 + curwin->w_cursor.col) - 4)) {
              {
              tmp___0 = strncmp((char const   *)((char *)((p___0 + curwin->w_cursor.col) - 4)),
                                (char const   *)((char *)"else"), (size_t )4);
              }
              if (tmp___0 == 0) {
                return (1);
              }
            }
          }
        }
      }
      look ++;
    } else { //Added block
    if ((int )*look == 58) {
      if (try_match) {
        if (keytyped == 58) {
          {
          p___0 = ml_get_curline();
          tmp___1 = cin_iscase(p___0);
          }
          if (tmp___1) {
            return (1);
          } else {
            {
            tmp___2 = cin_isscopedecl(p___0);
            }
            if (tmp___2) {
              return (1);
            } else {
              {
              tmp___3 = cin_islabel(30);
              }
              if (tmp___3) {
                return (1);
              }
            }
          }
          if (curwin->w_cursor.col > 2U) {
            if ((int )*(p___0 + (curwin->w_cursor.col - 1U)) == 58) {
              if ((int )*(p___0 + (curwin->w_cursor.col - 2U)) == 58) {
                {
                *(p___0 + (curwin->w_cursor.col - 1U)) = (char_u )' ';
                tmp___4 = cin_iscase(p___0);
                }
                if (tmp___4) {
                  tmp___7 = 1;
                } else {
                  {
                  tmp___5 = cin_isscopedecl(p___0);
                  }
                  if (tmp___5) {
                    tmp___7 = 1;
                  } else {
                    {
                    tmp___6 = cin_islabel(30);
                    }
                    if (tmp___6) {
                      tmp___7 = 1;
                    } else {
                      tmp___7 = 0;
                    }
                  }
                }
                {
                i___0 = tmp___7;
                p___0 = ml_get_curline();
                *(p___0 + (curwin->w_cursor.col - 1U)) = (char_u )':';
                }
                if (i___0) {
                  return (1);
                }
              }
            }
          }
        }
      }
      look ++;
    } else { //Added block
    if ((int )*look == 60) {
      if (try_match) {
        {
        tmp___8 = vim_strchr((char_u *)"<>!*oOe0", (int )*(look + 1));
        }
        if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
          if (keytyped == (int )*(look + 1)) {
            return (1);
          }
        }
        {
        tmp___9 = get_special_key_code(look + 1);
        }
        if (keytyped == tmp___9) {
          return (1);
        }
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (*look) {
          if (! ((int )*look != 62)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        look ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((int )*look == 62)) {
          goto while_break___1;
        }
        look ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      if (try_match) {
        if ((int )*look == keytyped) {
          return (1);
        }
      }
      look ++;
    }
    }
    }
    }
    }
    }
    {
    look = skip_to_option_part(look);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int ins_reg(void) 
{ 
  int need_redraw ;
  int regname___0 ;
  int literally ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  need_redraw = 0;
  literally = 0;
  tmp = redrawing();
  }
  if (tmp) {
    {
    tmp___0 = char_avail();
    }
    if (! tmp___0) {
      {
      edit_putchar('\"', 1);
      add_to_showcmd_c(18);
      }
    }
  }
  {
  no_mapping ++;
  regname___0 = safe_vgetc();
  }
  if (regname___0 == 18) {
    {
    literally = regname___0;
    add_to_showcmd_c(literally);
    regname___0 = safe_vgetc();
    }
  } else { //Added block
  if (regname___0 == 15) {
    {
    literally = regname___0;
    add_to_showcmd_c(literally);
    regname___0 = safe_vgetc();
    }
  } else { //Added block
  if (regname___0 == 16) {
    {
    literally = regname___0;
    add_to_showcmd_c(literally);
    regname___0 = safe_vgetc();
    }
  }
  }
  }
  no_mapping --;
  no_u_sync ++;
  if (regname___0 == 61) {
    {
    regname___0 = get_expr_register();
    }
  }
  if (regname___0 == 0) {
    need_redraw = 1;
  } else { //Added block
  if (literally == 15) {
    goto _L;
  } else { //Added block
  if (literally == 16) {
    _L: 
    {
    AppendCharToRedobuff(18);
    AppendCharToRedobuff(literally);
    AppendCharToRedobuff(regname___0);
    }
    if (literally == 16) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    {
    do_put(regname___0, -1, 1L, tmp___1 | 2);
    }
  } else {
    {
    tmp___2 = insert_reg(regname___0, literally);
    }
    if (tmp___2 == 0) {
      {
      vim_beep();
      need_redraw = 1;
      }
    }
  }
  }
  }
  {
  no_u_sync --;
  clear_showcmd();
  tmp___3 = stuff_empty();
  }
  if (tmp___3) {
    need_redraw = 1;
  }
  return (need_redraw);
}
}
static int disabled_redraw  =    0;
static int ins_esc(long *count___2 , int need_redraw , int cmdchar ) 
{ 
  int temp ;
  int tmp ;

  {
  temp = (int )curwin->w_cursor.col;
  if (disabled_redraw) {
    RedrawingDisabled --;
    disabled_redraw = 0;
  }
  if (! arrow_used) {
    if (cmdchar != 114) {
      if (cmdchar != 118) {
        {
        AppendToRedobuff((char_u *)"\033");
        }
      }
    }
    if (*count___2) {
      {
      line_breakcheck();
      }
      if (got_int) {
        *count___2 = 0L;
      }
    }
    (*count___2) --;
    if (*count___2 > 0L) {
      {
      start_redo_ins();
      RedrawingDisabled ++;
      disabled_redraw = 1;
      }
      return (0);
    }
    {
    stop_insert(& curwin->w_cursor);
    }
    if (dollar_vcol) {
      dollar_vcol = (colnr_t )0;
      if (curwin->w_redr_status == 1) {
        {
        redraw_later(40);
        }
      } else {
        need_redraw = 1;
      }
    }
  }
  if (need_redraw) {
    {
    update_screenline();
    }
  }
  if (! restart_edit) {
    if ((colnr_t )temp == curwin->w_cursor.col) {
      curwin->w_set_curswant = 1;
    }
  }
  if (curwin->w_cursor.col != 0U) {
    if (! restart_edit) {
      (curwin->w_cursor.col) --;
    } else {
      {
      tmp = gchar_cursor();
      }
      if (tmp == 0) {
        if (! VIsual_active) {
          (curwin->w_cursor.col) --;
        }
      }
    }
  }
  {
  changed_cline_bef_curs();
  State = 1;
  setmouse();
  }
  if (Recording) {
    {
    showmode();
    }
  } else { //Added block
  if (restart_edit) {
    {
    showmode();
    }
  } else { //Added block
  if (p_smd) {
    {
    msg((char_u *)"");
    }
  }
  }
  }
  return (1);
}
}
static void ins_shift(int c , int lastc___1 ) 
{ 
  int tmp ;

  {
  {
  stop_arrow();
  AppendCharToRedobuff(c);
  }
  if (lastc___1 == 48) {
    goto _L___0;
  } else { //Added block
  if (lastc___1 == 94) {
    _L___0: 
    if (curwin->w_cursor.col) {
      {
      (curwin->w_cursor.col) --;
      del_char(0);
      }
      if (State == 528) {
        {
        replace_pop_ins();
        }
      } else { //Added block
      if (State == 784) {
        {
        replace_pop_ins();
        }
      }
      }
      if (lastc___1 == 94) {
        {
        old_indent = get_indent();
        }
      }
      {
      change_indent(1, 0, 1, 0);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (c == 4) {
      tmp = 3;
    } else {
      tmp = 2;
    }
    {
    change_indent(tmp, 0, 1, 0);
    }
  }
  }
  did_ai = 0;
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  can_cindent = 0;
  return;
}
}
static void ins_del(void) 
{ 
  int temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  stop_arrow();
  tmp___3 = gchar_cursor();
  }
  if (tmp___3 == 0) {
    {
    temp = (int )curwin->w_cursor.col;
    tmp = can_bs('o');
    }
    if (tmp) {
      {
      tmp___0 = u_save(curwin->w_cursor.lnum - 1L, curwin->w_cursor.lnum + 2L);
      }
      if (tmp___0 == 0) {
        {
        vim_beep();
        }
      } else {
        {
        tmp___1 = do_join(0, 1);
        }
        if (tmp___1 == 0) {
          {
          vim_beep();
          }
        } else {
          {
          curwin->w_cursor.col = (colnr_t )temp;
          redraw_later(30);
          }
        }
      }
    } else {
      {
      vim_beep();
      }
    }
  } else {
    {
    tmp___2 = del_char(0);
    }
    if (tmp___2 == 0) {
      {
      vim_beep();
      }
    }
  }
  {
  did_ai = 0;
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  AppendCharToRedobuff(107 + (68 << 8));
  }
  return;
}
}
static int ins_bs(int c , int mode , int *inserted_space_p ) 
{ 
  linenr_t lnum ;
  int cc___0 ;
  int temp ;
  colnr_t mincol ;
  int did_backspace ;
  int in_indent ;
  int oldState ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int ts ;
  colnr_t vcol ;
  int want_vcol ;
  int extra ;
  char_u *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char_u *tmp___12 ;
  char_u *tmp___13 ;

  {
  temp = 0;
  did_backspace = 0;
  if (curbuf->b_ml.ml_line_count == 1L) {
    {
    tmp = ml_get((linenr_t )1);
    }
    if ((int )*tmp == 0) {
      {
      vim_beep();
      }
      return (0);
    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: 
  if (curwin->w_cursor.lnum == 1L) {
    if (curwin->w_cursor.col <= 0U) {
      {
      vim_beep();
      }
      return (0);
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    {
    tmp___0 = can_bs('s');
    }
    if (tmp___0) {
      _L___2: 
      {
      tmp___1 = can_bs('i');
      }
      if (tmp___1) {
        _L___1: 
        {
        tmp___2 = can_bs('o');
        }
        if (! tmp___2) {
          if (curwin->w_cursor.col == 0U) {
            {
            vim_beep();
            }
            return (0);
          }
        }
      } else { //Added block
      if (! arrow_used) {
        if (ai_col > 0U) {
          if (curwin->w_cursor.col <= ai_col) {
            {
            vim_beep();
            }
            return (0);
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
      }
    } else { //Added block
    if (arrow_used) {
      {
      vim_beep();
      }
      return (0);
    } else { //Added block
    if (curwin->w_cursor.lnum == Insstart.lnum) {
      if (curwin->w_cursor.col <= Insstart.col) {
        {
        vim_beep();
        }
        return (0);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
    }
    }
  }
  }
  {
  stop_arrow();
  in_indent = inindent(0);
  }
  if (in_indent) {
    can_cindent = 0;
  }
  end_comment_pending = '\000';
  if (curwin->w_cursor.col <= 0U) {
    lnum = Insstart.lnum;
    if (curwin->w_cursor.lnum == Insstart.lnum) {
      {
      tmp___3 = u_save(curwin->w_cursor.lnum - 2L, curwin->w_cursor.lnum + 1L);
      }
      if (tmp___3 == 0) {
        return (0);
      }
      (Insstart.lnum) --;
      Insstart.col = (colnr_t )2147483647;
    }
    cc___0 = -1;
    if (State == 528) {
      {
      cc___0 = replace_pop();
      }
    } else { //Added block
    if (State == 784) {
      {
      cc___0 = replace_pop();
      }
    }
    }
    if (State == 528) {
      goto _L___8;
    } else { //Added block
    if (State == 784) {
      _L___8: 
      if (curwin->w_cursor.lnum <= lnum) {
        {
        dec_cursor();
        }
      } else {
        goto _L___7;
      }
    } else {
      _L___7: 
      if (State != 784) {
        goto _L___5;
      } else { //Added block
      if (curwin->w_cursor.lnum > (linenr_t )orig_line_count) {
        _L___5: 
        {
        temp = gchar_cursor();
        (curwin->w_cursor.lnum) --;
        do_join(0, 1);
        redraw_later(30);
        }
        if (temp == 0) {
          {
          tmp___4 = gchar_cursor();
          }
          if (tmp___4 != 0) {
            (curwin->w_cursor.col) ++;
          }
        }
      } else {
        {
        dec_cursor();
        }
      }
      }
      if (State == 528) {
        goto _L___6;
      } else { //Added block
      if (State == 784) {
        _L___6: 
        oldState = State;
        State = 1;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (cc___0 > 0)) {
            goto while_break;
          }
          {
          temp = (int )curwin->w_cursor.col;
          ins_char(cc___0);
          curwin->w_cursor.col = (colnr_t )temp;
          cc___0 = replace_pop();
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
        replace_pop_ins();
        State = oldState;
        }
      }
      }
    }
    }
    did_ai = 0;
  } else {
    mincol = (colnr_t )0;
    if (mode == 4) {
      if (curbuf->b_p_ai) {
        {
        temp = (int )curwin->w_cursor.col;
        beginline(1);
        }
        if (curwin->w_cursor.col < (colnr_t )temp) {
          mincol = curwin->w_cursor.col;
        }
        curwin->w_cursor.col = (colnr_t )temp;
      }
    }
    if (mode == 1) {
      if (p_sta) {
        if (in_indent) {
          goto _L___14;
        } else {
          goto _L___15;
        }
      } else { //Added block
      _L___15: 
      if (curbuf->b_p_sts) {
        {
        tmp___12 = ml_get_cursor();
        }
        if ((int )*(tmp___12 - 1) == 9) {
          goto _L___14;
        } else {
          {
          tmp___13 = ml_get_cursor();
          }
          if ((int )*(tmp___13 - 1) == 32) {
            if (! *inserted_space_p) {
              goto _L___14;
            } else { //Added block
            if (arrow_used) {
              _L___14: 
              extra = 0;
              *inserted_space_p = 0;
              if (p_sta) {
                ts = (int )curbuf->b_p_sw;
              } else {
                ts = (int )curbuf->b_p_sts;
              }
              {
              getvcol(curwin, & curwin->w_cursor, & vcol, (colnr_t *)((void *)0),
                      (colnr_t *)((void *)0));
              want_vcol = (int )(((vcol - 1U) / (colnr_t )ts) * (colnr_t )ts);
              }
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if ((int )vcol > want_vcol) {
                  {
                  tmp___5 = ml_get_cursor();
                  cc___0 = (int )*(tmp___5 - 1);
                  }
                  if (cc___0 == 32) {
                    tmp___6 = 1;
                  } else { //Added block
                  if (cc___0 == 9) {
                    tmp___6 = 1;
                  } else {
                    tmp___6 = 0;
                  }
                  }
                  if (! tmp___6) {
                    goto while_break___0;
                  }
                } else {
                  goto while_break___0;
                }
                {
                dec_cursor();
                getvcol(curwin, & curwin->w_cursor, & vcol, (colnr_t *)((void *)0),
                        (colnr_t *)((void *)0));
                }
                if (State == 528) {
                  goto _L___9;
                } else { //Added block
                if (State == 784) {
                  _L___9: 
                  if (curwin->w_cursor.lnum != Insstart.lnum) {
                    {
                    replace_do_bs();
                    }
                  } else { //Added block
                  if (curwin->w_cursor.col >= Insstart.col) {
                    {
                    replace_do_bs();
                    }
                  }
                  }
                } else {
                  {
                  del_char(0);
                  }
                }
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              while (1) {
                while_continue___1: /* CIL Label */ ;
                if (! ((int )vcol < want_vcol)) {
                  goto while_break___1;
                }
                if (curwin->w_cursor.lnum == Insstart.lnum) {
                  if (curwin->w_cursor.col < Insstart.col) {
                    Insstart.col = curwin->w_cursor.col;
                  }
                }
                if (State == 784) {
                  {
                  ins_char(' ');
                  }
                } else {
                  {
                  ins_str((char_u *)" ");
                  }
                  if (State == 528) {
                    if (extra <= 1) {
                      if (extra) {
                        {
                        replace_push_off('\000');
                        }
                      } else {
                        {
                        replace_push('\000');
                        }
                      }
                    }
                  }
                  if (extra == 2) {
                    extra = 1;
                  }
                }
                vcol ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
              goto _L___11;
            }
            }
          } else {
            goto _L___11;
          }
        }
      } else {
        goto _L___11;
      }
      }
    } else {
      _L___11: 
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
        dec_cursor();
        }
        if (mode == 2) {
          {
          tmp___10 = gchar_cursor();
          tmp___11 = vim_isspace(tmp___10);
          }
          if (tmp___11) {
            goto _L___10;
          } else {
            {
            mode = 3;
            tmp___7 = gchar_cursor();
            temp = vim_iswordc(tmp___7);
            }
          }
        } else { //Added block
        _L___10: 
        if (mode == 3) {
          {
          cc___0 = gchar_cursor();
          tmp___8 = vim_isspace(cc___0);
          }
          if (tmp___8) {
            {
            inc_cursor();
            }
            goto while_break___2;
          } else {
            {
            tmp___9 = vim_iswordc(cc___0);
            }
            if (tmp___9 != temp) {
              {
              inc_cursor();
              }
              goto while_break___2;
            }
          }
        }
        }
        if (State == 528) {
          {
          replace_do_bs();
          }
        } else { //Added block
        if (State == 784) {
          {
          replace_do_bs();
          }
        } else {
          {
          del_char(0);
          }
        }
        }
        if (mode == 1) {
          goto while_break___2;
        }
        if (curwin->w_cursor.col > mincol) {
          if (! (curwin->w_cursor.lnum != Insstart.lnum)) {
            if (! (curwin->w_cursor.col != Insstart.col)) {
              goto while_break___2;
            }
          }
        } else {
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    did_backspace = 1;
  }
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  if (curwin->w_cursor.col <= 1U) {
    did_ai = 0;
  }
  {
  AppendCharToRedobuff(c);
  }
  if (curwin->w_cursor.lnum == Insstart.lnum) {
    if (curwin->w_cursor.col < Insstart.col) {
      Insstart.col = curwin->w_cursor.col;
    }
  }
  return (did_backspace);
}
}
static void ins_mouse(int c ) 
{ 
  FPOS tpos ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = mouse_has('i');
  }
  if (! tmp) {
    return;
  }
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  tmp___0 = do_mouse((OPARG *)((void *)0), c, -1, 1L, 0);
  }
  if (tmp___0) {
    {
    start_arrow(& tpos);
    can_cindent = 1;
    }
  }
  {
  redraw_statuslines();
  }
  return;
}
}
static void ins_mousescroll(int up ) 
{ 
  FPOS tpos ;

  {
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  }
  if (mod_mask & 2) {
    {
    scroll_redraw(up, curwin->w_botline - curwin->w_topline);
    }
  } else {
    {
    scroll_redraw(up, 3L);
    }
  }
  if (curwin->w_cursor.lnum == tpos.lnum) {
    if (! (curwin->w_cursor.col == tpos.col)) {
      {
      start_arrow(& tpos);
      can_cindent = 1;
      }
    }
  } else {
    {
    start_arrow(& tpos);
    can_cindent = 1;
    }
  }
  return;
}
}
static void ins_left(void) 
{ 
  FPOS tpos ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  tmp___0 = oneleft();
  }
  if (tmp___0 == 1) {
    {
    start_arrow(& tpos);
    }
  } else {
    {
    tmp = vim_strchr(p_ww, '[');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      if (curwin->w_cursor.lnum > 1L) {
        {
        start_arrow(& tpos);
        (curwin->w_cursor.lnum) --;
        coladvance((colnr_t )2147483647);
        curwin->w_set_curswant = 1;
        }
      } else {
        {
        vim_beep();
        }
      }
    } else {
      {
      vim_beep();
      }
    }
  }
  return;
}
}
static void ins_home(void) 
{ 
  FPOS tpos ;

  {
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  }
  if (mod_mask & 4) {
    curwin->w_cursor.lnum = (linenr_t )1;
  }
  {
  curwin->w_cursor.col = (colnr_t )0;
  curwin->w_curswant = (colnr_t )0;
  start_arrow(& tpos);
  }
  return;
}
}
static void ins_end(void) 
{ 
  FPOS tpos ;

  {
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  }
  if (mod_mask & 4) {
    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
  }
  {
  coladvance((colnr_t )2147483647);
  curwin->w_curswant = (colnr_t )2147483647;
  start_arrow(& tpos);
  }
  return;
}
}
static void ins_s_left(void) 
{ 


  {
  {
  undisplay_dollar();
  }
  if (curwin->w_cursor.lnum > 1L) {
    {
    start_arrow(& curwin->w_cursor);
    bck_word(1L, 0, 0);
    curwin->w_set_curswant = 1;
    }
  } else { //Added block
  if (curwin->w_cursor.col > 0U) {
    {
    start_arrow(& curwin->w_cursor);
    bck_word(1L, 0, 0);
    curwin->w_set_curswant = 1;
    }
  } else {
    {
    vim_beep();
    }
  }
  }
  return;
}
}
static void ins_right(void) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  undisplay_dollar();
  tmp___0 = gchar_cursor();
  }
  if (tmp___0 != 0) {
    {
    start_arrow(& curwin->w_cursor);
    curwin->w_set_curswant = 1;
    (curwin->w_cursor.col) ++;
    }
  } else {
    {
    tmp = vim_strchr(p_ww, ']');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
        {
        start_arrow(& curwin->w_cursor);
        curwin->w_set_curswant = 1;
        (curwin->w_cursor.lnum) ++;
        curwin->w_cursor.col = (colnr_t )0;
        }
      } else {
        {
        vim_beep();
        }
      }
    } else {
      {
      vim_beep();
      }
    }
  }
  return;
}
}
static void ins_s_right(void) 
{ 
  int tmp ;

  {
  {
  undisplay_dollar();
  }
  if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
    {
    start_arrow(& curwin->w_cursor);
    fwd_word(1L, 0, 0);
    curwin->w_set_curswant = 1;
    }
  } else {
    {
    tmp = gchar_cursor();
    }
    if (tmp != 0) {
      {
      start_arrow(& curwin->w_cursor);
      fwd_word(1L, 0, 0);
      curwin->w_set_curswant = 1;
      }
    } else {
      {
      vim_beep();
      }
    }
  }
  return;
}
}
static void ins_up(void) 
{ 
  FPOS tpos ;
  linenr_t old_topline___0 ;
  int tmp ;

  {
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  old_topline___0 = curwin->w_topline;
  tmp = cursor_up(1L, 1);
  }
  if (tmp == 1) {
    if (old_topline___0 != curwin->w_topline) {
      {
      update_screen(10);
      }
    }
    {
    start_arrow(& tpos);
    can_cindent = 1;
    }
  } else {
    {
    vim_beep();
    }
  }
  return;
}
}
static void ins_pageup(void) 
{ 
  FPOS tpos ;
  int tmp ;

  {
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  tmp = onepage(-1, 1L);
  }
  if (tmp == 1) {
    {
    start_arrow(& tpos);
    can_cindent = 1;
    }
  } else {
    {
    vim_beep();
    }
  }
  return;
}
}
static void ins_down(void) 
{ 
  FPOS tpos ;
  linenr_t old_topline___0 ;
  int tmp ;

  {
  {
  old_topline___0 = curwin->w_topline;
  undisplay_dollar();
  tpos = curwin->w_cursor;
  tmp = cursor_down(1L, 1);
  }
  if (tmp == 1) {
    if (old_topline___0 != curwin->w_topline) {
      {
      update_screen(10);
      }
    }
    {
    start_arrow(& tpos);
    can_cindent = 1;
    }
  } else {
    {
    vim_beep();
    }
  }
  return;
}
}
static void ins_pagedown(void) 
{ 
  FPOS tpos ;
  int tmp ;

  {
  {
  undisplay_dollar();
  tpos = curwin->w_cursor;
  tmp = onepage(1, 1L);
  }
  if (tmp == 1) {
    {
    start_arrow(& tpos);
    can_cindent = 1;
    }
  } else {
    {
    vim_beep();
    }
  }
  return;
}
}
static int ins_tab(void) 
{ 
  int ind ;
  int i___0 ;
  int temp ;
  int tmp ;
  colnr_t tmp___0 ;
  char_u *ptr ;
  char_u *saved_line ;
  FPOS fpos ;
  FPOS pos___0 ;
  FPOS *cursor ;
  colnr_t want_vcol ;
  colnr_t vcol ;
  colnr_t tab_vcol ;
  int change_col ;
  int ts ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  if (Insstart_blank_vcol == 2147483647U) {
    if (curwin->w_cursor.lnum == Insstart.lnum) {
      {
      Insstart_blank_vcol = get_nolist_virtcol();
      }
    }
  }
  {
  tmp = echeck_abbr(265);
  }
  if (tmp) {
    return (0);
  }
  {
  ind = inindent(0);
  }
  if (ind) {
    can_cindent = 0;
  }
  if (! curbuf->b_p_et) {
    if (p_sta) {
      if (ind) {
        if (! (curbuf->b_p_ts != curbuf->b_p_sw)) {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (! curbuf->b_p_sts) {
      return (1);
    }
    }
  }
  {
  stop_arrow();
  did_ai = 0;
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  AppendToRedobuff((char_u *)"\t");
  }
  if (p_sta) {
    if (ind) {
      temp = (int )curbuf->b_p_sw;
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (curbuf->b_p_sts) {
    temp = (int )curbuf->b_p_sts;
  } else {
    temp = (int )curbuf->b_p_ts;
  }
  }
  {
  tmp___0 = get_nolist_virtcol();
  temp = (int )((unsigned int )temp - tmp___0 % (unsigned int )temp);
  ins_char(' ');
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    temp --;
    if (! temp) {
      goto while_break;
    }
    if (State == 784) {
      {
      ins_char(' ');
      }
    } else {
      {
      ins_str((char_u *)" ");
      }
      if (State == 528) {
        {
        replace_push('\000');
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (! curbuf->b_p_et) {
    if (curbuf->b_p_sts) {
      goto _L___3;
    } else { //Added block
    if (p_sta) {
      if (ind) {
        _L___3: 
        saved_line = (char_u *)((void *)0);
        change_col = -1;
        ts = (int )curbuf->b_p_ts;
        if (State == 784) {
          {
          pos___0 = curwin->w_cursor;
          cursor = & pos___0;
          tmp___1 = ml_get_curline();
          saved_line = vim_strsave(tmp___1);
          }
          if ((unsigned long )saved_line == (unsigned long )((void *)0)) {
            return (0);
          }
          ptr = saved_line + pos___0.col;
        } else {
          {
          ptr = ml_get_cursor();
          cursor = & curwin->w_cursor;
          }
        }
        fpos = curwin->w_cursor;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (fpos.col > 0U) {
            if (! ((int )*(ptr + -1) == 32)) {
              if (! ((int )*(ptr + -1) == 9)) {
                goto while_break___0;
              }
            }
          } else {
            goto while_break___0;
          }
          (fpos.col) --;
          ptr --;
        }
        while_break___0: /* CIL Label */ ;
        }
        if (State == 528) {
          goto _L___2;
        } else { //Added block
        if (State == 784) {
          _L___2: 
          if (fpos.lnum == Insstart.lnum) {
            if (fpos.col < Insstart.col) {
              ptr += Insstart.col - fpos.col;
              fpos.col = Insstart.col;
            }
          }
        }
        }
        {
        getvcol(curwin, & fpos, & vcol, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
        getvcol(curwin, cursor, & want_vcol, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
        tab_vcol = (want_vcol / (colnr_t )ts) * (colnr_t )ts;
        }
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (vcol < tab_vcol)) {
            goto while_break___1;
          }
          if ((int )*ptr != 9) {
            *ptr = (char_u )'\t';
            if (change_col < 0) {
              change_col = (int )fpos.col;
              if (fpos.lnum == Insstart.lnum) {
                if (fpos.col < Insstart.col) {
                  Insstart.col = fpos.col;
                }
              }
            }
          }
          (fpos.col) ++;
          ptr ++;
          vcol = ((vcol + (colnr_t )ts) / (colnr_t )ts) * (colnr_t )ts;
        }
        while_break___1: /* CIL Label */ ;
        }
        if (change_col >= 0) {
          i___0 = (int )(want_vcol - vcol);
          ptr += i___0;
          fpos.col += (colnr_t )i___0;
          i___0 = (int )(cursor->col - fpos.col);
          if (i___0 > 0) {
            {
            tmp___2 = strlen((char const   *)((char *)(ptr + i___0)));
            memmove((void *)((char *)ptr), (void const   *)((char *)(ptr + i___0)),
                    tmp___2 + 1UL);
            }
            if (State == 528) {
              temp = i___0;
              {
              while (1) {
                while_continue___2: /* CIL Label */ ;
                temp --;
                if (! (temp >= 0)) {
                  goto while_break___2;
                }
                {
                replace_join((int )(want_vcol - vcol));
                }
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
          cursor->col -= (colnr_t )i___0;
          if (State == 784) {
            {
            backspace_until_column(change_col);
            }
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              if (! (change_col < (int )cursor->col)) {
                goto while_break___3;
              }
              {
              tmp___3 = change_col;
              change_col ++;
              ins_char((int )*(saved_line + tmp___3));
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
        if (State == 784) {
          {
          vim_free((void *)saved_line);
          }
        }
      }
    }
    }
  }
  return (0);
}
}
static int ins_eol(int c ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = echeck_abbr(c + 256);
  }
  if (tmp) {
    return (0);
  }
  {
  stop_arrow();
  }
  if (State == 528) {
    {
    replace_push('\000');
    }
  }
  {
  AppendToRedobuff((char_u *)"\n");
  tmp___0 = has_format_option('r');
  }
  if (tmp___0) {
    fo_do_comments = 1;
  }
  {
  i___0 = open_line(1, 1, 0, old_indent);
  old_indent = 0;
  fo_do_comments = 0;
  can_cindent = 1;
  }
  return (! i___0);
}
}
static int ins_digraph(void) 
{ 
  int c ;
  int cc___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = redrawing();
  }
  if (tmp) {
    {
    tmp___0 = char_avail();
    }
    if (! tmp___0) {
      {
      edit_putchar('?', 1);
      add_to_showcmd_c(11);
      }
    }
  }
  {
  no_mapping ++;
  allow_keys ++;
  c = safe_vgetc();
  no_mapping --;
  allow_keys --;
  }
  if (c >= 512) {
    {
    clear_showcmd();
    insert_special(c, 1, 0);
    }
    return ('\000');
  } else { //Added block
  if (mod_mask) {
    {
    clear_showcmd();
    insert_special(c, 1, 0);
    }
    return ('\000');
  }
  }
  if (c != 27) {
    {
    tmp___2 = redrawing();
    }
    if (tmp___2) {
      {
      tmp___3 = char_avail();
      }
      if (! tmp___3) {
        {
        tmp___1 = charsize(c);
        }
        if (tmp___1 == 1) {
          {
          edit_putchar(c, 1);
          }
        }
        {
        add_to_showcmd_c(c);
        }
      }
    }
    {
    no_mapping ++;
    allow_keys ++;
    cc___0 = safe_vgetc();
    no_mapping --;
    allow_keys --;
    }
    if (cc___0 != 27) {
      {
      AppendToRedobuff((char_u *)"\026");
      c = getdigraph(c, cc___0, 1);
      clear_showcmd();
      }
      return (c);
    }
  }
  {
  clear_showcmd();
  }
  return ('\000');
}
}
static int ins_copychar(linenr_t lnum ) 
{ 
  int c ;
  int temp ;
  char_u *ptr ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if (lnum < 1L) {
    {
    vim_beep();
    }
    return ('\000');
  } else { //Added block
  if (lnum > curbuf->b_ml.ml_line_count) {
    {
    vim_beep();
    }
    return ('\000');
  }
  }
  {
  temp = 0;
  ptr = ml_get(lnum);
  validate_virtcol();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((colnr_t )temp < curwin->w_virtcol) {
      if (! *ptr) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = ptr;
    ptr ++;
    tmp___0 = lbr_chartabsize(tmp, (colnr_t )temp);
    temp += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((colnr_t )temp > curwin->w_virtcol) {
    ptr --;
  }
  c = (int )*ptr;
  if (c == 0) {
    {
    vim_beep();
    }
  }
  return (c);
}
}
static void ins_try_si(int c ) 
{ 
  FPOS *pos___0 ;
  FPOS old_pos ;
  char_u *ptr ;
  int i___0 ;
  int temp ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if (did_si) {
    goto _L___2;
  } else { //Added block
  if (can_si_back) {
    _L___2: 
    if (c == 123) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (can_si) {
    if (c == 125) {
      _L___0: 
      if (c == 125) {
        {
        pos___0 = findmatch((OPARG *)((void *)0), '{');
        }
        if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
          {
          old_pos = curwin->w_cursor;
          ptr = ml_get(pos___0->lnum);
          i___0 = (int )pos___0->col;
          }
          if (i___0 > 0) {
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              i___0 --;
              if (i___0 > 0) {
                if (! ((int )*(ptr + i___0) == 32)) {
                  if (! ((int )*(ptr + i___0) == 9)) {
                    goto while_break;
                  }
                }
              } else {
                goto while_break;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
          curwin->w_cursor.lnum = pos___0->lnum;
          curwin->w_cursor.col = (colnr_t )i___0;
          if ((int )*(ptr + i___0) == 41) {
            {
            pos___0 = findmatch((OPARG *)((void *)0), '(');
            }
            if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
              curwin->w_cursor = *pos___0;
            }
          }
          {
          i___0 = get_indent();
          curwin->w_cursor = old_pos;
          }
          if (State == 784) {
            {
            change_indent(1, i___0, 0, '\000');
            }
          } else {
            {
            set_indent(i___0, 1);
            }
          }
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (curwin->w_cursor.col > 0U) {
        temp = 1;
        if (c == 123) {
          if (can_si_back) {
            if (curwin->w_cursor.lnum > 1L) {
              {
              old_pos = curwin->w_cursor;
              i___0 = get_indent();
              }
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (! (curwin->w_cursor.lnum > 1L)) {
                  goto while_break___0;
                }
                {
                (curwin->w_cursor.lnum) --;
                tmp = ml_get(curwin->w_cursor.lnum);
                ptr = skipwhite(tmp);
                }
                if ((int )*ptr != 35) {
                  if ((int )*ptr != 0) {
                    goto while_break___0;
                  }
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              tmp___0 = get_indent();
              }
              if (tmp___0 >= i___0) {
                temp = 0;
              }
              curwin->w_cursor = old_pos;
            }
          }
        }
        if (temp) {
          {
          shift_line(1, 0, 1);
          }
        }
      }
      }
    }
  }
  }
  }
  if (curwin->w_cursor.col > 0U) {
    if (can_si) {
      if (c == 35) {
        {
        old_indent = get_indent();
        set_indent(0, 1);
        }
      }
    }
  }
  if (ai_col > curwin->w_cursor.col) {
    ai_col = curwin->w_cursor.col;
  }
  return;
}
}
static colnr_t get_nolist_virtcol(void) 
{ 
  colnr_t virtcol ;
  char_u *tmp ;

  {
  if (curwin->w_p_list) {
    {
    tmp = vim_strchr(p_cpo, 'L');
    }
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
      curwin->w_p_list = 0;
      getvcol(curwin, & curwin->w_cursor, (colnr_t *)((void *)0), & virtcol, (colnr_t *)((void *)0));
      curwin->w_p_list = 1;
      }
      return (virtcol);
    }
  }
  {
  validate_virtcol();
  }
  return (curwin->w_virtcol);
}
}
#pragma merger("0","/tmp/cil-7getv7z7.i","-O0")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
char_u *term_strings[51]  ;
long Rows ;
int expand_context ;
char_u *expand_pattern ;
int msg_didout ;
int emsg_off ;
int did_emsg  ;
int need_wait_return ;
int didset_vim ;
int didset_vimruntime ;
int lines_left ;
int did_filetype ;
int starting ;
int KeyTyped  ;
char_u e_invarg2[21] ;
char_u e_invexpr2[23] ;
char_u e_letunexp[33] ;
char_u e_readonlyvar[35] ;
long p_mfd  ;
long p_verbose  ;
void mch_get_host_name(char_u *s , int len___0 ) ;
int mch_isFullName(char_u *fname ) ;
int mch_isdir(char_u *name___1 ) ;
void set_internal_string_var(char_u *name___1 , char_u *value ) ;
int eval_to_bool(char_u *arg , int *error , char_u **nextcmd , int skip ) ;
char_u *eval_to_string(char_u *arg , char_u **nextcmd ) ;
char_u *eval_to_string_safe(char_u *arg , char_u **nextcmd ) ;
void do_let(EXARG *eap ) ;
void set_context_for_expression(char_u *arg , CMDIDX cmdidx ) ;
void do_call(EXARG *eap ) ;
void do_unlet(char_u *arg , int forceit ) ;
char_u *get_user_var_name(int idx ) ;
char_u *get_function_name(int idx ) ;
char_u *get_expr_name(int idx ) ;
void set_vim_var_nr(int idx , long val ) ;
void set_vim_var_string(int idx , char_u *val ) ;
void do_echo(EXARG *eap , int echo ) ;
void do_echohl(char_u *arg ) ;
void do_execute(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
void do_function(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
char_u *get_user_func_name(int idx ) ;
void do_delfunction(char_u *arg ) ;
void *save_funccal(void) ;
void restore_funccal(void *fc ) ;
void do_return(EXARG *eap ) ;
char_u *get_func_line(int c , void *cookie , int indent ) ;
int func_has_ended(void *cookie ) ;
int func_has_abort(void *cookie ) ;
int read_viminfo_varlist(char_u *line , FILE *fp___0 , int writing ) ;
void write_viminfo_varlist(FILE *fp___0 ) ;
int store_session_globals(FILE *fd ) ;
int modify_fname(char_u *src , int *usedlen , char_u **fnamep , char_u **bufp , int *fnamelen ) ;
char_u *do_string_sub(char_u *str___1 , char_u *pat , char_u *sub , char_u *flags___0 ) ;
int do_cmdline(char_u *cmdline , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int flags___0 ) ;
int ends_excmd(int c ) ;
char_u *check_nextcmd(char_u *p___0 ) ;
char_u *eval_vars(char_u *src , int *usedlen , linenr_t *lnump , char_u **errormsg ,
                  char_u *srcstart ) ;
int put_eol(FILE *fd ) ;
char_u *getcmdline(int firstc , long count___2 , int indent ) ;
char_u *getcmdline_prompt(int firstc , char_u *prompt , int attr ) ;
char_u *ExpandOne(char_u *str___1 , char_u *orig , int options___0 , int mode ) ;
int get_histtype(char_u *name___1 ) ;
void add_to_history(int histype , char_u *new_entry , int in_map ) ;
int get_history_idx(int histype ) ;
char_u *get_history_entry(int histype , int idx ) ;
int clr_history(int histype ) ;
int del_history_entry(int histype , char_u *str___1 ) ;
int del_history_idx(int histype , int idx ) ;
int vim_rename(char_u *from , char_u *to ) ;
char_u *vim_tempname(int extra_char ) ;
void saveRedobuff(void) ;
void restoreRedobuff(void) ;
int get_map_mode(char_u **cmdp , int forceit ) ;
char_u *check_map(char_u *keys___0 , int mode , int exact ) ;
FPOS *getmark(int c , int changefile ) ;
void mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) ;
int ml_append(linenr_t lnum , char_u *line , colnr_t len___0 , int newfile ) ;
long ml_find_line_or_offset(BUF *buf___3 , linenr_t line , long *offp ) ;
void msg_start(void) ;
void msg_starthere(void) ;
void msg_putchar_attr(int c , int attr ) ;
int msg_outtrans_len_attr(char_u *str___1 , int len___0 , int attr ) ;
char_u *str2special(char_u **sp , int from ) ;
void msg_prt_line(char_u *s ) ;
void msg_puts_attr(char_u *s , int attr ) ;
void msg_clr_eos(void) ;
int msg_end(void) ;
void msg_advance(int col ) ;
int do_dialog(int type , char_u *title , char_u *message , char_u *buttons , int dfltbutton ) ;
void init_homedir(void) ;
char_u *expand_env_save(char_u *src ) ;
void vim_setenv(char_u *name___1 , char_u *val ) ;
char_u *get_past_head(char_u *path ) ;
int vim_ispathsep(int c ) ;
char_u *get_cmd_output(char_u *cmd , int flags___0 ) ;
char_u *vim_strsave_escaped(char_u *string___0 , char_u *esc_chars ) ;
void ga_clear(struct growarray *gap ) ;
void ga_clear_strings(struct growarray *gap ) ;
void ga_init(struct growarray *gap ) ;
void ga_init2(struct growarray *gap , int itemsize , int growsize ) ;
int ga_grow(struct growarray *gap , int n ) ;
void ga_concat(struct growarray *gap , char_u *s ) ;
void ga_append(struct growarray *gap , int c ) ;
int trans_special(char_u **srcp , char_u *dst , int keycode ) ;
char_u *get_reg_contents(int regname___0 ) ;
void write_reg_contents(int name___1 , char_u *str___1 ) ;
int get_option_value(char_u *name___1 , long *numval , char_u **stringval ) ;
void set_option_value(char_u *name___1 , long number , char_u *string___0 ) ;
int vim_regsub(vim_regexp *prog , char_u *source , char_u *dest , int copy , int magic ) ;
void redraw_curbuf_later(int type ) ;
void update_curbuf(int type ) ;
void changed_line_abv_curs(void) ;
void approximate_botline(void) ;
void save_search_patterns(void) ;
void restore_search_patterns(void) ;
int syn_get_id(long line , long col , int trans___0 ) ;
char_u *highlight_has_attr(int id , int flag , int modec ) ;
char_u *highlight_color(int id , char_u *what , int modec ) ;
int syn_name2id(char_u *name___1 ) ;
int highlight_exists(char_u *name___1 ) ;
int syn_id2attr(int hl_id ) ;
int syn_get_final_id(int hl_id ) ;
char_u *get_highlight_name(int idx ) ;
char_u *replace_termcodes(char_u *from , char_u **bufp , int from_part , int do_lt ) ;
int u_savesub(linenr_t lnum ) ;
struct growarray variables  =    {0, 0, (int )sizeof(var ), 4, (void *)0};
static int echo_attr  =    0;
struct ufunc *firstfunc  =    (struct ufunc *)((void *)0);
struct funccall *current_funccal  =    (struct funccall *)((void *)0);
struct vimvar vimvars[8]  = 
  {      {(char *)"count", (int )(sizeof("count") - 1UL), (char_u *)((void *)0), (char)1,
      (char)3}, 
        {(char *)"count1", (int )(sizeof("count1") - 1UL), (char_u *)((void *)0), (char)1,
      (char)2}, 
        {(char *)"errmsg", (int )(sizeof("errmsg") - 1UL), (char_u *)((void *)0), (char)2,
      (char)1}, 
        {(char *)"warningmsg", (int )(sizeof("warningmsg") - 1UL), (char_u *)((void *)0),
      (char)2, (char)0}, 
        {(char *)"statusmsg", (int )(sizeof("statusmsg") - 1UL), (char_u *)((void *)0),
      (char)2, (char)0}, 
        {(char *)"shell_error", (int )(sizeof("shell_error") - 1UL), (char_u *)((void *)0),
      (char)1, (char)3}, 
        {(char *)"this_session", (int )(sizeof("this_session") - 1UL), (char_u *)((void *)0),
      (char)2, (char)1}, 
        {(char *)"version", (int )(sizeof("version") - 1UL), (char_u *)508, (char)1,
      (char)3}};
static int eval0(char_u *arg , VAR retvar , char_u **nextcmd , int evaluate ) ;
static int eval1(char_u **arg , VAR retvar , int evaluate ) ;
static int eval2(char_u **arg , VAR retvar , int evaluate ) ;
static int eval3(char_u **arg , VAR retvar , int evaluate ) ;
static int eval4(char_u **arg , VAR retvar , int evaluate ) ;
static int eval5(char_u **arg , VAR retvar , int evaluate ) ;
static int eval6(char_u **arg , VAR retvar , int evaluate ) ;
static int get_option_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_string_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_lit_string_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_env_var(char_u **arg , VAR retvar , int evaluate ) ;
static int find_internal_func(char_u *name___1 ) ;
static int get_func_var(char_u *name___1 , int len___0 , VAR retvar , char_u **arg ,
                        linenr_t firstline , linenr_t lastline , int *doesrange ,
                        int evaluate ) ;
static linenr_t get_arg_lnum(VAR argvars , VAR retvar ) ;
static void f_append(VAR argvars , VAR retvar ) ;
static void f_argc(VAR argvars , VAR retvar ) ;
static void f_argv(VAR argvars , VAR retvar ) ;
static void f_browse(VAR argvars , VAR retvar ) ;
static BUF *find_buffer(VAR avar ) ;
static void f_bufexists(VAR argvars , VAR retvar ) ;
static void f_bufloaded(VAR argvars , VAR retvar ) ;
static BUF *get_buf_var(VAR avar ) ;
static void f_bufname(VAR argvars , VAR retvar ) ;
static void f_bufnr(VAR argvars , VAR retvar ) ;
static void f_bufwinnr(VAR argvars , VAR retvar ) ;
static void f_byte2line(VAR argvars , VAR retvar ) ;
static void f_char2nr(VAR argvars , VAR retvar ) ;
static void f_col(VAR argvars , VAR retvar ) ;
static void f_confirm(VAR argvars , VAR retvar ) ;
static void f_delete(VAR argvars , VAR retvar ) ;
static void f_did_filetype(VAR argvars , VAR retvar ) ;
static void f_escape(VAR argvars , VAR retvar ) ;
static void f_exists(VAR argvars , VAR retvar ) ;
static void f_expand(VAR argvars , VAR retvar ) ;
static void f_filereadable(VAR argvars , VAR retvar ) ;
static void f_fnamemodify(VAR argvars , VAR retvar ) ;
static void f_getcwd(VAR argvars , VAR retvar ) ;
static void f_getftime(VAR argvars , VAR retvar ) ;
static void f_getline(VAR argvars , VAR retvar ) ;
static void f_getwinposx(VAR argvars , VAR retvar ) ;
static void f_getwinposy(VAR argvars , VAR retvar ) ;
static void f_glob(VAR argvars , VAR retvar ) ;
static void f_has(VAR argvars , VAR retvar ) ;
static void f_histadd(VAR argvars , VAR retvar ) ;
static void f_histdel(VAR argvars , VAR retvar ) ;
static void f_histget(VAR argvars , VAR retvar ) ;
static void f_histnr(VAR argvars , VAR retvar ) ;
static void f_hlexists(VAR argvars , VAR retvar ) ;
static void f_hlID(VAR argvars , VAR retvar ) ;
static void f_hostname(VAR argvars , VAR retvar ) ;
static void f_isdirectory(VAR argvars , VAR retvar ) ;
static void f_input(VAR argvars , VAR retvar ) ;
static void f_last_buffer_nr(VAR argvars , VAR retvar ) ;
static void f_libcall(VAR argvars , VAR retvar ) ;
static void f_line(VAR argvars , VAR retvar ) ;
static void f_line2byte(VAR argvars , VAR retvar ) ;
static void f_localtime(VAR argvars , VAR retvar ) ;
static void f_maparg(VAR argvars , VAR retvar ) ;
static void f_mapcheck(VAR argvars , VAR retvar ) ;
static void get_maparg(VAR argvars , VAR retvar , int exact ) ;
static void f_match(VAR argvars , VAR retvar ) ;
static void f_matchend(VAR argvars , VAR retvar ) ;
static void f_matchstr(VAR argvars , VAR retvar ) ;
static void f_nr2char(VAR argvars , VAR retvar ) ;
static void f_rename(VAR argvars , VAR retvar ) ;
static void f_setline(VAR argvars , VAR retvar ) ;
static void f_some_match(VAR argvars , VAR retvar , int type ) ;
static void f_strftime(VAR argvars , VAR retvar ) ;
static void f_strlen(VAR argvars , VAR retvar ) ;
static void f_strpart(VAR argvars , VAR retvar ) ;
static void f_strtrans(VAR argvars , VAR retvar ) ;
static void f_synID(VAR argvars , VAR retvar ) ;
static void f_synIDattr(VAR argvars , VAR retvar ) ;
static void f_synIDtrans(VAR argvars , VAR retvar ) ;
static void f_system(VAR argvars , VAR retvar ) ;
static void f_substitute(VAR argvars , VAR retvar ) ;
static void f_tempname(VAR argvars , VAR retvar ) ;
static void f_virtcol(VAR argvars , VAR retvar ) ;
static void f_visualmode(VAR argvars , VAR retvar ) ;
static void f_winbufnr(VAR argvars , VAR retvar ) ;
static void f_winheight(VAR argvars , VAR retvar ) ;
static void f_winnr(VAR argvars , VAR retvar ) ;
static WIN *find_win_by_nr(VAR vp ) ;
static FPOS *var2fpos(VAR varp ) ;
static int get_env_len(char_u **arg ) ;
static int get_id_len(char_u **arg ) ;
static int eval_isnamec(int c ) ;
static int find_vim_var(char_u *name___1 , int len___0 ) ;
static int get_var_var(char_u *name___1 , int len___0 , VAR retvar ) ;
static VAR alloc_var(void) ;
static VAR alloc_string_var(char_u *s ) ;
static void free_var(VAR varp ) ;
static void clear_var(VAR varp ) ;
static long get_var_number(VAR varp ) ;
static char_u *get_var_string(VAR varp ) ;
static char_u *get_var_string_buf(VAR varp , char_u *buf___3 ) ;
static VAR find_var(char_u *name___1 , int writing ) ;
static struct growarray *find_var_ga(char_u *name___1 , char_u **varname ) ;
static void var_free_one(VAR v ) ;
static void list_one_var(VAR v , char_u *prefix ) ;
static void list_vim_var(int i___0 ) ;
static void list_one_var_a(char_u *prefix , char_u *name___1 , int type , char_u *string___0 ) ;
static void set_var(char_u *name___1 , VAR varp ) ;
static char_u *find_option_end(char_u *p___0 ) ;
static void list_func_head(struct ufunc *fp___0 ) ;
static struct ufunc *find_func(char_u *name___1 ) ;
static void call_func(struct ufunc *fp___0 , int argcount , VAR argvars , VAR retvar ,
                      linenr_t firstline , linenr_t lastline ) ;
void set_internal_string_var(char_u *name___1 , char_u *value ) 
{ 
  char_u *val ;
  VAR varp ;

  {
  {
  val = vim_strsave(value);
  }
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
    varp = alloc_string_var(val);
    }
    if ((unsigned long )varp != (unsigned long )((void *)0)) {
      {
      set_var(name___1, varp);
      free_var(varp);
      }
    }
  }
  return;
}
}
int eval_to_bool(char_u *arg , int *error , char_u **nextcmd , int skip ) 
{ 
  var retvar ;
  int retval ;
  long tmp ;
  int tmp___0 ;

  {
  retval = 0;
  if (skip) {
    emsg_off ++;
  }
  {
  tmp___0 = eval0(arg, & retvar, nextcmd, ! skip);
  }
  if (tmp___0 == 0) {
    *error = 1;
  } else { //Added block
  if (! skip) {
    {
    *error = 0;
    tmp = get_var_number(& retvar);
    retval = tmp != 0L;
    clear_var(& retvar);
    }
  }
  }
  if (skip) {
    emsg_off --;
  }
  return (retval);
}
}
char_u *eval_to_string(char_u *arg , char_u **nextcmd ) 
{ 
  var retvar ;
  char_u *retval ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = eval0(arg, & retvar, nextcmd, 1);
  }
  if (tmp___0 == 0) {
    retval = (char_u *)((void *)0);
  } else {
    {
    tmp = get_var_string(& retvar);
    retval = vim_strsave(tmp);
    clear_var(& retvar);
    }
  }
  return (retval);
}
}
char_u *eval_to_string_safe(char_u *arg , char_u **nextcmd ) 
{ 
  char_u *retval ;
  void *save_funccalp ;

  {
  {
  save_funccalp = save_funccal();
  sandbox ++;
  retval = eval_to_string(arg, nextcmd);
  sandbox --;
  restore_funccal(save_funccalp);
  }
  return (retval);
}
}
void do_let(EXARG *eap ) 
{ 
  char_u *arg ;
  char_u *expr ;
  char_u *name___1 ;
  VAR varp ;
  var retvar ;
  char_u *p___0 ;
  int c1 ;
  int c2 ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int len___0 ;
  int cc___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  long tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;
  char_u *tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;

  {
  {
  arg = eap->arg;
  expr = vim_strchr(arg, '=');
  }
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
    tmp___2 = ends_excmd((int )*arg);
    }
    if (tmp___2) {
      if (! eap->skip) {
        i___0 = 0;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (i___0 < variables.ga_len)) {
            goto while_break;
          }
          if ((unsigned long )((VAR )variables.ga_data + i___0)->var_name != (unsigned long )((void *)0)) {
            {
            list_one_var((VAR )variables.ga_data + i___0, (char_u *)"");
            }
          }
          i___0 ++;
        }
        while_break: /* CIL Label */ ;
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (i___0 < curbuf->b_vars.ga_len)) {
            goto while_break___0;
          }
          if ((unsigned long )((VAR )curbuf->b_vars.ga_data + i___0)->var_name != (unsigned long )((void *)0)) {
            {
            list_one_var((VAR )curbuf->b_vars.ga_data + i___0, (char_u *)"b:");
            }
          }
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (i___0 < curwin->w_vars.ga_len)) {
            goto while_break___1;
          }
          if ((unsigned long )((VAR )curwin->w_vars.ga_data + i___0)->var_name != (unsigned long )((void *)0)) {
            {
            list_one_var((VAR )curwin->w_vars.ga_data + i___0, (char_u *)"w:");
            }
          }
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (i___0 < 8)) {
            goto while_break___2;
          }
          if ((int )vimvars[i___0].type == 1) {
            {
            list_vim_var(i___0);
            }
          } else { //Added block
          if ((unsigned long )vimvars[i___0].val != (unsigned long )((void *)0)) {
            {
            list_vim_var(i___0);
            }
          }
          }
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
        tmp___1 = ends_excmd((int )*arg);
        }
        if (tmp___1) {
          goto while_break___3;
        }
        p___0 = arg;
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
          tmp = eval_isnamec((int )*p___0);
          }
          if (! tmp) {
            goto while_break___4;
          }
          p___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        if (! ((int )*p___0 == 32)) {
          if (! ((int )*p___0 == 9)) {
            {
            tmp___0 = ends_excmd((int )*p___0);
            }
            if (! tmp___0) {
              {
              emsg(e_trailing);
              }
              goto while_break___3;
            }
          }
        }
        if (! eap->skip) {
          {
          c1 = (int )*p___0;
          *p___0 = (char_u )'\000';
          i___0 = find_vim_var(arg, (int )(p___0 - arg));
          }
          if (i___0 >= 0) {
            {
            list_vim_var(i___0);
            }
          } else {
            {
            varp = find_var(arg, 0);
            }
            if ((unsigned long )varp == (unsigned long )((void *)0)) {
              {
              emsg2((char_u *)"Unknown variable: \"%s\"", arg);
              }
            } else {
              {
              name___1 = vim_strchr(arg, ':');
              }
              if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
                if ((int )*(arg + 0) == 97) {
                  if ((int )*(arg + 1) == 58) {
                    c2 = '\000';
                  } else {
                    name___1 ++;
                    c2 = (int )*name___1;
                    *name___1 = (char_u )'\000';
                  }
                } else {
                  name___1 ++;
                  c2 = (int )*name___1;
                  *name___1 = (char_u )'\000';
                }
                {
                list_one_var(varp, arg);
                }
                if (c2 != 0) {
                  *name___1 = (char_u )c2;
                }
              } else {
                {
                list_one_var(varp, (char_u *)"");
                }
              }
            }
          }
          *p___0 = (char_u )c1;
        }
        {
        arg = skipwhite(p___0);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    eap->nextcmd = check_nextcmd(arg);
    }
  } else {
    if (eap->skip) {
      emsg_off ++;
    }
    {
    i___0 = eval0(expr + 1, & retvar, & eap->nextcmd, ! eap->skip);
    }
    if (eap->skip) {
      if (i___0 != 0) {
        {
        clear_var(& retvar);
        }
      }
      emsg_off --;
    } else { //Added block
    if (i___0 != 0) {
      if ((int )*arg == 36) {
        {
        arg ++;
        name___1 = arg;
        len___0 = get_env_len(& arg);
        }
        if (len___0 == 0) {
          {
          emsg2(e_invarg2, name___1 - 1);
          }
        } else {
          {
          tmp___6 = skipwhite(arg);
          }
          if ((int )*tmp___6 != 61) {
            {
            emsg(e_letunexp);
            }
          } else {
            {
            cc___0 = (int )*(name___1 + len___0);
            *(name___1 + len___0) = (char_u )'\000';
            p___0 = get_var_string(& retvar);
            vim_setenv(name___1, p___0);
            tmp___5 = strcasecmp((char const   *)((char *)name___1), (char const   *)((char *)"HOME"));
            }
            if (tmp___5 == 0) {
              {
              init_homedir();
              }
            } else { //Added block
            if (didset_vim) {
              {
              tmp___4 = strcasecmp((char const   *)((char *)name___1), (char const   *)((char *)"VIM"));
              }
              if (tmp___4 == 0) {
                didset_vim = 0;
              } else {
                goto _L;
              }
            } else { //Added block
            _L: 
            if (didset_vimruntime) {
              {
              tmp___3 = strcasecmp((char const   *)((char *)name___1), (char const   *)((char *)"VIMRUNTIME"));
              }
              if (tmp___3 == 0) {
                didset_vimruntime = 0;
              }
            }
            }
            }
            *(name___1 + len___0) = (char_u )cc___0;
          }
        }
      } else { //Added block
      if ((int )*arg == 38) {
        {
        arg ++;
        p___0 = find_option_end(arg);
        tmp___9 = skipwhite(p___0);
        }
        if ((int )*tmp___9 != 61) {
          {
          emsg(e_letunexp);
          }
        } else {
          {
          c1 = (int )*p___0;
          *p___0 = (char_u )'\000';
          tmp___7 = get_var_string(& retvar);
          tmp___8 = get_var_number(& retvar);
          set_option_value(arg, tmp___8, tmp___7);
          *p___0 = (char_u )c1;
          }
        }
      } else { //Added block
      if ((int )*arg == 64) {
        {
        arg ++;
        tmp___12 = skipwhite(arg + 1);
        }
        if ((int )*tmp___12 != 61) {
          {
          emsg(e_letunexp);
          }
        } else {
          {
          tmp___10 = get_var_string(& retvar);
          }
          if ((int )*arg == 64) {
            tmp___11 = '\"';
          } else {
            tmp___11 = (int )*arg;
          }
          {
          write_reg_contents(tmp___11, tmp___10);
          }
        }
      } else {
        {
        tmp___15 = eval_isnamec((int )*arg);
        }
        if (tmp___15) {
          {
          tmp___16 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___16 + (int )*arg) & 2048) {
            {
            emsg2(e_invarg2, arg);
            }
          } else {
            p___0 = arg;
            {
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
              tmp___13 = eval_isnamec((int )*p___0);
              }
              if (! tmp___13) {
                goto while_break___5;
              }
              p___0 ++;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
            tmp___14 = skipwhite(p___0);
            }
            if ((int )*tmp___14 != 61) {
              {
              emsg(e_letunexp);
              }
            } else {
              {
              c1 = (int )*p___0;
              *p___0 = (char_u )'\000';
              set_var(arg, & retvar);
              *p___0 = (char_u )c1;
              }
            }
          }
        } else {
          {
          emsg2(e_invarg2, arg);
          }
        }
      }
      }
      }
      {
      clear_var(& retvar);
      }
    }
    }
  }
  return;
}
}
void set_context_for_expression(char_u *arg , CMDIDX cmdidx ) 
{ 
  int got_eq ;
  int c ;
  int tmp ;
  char *tmp___0 ;

  {
  got_eq = 0;
  if ((int )cmdidx == 128) {
    expand_context = 15;
  } else {
    if ((int )cmdidx == 31) {
      tmp = 18;
    } else {
      tmp = 20;
    }
    expand_context = tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = strpbrk((char const   *)((char *)arg), (char const   *)((char *)((char_u *)"\"\'+-*/%.=!?~|&([<>,#")));
    expand_pattern = (char_u *)tmp___0;
    }
    if (! ((unsigned long )expand_pattern != (unsigned long )((void *)0))) {
      goto while_break;
    }
    c = (int )*expand_pattern;
    if (c == 38) {
      c = (int )*(expand_pattern + 1);
      if (c == 38) {
        expand_pattern ++;
        if ((int )cmdidx != 128) {
          expand_context = 20;
        } else { //Added block
        if (got_eq) {
          expand_context = 20;
        } else {
          expand_context = 0;
        }
        }
      } else { //Added block
      if (c != 32) {
        expand_context = 4;
      }
      }
    } else { //Added block
    if (c == 36) {
      expand_context = 0;
    } else { //Added block
    if ((int )*expand_pattern == 61) {
      got_eq = 1;
      expand_context = 20;
    } else { //Added block
    if ((int )cmdidx != 128) {
      goto _L;
    } else { //Added block
    if (got_eq) {
      _L: 
      if (c == 34) {
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          expand_pattern ++;
          c = (int )*expand_pattern;
          if (c != 0) {
            if (! (c != 34)) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
          if (c == 92) {
            if ((int )*(expand_pattern + 1) != 0) {
              expand_pattern ++;
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        expand_context = 0;
      } else { //Added block
      if (c == 39) {
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          expand_pattern ++;
          c = (int )*expand_pattern;
          if (c != 0) {
            if (! (c != 39)) {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        expand_context = 0;
      } else { //Added block
      if (c == 124) {
        if ((int )*(expand_pattern + 1) == 124) {
          expand_pattern ++;
          expand_context = 20;
        } else {
          expand_context = 1;
        }
      } else {
        expand_context = 20;
      }
      }
      }
    } else {
      expand_context = 0;
    }
    }
    }
    }
    }
    arg = expand_pattern;
    if ((int )*arg != 0) {
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        arg ++;
        c = (int )*arg;
        if (c != 0) {
          if (! (c == 32)) {
            if (! (c == 9)) {
              goto while_break___2;
            }
          }
        } else {
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  expand_pattern = arg;
  return;
}
}
void do_call(EXARG *eap ) 
{ 
  char_u *arg ;
  char_u *startarg ;
  char_u *name___1 ;
  var retvar ;
  int len___0 ;
  linenr_t lnum ;
  int doesrange ;
  int failed ;
  int tmp ;
  int tmp___0 ;

  {
  {
  arg = eap->arg;
  failed = 0;
  name___1 = arg;
  len___0 = get_id_len(& arg);
  startarg = arg;
  retvar.var_type = (char)0;
  }
  if ((int )*startarg != 40) {
    {
    emsg2((char_u *)"Missing braces: %s", name___1);
    }
    return;
  }
  if (eap->skip) {
    emsg_off ++;
  }
  lnum = eap->line1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lnum <= eap->line2)) {
      goto while_break;
    }
    if (! eap->skip) {
      if (eap->line1 != eap->line2) {
        curwin->w_cursor.lnum = lnum;
        curwin->w_cursor.col = (colnr_t )0;
      }
    }
    {
    arg = startarg;
    tmp = get_func_var(name___1, len___0, & retvar, & arg, eap->line1, eap->line2,
                       & doesrange, ! eap->skip);
    }
    if (tmp == 0) {
      failed = 1;
      goto while_break;
    }
    {
    clear_var(& retvar);
    }
    if (doesrange) {
      goto while_break;
    } else { //Added block
    if (eap->skip) {
      goto while_break;
    }
    }
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (eap->skip) {
    emsg_off --;
  }
  if (! failed) {
    {
    tmp___0 = ends_excmd((int )*arg);
    }
    if (tmp___0) {
      {
      eap->nextcmd = check_nextcmd(arg);
      }
    } else {
      {
      emsg(e_trailing);
      }
    }
  }
  return;
}
}
void do_unlet(char_u *arg , int forceit ) 
{ 
  char_u *name_end ;
  VAR v ;
  char_u cc___0 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    name_end = skiptowhite(arg);
    cc___0 = *name_end;
    *name_end = (char_u )'\000';
    v = find_var(arg, 1);
    }
    if ((unsigned long )v != (unsigned long )((void *)0)) {
      {
      var_free_one(v);
      }
    } else { //Added block
    if (! forceit) {
      {
      *name_end = cc___0;
      emsg2((char_u *)"No such variable: \"%s\"", arg);
      }
      goto while_break;
    }
    }
    {
    *name_end = cc___0;
    arg = skipwhite(name_end);
    }
    if (! ((int )*arg != 0)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char_u *cat_prefix_varname(int prefix , char_u *name___1 ) ;
static char_u *varnamebuf  =    (char_u *)((void *)0);
static int varnamebuflen  =    0;
static char_u *cat_prefix_varname(int prefix , char_u *name___1 ) 
{ 
  int len___0 ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)name___1));
  len___0 = (int )(tmp + 3UL);
  }
  if (len___0 > varnamebuflen) {
    {
    vim_free((void *)varnamebuf);
    len___0 += 10;
    varnamebuf = alloc((unsigned int )len___0);
    }
    if ((unsigned long )varnamebuf == (unsigned long )((void *)0)) {
      varnamebuflen = 0;
      return ((char_u *)((void *)0));
    }
    varnamebuflen = len___0;
  }
  {
  *varnamebuf = (char_u )prefix;
  *(varnamebuf + 1) = (char_u )':';
  strcpy((char * __restrict  )((char *)(varnamebuf + 2)), (char const   * __restrict  )((char *)name___1));
  }
  return (varnamebuf);
}
}
static int gidx  ;
static int bidx  ;
static int widx  ;
static int vidx  ;
char_u *get_user_var_name(int idx ) 
{ 
  char_u *name___1 ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;

  {
  if (idx == 0) {
    vidx = 0;
    widx = vidx;
    bidx = widx;
    gidx = bidx;
  }
  if (gidx < variables.ga_len) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp = gidx;
      gidx ++;
      name___1 = ((VAR )variables.ga_data + tmp)->var_name;
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
        if (! (gidx < variables.ga_len)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
      return (name___1);
    }
  }
  if (bidx < curbuf->b_vars.ga_len) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      tmp___0 = bidx;
      bidx ++;
      name___1 = ((VAR )curbuf->b_vars.ga_data + tmp___0)->var_name;
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
        if (! (bidx < curbuf->b_vars.ga_len)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
      {
      tmp___1 = cat_prefix_varname('b', name___1);
      }
      return (tmp___1);
    }
  }
  if (widx < curwin->w_vars.ga_len) {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      tmp___2 = widx;
      widx ++;
      name___1 = ((VAR )curwin->w_vars.ga_data + tmp___2)->var_name;
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
        if (! (widx < curwin->w_vars.ga_len)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
      {
      tmp___3 = cat_prefix_varname('w', name___1);
      }
      return (tmp___3);
    }
  }
  if (vidx < 8) {
    {
    tmp___4 = vidx;
    vidx ++;
    tmp___5 = cat_prefix_varname('v', (char_u *)vimvars[tmp___4].name);
    }
    return (tmp___5);
  }
  {
  vim_free((void *)varnamebuf);
  varnamebuf = (char_u *)((void *)0);
  varnamebuflen = 0;
  }
  return ((char_u *)((void *)0));
}
}
static int eval0(char_u *arg , VAR retvar , char_u **nextcmd , int evaluate ) 
{ 
  int ret ;
  char_u *p___0 ;
  int tmp ;

  {
  {
  p___0 = skipwhite(arg);
  ret = eval1(& p___0, retvar, evaluate);
  }
  if (ret == 0) {
    goto _L;
  } else {
    {
    tmp = ends_excmd((int )*p___0);
    }
    if (! tmp) {
      _L: 
      if (ret != 0) {
        {
        clear_var(retvar);
        }
      }
      {
      emsg2(e_invexpr2, arg);
      ret = 0;
      }
    }
  }
  if ((unsigned long )nextcmd != (unsigned long )((void *)0)) {
    {
    *nextcmd = check_nextcmd(p___0);
    }
  }
  return (ret);
}
}
static int eval1(char_u **arg , VAR retvar , int evaluate ) 
{ 
  var var2 ;
  long result___0 ;
  int first___0 ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
  result___0 = 0L;
  first___0 = 1;
  tmp = eval2(arg, retvar, evaluate);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*(*arg + 0) == 124) {
      if (! ((int )*(*arg + 1) == 124)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (evaluate) {
      if (first___0) {
        {
        tmp___0 = get_var_number(retvar);
        }
        if (tmp___0 != 0L) {
          result___0 = 1L;
        }
        {
        clear_var(retvar);
        first___0 = 0;
        }
      }
    }
    {
    *arg = skipwhite(*arg + 2);
    }
    if (evaluate) {
      if (! result___0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    {
    tmp___2 = eval2(arg, & var2, tmp___1);
    }
    if (tmp___2 == 0) {
      return (0);
    }
    if (evaluate) {
      if (! result___0) {
        {
        tmp___3 = get_var_number(& var2);
        }
        if (tmp___3 != 0L) {
          result___0 = 1L;
        }
        {
        clear_var(& var2);
        }
      }
    }
    if (evaluate) {
      retvar->var_type = (char)1;
      retvar->var_val.var_number = (var_number_type )result___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int eval2(char_u **arg , VAR retvar , int evaluate ) 
{ 
  var var2 ;
  long result___0 ;
  int first___0 ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
  result___0 = 1L;
  first___0 = 1;
  tmp = eval3(arg, retvar, evaluate);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*(*arg + 0) == 38) {
      if (! ((int )*(*arg + 1) == 38)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (evaluate) {
      if (first___0) {
        {
        tmp___0 = get_var_number(retvar);
        }
        if (tmp___0 == 0L) {
          result___0 = 0L;
        }
        {
        clear_var(retvar);
        first___0 = 0;
        }
      }
    }
    {
    *arg = skipwhite(*arg + 2);
    }
    if (evaluate) {
      if (result___0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    {
    tmp___2 = eval3(arg, & var2, tmp___1);
    }
    if (tmp___2 == 0) {
      return (0);
    }
    if (evaluate) {
      if (result___0) {
        {
        tmp___3 = get_var_number(& var2);
        }
        if (tmp___3 == 0L) {
          result___0 = 0L;
        }
        {
        clear_var(& var2);
        }
      }
    }
    if (evaluate) {
      retvar->var_type = (char)1;
      retvar->var_val.var_number = (var_number_type )result___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int eval3(char_u **arg , VAR retvar , int evaluate ) 
{ 
  var var2 ;
  char_u *p___0 ;
  int i___0 ;
  enum exp_type type ;
  int len___0 ;
  long n1 ;
  long n2 ;
  char_u *s1 ;
  char_u *s2 ;
  char_u buf1[30] ;
  char_u buf2[30] ;
  vim_regexp *prog ;
  int ic ;
  char_u *save_cpo ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  i___0 = 0;
  type = (enum exp_type )0;
  len___0 = 2;
  n1 = 0L;
  tmp = eval4(arg, retvar, evaluate);
  }
  if (tmp == 0) {
    return (0);
  }
  p___0 = *arg;
  {
  if ((int )*(p___0 + 0) == 61) {
    goto case_61;
  }
  if ((int )*(p___0 + 0) == 33) {
    goto case_33;
  }
  if ((int )*(p___0 + 0) == 62) {
    goto case_62;
  }
  if ((int )*(p___0 + 0) == 60) {
    goto case_60;
  }
  goto switch_break;
  case_61: /* CIL Label */ 
  if ((int )*(p___0 + 1) == 61) {
    type = (enum exp_type )1;
  } else { //Added block
  if ((int )*(p___0 + 1) == 126) {
    type = (enum exp_type )7;
  }
  }
  goto switch_break;
  case_33: /* CIL Label */ 
  if ((int )*(p___0 + 1) == 61) {
    type = (enum exp_type )2;
  } else { //Added block
  if ((int )*(p___0 + 1) == 126) {
    type = (enum exp_type )8;
  }
  }
  goto switch_break;
  case_62: /* CIL Label */ 
  if ((int )*(p___0 + 1) != 61) {
    type = (enum exp_type )3;
    len___0 = 1;
  } else {
    type = (enum exp_type )4;
  }
  goto switch_break;
  case_60: /* CIL Label */ 
  if ((int )*(p___0 + 1) != 61) {
    type = (enum exp_type )5;
    len___0 = 1;
  } else {
    type = (enum exp_type )6;
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if ((unsigned int )type != 0U) {
    if ((int )*(p___0 + len___0) == 63) {
      ic = 1;
      len___0 ++;
    } else { //Added block
    if ((int )*(p___0 + len___0) == 35) {
      ic = 0;
      len___0 ++;
    } else {
      ic = p_ic;
    }
    }
    {
    *arg = skipwhite(p___0 + len___0);
    tmp___0 = eval4(arg, & var2, evaluate);
    }
    if (tmp___0 == 0) {
      {
      clear_var(retvar);
      }
      return (0);
    }
    if (evaluate) {
      if ((int )retvar->var_type == 1) {
        goto _L___1;
      } else { //Added block
      if ((int )var2.var_type == 1) {
        _L___1: 
        if ((unsigned int )type != 7U) {
          if ((unsigned int )type != 8U) {
            {
            n1 = get_var_number(retvar);
            n2 = get_var_number(& var2);
            }
            {
            if ((unsigned int )type == 1U) {
              goto case_1;
            }
            if ((unsigned int )type == 2U) {
              goto case_2;
            }
            if ((unsigned int )type == 3U) {
              goto case_3;
            }
            if ((unsigned int )type == 4U) {
              goto case_4;
            }
            if ((unsigned int )type == 5U) {
              goto case_5;
            }
            if ((unsigned int )type == 6U) {
              goto case_6;
            }
            if ((unsigned int )type == 0U) {
              goto case_0;
            }
            if ((unsigned int )type == 7U) {
              goto case_0;
            }
            if ((unsigned int )type == 8U) {
              goto case_0;
            }
            goto switch_break___0;
            case_1: /* CIL Label */ 
            n1 = (long )(n1 == n2);
            goto switch_break___0;
            case_2: /* CIL Label */ 
            n1 = (long )(n1 != n2);
            goto switch_break___0;
            case_3: /* CIL Label */ 
            n1 = (long )(n1 > n2);
            goto switch_break___0;
            case_4: /* CIL Label */ 
            n1 = (long )(n1 >= n2);
            goto switch_break___0;
            case_5: /* CIL Label */ 
            n1 = (long )(n1 < n2);
            goto switch_break___0;
            case_6: /* CIL Label */ 
            n1 = (long )(n1 <= n2);
            goto switch_break___0;
            case_0: /* CIL Label */ 
            case_7: /* CIL Label */ 
            case_8: /* CIL Label */ 
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        {
        s1 = get_var_string_buf(retvar, buf1);
        s2 = get_var_string_buf(& var2, buf2);
        }
        if ((unsigned int )type != 7U) {
          if ((unsigned int )type != 8U) {
            if (ic) {
              {
              tmp___1 = strcasecmp((char const   *)((char *)s1), (char const   *)((char *)s2));
              i___0 = tmp___1;
              }
            } else {
              {
              tmp___2 = strcmp((char const   *)((char *)s1), (char const   *)((char *)s2));
              i___0 = tmp___2;
              }
            }
          }
        }
        {
        if ((unsigned int )type == 1U) {
          goto case_1___0;
        }
        if ((unsigned int )type == 2U) {
          goto case_2___0;
        }
        if ((unsigned int )type == 3U) {
          goto case_3___0;
        }
        if ((unsigned int )type == 4U) {
          goto case_4___0;
        }
        if ((unsigned int )type == 5U) {
          goto case_5___0;
        }
        if ((unsigned int )type == 6U) {
          goto case_6___0;
        }
        if ((unsigned int )type == 7U) {
          goto case_7___0;
        }
        if ((unsigned int )type == 8U) {
          goto case_7___0;
        }
        if ((unsigned int )type == 0U) {
          goto case_0___0;
        }
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
        n1 = (long )(i___0 == 0);
        goto switch_break___1;
        case_2___0: /* CIL Label */ 
        n1 = (long )(i___0 != 0);
        goto switch_break___1;
        case_3___0: /* CIL Label */ 
        n1 = (long )(i___0 > 0);
        goto switch_break___1;
        case_4___0: /* CIL Label */ 
        n1 = (long )(i___0 >= 0);
        goto switch_break___1;
        case_5___0: /* CIL Label */ 
        n1 = (long )(i___0 < 0);
        goto switch_break___1;
        case_6___0: /* CIL Label */ 
        n1 = (long )(i___0 <= 0);
        goto switch_break___1;
        case_7___0: /* CIL Label */ 
        case_8___0: /* CIL Label */ 
        {
        reg_ic = ic;
        save_cpo = p_cpo;
        p_cpo = (char_u *)"";
        prog = vim_regcomp(s2, 1);
        }
        if ((unsigned long )prog != (unsigned long )((void *)0)) {
          {
          tmp___3 = vim_regexec(prog, s1, 1);
          n1 = (long )tmp___3;
          vim_free((void *)prog);
          }
          if ((unsigned int )type == 8U) {
            n1 = (long )(! n1);
          }
        }
        p_cpo = save_cpo;
        goto switch_break___1;
        case_0___0: /* CIL Label */ 
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
      }
      {
      clear_var(retvar);
      clear_var(& var2);
      retvar->var_type = (char)1;
      retvar->var_val.var_number = (var_number_type )n1;
      }
    }
  }
  return (1);
}
}
static int eval4(char_u **arg , VAR retvar , int evaluate ) 
{ 
  var var2 ;
  int op ;
  long n1 ;
  long n2 ;
  char_u *s1 ;
  char_u *s2 ;
  char_u buf1[30] ;
  char_u buf2[30] ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
  tmp = eval5(arg, retvar, evaluate);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    op = (int )*(*arg);
    if (op != 43) {
      if (op != 45) {
        if (op != 46) {
          goto while_break;
        }
      }
    }
    {
    *arg = skipwhite(*arg + 1);
    tmp___0 = eval5(arg, & var2, evaluate);
    }
    if (tmp___0 == 0) {
      {
      clear_var(retvar);
      }
      return (0);
    }
    if (evaluate) {
      if (op == 46) {
        {
        s1 = get_var_string_buf(retvar, buf1);
        s2 = get_var_string_buf(& var2, buf2);
        tmp___1 = strlen((char const   *)((char *)s1));
        op = (int )tmp___1;
        tmp___2 = strlen((char const   *)((char *)s2));
        p___0 = alloc((unsigned int )(((size_t )op + tmp___2) + 1UL));
        }
        if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
          {
          strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)s1));
          strcpy((char * __restrict  )((char *)(p___0 + op)), (char const   * __restrict  )((char *)s2));
          }
        }
        {
        clear_var(retvar);
        retvar->var_type = (char)2;
        retvar->var_val.var_string = p___0;
        }
      } else {
        {
        n1 = get_var_number(retvar);
        n2 = get_var_number(& var2);
        clear_var(retvar);
        }
        if (op == 43) {
          n1 += n2;
        } else {
          n1 -= n2;
        }
        retvar->var_type = (char)1;
        retvar->var_val.var_number = (var_number_type )n1;
      }
      {
      clear_var(& var2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int eval5(char_u **arg , VAR retvar , int evaluate ) 
{ 
  var var2 ;
  int op ;
  long n1 ;
  long n2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  n1 = 0L;
  tmp = eval6(arg, retvar, evaluate);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    op = (int )*(*arg);
    if (op != 42) {
      if (op != 47) {
        if (op != 37) {
          goto while_break;
        }
      }
    }
    if (evaluate) {
      {
      n1 = get_var_number(retvar);
      clear_var(retvar);
      }
    }
    {
    *arg = skipwhite(*arg + 1);
    tmp___0 = eval6(arg, & var2, evaluate);
    }
    if (tmp___0 == 0) {
      return (0);
    }
    if (evaluate) {
      {
      n2 = get_var_number(& var2);
      clear_var(& var2);
      }
      if (op == 42) {
        n1 *= n2;
      } else { //Added block
      if (op == 47) {
        if (n2 == 0L) {
          n1 = 2147483647L;
        } else {
          n1 /= n2;
        }
      } else { //Added block
      if (n2 == 0L) {
        n1 = 0L;
      } else {
        n1 %= n2;
      }
      }
      }
      retvar->var_type = (char)1;
      retvar->var_val.var_number = (var_number_type )n1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int eval6(char_u **arg , VAR retvar , int evaluate ) 
{ 
  var var2 ;
  long n ;
  int len___0 ;
  char_u *s ;
  int val ;
  char_u *start_leader ;
  char_u *end_leader ;
  int ret ;
  int tmp ;
  size_t tmp___0 ;
  long tmp___1 ;

  {
  ret = 1;
  retvar->var_type = (char)0;
  start_leader = *arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*(*arg) == 33)) {
      if (! ((int )*(*arg) == 45)) {
        goto while_break;
      }
    }
    {
    *arg = skipwhite(*arg + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  end_leader = *arg;
  {
  if ((int )*(*arg) == 48) {
    goto case_48;
  }
  if ((int )*(*arg) == 49) {
    goto case_48;
  }
  if ((int )*(*arg) == 50) {
    goto case_48;
  }
  if ((int )*(*arg) == 51) {
    goto case_48;
  }
  if ((int )*(*arg) == 52) {
    goto case_48;
  }
  if ((int )*(*arg) == 53) {
    goto case_48;
  }
  if ((int )*(*arg) == 54) {
    goto case_48;
  }
  if ((int )*(*arg) == 55) {
    goto case_48;
  }
  if ((int )*(*arg) == 56) {
    goto case_48;
  }
  if ((int )*(*arg) == 57) {
    goto case_48;
  }
  if ((int )*(*arg) == 34) {
    goto case_34;
  }
  if ((int )*(*arg) == 39) {
    goto case_39;
  }
  if ((int )*(*arg) == 38) {
    goto case_38;
  }
  if ((int )*(*arg) == 36) {
    goto case_36;
  }
  if ((int )*(*arg) == 64) {
    goto case_64;
  }
  if ((int )*(*arg) == 40) {
    goto case_40;
  }
  goto switch_default;
  case_48: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_57: /* CIL Label */ 
  {
  vim_str2nr(*arg, (int *)((void *)0), & len___0, 1, 1, & n, (unsigned long *)((void *)0));
  *arg += len___0;
  }
  if (evaluate) {
    retvar->var_type = (char)1;
    retvar->var_val.var_number = (var_number_type )n;
  }
  goto switch_break;
  case_34: /* CIL Label */ 
  {
  ret = get_string_var(arg, retvar, evaluate);
  }
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  ret = get_lit_string_var(arg, retvar, evaluate);
  }
  goto switch_break;
  case_38: /* CIL Label */ 
  {
  ret = get_option_var(arg, retvar, evaluate);
  }
  goto switch_break;
  case_36: /* CIL Label */ 
  {
  ret = get_env_var(arg, retvar, evaluate);
  }
  goto switch_break;
  case_64: /* CIL Label */ 
  (*arg) ++;
  if (evaluate) {
    {
    retvar->var_type = (char)2;
    retvar->var_val.var_string = get_reg_contents((int )*(*arg));
    }
  }
  if ((int )*(*arg) != 0) {
    (*arg) ++;
  }
  goto switch_break;
  case_40: /* CIL Label */ 
  {
  *arg = skipwhite(*arg + 1);
  ret = eval1(arg, retvar, evaluate);
  }
  if ((int )*(*arg) == 41) {
    (*arg) ++;
  } else { //Added block
  if (ret == 1) {
    {
    emsg((char_u *)"Missing \')\'");
    ret = 0;
    }
  }
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  s = *arg;
  len___0 = get_id_len(arg);
  }
  if (len___0) {
    if ((int )*(*arg) == 40) {
      {
      ret = get_func_var(s, len___0, retvar, arg, curwin->w_cursor.lnum, curwin->w_cursor.lnum,
                         & len___0, evaluate);
      }
    } else { //Added block
    if (evaluate) {
      {
      ret = get_var_var(s, len___0, retvar);
      }
    }
    }
  } else {
    ret = 0;
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  *arg = skipwhite(*arg);
  }
  if ((int )*(*arg) == 91) {
    if (ret == 1) {
      {
      *arg = skipwhite(*arg + 1);
      tmp = eval1(arg, & var2, evaluate);
      }
      if (tmp == 0) {
        {
        clear_var(retvar);
        }
        return (0);
      }
      if ((int )*(*arg) != 93) {
        {
        emsg((char_u *)"Missing \']\'");
        clear_var(retvar);
        }
        return (0);
      }
      if (evaluate) {
        {
        n = get_var_number(& var2);
        clear_var(& var2);
        s = get_var_string(retvar);
        tmp___0 = strlen((char const   *)((char *)s));
        }
        if (n >= (long )tmp___0) {
          s = (char_u *)((void *)0);
        } else { //Added block
        if (n < 0L) {
          s = (char_u *)((void *)0);
        } else {
          {
          s = vim_strnsave(s + n, 1);
          }
        }
        }
        {
        clear_var(retvar);
        retvar->var_type = (char)2;
        retvar->var_val.var_string = s;
        }
      }
      {
      *arg = skipwhite(*arg + 1);
      }
    }
  }
  if (ret == 1) {
    if (evaluate) {
      if ((unsigned long )end_leader > (unsigned long )start_leader) {
        {
        tmp___1 = get_var_number(retvar);
        val = (int )tmp___1;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((unsigned long )end_leader > (unsigned long )start_leader)) {
            goto while_break___0;
          }
          end_leader --;
          if ((int )*end_leader == 33) {
            val = ! val;
          } else { //Added block
          if ((int )*end_leader == 45) {
            val = - val;
          }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        clear_var(retvar);
        retvar->var_type = (char)1;
        retvar->var_val.var_number = val;
        }
      }
    }
  }
  return (ret);
}
}
static int get_option_var(char_u **arg , VAR retvar , int evaluate ) 
{ 
  char_u *option_end ;
  long numval ;
  char_u *stringval ;
  int opt_type ;
  int c ;
  int ret ;
  char_u **tmp ;

  {
  {
  ret = 1;
  option_end = find_option_end(*arg + 1);
  }
  if ((unsigned long )option_end == (unsigned long )(*arg + 1)) {
    if ((unsigned long )retvar != (unsigned long )((void *)0)) {
      {
      emsg2((char_u *)"Option name missing: %s", *arg);
      }
    }
    return (0);
  }
  if (! evaluate) {
    *arg = option_end;
    return (1);
  }
  c = (int )*option_end;
  *option_end = (char_u )'\000';
  if ((unsigned long )retvar == (unsigned long )((void *)0)) {
    tmp = (char_u **)((void *)0);
  } else {
    tmp = & stringval;
  }
  {
  opt_type = get_option_value(*arg + 1, & numval, tmp);
  }
  if (opt_type == -2) {
    if ((unsigned long )retvar != (unsigned long )((void *)0)) {
      {
      emsg2((char_u *)"Unknown option: %s", *arg + 1);
      }
    }
    ret = 0;
  } else { //Added block
  if ((unsigned long )retvar != (unsigned long )((void *)0)) {
    if (opt_type == -1) {
      retvar->var_type = (char)1;
      retvar->var_val.var_number = 0;
    } else { //Added block
    if (opt_type == 1) {
      retvar->var_type = (char)1;
      retvar->var_val.var_number = (var_number_type )numval;
    } else {
      retvar->var_type = (char)2;
      retvar->var_val.var_string = stringval;
    }
    }
  }
  }
  *option_end = (char_u )c;
  *arg = option_end;
  return (ret);
}
}
static int get_string_var(char_u **arg , VAR retvar , int evaluate ) 
{ 
  char_u *p___0 ;
  char_u *name___1 ;
  int i___0 ;
  int extra ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  extra = 0;
  p___0 = *arg + 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if (! ((int )*p___0 != 34)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 92) {
      if ((int )*(p___0 + 1) != 0) {
        p___0 ++;
        if ((int )*p___0 == 60) {
          extra += 2;
        }
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*p___0 != 34) {
    {
    emsg2((char_u *)"Missing quote: %s", *arg);
    }
    return (0);
  }
  if (! evaluate) {
    *arg = p___0 + 1;
    return (1);
  }
  {
  name___1 = alloc((unsigned int )((p___0 - *arg) + (long )extra));
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return (0);
  }
  i___0 = 0;
  p___0 = *arg + 1;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (*p___0) {
      if (! ((int )*p___0 != 34)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    if ((int )*p___0 == 92) {
      p___0 ++;
      {
      if ((int )*p___0 == 98) {
        goto case_98;
      }
      if ((int )*p___0 == 101) {
        goto case_101;
      }
      if ((int )*p___0 == 102) {
        goto case_102;
      }
      if ((int )*p___0 == 110) {
        goto case_110;
      }
      if ((int )*p___0 == 114) {
        goto case_114;
      }
      if ((int )*p___0 == 116) {
        goto case_116;
      }
      if ((int )*p___0 == 88) {
        goto case_88;
      }
      if ((int )*p___0 == 120) {
        goto case_88;
      }
      if ((int )*p___0 == 48) {
        goto case_48;
      }
      if ((int )*p___0 == 49) {
        goto case_48;
      }
      if ((int )*p___0 == 50) {
        goto case_48;
      }
      if ((int )*p___0 == 51) {
        goto case_48;
      }
      if ((int )*p___0 == 52) {
        goto case_48;
      }
      if ((int )*p___0 == 53) {
        goto case_48;
      }
      if ((int )*p___0 == 54) {
        goto case_48;
      }
      if ((int )*p___0 == 55) {
        goto case_48;
      }
      if ((int )*p___0 == 60) {
        goto case_60;
      }
      goto switch_default;
      case_98: /* CIL Label */ 
      tmp = i___0;
      i___0 ++;
      *(name___1 + tmp) = (char_u )'\b';
      goto switch_break;
      case_101: /* CIL Label */ 
      tmp___0 = i___0;
      i___0 ++;
      *(name___1 + tmp___0) = (char_u )'\033';
      goto switch_break;
      case_102: /* CIL Label */ 
      tmp___1 = i___0;
      i___0 ++;
      *(name___1 + tmp___1) = (char_u )'\f';
      goto switch_break;
      case_110: /* CIL Label */ 
      tmp___2 = i___0;
      i___0 ++;
      *(name___1 + tmp___2) = (char_u )'\n';
      goto switch_break;
      case_114: /* CIL Label */ 
      tmp___3 = i___0;
      i___0 ++;
      *(name___1 + tmp___3) = (char_u )'\r';
      goto switch_break;
      case_116: /* CIL Label */ 
      tmp___4 = i___0;
      i___0 ++;
      *(name___1 + tmp___4) = (char_u )'\t';
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      {
      tmp___9 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___9 + (int )*(p___0 + 1)) & 4096) {
        {
        p___0 ++;
        tmp___5 = hex2nr((int )*p___0);
        *(name___1 + i___0) = (char_u )tmp___5;
        tmp___7 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___7 + (int )*(p___0 + 1)) & 4096) {
          {
          p___0 ++;
          tmp___6 = hex2nr((int )*p___0);
          *(name___1 + i___0) = (char_u )(((int )*(name___1 + i___0) << 4) + tmp___6);
          }
        }
        i___0 ++;
      } else {
        tmp___8 = i___0;
        i___0 ++;
        *(name___1 + tmp___8) = *p___0;
      }
      goto switch_break;
      case_48: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_55: /* CIL Label */ 
      *(name___1 + i___0) = (char_u )((int )*p___0 - 48);
      if ((int )*(p___0 + 1) >= 48) {
        if ((int )*(p___0 + 1) <= 55) {
          p___0 ++;
          *(name___1 + i___0) = (char_u )((((int )*(name___1 + i___0) << 3) + (int )*p___0) - 48);
          if ((int )*(p___0 + 1) >= 48) {
            if ((int )*(p___0 + 1) <= 55) {
              p___0 ++;
              *(name___1 + i___0) = (char_u )((((int )*(name___1 + i___0) << 3) + (int )*p___0) - 48);
            }
          }
        }
      }
      i___0 ++;
      goto switch_break;
      case_60: /* CIL Label */ 
      {
      extra = trans_special(& p___0, name___1 + i___0, 0);
      }
      if (extra) {
        i___0 += extra;
        p___0 --;
        goto switch_break;
      }
      switch_default: /* CIL Label */ 
      tmp___10 = i___0;
      i___0 ++;
      *(name___1 + tmp___10) = *p___0;
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      tmp___11 = i___0;
      i___0 ++;
      *(name___1 + tmp___11) = *p___0;
    }
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *(name___1 + i___0) = (char_u )'\000';
  *arg = p___0 + 1;
  retvar->var_type = (char)2;
  retvar->var_val.var_string = name___1;
  return (1);
}
}
static int get_lit_string_var(char_u **arg , VAR retvar , int evaluate ) 
{ 
  char_u *p___0 ;
  char_u *name___1 ;

  {
  {
  p___0 = vim_strchr(*arg + 1, '\'');
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
    emsg2((char_u *)"Missing quote: %s", *arg);
    }
    return (0);
  }
  if (evaluate) {
    {
    name___1 = vim_strnsave(*arg + 1, (int )(p___0 - (*arg + 1)));
    }
    if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
      return (0);
    }
    retvar->var_type = (char)2;
    retvar->var_val.var_string = name___1;
  }
  *arg = p___0 + 1;
  return (1);
}
}
static int get_env_var(char_u **arg , VAR retvar , int evaluate ) 
{ 
  char_u *string___0 ;
  int len___0 ;
  int cc___0 ;
  char_u *name___1 ;
  char *tmp ;

  {
  {
  string___0 = (char_u *)((void *)0);
  (*arg) ++;
  name___1 = *arg;
  len___0 = get_env_len(arg);
  }
  if (evaluate) {
    if (len___0 != 0) {
      {
      cc___0 = (int )*(name___1 + len___0);
      *(name___1 + len___0) = (char_u )'\000';
      tmp = getenv((char const   *)((char *)name___1));
      string___0 = (char_u *)tmp;
      }
      if ((unsigned long )string___0 != (unsigned long )((void *)0)) {
        if ((int )*string___0 != 0) {
          {
          string___0 = vim_strsave(string___0);
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
        {
        string___0 = expand_env_save(name___1 - 1);
        }
        if ((unsigned long )string___0 != (unsigned long )((void *)0)) {
          if ((int )*string___0 == 36) {
            {
            vim_free((void *)string___0);
            string___0 = (char_u *)((void *)0);
            }
          }
        }
      }
      *(name___1 + len___0) = (char_u )cc___0;
    }
    retvar->var_type = (char)2;
    retvar->var_val.var_string = string___0;
  }
  return (1);
}
}
static struct fst functions[70]  = 
  {      {(char *)"append", (char)2, (char)2, & f_append}, 
        {(char *)"argc", (char)0, (char)0, & f_argc}, 
        {(char *)"argv", (char)1, (char)1, & f_argv}, 
        {(char *)"browse", (char)4, (char)4, & f_browse}, 
        {(char *)"bufexists", (char)1, (char)1, & f_bufexists}, 
        {(char *)"buffer_exists", (char)1, (char)1, & f_bufexists}, 
        {(char *)"buffer_name", (char)1, (char)1, & f_bufname}, 
        {(char *)"buffer_number", (char)1, (char)1, & f_bufnr}, 
        {(char *)"bufloaded", (char)1, (char)1, & f_bufloaded}, 
        {(char *)"bufname", (char)1, (char)1, & f_bufname}, 
        {(char *)"bufnr", (char)1, (char)1, & f_bufnr}, 
        {(char *)"bufwinnr", (char)1, (char)1, & f_bufwinnr}, 
        {(char *)"byte2line", (char)1, (char)1, & f_byte2line}, 
        {(char *)"char2nr", (char)1, (char)1, & f_char2nr}, 
        {(char *)"col", (char)1, (char)1, & f_col}, 
        {(char *)"confirm", (char)2, (char)4, & f_confirm}, 
        {(char *)"delete", (char)1, (char)1, & f_delete}, 
        {(char *)"did_filetype", (char)0, (char)0, & f_did_filetype}, 
        {(char *)"escape", (char)2, (char)2, & f_escape}, 
        {(char *)"exists", (char)1, (char)1, & f_exists}, 
        {(char *)"expand", (char)1, (char)2, & f_expand}, 
        {(char *)"file_readable", (char)1, (char)1, & f_filereadable}, 
        {(char *)"filereadable", (char)1, (char)1, & f_filereadable}, 
        {(char *)"fnamemodify", (char)2, (char)2, & f_fnamemodify}, 
        {(char *)"getcwd", (char)0, (char)0, & f_getcwd}, 
        {(char *)"getftime", (char)1, (char)1, & f_getftime}, 
        {(char *)"getline", (char)1, (char)1, & f_getline}, 
        {(char *)"getwinposx", (char)0, (char)0, & f_getwinposx}, 
        {(char *)"getwinposy", (char)0, (char)0, & f_getwinposy}, 
        {(char *)"glob", (char)1, (char)1, & f_glob}, 
        {(char *)"has", (char)1, (char)1, & f_has}, 
        {(char *)"highlightID", (char)1, (char)1, & f_hlID}, 
        {(char *)"highlight_exists", (char)1, (char)1, & f_hlexists}, 
        {(char *)"histadd", (char)2, (char)2, & f_histadd}, 
        {(char *)"histdel", (char)1, (char)2, & f_histdel}, 
        {(char *)"histget", (char)1, (char)2, & f_histget}, 
        {(char *)"histnr", (char)1, (char)1, & f_histnr}, 
        {(char *)"hlID", (char)1, (char)1, & f_hlID}, 
        {(char *)"hlexists", (char)1, (char)1, & f_hlexists}, 
        {(char *)"hostname", (char)0, (char)0, & f_hostname}, 
        {(char *)"input", (char)1, (char)1, & f_input}, 
        {(char *)"isdirectory", (char)1, (char)1, & f_isdirectory}, 
        {(char *)"last_buffer_nr", (char)0, (char)0, & f_last_buffer_nr}, 
        {(char *)"libcall", (char)3, (char)3, & f_libcall}, 
        {(char *)"line", (char)1, (char)1, & f_line}, 
        {(char *)"line2byte", (char)1, (char)1, & f_line2byte}, 
        {(char *)"localtime", (char)0, (char)0, & f_localtime}, 
        {(char *)"maparg", (char)1, (char)2, & f_maparg}, 
        {(char *)"mapcheck", (char)1, (char)2, & f_mapcheck}, 
        {(char *)"match", (char)2, (char)2, & f_match}, 
        {(char *)"matchend", (char)2, (char)2, & f_matchend}, 
        {(char *)"matchstr", (char)2, (char)2, & f_matchstr}, 
        {(char *)"nr2char", (char)1, (char)1, & f_nr2char}, 
        {(char *)"rename", (char)2, (char)2, & f_rename}, 
        {(char *)"setline", (char)2, (char)2, & f_setline}, 
        {(char *)"strftime", (char)1, (char)2, & f_strftime}, 
        {(char *)"strlen", (char)1, (char)1, & f_strlen}, 
        {(char *)"strpart", (char)3, (char)3, & f_strpart}, 
        {(char *)"strtrans", (char)1, (char)1, & f_strtrans}, 
        {(char *)"substitute", (char)4, (char)4, & f_substitute}, 
        {(char *)"synID", (char)3, (char)3, & f_synID}, 
        {(char *)"synIDattr", (char)2, (char)3, & f_synIDattr}, 
        {(char *)"synIDtrans", (char)1, (char)1, & f_synIDtrans}, 
        {(char *)"system", (char)1, (char)1, & f_system}, 
        {(char *)"tempname", (char)0, (char)0, & f_tempname}, 
        {(char *)"virtcol", (char)1, (char)1, & f_virtcol}, 
        {(char *)"visualmode", (char)0, (char)0, & f_visualmode}, 
        {(char *)"winbufnr", (char)1, (char)1, & f_winbufnr}, 
        {(char *)"winheight", (char)1, (char)1, & f_winheight}, 
        {(char *)"winnr", (char)0, (char)0, & f_winnr}};
static int intidx  =    -1;
char_u *get_function_name(int idx ) 
{ 
  char_u *name___1 ;
  int len___0 ;
  size_t tmp ;
  char *tmp___0 ;

  {
  if (idx == 0) {
    intidx = -1;
  }
  if (intidx < 0) {
    {
    name___1 = get_user_func_name(idx);
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
      {
      tmp = strlen((char const   *)((char *)name___1));
      len___0 = (int )tmp;
      }
      if (len___0 >= 1024) {
        return (name___1);
      }
      {
      strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)name___1));
      *(IObuff + len___0) = (char_u )'(';
      len___0 ++;
      *(IObuff + len___0) = (char_u )'\000';
      }
      return (IObuff);
    }
  }
  intidx ++;
  if (intidx < (int )(sizeof(functions) / sizeof(struct fst ))) {
    {
    tmp___0 = strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )functions[intidx].f_name);
    strcat((char * __restrict  )tmp___0, (char const   * __restrict  )((char *)"("));
    }
    return (IObuff);
  }
  return ((char_u *)((void *)0));
}
}
static int intidx___0  =    -1;
char_u *get_expr_name(int idx ) 
{ 
  char_u *name___1 ;
  char_u *tmp ;

  {
  if (idx == 0) {
    intidx___0 = -1;
  }
  if (intidx___0 < 0) {
    {
    name___1 = get_function_name(idx);
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
      return (name___1);
    }
  }
  {
  intidx___0 ++;
  tmp = get_user_var_name(intidx___0);
  }
  return (tmp);
}
}
static int find_internal_func(char_u *name___1 ) 
{ 
  int first___0 ;
  int last ;
  int cmp ;
  int x___0 ;

  {
  first___0 = 0;
  last = (int )(sizeof(functions) / sizeof(struct fst )) - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (first___0 <= last)) {
      goto while_break;
    }
    {
    x___0 = (int )((unsigned int )first___0 + ((unsigned int )(last - first___0) >> 1));
    cmp = strcmp((char const   *)((char *)name___1), (char const   *)functions[x___0].f_name);
    }
    if (cmp < 0) {
      last = x___0 - 1;
    } else { //Added block
    if (cmp > 0) {
      first___0 = x___0 + 1;
    } else {
      return (x___0);
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static char *errors[4]  = {      (char *)"Invalid arguments for function %s",      (char *)"Unknown function: %s",      (char *)"Too many arguments for function: %s",      (char *)"Not enough arguments for function: %s"};
static int get_func_var(char_u *name___1 , int len___0 , VAR retvar , char_u **arg ,
                        linenr_t firstline , linenr_t lastline , int *doesrange ,
                        int evaluate ) 
{ 
  char_u *argp ;
  int ret ;
  var argvars[20] ;
  int argcount ;
  int error ;
  int i___0 ;
  struct ufunc *fp___0 ;
  int cc___0 ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  ret = 0;
  argcount = 0;
  error = 4;
  cc___0 = (int )*(name___1 + len___0);
  *(name___1 + len___0) = (char_u )'\000';
  *doesrange = 0;
  argp = *arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (argcount < 20)) {
      goto while_break;
    }
    {
    argp = skipwhite(argp + 1);
    }
    if ((int )*argp == 41) {
      goto while_break;
    } else { //Added block
    if ((int )*argp == 44) {
      goto while_break;
    } else { //Added block
    if ((int )*argp == 0) {
      goto while_break;
    }
    }
    }
    {
    tmp = eval1(& argp, & argvars[argcount], evaluate);
    }
    if (tmp == 0) {
      error = 5;
      goto while_break;
    }
    argcount ++;
    if ((int )*argp != 44) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*argp != 41) {
    if (error == 4) {
      error = 0;
    }
  }
  if (evaluate) {
    if (error == 4) {
      {
      retvar->var_type = (char)1;
      error = 1;
      tmp___0 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___0 + (int )*(name___1 + 0)) & 512) {
        {
        i___0 = find_internal_func(name___1);
        }
        if (i___0 >= 0) {
          if (argcount < (int )functions[i___0].f_min_argc) {
            error = 3;
          } else { //Added block
          if (argcount > (int )functions[i___0].f_max_argc) {
            error = 2;
          } else {
            {
            argvars[argcount].var_type = (char)0;
            (*(functions[i___0].f_func))(argvars, retvar);
            error = 4;
            }
          }
          }
        }
      } else {
        {
        fp___0 = find_func(name___1);
        }
        if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
          if (fp___0->flags & 2) {
            *doesrange = 1;
          }
          if (argcount < fp___0->args.ga_len) {
            error = 3;
          } else { //Added block
          if (! fp___0->varargs) {
            if (argcount > fp___0->args.ga_len) {
              error = 2;
            } else {
              goto _L;
            }
          } else {
            _L: 
            {
            save_search_patterns();
            saveRedobuff();
            (fp___0->calls) ++;
            call_func(fp___0, argcount, argvars, retvar, firstline, lastline);
            (fp___0->calls) --;
            restoreRedobuff();
            restore_search_patterns();
            error = 4;
            }
          }
          }
        }
      }
    }
  }
  if (error == 4) {
    ret = 1;
  }
  {
  *arg = skipwhite(argp + 1);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    argcount --;
    if (! (argcount >= 0)) {
      goto while_break___0;
    }
    {
    clear_var(& argvars[argcount]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (error < 4) {
    {
    emsg2((char_u *)errors[error], name___1);
    }
  }
  *(name___1 + len___0) = (char_u )cc___0;
  return (ret);
}
}
static linenr_t get_arg_lnum(VAR argvars , VAR retvar ) 
{ 
  long lnum ;

  {
  {
  lnum = get_var_number(argvars + 0);
  }
  if (lnum == 0L) {
    {
    f_line(argvars, retvar);
    lnum = (long )retvar->var_val.var_number;
    clear_var(retvar);
    }
  }
  return (lnum);
}
}
static void f_append(VAR argvars , VAR retvar ) 
{ 
  long lnum ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  lnum = get_arg_lnum(argvars, retvar);
  retvar->var_val.var_number = 1;
  }
  if (lnum >= 0L) {
    if (lnum <= curbuf->b_ml.ml_line_count) {
      {
      tmp___0 = u_save(lnum, lnum + 1L);
      }
      if (tmp___0 == 1) {
        {
        syn_changed(lnum + 1L);
        mark_adjust(lnum + 1L, (linenr_t )2147483647, 1L, 0L);
        tmp = get_var_string(argvars + 1);
        ml_append(lnum, tmp, (colnr_t )0, 0);
        }
        if (curwin->w_cursor.lnum > lnum) {
          {
          (curwin->w_cursor.lnum) ++;
          changed_line_abv_curs();
          }
        }
        {
        changed();
        update_curbuf(40);
        retvar->var_val.var_number = 0;
        }
      }
    }
  }
  return;
}
}
static void f_argc(VAR argvars , VAR retvar ) 
{ 


  {
  retvar->var_val.var_number = arg_file_count;
  return;
}
}
static void f_argv(VAR argvars , VAR retvar ) 
{ 
  int idx ;
  long tmp ;

  {
  {
  tmp = get_var_number(argvars + 0);
  idx = (int )tmp;
  }
  if (idx >= 0) {
    if (idx < arg_file_count) {
      {
      retvar->var_val.var_string = vim_strsave(*(arg_files + idx));
      }
    } else {
      retvar->var_val.var_string = (char_u *)((void *)0);
    }
  } else {
    retvar->var_val.var_string = (char_u *)((void *)0);
  }
  retvar->var_type = (char)2;
  return;
}
}
static void f_browse(VAR argvars , VAR retvar ) 
{ 


  {
  retvar->var_val.var_string = (char_u *)((void *)0);
  retvar->var_type = (char)2;
  return;
}
}
static BUF *find_buffer(VAR avar ) 
{ 
  BUF *buf___3 ;
  char_u *name___1 ;

  {
  buf___3 = (BUF *)((void *)0);
  if ((int )avar->var_type == 1) {
    {
    buf___3 = buflist_findnr(avar->var_val.var_number);
    }
  } else { //Added block
  if ((unsigned long )avar->var_val.var_string != (unsigned long )((void *)0)) {
    {
    name___1 = FullName_save(avar->var_val.var_string, 1);
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
      {
      buf___3 = buflist_findname(name___1);
      vim_free((void *)name___1);
      }
    }
  }
  }
  return (buf___3);
}
}
static void f_bufexists(VAR argvars , VAR retvar ) 
{ 
  BUF *tmp ;

  {
  {
  tmp = find_buffer(argvars + 0);
  retvar->var_val.var_number = (unsigned long )tmp != (unsigned long )((void *)0);
  }
  return;
}
}
static void f_bufloaded(VAR argvars , VAR retvar ) 
{ 
  BUF *buf___3 ;
  int tmp ;

  {
  {
  buf___3 = find_buffer(argvars + 0);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    if ((unsigned long )buf___3->b_ml.ml_mfp != (unsigned long )((void *)0)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  retvar->var_val.var_number = tmp;
  return;
}
}
static BUF *get_buf_var(VAR avar ) 
{ 
  char_u *name___1 ;
  int save_magic ;
  char_u *save_cpo ;
  BUF *buf___3 ;
  BUF *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  name___1 = avar->var_val.var_string;
  if ((int )avar->var_type == 1) {
    {
    tmp = buflist_findnr(avar->var_val.var_number);
    }
    return (tmp);
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return (curbuf);
  } else { //Added block
  if ((int )*name___1 == 0) {
    return (curbuf);
  }
  }
  if ((int )*(name___1 + 0) == 36) {
    if ((int )*(name___1 + 1) == 0) {
      return (lastbuf);
    }
  }
  {
  save_magic = p_magic;
  p_magic = 1;
  save_cpo = p_cpo;
  p_cpo = (char_u *)"";
  tmp___0 = strlen((char const   *)((char *)name___1));
  tmp___1 = buflist_findpat(name___1, name___1 + tmp___0);
  buf___3 = buflist_findnr(tmp___1);
  p_magic = save_magic;
  p_cpo = save_cpo;
  }
  return (buf___3);
}
}
static void f_bufname(VAR argvars , VAR retvar ) 
{ 
  BUF *buf___3 ;

  {
  {
  emsg_off ++;
  buf___3 = get_buf_var(argvars + 0);
  retvar->var_type = (char)2;
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
      {
      retvar->var_val.var_string = vim_strsave(buf___3->b_fname);
      }
    } else {
      retvar->var_val.var_string = (char_u *)((void *)0);
    }
  } else {
    retvar->var_val.var_string = (char_u *)((void *)0);
  }
  emsg_off --;
  return;
}
}
static void f_bufnr(VAR argvars , VAR retvar ) 
{ 
  BUF *buf___3 ;

  {
  {
  emsg_off ++;
  buf___3 = get_buf_var(argvars + 0);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    retvar->var_val.var_number = buf___3->b_fnum;
  } else {
    retvar->var_val.var_number = -1;
  }
  emsg_off --;
  return;
}
}
static void f_bufwinnr(VAR argvars , VAR retvar ) 
{ 
  WIN *wp ;
  int winnr ;
  BUF *buf___3 ;

  {
  {
  winnr = 0;
  emsg_off ++;
  buf___3 = get_buf_var(argvars + 0);
  wp = firstwin;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    winnr ++;
    if ((unsigned long )wp->w_buffer == (unsigned long )buf___3) {
      goto while_break;
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  if (wp) {
    retvar->var_val.var_number = winnr;
  } else {
    retvar->var_val.var_number = -1;
  }
  emsg_off --;
  return;
}
}
static void f_byte2line(VAR argvars , VAR retvar ) 
{ 
  long boff ;
  long tmp ;
  long tmp___0 ;

  {
  {
  boff = 0L;
  tmp = get_var_number(argvars + 0);
  boff = tmp - 1L;
  }
  if (boff < 0L) {
    retvar->var_val.var_number = -1;
  } else {
    {
    tmp___0 = ml_find_line_or_offset(curbuf, (linenr_t )0, & boff);
    retvar->var_val.var_number = (var_number_type )tmp___0;
    }
  }
  return;
}
}
static void f_char2nr(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  retvar->var_val.var_number = (var_number_type )*(tmp + 0);
  }
  return;
}
}
static void f_col(VAR argvars , VAR retvar ) 
{ 
  colnr_t col ;
  FPOS *fp___0 ;

  {
  {
  col = (colnr_t )0;
  fp___0 = var2fpos(argvars + 0);
  }
  if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
    if (fp___0->lnum > 0L) {
      col = fp___0->col + 1U;
    }
  }
  retvar->var_val.var_number = (var_number_type )col;
  return;
}
}
static void f_confirm(VAR argvars , VAR retvar ) 
{ 
  char_u *message ;
  char_u *buttons ;
  char_u buf___3[30] ;
  char_u buf2[30] ;
  int def ;
  int type ;
  int c ;
  long tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  {
  def = 0;
  type = 0;
  message = get_var_string(argvars + 0);
  buttons = get_var_string_buf(argvars + 1, buf___3);
  }
  if ((int )(argvars + 2)->var_type != 0) {
    {
    tmp = get_var_number(argvars + 2);
    def = (int )tmp;
    }
    if ((int )(argvars + 3)->var_type != 0) {
      {
      tmp___0 = get_var_string_buf(argvars + 3, buf2);
      c = (int )*tmp___0;
      tmp___1 = toupper(c);
      }
      {
      if (tmp___1 == 69) {
        goto case_69;
      }
      if (tmp___1 == 81) {
        goto case_81;
      }
      if (tmp___1 == 73) {
        goto case_73;
      }
      if (tmp___1 == 87) {
        goto case_87;
      }
      if (tmp___1 == 71) {
        goto case_71;
      }
      goto switch_break;
      case_69: /* CIL Label */ 
      type = 1;
      goto switch_break;
      case_81: /* CIL Label */ 
      type = 4;
      goto switch_break;
      case_73: /* CIL Label */ 
      type = 3;
      goto switch_break;
      case_87: /* CIL Label */ 
      type = 2;
      goto switch_break;
      case_71: /* CIL Label */ 
      type = 0;
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
  retvar->var_val.var_number = do_dialog(type, (char_u *)((void *)0), message, buttons,
                                         def);
  }
  return;
}
}
static void f_libcall(VAR argvars , VAR retvar ) 
{ 


  {
  retvar->var_type = (char)2;
  retvar->var_val.var_string = (char_u *)((void *)0);
  return;
}
}
static void f_delete(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  retvar->var_val.var_number = unlink((char const   *)((char *)tmp));
  }
  return;
}
}
static void f_did_filetype(VAR argvars , VAR retvar ) 
{ 


  {
  retvar->var_val.var_number = did_filetype;
  return;
}
}
static void f_escape(VAR argvars , VAR retvar ) 
{ 
  char_u buf___3[30] ;
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  {
  tmp = get_var_string_buf(argvars + 1, buf___3);
  tmp___0 = get_var_string(argvars + 0);
  retvar->var_val.var_string = vim_strsave_escaped(tmp___0, tmp);
  retvar->var_type = (char)2;
  }
  return;
}
}
static void f_exists(VAR argvars , VAR retvar ) 
{ 
  char_u *p___0 ;
  char_u *name___1 ;
  int n ;
  int len___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct ufunc *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
  {
  n = 0;
  p___0 = get_var_string(argvars + 0);
  }
  if ((int )*p___0 == 36) {
    {
    tmp = getenv((char const   *)((char *)(p___0 + 1)));
    }
    if ((unsigned long )((char_u *)tmp) != (unsigned long )((void *)0)) {
      n = 1;
    } else {
      {
      p___0 = expand_env_save(p___0);
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        if ((int )*p___0 != 36) {
          n = 1;
        }
      }
      {
      vim_free((void *)p___0);
      }
    }
  } else { //Added block
  if ((int )*p___0 == 38) {
    {
    tmp___0 = get_option_var(& p___0, (VAR )((void *)0), 1);
    n = tmp___0 == 1;
    }
  } else { //Added block
  if ((int )*p___0 == 42) {
    {
    p___0 ++;
    tmp___4 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___4 + (int )*p___0) & 512) {
      {
      tmp___1 = find_internal_func(p___0);
      n = tmp___1 >= 0;
      }
    } else {
      {
      tmp___3 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___3 + (int )*p___0) & 256) {
        {
        tmp___2 = find_func(p___0);
        n = (unsigned long )tmp___2 != (unsigned long )((void *)0);
        }
      }
    }
  } else {
    {
    name___1 = p___0;
    len___0 = get_id_len(& p___0);
    }
    if (len___0 != 0) {
      {
      tmp___5 = get_var_var(name___1, len___0, (VAR )((void *)0));
      n = tmp___5 == 1;
      }
    }
  }
  }
  }
  retvar->var_val.var_number = n;
  return;
}
}
static void f_expand(VAR argvars , VAR retvar ) 
{ 
  char_u *s ;
  int len___0 ;
  char_u *errormsg ;
  int flags___0 ;
  long tmp ;

  {
  {
  flags___0 = 68;
  retvar->var_type = (char)2;
  s = get_var_string(argvars + 0);
  }
  if ((int )*s == 37) {
    {
    emsg_off ++;
    retvar->var_val.var_string = eval_vars(s, & len___0, (linenr_t *)((void *)0),
                                           & errormsg, s);
    emsg_off --;
    }
  } else { //Added block
  if ((int )*s == 35) {
    {
    emsg_off ++;
    retvar->var_val.var_string = eval_vars(s, & len___0, (linenr_t *)((void *)0),
                                           & errormsg, s);
    emsg_off --;
    }
  } else { //Added block
  if ((int )*s == 60) {
    {
    emsg_off ++;
    retvar->var_val.var_string = eval_vars(s, & len___0, (linenr_t *)((void *)0),
                                           & errormsg, s);
    emsg_off --;
    }
  } else {
    if ((int )(argvars + 1)->var_type != 0) {
      {
      tmp = get_var_number(argvars + 1);
      }
      if (tmp) {
        flags___0 |= 32;
      }
    }
    {
    expand_context = 2;
    retvar->var_val.var_string = ExpandOne(s, (char_u *)((void *)0), flags___0, 6);
    }
  }
  }
  }
  return;
}
}
static void f_filereadable(VAR argvars , VAR retvar ) 
{ 
  FILE *fd ;
  char_u *p___0 ;
  int n ;
  int tmp ;

  {
  {
  p___0 = get_var_string(argvars + 0);
  }
  if (*p___0) {
    {
    tmp = mch_isdir(p___0);
    }
    if (tmp) {
      n = 0;
    } else {
      {
      fd = fopen((char const   * __restrict  )((char *)p___0), (char const   * __restrict  )"r");
      }
      if ((unsigned long )fd != (unsigned long )((void *)0)) {
        {
        n = 1;
        fclose(fd);
        }
      } else {
        n = 0;
      }
    }
  } else {
    n = 0;
  }
  retvar->var_val.var_number = n;
  return;
}
}
static void f_fnamemodify(VAR argvars , VAR retvar ) 
{ 
  char_u *fname ;
  char_u *mods ;
  int usedlen ;
  int len___0 ;
  char_u *fbuf ;
  char_u buf___3[30] ;
  size_t tmp ;

  {
  {
  usedlen = 0;
  fbuf = (char_u *)((void *)0);
  fname = get_var_string(argvars + 0);
  mods = get_var_string_buf(argvars + 1, buf___3);
  tmp = strlen((char const   *)((char *)fname));
  len___0 = (int )tmp;
  modify_fname(mods, & usedlen, & fname, & fbuf, & len___0);
  retvar->var_type = (char)2;
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    retvar->var_val.var_string = (char_u *)((void *)0);
  } else {
    {
    retvar->var_val.var_string = vim_strnsave(fname, len___0);
    }
  }
  {
  vim_free((void *)fbuf);
  }
  return;
}
}
static void f_getcwd(VAR argvars , VAR retvar ) 
{ 
  char_u cwd[1024] ;
  int tmp ;

  {
  {
  retvar->var_type = (char)2;
  tmp = mch_dirname(cwd, 1024);
  }
  if (tmp == 0) {
    retvar->var_val.var_string = (char_u *)((void *)0);
  } else {
    {
    retvar->var_val.var_string = vim_strsave(cwd);
    }
  }
  return;
}
}
static void f_getftime(VAR argvars , VAR retvar ) 
{ 
  char_u *fname ;
  struct stat st ;
  int tmp ;

  {
  {
  fname = get_var_string(argvars + 0);
  tmp = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
  }
  if (tmp >= 0) {
    retvar->var_val.var_number = (var_number_type )st.st_mtim.tv_sec;
  } else {
    retvar->var_val.var_number = -1;
  }
  return;
}
}
static void f_getline(VAR argvars , VAR retvar ) 
{ 
  linenr_t lnum ;
  char_u *p___0 ;

  {
  {
  lnum = get_arg_lnum(argvars, retvar);
  }
  if (lnum >= 1L) {
    if (lnum <= curbuf->b_ml.ml_line_count) {
      {
      p___0 = ml_get(lnum);
      }
    } else {
      p___0 = (char_u *)"";
    }
  } else {
    p___0 = (char_u *)"";
  }
  {
  retvar->var_type = (char)2;
  retvar->var_val.var_string = vim_strsave(p___0);
  }
  return;
}
}
static void f_getwinposx(VAR argvars , VAR retvar ) 
{ 


  {
  retvar->var_val.var_number = -1;
  return;
}
}
static void f_getwinposy(VAR argvars , VAR retvar ) 
{ 


  {
  retvar->var_val.var_number = -1;
  return;
}
}
static void f_glob(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;

  {
  {
  expand_context = 2;
  retvar->var_type = (char)2;
  tmp = get_var_string(argvars + 0);
  retvar->var_val.var_string = ExpandOne(tmp, (char_u *)((void *)0), 68, 6);
  }
  return;
}
}
static char *has_list[49]  = 
  {      (char *)"unix",      (char *)"fname_case",      (char *)"autocmd",      (char *)"builtin_terms", 
        (char *)"byte_offset",      (char *)"cindent",      (char *)"clipboard",      (char *)"cmdline_compl", 
        (char *)"comments",      (char *)"cryptv",      (char *)"dialog_con",      (char *)"digraphs", 
        (char *)"eval",      (char *)"ex_extra",      (char *)"extra_search",      (char *)"file_in_path", 
        (char *)"find_in_path",      (char *)"fork",      (char *)"insert_expand",      (char *)"linebreak", 
        (char *)"lispindent",      (char *)"menu",      (char *)"mksession",      (char *)"modify_fname", 
        (char *)"mouse",      (char *)"mouse_xterm",      (char *)"quickfix",      (char *)"scrollbind", 
        (char *)"showcmd",      (char *)"cmdline_info",      (char *)"smartindent",      (char *)"statusline", 
        (char *)"syntax",      (char *)"tag_binary",      (char *)"tag_old_static",      (char *)"terminfo", 
        (char *)"textobjects",      (char *)"tgetent",      (char *)"title",      (char *)"user-commands", 
        (char *)"user_commands",      (char *)"viminfo",      (char *)"visualextra",      (char *)"wildignore", 
        (char *)"wildmenu",      (char *)"writebackup",      (char *)"xterm_clipboard",      (char *)"X11", 
        (char *)((void *)0)};
static void f_has(VAR argvars , VAR retvar ) 
{ 
  int i___0 ;
  char_u *name___1 ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  n = 0;
  name___1 = get_var_string(argvars + 0);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )has_list[i___0] != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = strcasecmp((char const   *)((char *)name___1), (char const   *)has_list[i___0]);
    }
    if (tmp == 0) {
      n = 1;
      goto while_break;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (n == 0) {
    {
    tmp___1 = strcasecmp((char const   *)((char *)name___1), (char const   *)((char *)"syntax_items"));
    }
    if (tmp___1 == 0) {
      {
      n = syntax_present(curbuf);
      }
    } else {
      {
      tmp___0 = strcasecmp((char const   *)((char *)name___1), (char const   *)((char *)"vim_starting"));
      }
      if (tmp___0 == 0) {
        n = starting != 0;
      }
    }
  }
  retvar->var_val.var_number = n;
  return;
}
}
static void f_histadd(VAR argvars , VAR retvar ) 
{ 
  int histype ;
  char_u *str___1 ;
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  histype = get_histtype(tmp);
  }
  if (histype >= 0) {
    {
    str___1 = get_var_string(argvars + 1);
    }
    if ((int )*str___1 != 0) {
      {
      add_to_history(histype, str___1, 0);
      retvar->var_val.var_number = 1;
      }
      return;
    }
  }
  retvar->var_val.var_number = 0;
  return;
}
}
static void f_histdel(VAR argvars , VAR retvar ) 
{ 
  int n ;
  char_u *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  int tmp___6 ;

  {
  if ((int )(argvars + 1)->var_type == 0) {
    {
    tmp = get_var_string(argvars + 0);
    tmp___0 = get_histtype(tmp);
    n = clr_history(tmp___0);
    }
  } else { //Added block
  if ((int )(argvars + 1)->var_type == 1) {
    {
    tmp___1 = get_var_number(argvars + 1);
    tmp___2 = get_var_string(argvars + 0);
    tmp___3 = get_histtype(tmp___2);
    n = del_history_idx(tmp___3, (int )tmp___1);
    }
  } else {
    {
    tmp___4 = get_var_string(argvars + 1);
    tmp___5 = get_var_string(argvars + 0);
    tmp___6 = get_histtype(tmp___5);
    n = del_history_entry(tmp___6, tmp___4);
    }
  }
  }
  retvar->var_val.var_number = n;
  return;
}
}
static void f_histget(VAR argvars , VAR retvar ) 
{ 
  int type ;
  int idx ;
  char_u *tmp ;
  long tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  tmp = get_var_string(argvars + 0);
  type = get_histtype(tmp);
  retvar->var_type = (char)2;
  }
  if ((int )(argvars + 1)->var_type == 0) {
    {
    idx = get_history_idx(type);
    }
  } else {
    {
    tmp___0 = get_var_number(argvars + 1);
    idx = (int )tmp___0;
    }
  }
  {
  tmp___1 = get_history_entry(type, idx);
  retvar->var_val.var_string = vim_strsave(tmp___1);
  }
  return;
}
}
static void f_histnr(VAR argvars , VAR retvar ) 
{ 
  int i___0 ;
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  i___0 = get_histtype(tmp);
  }
  if (i___0 >= 0) {
    if (i___0 <= 3) {
      {
      i___0 = get_history_idx(i___0);
      }
    } else {
      i___0 = -1;
    }
  } else {
    i___0 = -1;
  }
  retvar->var_val.var_number = i___0;
  return;
}
}
static void f_hlexists(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  retvar->var_val.var_number = highlight_exists(tmp);
  }
  return;
}
}
static void f_hlID(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  retvar->var_val.var_number = syn_name2id(tmp);
  }
  return;
}
}
static void f_hostname(VAR argvars , VAR retvar ) 
{ 
  char_u hostname[256] ;

  {
  {
  mch_get_host_name(hostname, 256);
  retvar->var_type = (char)2;
  retvar->var_val.var_string = vim_strsave(hostname);
  }
  return;
}
}
static void f_input(VAR argvars , VAR retvar ) 
{ 
  char_u *prompt ;
  char_u *tmp ;
  char_u *p___0 ;
  int c ;

  {
  {
  tmp = get_var_string(argvars + 0);
  prompt = tmp;
  p___0 = (char_u *)((void *)0);
  retvar->var_type = (char)2;
  }
  if ((unsigned long )prompt != (unsigned long )((void *)0)) {
    {
    p___0 = vim_strrchr(prompt, '\n');
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      p___0 = prompt;
    } else {
      {
      p___0 ++;
      c = (int )*p___0;
      *p___0 = (char_u )'\000';
      msg_start();
      msg_clr_eos();
      msg_puts_attr(prompt, echo_attr);
      msg_didout = 0;
      msg_starthere();
      *p___0 = (char_u )c;
      }
    }
    cmdline_row = msg_row;
  }
  {
  retvar->var_val.var_string = getcmdline_prompt('@', p___0, echo_attr);
  need_wait_return = 0;
  msg_didout = 0;
  }
  return;
}
}
static void f_isdirectory(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  retvar->var_val.var_number = mch_isdir(tmp);
  }
  return;
}
}
static void f_last_buffer_nr(VAR argvars , VAR retvar ) 
{ 
  int n ;
  BUF *buf___3 ;

  {
  n = 0;
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (n < buf___3->b_fnum) {
      n = buf___3->b_fnum;
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  retvar->var_val.var_number = n;
  return;
}
}
static void f_line(VAR argvars , VAR retvar ) 
{ 
  linenr_t lnum ;
  FPOS *fp___0 ;
  char_u *tmp ;

  {
  {
  lnum = (linenr_t )0;
  fp___0 = var2fpos(argvars + 0);
  }
  if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
    lnum = fp___0->lnum;
  } else {
    {
    tmp = get_var_string(argvars + 0);
    }
    if ((int )*(tmp + 0) == 36) {
      lnum = curbuf->b_ml.ml_line_count;
    }
  }
  retvar->var_val.var_number = (var_number_type )lnum;
  return;
}
}
static void f_line2byte(VAR argvars , VAR retvar ) 
{ 
  linenr_t lnum ;
  long tmp ;

  {
  {
  lnum = get_arg_lnum(argvars, retvar);
  }
  if (lnum < 1L) {
    retvar->var_val.var_number = -1;
  } else { //Added block
  if (lnum > curbuf->b_ml.ml_line_count + 1L) {
    retvar->var_val.var_number = -1;
  } else {
    {
    tmp = ml_find_line_or_offset(curbuf, lnum, (long *)((void *)0));
    retvar->var_val.var_number = (var_number_type )tmp;
    }
  }
  }
  if (retvar->var_val.var_number >= 0) {
    (retvar->var_val.var_number) ++;
  }
  return;
}
}
static void f_localtime(VAR argvars , VAR retvar ) 
{ 
  time_t tmp ;

  {
  {
  tmp = time((time_t *)((void *)0));
  retvar->var_val.var_number = (var_number_type )tmp;
  }
  return;
}
}
static void f_maparg(VAR argvars , VAR retvar ) 
{ 


  {
  {
  get_maparg(argvars, retvar, 1);
  }
  return;
}
}
static void f_mapcheck(VAR argvars , VAR retvar ) 
{ 


  {
  {
  get_maparg(argvars, retvar, 0);
  }
  return;
}
}
static void get_maparg(VAR argvars , VAR retvar , int exact ) 
{ 
  char_u *keys___0 ;
  char_u *which ;
  char_u buf___3[30] ;
  char_u *keys_buf ;
  char_u *rhs ;
  int mode ;
  struct growarray ga ;
  char_u *tmp ;

  {
  {
  keys_buf = (char_u *)((void *)0);
  retvar->var_type = (char)2;
  retvar->var_val.var_string = (char_u *)((void *)0);
  keys___0 = get_var_string(argvars + 0);
  }
  if ((int )*keys___0 == 0) {
    return;
  }
  if ((int )(argvars + 1)->var_type != 0) {
    {
    which = get_var_string_buf(argvars + 1, buf___3);
    }
  } else {
    which = (char_u *)"";
  }
  {
  mode = get_map_mode(& which, 0);
  keys___0 = replace_termcodes(keys___0, & keys_buf, 1, 1);
  rhs = check_map(keys___0, mode, exact);
  vim_free((void *)keys_buf);
  }
  if ((unsigned long )rhs != (unsigned long )((void *)0)) {
    {
    ga_init(& ga);
    ga.ga_itemsize = 1;
    ga.ga_growsize = 40;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((int )*rhs != 0)) {
        goto while_break;
      }
      {
      tmp = str2special(& rhs, 0);
      ga_concat(& ga, tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    ga_append(& ga, '\000');
    retvar->var_val.var_string = (char_u *)ga.ga_data;
    }
  }
  return;
}
}
static void f_match(VAR argvars , VAR retvar ) 
{ 


  {
  {
  f_some_match(argvars, retvar, 1);
  }
  return;
}
}
static void f_matchend(VAR argvars , VAR retvar ) 
{ 


  {
  {
  f_some_match(argvars, retvar, 0);
  }
  return;
}
}
static void f_matchstr(VAR argvars , VAR retvar ) 
{ 


  {
  {
  f_some_match(argvars, retvar, 2);
  }
  return;
}
}
static void f_some_match(VAR argvars , VAR retvar , int type ) 
{ 
  char_u *str___1 ;
  char_u *pat ;
  vim_regexp *prog ;
  char_u patbuf[30] ;
  char_u *save_cpo ;
  int tmp ;

  {
  {
  save_cpo = p_cpo;
  p_cpo = (char_u *)"";
  str___1 = get_var_string(argvars + 0);
  pat = get_var_string_buf(argvars + 1, patbuf);
  }
  if (type == 2) {
    retvar->var_type = (char)2;
    retvar->var_val.var_string = (char_u *)((void *)0);
  } else {
    retvar->var_val.var_number = -1;
  }
  {
  prog = vim_regcomp(pat, 1);
  }
  if ((unsigned long )prog != (unsigned long )((void *)0)) {
    {
    reg_ic = p_ic;
    tmp = vim_regexec(prog, str___1, 1);
    }
    if (tmp) {
      if (type == 2) {
        {
        retvar->var_val.var_string = vim_strnsave(prog->startp[0], (int )(prog->endp[0] - prog->startp[0]));
        }
      } else { //Added block
      if (type) {
        retvar->var_val.var_number = (var_number_type )(prog->startp[0] - str___1);
      } else {
        retvar->var_val.var_number = (var_number_type )(prog->endp[0] - str___1);
      }
      }
    }
    {
    vim_free((void *)prog);
    }
  }
  p_cpo = save_cpo;
  return;
}
}
static void f_nr2char(VAR argvars , VAR retvar ) 
{ 
  char_u buf___3[2] ;
  long tmp ;

  {
  {
  tmp = get_var_number(argvars + 0);
  buf___3[0] = (char_u )tmp;
  retvar->var_type = (char)2;
  retvar->var_val.var_string = vim_strnsave(buf___3, 1);
  }
  return;
}
}
static void f_rename(VAR argvars , VAR retvar ) 
{ 
  char_u buf___3[30] ;
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  {
  tmp = get_var_string_buf(argvars + 1, buf___3);
  tmp___0 = get_var_string(argvars + 0);
  retvar->var_val.var_number = vim_rename(tmp___0, tmp);
  }
  return;
}
}
static void f_setline(VAR argvars , VAR retvar ) 
{ 
  linenr_t lnum ;
  char_u *line ;
  int tmp ;
  int tmp___0 ;

  {
  {
  lnum = get_arg_lnum(argvars, retvar);
  line = get_var_string(argvars + 1);
  retvar->var_val.var_number = 1;
  }
  if (lnum >= 1L) {
    if (lnum <= curbuf->b_ml.ml_line_count) {
      {
      tmp = u_savesub(lnum);
      }
      if (tmp == 1) {
        {
        tmp___0 = ml_replace(lnum, line, 1);
        }
        if (tmp___0 == 1) {
          {
          changed();
          changed_cline_bef_curs();
          approximate_botline();
          check_cursor_col();
          syn_changed(lnum);
          redraw_curbuf_later(40);
          retvar->var_val.var_number = 0;
          }
        }
      }
    }
  }
  return;
}
}
static void f_strftime(VAR argvars , VAR retvar ) 
{ 
  char_u result_buf[80] ;
  struct tm *curtime ;
  time_t seconds ;
  char_u *p___0 ;
  long tmp ;

  {
  {
  p___0 = get_var_string(argvars + 0);
  }
  if ((int )(argvars + 1)->var_type == 0) {
    {
    seconds = time((time_t *)((void *)0));
    }
  } else {
    {
    tmp = get_var_number(argvars + 1);
    seconds = tmp;
    }
  }
  {
  curtime = localtime((time_t const   *)(& seconds));
  strftime((char * __restrict  )((char *)(result_buf)), (size_t )80, (char const   * __restrict  )((char *)p___0),
           (struct tm  const  * __restrict  )curtime);
  retvar->var_type = (char)2;
  retvar->var_val.var_string = vim_strsave(result_buf);
  }
  return;
}
}
static void f_strlen(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = get_var_string(argvars + 0);
  tmp___0 = strlen((char const   *)((char *)tmp));
  retvar->var_val.var_number = (var_number_type )tmp___0;
  }
  return;
}
}
static void f_strpart(VAR argvars , VAR retvar ) 
{ 
  char_u *p___0 ;
  int n ;
  int len___0 ;
  int slen ;
  long tmp ;
  long tmp___0 ;
  size_t tmp___1 ;

  {
  {
  p___0 = get_var_string(argvars + 0);
  tmp = get_var_number(argvars + 1);
  n = (int )tmp;
  tmp___0 = get_var_number(argvars + 2);
  len___0 = (int )tmp___0;
  tmp___1 = strlen((char const   *)((char *)p___0));
  slen = (int )tmp___1;
  }
  if (n < 0) {
    len___0 += n;
    n = 0;
  } else { //Added block
  if (n > slen) {
    n = slen;
  }
  }
  if (len___0 < 0) {
    len___0 = 0;
  } else { //Added block
  if (n + len___0 > slen) {
    len___0 = slen - n;
  }
  }
  {
  retvar->var_type = (char)2;
  retvar->var_val.var_string = vim_strnsave(p___0 + n, len___0);
  }
  return;
}
}
static void f_strtrans(VAR argvars , VAR retvar ) 
{ 
  char_u *tmp ;

  {
  {
  retvar->var_type = (char)2;
  tmp = get_var_string(argvars + 0);
  retvar->var_val.var_string = transstr(tmp);
  }
  return;
}
}
static void f_synID(VAR argvars , VAR retvar ) 
{ 
  int id ;
  long line ;
  long col ;
  int trans___0 ;
  long tmp ;
  long tmp___0 ;
  char_u *tmp___1 ;
  size_t tmp___2 ;

  {
  {
  id = 0;
  line = get_arg_lnum(argvars, retvar);
  tmp = get_var_number(argvars + 1);
  col = tmp - 1L;
  tmp___0 = get_var_number(argvars + 2);
  trans___0 = (int )tmp___0;
  }
  if (line >= 1L) {
    if (line <= curbuf->b_ml.ml_line_count) {
      if (col >= 0L) {
        {
        tmp___1 = ml_get(line);
        tmp___2 = strlen((char const   *)((char *)tmp___1));
        }
        if (col < (long )tmp___2) {
          {
          id = syn_get_id(line, col, trans___0);
          }
        }
      }
    }
  }
  retvar->var_val.var_number = id;
  return;
}
}
static void f_synIDattr(VAR argvars , VAR retvar ) 
{ 
  char_u *p___0 ;
  int id ;
  char_u *what ;
  char_u *mode ;
  char_u modebuf[30] ;
  int modec ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  p___0 = (char_u *)((void *)0);
  tmp = get_var_number(argvars + 0);
  id = (int )tmp;
  what = get_var_string(argvars + 1);
  }
  if ((int )(argvars + 2)->var_type != 0) {
    {
    mode = get_var_string_buf(argvars + 2, modebuf);
    modec = tolower((int )*(mode + 0));
    }
    if (modec != 116) {
      if (modec != 99) {
        modec = 0;
      }
    }
  } else { //Added block
  if (*(term_strings[34])) {
    modec = 'c';
  } else {
    modec = 't';
  }
  }
  {
  tmp___0 = tolower((int )*(what + 0));
  }
  {
  if (tmp___0 == 98) {
    goto case_98;
  }
  if (tmp___0 == 102) {
    goto case_102;
  }
  if (tmp___0 == 105) {
    goto case_105;
  }
  if (tmp___0 == 110) {
    goto case_110;
  }
  if (tmp___0 == 114) {
    goto case_114;
  }
  if (tmp___0 == 115) {
    goto case_115;
  }
  if (tmp___0 == 117) {
    goto case_117;
  }
  goto switch_break;
  case_98: /* CIL Label */ 
  {
  tmp___1 = tolower((int )*(what + 1));
  }
  if (tmp___1 == 103) {
    {
    p___0 = highlight_color(id, what, modec);
    }
  } else {
    {
    p___0 = highlight_has_attr(id, 2, modec);
    }
  }
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  p___0 = highlight_color(id, what, modec);
  }
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  tmp___2 = tolower((int )*(what + 1));
  }
  if (tmp___2 == 110) {
    {
    p___0 = highlight_has_attr(id, 1, modec);
    }
  } else {
    {
    p___0 = highlight_has_attr(id, 4, modec);
    }
  }
  goto switch_break;
  case_110: /* CIL Label */ 
  {
  p___0 = get_highlight_name(id - 1);
  }
  goto switch_break;
  case_114: /* CIL Label */ 
  {
  p___0 = highlight_has_attr(id, 1, modec);
  }
  goto switch_break;
  case_115: /* CIL Label */ 
  {
  p___0 = highlight_has_attr(id, 16, modec);
  }
  goto switch_break;
  case_117: /* CIL Label */ 
  {
  p___0 = highlight_has_attr(id, 8, modec);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    p___0 = vim_strsave(p___0);
    }
  }
  retvar->var_type = (char)2;
  retvar->var_val.var_string = p___0;
  return;
}
}
static void f_synIDtrans(VAR argvars , VAR retvar ) 
{ 
  int id ;
  long tmp ;

  {
  {
  tmp = get_var_number(argvars + 0);
  id = (int )tmp;
  }
  if (id > 0) {
    {
    id = syn_get_final_id(id);
    }
  } else {
    id = 0;
  }
  retvar->var_val.var_number = id;
  return;
}
}
static void f_system(VAR argvars , VAR retvar ) 
{ 
  char_u *p___0 ;
  char_u *tmp ;

  {
  {
  tmp = get_var_string(argvars + 0);
  p___0 = get_cmd_output(tmp, 16);
  retvar->var_type = (char)2;
  retvar->var_val.var_string = p___0;
  }
  return;
}
}
static void f_substitute(VAR argvars , VAR retvar ) 
{ 
  char_u patbuf[30] ;
  char_u subbuf[30] ;
  char_u flagsbuf[30] ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;

  {
  {
  retvar->var_type = (char)2;
  tmp = get_var_string_buf(argvars + 3, flagsbuf);
  tmp___0 = get_var_string_buf(argvars + 2, subbuf);
  tmp___1 = get_var_string_buf(argvars + 1, patbuf);
  tmp___2 = get_var_string(argvars + 0);
  retvar->var_val.var_string = do_string_sub(tmp___2, tmp___1, tmp___0, tmp);
  }
  return;
}
}
static int x  =    'A';
static void f_tempname(VAR argvars , VAR retvar ) 
{ 


  {
  {
  retvar->var_type = (char)2;
  retvar->var_val.var_string = vim_tempname(x);
  }
  if (x == 90) {
    x = 'A';
  } else {
    x ++;
  }
  return;
}
}
static void f_virtcol(VAR argvars , VAR retvar ) 
{ 
  colnr_t vcol ;
  FPOS *fp___0 ;

  {
  {
  vcol = (colnr_t )0;
  fp___0 = var2fpos(argvars + 0);
  }
  if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
    {
    getvcol(curwin, fp___0, (colnr_t *)((void *)0), (colnr_t *)((void *)0), & vcol);
    vcol ++;
    }
  }
  retvar->var_val.var_number = (var_number_type )vcol;
  return;
}
}
static void f_visualmode(VAR argvars , VAR retvar ) 
{ 
  char_u str___1[2] ;

  {
  {
  retvar->var_type = (char)2;
  str___1[0] = (char_u )curbuf->b_visual_mode;
  str___1[1] = (char_u )'\000';
  retvar->var_val.var_string = vim_strsave(str___1);
  }
  return;
}
}
static void f_winbufnr(VAR argvars , VAR retvar ) 
{ 
  WIN *wp ;

  {
  {
  wp = find_win_by_nr(argvars + 0);
  }
  if ((unsigned long )wp == (unsigned long )((void *)0)) {
    retvar->var_val.var_number = -1;
  } else {
    retvar->var_val.var_number = (wp->w_buffer)->b_fnum;
  }
  return;
}
}
static void f_winheight(VAR argvars , VAR retvar ) 
{ 
  WIN *wp ;

  {
  {
  wp = find_win_by_nr(argvars + 0);
  }
  if ((unsigned long )wp == (unsigned long )((void *)0)) {
    retvar->var_val.var_number = -1;
  } else {
    retvar->var_val.var_number = wp->w_height;
  }
  return;
}
}
static void f_winnr(VAR argvars , VAR retvar ) 
{ 
  int nr ;
  WIN *wp ;

  {
  nr = 1;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )curwin)) {
      goto while_break;
    }
    nr ++;
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  retvar->var_val.var_number = nr;
  return;
}
}
static WIN *find_win_by_nr(VAR vp ) 
{ 
  WIN *wp ;
  int nr ;
  long tmp ;

  {
  {
  tmp = get_var_number(vp);
  nr = (int )tmp;
  }
  if (nr == 0) {
    return (curwin);
  }
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    nr --;
    if (nr <= 0) {
      goto while_break;
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (wp);
}
}
static FPOS *var2fpos(VAR varp ) 
{ 
  char_u *name___1 ;
  FPOS *tmp ;

  {
  {
  name___1 = get_var_string(varp);
  }
  if ((int )*(name___1 + 0) == 46) {
    return (& curwin->w_cursor);
  }
  if ((int )*(name___1 + 0) == 39) {
    {
    tmp = getmark((int )*(name___1 + 1), 0);
    }
    return (tmp);
  }
  return ((FPOS *)((void *)0));
}
}
static int get_env_len(char_u **arg ) 
{ 
  char_u *p___0 ;
  int len___0 ;
  int tmp ;

  {
  p___0 = *arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = vim_isIDc((int )*p___0);
    }
    if (! tmp) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )p___0 == (unsigned long )*arg) {
    return (0);
  }
  len___0 = (int )(p___0 - *arg);
  *arg = p___0;
  return (len___0);
}
}
static int get_id_len(char_u **arg ) 
{ 
  char_u *p___0 ;
  int len___0 ;
  int tmp ;

  {
  p___0 = *arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = eval_isnamec((int )*p___0);
    }
    if (! tmp) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )p___0 == (unsigned long )*arg) {
    return (0);
  }
  {
  len___0 = (int )(p___0 - *arg);
  *arg = skipwhite(p___0);
  }
  return (len___0);
}
}
static int eval_isnamec(int c ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + c) & 1024) {
    tmp___1 = 1;
  } else {
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + c) & 2048) {
      tmp___1 = 1;
    } else { //Added block
    if (c == 95) {
      tmp___1 = 1;
    } else { //Added block
    if (c == 58) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    }
    }
  }
  return (tmp___1);
}
}
static int find_vim_var(char_u *name___1 , int len___0 ) 
{ 
  char_u *vname ;
  int vlen ;
  int i___0 ;
  int tmp ;

  {
  if ((int )*(name___1 + 0) == 118) {
    if ((int )*(name___1 + 1) == 58) {
      vname = name___1 + 2;
      vlen = len___0 - 2;
    } else {
      vname = name___1;
      vlen = len___0;
    }
  } else {
    vname = name___1;
    vlen = len___0;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 8)) {
      goto while_break;
    }
    if (vlen == vimvars[i___0].len) {
      {
      tmp = strcmp((char const   *)((char *)vname), (char const   *)vimvars[i___0].name);
      }
      if (tmp == 0) {
        if ((int )vimvars[i___0].flags & 1) {
          return (i___0);
        } else { //Added block
        if ((unsigned long )vname != (unsigned long )name___1) {
          return (i___0);
        }
        }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
void set_vim_var_nr(int idx , long val ) 
{ 


  {
  vimvars[idx].val = (char_u *)val;
  return;
}
}
void set_vim_var_string(int idx , char_u *val ) 
{ 


  {
  {
  vim_free((void *)vimvars[idx].val);
  }
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    vimvars[idx].val = (char_u *)((void *)0);
  } else {
    {
    vimvars[idx].val = vim_strsave(val);
    }
  }
  return;
}
}
static int get_var_var(char_u *name___1 , int len___0 , VAR retvar ) 
{ 
  int ret ;
  int type ;
  long number ;
  char_u *string___0 ;
  VAR v ;
  int cc___0 ;
  int i___0 ;

  {
  {
  ret = 1;
  type = 0;
  number = 1L;
  string___0 = (char_u *)((void *)0);
  cc___0 = (int )*(name___1 + len___0);
  *(name___1 + len___0) = (char_u )'\000';
  i___0 = find_vim_var(name___1, len___0);
  }
  if (i___0 >= 0) {
    type = (int )vimvars[i___0].type;
    number = (long )vimvars[i___0].val;
    string___0 = vimvars[i___0].val;
  } else {
    {
    v = find_var(name___1, 0);
    }
    if ((unsigned long )v != (unsigned long )((void *)0)) {
      type = (int )v->var_type;
      number = (long )v->var_val.var_number;
      string___0 = v->var_val.var_string;
    }
  }
  if (type == 0) {
    if ((unsigned long )retvar != (unsigned long )((void *)0)) {
      {
      emsg2((char_u *)"Undefined variable: %s", name___1);
      }
    }
    ret = 0;
  } else { //Added block
  if ((unsigned long )retvar != (unsigned long )((void *)0)) {
    retvar->var_type = (char )type;
    if (type == 1) {
      retvar->var_val.var_number = (var_number_type )number;
    } else { //Added block
    if (type == 2) {
      if ((unsigned long )string___0 != (unsigned long )((void *)0)) {
        {
        string___0 = vim_strsave(string___0);
        }
      }
      retvar->var_val.var_string = string___0;
    }
    }
  }
  }
  *(name___1 + len___0) = (char_u )cc___0;
  return (ret);
}
}
static VAR alloc_var(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = alloc_clear((unsigned int )sizeof(var ));
  }
  return ((VAR )tmp);
}
}
static VAR alloc_string_var(char_u *s ) 
{ 
  VAR retvar ;

  {
  {
  retvar = alloc_var();
  }
  if ((unsigned long )retvar != (unsigned long )((void *)0)) {
    retvar->var_type = (char)2;
    retvar->var_val.var_string = s;
  } else {
    {
    vim_free((void *)s);
    }
  }
  return (retvar);
}
}
static void free_var(VAR varp ) 
{ 


  {
  if ((unsigned long )varp != (unsigned long )((void *)0)) {
    if ((int )varp->var_type == 2) {
      {
      vim_free((void *)varp->var_val.var_string);
      }
    }
    {
    vim_free((void *)varp->var_name);
    vim_free((void *)varp);
    }
  }
  return;
}
}
static void clear_var(VAR varp ) 
{ 


  {
  if ((unsigned long )varp != (unsigned long )((void *)0)) {
    if ((int )varp->var_type == 2) {
      {
      vim_free((void *)varp->var_val.var_string);
      varp->var_val.var_string = (char_u *)((void *)0);
      }
    } else {
      varp->var_val.var_number = 0;
    }
  }
  return;
}
}
static long get_var_number(VAR varp ) 
{ 
  long n ;

  {
  if ((int )varp->var_type == 1) {
    return ((long )varp->var_val.var_number);
  } else { //Added block
  if ((int )varp->var_type == 0) {
    return (0L);
  } else { //Added block
  if ((unsigned long )varp->var_val.var_string == (unsigned long )((void *)0)) {
    return (0L);
  } else {
    {
    vim_str2nr(varp->var_val.var_string, (int *)((void *)0), (int *)((void *)0), 1,
               1, & n, (unsigned long *)((void *)0));
    }
    return (n);
  }
  }
  }
}
}
static char_u mybuf[30]  ;
static char_u *get_var_string(VAR varp ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_var_string_buf(varp, mybuf);
  }
  return (tmp);
}
}
static char_u *get_var_string_buf(VAR varp , char_u *buf___3 ) 
{ 


  {
  if ((int )varp->var_type == 1) {
    {
    sprintf((char * __restrict  )((char *)buf___3), (char const   * __restrict  )"%ld",
            (long )varp->var_val.var_number);
    }
    return (buf___3);
  } else { //Added block
  if ((unsigned long )varp->var_val.var_string == (unsigned long )((void *)0)) {
    return ((char_u *)"");
  } else {
    return (varp->var_val.var_string);
  }
  }
}
}
static VAR find_var(char_u *name___1 , int writing ) 
{ 
  int i___0 ;
  char_u *varname ;
  struct growarray *gap ;
  long tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((int )*(name___1 + 0) == 97) {
    if ((int )*(name___1 + 1) == 58) {
      if (writing) {
        {
        emsg2(e_readonlyvar, name___1);
        }
        return ((VAR )((void *)0));
      }
      name___1 += 2;
      if ((unsigned long )current_funccal == (unsigned long )((void *)0)) {
        return ((VAR )((void *)0));
      }
      {
      tmp___0 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___0 + (int )*name___1) & 2048) {
        {
        tmp = atol((char const   *)((char *)name___1));
        i___0 = (int )tmp;
        }
        if (i___0 == 0) {
          return (& current_funccal->a0_var);
        }
        i___0 += (current_funccal->func)->args.ga_len;
        if (i___0 > current_funccal->argcount) {
          return ((VAR )((void *)0));
        }
        return (current_funccal->argvars + (i___0 - 1));
      }
      {
      tmp___1 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"firstline"));
      }
      if (tmp___1 == 0) {
        return (& current_funccal->firstline);
      }
      {
      tmp___2 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"lastline"));
      }
      if (tmp___2 == 0) {
        return (& current_funccal->lastline);
      }
      i___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < (current_funccal->func)->args.ga_len)) {
          goto while_break;
        }
        {
        tmp___3 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)*((char_u **)(current_funccal->func)->args.ga_data + i___0)));
        }
        if (tmp___3 == 0) {
          return (current_funccal->argvars + i___0);
        }
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      return ((VAR )((void *)0));
    }
  }
  {
  gap = find_var_ga(name___1, & varname);
  }
  if ((unsigned long )gap == (unsigned long )((void *)0)) {
    return ((VAR )((void *)0));
  }
  i___0 = gap->ga_len;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break___0;
    }
    if ((unsigned long )((VAR )gap->ga_data + i___0)->var_name != (unsigned long )((void *)0)) {
      {
      tmp___4 = strcmp((char const   *)((char *)((VAR )gap->ga_data + i___0)->var_name),
                       (char const   *)((char *)varname));
      }
      if (tmp___4 == 0) {
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (i___0 < 0) {
    return ((VAR )((void *)0));
  }
  return ((VAR )gap->ga_data + i___0);
}
}
static struct growarray *find_var_ga(char_u *name___1 , char_u **varname ) 
{ 


  {
  if ((int )*(name___1 + 1) != 58) {
    *varname = name___1;
    if ((unsigned long )current_funccal == (unsigned long )((void *)0)) {
      return (& variables);
    }
    return (& current_funccal->l_vars);
  }
  *varname = name___1 + 2;
  if ((int )*name___1 == 98) {
    return (& curbuf->b_vars);
  }
  if ((int )*name___1 == 119) {
    return (& curwin->w_vars);
  }
  if ((int )*name___1 == 103) {
    return (& variables);
  }
  if ((int )*name___1 == 108) {
    if ((unsigned long )current_funccal != (unsigned long )((void *)0)) {
      return (& current_funccal->l_vars);
    }
  }
  return ((struct growarray *)((void *)0));
}
}
void var_init(struct growarray *gap ) 
{ 


  {
  {
  ga_init2(gap, (int )sizeof(var ), 4);
  }
  return;
}
}
void var_clear(struct growarray *gap ) 
{ 
  int i___0 ;

  {
  i___0 = gap->ga_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    {
    var_free_one((VAR )gap->ga_data + i___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  ga_clear(gap);
  }
  return;
}
}
static void var_free_one(VAR v ) 
{ 


  {
  {
  vim_free((void *)v->var_name);
  v->var_name = (char_u *)((void *)0);
  }
  if ((int )v->var_type == 2) {
    {
    vim_free((void *)v->var_val.var_string);
    }
  }
  v->var_val.var_string = (char_u *)((void *)0);
  return;
}
}
static void list_one_var(VAR v , char_u *prefix ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_var_string(v);
  list_one_var_a(prefix, v->var_name, (int )v->var_type, tmp);
  }
  return;
}
}
static void list_vim_var(int i___0 ) 
{ 
  char_u *p___0 ;
  char_u numbuf[30] ;

  {
  if ((int )vimvars[i___0].type == 1) {
    {
    p___0 = numbuf;
    sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )"%ld",
            (long )vimvars[i___0].val);
    }
  } else { //Added block
  if ((unsigned long )vimvars[i___0].val == (unsigned long )((void *)0)) {
    p___0 = (char_u *)"";
  } else {
    p___0 = vimvars[i___0].val;
  }
  }
  {
  list_one_var_a((char_u *)"v:", (char_u *)vimvars[i___0].name, (int )vimvars[i___0].type,
                 p___0);
  }
  return;
}
}
static void list_one_var_a(char_u *prefix , char_u *name___1 , int type , char_u *string___0 ) 
{ 


  {
  {
  msg_attr(prefix, 0);
  }
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    {
    msg_puts(name___1);
    }
  }
  {
  msg_putchar(' ');
  msg_advance(22);
  }
  if (type == 1) {
    {
    msg_putchar('#');
    }
  } else {
    {
    msg_putchar(' ');
    }
  }
  {
  msg_outtrans(string___0);
  }
  return;
}
}
static void set_var(char_u *name___1 , VAR varp ) 
{ 
  int i___0 ;
  VAR v ;
  char_u *varname ;
  struct growarray *gap ;
  size_t tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  {
  tmp = strlen((char const   *)((char *)name___1));
  i___0 = find_vim_var(name___1, (int )tmp);
  }
  if (i___0 >= 0) {
    if ((int )vimvars[i___0].flags & 2) {
      {
      emsg2(e_readonlyvar, name___1);
      }
    } else { //Added block
    if ((int )vimvars[i___0].type == 2) {
      {
      vim_free((void *)vimvars[i___0].val);
      tmp___0 = get_var_string(varp);
      vimvars[i___0].val = vim_strsave(tmp___0);
      }
    } else {
      vimvars[i___0].val = (char_u *)varp->var_val.var_number;
    }
    }
    return;
  }
  {
  v = find_var(name___1, 1);
  }
  if ((unsigned long )v != (unsigned long )((void *)0)) {
    if ((int )v->var_type == 2) {
      {
      vim_free((void *)v->var_val.var_string);
      }
    }
  } else {
    {
    gap = find_var_ga(name___1, & varname);
    }
    if ((unsigned long )gap == (unsigned long )((void *)0)) {
      return;
    }
    i___0 = gap->ga_len;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      i___0 --;
      if (! (i___0 >= 0)) {
        goto while_break;
      }
      if ((unsigned long )((VAR )gap->ga_data + i___0)->var_name == (unsigned long )((void *)0)) {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (i___0 < 0) {
      {
      tmp___1 = ga_grow(gap, 1);
      }
      if (tmp___1 == 0) {
        return;
      }
      i___0 = gap->ga_len;
    }
    {
    v = (VAR )gap->ga_data + i___0;
    tmp___2 = vim_strsave(varname);
    v->var_name = tmp___2;
    }
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      return;
    }
    if (i___0 == gap->ga_len) {
      (gap->ga_len) ++;
      (gap->ga_room) --;
    }
  }
  v->var_type = varp->var_type;
  if ((int )varp->var_type == 2) {
    {
    tmp___3 = get_var_string(varp);
    v->var_val.var_string = vim_strsave(tmp___3);
    }
  } else {
    v->var_val.var_number = varp->var_val.var_number;
  }
  return;
}
}
void do_echo(EXARG *eap , int echo ) 
{ 
  char_u *arg ;
  var retvar ;
  char_u *p___0 ;
  int needclr ;
  int atstart ;
  int tmp ;

  {
  arg = eap->arg;
  needclr = 1;
  atstart = 1;
  if (eap->skip) {
    emsg_off ++;
  } else { //Added block
  if (echo) {
    {
    msg_start();
    }
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*arg != 0) {
      if ((int )*arg != 124) {
        if ((int )*arg != 10) {
          if (! (! got_int)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    p___0 = arg;
    tmp = eval1(& arg, & retvar, ! eap->skip);
    }
    if (tmp == 0) {
      {
      emsg2(e_invexpr2, p___0);
      }
      goto while_break;
    }
    if (! eap->skip) {
      if (atstart) {
        atstart = 0;
      } else { //Added block
      if (echo) {
        {
        msg_puts_attr((char_u *)" ", echo_attr);
        }
      }
      }
      {
      p___0 = get_var_string(& retvar);
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if ((int )*p___0 != 0) {
          if (! (! got_int)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        if ((int )*p___0 == 10) {
          goto _L;
        } else { //Added block
        if ((int )*p___0 == 13) {
          goto _L;
        } else { //Added block
        if ((int )*p___0 == 9) {
          _L: 
          if ((int )*p___0 != 9) {
            if (needclr) {
              {
              msg_clr_eos();
              needclr = 0;
              }
            }
          }
          {
          msg_putchar_attr((int )*p___0, echo_attr);
          }
        } else {
          {
          msg_outtrans_len_attr(p___0, 1, echo_attr);
          }
        }
        }
        }
        p___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    clear_var(& retvar);
    arg = skipwhite(arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  eap->nextcmd = check_nextcmd(arg);
  }
  if (eap->skip) {
    emsg_off --;
  } else {
    if (needclr) {
      {
      msg_clr_eos();
      }
    }
    if (echo) {
      {
      msg_end();
      }
    }
  }
  return;
}
}
void do_echohl(char_u *arg ) 
{ 
  int id ;

  {
  {
  id = syn_name2id(arg);
  }
  if (id == 0) {
    echo_attr = 0;
  } else {
    {
    echo_attr = syn_id2attr(id);
    }
  }
  return;
}
}
void do_execute(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{ 
  char_u *arg ;
  var retvar ;
  int ret ;
  char_u *p___0 ;
  struct growarray ga ;
  int len___0 ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  arg = eap->arg;
  ret = 1;
  ga_init2(& ga, 1, 80);
  }
  if (eap->skip) {
    emsg_off ++;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*arg != 0) {
      if ((int )*arg != 124) {
        if (! ((int )*arg != 10)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    p___0 = arg;
    tmp = eval1(& arg, & retvar, ! eap->skip);
    }
    if (tmp == 0) {
      {
      emsg2(e_invexpr2, p___0);
      ret = 0;
      }
      goto while_break;
    }
    if (! eap->skip) {
      {
      p___0 = get_var_string(& retvar);
      tmp___0 = strlen((char const   *)((char *)p___0));
      len___0 = (int )tmp___0;
      tmp___1 = ga_grow(& ga, len___0 + 2);
      }
      if (tmp___1 == 0) {
        {
        clear_var(& retvar);
        ret = 0;
        }
        goto while_break;
      }
      if (ga.ga_len) {
        tmp___2 = ga.ga_len;
        (ga.ga_len) ++;
        *((char_u *)ga.ga_data + tmp___2) = (char_u )' ';
        (ga.ga_room) --;
      }
      {
      strcpy((char * __restrict  )((char *)((char_u *)ga.ga_data + ga.ga_len)), (char const   * __restrict  )((char *)p___0));
      ga.ga_room -= len___0;
      ga.ga_len += len___0;
      }
    }
    {
    clear_var(& retvar);
    arg = skipwhite(arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (ret != 0) {
    if ((unsigned long )ga.ga_data != (unsigned long )((void *)0)) {
      {
      do_cmdline((char_u *)ga.ga_data, getline___0, cookie, 3);
      }
    }
  }
  {
  ga_clear(& ga);
  }
  if (eap->skip) {
    emsg_off --;
  }
  {
  eap->nextcmd = check_nextcmd(arg);
  }
  return;
}
}
static char_u *find_option_end(char_u *p___0 ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp + (int )*p___0) & 8)) {
      if (! ((int )*p___0 == 95)) {
        goto while_break;
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
void do_function(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{ 
  char_u *theline ;
  int j ;
  int c ;
  char_u *name___1 ;
  char_u *nameend ;
  char_u *p___0 ;
  char_u *arg ;
  struct growarray newargs ;
  struct growarray newlines ;
  int varargs ;
  int mustend ;
  int flags___0 ;
  struct ufunc *fp___0 ;
  int indent ;
  int nesting___0 ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char_u *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char_u *tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  char_u *tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char_u *tmp___22 ;

  {
  varargs = 0;
  mustend = 0;
  flags___0 = 0;
  if ((int )*(eap->arg) == 0) {
    if (! eap->skip) {
      fp___0 = firstfunc;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((unsigned long )fp___0 != (unsigned long )((void *)0))) {
          goto while_break;
        }
        {
        list_func_head(fp___0);
        fp___0 = fp___0->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    return;
  }
  {
  tmp = __ctype_b_loc();
  }
  if (! ((int const   )*(*tmp + (int )*(eap->arg)) & 256)) {
    if (! eap->skip) {
      {
      emsg2((char_u *)"Function name must start with a capital: %s", eap->arg);
      }
      return;
    }
  }
  {
  tmp___0 = vim_strchr(eap->arg, '(');
  }
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    if (! eap->skip) {
      {
      fp___0 = find_func(eap->arg);
      }
      if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
        {
        list_func_head(fp___0);
        j = 0;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (j < fp___0->lines.ga_len)) {
            goto while_break___0;
          }
          {
          msg_putchar('\n');
          msg_prt_line(*((char_u **)fp___0->lines.ga_data + j));
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        msg((char_u *)"endfunction");
        }
      } else {
        {
        emsg2((char_u *)"Undefined function: %s", eap->arg);
        }
      }
    }
    return;
  }
  name___1 = eap->arg;
  p___0 = name___1;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    tmp___1 = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp___1 + (int )*p___0) & 1024)) {
      {
      tmp___2 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___2 + (int )*p___0) & 2048)) {
        if (! ((int )*p___0 == 95)) {
          goto while_break___1;
        }
      }
    }
    p___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  if ((unsigned long )p___0 == (unsigned long )name___1) {
    if (! eap->skip) {
      {
      emsg((char_u *)"Function name required");
      }
      return;
    }
  }
  {
  nameend = p___0;
  p___0 = skipwhite(p___0);
  }
  if ((int )*p___0 != 40) {
    if (! eap->skip) {
      {
      emsg2((char_u *)"Missing \'(\': %s", name___1);
      }
      return;
    }
    {
    tmp___3 = vim_strchr(p___0, '(');
    }
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
      p___0 = vim_strchr(p___0, '(');
      }
    }
  }
  {
  p___0 = skipwhite(p___0 + 1);
  ga_init2(& newargs, (int )sizeof(char_u *), 3);
  ga_init2(& newlines, (int )sizeof(char_u *), 3);
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! ((int )*p___0 != 41)) {
      goto while_break___2;
    }
    if ((int )*(p___0 + 0) == 46) {
      if ((int )*(p___0 + 1) == 46) {
        if ((int )*(p___0 + 2) == 46) {
          varargs = 1;
          p___0 += 3;
          mustend = 1;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      arg = p___0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
        tmp___4 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___4 + (int )*p___0) & 1024)) {
          {
          tmp___5 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___5 + (int )*p___0) & 2048)) {
            if (! ((int )*p___0 == 95)) {
              goto while_break___3;
            }
          }
        }
        p___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      if ((unsigned long )arg == (unsigned long )p___0) {
        goto _L;
      } else {
        {
        tmp___6 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___6 + (int )*arg) & 2048) {
          _L: 
          if (! eap->skip) {
            {
            emsg2((char_u *)"Illegal argument: %s", arg);
            }
          }
          goto erret;
        }
      }
      {
      tmp___7 = ga_grow(& newargs, 1);
      }
      if (tmp___7 == 0) {
        goto erret;
      }
      {
      c = (int )*p___0;
      *p___0 = (char_u )'\000';
      arg = vim_strsave(arg);
      }
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
        goto erret;
      }
      *((char_u **)newargs.ga_data + newargs.ga_len) = arg;
      *p___0 = (char_u )c;
      (newargs.ga_len) ++;
      (newargs.ga_room) --;
      if ((int )*p___0 == 44) {
        p___0 ++;
      } else {
        mustend = 1;
      }
    }
    {
    p___0 = skipwhite(p___0);
    }
    if (mustend) {
      if ((int )*p___0 != 41) {
        if (! eap->skip) {
          {
          emsg2(e_invarg2, eap->arg);
          }
        }
        goto erret;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  p___0 ++;
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
    p___0 = skipwhite(p___0);
    tmp___9 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"range"),
                      (size_t )5);
    }
    if (tmp___9 == 0) {
      flags___0 |= 2;
      p___0 += 5;
    } else {
      {
      tmp___8 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"abort"),
                        (size_t )5);
      }
      if (tmp___8 == 0) {
        flags___0 |= 1;
        p___0 += 5;
      } else {
        goto while_break___4;
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  if ((int )*p___0 != 0) {
    if ((int )*p___0 != 34) {
      if ((int )*p___0 != 10) {
        if (! eap->skip) {
          {
          emsg(e_trailing);
          }
        }
        goto erret;
      }
    }
  }
  if (KeyTyped) {
    {
    msg_putchar('\n');
    cmdline_row = msg_row;
    }
  }
  indent = 2;
  nesting___0 = 0;
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    msg_scroll = 1;
    need_wait_return = 0;
    if ((unsigned long )getline___0 == (unsigned long )((void *)0)) {
      {
      theline = getcmdline(':', 0L, indent);
      }
    } else {
      {
      theline = (*getline___0)(':', cookie, indent);
      }
    }
    lines_left = (int )(Rows - 1L);
    if ((unsigned long )theline == (unsigned long )((void *)0)) {
      {
      emsg((char_u *)"Missing :endfunction");
      }
      goto erret;
    }
    p___0 = theline;
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (! ((int )*p___0 == 32)) {
        if (! ((int )*p___0 == 9)) {
          if (! ((int )*p___0 == 58)) {
            goto while_break___6;
          }
        }
      }
      p___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
    tmp___10 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"endf"),
                       (size_t )4);
    }
    if (tmp___10 == 0) {
      tmp___11 = nesting___0;
      nesting___0 --;
      if (tmp___11 == 0) {
        {
        vim_free((void *)theline);
        }
        goto while_break___5;
      }
    }
    if (indent > 2) {
      {
      tmp___14 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"end"),
                         (size_t )3);
      }
      if (tmp___14 == 0) {
        indent -= 2;
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      {
      tmp___12 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"if"),
                         (size_t )2);
      }
      if (tmp___12 == 0) {
        indent += 2;
      } else {
        {
        tmp___13 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"wh"),
                           (size_t )2);
        }
        if (tmp___13 == 0) {
          indent += 2;
        }
      }
    }
    {
    tmp___20 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"fu"),
                       (size_t )2);
    }
    if (tmp___20 == 0) {
      {
      tmp___15 = skiptowhite(p___0);
      p___0 = skipwhite(tmp___15);
      tmp___19 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___19 + (int )*p___0) & 256) {
        {
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
          tmp___16 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___16 + (int )*p___0) & 1024)) {
            {
            tmp___17 = __ctype_b_loc();
            }
            if (! ((int const   )*(*tmp___17 + (int )*p___0) & 2048)) {
              if (! ((int )*p___0 == 95)) {
                goto while_break___7;
              }
            }
          }
          p___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
        tmp___18 = skipwhite(p___0);
        }
        if ((int )*tmp___18 == 40) {
          nesting___0 ++;
          indent += 2;
        }
      }
    }
    {
    tmp___21 = ga_grow(& newlines, 1);
    }
    if (tmp___21 == 0) {
      goto erret;
    }
    *((char_u **)newlines.ga_data + newlines.ga_len) = theline;
    (newlines.ga_len) ++;
    (newlines.ga_room) --;
  }
  while_break___5: /* CIL Label */ ;
  }
  if (eap->skip) {
    goto erret;
  }
  {
  *nameend = (char_u )'\000';
  fp___0 = find_func(name___1);
  }
  if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
    if (! eap->forceit) {
      {
      emsg2((char_u *)"Function %s already exists, use ! to replace", name___1);
      }
      goto erret;
    }
    if (fp___0->calls) {
      {
      emsg2((char_u *)"Cannot redefine function %s: It is in use", name___1);
      }
      goto erret;
    }
    {
    ga_clear_strings(& fp___0->args);
    ga_clear_strings(& fp___0->lines);
    }
  } else {
    {
    tmp___22 = alloc((unsigned int )sizeof(struct ufunc ));
    fp___0 = (struct ufunc *)tmp___22;
    }
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      goto erret;
    }
    {
    name___1 = vim_strsave(name___1);
    }
    if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
      {
      vim_free((void *)fp___0);
      }
      goto erret;
    }
    fp___0->next = firstfunc;
    firstfunc = fp___0;
    fp___0->name = name___1;
  }
  fp___0->args = newargs;
  fp___0->lines = newlines;
  fp___0->varargs = varargs;
  fp___0->flags = flags___0;
  fp___0->calls = 0;
  return;
  erret: 
  {
  ga_clear_strings(& newargs);
  ga_clear_strings(& newlines);
  }
  return;
}
}
static void list_func_head(struct ufunc *fp___0 ) 
{ 
  int j ;

  {
  {
  msg((char_u *)"function ");
  msg_puts(fp___0->name);
  msg_putchar('(');
  j = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (j < fp___0->args.ga_len)) {
      goto while_break;
    }
    if (j) {
      {
      msg_puts((char_u *)", ");
      }
    }
    {
    msg_puts(*((char_u **)fp___0->args.ga_data + j));
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (fp___0->varargs) {
    if (j) {
      {
      msg_puts((char_u *)", ");
      }
    }
    {
    msg_puts((char_u *)"...");
    }
  }
  {
  msg_putchar(')');
  }
  return;
}
}
static struct ufunc *find_func(char_u *name___1 ) 
{ 
  struct ufunc *fp___0 ;
  int tmp ;

  {
  fp___0 = firstfunc;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )fp___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = strcmp((char const   *)((char *)name___1), (char const   *)((char *)fp___0->name));
    }
    if (tmp == 0) {
      goto while_break;
    }
    fp___0 = fp___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  return (fp___0);
}
}
static struct ufunc *fp  =    (struct ufunc *)((void *)0);
char_u *get_user_func_name(int idx ) 
{ 
  char_u *name___1 ;

  {
  if (idx == 0) {
    fp = firstfunc;
  }
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    name___1 = fp->name;
    fp = fp->next;
    return (name___1);
  }
  return ((char_u *)((void *)0));
}
}
void do_delfunction(char_u *arg ) 
{ 
  struct ufunc *fp___0 ;
  struct ufunc *pfp ;

  {
  {
  fp___0 = find_func(arg);
  }
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
    emsg2((char_u *)"Undefined function: %s", arg);
    }
    return;
  }
  if (fp___0->calls) {
    {
    emsg2((char_u *)"Cannot delete function %s: It is in use", arg);
    }
    return;
  }
  {
  vim_free((void *)fp___0->name);
  ga_clear_strings(& fp___0->args);
  ga_clear_strings(& fp___0->lines);
  }
  if ((unsigned long )firstfunc == (unsigned long )fp___0) {
    firstfunc = fp___0->next;
  } else {
    pfp = firstfunc;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )pfp != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if ((unsigned long )pfp->next == (unsigned long )fp___0) {
        pfp->next = fp___0->next;
        goto while_break;
      }
      pfp = pfp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  vim_free((void *)fp___0);
  }
  return;
}
}
static int depth  =    0;
static void call_func(struct ufunc *fp___0 , int argcount , VAR argvars , VAR retvar ,
                      linenr_t firstline , linenr_t lastline ) 
{ 
  char_u *save_sourcing_name ;
  linenr_t save_sourcing_lnum ;
  int save_redrawing ;
  struct funccall fc ;
  struct funccall *save_fcp ;
  int save_did_emsg ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  save_redrawing = RedrawingDisabled;
  save_fcp = current_funccal;
  if ((long )depth >= p_mfd) {
    {
    emsg((char_u *)"Function call depth is higher than \'maxfuncdepth\'");
    retvar->var_type = (char)1;
    retvar->var_val.var_number = -1;
    }
    return;
  }
  {
  depth ++;
  line_breakcheck();
  var_init(& fc.l_vars);
  fc.func = fp___0;
  fc.argcount = argcount;
  fc.argvars = argvars;
  fc.retvar = retvar;
  retvar->var_val.var_number = 0;
  fc.linenr = 0;
  fc.a0_var.var_type = (char)1;
  fc.a0_var.var_val.var_number = argcount - fp___0->args.ga_len;
  fc.a0_var.var_name = (char_u *)((void *)0);
  current_funccal = & fc;
  fc.firstline.var_type = (char)1;
  fc.firstline.var_val.var_number = (var_number_type )firstline;
  fc.firstline.var_name = (char_u *)((void *)0);
  fc.lastline.var_type = (char)1;
  fc.lastline.var_val.var_number = (var_number_type )lastline;
  fc.lastline.var_name = (char_u *)((void *)0);
  RedrawingDisabled = 1;
  save_sourcing_name = sourcing_name;
  save_sourcing_lnum = sourcing_lnum;
  sourcing_lnum = (linenr_t )0;
  }
  if ((unsigned long )save_sourcing_name == (unsigned long )((void *)0)) {
    tmp___0 = (size_t )0;
  } else {
    {
    tmp = strlen((char const   *)((char *)save_sourcing_name));
    tmp___0 = tmp;
    }
  }
  {
  tmp___1 = strlen((char const   *)((char *)fp___0->name));
  sourcing_name = alloc((unsigned int )((tmp___0 + tmp___1) + 10UL));
  }
  if ((unsigned long )sourcing_name != (unsigned long )((void *)0)) {
    if ((unsigned long )save_sourcing_name != (unsigned long )((void *)0)) {
      {
      tmp___2 = strncmp((char const   *)((char *)save_sourcing_name), (char const   *)((char *)"function "),
                        (size_t )9);
      }
      if (tmp___2 == 0) {
        {
        sprintf((char * __restrict  )((char *)sourcing_name), (char const   * __restrict  )"%s->",
                save_sourcing_name);
        }
      } else {
        {
        strcpy((char * __restrict  )((char *)sourcing_name), (char const   * __restrict  )((char *)"function "));
        }
      }
    } else {
      {
      strcpy((char * __restrict  )((char *)sourcing_name), (char const   * __restrict  )((char *)"function "));
      }
    }
    {
    strcat((char * __restrict  )((char *)sourcing_name), (char const   * __restrict  )((char *)fp___0->name));
    }
  }
  {
  save_did_emsg = did_emsg;
  did_emsg = 0;
  do_cmdline((char_u *)((void *)0), & get_func_line, (void *)(& fc), 7);
  RedrawingDisabled = save_redrawing;
  vim_free((void *)sourcing_name);
  sourcing_name = save_sourcing_name;
  sourcing_lnum = save_sourcing_lnum;
  }
  if (did_emsg) {
    if (fp___0->flags & 1) {
      {
      clear_var(retvar);
      retvar->var_type = (char)1;
      retvar->var_val.var_number = -1;
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )retvar->var_type == 0) {
    {
    clear_var(retvar);
    retvar->var_type = (char)1;
    retvar->var_val.var_number = -1;
    }
  }
  }
  {
  did_emsg |= save_did_emsg;
  current_funccal = save_fcp;
  var_clear(& fc.l_vars);
  depth --;
  }
  return;
}
}
void *save_funccal(void) 
{ 
  struct funccall *fc ;

  {
  fc = current_funccal;
  current_funccal = (struct funccall *)((void *)0);
  return ((void *)fc);
}
}
void restore_funccal(void *fc ) 
{ 


  {
  current_funccal = (struct funccall *)fc;
  return;
}
}
void do_return(EXARG *eap ) 
{ 
  char_u *arg ;
  var retvar ;
  char_u *p___0 ;
  int tmp ;

  {
  arg = eap->arg;
  if ((unsigned long )current_funccal == (unsigned long )((void *)0)) {
    {
    emsg((char_u *)":return not inside a function");
    }
    return;
  }
  if (eap->skip) {
    emsg_off ++;
  } else {
    current_funccal->linenr = -1;
  }
  if ((int )*arg != 0) {
    if ((int )*arg != 124) {
      if ((int )*arg != 10) {
        {
        p___0 = arg;
        tmp = eval1(& arg, & retvar, ! eap->skip);
        }
        if (tmp != 0) {
          if (! eap->skip) {
            {
            clear_var(current_funccal->retvar);
            *(current_funccal->retvar) = retvar;
            }
          } else {
            {
            clear_var(& retvar);
            }
          }
        } else {
          {
          emsg2(e_invexpr2, p___0);
          }
        }
      }
    }
  }
  if (eap->skip) {
    {
    emsg_off --;
    eap->nextcmd = check_nextcmd(arg);
    }
  } else {
    eap->nextcmd = (char_u *)((void *)0);
  }
  return;
}
}
char_u *get_func_line(int c , void *cookie , int indent ) 
{ 
  struct funccall *fcp ;
  char_u *retval ;
  struct growarray *gap ;
  int tmp ;

  {
  fcp = (struct funccall *)cookie;
  gap = & (fcp->func)->lines;
  if ((fcp->func)->flags & 1) {
    if (did_emsg) {
      retval = (char_u *)((void *)0);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (fcp->linenr < 0) {
    retval = (char_u *)((void *)0);
  } else { //Added block
  if (fcp->linenr >= gap->ga_len) {
    retval = (char_u *)((void *)0);
  } else {
    {
    tmp = fcp->linenr;
    (fcp->linenr) ++;
    retval = vim_strsave(*((char_u **)gap->ga_data + tmp));
    }
  }
  }
  }
  if (p_verbose >= 15L) {
    msg_scroll = 1;
    if ((unsigned long )retval == (unsigned long )((void *)0)) {
      {
      msg((char_u *)"function returning");
      }
    } else {
      {
      smsg((char_u *)"function line %s", retval);
      }
    }
    {
    msg_puts((char_u *)"\n");
    cmdline_row = msg_row;
    }
  }
  return (retval);
}
}
int func_has_ended(void *cookie ) 
{ 
  struct funccall *fcp ;
  int tmp ;

  {
  fcp = (struct funccall *)cookie;
  if ((fcp->func)->flags & 1) {
    if (did_emsg) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (fcp->linenr < 0) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
int func_has_abort(void *cookie ) 
{ 


  {
  return ((((struct funccall *)cookie)->func)->flags & 1);
}
}
static VAR_FLAVOUR var_flavour(char_u *varname ) ;
static VAR_FLAVOUR var_flavour(char_u *varname ) 
{ 
  char_u *p___0 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  p___0 = varname;
  tmp___0 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___0 + (int )*p___0) & 256) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      p___0 ++;
      if (! *p___0) {
        goto while_break;
      }
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + (int )*p___0) & 512) {
        return ((VAR_FLAVOUR )1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    return ((VAR_FLAVOUR )2);
  } else {
    return ((VAR_FLAVOUR )0);
  }
}
}
int read_viminfo_varlist(char_u *line , FILE *fp___0 , int writing ) 
{ 
  char_u *tab ;
  int is_string ;
  VAR varp ;
  char_u *val ;
  char_u *tmp ;
  long tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  is_string = 0;
  varp = (VAR )((void *)0);
  if (! writing) {
    {
    tmp___1 = find_viminfo_parameter('!');
    }
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
      tab = vim_strchr(line + 1, '\t');
      }
      if ((unsigned long )tab != (unsigned long )((void *)0)) {
        tmp = tab;
        tab ++;
        *tmp = (char_u )'\000';
        if ((int )*tab == 83) {
          is_string = 1;
        }
        {
        tab = vim_strchr(tab, '\t');
        }
        if ((unsigned long )tab != (unsigned long )((void *)0)) {
          if (is_string) {
            {
            val = viminfo_readstring(tab + 1, fp___0);
            }
            if ((unsigned long )val != (unsigned long )((void *)0)) {
              {
              varp = alloc_string_var(val);
              }
            }
          } else {
            {
            varp = alloc_var();
            }
            if ((unsigned long )varp != (unsigned long )((void *)0)) {
              {
              varp->var_type = (char)1;
              tmp___0 = atol((char const   *)((char *)tab + 1));
              varp->var_val.var_number = (var_number_type )tmp___0;
              }
            }
          }
          if ((unsigned long )varp != (unsigned long )((void *)0)) {
            {
            set_var(line + 1, varp);
            free_var(varp);
            }
          }
        }
      }
    }
  }
  {
  tmp___2 = vim_fgets(line, 512, fp___0);
  }
  return (tmp___2);
}
}
void write_viminfo_varlist(FILE *fp___0 ) 
{ 
  struct growarray *gap ;
  VAR this_var ;
  int i___0 ;
  char_u *tmp ;
  char const   *tmp___0 ;
  char_u *tmp___1 ;
  VAR_FLAVOUR tmp___2 ;

  {
  {
  gap = & variables;
  tmp = find_viminfo_parameter('!');
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return;
  }
  {
  fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# global variables:\n");
  i___0 = gap->ga_len;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    this_var = (VAR )gap->ga_data + i___0;
    if ((unsigned long )this_var->var_name != (unsigned long )((void *)0)) {
      {
      tmp___2 = var_flavour(this_var->var_name);
      }
      if ((unsigned int )tmp___2 == 2U) {
        if ((int )this_var->var_type == 2) {
          tmp___0 = "STR";
        } else {
          tmp___0 = "NUM";
        }
        {
        fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"!%s\t%s\t",
                this_var->var_name, tmp___0);
        tmp___1 = get_var_string(this_var);
        viminfo_writestring(fp___0, tmp___1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int store_session_globals(FILE *fd ) 
{ 
  struct growarray *gap ;
  VAR this_var ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  VAR_FLAVOUR tmp___4 ;

  {
  gap = & variables;
  i___0 = gap->ga_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    this_var = (VAR )gap->ga_data + i___0;
    if ((unsigned long )this_var->var_name != (unsigned long )((void *)0)) {
      {
      tmp___4 = var_flavour(this_var->var_name);
      }
      if ((unsigned int )tmp___4 == 1U) {
        if ((int )this_var->var_type == 2) {
          tmp = '\"';
        } else {
          tmp = ' ';
        }
        {
        tmp___0 = get_var_string(this_var);
        }
        if ((int )this_var->var_type == 2) {
          tmp___1 = '\"';
        } else {
          tmp___1 = ' ';
        }
        {
        tmp___2 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"let %s = %c%s%c",
                          this_var->var_name, tmp___1, tmp___0, tmp);
        }
        if (tmp___2 < 0) {
          return (0);
        } else {
          {
          tmp___3 = put_eol(fd);
          }
          if (tmp___3 == 0) {
            return (0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
int modify_fname(char_u *src , int *usedlen , char_u **fnamep , char_u **bufp , int *fnamelen ) 
{ 
  int valid ;
  char_u *tail ;
  char_u *s ;
  char_u *p___0 ;
  char_u dirname[1024] ;
  int c ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *str___1 ;
  char_u *pat ;
  char_u *sub ;
  int sep ;
  char_u *flags___0 ;
  int didit ;
  char_u *tmp___3 ;
  size_t tmp___4 ;

  {
  valid = 0;
  repeat: 
  if ((int )*(src + *usedlen) == 58) {
    if ((int )*(src + (*usedlen + 1)) == 112) {
      {
      valid |= 1;
      *usedlen += 2;
      tmp = mch_isFullName(*fnamep);
      }
      if (! tmp) {
        {
        *fnamep = FullName_save(*fnamep, 0);
        vim_free((void *)*bufp);
        *bufp = *fnamep;
        }
        if ((unsigned long )*fnamep == (unsigned long )((void *)0)) {
          return (-1);
        }
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*(src + *usedlen) == 58) {
      c = (int )*(src + (*usedlen + 1));
      if (! (c == 46)) {
        if (! (c == 126)) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
    *usedlen += 2;
    if (c == 46) {
      if ((int )*(*fnamep) == 126) {
        {
        p___0 = expand_env_save(*fnamep);
        }
      } else {
        {
        p___0 = FullName_save(*fnamep, 0);
        }
      }
    } else {
      {
      p___0 = FullName_save(*fnamep, 0);
      }
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      if (c == 46) {
        {
        mch_dirname(dirname, 1024);
        s = shorten_fname(p___0, dirname);
        }
        if ((unsigned long )s != (unsigned long )((void *)0)) {
          {
          *fnamep = s;
          vim_free((void *)*bufp);
          *bufp = p___0;
          }
        } else {
          {
          vim_free((void *)p___0);
          }
        }
      } else {
        {
        home_replace((BUF *)((void *)0), p___0, dirname, 1024, 1);
        }
        if ((int )dirname[0] == 126) {
          {
          s = vim_strsave(dirname);
          }
          if ((unsigned long )s != (unsigned long )((void *)0)) {
            {
            *fnamep = s;
            vim_free((void *)*bufp);
            *bufp = s;
            }
          }
        }
        {
        vim_free((void *)p___0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  tail = gettail(*fnamep);
  tmp___0 = strlen((char const   *)((char *)*fnamep));
  *fnamelen = (int )tmp___0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if ((int )*(src + *usedlen) == 58) {
      if (! ((int )*(src + (*usedlen + 1)) == 104)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    valid |= 2;
    *usedlen += 2;
    s = get_past_head(*fnamep);
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if ((unsigned long )tail > (unsigned long )s) {
        {
        tmp___1 = vim_ispathsep((int )*(tail + -1));
        }
        if (! tmp___1) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      tail --;
    }
    while_break___1: /* CIL Label */ ;
    }
    *fnamelen = (int )(tail - *fnamep);
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if ((unsigned long )tail > (unsigned long )s) {
        {
        tmp___2 = vim_ispathsep((int )*(tail + -1));
        }
        if (tmp___2) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
      tail --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((int )*(src + *usedlen) == 58) {
    if ((int )*(src + (*usedlen + 1)) == 116) {
      *usedlen += 2;
      *fnamelen = (int )((long )*fnamelen - (tail - *fnamep));
      *fnamep = tail;
    }
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if ((int )*(src + *usedlen) == 58) {
      if (! ((int )*(src + (*usedlen + 1)) == 101)) {
        if (! ((int )*(src + (*usedlen + 1)) == 114)) {
          goto while_break___3;
        }
      }
    } else {
      goto while_break___3;
    }
    if ((int )*(src + (*usedlen + 1)) == 101) {
      if ((unsigned long )*fnamep > (unsigned long )tail) {
        s = *fnamep - 2;
      } else {
        s = (*fnamep + *fnamelen) - 1;
      }
    } else {
      s = (*fnamep + *fnamelen) - 1;
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ((unsigned long )s > (unsigned long )tail)) {
        goto while_break___4;
      }
      if ((int )*(s + 0) == 46) {
        goto while_break___4;
      }
      s --;
    }
    while_break___4: /* CIL Label */ ;
    }
    if ((int )*(src + (*usedlen + 1)) == 101) {
      if ((unsigned long )s > (unsigned long )tail) {
        *fnamelen = (int )((long )*fnamelen + (*fnamep - (s + 1)));
        *fnamep = s + 1;
      } else { //Added block
      if ((unsigned long )*fnamep <= (unsigned long )tail) {
        *fnamelen = 0;
      }
      }
    } else { //Added block
    if ((unsigned long )s > (unsigned long )tail) {
      *fnamelen = (int )(s - *fnamep);
    }
    }
    *usedlen += 2;
  }
  while_break___3: /* CIL Label */ ;
  }
  if ((int )*(src + *usedlen) == 58) {
    if ((int )*(src + (*usedlen + 1)) == 115) {
      goto _L;
    } else { //Added block
    if ((int )*(src + (*usedlen + 1)) == 103) {
      if ((int )*(src + (*usedlen + 2)) == 115) {
        _L: 
        didit = 0;
        flags___0 = (char_u *)"";
        s = (src + *usedlen) + 2;
        if ((int )*(src + (*usedlen + 1)) == 103) {
          flags___0 = (char_u *)"g";
          s ++;
        }
        tmp___3 = s;
        s ++;
        sep = (int )*tmp___3;
        if (sep) {
          {
          p___0 = vim_strchr(s, sep);
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            pat = vim_strnsave(s, (int )(p___0 - s));
            }
            if ((unsigned long )pat != (unsigned long )((void *)0)) {
              {
              s = p___0 + 1;
              p___0 = vim_strchr(s, sep);
              }
              if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                {
                sub = vim_strnsave(s, (int )(p___0 - s));
                str___1 = vim_strnsave(*fnamep, *fnamelen);
                }
                if ((unsigned long )sub != (unsigned long )((void *)0)) {
                  if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
                    {
                    *usedlen = (int )((p___0 + 1) - src);
                    s = do_string_sub(str___1, pat, sub, flags___0);
                    }
                    if ((unsigned long )s != (unsigned long )((void *)0)) {
                      {
                      *fnamep = s;
                      tmp___4 = strlen((char const   *)((char *)s));
                      *fnamelen = (int )tmp___4;
                      vim_free((void *)*bufp);
                      *bufp = s;
                      didit = 1;
                      }
                    }
                  }
                }
                {
                vim_free((void *)sub);
                vim_free((void *)str___1);
                }
              }
              {
              vim_free((void *)pat);
              }
            }
          }
          if (didit) {
            goto repeat;
          }
        }
      }
    }
    }
  }
  return (valid);
}
}
char_u *do_string_sub(char_u *str___1 , char_u *pat , char_u *sub , char_u *flags___0 ) 
{ 
  int sublen ;
  vim_regexp *prog ;
  int i___0 ;
  int do_all___0 ;
  char_u *tail ;
  struct growarray ga ;
  char_u *ret ;
  char_u *save_cpo ;
  size_t tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;

  {
  {
  save_cpo = p_cpo;
  p_cpo = (char_u *)"";
  ga_init2(& ga, 1, 200);
  do_all___0 = (int )*(flags___0 + 0) == 103;
  reg_ic = p_ic;
  prog = vim_regcomp(pat, 1);
  }
  if ((unsigned long )prog != (unsigned long )((void *)0)) {
    tail = str___1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp___2 = vim_regexec(prog, tail, (unsigned long )tail == (unsigned long )str___1);
      }
      if (! tmp___2) {
        goto while_break;
      }
      {
      sublen = vim_regsub(prog, sub, tail, 0, 1);
      tmp = strlen((char const   *)((char *)tail));
      tmp___0 = ga_grow(& ga, (int )((tmp + (size_t )sublen) - (size_t )(prog->endp[0] - prog->startp[0])));
      }
      if (tmp___0 == 0) {
        {
        ga_clear(& ga);
        }
        goto while_break;
      }
      {
      i___0 = (int )(prog->startp[0] - tail);
      memmove((void *)((char *)((char_u *)ga.ga_data + ga.ga_len)), (void const   *)((char *)tail),
              (size_t )i___0);
      vim_regsub(prog, sub, ((char_u *)ga.ga_data + ga.ga_len) + i___0, 1, 1);
      ga.ga_len += (i___0 + sublen) - 1;
      ga.ga_room -= (i___0 + sublen) - 1;
      }
      if ((unsigned long )tail == (unsigned long )prog->endp[0]) {
        if ((int )*tail == 0) {
          goto while_break;
        }
        tmp___1 = tail;
        tail ++;
        *((char_u *)ga.ga_data + ga.ga_len) = *tmp___1;
        (ga.ga_len) ++;
        (ga.ga_room) --;
      } else {
        tail = prog->endp[0];
        if ((int )*tail == 0) {
          goto while_break;
        }
      }
      if (! do_all___0) {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if ((unsigned long )ga.ga_data != (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )((char *)ga.ga_data + ga.ga_len), (char const   * __restrict  )((char *)tail));
      }
    }
    {
    vim_free((void *)prog);
    }
  }
  if ((unsigned long )ga.ga_data == (unsigned long )((void *)0)) {
    tmp___3 = str___1;
  } else {
    tmp___3 = (char_u *)ga.ga_data;
  }
  {
  ret = vim_strsave(tmp___3);
  ga_clear(& ga);
  p_cpo = save_cpo;
  }
  return (ret);
}
}
#pragma merger("0","/tmp/cil-U5alLrC_.i","-O0")
extern struct _IO_FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
int msg_col  ;
int msg_scrolled  ;
char_u *keep_msg ;
int keep_msg_attr ;
int msg_didany ;
int no_wait_return ;
int highlight_match ;
int search_match_len  ;
int need_check_timestamps ;
int autocmd_busy ;
int exiting ;
int restricted ;
int secure ;
int silent_mode ;
int VIsual_reselect  ;
int exmode_active ;
int confirm ;
char_u msg_buf[80]  ;
int skip_redraw ;
char_u *use_viminfo ;
int bangredo ;
int need_start_insertmode ;
int g_do_tagpreview ;
char_u *help_save_isk ;
long help_save_ts ;
char_u e_backslash[34] ;
char_u e_curdir[65] ;
char_u e_exists[32] ;
char_u e_interr[12] ;
char_u e_invcmd[16] ;
char_u e_noname[13] ;
char_u e_nopresub[42] ;
char_u e_noprev[20] ;
char_u e_notcreate[21] ;
char_u e_notmp[25] ;
char_u e_notread[19] ;
char_u e_patnotf2[22] ;
char_u e_readonly[45] ;
char_u e_zerocount[11] ;
int p_confirm  ;
int p_ed  ;
char_u *p_ffs  ;
int p_gd  ;
char_u *p_hf  ;
long p_hh  ;
long p_report  ;
char_u *p_shq  ;
char_u *p_srr  ;
int p_warn  ;
int p_write  ;
int p_wa  ;
int mch_setperm(char_u *name___1 , long perm ) ;
void do_ascii(void) ;
void do_align(EXARG *eap ) ;
void do_retab(EXARG *eap ) ;
int do_move(linenr_t line1 , linenr_t line2 , linenr_t dest ) ;
void do_copy(linenr_t line1 , linenr_t line2 , linenr_t n ) ;
void do_bang(int addr_count , linenr_t line1 , linenr_t line2 , int forceit , char_u *arg ,
             int do_in , int do_out ) ;
void do_shell(char_u *cmd , int flags___0 ) ;
char_u *make_filter_cmd(char_u *cmd , char_u *itmp , char_u *otmp ) ;
int viminfo_error(char *message , char_u *line ) ;
int read_viminfo(char_u *file , int want_info , int want_marks , int forceit ) ;
void write_viminfo(char_u *file , int forceit ) ;
void do_fixdel(void) ;
void print_line_no_prefix(linenr_t lnum , int use_number ) ;
void print_line(linenr_t lnum , int use_number ) ;
void do_file(char_u *arg , int forceit ) ;
int do_write(EXARG *eap ) ;
void do_wnext(EXARG *eap ) ;
void do_wqall(EXARG *eap ) ;
int not_writing(void) ;
void do_append(linenr_t lnum , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int getl_break ) ;
void do_change(linenr_t start___0 , linenr_t end , char_u *(*getline___0)(int  , void * ,
                                                                          int  ) ,
               void *cookie , int getl_break ) ;
void do_z(linenr_t line , char_u *arg ) ;
int check_restricted(void) ;
int check_secure(void) ;
void do_sub(EXARG *eap ) ;
void do_glob(EXARG *eap ) ;
int read_viminfo_sub_string(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_sub_string(FILE *fp___0 ) ;
void prepare_tagpreview(void) ;
void do_help(EXARG *eap ) ;
int help_heuristic(char_u *matched_string , int offset , int wrong_case ) ;
int find_help_tags(char_u *arg , int *num_matches___0 , char_u ***matches___0 ) ;
void autowrite_all(void) ;
int check_changed(BUF *buf___3 , int checkaw , int mult_win , int forceit , int allbuf ) ;
int check_fname(void) ;
int buf_write_all(BUF *buf___3 ) ;
void not_exiting(void) ;
void do_argfile(EXARG *eap , int argn ) ;
void dialog_msg(char_u *buff , char *format , char_u *fname ) ;
void gotocmdline(int clr ) ;
void prepare_viminfo_history(int asklen ) ;
int read_viminfo_history(char_u *line , FILE *fp___0 ) ;
void finish_viminfo_history(void) ;
void write_viminfo_history(FILE *fp___0 ) ;
int buf_write(BUF *buf___3 , char_u *fname , char_u *sfname , linenr_t start___0 ,
              linenr_t end , int append , int forceit , int reset_changed , int filtering ) ;
char_u *buf_modname(int shortname , char_u *fname , char_u *ext , int prepend_dot ) ;
void write_lnum_adjust(linenr_t offset ) ;
int read_viminfo_filemark(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_filemarks(FILE *fp___0 ) ;
int write_viminfo_marks(FILE *fp_out ) ;
void copy_viminfo_marks(char_u *line , FILE *fp_in , FILE *fp_out , int count___2 ,
                        int eof ) ;
int smsg_attr(int attr , char_u *s  , ...) ;
int ml_delete(linenr_t lnum , int message ) ;
void ml_setmarked(linenr_t lnum ) ;
linenr_t ml_firstmarked(void) ;
void ml_clearmarked(void) ;
void wait_return(int redraw ) ;
int vim_dialog_yesno(int type , char_u *title , char_u *message , int dflt ) ;
void del_lines(long nlines , int dowindow , int undo ) ;
void msgmore(long n ) ;
int vim_fexists(char_u *fname ) ;
void adjust_cursor(void) ;
char_u *alloc_check(unsigned int size ) ;
void set_fileformat(int t ) ;
int default_fileformat(void) ;
int call_shell(char_u *cmd , int opt ) ;
void end_visual_mode(void) ;
int read_viminfo_register(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_registers(FILE *fp___0 ) ;
int get_viminfo_parameter(int type ) ;
void check_buf_options(BUF *buf___3 ) ;
void set_string_option_direct(char_u *name___1 , int opt_idx , char_u *val , int dofree ) ;
char_u *skip_regexp(char_u *p___0 , int dirc , int magic ) ;
char_u *regtilde(char_u *source , int magic ) ;
void vim_regnewptr(vim_regexp *prog , char_u *old_ptr , char_u *new_ptr ) ;
void windgoto(int row , int col ) ;
void invalidate_botline(void) ;
int botline_approximated(void) ;
int messaging(void) ;
vim_regexp *search_regcomp(char_u *pat , int pat_save , int pat_use , int options___0 ) ;
char_u *get_search_pat(void) ;
int read_viminfo_search_pattern(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_search_pattern(FILE *fp___0 ) ;
int do_tag(char_u *tag , int type , int count___2 , int forceit , int verbose ) ;
void starttermcap(void) ;
void stoptermcap(void) ;
int swapping_screen(void) ;
void cursor_on(void) ;
void add_termcode(char_u *name___1 , char_u *string___0 , int use_8bit ) ;
char_u *find_termcode(char_u *name___1 ) ;
int u_inssub(linenr_t lnum ) ;
void u_clearline(void) ;
void win_init(WIN *wp ) ;
void win_setheight(int height ) ;
void check_lnums(int do_curwin ) ;
static int linelen(int *has_tab ) ;
static void do_filter(linenr_t line1 , linenr_t line2 , char_u *cmd , int do_in ,
                      int do_out ) ;
static char_u *viminfo_filename(char_u *file ) ;
static void do_viminfo(FILE *fp_in , FILE *fp_out , int want_info , int want_marks ,
                       int force_read ) ;
static int read_viminfo_up_to_marks(char_u *line , FILE *fp___0 , int forceit , int writing ) ;
static int check_overwrite(EXARG *eap , BUF *buf___3 , char_u *fname , char_u *ffname ,
                           int other ) ;
static int check_readonly(int *forceit , BUF *buf___3 ) ;
static void delbuf_msg(char_u *name___1 ) ;
static int do_sub_msg(void) ;
static int help_compare(void const   *s1 , void const   *s2 ) ;
void do_ascii(void) 
{ 
  int c ;
  char buf1[20] ;
  char buf2[20] ;
  char_u buf3[3] ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  c = gchar_cursor();
  }
  if (c == 0) {
    {
    msg((char_u *)"empty line");
    }
    return;
  }
  if (c == 10) {
    c = '\000';
  }
  {
  tmp = vim_isprintc(c);
  }
  if (tmp) {
    if (c < 32) {
      {
      transchar_nonprint(buf3, c);
      sprintf((char * __restrict  )(buf1), (char const   * __restrict  )"  <%s>",
              (char *)(buf3));
      }
    } else { //Added block
    if (c > 126) {
      {
      transchar_nonprint(buf3, c);
      sprintf((char * __restrict  )(buf1), (char const   * __restrict  )"  <%s>",
              (char *)(buf3));
      }
    } else {
      buf1[0] = (char )'\000';
    }
    }
  } else {
    buf1[0] = (char )'\000';
  }
  if (c >= 128) {
    {
    tmp___0 = transchar(c & 127);
    sprintf((char * __restrict  )(buf2), (char const   * __restrict  )"  <M-%s>",
            tmp___0);
    }
  } else {
    buf2[0] = (char )'\000';
  }
  {
  tmp___1 = transchar(c);
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"<%s>%s%s  %d,  Hex %02x,  Octal %03o",
          tmp___1, buf1, buf2, c, c, c);
  msg(IObuff);
  }
  return;
}
}
void do_align(EXARG *eap ) 
{ 
  FPOS save_curpos ;
  int len___0 ;
  int indent ;
  int new_indent ;
  int has_tab ;
  int width ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  indent = 0;
  width = atoi((char const   *)((char *)eap->arg));
  save_curpos = curwin->w_cursor;
  }
  if ((int )eap->cmdidx == 127) {
    if (width >= 0) {
      indent = width;
    }
  } else {
    if (width <= 0) {
      width = (int )curbuf->b_p_tw;
    }
    if (width == 0) {
      if (curbuf->b_p_wm > 0L) {
        width = (int )(Columns - curbuf->b_p_wm);
      }
    }
    if (width <= 0) {
      width = 80;
    }
  }
  {
  tmp = u_save(eap->line1 - 1L, eap->line2 + 1L);
  }
  if (tmp == 0) {
    return;
  }
  {
  syn_changed(eap->line1);
  curwin->w_cursor.lnum = eap->line1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curwin->w_cursor.lnum <= eap->line2)) {
      goto while_break;
    }
    if ((int )eap->cmdidx == 127) {
      new_indent = indent;
    } else {
      if ((int )eap->cmdidx == 200) {
        tmp___0 = & has_tab;
      } else {
        tmp___0 = (int *)((void *)0);
      }
      {
      tmp___1 = linelen(tmp___0);
      tmp___2 = get_indent();
      len___0 = tmp___1 - tmp___2;
      }
      if (len___0 <= 0) {
        goto __Cont;
      }
      if ((int )eap->cmdidx == 34) {
        new_indent = (width - len___0) / 2;
      } else {
        new_indent = width - len___0;
        if (has_tab) {
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (new_indent > 0)) {
              goto while_break___0;
            }
            {
            set_indent(new_indent, 1);
            tmp___4 = linelen((int *)((void *)0));
            }
            if (tmp___4 <= width) {
              {
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
                new_indent ++;
                set_indent(new_indent, 1);
                tmp___3 = linelen((int *)((void *)0));
                }
                if (! (tmp___3 <= width)) {
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
              new_indent --;
              goto while_break___0;
            }
            new_indent --;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
    if (new_indent < 0) {
      new_indent = 0;
    }
    {
    set_indent(new_indent, 1);
    }
    __Cont: 
    (curwin->w_cursor.lnum) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  curwin->w_cursor = save_curpos;
  beginline(5);
  }
  if (curwin->w_cursor.lnum > eap->line1) {
    {
    changed_line_abv_curs();
    invalidate_botline();
    }
  } else { //Added block
  if (curwin->w_cursor.lnum == eap->line1) {
    {
    changed_cline_bef_curs();
    }
  }
  }
  {
  tmp___5 = botline_approximated();
  }
  if (tmp___5) {
    if (eap->line1 < curwin->w_botline) {
      {
      approximate_botline();
      }
    }
  }
  {
  update_screen(40);
  }
  return;
}
}
static int linelen(int *has_tab ) 
{ 
  char_u *line ;
  char_u *first___0 ;
  char_u *last ;
  int save ;
  int len___0 ;
  size_t tmp ;
  char_u *tmp___0 ;

  {
  {
  line = ml_get_curline();
  first___0 = skipwhite(line);
  tmp = strlen((char const   *)((char *)first___0));
  last = first___0 + tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )last > (unsigned long )first___0) {
      if (! ((int )*(last + -1) == 32)) {
        if (! ((int )*(last + -1) == 9)) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
    last --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  save = (int )*last;
  *last = (char_u )'\000';
  len___0 = linetabsize(line);
  }
  if ((unsigned long )has_tab != (unsigned long )((void *)0)) {
    {
    tmp___0 = vim_strrchr(first___0, '\t');
    *has_tab = (unsigned long )tmp___0 != (unsigned long )((void *)0);
    }
  }
  *last = (char_u )save;
  return (len___0);
}
}
void do_retab(EXARG *eap ) 
{ 
  linenr_t lnum ;
  int got_tab ;
  long num_spaces ;
  long num_tabs ;
  long len___0 ;
  long col ;
  long vcol ;
  long start_col ;
  long start_vcol ;
  int temp ;
  long old_len ;
  char_u *ptr ;
  char_u *new_line ;
  int did_something ;
  int did_undo ;
  int new_ts ;
  int save_list ;
  long tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
  got_tab = 0;
  num_spaces = 0L;
  start_col = 0L;
  start_vcol = 0L;
  new_line = (char_u *)1;
  did_something = 0;
  save_list = curwin->w_p_list;
  curwin->w_p_list = 0;
  syn_changed(eap->line1);
  tmp = getdigits(& eap->arg);
  new_ts = (int )tmp;
  }
  if (new_ts == 0) {
    new_ts = (int )curbuf->b_p_ts;
  }
  lnum = eap->line1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! got_int) {
      if (! (lnum <= eap->line2)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    ptr = ml_get(lnum);
    col = 0L;
    vcol = 0L;
    did_undo = 0;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((int )*(ptr + col) == 32) {
        goto _L___1;
      } else { //Added block
      if ((int )*(ptr + col) == 9) {
        _L___1: 
        if (! got_tab) {
          if (num_spaces == 0L) {
            start_vcol = vcol;
            start_col = col;
          }
        }
        if ((int )*(ptr + col) == 32) {
          num_spaces ++;
        } else {
          got_tab = 1;
        }
      } else {
        if (got_tab) {
          goto _L___0;
        } else { //Added block
        if (eap->forceit) {
          if (num_spaces > 1L) {
            _L___0: 
            num_spaces = vcol - start_vcol;
            len___0 = num_spaces;
            num_tabs = 0L;
            if (! curbuf->b_p_et) {
              temp = (int )((long )new_ts - start_vcol % (long )new_ts);
              if (num_spaces >= (long )temp) {
                num_spaces -= (long )temp;
                num_tabs ++;
              }
              num_tabs += num_spaces / (long )new_ts;
              num_spaces -= (num_spaces / (long )new_ts) * (long )new_ts;
            }
            if (curbuf->b_p_et) {
              goto _L;
            } else { //Added block
            if (got_tab) {
              goto _L;
            } else { //Added block
            if (num_spaces + num_tabs < len___0) {
              _L: 
              if (did_undo == 0) {
                {
                did_undo = 1;
                tmp___0 = u_save(lnum - 1L, lnum + 1L);
                }
                if (tmp___0 == 0) {
                  new_line = (char_u *)((void *)0);
                  goto while_break___0;
                }
              }
              {
              len___0 = num_spaces + num_tabs;
              tmp___1 = strlen((char const   *)((char *)ptr));
              old_len = (long )tmp___1;
              new_line = lalloc((long_u )((((old_len - col) + start_col) + len___0) + 1L),
                                1);
              }
              if ((unsigned long )new_line == (unsigned long )((void *)0)) {
                goto while_break___0;
              }
              if (start_col > 0L) {
                {
                memmove((void *)((char *)new_line), (void const   *)((char *)ptr),
                        (size_t )start_col);
                }
              }
              {
              memmove((void *)((char *)((new_line + start_col) + len___0)), (void const   *)((char *)(ptr + col)),
                      (size_t )((old_len - col) + 1L));
              ptr = new_line + start_col;
              col = 0L;
              }
              {
              while (1) {
                while_continue___1: /* CIL Label */ ;
                if (! (col < len___0)) {
                  goto while_break___1;
                }
                if (col < num_tabs) {
                  *(ptr + col) = (char_u )'\t';
                } else {
                  *(ptr + col) = (char_u )' ';
                }
                col ++;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
              ml_replace(lnum, new_line, 0);
              did_something = 1;
              ptr = new_line;
              col = start_col + len___0;
              }
            }
            }
            }
          }
        }
        }
        got_tab = 0;
        num_spaces = 0L;
      }
      }
      if ((int )*(ptr + col) == 0) {
        goto while_break___0;
      }
      {
      tmp___2 = col;
      col ++;
      tmp___3 = chartabsize((int )*(ptr + tmp___2), (colnr_t )vcol);
      vcol += (long )tmp___3;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )new_line == (unsigned long )((void *)0)) {
      goto while_break;
    }
    {
    line_breakcheck();
    lnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (got_int) {
    {
    emsg(e_interr);
    }
  }
  if (did_something) {
    {
    changed();
    }
  }
  curwin->w_p_list = save_list;
  if (curbuf->b_p_ts != (long )new_ts) {
    goto _L___2;
  } else { //Added block
  if (did_something) {
    _L___2: 
    if (curbuf->b_p_ts != (long )new_ts) {
      {
      changed_line_abv_curs();
      }
    } else { //Added block
    if (eap->line1 < curwin->w_cursor.lnum) {
      {
      changed_line_abv_curs();
      }
    } else { //Added block
    if (eap->line1 == curwin->w_cursor.lnum) {
      {
      changed_cline_bef_curs();
      }
    }
    }
    }
    {
    approximate_botline();
    }
  }
  }
  {
  curbuf->b_p_ts = (long )new_ts;
  coladvance(curwin->w_curswant);
  u_clearline();
  update_screen(40);
  }
  return;
}
}
int do_move(linenr_t line1 , linenr_t line2 , linenr_t dest ) 
{ 
  char_u *str___1 ;
  linenr_t l ;
  linenr_t extra ;
  linenr_t num_lines ;
  linenr_t last_line ;
  int tmp ;
  char_u *tmp___0 ;
  colnr_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  if (dest >= line1) {
    if (dest < line2) {
      {
      emsg((char_u *)"Move lines into themselves");
      }
      return (0);
    }
  }
  {
  num_lines = (line2 - line1) + 1L;
  tmp = u_save(dest, dest + 1L);
  }
  if (tmp == 0) {
    return (0);
  }
  extra = (linenr_t )0;
  l = line1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (l <= line2)) {
      goto while_break;
    }
    {
    tmp___0 = ml_get(l + extra);
    str___1 = vim_strsave(tmp___0);
    }
    if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
      {
      ml_append((dest + l) - line1, str___1, (colnr_t )0, 0);
      vim_free((void *)str___1);
      }
      if (dest < line1) {
        extra ++;
      }
    }
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  last_line = curbuf->b_ml.ml_line_count;
  mark_adjust(line1, line2, last_line - line2, 0L);
  }
  if (dest >= line2) {
    {
    mark_adjust(line2 + 1L, dest, - num_lines, 0L);
    curbuf->b_op_start.lnum = (dest - num_lines) + 1L;
    curbuf->b_op_end.lnum = dest;
    }
  } else {
    {
    mark_adjust(dest + 1L, line1 - 1L, num_lines, 0L);
    curbuf->b_op_start.lnum = dest + 1L;
    curbuf->b_op_end.lnum = dest + num_lines;
    }
  }
  {
  tmp___1 = (colnr_t )0;
  curbuf->b_op_end.col = tmp___1;
  curbuf->b_op_start.col = tmp___1;
  mark_adjust((last_line - num_lines) + 1L, last_line, - ((last_line - dest) - extra),
              0L);
  tmp___2 = u_save((line1 + extra) - 1L, (line2 + extra) + 1L);
  }
  if (tmp___2 == 0) {
    return (0);
  }
  l = line1;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (l <= line2)) {
      goto while_break___0;
    }
    {
    ml_delete(line1 + extra, 1);
    l ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  changed();
  }
  if (! global_busy) {
    if (num_lines > p_report) {
      {
      tmp___3 = plural(num_lines);
      smsg((char_u *)"%ld line%s moved", num_lines, tmp___3);
      }
    }
  }
  if (dest >= line1) {
    curwin->w_cursor.lnum = dest;
  } else {
    curwin->w_cursor.lnum = (dest + (line2 - line1)) + 1L;
  }
  {
  changed_line_abv_curs();
  invalidate_botline();
  }
  return (1);
}
}
void do_copy(linenr_t line1 , linenr_t line2 , linenr_t n ) 
{ 
  linenr_t lnum ;
  char_u *p___0 ;
  colnr_t tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  lnum = (line2 - line1) + 1L;
  mark_adjust(n + 1L, (linenr_t )2147483647, lnum, 0L);
  curbuf->b_op_start.lnum = n + 1L;
  curbuf->b_op_end.lnum = n + lnum;
  tmp = (colnr_t )0;
  curbuf->b_op_end.col = tmp;
  curbuf->b_op_start.col = tmp;
  tmp___0 = u_save(n, n + 1L);
  }
  if (tmp___0 == 0) {
    return;
  }
  curwin->w_cursor.lnum = n;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (line1 <= line2)) {
      goto while_break;
    }
    {
    tmp___1 = ml_get(line1);
    p___0 = vim_strsave(tmp___1);
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      {
      ml_append(curwin->w_cursor.lnum, p___0, (colnr_t )0, 0);
      vim_free((void *)p___0);
      }
    }
    if (line1 == n) {
      line1 = curwin->w_cursor.lnum;
    }
    line1 ++;
    if (curwin->w_cursor.lnum < line1) {
      line1 ++;
    }
    if (curwin->w_cursor.lnum < line2) {
      line2 ++;
    }
    (curwin->w_cursor.lnum) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  changed();
  changed_line_abv_curs();
  invalidate_botline();
  msgmore(lnum);
  }
  return;
}
}
static char_u *prevcmd  =    (char_u *)((void *)0);
void do_bang(int addr_count , linenr_t line1 , linenr_t line2 , int forceit , char_u *arg ,
             int do_in , int do_out ) 
{ 
  char_u *newcmd ;
  int free_newcmd ;
  int ins_prevcmd ;
  char_u *t ;
  char_u *p___0 ;
  char_u *trailarg ;
  int len___0 ;
  int scroll_save ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char_u *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
  newcmd = (char_u *)((void *)0);
  free_newcmd = 0;
  scroll_save = msg_scroll;
  tmp = check_restricted();
  }
  if (tmp) {
    return;
  } else {
    {
    tmp___0 = check_secure();
    }
    if (tmp___0) {
      return;
    }
  }
  if (addr_count == 0) {
    {
    msg_scroll = 0;
    autowrite_all();
    msg_scroll = scroll_save;
    }
  }
  ins_prevcmd = forceit;
  trailarg = arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___1 = strlen((char const   *)((char *)trailarg));
    len___0 = (int )(tmp___1 + 1UL);
    }
    if ((unsigned long )newcmd != (unsigned long )((void *)0)) {
      {
      tmp___2 = strlen((char const   *)((char *)newcmd));
      len___0 = (int )((size_t )len___0 + tmp___2);
      }
    }
    if (ins_prevcmd) {
      if ((unsigned long )prevcmd == (unsigned long )((void *)0)) {
        {
        emsg(e_noprev);
        vim_free((void *)newcmd);
        }
        return;
      }
      {
      tmp___3 = strlen((char const   *)((char *)prevcmd));
      len___0 = (int )((size_t )len___0 + tmp___3);
      }
    }
    {
    t = alloc((unsigned int )len___0);
    }
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
      vim_free((void *)newcmd);
      }
      return;
    }
    *t = (char_u )'\000';
    if ((unsigned long )newcmd != (unsigned long )((void *)0)) {
      {
      strcat((char * __restrict  )((char *)t), (char const   * __restrict  )((char *)newcmd));
      }
    }
    if (ins_prevcmd) {
      {
      strcat((char * __restrict  )((char *)t), (char const   * __restrict  )((char *)prevcmd));
      }
    }
    {
    tmp___4 = strlen((char const   *)((char *)t));
    p___0 = t + tmp___4;
    strcat((char * __restrict  )((char *)t), (char const   * __restrict  )((char *)trailarg));
    vim_free((void *)newcmd);
    newcmd = t;
    trailarg = (char_u *)((void *)0);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break___0;
      }
      if ((int )*p___0 == 33) {
        if ((unsigned long )p___0 > (unsigned long )newcmd) {
          if ((int )*(p___0 + -1) == 92) {
            {
            tmp___5 = strlen((char const   *)((char *)p___0));
            memmove((void *)((char *)(p___0 - 1)), (void const   *)((char *)p___0),
                    tmp___5 + 1UL);
            }
          } else {
            goto _L;
          }
        } else {
          _L: 
          trailarg = p___0;
          tmp___6 = trailarg;
          trailarg ++;
          *tmp___6 = (char_u )'\000';
          ins_prevcmd = 1;
          goto while_break___0;
        }
      }
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (! ((unsigned long )trailarg != (unsigned long )((void *)0))) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)prevcmd);
  prevcmd = newcmd;
  }
  if (bangredo) {
    {
    AppendToRedobuff(prevcmd);
    AppendToRedobuff((char_u *)"\n");
    bangredo = 0;
    }
  }
  if ((int )*p_shq != 0) {
    {
    tmp___7 = strlen((char const   *)((char *)prevcmd));
    tmp___8 = strlen((char const   *)((char *)p_shq));
    newcmd = alloc((unsigned int )((tmp___7 + 2UL * tmp___8) + 1UL));
    }
    if ((unsigned long )newcmd == (unsigned long )((void *)0)) {
      return;
    }
    {
    strcpy((char * __restrict  )((char *)newcmd), (char const   * __restrict  )((char *)p_shq));
    strcat((char * __restrict  )((char *)newcmd), (char const   * __restrict  )((char *)prevcmd));
    strcat((char * __restrict  )((char *)newcmd), (char const   * __restrict  )((char *)p_shq));
    free_newcmd = 1;
    }
  }
  if (addr_count == 0) {
    {
    msg_start();
    msg_putchar(':');
    msg_putchar('!');
    msg_outtrans(newcmd);
    msg_clr_eos();
    windgoto(msg_row, msg_col);
    do_shell(newcmd, 0);
    }
  } else {
    {
    do_filter(line1, line2, newcmd, do_in, do_out);
    }
  }
  if (free_newcmd) {
    {
    vim_free((void *)newcmd);
    }
  }
  return;
}
}
void do_shell(char_u *cmd , int flags___0 ) 
{ 
  BUF *buf___3 ;
  int save_nwr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = check_restricted();
  }
  if (tmp) {
    {
    msg_end();
    }
    return;
  } else {
    {
    tmp___0 = check_secure();
    }
    if (tmp___0) {
      {
      msg_end();
      }
      return;
    }
  }
  {
  msg_putchar('\r');
  }
  if (! autocmd_busy) {
    {
    stoptermcap();
    }
  }
  {
  msg_putchar('\n');
  }
  if (p_warn) {
    if (! autocmd_busy) {
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! buf___3) {
          goto while_break;
        }
        {
        tmp___1 = buf_changed(buf___3);
        }
        if (tmp___1) {
          {
          msg_puts((char_u *)"[No write since last change]\n");
          }
          goto while_break;
        }
        buf___3 = buf___3->b_next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
  tmp___2 = swapping_screen();
  }
  if (! tmp___2) {
    {
    windgoto(msg_row, msg_col);
    }
  }
  {
  cursor_on();
  call_shell(cmd, 4 | flags___0);
  need_check_timestamps = 1;
  tmp___3 = swapping_screen();
  }
  if (! tmp___3) {
    msg_row = (int )(Rows - 1L);
    msg_col = 0;
  }
  if (autocmd_busy) {
    must_redraw = 50;
  } else {
    if ((unsigned long )cmd == (unsigned long )((void *)0)) {
      must_redraw = 50;
      need_wait_return = 0;
    } else {
      {
      save_nwr = no_wait_return;
      tmp___4 = swapping_screen();
      }
      if (tmp___4) {
        no_wait_return = 0;
      }
      {
      wait_return(1);
      no_wait_return = save_nwr;
      }
    }
    {
    starttermcap();
    }
  }
  {
  fflush(stderr);
  }
  return;
}
}
static void do_filter(linenr_t line1 , linenr_t line2 , char_u *cmd , int do_in ,
                      int do_out ) 
{ 
  char_u *itmp ;
  char_u *otmp ;
  linenr_t linecount ;
  FPOS cursor_save ;
  char_u *cmd_buf ;
  BUF *old_curbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  itmp = (char_u *)((void *)0);
  otmp = (char_u *)((void *)0);
  old_curbuf = curbuf;
  if ((int )*cmd == 0) {
    return;
  }
  {
  cursor_save = curwin->w_cursor;
  linecount = (line2 - line1) + 1L;
  curwin->w_cursor.lnum = line1;
  curwin->w_cursor.col = (colnr_t )0;
  changed_line_abv_curs();
  invalidate_botline();
  }
  if (do_in) {
    {
    itmp = vim_tempname('i');
    }
    if ((unsigned long )itmp == (unsigned long )((void *)0)) {
      {
      emsg(e_notmp);
      }
      goto filterend;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (do_out) {
    {
    otmp = vim_tempname('o');
    }
    if ((unsigned long )otmp == (unsigned long )((void *)0)) {
      {
      emsg(e_notmp);
      }
      goto filterend;
    }
  }
  }
  no_wait_return ++;
  if (do_in) {
    {
    tmp = buf_write(curbuf, itmp, (char_u *)((void *)0), line1, line2, 0, 0, 0, 1);
    }
    if (tmp == 0) {
      {
      msg_putchar('\n');
      no_wait_return --;
      emsg2(e_notcreate, itmp);
      }
      goto filterend;
    }
  }
  if ((unsigned long )curbuf != (unsigned long )old_curbuf) {
    goto filterend;
  }
  if (! do_out) {
    {
    msg_putchar('\n');
    }
  }
  {
  cmd_buf = make_filter_cmd(cmd, itmp, otmp);
  }
  if ((unsigned long )cmd_buf == (unsigned long )((void *)0)) {
    goto filterend;
  }
  {
  windgoto((int )Rows - 1, 0);
  cursor_on();
  }
  if (! do_out) {
    must_redraw = 50;
  } else {
    {
    tmp___0 = strcmp((char const   *)((char *)p_srr), (char const   *)((char *)">"));
    }
    if (tmp___0 == 0) {
      must_redraw = 50;
    } else { //Added block
    if (! do_in) {
      must_redraw = 50;
    } else {
      {
      redraw_later(40);
      }
    }
    }
  }
  if (do_out) {
    tmp___1 = 8;
  } else {
    tmp___1 = 0;
  }
  {
  tmp___2 = call_shell(cmd_buf, 5 | tmp___1);
  }
  if (tmp___2) {
    {
    must_redraw = 50;
    wait_return(0);
    }
  }
  {
  vim_free((void *)cmd_buf);
  need_check_timestamps = 1;
  }
  if (do_out) {
    {
    tmp___3 = u_save(line2, line2 + 1L);
    }
    if (tmp___3 == 0) {
      goto error;
    }
    {
    tmp___4 = readfile(otmp, (char_u *)((void *)0), line2, (linenr_t )0, (linenr_t )2147483647,
                       2);
    }
    if (tmp___4 == 0) {
      {
      msg_putchar('\n');
      emsg2(e_notread, otmp);
      }
      goto error;
    }
    if ((unsigned long )curbuf != (unsigned long )old_curbuf) {
      goto filterend;
    }
    if (do_in) {
      {
      curwin->w_cursor.lnum = line1;
      del_lines(linecount, 1, 1);
      curbuf->b_op_start.lnum -= linecount;
      curbuf->b_op_end.lnum -= linecount;
      write_lnum_adjust(- linecount);
      }
    } else {
      curwin->w_cursor.lnum = curbuf->b_op_end.lnum;
      linecount = (curbuf->b_op_end.lnum - curbuf->b_op_start.lnum) + 1L;
    }
    {
    beginline(5);
    no_wait_return --;
    }
    if (linecount > p_report) {
      if (do_in) {
        {
        sprintf((char * __restrict  )((char *)(msg_buf)), (char const   * __restrict  )"%ld lines filtered",
                linecount);
        tmp___5 = msg(msg_buf);
        }
        if (tmp___5) {
          if (! msg_scroll) {
            keep_msg = msg_buf;
            keep_msg_attr = 0;
          }
        }
      } else {
        {
        msgmore(linecount);
        }
      }
    }
  } else {
    error: 
    {
    curwin->w_cursor = cursor_save;
    no_wait_return --;
    wait_return(0);
    }
  }
  filterend: 
  if ((unsigned long )curbuf != (unsigned long )old_curbuf) {
    {
    no_wait_return --;
    emsg((char_u *)"*Filter* Autocommands must not change current buffer");
    }
  }
  if ((unsigned long )itmp != (unsigned long )((void *)0)) {
    {
    unlink((char const   *)((char *)itmp));
    }
  }
  if ((unsigned long )otmp != (unsigned long )((void *)0)) {
    {
    unlink((char const   *)((char *)otmp));
    }
  }
  {
  vim_free((void *)itmp);
  vim_free((void *)otmp);
  }
  return;
}
}
char_u *make_filter_cmd(char_u *cmd , char_u *itmp , char_u *otmp ) 
{ 
  char_u *buf___3 ;
  long_u len___0 ;
  char_u *p___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char_u *tmp___4 ;
  size_t tmp___5 ;

  {
  {
  tmp = strlen((char const   *)((char *)cmd));
  len___0 = tmp + 3UL;
  }
  if ((unsigned long )itmp != (unsigned long )((void *)0)) {
    {
    tmp___0 = strlen((char const   *)((char *)itmp));
    len___0 += tmp___0 + 8UL;
    }
  }
  if ((unsigned long )otmp != (unsigned long )((void *)0)) {
    {
    tmp___1 = strlen((char const   *)((char *)otmp));
    tmp___2 = strlen((char const   *)((char *)p_srr));
    len___0 += (tmp___1 + tmp___2) + 2UL;
    }
  }
  {
  buf___3 = lalloc(len___0, 1);
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  sprintf((char * __restrict  )((char *)buf___3), (char const   * __restrict  )"(%s)",
          (char *)cmd);
  }
  if ((unsigned long )itmp != (unsigned long )((void *)0)) {
    {
    strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)" < "));
    strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)itmp));
    }
  }
  if ((unsigned long )otmp != (unsigned long )((void *)0)) {
    {
    p___0 = vim_strchr(p_srr, '%');
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      if ((int )*(p___0 + 1) == 115) {
        {
        tmp___3 = strlen((char const   *)((char *)buf___3));
        p___0 = buf___3 + tmp___3;
        tmp___4 = p___0;
        p___0 ++;
        *tmp___4 = (char_u )' ';
        sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)p_srr),
                (char *)otmp);
        }
      } else {
        {
        tmp___5 = strlen((char const   *)((char *)buf___3));
        sprintf((char * __restrict  )((char *)buf___3 + tmp___5), (char const   * __restrict  )" %s%s",
                (char *)p_srr, (char *)otmp);
        }
      }
    } else {
      {
      tmp___5 = strlen((char const   *)((char *)buf___3));
      sprintf((char * __restrict  )((char *)buf___3 + tmp___5), (char const   * __restrict  )" %s%s",
              (char *)p_srr, (char *)otmp);
      }
    }
  }
  return (buf___3);
}
}
static int no_viminfo(void) ;
static int viminfo_errcnt  ;
static int no_viminfo(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )use_viminfo != (unsigned long )((void *)0)) {
    {
    tmp = strcmp((char const   *)((char *)use_viminfo), (char const   *)((char *)"NONE"));
    }
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int viminfo_error(char *message , char_u *line ) 
{ 
  size_t tmp ;

  {
  {
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"viminfo: %s in line: ",
          message);
  tmp = strlen((char const   *)((char *)IObuff));
  strncat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)line),
          1025UL - tmp);
  emsg(IObuff);
  viminfo_errcnt ++;
  }
  if (viminfo_errcnt >= 10) {
    {
    emsg((char_u *)"viminfo: Too many errors, skipping rest of file");
    }
    return (1);
  }
  return (0);
}
}
int read_viminfo(char_u *file , int want_info , int want_marks , int forceit ) 
{ 
  FILE *fp___0 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  tmp = no_viminfo();
  }
  if (tmp) {
    return (0);
  }
  {
  file = viminfo_filename(file);
  fp___0 = fopen((char const   * __restrict  )((char *)file), (char const   * __restrict  )"r");
  }
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    return (0);
  }
  if (p_verbose > 0L) {
    if (want_marks) {
      tmp___0 = " marks";
    } else {
      tmp___0 = "";
    }
    if (want_info) {
      tmp___1 = " info";
    } else {
      tmp___1 = "";
    }
    {
    smsg((char_u *)"Reading viminfo file \"%s\"%s%s", file, tmp___1, tmp___0);
    }
  }
  {
  viminfo_errcnt = 0;
  do_viminfo(fp___0, (FILE *)((void *)0), want_info, want_marks, forceit);
  fclose(fp___0);
  }
  return (1);
}
}
void write_viminfo(char_u *file , int forceit ) 
{ 
  FILE *fp_in ;
  FILE *fp_out ;
  char_u *tempname ;
  struct stat st_new ;
  char_u *wp ;
  mode_t umask_save ;
  int shortname ;
  struct stat st_old ;
  int tmp ;
  int tmp___0 ;
  int tt ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  unsigned int tmp___5 ;
  __gid_t tmp___6 ;
  unsigned int tmp___7 ;
  __uid_t tmp___8 ;
  size_t tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  char_u *tmp___14 ;
  int tmp___15 ;

  {
  {
  fp_in = (FILE *)((void *)0);
  fp_out = (FILE *)((void *)0);
  tempname = (char_u *)((void *)0);
  shortname = 0;
  tmp = no_viminfo();
  }
  if (tmp) {
    return;
  }
  {
  file = viminfo_filename(file);
  file = vim_strsave(file);
  }
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
    fp_in = fopen((char const   * __restrict  )((char *)file), (char const   * __restrict  )"r");
    }
    if ((unsigned long )fp_in == (unsigned long )((void *)0)) {
      {
      tmp___0 = stat((char const   * __restrict  )((char *)file), (struct stat * __restrict  )(& st_new));
      }
      if (tmp___0 == 0) {
        goto end;
      }
      {
      umask_save = umask((__mode_t )63);
      fp_out = fopen((char const   * __restrict  )((char *)file), (char const   * __restrict  )"w");
      umask(umask_save);
      }
    } else {
      {
      st_old.st_ino = (__ino_t )0;
      st_old.st_dev = st_old.st_ino;
      st_old.st_mode = (__mode_t )384;
      tmp___1 = stat((char const   * __restrict  )((char *)file), (struct stat * __restrict  )(& st_old));
      }
      if (tmp___1 == 0) {
        {
        tmp___2 = getuid();
        }
        if (tmp___2) {
          {
          tmp___8 = getuid();
          }
          if (st_old.st_uid == tmp___8) {
            tmp___7 = st_old.st_mode & 128U;
          } else {
            {
            tmp___6 = getgid();
            }
            if (st_old.st_gid == tmp___6) {
              tmp___5 = st_old.st_mode & 16U;
            } else {
              tmp___5 = st_old.st_mode & 2U;
            }
            tmp___7 = tmp___5;
          }
          if (! tmp___7) {
            {
            tt = msg_didany;
            emsg2((char_u *)"Viminfo file is not writable: %s", file);
            msg_didany = tt;
            }
            goto end;
          }
        }
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        tempname = buf_modname(shortname, file, (char_u *)".tmp", 0);
        }
        if ((unsigned long )tempname == (unsigned long )((void *)0)) {
          goto while_break;
        }
        {
        tmp___12 = stat((char const   * __restrict  )((char *)tempname), (struct stat * __restrict  )(& st_new));
        }
        if (tmp___12 == 0) {
          if (! shortname) {
            if (st_new.st_dev == st_old.st_dev) {
              if (st_new.st_ino == st_old.st_ino) {
                {
                vim_free((void *)tempname);
                tempname = (char_u *)((void *)0);
                shortname = 1;
                }
                goto __Cont;
              }
            }
          }
          {
          tmp___9 = strlen((char const   *)((char *)tempname));
          wp = (tempname + tmp___9) - 5;
          tmp___10 = gettail(tempname);
          }
          if ((unsigned long )wp < (unsigned long )tmp___10) {
            {
            wp = gettail(tempname);
            }
          }
          *wp = (char_u )'z';
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
            tmp___11 = stat((char const   * __restrict  )((char *)tempname), (struct stat * __restrict  )(& st_new));
            }
            if (! (tmp___11 == 0)) {
              goto while_break___0;
            }
            if ((int )*wp == 97) {
              {
              vim_free((void *)tempname);
              tempname = (char_u *)((void *)0);
              }
              goto while_break___0;
            }
            *wp = (char_u )((int )*wp - 1);
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        goto while_break;
        __Cont: ;
      }
      while_break: /* CIL Label */ ;
      }
      if ((unsigned long )tempname != (unsigned long )((void *)0)) {
        {
        fp_out = fopen((char const   * __restrict  )((char *)tempname), (char const   * __restrict  )"w");
        }
        if ((unsigned long )fp_out == (unsigned long )((void *)0)) {
          {
          vim_free((void *)tempname);
          tempname = vim_tempname('o');
          }
          if ((unsigned long )tempname != (unsigned long )((void *)0)) {
            {
            fp_out = fopen((char const   * __restrict  )((char *)tempname), (char const   * __restrict  )"w");
            }
          }
        }
        if ((unsigned long )fp_out != (unsigned long )((void *)0)) {
          {
          mch_setperm(tempname, (long )((st_old.st_mode & 511U) | 384U));
          chown((char const   *)((char *)tempname), st_old.st_uid, st_old.st_gid);
          }
        }
      }
    }
  }
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if ((unsigned long )fp_out == (unsigned long )((void *)0)) {
    _L: 
    if ((unsigned long )file == (unsigned long )((void *)0)) {
      tmp___14 = (char_u *)"";
    } else {
      if ((unsigned long )fp_in == (unsigned long )((void *)0)) {
        tmp___13 = file;
      } else {
        tmp___13 = tempname;
      }
      tmp___14 = tmp___13;
    }
    {
    emsg2((char_u *)"Can\'t write viminfo file %s!", tmp___14);
    }
    if ((unsigned long )fp_in != (unsigned long )((void *)0)) {
      {
      fclose(fp_in);
      }
    }
    goto end;
  }
  }
  if (p_verbose > 0L) {
    {
    smsg((char_u *)"Writing viminfo file \"%s\"", file);
    }
  }
  {
  viminfo_errcnt = 0;
  do_viminfo(fp_in, fp_out, ! forceit, ! forceit, 0);
  fclose(fp_out);
  }
  if ((unsigned long )fp_in != (unsigned long )((void *)0)) {
    {
    fclose(fp_in);
    }
    if (viminfo_errcnt) {
      {
      unlink((char const   *)((char *)tempname));
      }
    } else {
      {
      tmp___15 = vim_rename(tempname, file);
      }
      if (tmp___15 == -1) {
        {
        unlink((char const   *)((char *)tempname));
        }
      }
    }
  }
  end: 
  {
  vim_free((void *)file);
  vim_free((void *)tempname);
  }
  return;
}
}
static char_u *viminfo_filename(char_u *file ) 
{ 


  {
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if ((int )*file == 0) {
    _L: 
    if ((unsigned long )use_viminfo != (unsigned long )((void *)0)) {
      file = use_viminfo;
    } else {
      {
      file = find_viminfo_parameter('n');
      }
      if ((unsigned long )file == (unsigned long )((void *)0)) {
        file = (char_u *)"$HOME/.viminfo";
      } else { //Added block
      if ((int )*file == 0) {
        file = (char_u *)"$HOME/.viminfo";
      }
      }
    }
    {
    expand_env(file, NameBuff, 1024);
    }
    return (NameBuff);
  }
  }
  return (file);
}
}
static void do_viminfo(FILE *fp_in , FILE *fp_out , int want_info , int want_marks ,
                       int force_read ) 
{ 
  int count___2 ;
  int eof ;
  char_u *line ;

  {
  {
  count___2 = 0;
  eof = 0;
  line = alloc(512U);
  }
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )fp_in != (unsigned long )((void *)0)) {
    if (want_info) {
      {
      eof = read_viminfo_up_to_marks(line, fp_in, force_read, (unsigned long )fp_out != (unsigned long )((void *)0));
      }
    } else {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        eof = vim_fgets(line, 512, fp_in);
        }
        if (eof) {
          goto while_break;
        } else { //Added block
        if (! ((int )*(line + 0) != 62)) {
          goto while_break;
        }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  if ((unsigned long )fp_out != (unsigned long )((void *)0)) {
    {
    fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"# This viminfo file was generated by vim\n");
    fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"# You may edit it if you\'re careful!\n\n");
    write_viminfo_search_pattern(fp_out);
    write_viminfo_sub_string(fp_out);
    write_viminfo_history(fp_out);
    write_viminfo_registers(fp_out);
    write_viminfo_varlist(fp_out);
    write_viminfo_filemarks(fp_out);
    write_viminfo_bufferlist(fp_out);
    count___2 = write_viminfo_marks(fp_out);
    }
  }
  if ((unsigned long )fp_in != (unsigned long )((void *)0)) {
    if (want_marks) {
      {
      copy_viminfo_marks(line, fp_in, fp_out, count___2, eof);
      }
    }
  }
  {
  vim_free((void *)line);
  }
  return;
}
}
static int read_viminfo_up_to_marks(char_u *line , FILE *fp___0 , int forceit , int writing ) 
{ 
  int eof ;
  int tmp ;
  int tmp___0 ;

  {
  if (forceit) {
    tmp = 9999;
  } else {
    tmp = 0;
  }
  {
  prepare_viminfo_history(tmp);
  eof = vim_fgets(line, 512, fp___0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! eof) {
      if (! ((int )*(line + 0) != 62)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    if ((int )*(line + 0) == 43) {
      goto case_43;
    }
    if ((int )*(line + 0) == 124) {
      goto case_43;
    }
    if ((int )*(line + 0) == 45) {
      goto case_43;
    }
    if ((int )*(line + 0) == 94) {
      goto case_43;
    }
    if ((int )*(line + 0) == 42) {
      goto case_43;
    }
    if ((int )*(line + 0) == 60) {
      goto case_43;
    }
    if ((int )*(line + 0) == 0) {
      goto case_43;
    }
    if ((int )*(line + 0) == 13) {
      goto case_43;
    }
    if ((int )*(line + 0) == 10) {
      goto case_43;
    }
    if ((int )*(line + 0) == 35) {
      goto case_43;
    }
    if ((int )*(line + 0) == 33) {
      goto case_33;
    }
    if ((int )*(line + 0) == 37) {
      goto case_37;
    }
    if ((int )*(line + 0) == 34) {
      goto case_34;
    }
    if ((int )*(line + 0) == 47) {
      goto case_47;
    }
    if ((int )*(line + 0) == 38) {
      goto case_47;
    }
    if ((int )*(line + 0) == 126) {
      goto case_47;
    }
    if ((int )*(line + 0) == 36) {
      goto case_36;
    }
    if ((int )*(line + 0) == 58) {
      goto case_58;
    }
    if ((int )*(line + 0) == 63) {
      goto case_58;
    }
    if ((int )*(line + 0) == 61) {
      goto case_58;
    }
    if ((int )*(line + 0) == 64) {
      goto case_58;
    }
    if ((int )*(line + 0) == 39) {
      goto case_39;
    }
    goto switch_default;
    case_43: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_35: /* CIL Label */ 
    {
    eof = vim_fgets(line, 512, fp___0);
    }
    goto switch_break;
    case_33: /* CIL Label */ 
    {
    eof = read_viminfo_varlist(line, fp___0, writing);
    }
    goto switch_break;
    case_37: /* CIL Label */ 
    {
    eof = read_viminfo_bufferlist(line, fp___0, writing);
    }
    goto switch_break;
    case_34: /* CIL Label */ 
    {
    eof = read_viminfo_register(line, fp___0, forceit);
    }
    goto switch_break;
    case_47: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_126: /* CIL Label */ 
    {
    eof = read_viminfo_search_pattern(line, fp___0, forceit);
    }
    goto switch_break;
    case_36: /* CIL Label */ 
    {
    eof = read_viminfo_sub_string(line, fp___0, forceit);
    }
    goto switch_break;
    case_58: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_64: /* CIL Label */ 
    {
    eof = read_viminfo_history(line, fp___0);
    }
    goto switch_break;
    case_39: /* CIL Label */ 
    {
    eof = read_viminfo_filemark(line, fp___0, forceit);
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    tmp___0 = viminfo_error((char *)"Illegal starting char", line);
    }
    if (tmp___0) {
      eof = 1;
    } else {
      {
      eof = vim_fgets(line, 512, fp___0);
      }
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  finish_viminfo_history();
  }
  return (eof);
}
}
char_u *viminfo_readstring(char_u *p___0 , FILE *fp___0 ) 
{ 
  char_u *retval ;
  char_u *s ;
  char_u *d ;
  long len___0 ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  if ((int )*(p___0 + 0) == 22) {
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )*(p___0 + 1)) & 2048) {
      {
      len___0 = atol((char const   *)((char *)p___0 + 1));
      retval = lalloc((long_u )len___0, 1);
      }
      if ((unsigned long )retval == (unsigned long )((void *)0)) {
        {
        vim_fgets(p___0, 10, fp___0);
        }
        return ((char_u *)((void *)0));
      }
      {
      vim_fgets(retval, (int )len___0, fp___0);
      s = retval + 1;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    retval = vim_strsave(p___0);
    }
    if ((unsigned long )retval == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    s = retval;
  }
  d = retval;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*s != 0) {
      if (! ((int )*s != 10)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*(s + 0) == 22) {
      if ((int )*(s + 1) != 0) {
        if ((int )*(s + 1) == 110) {
          tmp___0 = d;
          d ++;
          *tmp___0 = (char_u )'\n';
        } else {
          tmp___1 = d;
          d ++;
          *tmp___1 = (char_u )22;
        }
        s += 2;
      } else {
        tmp___2 = d;
        d ++;
        tmp___3 = s;
        s ++;
        *tmp___2 = *tmp___3;
      }
    } else {
      tmp___2 = d;
      d ++;
      tmp___3 = s;
      s ++;
      *tmp___2 = *tmp___3;
    }
  }
  while_break: /* CIL Label */ ;
  }
  *d = (char_u )'\000';
  return (retval);
}
}
void viminfo_writestring(FILE *fd , char_u *p___0 ) 
{ 
  int c ;
  char_u *s ;
  int len___0 ;
  char_u *tmp ;

  {
  len___0 = 0;
  s = p___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*s != 0)) {
      goto while_break;
    }
    if ((int )*s == 22) {
      len___0 ++;
    } else { //Added block
    if ((int )*s == 10) {
      len___0 ++;
    }
    }
    len___0 ++;
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (len___0 > 256) {
    {
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\026%d\n<", len___0 + 3);
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    tmp = p___0;
    p___0 ++;
    c = (int )*tmp;
    if (! (c != 0)) {
      goto while_break___0;
    }
    if (c == 22) {
      goto _L;
    } else { //Added block
    if (c == 10) {
      _L: 
      {
      _IO_putc(22, fd);
      }
      if (c == 10) {
        c = 'n';
      }
    }
    }
    {
    _IO_putc(c, fd);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  _IO_putc('\n', fd);
  }
  return;
}
}
void do_fixdel(void) 
{ 
  char_u *p___0 ;
  char_u *tmp ;

  {
  {
  p___0 = find_termcode((char_u *)"kb");
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if ((int )*p___0 == 127) {
      tmp = (char_u *)"\b";
    } else {
      tmp = (char_u *)"\177";
    }
  } else {
    tmp = (char_u *)"\177";
  }
  {
  add_termcode((char_u *)"kD", tmp, 0);
  }
  return;
}
}
void print_line_no_prefix(linenr_t lnum , int use_number ) 
{ 
  char_u numbuf[20] ;
  char_u *tmp ;

  {
  if (curwin->w_p_nu) {
    {
    sprintf((char * __restrict  )((char *)(numbuf)), (char const   * __restrict  )"%7ld ",
            lnum);
    msg_puts_attr(numbuf, highlight_attr[9]);
    }
  } else { //Added block
  if (use_number) {
    {
    sprintf((char * __restrict  )((char *)(numbuf)), (char const   * __restrict  )"%7ld ",
            lnum);
    msg_puts_attr(numbuf, highlight_attr[9]);
    }
  }
  }
  {
  tmp = ml_get(lnum);
  msg_prt_line(tmp);
  }
  return;
}
}
void print_line(linenr_t lnum , int use_number ) 
{ 
  int save_silent ;

  {
  {
  save_silent = silent_mode;
  silent_mode = 0;
  msg_start();
  print_line_no_prefix(lnum, use_number);
  }
  if (save_silent) {
    {
    msg_putchar('\n');
    cursor_on();
    out_flush();
    silent_mode = save_silent;
    }
  }
  return;
}
}
void do_file(char_u *arg , int forceit ) 
{ 
  char_u *fname ;
  char_u *sfname ;
  char_u *xfname ;
  BUF *buf___3 ;
  int tmp ;

  {
  if ((int )*arg != 0) {
    {
    buf___3 = curbuf;
    apply_autocmds((EVENT_T )4, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
    }
    if ((unsigned long )buf___3 != (unsigned long )curbuf) {
      return;
    }
    {
    fname = curbuf->b_ffname;
    sfname = curbuf->b_sfname;
    xfname = curbuf->b_fname;
    curbuf->b_ffname = (char_u *)((void *)0);
    curbuf->b_sfname = (char_u *)((void *)0);
    tmp = setfname(arg, (char_u *)((void *)0), 1);
    }
    if (tmp == 0) {
      curbuf->b_ffname = fname;
      curbuf->b_sfname = sfname;
      return;
    }
    {
    curbuf->b_flags |= 8;
    buf___3 = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);
    }
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      curwin->w_alt_fnum = buf___3->b_fnum;
    }
    {
    vim_free((void *)fname);
    vim_free((void *)sfname);
    apply_autocmds((EVENT_T )3, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
    }
  }
  {
  fileinfo(0, 0, forceit);
  }
  return;
}
}
int do_write(EXARG *eap ) 
{ 
  int other ;
  char_u *fname ;
  char_u *ffname ;
  int retval ;
  char_u *free_fname ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  fname = (char_u *)((void *)0);
  retval = 0;
  free_fname = (char_u *)((void *)0);
  tmp = not_writing();
  }
  if (tmp) {
    return (0);
  }
  ffname = eap->arg;
  if ((int )*ffname == 0) {
    other = 0;
  } else {
    {
    fname = ffname;
    free_fname = fix_fname(ffname);
    }
    if ((unsigned long )free_fname != (unsigned long )((void *)0)) {
      ffname = free_fname;
    }
    {
    other = otherfile(ffname);
    }
  }
  if (other) {
    {
    tmp___0 = vim_strchr(p_cpo, 'A');
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
      setaltfname(ffname, fname, (linenr_t )1);
      }
    }
  }
  if (! other) {
    {
    tmp___1 = check_fname();
    }
    if (tmp___1 == 0) {
      goto theend;
    } else {
      {
      tmp___2 = check_readonly(& eap->forceit, curbuf);
      }
      if (tmp___2) {
        goto theend;
      }
    }
  }
  if (! other) {
    ffname = curbuf->b_ffname;
    fname = curbuf->b_fname;
    if (eap->line1 != 1L) {
      goto _L___0;
    } else { //Added block
    if (eap->line2 != curbuf->b_ml.ml_line_count) {
      _L___0: 
      if (! eap->forceit) {
        if (! eap->append) {
          if (! p_wa) {
            if (p_confirm) {
              goto _L;
            } else { //Added block
            if (confirm) {
              _L: 
              {
              tmp___3 = vim_dialog_yesno(4, (char_u *)((void *)0), (char_u *)"Write partial file?",
                                         2);
              }
              if (tmp___3 != 2) {
                goto theend;
              }
              eap->forceit = 1;
            } else {
              {
              emsg((char_u *)"Use ! to write partial buffer");
              }
              goto theend;
            }
            }
          }
        }
      }
    }
    }
  }
  {
  tmp___4 = check_overwrite(eap, curbuf, fname, ffname, other);
  }
  if (tmp___4 == 1) {
    {
    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2, eap->append,
                       eap->forceit, 1, 0);
    }
  }
  theend: 
  {
  vim_free((void *)free_fname);
  }
  return (retval);
}
}
static int check_overwrite(EXARG *eap , BUF *buf___3 , char_u *fname , char_u *ffname ,
                           int other ) 
{ 
  int tmp ;
  char_u buff[1025] ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  if (other) {
    goto _L___0;
  } else { //Added block
  if (buf___3->b_flags & 8) {
    goto _L___0;
  } else { //Added block
  if (buf___3->b_flags & 16) {
    {
    tmp___1 = vim_strchr(p_cpo, 'O');
    }
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (buf___3->b_flags & 64) {
    _L___0: 
    if (! eap->forceit) {
      if (! eap->append) {
        if (! p_wa) {
          {
          tmp___2 = vim_fexists(ffname);
          }
          if (tmp___2) {
            {
            tmp = mch_isdir(ffname);
            }
            if (tmp) {
              {
              emsg2((char_u *)"\"%s\" is a directory", ffname);
              }
              return (0);
            }
            if (p_confirm) {
              goto _L;
            } else { //Added block
            if (confirm) {
              _L: 
              {
              dialog_msg(buff, (char *)"Overwrite existing file \"%.*s\"?", fname);
              tmp___0 = vim_dialog_yesno(4, (char_u *)((void *)0), buff, 2);
              }
              if (tmp___0 != 2) {
                return (0);
              }
              eap->forceit = 1;
            } else {
              {
              emsg(e_exists);
              }
              return (0);
            }
            }
          }
        }
      }
    }
  }
  }
  }
  }
  return (1);
}
}
void do_wnext(EXARG *eap ) 
{ 
  int i___0 ;
  int tmp ;

  {
  if ((int )*(eap->cmd + 1) == 110) {
    i___0 = curwin->w_arg_idx + (int )eap->line2;
  } else {
    i___0 = curwin->w_arg_idx - (int )eap->line2;
  }
  {
  eap->line1 = (linenr_t )1;
  eap->line2 = curbuf->b_ml.ml_line_count;
  tmp = do_write(eap);
  }
  if (tmp != 0) {
    {
    do_argfile(eap, i___0);
    }
  }
  return;
}
}
void do_wqall(EXARG *eap ) 
{ 
  BUF *buf___3 ;
  int error ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  error = 0;
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp___4 = buf_changed(buf___3);
    }
    if (tmp___4) {
      {
      tmp = not_writing();
      }
      if (tmp) {
        error ++;
        goto while_break;
      }
      if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
        {
        emsg(e_noname);
        error ++;
        }
      } else {
        {
        tmp___2 = check_readonly(& eap->forceit, buf___3);
        }
        if (tmp___2) {
          error ++;
        } else {
          {
          tmp___3 = check_overwrite(eap, buf___3, buf___3->b_fname, buf___3->b_ffname,
                                    0);
          }
          if (tmp___3 == 0) {
            error ++;
          } else {
            {
            tmp___0 = buf_write_all(buf___3);
            }
            if (tmp___0 == 0) {
              error ++;
            }
            {
            tmp___1 = buf_valid(buf___3);
            }
            if (! tmp___1) {
              buf___3 = firstbuf;
            }
          }
        }
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  if (exiting) {
    if (! error) {
      {
      getout(0);
      }
    }
    {
    not_exiting();
    }
  }
  return;
}
}
int not_writing(void) 
{ 


  {
  if (p_write) {
    return (0);
  }
  {
  emsg((char_u *)"File not written: Writing is disabled by \'write\' option");
  }
  return (1);
}
}
static int check_readonly(int *forceit , BUF *buf___3 ) 
{ 
  char_u buff[1025] ;
  int tmp ;

  {
  if (! *forceit) {
    if (buf___3->b_p_ro) {
      if (p_confirm) {
        goto _L;
      } else { //Added block
      if (confirm) {
        _L: 
        if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
          {
          dialog_msg(buff, (char *)"\'readonly\' option is set for \"%.*s\".\nDo you wish to override it?",
                     buf___3->b_fname);
          tmp = vim_dialog_yesno(4, (char_u *)((void *)0), buff, 2);
          }
          if (tmp == 2) {
            *forceit = 1;
            return (0);
          } else {
            return (1);
          }
        } else {
          {
          emsg(e_readonly);
          }
        }
      } else {
        {
        emsg(e_readonly);
        }
      }
      }
      return (1);
    }
  }
  return (0);
}
}
int getfile(int fnum , char_u *ffname , char_u *sfname , int setpm , linenr_t lnum ,
            int forceit ) 
{ 
  int other ;
  int retval ;
  char_u *free_me ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  free_me = (char_u *)((void *)0);
  if (fnum == 0) {
    {
    fname_expand(& ffname, & sfname);
    other = otherfile(ffname);
    free_me = ffname;
    }
  } else {
    other = fnum != curbuf->b_fnum;
  }
  if (other) {
    no_wait_return ++;
  }
  if (other) {
    if (! forceit) {
      if (curbuf->b_nwindows == 1) {
        if (! p_hid) {
          {
          tmp = curbuf_changed();
          }
          if (tmp) {
            {
            tmp___0 = autowrite(curbuf, forceit);
            }
            if (tmp___0 == 0) {
              if (other) {
                no_wait_return --;
              }
              {
              emsg(e_nowrtmsg);
              retval = 2;
              }
              goto theend;
            }
          }
        }
      }
    }
  }
  if (other) {
    no_wait_return --;
  }
  if (setpm) {
    {
    setpcmark();
    }
  }
  if (! other) {
    if (lnum != 0L) {
      curwin->w_cursor.lnum = lnum;
    }
    {
    check_cursor_lnum();
    beginline(6);
    retval = 0;
    }
  } else {
    if (p_hid) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if (forceit) {
      tmp___2 = 8;
    } else {
      tmp___2 = 0;
    }
    {
    tmp___3 = do_ecmd(fnum, ffname, sfname, (char_u *)((void *)0), lnum, tmp___1 + tmp___2);
    }
    if (tmp___3 == 1) {
      retval = -1;
    } else {
      retval = 1;
    }
  }
  theend: 
  {
  vim_free((void *)free_me);
  }
  return (retval);
}
}
int do_ecmd(int fnum , char_u *ffname , char_u *sfname , char_u *command , linenr_t newlnum ,
            int flags___0 ) 
{ 
  int other_file ;
  int oldbuf ;
  int auto_buf ;
  char_u *new_name ;
  BUF *buf___3 ;
  BUF *old_curbuf ;
  char_u *free_fname ;
  int retval ;
  long n ;
  linenr_t lnum ;
  linenr_t topline ;
  int newcol ;
  int solcol ;
  FPOS *pos___0 ;
  linenr_t tmp ;
  int tmp___0 ;
  linenr_t tlnum ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  auto_buf = 0;
  new_name = (char_u *)((void *)0);
  old_curbuf = curbuf;
  free_fname = (char_u *)((void *)0);
  retval = 0;
  topline = (linenr_t )0;
  newcol = -1;
  solcol = -1;
  if (fnum != 0) {
    if (fnum == curbuf->b_fnum) {
      return (1);
    }
    other_file = 1;
  } else {
    if ((unsigned long )sfname == (unsigned long )((void *)0)) {
      sfname = ffname;
    }
    if (flags___0 & 16) {
      if ((unsigned long )ffname == (unsigned long )((void *)0)) {
        goto theend;
      } else { //Added block
      if ((int )*ffname == 0) {
        goto theend;
      }
      }
    }
    if ((unsigned long )ffname == (unsigned long )((void *)0)) {
      other_file = 1;
    } else { //Added block
    if ((int )*ffname == 0) {
      if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
        other_file = 0;
      } else {
        goto _L;
      }
    } else {
      _L: 
      if ((int )*ffname == 0) {
        ffname = curbuf->b_ffname;
        sfname = curbuf->b_fname;
      }
      {
      free_fname = fix_fname(ffname);
      }
      if ((unsigned long )free_fname != (unsigned long )((void *)0)) {
        ffname = free_fname;
      }
      {
      other_file = otherfile(ffname);
      }
    }
    }
  }
  if (! other_file) {
    if (! (flags___0 & 4)) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (curbuf->b_nwindows == 1) {
    if (! (flags___0 & 17)) {
      _L___0: 
      {
      tmp___0 = check_changed(curbuf, 0, ! other_file, flags___0 & 8, 0);
      }
      if (tmp___0) {
        if (fnum == 0) {
          if (other_file) {
            if ((unsigned long )ffname != (unsigned long )((void *)0)) {
              if (newlnum < 0L) {
                tmp = (linenr_t )0;
              } else {
                tmp = newlnum;
              }
              {
              setaltfname(ffname, sfname, tmp);
              }
            }
          }
        }
        goto theend;
      }
    }
  }
  }
  if (VIsual_active) {
    {
    end_visual_mode();
    VIsual_reselect = 0;
    }
  }
  if (other_file) {
    if (! (flags___0 & 16)) {
      {
      curwin->w_alt_fnum = curbuf->b_fnum;
      buflist_altfpos();
      }
    }
    if (fnum) {
      {
      buf___3 = buflist_findnr(fnum);
      }
    } else {
      if (flags___0 & 16) {
        tlnum = 1L;
        if ((unsigned long )command != (unsigned long )((void *)0)) {
          {
          tlnum = atol((char const   *)((char *)command));
          }
          if (tlnum <= 0L) {
            tlnum = 1L;
          }
        }
        {
        buflist_new(ffname, sfname, tlnum, 0);
        }
        goto theend;
      }
      {
      buf___3 = buflist_new(ffname, sfname, 0L, 1);
      }
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      goto theend;
    }
    if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      oldbuf = 0;
      buf___3->b_nwindows = 0;
    } else {
      {
      oldbuf = 1;
      buf_check_timestamp(buf___3, 0);
      }
    }
    if (oldbuf) {
      if (newlnum == 0L) {
        {
        pos___0 = buflist_findfpos(buf___3);
        newlnum = pos___0->lnum;
        solcol = (int )pos___0->col;
        }
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if (newlnum == -1L) {
      {
      pos___0 = buflist_findfpos(buf___3);
      newlnum = pos___0->lnum;
      solcol = (int )pos___0->col;
      }
    }
    }
    if ((unsigned long )buf___3 != (unsigned long )curbuf) {
      if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
        {
        new_name = vim_strsave(buf___3->b_fname);
        }
      }
      {
      au_new_curbuf = buf___3;
      apply_autocmds((EVENT_T )5, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      tmp___1 = buf_valid(buf___3);
      }
      if (! tmp___1) {
        {
        delbuf_msg(new_name);
        }
        goto theend;
      }
      if ((unsigned long )buf___3 == (unsigned long )curbuf) {
        auto_buf = 1;
      } else {
        if ((unsigned long )curbuf == (unsigned long )old_curbuf) {
          {
          buf_copy_options(curbuf, buf___3, 1);
          }
        }
        {
        close_buffer(curwin, curbuf, ! (flags___0 & 1), 0);
        tmp___2 = buf_valid(buf___3);
        }
        if (! tmp___2) {
          {
          delbuf_msg(new_name);
          }
          goto theend;
        }
        if ((unsigned long )buf___3 == (unsigned long )curbuf) {
          auto_buf = 1;
        } else {
          curwin->w_buffer = buf___3;
          curbuf = buf___3;
          (curbuf->b_nwindows) ++;
          if (*p_ffs) {
            if (! oldbuf) {
              {
              tmp___3 = default_fileformat();
              set_fileformat(tmp___3);
              }
            }
          }
        }
      }
      {
      vim_free((void *)new_name);
      au_new_curbuf = (BUF *)((void *)0);
      }
    } else {
      (curbuf->b_nwindows) ++;
    }
    curwin->w_pcmark.lnum = (linenr_t )1;
    curwin->w_pcmark.col = (colnr_t )0;
  } else {
    if (flags___0 & 16) {
      goto theend;
    } else {
      {
      tmp___4 = check_fname();
      }
      if (tmp___4 == 0) {
        goto theend;
      }
    }
    oldbuf = flags___0 & 4;
  }
  if (flags___0 & 2) {
    curbuf->b_help = 1;
    curbuf->b_p_bin = 0;
  }
  if (! other_file) {
    if (! oldbuf) {
      {
      set_last_cursor(curwin);
      }
      if (newlnum == -1L) {
        newlnum = curwin->w_cursor.lnum;
        solcol = (int )curwin->w_cursor.col;
      } else { //Added block
      if (newlnum == 0L) {
        newlnum = curwin->w_cursor.lnum;
        solcol = (int )curwin->w_cursor.col;
      }
      }
      buf___3 = curbuf;
      if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
        {
        new_name = vim_strsave(buf___3->b_fname);
        }
      } else {
        new_name = (char_u *)((void *)0);
      }
      {
      buf_freeall(curbuf, 0);
      tmp___5 = buf_valid(buf___3);
      }
      if (! tmp___5) {
        {
        delbuf_msg(new_name);
        }
        goto theend;
      }
      {
      vim_free((void *)new_name);
      }
      if ((unsigned long )buf___3 != (unsigned long )curbuf) {
        goto theend;
      }
      {
      buf_clear(curbuf);
      curbuf->b_op_start.lnum = (linenr_t )0;
      curbuf->b_op_end.lnum = (linenr_t )0;
      }
    }
  }
  {
  RedrawingDisabled ++;
  retval = 1;
  adjust_cursor();
  check_arg_idx(curwin);
  }
  if (! auto_buf) {
    {
    win_init(curwin);
    lnum = curwin->w_cursor.lnum;
    topline = curwin->w_topline;
    }
    if (! oldbuf) {
      {
      swap_exists_action = 1;
      curbuf->b_flags |= 2;
      open_buffer(0);
      }
      if (swap_exists_action == 2) {
        {
        swap_exists_action = 0;
        close_buffer(curwin, curbuf, 1, 0);
        tmp___6 = buf_valid(old_curbuf);
        }
        if (tmp___6) {
          if ((unsigned long )old_curbuf == (unsigned long )curbuf) {
            {
            old_curbuf = buflist_new((char_u *)((void *)0), (char_u *)((void *)0),
                                     1L, 1);
            }
          }
        } else {
          {
          old_curbuf = buflist_new((char_u *)((void *)0), (char_u *)((void *)0), 1L,
                                   1);
          }
        }
        {
        enter_buffer(old_curbuf);
        retval = 0;
        }
      } else { //Added block
      if (swap_exists_action == 3) {
        {
        ml_recover();
        msg_puts((char_u *)"\n");
        cmdline_row = msg_row;
        do_modelines();
        }
      }
      }
      swap_exists_action = 0;
    } else {
      {
      apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      }
    }
    {
    check_arg_idx(curwin);
    }
    if (curwin->w_cursor.lnum != lnum) {
      newlnum = curwin->w_cursor.lnum;
      newcol = (int )curwin->w_cursor.col;
    }
    if (curwin->w_topline == topline) {
      topline = (linenr_t )0;
    }
    {
    maketitle();
    }
  }
  if ((unsigned long )command == (unsigned long )((void *)0)) {
    if (newcol >= 0) {
      {
      curwin->w_cursor.lnum = newlnum;
      curwin->w_cursor.col = (colnr_t )newcol;
      adjust_cursor();
      }
    } else { //Added block
    if (newlnum > 0L) {
      {
      curwin->w_cursor.lnum = newlnum;
      check_cursor_lnum();
      }
      if (solcol >= 0) {
        if (! p_sol) {
          {
          curwin->w_cursor.col = (colnr_t )solcol;
          check_cursor_col();
          }
        } else {
          {
          beginline(6);
          }
        }
      } else {
        {
        beginline(6);
        }
      }
    } else {
      if (exmode_active) {
        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
      }
      {
      beginline(5);
      }
    }
    }
  }
  {
  check_lnums(0);
  }
  if (oldbuf) {
    if (! auto_buf) {
      {
      fileinfo(0, 1, 0);
      }
    }
  }
  if ((unsigned long )command != (unsigned long )((void *)0)) {
    {
    do_cmdline(command, (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
               1);
    }
  }
  RedrawingDisabled --;
  if (! skip_redraw) {
    n = p_so;
    if (topline == 0L) {
      if ((unsigned long )command == (unsigned long )((void *)0)) {
        p_so = 999L;
      }
    }
    {
    update_topline();
    curwin->w_scbind_pos = curwin->w_topline;
    p_so = n;
    update_curbuf(40);
    }
  }
  if (p_im) {
    need_start_insertmode = 1;
  }
  theend: 
  {
  vim_free((void *)free_fname);
  }
  return (retval);
}
}
static void delbuf_msg(char_u *name___1 ) 
{ 
  char_u *tmp ;

  {
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    tmp = (char_u *)"";
  } else {
    tmp = name___1;
  }
  {
  emsg2((char_u *)"Autocommands unexpectedly deleted new buffer %s", tmp);
  vim_free((void *)name___1);
  au_new_curbuf = (BUF *)((void *)0);
  }
  return;
}
}
void do_append(linenr_t lnum , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int getl_break ) 
{ 
  char_u *theline ;
  int did_undo ;
  int lfirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  colnr_t tmp___2 ;

  {
  did_undo = 0;
  lfirst = (int )lnum;
  State = 16;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    msg_scroll = 1;
    need_wait_return = 0;
    if ((unsigned long )getline___0 == (unsigned long )((void *)0)) {
      if (getl_break) {
        tmp = -1;
      } else {
        tmp = '\000';
      }
      {
      theline = getcmdline(tmp, 0L, 0);
      }
    } else {
      if (getl_break) {
        tmp___0 = -1;
      } else {
        tmp___0 = '\000';
      }
      {
      theline = (*getline___0)(tmp___0, cookie, 0);
      }
    }
    lines_left = (int )(Rows - 1L);
    if ((unsigned long )theline == (unsigned long )((void *)0)) {
      goto while_break;
    } else { //Added block
    if ((int )*(theline + 0) == 46) {
      if ((int )*(theline + 1) == 0) {
        goto while_break;
      }
    }
    }
    if (! did_undo) {
      {
      tmp___1 = u_save(lnum, lnum + 1L);
      }
      if (tmp___1 == 0) {
        goto while_break;
      }
    }
    {
    did_undo = 1;
    mark_adjust(lnum + 1L, (linenr_t )2147483647, 1L, 0L);
    ml_append(lnum, theline, (colnr_t )0, 0);
    changed();
    vim_free((void *)theline);
    lnum ++;
    msg_didout = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  State = 1;
  if ((linenr_t )lfirst < curbuf->b_ml.ml_line_count) {
    curbuf->b_op_start.lnum = (linenr_t )(lfirst + 1);
  } else {
    curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;
  }
  if ((linenr_t )lfirst < lnum) {
    curbuf->b_op_end.lnum = lnum;
  } else {
    curbuf->b_op_end.lnum = curbuf->b_op_start.lnum;
  }
  {
  tmp___2 = (colnr_t )0;
  curbuf->b_op_end.col = tmp___2;
  curbuf->b_op_start.col = tmp___2;
  curwin->w_cursor.lnum = lnum;
  check_cursor_lnum();
  beginline(6);
  changed_line_abv_curs();
  invalidate_botline();
  need_wait_return = 0;
  update_screen(40);
  }
  return;
}
}
void do_change(linenr_t start___0 , linenr_t end , char_u *(*getline___0)(int  , void * ,
                                                                          int  ) ,
               void *cookie , int getl_break ) 
{ 
  int tmp ;

  {
  if (end >= start___0) {
    {
    tmp = u_save(start___0 - 1L, end + 1L);
    }
    if (tmp == 0) {
      return;
    }
  }
  {
  mark_adjust(start___0, end, 2147483647L, (start___0 - end) - 1L);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (end >= start___0)) {
      goto while_break;
    }
    if (curbuf->b_ml.ml_flags & 1) {
      goto while_break;
    }
    {
    ml_delete(start___0, 0);
    changed();
    end --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  do_append(start___0 - 1L, getline___0, cookie, getl_break);
  }
  return;
}
}
void do_z(linenr_t line , char_u *arg ) 
{ 
  char_u *x___0 ;
  int bigness ;
  char_u kind ;
  int minus ;
  linenr_t start___0 ;
  linenr_t end ;
  linenr_t curs ;
  linenr_t i___0 ;
  unsigned short const   **tmp ;
  int j ;

  {
  bigness = curwin->w_height - 3;
  minus = 0;
  if (bigness < 1) {
    bigness = 1;
  }
  x___0 = arg;
  if ((int )*x___0 == 45) {
    x___0 ++;
  } else { //Added block
  if ((int )*x___0 == 43) {
    x___0 ++;
  } else { //Added block
  if ((int )*x___0 == 61) {
    x___0 ++;
  } else { //Added block
  if ((int )*x___0 == 94) {
    x___0 ++;
  } else { //Added block
  if ((int )*x___0 == 46) {
    x___0 ++;
  }
  }
  }
  }
  }
  if ((int )*x___0 != 0) {
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )*x___0) & 2048) {
      {
      bigness = atoi((char const   *)((char *)x___0));
      }
    } else {
      {
      emsg((char_u *)"non-numeric argument to :z");
      }
      return;
    }
  }
  kind = *arg;
  {
  if ((int )kind == 45) {
    goto case_45;
  }
  if ((int )kind == 61) {
    goto case_61;
  }
  if ((int )kind == 94) {
    goto case_94;
  }
  if ((int )kind == 46) {
    goto case_46;
  }
  goto switch_default;
  case_45: /* CIL Label */ 
  start___0 = line - (linenr_t )bigness;
  end = line;
  curs = line;
  goto switch_break;
  case_61: /* CIL Label */ 
  start___0 = (line - (linenr_t )(bigness / 2)) + 1L;
  end = (line + (linenr_t )(bigness / 2)) - 1L;
  curs = line;
  minus = 1;
  goto switch_break;
  case_94: /* CIL Label */ 
  start___0 = line - (linenr_t )(bigness * 2);
  end = line - (linenr_t )bigness;
  curs = line - (linenr_t )bigness;
  goto switch_break;
  case_46: /* CIL Label */ 
  start___0 = line - (linenr_t )(bigness / 2);
  end = line + (linenr_t )(bigness / 2);
  curs = end;
  goto switch_break;
  switch_default: /* CIL Label */ 
  start___0 = line;
  end = line + (linenr_t )bigness;
  curs = end;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  if (start___0 < 1L) {
    start___0 = (linenr_t )1;
  }
  if (end > curbuf->b_ml.ml_line_count) {
    end = curbuf->b_ml.ml_line_count;
  }
  if (curs > curbuf->b_ml.ml_line_count) {
    curs = curbuf->b_ml.ml_line_count;
  }
  i___0 = start___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 <= end)) {
      goto while_break;
    }
    if (minus) {
      if (i___0 == line) {
        {
        msg_putchar('\n');
        j = 1;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((long )j < Columns)) {
            goto while_break___0;
          }
          {
          msg_putchar('-');
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
    print_line(i___0, 0);
    }
    if (minus) {
      if (i___0 == line) {
        {
        msg_putchar('\n');
        j = 1;
        }
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((long )j < Columns)) {
            goto while_break___1;
          }
          {
          msg_putchar('-');
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  curwin->w_cursor.lnum = curs;
  return;
}
}
int check_restricted(void) 
{ 


  {
  if (restricted) {
    {
    emsg((char_u *)"Shell commands not allowed in rvim");
    }
    return (1);
  }
  return (0);
}
}
int check_secure(void) 
{ 


  {
  if (secure) {
    {
    secure = 2;
    emsg(e_curdir);
    }
    return (1);
  }
  if (sandbox != 0) {
    {
    emsg(e_sandbox);
    }
    return (1);
  }
  return (0);
}
}
static char_u *old_sub  =    (char_u *)((void *)0);
static int global_need_beginline  ;
static long sub_nsubs  ;
static linenr_t sub_nlines  ;
static int do_all  =    0;
static int do_ask  =    0;
void do_sub(EXARG *eap ) 
{ 
  linenr_t lnum ;
  long i___0 ;
  char_u *ptr ;
  char_u *old_line ;
  vim_regexp *prog ;
  int do_error ;
  int do_print___0 ;
  int do_ic ;
  char_u *pat ;
  char_u *sub ;
  int delimiter ;
  int sublen ;
  int got_quit ;
  int got_match ;
  int temp ;
  int which_pat ;
  char_u *cmd ;
  int save_reg_ic ;
  int save_State ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char_u *new_end ;
  char_u *new_start ;
  char_u *old_match ;
  char_u *old_copy ;
  char_u *prev_old_match ;
  char_u *p1 ;
  int did_sub ;
  int match ;
  int lastone ;
  unsigned int len___0 ;
  unsigned int needed_len ;
  unsigned int new_start_len ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  colnr_t tmp___17 ;
  int tmp___18 ;
  char_u *tmp___19 ;

  {
  i___0 = 0L;
  do_error = 1;
  do_print___0 = 0;
  do_ic = 0;
  pat = (char_u *)((void *)0);
  sub = (char_u *)((void *)0);
  got_quit = 0;
  got_match = 0;
  cmd = eap->arg;
  if (! global_busy) {
    sub_nsubs = 0L;
    sub_nlines = (linenr_t )0;
  }
  if ((int )eap->cmdidx == 298) {
    which_pat = 2;
  } else {
    which_pat = 1;
  }
  if ((int )*(eap->cmd + 0) == 115) {
    if ((int )*cmd != 0) {
      if ((int )*cmd == 32) {
        goto _L___1;
      } else { //Added block
      if ((int )*cmd == 9) {
        goto _L___1;
      } else {
        {
        tmp___5 = vim_strchr((char_u *)"0123456789gcr|\"", (int )*cmd);
        }
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
          {
          tmp = __ctype_b_loc();
          }
          if ((int const   )*(*tmp + (int )*cmd) & 1024) {
            {
            emsg((char_u *)"Regular expressions can\'t be delimited by letters");
            }
            return;
          }
          if ((int )*cmd == 92) {
            {
            cmd ++;
            tmp___0 = vim_strchr((char_u *)"/?&", (int )*cmd);
            }
            if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
              {
              emsg(e_backslash);
              }
              return;
            }
            if ((int )*cmd != 38) {
              which_pat = 0;
            }
            pat = (char_u *)"";
            tmp___1 = cmd;
            cmd ++;
            delimiter = (int )*tmp___1;
          } else {
            {
            which_pat = 2;
            tmp___2 = cmd;
            cmd ++;
            delimiter = (int )*tmp___2;
            pat = cmd;
            cmd = skip_regexp(cmd, delimiter, p_magic);
            }
            if ((int )*(cmd + 0) == delimiter) {
              tmp___3 = cmd;
              cmd ++;
              *tmp___3 = (char_u )'\000';
            }
          }
          sub = cmd;
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (! *(cmd + 0)) {
              goto while_break;
            }
            if ((int )*(cmd + 0) == delimiter) {
              tmp___4 = cmd;
              cmd ++;
              *tmp___4 = (char_u )'\000';
              goto while_break;
            }
            if ((int )*(cmd + 0) == 92) {
              if ((int )*(cmd + 1) != 0) {
                if ((int )*(cmd + 1) == 13) {
                  *(cmd + 0) = (char_u )22;
                }
                cmd ++;
              }
            }
            cmd ++;
          }
          while_break: /* CIL Label */ ;
          }
          if (! eap->skip) {
            {
            vim_free((void *)old_sub);
            old_sub = vim_strsave(sub);
            }
          }
        } else {
          goto _L___1;
        }
      }
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (! eap->skip) {
    if ((unsigned long )old_sub == (unsigned long )((void *)0)) {
      {
      emsg(e_nopresub);
      }
      return;
    }
    pat = (char_u *)((void *)0);
    sub = old_sub;
  }
  }
  if (! p_ed) {
    if (p_gd) {
      do_all = 1;
    } else {
      do_all = 0;
    }
    do_ask = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *cmd) {
      goto while_break___0;
    }
    if ((int )*cmd == 103) {
      do_all = ! do_all;
    } else { //Added block
    if ((int )*cmd == 99) {
      do_ask = ! do_ask;
    } else { //Added block
    if ((int )*cmd == 101) {
      do_error = ! do_error;
    } else { //Added block
    if ((int )*cmd == 114) {
      which_pat = 2;
    } else { //Added block
    if ((int )*cmd == 112) {
      do_print___0 = 1;
    } else { //Added block
    if ((int )*cmd == 105) {
      do_ic = 'i';
    } else { //Added block
    if ((int )*cmd == 73) {
      do_ic = 'I';
    } else {
      goto while_break___0;
    }
    }
    }
    }
    }
    }
    }
    cmd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  cmd = skipwhite(cmd);
  tmp___6 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___6 + (int )*cmd) & 2048) {
    {
    i___0 = getdigits(& cmd);
    }
    if (i___0 <= 0L) {
      if (! eap->skip) {
        if (do_error) {
          {
          emsg(e_zerocount);
          }
          return;
        }
      }
    }
    eap->line1 = eap->line2;
    eap->line2 += i___0 - 1L;
  }
  {
  cmd = skipwhite(cmd);
  }
  if (*cmd) {
    if ((int )*cmd != 34) {
      {
      eap->nextcmd = check_nextcmd(cmd);
      }
      if ((unsigned long )eap->nextcmd == (unsigned long )((void *)0)) {
        {
        emsg(e_trailing);
        }
        return;
      }
    }
  }
  if (eap->skip) {
    return;
  }
  {
  prog = search_regcomp(pat, 1, which_pat, 32);
  }
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    if (do_error) {
      {
      emsg(e_invcmd);
      }
    }
    return;
  }
  if (do_ic == 105) {
    reg_ic = 1;
  } else { //Added block
  if (do_ic == 73) {
    reg_ic = 0;
  }
  }
  {
  sub = regtilde(sub, p_magic);
  old_line = (char_u *)((void *)0);
  lnum = eap->line1;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (lnum <= eap->line2) {
      if (got_int) {
        goto while_break___1;
      } else { //Added block
      if (got_quit) {
        goto while_break___1;
      }
      }
    } else {
      goto while_break___1;
    }
    {
    ptr = ml_get(lnum);
    tmp___16 = vim_regexec(prog, ptr, 1);
    }
    if (tmp___16) {
      {
      new_start = (char_u *)((void *)0);
      prev_old_match = (char_u *)((void *)0);
      did_sub = 0;
      new_start_len = 0U;
      old_line = vim_strsave(ptr);
      }
      if ((unsigned long )old_line == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      {
      vim_regnewptr(prog, ptr, old_line);
      }
      if (! got_match) {
        {
        setpcmark();
        got_match = 1;
        }
      }
      old_match = old_line;
      old_copy = old_match;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        curwin->w_cursor.lnum = lnum;
        if (sub_nlines) {
          {
          changed_line_abv_curs();
          }
        } else {
          {
          changed_cline_bef_curs();
          }
        }
        if ((unsigned long )old_match == (unsigned long )prev_old_match) {
          if ((unsigned long )old_match == (unsigned long )prog->endp[0]) {
            old_match ++;
            goto skip;
          }
        }
        old_match = prog->endp[0];
        prev_old_match = old_match;
        if (do_ask) {
          {
          save_reg_ic = reg_ic;
          save_State = State;
          State = 3072;
          setmouse();
          curwin->w_cursor.col = (colnr_t )(prog->startp[0] - old_line);
          }
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if (! do_ask) {
              goto while_break___3;
            }
            temp = RedrawingDisabled;
            RedrawingDisabled = 0;
            search_match_len = (int )(prog->endp[0] - prog->startp[0]);
            if (search_match_len == 0) {
              search_match_len = 1;
            }
            {
            highlight_match = 1;
            update_topline();
            validate_cursor();
            update_screen(40);
            highlight_match = 0;
            redraw_later(40);
            }
            if ((long )msg_row == Rows - 1L) {
              msg_didout = 0;
            }
            {
            smsg_attr(highlight_attr[10], (char_u *)"replace with %s (y/n/a/q/^E/^Y)?",
                      sub);
            showruler(1);
            RedrawingDisabled = temp;
            no_mapping ++;
            allow_keys ++;
            tmp___7 = safe_vgetc();
            i___0 = (long )tmp___7;
            allow_keys --;
            no_mapping --;
            msg_didout = 0;
            msg_col = 0;
            gotocmdline(1);
            need_wait_return = 0;
            }
            if (i___0 == 113L) {
              got_quit = 1;
              goto while_break___3;
            } else { //Added block
            if (i___0 == 27L) {
              got_quit = 1;
              goto while_break___3;
            } else { //Added block
            if (i___0 == 3L) {
              got_quit = 1;
              goto while_break___3;
            } else { //Added block
            if (i___0 == (long )intr_char) {
              got_quit = 1;
              goto while_break___3;
            } else { //Added block
            if (i___0 == 110L) {
              goto while_break___3;
            } else { //Added block
            if (i___0 == 121L) {
              goto while_break___3;
            } else { //Added block
            if (i___0 == 97L) {
              do_ask = 0;
              goto while_break___3;
            } else { //Added block
            if (i___0 == 5L) {
              {
              scrollup_clamp();
              }
            } else { //Added block
            if (i___0 == 25L) {
              {
              scrolldown_clamp();
              }
            }
            }
            }
            }
            }
            }
            }
            }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
          reg_ic = save_reg_ic;
          State = save_State;
          setmouse();
          }
          if (i___0 == 110L) {
            goto skip;
          }
          if (got_quit) {
            goto while_break___2;
          }
        }
        {
        curwin->w_cursor.col = (colnr_t )0;
        sublen = vim_regsub(prog, sub, old_line, 0, p_magic);
        }
        if ((unsigned long )new_start == (unsigned long )((void *)0)) {
          {
          tmp___8 = strlen((char const   *)((char *)old_copy));
          new_start_len = (unsigned int )((tmp___8 + (size_t )sublen) + 25UL);
          new_start = alloc_check(new_start_len);
          }
          if ((unsigned long )new_start == (unsigned long )((void *)0)) {
            goto outofmem;
          }
          *new_start = (char_u )'\000';
          new_end = new_start;
        } else {
          {
          tmp___9 = strlen((char const   *)((char *)new_start));
          len___0 = (unsigned int )tmp___9;
          tmp___10 = strlen((char const   *)((char *)old_copy));
          needed_len = (unsigned int )((((size_t )len___0 + tmp___10) + (size_t )sublen) + 1UL);
          }
          if (needed_len > new_start_len) {
            {
            needed_len += 20U;
            p1 = alloc_check(needed_len);
            }
            if ((unsigned long )p1 == (unsigned long )((void *)0)) {
              goto outofmem;
            }
            {
            strcpy((char * __restrict  )((char *)p1), (char const   * __restrict  )((char *)new_start));
            vim_free((void *)new_start);
            new_start = p1;
            new_start_len = needed_len;
            }
          }
          new_end = new_start + len___0;
        }
        {
        i___0 = prog->startp[0] - old_copy;
        memmove((void *)((char *)new_end), (void const   *)((char *)old_copy), (size_t )i___0);
        new_end += i___0;
        vim_regsub(prog, sub, new_end, 1, p_magic);
        sub_nsubs ++;
        did_sub = 1;
        }
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
          p1 = vim_strchr(new_end, '\r');
          }
          if (! ((unsigned long )p1 != (unsigned long )((void *)0))) {
            goto while_break___4;
          }
          if ((unsigned long )p1 == (unsigned long )new_end) {
            goto _L___2;
          } else { //Added block
          if ((int )*(p1 + -1) != 22) {
            _L___2: 
            {
            tmp___11 = u_inssub(lnum);
            }
            if (tmp___11 == 1) {
              {
              *p1 = (char_u )'\000';
              mark_adjust(lnum, (linenr_t )2147483647, 1L, 0L);
              ml_append(lnum - 1L, new_start, (colnr_t )((p1 - new_start) + 1L), 0);
              lnum ++;
              (curwin->w_cursor.lnum) ++;
              (eap->line2) ++;
              strcpy((char * __restrict  )((char *)new_start), (char const   * __restrict  )((char *)(p1 + 1)));
              new_end = new_start;
              }
            }
          } else {
            {
            strcpy((char * __restrict  )((char *)(p1 - 1)), (char const   * __restrict  )((char *)p1));
            new_end = p1;
            }
          }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        old_copy = prog->endp[0];
        skip: 
        match = -1;
        if ((int )*old_match == 0) {
          tmp___12 = 1;
        } else { //Added block
        if (got_int) {
          tmp___12 = 1;
        } else { //Added block
        if (got_quit) {
          tmp___12 = 1;
        } else { //Added block
        if (! do_all) {
          tmp___12 = 1;
        } else {
          tmp___12 = 0;
        }
        }
        }
        }
        lastone = tmp___12;
        if (lastone) {
          goto _L___3;
        } else { //Added block
        if (do_ask) {
          goto _L___3;
        } else {
          {
          match = vim_regexec(prog, old_match, 0);
          }
          if (match == 0) {
            _L___3: 
            if (new_start) {
              {
              strcat((char * __restrict  )((char *)new_start), (char const   * __restrict  )((char *)old_copy));
              tmp___13 = strlen((char const   *)((char *)old_line));
              i___0 = (old_line + tmp___13) - old_match;
              tmp___14 = u_savesub(lnum);
              }
              if (tmp___14 == 1) {
                {
                ml_replace(lnum, new_start, 1);
                }
              }
              if (do_ask) {
                {
                changed();
                }
              }
              {
              syn_changed(lnum);
              vim_free((void *)old_line);
              old_line = new_start;
              new_start = (char_u *)((void *)0);
              tmp___15 = strlen((char const   *)((char *)old_line));
              old_match = (old_line + tmp___15) - i___0;
              }
              if ((unsigned long )old_match < (unsigned long )old_line) {
                {
                emsg((char_u *)"do_sub internal error: old_match < old_line");
                old_match = old_line;
                }
              }
              old_copy = old_line;
            }
            if (match == -1) {
              if (! lastone) {
                {
                match = vim_regexec(prog, old_match, 0);
                }
              }
            }
            if (match <= 0) {
              goto while_break___2;
            }
          }
        }
        }
        {
        line_breakcheck();
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      if (did_sub) {
        sub_nlines ++;
      }
      {
      vim_free((void *)old_line);
      old_line = (char_u *)((void *)0);
      }
    }
    {
    line_breakcheck();
    }
    __Cont: 
    lnum ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  curbuf->b_op_start.lnum = eap->line1;
  curbuf->b_op_end.lnum = eap->line2;
  tmp___17 = (colnr_t )0;
  curbuf->b_op_end.col = tmp___17;
  curbuf->b_op_start.col = tmp___17;
  outofmem: 
  {
  vim_free((void *)old_line);
  }
  if (sub_nsubs) {
    {
    changed();
    approximate_botline();
    }
    if (! global_busy) {
      {
      update_topline();
      beginline(5);
      update_screen(40);
      tmp___18 = do_sub_msg();
      }
      if (! tmp___18) {
        if (do_ask) {
          {
          msg((char_u *)"");
          }
        }
      }
    } else {
      global_need_beginline = 1;
    }
    if (do_print___0) {
      {
      print_line(curwin->w_cursor.lnum, 0);
      }
    }
  } else { //Added block
  if (! global_busy) {
    if (got_int) {
      {
      emsg(e_interr);
      }
    } else { //Added block
    if (got_match) {
      {
      msg((char_u *)"");
      }
    } else { //Added block
    if (do_error) {
      {
      tmp___19 = get_search_pat();
      emsg2(e_patnotf2, tmp___19);
      }
    }
    }
    }
  }
  }
  {
  vim_free((void *)prog);
  }
  return;
}
}
static int do_sub_msg(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (sub_nsubs > p_report) {
    if (KeyTyped) {
      goto _L;
    } else { //Added block
    if (sub_nlines > 1L) {
      goto _L;
    } else { //Added block
    if (p_report < 1L) {
      _L: 
      {
      tmp___3 = messaging();
      }
      if (tmp___3) {
        {
        tmp = plural(sub_nlines);
        tmp___0 = plural(sub_nsubs);
        }
        if (got_int) {
          tmp___1 = "(Interrupted) ";
        } else {
          tmp___1 = "";
        }
        {
        sprintf((char * __restrict  )((char *)(msg_buf)), (char const   * __restrict  )"%s%ld substitution%s on %ld line%s",
                tmp___1, sub_nsubs, tmp___0, sub_nlines, tmp);
        tmp___2 = msg(msg_buf);
        }
        if (tmp___2) {
          keep_msg = msg_buf;
          keep_msg_attr = 0;
        }
        return (1);
      }
    }
    }
    }
  }
  if (got_int) {
    {
    emsg(e_interr);
    }
    return (1);
  }
  return (0);
}
}
void do_glob(EXARG *eap ) 
{ 
  linenr_t lnum ;
  linenr_t old_lcount ;
  int ndone ;
  int type ;
  char_u *cmd ;
  char_u delim ;
  char_u *pat ;
  vim_regexp *prog ;
  int match ;
  int which_pat ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  if (global_busy) {
    {
    emsg((char_u *)"Cannot do :global recursive");
    }
    return;
  }
  type = (int )*(eap->cmd);
  cmd = eap->arg;
  which_pat = 2;
  sub_nsubs = 0L;
  sub_nlines = (linenr_t )0;
  if ((int )*cmd == 92) {
    {
    cmd ++;
    tmp = vim_strchr((char_u *)"/?&", (int )*cmd);
    }
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
      emsg(e_backslash);
      }
      return;
    }
    if ((int )*cmd == 38) {
      which_pat = 1;
    } else {
      which_pat = 0;
    }
    cmd ++;
    pat = (char_u *)"";
  } else { //Added block
  if ((int )*cmd == 0) {
    {
    emsg((char_u *)"Regular expression missing from global");
    }
    return;
  } else {
    delim = *cmd;
    if (delim) {
      cmd ++;
    }
    {
    pat = cmd;
    cmd = skip_regexp(cmd, (int )delim, p_magic);
    }
    if ((int )*(cmd + 0) == (int )delim) {
      tmp___0 = cmd;
      cmd ++;
      *tmp___0 = (char_u )'\000';
    }
  }
  }
  {
  prog = search_regcomp(pat, 2, which_pat, 32);
  }
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
    emsg(e_invcmd);
    }
    return;
  }
  ndone = 0;
  lnum = eap->line1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (lnum <= eap->line2) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp___1 = ml_get(lnum);
    match = vim_regexec(prog, tmp___1, 1);
    }
    if (type == 103) {
      if (match) {
        {
        ml_setmarked(lnum);
        ndone ++;
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (type == 118) {
      if (! match) {
        {
        ml_setmarked(lnum);
        ndone ++;
        }
      }
    }
    }
    {
    line_breakcheck();
    lnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (got_int) {
    {
    msg(e_interr);
    }
  } else { //Added block
  if (ndone == 0) {
    {
    smsg(e_patnotf2, pat);
    }
  } else {
    {
    setpcmark();
    msg_didout = 1;
    global_need_beginline = 0;
    global_busy = 1;
    old_lcount = curbuf->b_ml.ml_line_count;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! got_int) {
        {
        lnum = ml_firstmarked();
        }
        if (lnum != 0L) {
          if (! (global_busy == 1)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      curwin->w_cursor.lnum = lnum;
      curwin->w_cursor.col = (colnr_t )0;
      if ((int )*cmd == 0) {
        {
        do_cmdline((char_u *)"p", (char_u *(*)(int  , void * , int  ))((void *)0),
                   (void *)0, 2);
        }
      } else { //Added block
      if ((int )*cmd == 10) {
        {
        do_cmdline((char_u *)"p", (char_u *(*)(int  , void * , int  ))((void *)0),
                   (void *)0, 2);
        }
      } else {
        {
        do_cmdline(cmd, (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
                   2);
        }
      }
      }
      {
      ui_breakcheck();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    global_busy = 0;
    if (global_need_beginline) {
      {
      beginline(5);
      }
    } else {
      {
      adjust_cursor();
      }
    }
    {
    redraw_later(40);
    }
    if (msg_col == 0) {
      if (msg_scrolled == 0) {
        msg_didout = 0;
      }
    }
    {
    tmp___2 = do_sub_msg();
    }
    if (! tmp___2) {
      {
      msgmore(curbuf->b_ml.ml_line_count - old_lcount);
      }
    }
  }
  }
  {
  ml_clearmarked();
  vim_free((void *)prog);
  }
  return;
}
}
int read_viminfo_sub_string(char_u *line , FILE *fp___0 , int force ) 
{ 
  int tmp ;

  {
  if ((unsigned long )old_sub != (unsigned long )((void *)0)) {
    if (force) {
      {
      vim_free((void *)old_sub);
      }
    }
  }
  if (force) {
    {
    old_sub = viminfo_readstring(line + 1, fp___0);
    }
  } else { //Added block
  if ((unsigned long )old_sub == (unsigned long )((void *)0)) {
    {
    old_sub = viminfo_readstring(line + 1, fp___0);
    }
  }
  }
  {
  tmp = vim_fgets(line, 512, fp___0);
  }
  return (tmp);
}
}
void write_viminfo_sub_string(FILE *fp___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = get_viminfo_parameter('/');
  }
  if (tmp != 0) {
    if ((unsigned long )old_sub != (unsigned long )((void *)0)) {
      {
      fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# Last Substitute String:\n$");
      viminfo_writestring(fp___0, old_sub);
      }
    }
  }
  return;
}
}
void prepare_tagpreview(void) 
{ 
  WIN *wp ;
  int tmp ;
  int tmp___0 ;

  {
  if (! curwin->w_preview) {
    wp = firstwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if (wp->w_preview) {
        goto while_break;
      }
      wp = wp->w_next;
    }
    while_break: /* CIL Label */ ;
    }
    if ((unsigned long )wp != (unsigned long )((void *)0)) {
      {
      win_enter(wp, 1);
      }
    } else {
      if (g_do_tagpreview > 0) {
        tmp = g_do_tagpreview;
      } else {
        tmp = 0;
      }
      {
      tmp___0 = win_split(tmp, 0, 0);
      }
      if (tmp___0 == 0) {
        return;
      }
      curwin->w_preview = 1;
    }
  }
  if (! p_im) {
    restart_edit = 0;
  }
  return;
}
}
void do_help(EXARG *eap ) 
{ 
  char_u *arg ;
  FILE *helpfd ;
  int n ;
  WIN *wp ;
  int num_matches___0 ;
  char_u **matches___0 ;
  int need_free ;
  char_u *tmp ;
  int tmp___0 ;

  {
  need_free = 0;
  if ((unsigned long )eap != (unsigned long )((void *)0)) {
    arg = eap->arg;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *arg) {
        goto while_break;
      }
      if ((int )*arg == 10) {
        tmp = arg;
        arg ++;
        *tmp = (char_u )'\000';
        eap->nextcmd = arg;
        goto while_break;
      } else { //Added block
      if ((int )*arg == 13) {
        tmp = arg;
        arg ++;
        *tmp = (char_u )'\000';
        eap->nextcmd = arg;
        goto while_break;
      } else { //Added block
      if ((int )*arg == 124) {
        if ((int )*(arg + 1) != 0) {
          tmp = arg;
          arg ++;
          *tmp = (char_u )'\000';
          eap->nextcmd = arg;
          goto while_break;
        }
      }
      }
      }
      arg ++;
    }
    while_break: /* CIL Label */ ;
    }
    arg = eap->arg;
    if (eap->skip) {
      return;
    }
  } else {
    arg = (char_u *)"";
  }
  if ((int )*arg != 0) {
    {
    n = find_help_tags(arg, & num_matches___0, & matches___0);
    }
    if (num_matches___0 == 0) {
      {
      emsg2((char_u *)"Sorry, no help for %s", arg);
      }
      return;
    } else { //Added block
    if (n == 0) {
      {
      emsg2((char_u *)"Sorry, no help for %s", arg);
      }
      return;
    }
    }
    {
    arg = vim_strsave(*(matches___0 + 0));
    need_free = 1;
    FreeWild(num_matches___0, matches___0);
    }
  }
  if (! (curwin->w_buffer)->b_help) {
    wp = firstwin;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      if ((unsigned long )wp->w_buffer != (unsigned long )((void *)0)) {
        if ((wp->w_buffer)->b_help) {
          goto while_break___0;
        }
      }
      wp = wp->w_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )wp != (unsigned long )((void *)0)) {
      if ((wp->w_buffer)->b_nwindows > 0) {
        {
        win_enter(wp, 1);
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
      helpfd = fopen((char const   * __restrict  )((char *)p_hf), (char const   * __restrict  )"r");
      }
      if ((unsigned long )helpfd == (unsigned long )((void *)0)) {
        {
        smsg((char_u *)"Sorry, help file \"%s\" not found", p_hf);
        }
        goto erret;
      }
      {
      fclose(helpfd);
      tmp___0 = win_split(0, 0, 0);
      }
      if (tmp___0 == 0) {
        goto erret;
      }
      if ((long )curwin->w_height < p_hh) {
        {
        win_setheight((int )p_hh);
        }
      }
      {
      curwin->w_p_nu = 0;
      vim_free((void *)help_save_isk);
      help_save_isk = vim_strsave(curbuf->b_p_isk);
      help_save_ts = curbuf->b_p_ts;
      do_ecmd(0, p_hf, (char_u *)((void *)0), (char_u *)((void *)0), (linenr_t )0,
              3);
      set_string_option_direct((char_u *)"isk", -1, (char_u *)"!-~,^*,^|,^\"", 1);
      curbuf->b_p_ts = 8L;
      curwin->w_p_list = 0;
      check_buf_options(curbuf);
      init_chartab();
      }
    }
  }
  if (! p_im) {
    restart_edit = 0;
  }
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    arg = (char_u *)"help.txt";
    need_free = 0;
  } else { //Added block
  if ((int )*arg == 0) {
    arg = (char_u *)"help.txt";
    need_free = 0;
  }
  }
  {
  do_tag(arg, 8, 1, 0, 1);
  }
  erret: 
  if (need_free) {
    {
    vim_free((void *)arg);
    }
  }
  return;
}
}
int help_heuristic(char_u *matched_string , int offset , int wrong_case ) 
{ 
  int num_letters ;
  char_u *p___0 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;

  {
  num_letters = 0;
  p___0 = matched_string;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )*p___0) & 8) {
      num_letters ++;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___0 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___0 + (int )*(matched_string + offset)) & 8) {
    if (offset > 0) {
      {
      tmp___1 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___1 + (int )*(matched_string + (offset - 1))) & 8) {
        offset += 10000;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (offset > 2) {
    offset *= 200;
  }
  }
  if (wrong_case) {
    offset += 5000;
  }
  if ((int )*(matched_string + 0) == 43) {
    offset += 100;
  }
  {
  tmp___2 = strlen((char const   *)((char *)matched_string));
  }
  return ((int )(((size_t )(100 * num_letters) + tmp___2) + (size_t )offset));
}
}
static int help_compare(void const   *s1 , void const   *s2 ) 
{ 
  char *p1 ;
  char *p2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = strlen((char const   *)*((char **)s1));
  p1 = (*((char **)s1) + tmp) + 1;
  tmp___0 = strlen((char const   *)*((char **)s2));
  p2 = (*((char **)s2) + tmp___0) + 1;
  tmp___1 = strcmp((char const   *)p1, (char const   *)p2);
  }
  return (tmp___1);
}
}
static char *mtable[20]  = 
  {      (char *)"*",      (char *)"g*",      (char *)"[*",      (char *)"]*", 
        (char *)":*",      (char *)"/*",      (char *)"/\\*",      (char *)"\"*", 
        (char *)"/\\(\\)",      (char *)"?",      (char *)":?",      (char *)"?<CR>", 
        (char *)"g?",      (char *)"g?g?",      (char *)"g??",      (char *)"[count]", 
        (char *)"[quotex]",      (char *)"[range]",      (char *)"[pattern]",      (char *)"\\|"};
static char *rtable[20]  = 
  {      (char *)"star",      (char *)"gstar",      (char *)"[star",      (char *)"]star", 
        (char *)":star",      (char *)"/star",      (char *)"/\\\\star",      (char *)"quotestar", 
        (char *)"/\\\\(\\\\)",      (char *)"?",      (char *)":?",      (char *)"?<CR>", 
        (char *)"g?",      (char *)"g?g?",      (char *)"g??",      (char *)"\\[count]", 
        (char *)"\\[quotex]",      (char *)"\\[range]",      (char *)"\\[pattern]",      (char *)"\\\\bar"};
int find_help_tags(char_u *arg , int *num_matches___0 , char_u ***matches___0 ) 
{ 
  char_u *s ;
  char_u *d ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;

  {
  d = IObuff;
  i___0 = (int )(sizeof(mtable) / sizeof(char *));
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    {
    tmp = strcmp((char const   *)((char *)arg), (char const   *)mtable[i___0]);
    }
    if (tmp == 0) {
      {
      strcpy((char * __restrict  )((char *)d), (char const   * __restrict  )rtable[i___0]);
      }
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (i___0 < 0) {
    if ((int )*(arg + 0) == 92) {
      if ((int )*(arg + 1) != 0) {
        if ((int )*(arg + 2) == 0) {
          {
          strcpy((char * __restrict  )((char *)d), (char const   * __restrict  )((char *)"/\\\\x"));
          *(d + 3) = *(arg + 1);
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      if ((int )*(arg + 0) == 91) {
        if ((int )*(arg + 1) == 58) {
          tmp___0 = d;
          d ++;
          *tmp___0 = (char_u )'\\';
        }
      }
      s = arg;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! *s) {
          goto while_break___0;
        }
        if (d - IObuff > 1015L) {
          goto while_break___0;
        }
        {
        if ((int )*s == 124) {
          goto case_124;
        }
        if ((int )*s == 34) {
          goto case_34;
        }
        if ((int )*s == 42) {
          goto case_42;
        }
        if ((int )*s == 63) {
          goto case_63;
        }
        if ((int )*s == 36) {
          goto case_36;
        }
        if ((int )*s == 46) {
          goto case_36;
        }
        if ((int )*s == 126) {
          goto case_36;
        }
        goto switch_break;
        case_124: /* CIL Label */ 
        {
        strcpy((char * __restrict  )((char *)d), (char const   * __restrict  )((char *)"bar"));
        d += 3;
        }
        goto __Cont;
        case_34: /* CIL Label */ 
        {
        strcpy((char * __restrict  )((char *)d), (char const   * __restrict  )((char *)"quote"));
        d += 5;
        }
        goto __Cont;
        case_42: /* CIL Label */ 
        tmp___1 = d;
        d ++;
        *tmp___1 = (char_u )'.';
        goto switch_break;
        case_63: /* CIL Label */ 
        tmp___2 = d;
        d ++;
        *tmp___2 = (char_u )'.';
        goto __Cont;
        case_36: /* CIL Label */ 
        case_46: /* CIL Label */ 
        case_126: /* CIL Label */ 
        tmp___3 = d;
        d ++;
        *tmp___3 = (char_u )'\\';
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        if ((int )*s < 32) {
          goto _L;
        } else { //Added block
        if ((int )*s == 94) {
          if (*(s + 1)) {
            if ((int )*(s + 1) != 95) {
              _L: 
              if ((unsigned long )d > (unsigned long )IObuff) {
                if ((int )*(d + -1) != 95) {
                  tmp___4 = d;
                  d ++;
                  *tmp___4 = (char_u )'_';
                }
              }
              {
              strcpy((char * __restrict  )((char *)d), (char const   * __restrict  )((char *)"CTRL-"));
              d += 5;
              }
              if ((int )*s < 32) {
                tmp___5 = d;
                d ++;
                *tmp___5 = (char_u )((int )*s + 64);
              } else {
                tmp___6 = d;
                d ++;
                s ++;
                *tmp___6 = *s;
              }
              if ((int )*(s + 1) != 0) {
                if ((int )*(s + 1) != 95) {
                  tmp___7 = d;
                  d ++;
                  *tmp___7 = (char_u )'_';
                }
              }
              goto __Cont;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if ((int )*s == 94) {
          tmp___8 = d;
          d ++;
          *tmp___8 = (char_u )'\\';
        } else { //Added block
        if ((int )*(s + 0) == 92) {
          if ((int )*(s + 1) != 92) {
            if ((int )*arg == 47) {
              if ((unsigned long )s == (unsigned long )(arg + 1)) {
                tmp___9 = d;
                d ++;
                *tmp___9 = (char_u )'\\';
              }
            }
          }
        }
        }
        }
        }
        tmp___10 = d;
        d ++;
        *tmp___10 = *s;
        if ((int )*s == 39) {
          if ((unsigned long )s > (unsigned long )arg) {
            if ((int )*arg == 39) {
              goto while_break___0;
            }
          }
        }
        __Cont: 
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      *d = (char_u )'\000';
    }
  }
  {
  *matches___0 = (char_u **)"";
  *num_matches___0 = 0;
  tmp___11 = find_tags(IObuff, num_matches___0, matches___0, 39, 2147483647);
  }
  if (tmp___11 == 1) {
    {
    qsort((void *)*matches___0, (size_t )*num_matches___0, sizeof(char_u *), & help_compare);
    }
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-bQYL8qc0.i","-O0")
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
int exec_from_reg ;
int expand_set_path ;
int vgetc_busy ;
int did_syncbind ;
int ex_no_reprint ;
int searchcmdlen  ;
char_u *last_cmdline ;
char_u *new_last_cmdline ;
char_u *autocmd_fname ;
int autocmd_bufnr ;
char_u *autocmd_match ;
int postponed_split ;
char_u *escape_chars ;
FILE *redir_fd ;
int redir_reg ;
char_u e_argreq[18] ;
char_u e_failed[15] ;
char_u e_invaddr[16] ;
char_u e_invarg[17] ;
char_u e_invrange[14] ;
char_u e_noabbr[21] ;
char_u e_nobang[13] ;
char_u e_nogvim[49] ;
char_u e_nomap[16] ;
char_u e_nomatch[9] ;
char_u e_norange[17] ;
char_u e_notopen[19] ;
char_u e_unknown[8] ;
char_u e_write[20] ;
int p_aw  ;
int p_cp  ;
char_u *p_ef  ;
char_u *p_efm  ;
char_u *p_gefm  ;
char_u *p_gp  ;
char_u *p_mef  ;
char_u *p_mp  ;
long p_mmd  ;
long p_pvh  ;
char_u *p_sessopt  ;
char_u *p_sp  ;
char_u *p_viminfo  ;
void mch_restore_title(int which ) ;
long mch_get_pid(void) ;
int mch_FullName(char_u *fname , char_u *buf___3 , int len___0 , int force ) ;
long mch_getperm(char_u *name___1 ) ;
int mch_screenmode(char_u *arg ) ;
int mch_has_wildcard(char_u *p___0 ) ;
void do_exmode(void) ;
char_u *set_one_cmd_context(char_u *buff ) ;
int expand_filename(EXARG *eap , char_u **cmdlinep , char_u **errormsgp ) ;
void separate_nextcmd(EXARG *eap ) ;
void dialog_changed(BUF *buf___3 , int checkall ) ;
int check_changed_any(int hidden ) ;
int rem_backslash(char_u *str___1 ) ;
void backslash_halve(char_u *p___0 ) ;
char_u *backslash_halve_save(char_u *p___0 ) ;
char_u *find_nextcmd(char_u *p___0 ) ;
int do_source(char_u *fname , int check_other , int is_vimrc ) ;
char_u *getsourceline(int c , void *cookie , int indent ) ;
char_u *get_command_name(int idx ) ;
char_u *get_user_commands(int idx ) ;
char_u *get_user_cmd_flags(int idx ) ;
char_u *get_user_cmd_nargs(int idx ) ;
char_u *get_user_cmd_complete(int idx ) ;
char_u *expand_sfile(char_u *arg ) ;
char_u *getexline(int c , void *dummy , int indent ) ;
char_u *getexmodeline(int c , void *dummy , int indent ) ;
void do_history(char_u *arg ) ;
void shorten_fnames(int force ) ;
void do_augroup(char_u *arg ) ;
void do_autocmd(char_u *arg , int forceit ) ;
int do_doautocmd(char_u *arg , int do_msg ) ;
void do_autoall(char_u *arg ) ;
char_u *set_context_in_autocmd(char_u *arg , int doautocmd ) ;
int ins_typebuf(char_u *str___1 , int noremap , int offset , int nottyped ) ;
int typebuf_typed(void) ;
int openscript(char_u *name___1 ) ;
int do_map(int maptype , char_u *keys___0 , int mode , int abbrev , char_u **ambig ) ;
void map_clear(char_u *cmdp , int forceit , int abbr ) ;
char_u *set_context_in_map_cmd(char_u *cmd , char_u *arg , int forceit , int isabbrev ,
                               int isunmap , CMDIDX cmdidx ) ;
int makemap(FILE *fd ) ;
int setmark(int c ) ;
void checkpcmark(void) ;
int check_mark(FPOS *pos___0 ) ;
void do_marks(char_u *arg ) ;
void do_jumps(void) ;
void ml_preserve(BUF *buf___3 , int message ) ;
void goto_byte(long cnt ) ;
void do_menu(EXARG *eap ) ;
char_u *set_context_in_menu_cmd(char_u *cmd , char_u *arg , int forceit ) ;
void execute_menu(char_u *path_name ) ;
void ex_messages(void) ;
int msg_outtrans_attr(char_u *str___1 , int attr ) ;
void msg_make(char_u *arg ) ;
void msg_puts_title(char_u *s ) ;
int vim_dialog_yesnocancel(int type , char_u *title , char_u *message , int dflt ) ;
int vim_dialog_yesnoallcancel(int type , char_u *title , char_u *message , int dflt ) ;
int ask_yesno(char_u *str___1 , int direct ) ;
void beep_flush(void) ;
void del_trailing_spaces(char_u *ptr ) ;
int vim_chdirfile(char_u *fname ) ;
char_u *get_crypt_key(int store ) ;
void normal_cmd(OPARG *oap , int toplevel ) ;
int find_ident_under_cursor(char_u **string___0 , int find_type ) ;
void op_shift(OPARG *oap , int curs_top , int amount ) ;
void set_expr_line(char_u *new_line ) ;
int valid_yank_reg(int regname___0 , int writing ) ;
int do_execreg(int regname___0 , int colon , int addcr ) ;
int op_delete(OPARG *oap ) ;
int op_yank(OPARG *oap , int deleting , int mess ) ;
void do_dis(char_u *arg ) ;
void do_do_join(long count___2 , int insert_space , int redraw ) ;
void clear_oparg(OPARG *oap ) ;
int makeset(FILE *fd ) ;
void set_context_in_set_cmd(char_u *arg ) ;
void vimrc_found(void) ;
int qf_init(char_u *efile , char_u *errorformat ) ;
void qf_jump(int dir , int errornr , int forceit ) ;
void qf_list(char_u *arg , int all ) ;
void qf_older(int count___2 ) ;
void qf_newer(int count___2 ) ;
void redraw_all_later(int type ) ;
void cursor_correct(void) ;
int cursor_valid(void) ;
void scrolldown(long line_count ) ;
void scrollup(long line_count ) ;
void do_intro(void) ;
int do_search(OPARG *oap , int dirc , char_u *str___1 , long count___2 , int options___0 ) ;
void do_syntax(EXARG *eap , char_u **cmdlinep ) ;
void set_context_in_syntax_cmd(char_u *arg ) ;
void do_highlight(char_u *line , int forceit , int init ) ;
void set_context_in_highlight_cmd(char_u *arg ) ;
void do_tags(void) ;
void out_char(unsigned int c ) ;
void term_set_winpos(int x___0 , int y ) ;
void set_winsize(int width , int height , int mustset ) ;
void settmode(int tmode ) ;
void scroll_start(void) ;
char_u *translate_mapping(char_u *str___1 , int expmap ) ;
void ui_suspend(void) ;
void u_undo(int count___2 ) ;
void u_redo(int count___2 ) ;
void do_version(char_u *arg ) ;
char_u *file_name_at_cursor(int options___0 , long count___2 ) ;
char_u *find_file_in_path(char_u *ptr , int len___0 , int options___0 , long count___2 ) ;
int only_one_window(void) ;
static struct cmdname cmdnames[299]  = 
  {      {(char_u *)"append", (long_u )4355}, 
        {(char_u *)"abbreviate", (long_u )10500}, 
        {(char_u *)"abclear", (long_u )256}, 
        {(char_u *)"all", (long_u )17665}, 
        {(char_u *)"amenu", (long_u )30981}, 
        {(char_u *)"anoremenu", (long_u )30981}, 
        {(char_u *)"args", (long_u )33102}, 
        {(char_u *)"argument", (long_u )50439}, 
        {(char_u *)"ascii", (long_u )256}, 
        {(char_u *)"autocmd", (long_u )10246}, 
        {(char_u *)"augroup", (long_u )276}, 
        {(char_u *)"aunmenu", (long_u )10500}, 
        {(char_u *)"buffer", (long_u )83207}, 
        {(char_u *)"bNext", (long_u )17667}, 
        {(char_u *)"ball", (long_u )17665}, 
        {(char_u *)"badd", (long_u )33180}, 
        {(char_u *)"bdelete", (long_u )83207}, 
        {(char_u *)"behave", (long_u )404}, 
        {(char_u *)"blast", (long_u )259}, 
        {(char_u *)"bmodified", (long_u )17667}, 
        {(char_u *)"bnext", (long_u )17667}, 
        {(char_u *)"bprevious", (long_u )17667}, 
        {(char_u *)"brewind", (long_u )259}, 
        {(char_u *)"break", (long_u )262400}, 
        {(char_u *)"browse", (long_u )2180}, 
        {(char_u *)"buffers", (long_u )256}, 
        {(char_u *)"bunload", (long_u )83207}, 
        {(char_u *)"change", (long_u )1283}, 
        {(char_u *)"cNext", (long_u )17667}, 
        {(char_u *)"cabbrev", (long_u )10500}, 
        {(char_u *)"cabclear", (long_u )256}, 
        {(char_u *)"call", (long_u )264325}, 
        {(char_u *)"cc", (long_u )17667}, 
        {(char_u *)"cd", (long_u )348}, 
        {(char_u *)"center", (long_u )261}, 
        {(char_u *)"cfile", (long_u )286}, 
        {(char_u *)"chdir", (long_u )348}, 
        {(char_u *)"checkpath", (long_u )258}, 
        {(char_u *)"clist", (long_u )262}, 
        {(char_u *)"clast", (long_u )17667}, 
        {(char_u *)"close", (long_u )258}, 
        {(char_u *)"cmap", (long_u )10500}, 
        {(char_u *)"cmapclear", (long_u )256}, 
        {(char_u *)"cmenu", (long_u )30981}, 
        {(char_u *)"cnext", (long_u )17667}, 
        {(char_u *)"cnewer", (long_u )17665}, 
        {(char_u *)"cnfile", (long_u )17667}, 
        {(char_u *)"cnoremap", (long_u )10500}, 
        {(char_u *)"cnoreabbrev", (long_u )10500}, 
        {(char_u *)"cnoremenu", (long_u )30981}, 
        {(char_u *)"copy", (long_u )261}, 
        {(char_u *)"colder", (long_u )17665}, 
        {(char_u *)"command", (long_u )10246}, 
        {(char_u *)"comclear", (long_u )256}, 
        {(char_u *)"continue", (long_u )262400}, 
        {(char_u *)"confirm", (long_u )2180}, 
        {(char_u *)"cprevious", (long_u )17667}, 
        {(char_u *)"cquit", (long_u )258}, 
        {(char_u *)"crewind", (long_u )17667}, 
        {(char_u *)"cscope", (long_u )2052}, 
        {(char_u *)"cstag", (long_u )278}, 
        {(char_u *)"cunmap", (long_u )10500}, 
        {(char_u *)"cunabbrev", (long_u )10500}, 
        {(char_u *)"cunmenu", (long_u )10500}, 
        {(char_u *)"delete", (long_u )1793}, 
        {(char_u *)"delcommand", (long_u )404}, 
        {(char_u *)"delfunction", (long_u )404}, 
        {(char_u *)"display", (long_u )2308}, 
        {(char_u *)"digraphs", (long_u )260}, 
        {(char_u *)"djump", (long_u )39}, 
        {(char_u *)"dlist", (long_u )39}, 
        {(char_u *)"doautocmd", (long_u )260}, 
        {(char_u *)"doautoall", (long_u )260}, 
        {(char_u *)"dsearch", (long_u )39}, 
        {(char_u *)"dsplit", (long_u )39}, 
        {(char_u *)"edit", (long_u )33054}, 
        {(char_u *)"echo", (long_u )264196}, 
        {(char_u *)"echohl", (long_u )262404}, 
        {(char_u *)"echon", (long_u )264196}, 
        {(char_u *)"else", (long_u )262400}, 
        {(char_u *)"elseif", (long_u )264196}, 
        {(char_u *)"emenu", (long_u )2436}, 
        {(char_u *)"endif", (long_u )262400}, 
        {(char_u *)"endfunction", (long_u )256}, 
        {(char_u *)"endwhile", (long_u )262400}, 
        {(char_u *)"ex", (long_u )33054}, 
        {(char_u *)"execute", (long_u )264196}, 
        {(char_u *)"exit", (long_u )319}, 
        {(char_u *)"file", (long_u )286}, 
        {(char_u *)"files", (long_u )256}, 
        {(char_u *)"filetype", (long_u )404}, 
        {(char_u *)"find", (long_u )33054}, 
        {(char_u *)"fixdel", (long_u )256}, 
        {(char_u *)"function", (long_u )6}, 
        {(char_u *)"global", (long_u )39}, 
        {(char_u *)"goto", (long_u )279809}, 
        {(char_u *)"grep", (long_u )2444}, 
        {(char_u *)"gui", (long_u )33102}, 
        {(char_u *)"gvim", (long_u )33102}, 
        {(char_u *)"help", (long_u )2052}, 
        {(char_u *)"helpfind", (long_u )2052}, 
        {(char_u *)"highlight", (long_u )262406}, 
        {(char_u *)"hide", (long_u )258}, 
        {(char_u *)"history", (long_u )260}, 
        {(char_u *)"insert", (long_u )259}, 
        {(char_u *)"iabbrev", (long_u )10500}, 
        {(char_u *)"iabclear", (long_u )256}, 
        {(char_u *)"if", (long_u )264196}, 
        {(char_u *)"ijump", (long_u )39}, 
        {(char_u *)"ilist", (long_u )39}, 
        {(char_u *)"imap", (long_u )10500}, 
        {(char_u *)"imapclear", (long_u )256}, 
        {(char_u *)"imenu", (long_u )30981}, 
        {(char_u *)"inoremap", (long_u )10500}, 
        {(char_u *)"inoreabbrev", (long_u )10500}, 
        {(char_u *)"inoremenu", (long_u )30981}, 
        {(char_u *)"intro", (long_u )256}, 
        {(char_u *)"isearch", (long_u )39}, 
        {(char_u *)"isplit", (long_u )39}, 
        {(char_u *)"iunmap", (long_u )10500}, 
        {(char_u *)"iunabbrev", (long_u )10500}, 
        {(char_u *)"iunmenu", (long_u )10500}, 
        {(char_u *)"join", (long_u )1283}, 
        {(char_u *)"jumps", (long_u )256}, 
        {(char_u *)"k", (long_u )262421}, 
        {(char_u *)"list", (long_u )1281}, 
        {(char_u *)"last", (long_u )33030}, 
        {(char_u *)"left", (long_u )261}, 
        {(char_u *)"let", (long_u )264196}, 
        {(char_u *)"ls", (long_u )256}, 
        {(char_u *)"move", (long_u )261}, 
        {(char_u *)"mark", (long_u )262421}, 
        {(char_u *)"make", (long_u )2316}, 
        {(char_u *)"map", (long_u )10502}, 
        {(char_u *)"mapclear", (long_u )258}, 
        {(char_u *)"marks", (long_u )260}, 
        {(char_u *)"menu", (long_u )30983}, 
        {(char_u *)"messages", (long_u )256}, 
        {(char_u *)"mkexrc", (long_u )286}, 
        {(char_u *)"mksession", (long_u )286}, 
        {(char_u *)"mkvimrc", (long_u )286}, 
        {(char_u *)"mode", (long_u )276}, 
        {(char_u *)"next", (long_u )49487}, 
        {(char_u *)"new", (long_u )49439}, 
        {(char_u *)"nmap", (long_u )10500}, 
        {(char_u *)"nmapclear", (long_u )256}, 
        {(char_u *)"nmenu", (long_u )30981}, 
        {(char_u *)"nnoremap", (long_u )10500}, 
        {(char_u *)"nnoremenu", (long_u )30981}, 
        {(char_u *)"noremap", (long_u )10502}, 
        {(char_u *)"nohlsearch", (long_u )262400}, 
        {(char_u *)"noreabbrev", (long_u )10500}, 
        {(char_u *)"noremenu", (long_u )30983}, 
        {(char_u *)"normal", (long_u )272519}, 
        {(char_u *)"number", (long_u )1281}, 
        {(char_u *)"nunmap", (long_u )10500}, 
        {(char_u *)"nunmenu", (long_u )10500}, 
        {(char_u *)"open", (long_u )256}, 
        {(char_u *)"omap", (long_u )10500}, 
        {(char_u *)"omapclear", (long_u )256}, 
        {(char_u *)"omenu", (long_u )30981}, 
        {(char_u *)"only", (long_u )258}, 
        {(char_u *)"onoremap", (long_u )10500}, 
        {(char_u *)"onoremenu", (long_u )30981}, 
        {(char_u *)"options", (long_u )256}, 
        {(char_u *)"ounmap", (long_u )10500}, 
        {(char_u *)"ounmenu", (long_u )10500}, 
        {(char_u *)"print", (long_u )1281}, 
        {(char_u *)"pclose", (long_u )258}, 
        {(char_u *)"perl", (long_u )262309}, 
        {(char_u *)"perldo", (long_u )262309}, 
        {(char_u *)"pop", (long_u )21763}, 
        {(char_u *)"ppop", (long_u )21763}, 
        {(char_u *)"preserve", (long_u )256}, 
        {(char_u *)"previous", (long_u )50439}, 
        {(char_u *)"promptfind", (long_u )2052}, 
        {(char_u *)"promptrepl", (long_u )2052}, 
        {(char_u *)"ptag", (long_u )20759}, 
        {(char_u *)"ptNext", (long_u )20739}, 
        {(char_u *)"ptjump", (long_u )278}, 
        {(char_u *)"ptlast", (long_u )258}, 
        {(char_u *)"ptnext", (long_u )20739}, 
        {(char_u *)"ptprevious", (long_u )20739}, 
        {(char_u *)"ptrewind", (long_u )20739}, 
        {(char_u *)"ptselect", (long_u )278}, 
        {(char_u *)"put", (long_u )4867}, 
        {(char_u *)"pwd", (long_u )256}, 
        {(char_u *)"python", (long_u )262277}, 
        {(char_u *)"pyfile", (long_u )262301}, 
        {(char_u *)"quit", (long_u )258}, 
        {(char_u *)"qall", (long_u )258}, 
        {(char_u *)"read", (long_u )4447}, 
        {(char_u *)"recover", (long_u )286}, 
        {(char_u *)"redo", (long_u )256}, 
        {(char_u *)"redir", (long_u )270}, 
        {(char_u *)"registers", (long_u )2308}, 
        {(char_u *)"resize", (long_u )276}, 
        {(char_u *)"retab", (long_u )311}, 
        {(char_u *)"return", (long_u )264196}, 
        {(char_u *)"rewind", (long_u )33030}, 
        {(char_u *)"right", (long_u )261}, 
        {(char_u *)"rviminfo", (long_u )286}, 
        {(char_u *)"substitute", (long_u )5}, 
        {(char_u *)"sNext", (long_u )50439}, 
        {(char_u *)"sargument", (long_u )50439}, 
        {(char_u *)"sall", (long_u )17665}, 
        {(char_u *)"sbuffer", (long_u )83207}, 
        {(char_u *)"sbNext", (long_u )17665}, 
        {(char_u *)"sball", (long_u )17665}, 
        {(char_u *)"sblast", (long_u )256}, 
        {(char_u *)"sbmodified", (long_u )17665}, 
        {(char_u *)"sbnext", (long_u )17665}, 
        {(char_u *)"sbprevious", (long_u )17665}, 
        {(char_u *)"sbrewind", (long_u )256}, 
        {(char_u *)"set", (long_u )260}, 
        {(char_u *)"sfind", (long_u )49439}, 
        {(char_u *)"shell", (long_u )256}, 
        {(char_u *)"sleep", (long_u )17669}, 
        {(char_u *)"slast", (long_u )33030}, 
        {(char_u *)"smagic", (long_u )5}, 
        {(char_u *)"snext", (long_u )49487}, 
        {(char_u *)"sniff", (long_u )260}, 
        {(char_u *)"snomagic", (long_u )5}, 
        {(char_u *)"source", (long_u )262494}, 
        {(char_u *)"split", (long_u )49439}, 
        {(char_u *)"sprevious", (long_u )50439}, 
        {(char_u *)"srewind", (long_u )33030}, 
        {(char_u *)"stop", (long_u )258}, 
        {(char_u *)"stag", (long_u )20759}, 
        {(char_u *)"startinsert", (long_u )258}, 
        {(char_u *)"stjump", (long_u )278}, 
        {(char_u *)"stselect", (long_u )278}, 
        {(char_u *)"sunhide", (long_u )17665}, 
        {(char_u *)"suspend", (long_u )258}, 
        {(char_u *)"sview", (long_u )33183}, 
        {(char_u *)"swapname", (long_u )256}, 
        {(char_u *)"syntax", (long_u )2052}, 
        {(char_u *)"syncbind", (long_u )256}, 
        {(char_u *)"t", (long_u )261}, 
        {(char_u *)"tNext", (long_u )20739}, 
        {(char_u *)"tag", (long_u )20759}, 
        {(char_u *)"tags", (long_u )256}, 
        {(char_u *)"tcl", (long_u )262277}, 
        {(char_u *)"tcldo", (long_u )262309}, 
        {(char_u *)"tclfile", (long_u )262301}, 
        {(char_u *)"tearoff", (long_u )2436}, 
        {(char_u *)"tjump", (long_u )278}, 
        {(char_u *)"tlast", (long_u )258}, 
        {(char_u *)"tmenu", (long_u )30981}, 
        {(char_u *)"tnext", (long_u )20739}, 
        {(char_u *)"tprevious", (long_u )20739}, 
        {(char_u *)"trewind", (long_u )20739}, 
        {(char_u *)"tselect", (long_u )278}, 
        {(char_u *)"tunmenu", (long_u )10500}, 
        {(char_u *)"undo", (long_u )256}, 
        {(char_u *)"unabbreviate", (long_u )10500}, 
        {(char_u *)"unhide", (long_u )17665}, 
        {(char_u *)"unlet", (long_u )262534}, 
        {(char_u *)"unmap", (long_u )10502}, 
        {(char_u *)"unmenu", (long_u )10502}, 
        {(char_u *)"update", (long_u )319}, 
        {(char_u *)"vglobal", (long_u )37}, 
        {(char_u *)"version", (long_u )260}, 
        {(char_u *)"visual", (long_u )33055}, 
        {(char_u *)"view", (long_u )33055}, 
        {(char_u *)"vmap", (long_u )10500}, 
        {(char_u *)"vmapclear", (long_u )256}, 
        {(char_u *)"vmenu", (long_u )30981}, 
        {(char_u *)"vnoremap", (long_u )10500}, 
        {(char_u *)"vnoremenu", (long_u )30981}, 
        {(char_u *)"vunmap", (long_u )10500}, 
        {(char_u *)"vunmenu", (long_u )10500}, 
        {(char_u *)"write", (long_u )319}, 
        {(char_u *)"wNext", (long_u )16671}, 
        {(char_u *)"wall", (long_u )258}, 
        {(char_u *)"while", (long_u )264196}, 
        {(char_u *)"winsize", (long_u )388}, 
        {(char_u *)"winpos", (long_u )260}, 
        {(char_u *)"wnext", (long_u )16671}, 
        {(char_u *)"wprevious", (long_u )16671}, 
        {(char_u *)"wq", (long_u )319}, 
        {(char_u *)"wqall", (long_u )318}, 
        {(char_u *)"wviminfo", (long_u )286}, 
        {(char_u *)"xit", (long_u )319}, 
        {(char_u *)"xall", (long_u )258}, 
        {(char_u *)"yank", (long_u )1793}, 
        {(char_u *)"z", (long_u )261}, 
        {(char_u *)"!", (long_u )79}, 
        {(char_u *)"#", (long_u )1281}, 
        {(char_u *)"&", (long_u )5}, 
        {(char_u *)"*", (long_u )261}, 
        {(char_u *)"<", (long_u )1281}, 
        {(char_u *)"=", (long_u )257}, 
        {(char_u *)">", (long_u )1281}, 
        {(char_u *)"@", (long_u )261}, 
        {(char_u *)"Next", (long_u )50439}, 
        {(char_u *)"Print", (long_u )1281}, 
        {(char_u *)"X", (long_u )256}, 
        {(char_u *)"~", (long_u )5}};
static int quitmore  =    0;
static int ex_pressedreturn  =    0;
struct growarray ucmds  =    {0, 0, (int )sizeof(UCMD ), 4, (void *)0};
static void do_ucmd(UCMD *cmd , EXARG *eap ) ;
static void do_command(EXARG *eap ) ;
static void do_comclear(void) ;
static void do_delcommand(EXARG *eap ) ;
static char_u *get_user_command_name(int idx ) ;
static void free_cmdlines(struct growarray *gap ) ;
static char_u *do_one_cmd(char_u **cmdlinep , int sourcing , struct condstack *cstack ,
                          char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
static void goto_buffer(EXARG *eap , int start___0 , int dir , int count___2 ) ;
static char_u *getargcmd(char_u **argp ) ;
static char_u *skip_cmd_arg(char_u *p___0 ) ;
static void do_make(char_u *arg , char_u *errorformat ) ;
static char_u *get_mef_name(int newname ) ;
static void do_cfile(EXARG *eap ) ;
static int do_arglist(char_u *str___1 ) ;
static int check_more(int message , int forceit ) ;
static linenr_t get_address(char_u **ptr , int skip ) ;
static char_u *invalid_range(EXARG *eap ) ;
static void correct_range(EXARG *eap ) ;
static char_u *repl_cmdline(EXARG *eap , char_u *src , int srclen , char_u *repl ,
                            char_u **cmdlinep ) ;
static void do_quit(EXARG *eap ) ;
static void do_quit_all(int forceit ) ;
static void do_close(EXARG *eap , WIN *win ) ;
static void do_pclose(EXARG *eap ) ;
static void do_suspend(int forceit ) ;
static void do_exit(EXARG *eap ) ;
static void do_print(EXARG *eap ) ;
static void do_next(EXARG *eap ) ;
static void do_recover(EXARG *eap ) ;
static void do_args(EXARG *eap ) ;
static void do_resize(EXARG *eap ) ;
static void do_splitview(EXARG *eap ) ;
static void do_find(EXARG *eap ) ;
static void do_exedit(EXARG *eap , WIN *old_curwin___0 ) ;
static void do_swapname(void) ;
static void do_syncbind(void) ;
static void do_read(EXARG *eap ) ;
static void do_cd(EXARG *eap ) ;
static void do_pwd(void) ;
static void do_sleep(EXARG *eap ) ;
static void do_exmap(EXARG *eap , int isabbrev ) ;
static void do_winsize(char_u *arg ) ;
static void do_winpos(char_u *arg ) ;
static void do_exops(EXARG *eap ) ;
static void do_copymove(EXARG *eap ) ;
static void do_exjoin(EXARG *eap ) ;
static void do_exat(EXARG *eap ) ;
static void do_redir(EXARG *eap ) ;
static void close_redir(void) ;
static void do_mkrc(EXARG *eap , char_u *defname ) ;
static FILE *open_exfile(EXARG *eap , char *mode ) ;
static void do_setmark(EXARG *eap ) ;
static void do_normal(EXARG *eap ) ;
static char_u *do_findpat(EXARG *eap , int action ) ;
static void do_ex_tag(EXARG *eap , int dt , int preview ) ;
static char_u *do_if(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_else(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_while(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_continue(struct condstack *cstack ) ;
static char_u *do_break(struct condstack *cstack ) ;
static char_u *do_endwhile(struct condstack *cstack ) ;
static int has_while_cmd(char_u *p___0 ) ;
static int did_endif  =    0;
static int makeopens(FILE *fd ) ;
static int ses_fname_line(FILE *fd , char *cmd , linenr_t lnum , BUF *buf___3 ) ;
static int ses_fname(FILE *fd , BUF *buf___3 ) ;
static void cmd_source(char_u *fname , int forceit ) ;
static void ex_behave(char_u *arg ) ;
static void ex_filetype(char_u *arg ) ;
static void ex_options(void) ;
CMDIDX cmdidxs[27]  = 
  {      (CMDIDX )0,      (CMDIDX )12,      (CMDIDX )27,      (CMDIDX )64, 
        (CMDIDX )75,      (CMDIDX )88,      (CMDIDX )94,      (CMDIDX )99, 
        (CMDIDX )104,      (CMDIDX )122,      (CMDIDX )124,      (CMDIDX )125, 
        (CMDIDX )130,      (CMDIDX )142,      (CMDIDX )157,      (CMDIDX )167, 
        (CMDIDX )189,      (CMDIDX )191,      (CMDIDX )202,      (CMDIDX )238, 
        (CMDIDX )254,      (CMDIDX )261,      (CMDIDX )272,      (CMDIDX )283, 
        (CMDIDX )285,      (CMDIDX )286,      (CMDIDX )287};
void do_exmode(void) 
{ 
  int save_msg_scroll ;
  int prev_msg_row ;
  linenr_t prev_line ;

  {
  {
  save_msg_scroll = msg_scroll;
  RedrawingDisabled ++;
  no_wait_return ++;
  settmode(0);
  State = 1;
  exmode_active = 1;
  msg((char_u *)"Entering Ex mode.  Type \"visual\" to go to Normal mode.");
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! exmode_active) {
      goto while_break;
    }
    {
    msg_scroll = 1;
    need_wait_return = 0;
    ex_pressedreturn = 0;
    ex_no_reprint = 0;
    prev_msg_row = msg_row;
    prev_line = curwin->w_cursor.lnum;
    do_cmdline((char_u *)((void *)0), & getexmodeline, (void *)0, 2);
    lines_left = (int )(Rows - 1L);
    }
    if (prev_line != curwin->w_cursor.lnum) {
      if (! ex_no_reprint) {
        if (ex_pressedreturn) {
          msg_row = prev_msg_row;
          if ((long )prev_msg_row == Rows - 1L) {
            msg_row --;
          }
        }
        {
        msg_col = 0;
        print_line_no_prefix(curwin->w_cursor.lnum, 0);
        msg_clr_eos();
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (ex_pressedreturn) {
      {
      emsg((char_u *)"At end-of-file");
      }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  settmode(2);
  RedrawingDisabled --;
  no_wait_return --;
  update_screen(50);
  need_wait_return = 0;
  msg_scroll = save_msg_scroll;
  }
  return;
}
}
static int recursive  =    0;
int do_cmdline(char_u *cmdline , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int flags___0 ) 
{ 
  char_u *next_cmdline ;
  char_u *cmdline_copy ;
  int msg_didout_before_start ;
  int count___2 ;
  int did_inc ;
  int retval ;
  int save_confirm ;
  struct condstack cstack ;
  struct growarray lines_ga ;
  int current_line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  cmdline_copy = (char_u *)((void *)0);
  msg_didout_before_start = 0;
  count___2 = 0;
  did_inc = 0;
  retval = 1;
  save_confirm = confirm;
  current_line = 0;
  cstack.cs_idx = -1;
  cstack.cs_whilelevel = 0;
  cstack.cs_had_while = (char)0;
  cstack.cs_had_endwhile = (char)0;
  cstack.cs_had_continue = (char)0;
  ga_init2(& lines_ga, (int )sizeof(char_u *), 10);
  confirm = 0;
  did_emsg = 0;
  }
  if ((unsigned long )getline___0 != (unsigned long )(& getexline)) {
    KeyTyped = 0;
  }
  next_cmdline = cmdline;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
      if (cstack.cs_idx < 0) {
        did_emsg = 0;
      }
    }
    if (cstack.cs_whilelevel) {
      if (current_line < lines_ga.ga_len) {
        {
        vim_free((void *)cmdline_copy);
        cmdline_copy = (char_u *)((void *)0);
        }
        if ((unsigned long )getline___0 == (unsigned long )(& get_func_line)) {
          {
          tmp = func_has_ended(cookie);
          }
          if (tmp) {
            retval = 0;
            goto while_break;
          }
        }
        next_cmdline = *((char_u **)lines_ga.ga_data + current_line);
      }
    }
    if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
      if (count___2 == 1) {
        if ((unsigned long )getline___0 == (unsigned long )(& getexline)) {
          msg_didout = 1;
        }
      }
      if ((unsigned long )getline___0 == (unsigned long )((void *)0)) {
        goto _L;
      } else {
        if (cstack.cs_idx < 0) {
          tmp___0 = 0;
        } else {
          tmp___0 = (cstack.cs_idx + 1) * 2;
        }
        {
        next_cmdline = (*getline___0)(':', cookie, tmp___0);
        }
        if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
          _L: 
          if (KeyTyped) {
            need_wait_return = 0;
          }
          retval = 0;
          goto while_break;
        }
      }
    } else { //Added block
    if ((unsigned long )cmdline_copy == (unsigned long )((void *)0)) {
      {
      next_cmdline = vim_strsave(next_cmdline);
      }
      if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
        retval = 0;
        goto while_break;
      }
    }
    }
    cmdline_copy = next_cmdline;
    if (current_line == lines_ga.ga_len) {
      if (cstack.cs_whilelevel) {
        goto _L___0;
      } else {
        {
        tmp___1 = has_while_cmd(next_cmdline);
        }
        if (tmp___1) {
          _L___0: 
          {
          tmp___2 = ga_grow(& lines_ga, 1);
          }
          if (tmp___2 == 1) {
            {
            *((char_u **)lines_ga.ga_data + current_line) = vim_strsave(next_cmdline);
            (lines_ga.ga_len) ++;
            (lines_ga.ga_room) --;
            }
          }
        }
      }
    }
    did_endif = 0;
    tmp___3 = count___2;
    count___2 ++;
    if (tmp___3 == 0) {
      if (! (flags___0 & 2)) {
        if (! recursive) {
          {
          msg_didout_before_start = msg_didout;
          msg_didany = 0;
          msg_start();
          msg_scroll = 1;
          no_wait_return ++;
          RedrawingDisabled ++;
          did_inc = 1;
          }
        }
      }
    }
    {
    recursive ++;
    next_cmdline = do_one_cmd(& cmdline_copy, flags___0 & 1, & cstack, getline___0,
                              cookie);
    recursive --;
    }
    if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
      {
      vim_free((void *)cmdline_copy);
      cmdline_copy = (char_u *)((void *)0);
      }
      if ((unsigned long )getline___0 == (unsigned long )(& getexline)) {
        if ((unsigned long )new_last_cmdline != (unsigned long )((void *)0)) {
          {
          vim_free((void *)last_cmdline);
          last_cmdline = new_last_cmdline;
          new_last_cmdline = (char_u *)((void *)0);
          }
        }
      }
    } else {
      {
      tmp___4 = strlen((char const   *)((char *)next_cmdline));
      memmove((void *)((char *)cmdline_copy), (void const   *)((char *)next_cmdline),
              tmp___4 + 1UL);
      next_cmdline = cmdline_copy;
      }
    }
    if (did_emsg) {
      if ((unsigned long )getline___0 == (unsigned long )(& get_func_line)) {
        {
        tmp___5 = func_has_abort(cookie);
        }
        if (! tmp___5) {
          did_emsg = 0;
        }
      }
    }
    if (cstack.cs_whilelevel) {
      current_line ++;
      if (cstack.cs_had_endwhile) {
        goto _L___5;
      } else { //Added block
      if (cstack.cs_had_continue) {
        _L___5: 
        if (cstack.cs_had_endwhile) {
          cstack.cs_had_endwhile = (char)0;
        } else {
          cstack.cs_had_continue = (char)0;
        }
        if (! did_emsg) {
          if (cstack.cs_idx >= 0) {
            if ((int )cstack.cs_flags[cstack.cs_idx] & 4) {
              if (cstack.cs_line[cstack.cs_idx] >= 0) {
                if ((int )cstack.cs_flags[cstack.cs_idx] & 2) {
                  {
                  current_line = cstack.cs_line[cstack.cs_idx];
                  cstack.cs_had_while = (char)1;
                  line_breakcheck();
                  }
                } else {
                  goto _L___4;
                }
              } else {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          (cstack.cs_whilelevel) --;
          if (cstack.cs_idx >= 0) {
            (cstack.cs_idx) --;
          }
        }
      } else { //Added block
      if (cstack.cs_had_while) {
        cstack.cs_had_while = (char)0;
        cstack.cs_line[cstack.cs_idx] = current_line - 1;
      }
      }
      }
    }
    if (! cstack.cs_whilelevel) {
      {
      free_cmdlines(& lines_ga);
      current_line = 0;
      }
    }
    if (! got_int) {
      if (did_emsg) {
        if ((unsigned long )getline___0 == (unsigned long )(& getexmodeline)) {
          goto while_break;
        } else { //Added block
        if ((unsigned long )getline___0 == (unsigned long )(& getexline)) {
          goto while_break;
        } else {
          goto _L___6;
        }
        }
      } else { //Added block
      _L___6: 
      if (! ((unsigned long )next_cmdline != (unsigned long )((void *)0))) {
        if (! (cstack.cs_idx >= 0)) {
          if (! (flags___0 & 4)) {
            goto while_break;
          }
        }
      }
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)cmdline_copy);
  free_cmdlines(& lines_ga);
  ga_clear(& lines_ga);
  }
  if (cstack.cs_idx >= 0) {
    if ((unsigned long )getline___0 == (unsigned long )(& getsourceline)) {
      goto _L___7;
    } else { //Added block
    if ((unsigned long )getline___0 == (unsigned long )(& get_func_line)) {
      {
      tmp___6 = func_has_ended(cookie);
      }
      if (! tmp___6) {
        _L___7: 
        if ((int )cstack.cs_flags[cstack.cs_idx] & 4) {
          {
          emsg((char_u *)"Missing :endwhile");
          }
        } else {
          {
          emsg((char_u *)"Missing :endif");
          }
        }
      }
    }
    }
  }
  if (did_inc) {
    RedrawingDisabled --;
    no_wait_return --;
    msg_scroll = 0;
    if (retval == 0) {
      {
      need_wait_return = 0;
      msg_didany = 0;
      redraw_later(40);
      }
    } else { //Added block
    if (did_endif) {
      if (KeyTyped) {
        if (! did_emsg) {
          {
          need_wait_return = 0;
          msg_didany = 0;
          redraw_later(40);
          }
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else { //Added block
    _L___9: 
    if (need_wait_return) {
      {
      msg_didout = msg_didout_before_start;
      wait_return(0);
      }
    }
    }
    }
  }
  confirm = save_confirm;
  return (retval);
}
}
static void free_cmdlines(struct growarray *gap ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! gap->ga_len) {
      goto while_break;
    }
    {
    vim_free((void *)*((char_u **)gap->ga_data + (gap->ga_len - 1)));
    (gap->ga_len) --;
    (gap->ga_room) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char_u *do_one_cmd(char_u **cmdlinep , int sourcing , struct condstack *cstack ,
                          char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{ 
  char_u *p___0 ;
  int i___0 ;
  linenr_t lnum ;
  long n ;
  char_u *errormsg ;
  EXARG ea ;
  int tmp ;
  FPOS *fp___0 ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  UCMD *cmd ;
  int j ;
  int k ;
  int matchlen ;
  int found ;
  int possible ;
  char_u *cp ;
  char_u *np___0 ;
  unsigned short const   **tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  char_u *new_cmdline ;
  char_u *program ;
  char_u *pos___0 ;
  char_u *ptr ;
  int len___0 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char_u *tmp___18 ;
  char_u *tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  char_u *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  size_t tmp___44 ;

  {
  {
  errormsg = (char_u *)((void *)0);
  memset((void *)(& ea), 0, sizeof(ea));
  ea.line1 = (linenr_t )1;
  ea.line2 = (linenr_t )1;
  }
  if (quitmore) {
    if ((unsigned long )getline___0 != (unsigned long )(& get_func_line)) {
      quitmore --;
    }
  }
  ea.cmd = *cmdlinep;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*(ea.cmd) == 32)) {
      if (! ((int )*(ea.cmd) == 9)) {
        if (! ((int )*(ea.cmd) == 58)) {
          goto while_break;
        }
      }
    }
    (ea.cmd) ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*(ea.cmd) == 0) {
    if (exmode_active) {
      if ((unsigned long )getline___0 == (unsigned long )(& getexmodeline)) {
        ea.cmd = (char_u *)"+";
        ex_pressedreturn = 1;
      }
    }
  }
  if ((int )*(ea.cmd) == 34) {
    goto doend;
  } else { //Added block
  if ((int )*(ea.cmd) == 0) {
    goto doend;
  }
  }
  if (did_emsg) {
    tmp = 1;
  } else { //Added block
  if (cstack->cs_idx >= 0) {
    if (! ((int )cstack->cs_flags[cstack->cs_idx] & 2)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  }
  ea.skip = tmp;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    ea.line1 = ea.line2;
    ea.line2 = curwin->w_cursor.lnum;
    ea.cmd = skipwhite(ea.cmd);
    lnum = get_address(& ea.cmd, ea.skip);
    }
    if ((unsigned long )ea.cmd == (unsigned long )((void *)0)) {
      goto doend;
    }
    if (lnum == 2147483647L) {
      if ((int )*(ea.cmd) == 37) {
        (ea.cmd) ++;
        ea.line1 = (linenr_t )1;
        ea.line2 = curbuf->b_ml.ml_line_count;
        (ea.addr_count) ++;
      } else { //Added block
      if ((int )*(ea.cmd) == 42) {
        {
        tmp___2 = vim_strchr(p_cpo, '*');
        }
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
          (ea.cmd) ++;
          if (! ea.skip) {
            {
            fp___0 = getmark('<', 0);
            tmp___0 = check_mark(fp___0);
            }
            if (tmp___0 == 0) {
              goto doend;
            }
            {
            ea.line1 = fp___0->lnum;
            fp___0 = getmark('>', 0);
            tmp___1 = check_mark(fp___0);
            }
            if (tmp___1 == 0) {
              goto doend;
            }
            ea.line2 = fp___0->lnum;
            (ea.addr_count) ++;
          }
        }
      }
      }
    } else {
      ea.line2 = lnum;
    }
    (ea.addr_count) ++;
    if ((int )*(ea.cmd) == 59) {
      if (! ea.skip) {
        curwin->w_cursor.lnum = ea.line2;
      }
    } else { //Added block
    if ((int )*(ea.cmd) != 44) {
      goto while_break___0;
    }
    }
    (ea.cmd) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (ea.addr_count == 1) {
    ea.line1 = ea.line2;
    if (lnum == 2147483647L) {
      ea.addr_count = 0;
    }
  }
  {
  check_cursor_lnum();
  ea.cmd = skipwhite(ea.cmd);
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! ((int )*(ea.cmd) == 58)) {
      goto while_break___1;
    }
    {
    ea.cmd = skipwhite(ea.cmd + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  if ((int )*(ea.cmd) == 0) {
    goto _L;
  } else { //Added block
  if ((int )*(ea.cmd) == 34) {
    goto _L;
  } else {
    {
    ea.nextcmd = check_nextcmd(ea.cmd);
    }
    if ((unsigned long )ea.nextcmd != (unsigned long )((void *)0)) {
      _L: 
      if (ea.skip) {
        goto doend;
      }
      if ((int )*(ea.cmd) == 124) {
        {
        ea.cmdidx = (CMDIDX )167;
        ea.argt = 1281L;
        errormsg = invalid_range(& ea);
        }
        if ((unsigned long )errormsg == (unsigned long )((void *)0)) {
          {
          correct_range(& ea);
          do_print(& ea);
          }
        }
      } else { //Added block
      if (ea.addr_count != 0) {
        if (ea.line2 < 0L) {
          {
          errormsg = invalid_range(& ea);
          }
        } else { //Added block
        if (ea.line2 == 0L) {
          curwin->w_cursor.lnum = (linenr_t )1;
        } else { //Added block
        if (ea.line2 > curbuf->b_ml.ml_line_count) {
          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
        } else {
          curwin->w_cursor.lnum = ea.line2;
        }
        }
        }
        {
        beginline(6);
        }
      }
      }
      goto doend;
    }
  }
  }
  if ((int )*(ea.cmd) == 107) {
    ea.cmdidx = (CMDIDX )124;
    p___0 = ea.cmd + 1;
  } else { //Added block
  if ((int )*(ea.cmd + 0) == 115) {
    if ((int )*(ea.cmd + 1) == 99) {
      ea.cmdidx = (CMDIDX )202;
      p___0 = ea.cmd + 1;
    } else { //Added block
    if ((int )*(ea.cmd + 1) == 103) {
      ea.cmdidx = (CMDIDX )202;
      p___0 = ea.cmd + 1;
    } else { //Added block
    if ((int )*(ea.cmd + 1) == 105) {
      if ((int )*(ea.cmd + 2) != 109) {
        ea.cmdidx = (CMDIDX )202;
        p___0 = ea.cmd + 1;
      } else {
        goto _L___3;
      }
    } else { //Added block
    _L___3: 
    if ((int )*(ea.cmd + 1) == 73) {
      ea.cmdidx = (CMDIDX )202;
      p___0 = ea.cmd + 1;
    } else { //Added block
    if ((int )*(ea.cmd + 1) == 114) {
      if ((int )*(ea.cmd + 2) != 101) {
        ea.cmdidx = (CMDIDX )202;
        p___0 = ea.cmd + 1;
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
    }
    }
    }
    }
  } else {
    _L___2: 
    p___0 = ea.cmd;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
      tmp___3 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___3 + (int )*p___0) & 1024)) {
        goto while_break___2;
      }
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    if ((unsigned long )p___0 == (unsigned long )ea.cmd) {
      {
      tmp___4 = vim_strchr((char_u *)"@*!=><&~#", (int )*p___0);
      }
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
        p___0 ++;
      }
    }
    i___0 = (int )(p___0 - ea.cmd);
    if ((int )*(ea.cmd) >= 97) {
      if ((int )*(ea.cmd) <= 122) {
        ea.cmdidx = cmdidxs[(int )*(ea.cmd) - 97];
      } else {
        ea.cmdidx = cmdidxs[26];
      }
    } else {
      ea.cmdidx = cmdidxs[26];
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! ((int )ea.cmdidx < 299)) {
        goto while_break___3;
      }
      {
      tmp___5 = strncmp((char const   *)((char *)cmdnames[(int )ea.cmdidx].cmd_name),
                        (char const   *)((char *)ea.cmd), (size_t )i___0);
      }
      if (tmp___5 == 0) {
        goto while_break___3;
      }
      ea.cmdidx = (CMDIDX )((int )ea.cmdidx + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
    if ((int )ea.cmdidx == 299) {
      if ((int )*(ea.cmd) >= 65) {
        if ((int )*(ea.cmd) <= 90) {
          cmd = (UCMD *)ucmds.ga_data + 0;
          matchlen = 0;
          found = 0;
          possible = 0;
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
            tmp___6 = __ctype_b_loc();
            }
            if (! ((int const   )*(*tmp___6 + (int )*p___0) & 8)) {
              goto while_break___4;
            }
            p___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          i___0 = (int )(p___0 - ea.cmd);
          j = 0;
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (! (j < ucmds.ga_len)) {
              goto while_break___5;
            }
            cp = ea.cmd;
            np___0 = cmd->uc_name;
            k = 0;
            {
            while (1) {
              while_continue___6: /* CIL Label */ ;
              if (k < i___0) {
                if ((int )*np___0 != 0) {
                  tmp___7 = cp;
                  cp ++;
                  tmp___8 = np___0;
                  np___0 ++;
                  if (! ((int )*tmp___7 == (int )*tmp___8)) {
                    goto while_break___6;
                  }
                } else {
                  goto while_break___6;
                }
              } else {
                goto while_break___6;
              }
              k ++;
            }
            while_break___6: /* CIL Label */ ;
            }
            if (k == i___0) {
              goto _L___0;
            } else { //Added block
            if ((int )*np___0 == 0) {
              {
              tmp___9 = __ctype_b_loc();
              }
              if ((int const   )*(*tmp___9 + (int )*(ea.cmd + k)) & 2048) {
                _L___0: 
                if (k == i___0) {
                  if (found) {
                    errormsg = (char_u *)"Ambiguous use of user-defined command";
                    goto doend;
                  }
                }
                if (! found) {
                  if (k == i___0) {
                    found = 1;
                  } else {
                    possible = 1;
                  }
                  ea.cmdidx = (CMDIDX )-1;
                  ea.argt = cmd->uc_argt;
                  ea.useridx = j;
                  matchlen = k;
                  if (k == i___0) {
                    if ((int )*np___0 == 0) {
                      goto while_break___5;
                    }
                  }
                }
              }
            }
            }
            j ++;
            cmd ++;
          }
          while_break___5: /* CIL Label */ ;
          }
          if (found) {
            p___0 += matchlen - i___0;
          } else { //Added block
          if (possible) {
            p___0 += matchlen - i___0;
          }
          }
        }
      }
    }
    if (i___0 == 0) {
      goto _L___1;
    } else { //Added block
    if ((int )ea.cmdidx == 299) {
      _L___1: 
      if (! ea.skip) {
        {
        strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"Not an editor command"));
        }
        if (! sourcing) {
          {
          strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)": "));
          strncat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)*cmdlinep),
                  (size_t )40);
          }
        }
        errormsg = IObuff;
      }
      goto doend;
    }
    }
  }
  }
  if ((int )*p___0 == 33) {
    if ((int )ea.cmdidx != 202) {
      p___0 ++;
      ea.forceit = 1;
    } else {
      ea.forceit = 0;
    }
  } else {
    ea.forceit = 0;
  }
  if ((int )ea.cmdidx != -1) {
    ea.argt = (long )cmdnames[(int )ea.cmdidx].cmd_argt;
  }
  if (sandbox != 0) {
    if (! (ea.argt & 262144L)) {
      errormsg = e_sandbox;
      goto doend;
    }
  }
  if (! (ea.argt & 1L)) {
    if (ea.addr_count) {
      errormsg = e_norange;
      goto doend;
    }
  }
  if (! (ea.argt & 2L)) {
    if (ea.forceit) {
      errormsg = e_nobang;
      if ((int )ea.cmdidx == 99) {
        errormsg = (char_u *)"Don\'t panic!";
      }
      goto doend;
    }
  }
  if (! ea.skip) {
    if (! global_busy) {
      if (ea.line1 > ea.line2) {
        if (sourcing) {
          errormsg = (char_u *)"Backwards range given";
          goto doend;
        } else {
          {
          tmp___10 = ask_yesno((char_u *)"Backwards range given, OK to swap", 0);
          }
          if (tmp___10 != 121) {
            goto doend;
          }
        }
        lnum = ea.line1;
        ea.line1 = ea.line2;
        ea.line2 = lnum;
      }
    }
    {
    errormsg = invalid_range(& ea);
    }
    if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
      goto doend;
    }
  }
  if (ea.argt & 16384L) {
    if (ea.addr_count == 0) {
      ea.line2 = (linenr_t )1;
    }
  }
  {
  correct_range(& ea);
  }
  if ((int )ea.cmdidx == 132) {
    goto _L___4;
  } else { //Added block
  if ((int )ea.cmdidx == 96) {
    _L___4: 
    if ((int )ea.cmdidx == 96) {
      program = p_gp;
    } else {
      program = p_mp;
    }
    {
    p___0 = skipwhite(p___0);
    tmp___17 = strstr((char const   *)((char *)program), "$*");
    pos___0 = (char_u *)tmp___17;
    }
    if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
      i___0 = 1;
      {
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
        tmp___11 = strstr((char const   *)((char *)pos___0 + 2), "$*");
        pos___0 = (char_u *)tmp___11;
        }
        if (! ((unsigned long )pos___0 != (unsigned long )((void *)0))) {
          goto while_break___7;
        }
        i___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
      tmp___12 = strlen((char const   *)((char *)p___0));
      len___0 = (int )tmp___12;
      tmp___13 = strlen((char const   *)((char *)program));
      new_cmdline = alloc((unsigned int )((int )((tmp___13 + (size_t )(i___0 * (len___0 - 2))) + 1UL)));
      }
      if ((unsigned long )new_cmdline == (unsigned long )((void *)0)) {
        goto doend;
      }
      ptr = new_cmdline;
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
        tmp___14 = strstr((char const   *)((char *)program), "$*");
        pos___0 = (char_u *)tmp___14;
        }
        if (! ((unsigned long )pos___0 != (unsigned long )((void *)0))) {
          goto while_break___8;
        }
        {
        i___0 = (int )(pos___0 - program);
        strncpy((char * __restrict  )((char *)ptr), (char const   * __restrict  )((char *)program),
                (size_t )i___0);
        ptr += i___0;
        strcpy((char * __restrict  )((char *)ptr), (char const   * __restrict  )((char *)p___0));
        ptr += len___0;
        program = pos___0 + 2;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
      strcpy((char * __restrict  )((char *)ptr), (char const   * __restrict  )((char *)program));
      }
    } else {
      {
      tmp___15 = strlen((char const   *)((char *)program));
      tmp___16 = strlen((char const   *)((char *)p___0));
      new_cmdline = alloc((unsigned int )((int )((tmp___15 + tmp___16) + 2UL)));
      }
      if ((unsigned long )new_cmdline == (unsigned long )((void *)0)) {
        goto doend;
      }
      {
      strcpy((char * __restrict  )((char *)new_cmdline), (char const   * __restrict  )((char *)program));
      strcat((char * __restrict  )((char *)new_cmdline), (char const   * __restrict  )((char *)" "));
      strcat((char * __restrict  )((char *)new_cmdline), (char const   * __restrict  )((char *)p___0));
      }
    }
    {
    msg_make(p___0);
    vim_free((void *)*cmdlinep);
    *cmdlinep = new_cmdline;
    p___0 = new_cmdline;
    }
  }
  }
  if ((int )ea.cmdidx == 287) {
    ea.arg = p___0;
  } else {
    {
    ea.arg = skipwhite(p___0);
    }
  }
  if ((int )ea.cmdidx == 272) {
    goto _L___5;
  } else { //Added block
  if ((int )ea.cmdidx == 260) {
    _L___5: 
    if ((int )*(ea.arg) == 62) {
      (ea.arg) ++;
      if ((int )*(ea.arg) != 62) {
        errormsg = (char_u *)"Use w or w>>";
        goto doend;
      }
      {
      ea.arg = skipwhite(ea.arg + 1);
      ea.append = 1;
      }
    } else { //Added block
    if ((int )*(ea.arg) == 33) {
      if ((int )ea.cmdidx == 272) {
        (ea.arg) ++;
        ea.usefilter = 1;
      }
    }
    }
  }
  }
  if ((int )ea.cmdidx == 191) {
    if (ea.forceit) {
      ea.usefilter = 1;
      ea.forceit = 0;
    } else { //Added block
    if ((int )*(ea.arg) == 33) {
      (ea.arg) ++;
      ea.usefilter = 1;
    }
    }
  }
  if ((int )ea.cmdidx == 291) {
    goto _L___6;
  } else { //Added block
  if ((int )ea.cmdidx == 293) {
    _L___6: 
    ea.amount = 1;
    {
    while (1) {
      while_continue___9: /* CIL Label */ ;
      if (! ((int )*(ea.arg) == (int )*(ea.cmd))) {
        goto while_break___9;
      }
      (ea.arg) ++;
      (ea.amount) ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
    ea.arg = skipwhite(ea.arg);
    }
  }
  }
  if (ea.argt & 32768L) {
    if (! ea.usefilter) {
      {
      ea.do_ecmd_cmd = getargcmd(& ea.arg);
      }
    }
  }
  if (ea.argt & 256L) {
    if (! ea.usefilter) {
      {
      separate_nextcmd(& ea);
      }
    } else {
      goto _L___9;
    }
  } else { //Added block
  _L___9: 
  if ((int )ea.cmdidx == 287) {
    goto _L___8;
  } else { //Added block
  if (ea.usefilter) {
    _L___8: 
    p___0 = ea.arg;
    {
    while (1) {
      while_continue___10: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break___10;
      }
      if ((int )*p___0 == 92) {
        if (*(p___0 + 1)) {
          p___0 ++;
        } else {
          goto _L___7;
        }
      } else { //Added block
      _L___7: 
      if ((int )*p___0 == 10) {
        ea.nextcmd = p___0 + 1;
        *p___0 = (char_u )'\000';
        goto while_break___10;
      }
      }
      p___0 ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  }
  }
  if (ea.argt & 32L) {
    if (ea.addr_count == 0) {
      ea.line1 = (linenr_t )1;
      ea.line2 = curbuf->b_ml.ml_line_count;
    }
  }
  if (ea.argt & 512L) {
    if ((int )*(ea.arg) != 0) {
      if ((int )ea.cmdidx != 185) {
        if ((int )ea.cmdidx != -1) {
          tmp___21 = 1;
        } else {
          tmp___21 = 0;
        }
      } else {
        tmp___21 = 0;
      }
      {
      tmp___22 = valid_yank_reg((int )*(ea.arg), tmp___21);
      }
      if (tmp___22) {
        if ((int )ea.cmdidx != -1) {
          goto _L___11;
        } else { //Added block
        if ((int )*(ea.arg) != 61) {
          _L___11: 
          if (ea.argt & 1024L) {
            {
            tmp___23 = __ctype_b_loc();
            }
            if (! ((int const   )*(*tmp___23 + (int )*(ea.arg)) & 2048)) {
              goto _L___10;
            }
          } else {
            _L___10: 
            tmp___18 = ea.arg;
            (ea.arg) ++;
            ea.regname = (int )*tmp___18;
            if ((int )*(ea.arg + -1) == 61) {
              if ((int )*(ea.arg + 0) != 0) {
                {
                tmp___19 = vim_strsave(ea.arg);
                set_expr_line(tmp___19);
                tmp___20 = strlen((char const   *)((char *)ea.arg));
                ea.arg += tmp___20;
                }
              }
            }
            {
            ea.arg = skipwhite(ea.arg);
            }
          }
        }
        }
      }
    }
  }
  if (ea.argt & 1024L) {
    {
    tmp___24 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___24 + (int )*(ea.arg)) & 2048) {
      if (! (ea.argt & 65536L)) {
        goto _L___13;
      } else {
        {
        p___0 = skipdigits(ea.arg);
        }
        if ((int )*p___0 == 0) {
          goto _L___13;
        } else { //Added block
        if ((int )*p___0 == 32) {
          goto _L___13;
        } else { //Added block
        if ((int )*p___0 == 9) {
          _L___13: 
          {
          n = getdigits(& ea.arg);
          ea.arg = skipwhite(ea.arg);
          }
          if (n <= 0L) {
            errormsg = e_zerocount;
            goto doend;
          }
          if (ea.argt & 16384L) {
            ea.line2 = n;
            if (ea.addr_count == 0) {
              ea.addr_count = 1;
            }
          } else {
            ea.line1 = ea.line2;
            ea.line2 += n - 1L;
            (ea.addr_count) ++;
            if (ea.line2 > curbuf->b_ml.ml_line_count) {
              ea.line2 = curbuf->b_ml.ml_line_count;
            }
          }
        }
        }
        }
      }
    }
  }
  if (! (ea.argt & 4L)) {
    if ((int )*(ea.arg) != 0) {
      {
      tmp___25 = vim_strchr((char_u *)"|\"", (int )*(ea.arg));
      }
      if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
        errormsg = e_trailing;
        goto doend;
      }
    }
  }
  if (ea.argt & 128L) {
    if ((int )*(ea.arg) == 0) {
      errormsg = e_argreq;
      goto doend;
    }
  }
  if (ea.argt & 8L) {
    {
    tmp___26 = expand_filename(& ea, cmdlinep, & errormsg);
    }
    if (tmp___26 == 0) {
      goto doend;
    }
  }
  if (ea.skip) {
    {
    if ((int )ea.cmdidx == 275) {
      goto case_275;
    }
    if ((int )ea.cmdidx == 84) {
      goto case_275;
    }
    if ((int )ea.cmdidx == 107) {
      goto case_275;
    }
    if ((int )ea.cmdidx == 80) {
      goto case_275;
    }
    if ((int )ea.cmdidx == 79) {
      goto case_275;
    }
    if ((int )ea.cmdidx == 82) {
      goto case_275;
    }
    if ((int )ea.cmdidx == 93) {
      goto case_275;
    }
    if ((int )ea.cmdidx == 31) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 69) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 70) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 73) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 74) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 76) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 78) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 86) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 99) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 108) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 109) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 117) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 118) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 128) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 198) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 202) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 219) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 222) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 236) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 289) {
      goto case_31;
    }
    if ((int )ea.cmdidx == 298) {
      goto case_31;
    }
    goto switch_default;
    case_275: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_93: /* CIL Label */ 
    goto switch_break;
    case_31: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_128: /* CIL Label */ 
    case_198: /* CIL Label */ 
    case_202: /* CIL Label */ 
    case_219: /* CIL Label */ 
    case_222: /* CIL Label */ 
    case_236: /* CIL Label */ 
    case_289: /* CIL Label */ 
    case_298: /* CIL Label */ 
    goto switch_break;
    switch_default: /* CIL Label */ 
    goto doend;
    switch_break: /* CIL Label */ ;
    }
  }
  if (ea.argt & 65536L) {
    if (*(ea.arg)) {
      if (ea.addr_count == 0) {
        if ((int )ea.cmdidx != -1) {
          if ((int )ea.cmdidx == 16) {
            {
            p___0 = skiptowhite_esc(ea.arg);
            }
          } else { //Added block
          if ((int )ea.cmdidx == 26) {
            {
            p___0 = skiptowhite_esc(ea.arg);
            }
          } else {
            {
            tmp___27 = strlen((char const   *)((char *)ea.arg));
            p___0 = ea.arg + tmp___27;
            }
            {
            while (1) {
              while_continue___11: /* CIL Label */ ;
              if ((unsigned long )p___0 > (unsigned long )ea.arg) {
                if (! ((int )*(p___0 + -1) == 32)) {
                  if (! ((int )*(p___0 + -1) == 9)) {
                    goto while_break___11;
                  }
                }
              } else {
                goto while_break___11;
              }
              p___0 --;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
          }
          {
          tmp___28 = buflist_findpat(ea.arg, p___0);
          ea.line2 = (linenr_t )tmp___28;
          }
          if (ea.line2 < 0L) {
            goto doend;
          }
          {
          ea.addr_count = 1;
          ea.arg = skipwhite(p___0);
          }
        }
      }
    }
  }
  {
  if ((int )ea.cmdidx == 189) {
    goto case_189;
  }
  if ((int )ea.cmdidx == 190) {
    goto case_190;
  }
  if ((int )ea.cmdidx == 40) {
    goto case_40;
  }
  if ((int )ea.cmdidx == 168) {
    goto case_168;
  }
  if ((int )ea.cmdidx == 102) {
    goto case_102;
  }
  if ((int )ea.cmdidx == 161) {
    goto case_161;
  }
  if ((int )ea.cmdidx == 227) {
    goto case_227;
  }
  if ((int )ea.cmdidx == 233) {
    goto case_227;
  }
  if ((int )ea.cmdidx == 87) {
    goto case_87;
  }
  if ((int )ea.cmdidx == 283) {
    goto case_87;
  }
  if ((int )ea.cmdidx == 280) {
    goto case_87;
  }
  if ((int )ea.cmdidx == 284) {
    goto case_284;
  }
  if ((int )ea.cmdidx == 281) {
    goto case_284;
  }
  if ((int )ea.cmdidx == 274) {
    goto case_274;
  }
  if ((int )ea.cmdidx == 173) {
    goto case_173;
  }
  if ((int )ea.cmdidx == 192) {
    goto case_192;
  }
  if ((int )ea.cmdidx == 6) {
    goto case_6;
  }
  if ((int )ea.cmdidx == 278) {
    goto case_278;
  }
  if ((int )ea.cmdidx == 273) {
    goto case_278;
  }
  if ((int )ea.cmdidx == 279) {
    goto case_278;
  }
  if ((int )ea.cmdidx == 142) {
    goto case_142;
  }
  if ((int )ea.cmdidx == 220) {
    goto case_142;
  }
  if ((int )ea.cmdidx == 174) {
    goto case_174;
  }
  if ((int )ea.cmdidx == 225) {
    goto case_174;
  }
  if ((int )ea.cmdidx == 295) {
    goto case_174;
  }
  if ((int )ea.cmdidx == 203) {
    goto case_174;
  }
  if ((int )ea.cmdidx == 199) {
    goto case_199;
  }
  if ((int )ea.cmdidx == 226) {
    goto case_199;
  }
  if ((int )ea.cmdidx == 126) {
    goto case_126;
  }
  if ((int )ea.cmdidx == 218) {
    goto case_126;
  }
  if ((int )ea.cmdidx == 7) {
    goto case_7;
  }
  if ((int )ea.cmdidx == 204) {
    goto case_7;
  }
  if ((int )ea.cmdidx == 3) {
    goto case_3;
  }
  if ((int )ea.cmdidx == 205) {
    goto case_3;
  }
  if ((int )ea.cmdidx == 12) {
    goto case_12;
  }
  if ((int )ea.cmdidx == 206) {
    goto case_12;
  }
  if ((int )ea.cmdidx == 19) {
    goto case_19;
  }
  if ((int )ea.cmdidx == 210) {
    goto case_19;
  }
  if ((int )ea.cmdidx == 20) {
    goto case_20;
  }
  if ((int )ea.cmdidx == 211) {
    goto case_20;
  }
  if ((int )ea.cmdidx == 13) {
    goto case_13;
  }
  if ((int )ea.cmdidx == 21) {
    goto case_13;
  }
  if ((int )ea.cmdidx == 207) {
    goto case_13;
  }
  if ((int )ea.cmdidx == 212) {
    goto case_13;
  }
  if ((int )ea.cmdidx == 22) {
    goto case_22;
  }
  if ((int )ea.cmdidx == 213) {
    goto case_22;
  }
  if ((int )ea.cmdidx == 18) {
    goto case_18;
  }
  if ((int )ea.cmdidx == 209) {
    goto case_18;
  }
  if ((int )ea.cmdidx == 26) {
    goto case_26;
  }
  if ((int )ea.cmdidx == 16) {
    goto case_26;
  }
  if ((int )ea.cmdidx == 256) {
    goto case_256;
  }
  if ((int )ea.cmdidx == 232) {
    goto case_256;
  }
  if ((int )ea.cmdidx == 14) {
    goto case_14;
  }
  if ((int )ea.cmdidx == 208) {
    goto case_14;
  }
  if ((int )ea.cmdidx == 25) {
    goto case_25;
  }
  if ((int )ea.cmdidx == 89) {
    goto case_25;
  }
  if ((int )ea.cmdidx == 129) {
    goto case_25;
  }
  if ((int )ea.cmdidx == 260) {
    goto case_260;
  }
  if ((int )ea.cmdidx == 272) {
    goto case_272;
  }
  if ((int )ea.cmdidx == 141) {
    goto case_141;
  }
  if ((int )ea.cmdidx == 196) {
    goto case_196;
  }
  if ((int )ea.cmdidx == 234) {
    goto case_234;
  }
  if ((int )ea.cmdidx == 224) {
    goto case_234;
  }
  if ((int )ea.cmdidx == 143) {
    goto case_234;
  }
  if ((int )ea.cmdidx == 215) {
    goto case_234;
  }
  if ((int )ea.cmdidx == 75) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 85) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 263) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 264) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 15) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 91) {
    goto case_91;
  }
  if ((int )ea.cmdidx == 98) {
    goto case_98;
  }
  if ((int )ea.cmdidx == 97) {
    goto case_98;
  }
  if ((int )ea.cmdidx == 81) {
    goto case_81;
  }
  if ((int )ea.cmdidx == 17) {
    goto case_17;
  }
  if ((int )ea.cmdidx == 90) {
    goto case_90;
  }
  if ((int )ea.cmdidx == 24) {
    goto case_24;
  }
  if ((int )ea.cmdidx == 55) {
    goto case_55;
  }
  if ((int )ea.cmdidx == 88) {
    goto case_88;
  }
  if ((int )ea.cmdidx == 235) {
    goto case_235;
  }
  if ((int )ea.cmdidx == 237) {
    goto case_237;
  }
  if ((int )ea.cmdidx == 191) {
    goto case_191;
  }
  if ((int )ea.cmdidx == 33) {
    goto case_33;
  }
  if ((int )ea.cmdidx == 36) {
    goto case_33;
  }
  if ((int )ea.cmdidx == 186) {
    goto case_186;
  }
  if ((int )ea.cmdidx == 292) {
    goto case_292;
  }
  if ((int )ea.cmdidx == 125) {
    goto case_125;
  }
  if ((int )ea.cmdidx == 154) {
    goto case_154;
  }
  if ((int )ea.cmdidx == 288) {
    goto case_154;
  }
  if ((int )ea.cmdidx == 167) {
    goto case_154;
  }
  if ((int )ea.cmdidx == 296) {
    goto case_154;
  }
  if ((int )ea.cmdidx == 95) {
    goto case_95;
  }
  if ((int )ea.cmdidx == 216) {
    goto case_216;
  }
  if ((int )ea.cmdidx == 217) {
    goto case_217;
  }
  if ((int )ea.cmdidx == 177) {
    goto case_177;
  }
  if ((int )ea.cmdidx == 228) {
    goto case_228;
  }
  if ((int )ea.cmdidx == 240) {
    goto case_240;
  }
  if ((int )ea.cmdidx == 184) {
    goto case_184;
  }
  if ((int )ea.cmdidx == 231) {
    goto case_231;
  }
  if ((int )ea.cmdidx == 252) {
    goto case_252;
  }
  if ((int )ea.cmdidx == 179) {
    goto case_179;
  }
  if ((int )ea.cmdidx == 230) {
    goto case_230;
  }
  if ((int )ea.cmdidx == 246) {
    goto case_246;
  }
  if ((int )ea.cmdidx == 171) {
    goto case_171;
  }
  if ((int )ea.cmdidx == 249) {
    goto case_249;
  }
  if ((int )ea.cmdidx == 239) {
    goto case_239;
  }
  if ((int )ea.cmdidx == 250) {
    goto case_239;
  }
  if ((int )ea.cmdidx == 251) {
    goto case_251;
  }
  if ((int )ea.cmdidx == 247) {
    goto case_247;
  }
  if ((int )ea.cmdidx == 172) {
    goto case_172;
  }
  if ((int )ea.cmdidx == 181) {
    goto case_181;
  }
  if ((int )ea.cmdidx == 178) {
    goto case_178;
  }
  if ((int )ea.cmdidx == 182) {
    goto case_178;
  }
  if ((int )ea.cmdidx == 183) {
    goto case_183;
  }
  if ((int )ea.cmdidx == 180) {
    goto case_180;
  }
  if ((int )ea.cmdidx == 241) {
    goto case_241;
  }
  if ((int )ea.cmdidx == 135) {
    goto case_135;
  }
  if ((int )ea.cmdidx == 123) {
    goto case_123;
  }
  if ((int )ea.cmdidx == 8) {
    goto case_8;
  }
  if ((int )ea.cmdidx == 37) {
    goto case_37;
  }
  if ((int )ea.cmdidx == 68) {
    goto case_68;
  }
  if ((int )ea.cmdidx == 214) {
    goto case_214;
  }
  if ((int )ea.cmdidx == 92) {
    goto case_92;
  }
  if ((int )ea.cmdidx == 10) {
    goto case_10;
  }
  if ((int )ea.cmdidx == 9) {
    goto case_10;
  }
  if ((int )ea.cmdidx == 72) {
    goto case_72;
  }
  if ((int )ea.cmdidx == 71) {
    goto case_71;
  }
  if ((int )ea.cmdidx == 1) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 151) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 255) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 29) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 48) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 62) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 105) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 114) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 120) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 133) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 144) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 265) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 158) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 41) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 110) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 149) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 147) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 268) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 162) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 47) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 113) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 258) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 155) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 270) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 165) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 61) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 119) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 134) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 145) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 266) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 159) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 42) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 111) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 2) {
    goto case_2;
  }
  if ((int )ea.cmdidx == 106) {
    goto case_2;
  }
  if ((int )ea.cmdidx == 30) {
    goto case_2;
  }
  if ((int )ea.cmdidx == 136) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 152) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 259) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 4) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 5) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 11) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 146) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 148) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 156) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 267) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 269) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 271) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 160) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 163) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 166) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 112) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 115) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 121) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 43) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 49) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 63) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 248) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 253) {
    goto case_136;
  }
  if ((int )ea.cmdidx == 67) {
    goto case_67;
  }
  if ((int )ea.cmdidx == 195) {
    goto case_67;
  }
  if ((int )ea.cmdidx == 99) {
    goto case_99___0;
  }
  if ((int )ea.cmdidx == 262) {
    goto case_262;
  }
  if ((int )ea.cmdidx == 103) {
    goto case_103;
  }
  if ((int )ea.cmdidx == 137) {
    goto case_137;
  }
  if ((int )ea.cmdidx == 276) {
    goto case_276;
  }
  if ((int )ea.cmdidx == 277) {
    goto case_277;
  }
  if ((int )ea.cmdidx == 64) {
    goto case_64;
  }
  if ((int )ea.cmdidx == 285) {
    goto case_64;
  }
  if ((int )ea.cmdidx == 293) {
    goto case_64;
  }
  if ((int )ea.cmdidx == 291) {
    goto case_64;
  }
  if ((int )ea.cmdidx == 185) {
    goto case_185;
  }
  if ((int )ea.cmdidx == 238) {
    goto case_238;
  }
  if ((int )ea.cmdidx == 50) {
    goto case_238;
  }
  if ((int )ea.cmdidx == 130) {
    goto case_238;
  }
  if ((int )ea.cmdidx == 289) {
    goto case_289___0;
  }
  if ((int )ea.cmdidx == 298) {
    goto case_289___0;
  }
  if ((int )ea.cmdidx == 202) {
    goto case_289___0;
  }
  if ((int )ea.cmdidx == 219) {
    goto case_219___0;
  }
  if ((int )ea.cmdidx == 222) {
    goto case_222___0;
  }
  if ((int )ea.cmdidx == 122) {
    goto case_122;
  }
  if ((int )ea.cmdidx == 94) {
    goto case_94;
  }
  if ((int )ea.cmdidx == 261) {
    goto case_261;
  }
  if ((int )ea.cmdidx == 290) {
    goto case_290;
  }
  if ((int )ea.cmdidx == 294) {
    goto case_290;
  }
  if ((int )ea.cmdidx == 287) {
    goto case_287;
  }
  if ((int )ea.cmdidx == 254) {
    goto case_254;
  }
  if ((int )ea.cmdidx == 193) {
    goto case_193;
  }
  if ((int )ea.cmdidx == 223) {
    goto case_223;
  }
  if ((int )ea.cmdidx == 201) {
    goto case_201;
  }
  if ((int )ea.cmdidx == 282) {
    goto case_282;
  }
  if ((int )ea.cmdidx == 194) {
    goto case_194;
  }
  if ((int )ea.cmdidx == 139) {
    goto case_139;
  }
  if ((int )ea.cmdidx == 140) {
    goto case_140;
  }
  if ((int )ea.cmdidx == 138) {
    goto case_138;
  }
  if ((int )ea.cmdidx == 32) {
    goto case_32;
  }
  if ((int )ea.cmdidx == 35) {
    goto case_35;
  }
  if ((int )ea.cmdidx == 38) {
    goto case_38;
  }
  if ((int )ea.cmdidx == 58) {
    goto case_58;
  }
  if ((int )ea.cmdidx == 39) {
    goto case_39;
  }
  if ((int )ea.cmdidx == 44) {
    goto case_44;
  }
  if ((int )ea.cmdidx == 46) {
    goto case_46;
  }
  if ((int )ea.cmdidx == 51) {
    goto case_51;
  }
  if ((int )ea.cmdidx == 45) {
    goto case_45;
  }
  if ((int )ea.cmdidx == 28) {
    goto case_28;
  }
  if ((int )ea.cmdidx == 56) {
    goto case_28;
  }
  if ((int )ea.cmdidx == -1) {
    goto case_neg_1;
  }
  if ((int )ea.cmdidx == 52) {
    goto case_52;
  }
  if ((int )ea.cmdidx == 53) {
    goto case_53;
  }
  if ((int )ea.cmdidx == 65) {
    goto case_65;
  }
  if ((int )ea.cmdidx == 57) {
    goto case_57;
  }
  if ((int )ea.cmdidx == 131) {
    goto case_131;
  }
  if ((int )ea.cmdidx == 124) {
    goto case_131;
  }
  if ((int )ea.cmdidx == 34) {
    goto case_34;
  }
  if ((int )ea.cmdidx == 200) {
    goto case_34;
  }
  if ((int )ea.cmdidx == 127) {
    goto case_34;
  }
  if ((int )ea.cmdidx == 197) {
    goto case_197;
  }
  if ((int )ea.cmdidx == 153) {
    goto case_153;
  }
  if ((int )ea.cmdidx == 96) {
    goto case_96;
  }
  if ((int )ea.cmdidx == 132) {
    goto case_132;
  }
  if ((int )ea.cmdidx == 117) {
    goto case_117___0;
  }
  if ((int )ea.cmdidx == 73) {
    goto case_117___0;
  }
  if ((int )ea.cmdidx == 109) {
    goto case_109___0;
  }
  if ((int )ea.cmdidx == 70) {
    goto case_109___0;
  }
  if ((int )ea.cmdidx == 108) {
    goto case_108___0;
  }
  if ((int )ea.cmdidx == 69) {
    goto case_108___0;
  }
  if ((int )ea.cmdidx == 118) {
    goto case_118___0;
  }
  if ((int )ea.cmdidx == 74) {
    goto case_118___0;
  }
  if ((int )ea.cmdidx == 236) {
    goto case_236___0;
  }
  if ((int )ea.cmdidx == 101) {
    goto case_101;
  }
  if ((int )ea.cmdidx == 76) {
    goto case_76___0;
  }
  if ((int )ea.cmdidx == 78) {
    goto case_76___0;
  }
  if ((int )ea.cmdidx == 77) {
    goto case_77;
  }
  if ((int )ea.cmdidx == 86) {
    goto case_86___0;
  }
  if ((int )ea.cmdidx == 31) {
    goto case_31___0;
  }
  if ((int )ea.cmdidx == 107) {
    goto case_107___0;
  }
  if ((int )ea.cmdidx == 80) {
    goto case_80___0;
  }
  if ((int )ea.cmdidx == 79) {
    goto case_80___0;
  }
  if ((int )ea.cmdidx == 82) {
    goto case_82___0;
  }
  if ((int )ea.cmdidx == 275) {
    goto case_275___0;
  }
  if ((int )ea.cmdidx == 54) {
    goto case_54;
  }
  if ((int )ea.cmdidx == 23) {
    goto case_23;
  }
  if ((int )ea.cmdidx == 84) {
    goto case_84___0;
  }
  if ((int )ea.cmdidx == 128) {
    goto case_128___0;
  }
  if ((int )ea.cmdidx == 257) {
    goto case_257;
  }
  if ((int )ea.cmdidx == 93) {
    goto case_93___0;
  }
  if ((int )ea.cmdidx == 66) {
    goto case_66;
  }
  if ((int )ea.cmdidx == 198) {
    goto case_198___0;
  }
  if ((int )ea.cmdidx == 83) {
    goto case_83;
  }
  if ((int )ea.cmdidx == 104) {
    goto case_104;
  }
  if ((int )ea.cmdidx == 0) {
    goto case_0;
  }
  if ((int )ea.cmdidx == 27) {
    goto case_27;
  }
  if ((int )ea.cmdidx == 286) {
    goto case_286;
  }
  if ((int )ea.cmdidx == 116) {
    goto case_116;
  }
  if ((int )ea.cmdidx == 150) {
    goto case_150;
  }
  if ((int )ea.cmdidx == 229) {
    goto case_229;
  }
  if ((int )ea.cmdidx == 297) {
    goto case_297;
  }
  if ((int )ea.cmdidx == 164) {
    goto case_164;
  }
  goto switch_default___0;
  case_189: /* CIL Label */ 
  {
  do_quit(& ea);
  }
  goto switch_break___0;
  case_190: /* CIL Label */ 
  {
  do_quit_all(ea.forceit);
  }
  goto switch_break___0;
  case_40: /* CIL Label */ 
  {
  do_close(& ea, curwin);
  }
  goto switch_break___0;
  case_168: /* CIL Label */ 
  {
  do_pclose(& ea);
  }
  goto switch_break___0;
  case_102: /* CIL Label */ 
  {
  close_window(curwin, 0);
  }
  goto switch_break___0;
  case_161: /* CIL Label */ 
  {
  close_others(1, ea.forceit);
  }
  goto switch_break___0;
  case_227: /* CIL Label */ 
  case_233: /* CIL Label */ 
  {
  do_suspend(ea.forceit);
  }
  goto switch_break___0;
  case_87: /* CIL Label */ 
  case_283: /* CIL Label */ 
  case_280: /* CIL Label */ 
  {
  do_exit(& ea);
  }
  goto switch_break___0;
  case_284: /* CIL Label */ 
  case_281: /* CIL Label */ 
  exiting = 1;
  case_274: /* CIL Label */ 
  {
  do_wqall(& ea);
  }
  goto switch_break___0;
  case_173: /* CIL Label */ 
  {
  ml_preserve(curbuf, 1);
  }
  goto switch_break___0;
  case_192: /* CIL Label */ 
  {
  do_recover(& ea);
  }
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
  do_args(& ea);
  }
  goto switch_break___0;
  case_278: /* CIL Label */ 
  case_273: /* CIL Label */ 
  case_279: /* CIL Label */ 
  {
  do_wnext(& ea);
  }
  goto switch_break___0;
  case_142: /* CIL Label */ 
  case_220: /* CIL Label */ 
  {
  do_next(& ea);
  }
  goto switch_break___0;
  case_174: /* CIL Label */ 
  case_225: /* CIL Label */ 
  case_295: /* CIL Label */ 
  case_203: /* CIL Label */ 
  if (curwin->w_arg_idx - (int )ea.line2 >= arg_file_count) {
    {
    do_argfile(& ea, arg_file_count - 1);
    }
  } else {
    {
    do_argfile(& ea, curwin->w_arg_idx - (int )ea.line2);
    }
  }
  goto switch_break___0;
  case_199: /* CIL Label */ 
  case_226: /* CIL Label */ 
  {
  do_argfile(& ea, 0);
  }
  goto switch_break___0;
  case_126: /* CIL Label */ 
  case_218: /* CIL Label */ 
  {
  do_argfile(& ea, arg_file_count - 1);
  }
  goto switch_break___0;
  case_7: /* CIL Label */ 
  case_204: /* CIL Label */ 
  if (ea.addr_count) {
    i___0 = (int )(ea.line2 - 1L);
  } else {
    i___0 = curwin->w_arg_idx;
  }
  {
  do_argfile(& ea, i___0);
  }
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_205: /* CIL Label */ 
  if (ea.addr_count == 0) {
    ea.line2 = (linenr_t )9999;
  }
  {
  do_arg_all((int )ea.line2, ea.forceit);
  }
  goto switch_break___0;
  case_12: /* CIL Label */ 
  case_206: /* CIL Label */ 
  if (*(ea.arg)) {
    errormsg = e_trailing;
  } else { //Added block
  if (ea.addr_count == 0) {
    {
    goto_buffer(& ea, 0, 1, 0);
    }
  } else {
    {
    goto_buffer(& ea, 1, 1, (int )ea.line2);
    }
  }
  }
  goto switch_break___0;
  case_19: /* CIL Label */ 
  case_210: /* CIL Label */ 
  {
  goto_buffer(& ea, 3, 1, (int )ea.line2);
  }
  goto switch_break___0;
  case_20: /* CIL Label */ 
  case_211: /* CIL Label */ 
  {
  goto_buffer(& ea, 0, 1, (int )ea.line2);
  }
  goto switch_break___0;
  case_13: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_207: /* CIL Label */ 
  case_212: /* CIL Label */ 
  {
  goto_buffer(& ea, 0, -1, (int )ea.line2);
  }
  goto switch_break___0;
  case_22: /* CIL Label */ 
  case_213: /* CIL Label */ 
  {
  goto_buffer(& ea, 1, 1, 0);
  }
  goto switch_break___0;
  case_18: /* CIL Label */ 
  case_209: /* CIL Label */ 
  {
  goto_buffer(& ea, 2, 1, 0);
  }
  goto switch_break___0;
  case_26: /* CIL Label */ 
  case_16: /* CIL Label */ 
  if ((int )ea.cmdidx == 16) {
    tmp___29 = 3;
  } else {
    tmp___29 = 2;
  }
  {
  errormsg = do_bufdel(tmp___29, ea.arg, ea.addr_count, (int )ea.line1, (int )ea.line2,
                       ea.forceit);
  }
  goto switch_break___0;
  case_256: /* CIL Label */ 
  case_232: /* CIL Label */ 
  if (ea.addr_count == 0) {
    ea.line2 = (linenr_t )9999;
  }
  {
  do_buffer_all((int )ea.line2, 0);
  }
  goto switch_break___0;
  case_14: /* CIL Label */ 
  case_208: /* CIL Label */ 
  if (ea.addr_count == 0) {
    ea.line2 = (linenr_t )9999;
  }
  {
  do_buffer_all((int )ea.line2, 1);
  }
  goto switch_break___0;
  case_25: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_129: /* CIL Label */ 
  {
  buflist_list();
  }
  goto switch_break___0;
  case_260: /* CIL Label */ 
  {
  tmp___30 = curbuf_changed();
  }
  if (tmp___30) {
    {
    do_write(& ea);
    }
  }
  goto switch_break___0;
  case_272: /* CIL Label */ 
  if (ea.usefilter) {
    {
    do_bang(1, ea.line1, ea.line2, 0, ea.arg, 1, 0);
    }
  } else {
    {
    do_write(& ea);
    }
  }
  goto switch_break___0;
  case_141: /* CIL Label */ 
  if ((int )*(ea.arg) == 0) {
    {
    set_winsize(0, 0, 0);
    }
  } else {
    {
    tmp___31 = mch_screenmode(ea.arg);
    }
    if (tmp___31 != 0) {
      {
      set_winsize(0, 0, 0);
      }
    }
  }
  goto switch_break___0;
  case_196: /* CIL Label */ 
  {
  do_resize(& ea);
  }
  goto switch_break___0;
  case_234: /* CIL Label */ 
  case_224: /* CIL Label */ 
  case_143: /* CIL Label */ 
  case_215: /* CIL Label */ 
  {
  do_splitview(& ea);
  }
  goto switch_break___0;
  case_75: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_263: /* CIL Label */ 
  case_264: /* CIL Label */ 
  case_15: /* CIL Label */ 
  {
  do_exedit(& ea, (WIN *)((void *)0));
  }
  goto switch_break___0;
  case_91: /* CIL Label */ 
  {
  do_find(& ea);
  }
  goto switch_break___0;
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  {
  emsg(e_nogvim);
  }
  goto switch_break___0;
  case_81: /* CIL Label */ 
  {
  execute_menu(ea.arg);
  }
  goto switch_break___0;
  case_17: /* CIL Label */ 
  {
  ex_behave(ea.arg);
  }
  goto switch_break___0;
  case_90: /* CIL Label */ 
  {
  ex_filetype(ea.arg);
  }
  goto switch_break___0;
  case_24: /* CIL Label */ 
  ea.nextcmd = ea.arg;
  goto switch_break___0;
  case_55: /* CIL Label */ 
  confirm = 1;
  ea.nextcmd = ea.arg;
  goto switch_break___0;
  case_88: /* CIL Label */ 
  {
  do_file(ea.arg, ea.forceit);
  }
  goto switch_break___0;
  case_235: /* CIL Label */ 
  {
  do_swapname();
  }
  goto switch_break___0;
  case_237: /* CIL Label */ 
  {
  do_syncbind();
  }
  goto switch_break___0;
  case_191: /* CIL Label */ 
  {
  do_read(& ea);
  }
  goto switch_break___0;
  case_33: /* CIL Label */ 
  case_36: /* CIL Label */ 
  {
  do_cd(& ea);
  }
  goto switch_break___0;
  case_186: /* CIL Label */ 
  {
  do_pwd();
  }
  goto switch_break___0;
  case_292: /* CIL Label */ 
  {
  smsg((char_u *)"line %ld", ea.line2);
  }
  goto switch_break___0;
  case_125: /* CIL Label */ 
  {
  i___0 = curwin->w_p_list;
  curwin->w_p_list = 1;
  do_print(& ea);
  curwin->w_p_list = i___0;
  }
  goto switch_break___0;
  case_154: /* CIL Label */ 
  case_288: /* CIL Label */ 
  case_167: /* CIL Label */ 
  case_296: /* CIL Label */ 
  {
  do_print(& ea);
  }
  goto switch_break___0;
  case_95: /* CIL Label */ 
  {
  goto_byte(ea.line2);
  }
  goto switch_break___0;
  case_216: /* CIL Label */ 
  {
  do_shell((char_u *)((void *)0), 0);
  }
  goto switch_break___0;
  case_217: /* CIL Label */ 
  {
  do_sleep(& ea);
  }
  goto switch_break___0;
  case_177: /* CIL Label */ 
  g_do_tagpreview = (int )p_pvh;
  case_228: /* CIL Label */ 
  postponed_split = -1;
  case_240: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___32 = (int )ea.line2;
  } else {
    tmp___32 = 1;
  }
  {
  do_tag(ea.arg, 1, tmp___32, ea.forceit, 1);
  }
  goto switch_break___0;
  case_184: /* CIL Label */ 
  g_do_tagpreview = (int )p_pvh;
  case_231: /* CIL Label */ 
  postponed_split = -1;
  case_252: /* CIL Label */ 
  {
  do_tag(ea.arg, 7, 0, ea.forceit, 1);
  }
  goto switch_break___0;
  case_179: /* CIL Label */ 
  g_do_tagpreview = (int )p_pvh;
  case_230: /* CIL Label */ 
  postponed_split = -1;
  case_246: /* CIL Label */ 
  {
  do_tag(ea.arg, 9, 0, ea.forceit, 1);
  }
  goto switch_break___0;
  case_171: /* CIL Label */ 
  {
  do_ex_tag(& ea, 2, 0);
  }
  goto switch_break___0;
  case_249: /* CIL Label */ 
  {
  do_ex_tag(& ea, 3, 0);
  }
  goto switch_break___0;
  case_239: /* CIL Label */ 
  case_250: /* CIL Label */ 
  {
  do_ex_tag(& ea, 4, 0);
  }
  goto switch_break___0;
  case_251: /* CIL Label */ 
  {
  do_ex_tag(& ea, 5, 0);
  }
  goto switch_break___0;
  case_247: /* CIL Label */ 
  {
  do_ex_tag(& ea, 6, 0);
  }
  goto switch_break___0;
  case_172: /* CIL Label */ 
  {
  do_ex_tag(& ea, 2, 1);
  }
  goto switch_break___0;
  case_181: /* CIL Label */ 
  {
  do_ex_tag(& ea, 3, 1);
  }
  goto switch_break___0;
  case_178: /* CIL Label */ 
  case_182: /* CIL Label */ 
  {
  do_ex_tag(& ea, 4, 1);
  }
  goto switch_break___0;
  case_183: /* CIL Label */ 
  {
  do_ex_tag(& ea, 5, 1);
  }
  goto switch_break___0;
  case_180: /* CIL Label */ 
  {
  do_ex_tag(& ea, 6, 1);
  }
  goto switch_break___0;
  case_241: /* CIL Label */ 
  {
  do_tags();
  }
  goto switch_break___0;
  case_135: /* CIL Label */ 
  {
  do_marks(ea.arg);
  }
  goto switch_break___0;
  case_123: /* CIL Label */ 
  {
  do_jumps();
  }
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
  do_ascii();
  }
  goto switch_break___0;
  case_37: /* CIL Label */ 
  if (ea.forceit) {
    tmp___33 = 4;
  } else {
    tmp___33 = 1;
  }
  {
  find_pattern_in_path((char_u *)((void *)0), 0, 0, 0, 0, 3, 1L, tmp___33, (linenr_t )1,
                       (linenr_t )2147483647);
  }
  goto switch_break___0;
  case_68: /* CIL Label */ 
  if (*(ea.arg)) {
    {
    putdigraph(ea.arg);
    }
  } else {
    {
    listdigraphs();
    }
  }
  goto switch_break___0;
  case_214: /* CIL Label */ 
  {
  do_set(ea.arg, 0);
  }
  goto switch_break___0;
  case_92: /* CIL Label */ 
  {
  do_fixdel();
  }
  goto switch_break___0;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  if (secure) {
    secure = 2;
    errormsg = e_curdir;
  } else { //Added block
  if ((int )ea.cmdidx == 9) {
    {
    do_autocmd(ea.arg, ea.forceit);
    }
  } else {
    {
    do_augroup(ea.arg);
    }
  }
  }
  goto switch_break___0;
  case_72: /* CIL Label */ 
  {
  do_autoall(ea.arg);
  }
  goto switch_break___0;
  case_71: /* CIL Label */ 
  {
  do_doautocmd(ea.arg, 1);
  do_modelines();
  }
  goto switch_break___0;
  case_1: /* CIL Label */ 
  case_151: /* CIL Label */ 
  case_255: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_120: /* CIL Label */ 
  {
  do_exmap(& ea, 1);
  }
  goto switch_break___0;
  case_133: /* CIL Label */ 
  case_144: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_158: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_149: /* CIL Label */ 
  case_147: /* CIL Label */ 
  case_268: /* CIL Label */ 
  case_162: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_113: /* CIL Label */ 
  if (secure) {
    {
    secure = 2;
    msg_outtrans(ea.cmd);
    msg_putchar('\n');
    }
  }
  case_258: /* CIL Label */ 
  case_155: /* CIL Label */ 
  case_270: /* CIL Label */ 
  case_165: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_119: /* CIL Label */ 
  {
  do_exmap(& ea, 0);
  }
  goto switch_break___0;
  case_134: /* CIL Label */ 
  case_145: /* CIL Label */ 
  case_266: /* CIL Label */ 
  case_159: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_111: /* CIL Label */ 
  {
  map_clear(ea.cmd, ea.forceit, 0);
  }
  goto switch_break___0;
  case_2: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_30: /* CIL Label */ 
  {
  map_clear(ea.cmd, 1, 1);
  }
  goto switch_break___0;
  case_136: /* CIL Label */ 
  case_152: /* CIL Label */ 
  case_259: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_146: /* CIL Label */ 
  case_148: /* CIL Label */ 
  case_156: /* CIL Label */ 
  case_267: /* CIL Label */ 
  case_269: /* CIL Label */ 
  case_271: /* CIL Label */ 
  case_160: /* CIL Label */ 
  case_163: /* CIL Label */ 
  case_166: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_248: /* CIL Label */ 
  case_253: /* CIL Label */ 
  {
  do_menu(& ea);
  }
  goto switch_break___0;
  case_67: /* CIL Label */ 
  case_195: /* CIL Label */ 
  {
  do_dis(ea.arg);
  }
  goto switch_break___0;
  case_99___0: /* CIL Label */ 
  {
  do_help(& ea);
  }
  goto switch_break___0;
  case_262: /* CIL Label */ 
  {
  do_version(ea.arg);
  }
  goto switch_break___0;
  case_103: /* CIL Label */ 
  {
  do_history(ea.arg);
  }
  goto switch_break___0;
  case_137: /* CIL Label */ 
  {
  ex_messages();
  }
  goto switch_break___0;
  case_276: /* CIL Label */ 
  {
  do_winsize(ea.arg);
  }
  goto switch_break___0;
  case_277: /* CIL Label */ 
  {
  do_winpos(ea.arg);
  }
  goto switch_break___0;
  case_64: /* CIL Label */ 
  case_285: /* CIL Label */ 
  case_293: /* CIL Label */ 
  case_291: /* CIL Label */ 
  {
  do_exops(& ea);
  }
  goto switch_break___0;
  case_185: /* CIL Label */ 
  if (ea.line2 == 0L) {
    ea.line2 = (linenr_t )1;
    ea.forceit = 1;
  }
  curwin->w_cursor.lnum = ea.line2;
  if (ea.forceit) {
    tmp___34 = -1;
  } else {
    tmp___34 = 1;
  }
  {
  do_put(ea.regname, tmp___34, -1L, 0);
  }
  goto switch_break___0;
  case_238: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_130: /* CIL Label */ 
  {
  do_copymove(& ea);
  }
  goto switch_break___0;
  case_289___0: /* CIL Label */ 
  case_298___0: /* CIL Label */ 
  case_202___0: /* CIL Label */ 
  {
  do_sub(& ea);
  }
  goto switch_break___0;
  case_219___0: /* CIL Label */ 
  {
  i___0 = p_magic;
  p_magic = 1;
  do_sub(& ea);
  p_magic = i___0;
  }
  goto switch_break___0;
  case_222___0: /* CIL Label */ 
  {
  i___0 = p_magic;
  p_magic = 0;
  do_sub(& ea);
  p_magic = i___0;
  }
  goto switch_break___0;
  case_122: /* CIL Label */ 
  {
  do_exjoin(& ea);
  }
  goto switch_break___0;
  case_94: /* CIL Label */ 
  if (ea.forceit) {
    *(ea.cmd) = (char_u )'v';
  }
  case_261: /* CIL Label */ 
  {
  do_glob(& ea);
  }
  goto switch_break___0;
  case_290: /* CIL Label */ 
  case_294: /* CIL Label */ 
  {
  do_exat(& ea);
  }
  goto switch_break___0;
  case_287: /* CIL Label */ 
  {
  do_bang(ea.addr_count, ea.line1, ea.line2, ea.forceit, ea.arg, 1, 1);
  }
  goto switch_break___0;
  case_254: /* CIL Label */ 
  {
  u_undo(1);
  }
  goto switch_break___0;
  case_193: /* CIL Label */ 
  {
  u_redo(1);
  }
  goto switch_break___0;
  case_223: /* CIL Label */ 
  {
  cmd_source(ea.arg, ea.forceit);
  }
  goto switch_break___0;
  case_201: /* CIL Label */ 
  p___0 = p_viminfo;
  if ((int )*p_viminfo == 0) {
    p_viminfo = (char_u *)"\'100";
  }
  {
  tmp___35 = read_viminfo(ea.arg, 1, 1, ea.forceit);
  }
  if (tmp___35 == 0) {
    {
    emsg((char_u *)"Cannot open viminfo file for reading");
    }
  }
  p_viminfo = p___0;
  goto switch_break___0;
  case_282: /* CIL Label */ 
  p___0 = p_viminfo;
  if ((int )*p_viminfo == 0) {
    p_viminfo = (char_u *)"\'100";
  }
  {
  write_viminfo(ea.arg, ea.forceit);
  p_viminfo = p___0;
  }
  goto switch_break___0;
  case_194: /* CIL Label */ 
  {
  do_redir(& ea);
  }
  goto switch_break___0;
  case_139: /* CIL Label */ 
  {
  do_mkrc(& ea, (char_u *)"Session.vim");
  }
  goto switch_break___0;
  case_140: /* CIL Label */ 
  {
  do_mkrc(& ea, (char_u *)".vimrc");
  }
  goto switch_break___0;
  case_138: /* CIL Label */ 
  {
  do_mkrc(& ea, (char_u *)".exrc");
  }
  goto switch_break___0;
  case_32: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___36 = (int )ea.line2;
  } else {
    tmp___36 = 0;
  }
  {
  qf_jump(0, tmp___36, ea.forceit);
  }
  goto switch_break___0;
  case_35: /* CIL Label */ 
  {
  do_cfile(& ea);
  }
  goto switch_break___0;
  case_38: /* CIL Label */ 
  {
  qf_list(ea.arg, ea.forceit);
  }
  goto switch_break___0;
  case_58: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___37 = (int )ea.line2;
  } else {
    tmp___37 = 1;
  }
  {
  qf_jump(0, tmp___37, ea.forceit);
  }
  goto switch_break___0;
  case_39: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___38 = (int )ea.line2;
  } else {
    tmp___38 = 32767;
  }
  {
  qf_jump(0, tmp___38, ea.forceit);
  }
  goto switch_break___0;
  case_44: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___39 = (int )ea.line2;
  } else {
    tmp___39 = 1;
  }
  {
  qf_jump(1, tmp___39, ea.forceit);
  }
  goto switch_break___0;
  case_46: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___40 = (int )ea.line2;
  } else {
    tmp___40 = 1;
  }
  {
  qf_jump(3, tmp___40, ea.forceit);
  }
  goto switch_break___0;
  case_51: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___41 = (int )ea.line2;
  } else {
    tmp___41 = 1;
  }
  {
  qf_older(tmp___41);
  }
  goto switch_break___0;
  case_45: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___42 = (int )ea.line2;
  } else {
    tmp___42 = 1;
  }
  {
  qf_newer(tmp___42);
  }
  goto switch_break___0;
  case_28: /* CIL Label */ 
  case_56: /* CIL Label */ 
  if (ea.addr_count) {
    tmp___43 = (int )ea.line2;
  } else {
    tmp___43 = 1;
  }
  {
  qf_jump(-1, tmp___43, ea.forceit);
  }
  goto switch_break___0;
  case_neg_1: /* CIL Label */ 
  {
  do_ucmd((UCMD *)ucmds.ga_data + ea.useridx, & ea);
  }
  goto switch_break___0;
  case_52: /* CIL Label */ 
  {
  do_command(& ea);
  }
  goto switch_break___0;
  case_53: /* CIL Label */ 
  {
  do_comclear();
  }
  goto switch_break___0;
  case_65: /* CIL Label */ 
  {
  do_delcommand(& ea);
  }
  goto switch_break___0;
  case_57: /* CIL Label */ 
  {
  getout(1);
  }
  case_131: /* CIL Label */ 
  case_124: /* CIL Label */ 
  {
  do_setmark(& ea);
  }
  goto switch_break___0;
  case_34: /* CIL Label */ 
  case_200: /* CIL Label */ 
  case_127: /* CIL Label */ 
  {
  do_align(& ea);
  }
  goto switch_break___0;
  case_197: /* CIL Label */ 
  {
  do_retab(& ea);
  }
  goto switch_break___0;
  case_153: /* CIL Label */ 
  {
  do_normal(& ea);
  }
  goto switch_break___0;
  case_96: /* CIL Label */ 
  {
  do_make(ea.arg, p_gefm);
  }
  goto switch_break___0;
  case_132: /* CIL Label */ 
  {
  do_make(ea.arg, p_efm);
  }
  goto switch_break___0;
  case_117___0: /* CIL Label */ 
  case_73___0: /* CIL Label */ 
  {
  errormsg = do_findpat(& ea, 1);
  }
  goto switch_break___0;
  case_109___0: /* CIL Label */ 
  case_70___0: /* CIL Label */ 
  {
  errormsg = do_findpat(& ea, 4);
  }
  goto switch_break___0;
  case_108___0: /* CIL Label */ 
  case_69___0: /* CIL Label */ 
  {
  errormsg = do_findpat(& ea, 2);
  }
  goto switch_break___0;
  case_118___0: /* CIL Label */ 
  case_74___0: /* CIL Label */ 
  {
  errormsg = do_findpat(& ea, 3);
  }
  goto switch_break___0;
  case_236___0: /* CIL Label */ 
  {
  do_syntax(& ea, cmdlinep);
  }
  goto switch_break___0;
  case_101: /* CIL Label */ 
  {
  do_highlight(ea.arg, ea.forceit, 0);
  }
  goto switch_break___0;
  case_76___0: /* CIL Label */ 
  case_78___0: /* CIL Label */ 
  {
  do_echo(& ea, (int )ea.cmdidx == 76);
  }
  goto switch_break___0;
  case_77: /* CIL Label */ 
  {
  do_echohl(ea.arg);
  }
  goto switch_break___0;
  case_86___0: /* CIL Label */ 
  {
  do_execute(& ea, getline___0, cookie);
  }
  goto switch_break___0;
  case_31___0: /* CIL Label */ 
  {
  do_call(& ea);
  }
  goto switch_break___0;
  case_107___0: /* CIL Label */ 
  {
  errormsg = do_if(& ea, cstack);
  }
  goto switch_break___0;
  case_80___0: /* CIL Label */ 
  case_79___0: /* CIL Label */ 
  {
  errormsg = do_else(& ea, cstack);
  }
  goto switch_break___0;
  case_82___0: /* CIL Label */ 
  did_endif = 1;
  if (cstack->cs_idx < 0) {
    errormsg = (char_u *)":endif without :if";
  } else { //Added block
  if ((int )cstack->cs_flags[cstack->cs_idx] & 4) {
    errormsg = (char_u *)":endif without :if";
  } else {
    (cstack->cs_idx) --;
  }
  }
  goto switch_break___0;
  case_275___0: /* CIL Label */ 
  {
  errormsg = do_while(& ea, cstack);
  }
  goto switch_break___0;
  case_54: /* CIL Label */ 
  {
  errormsg = do_continue(cstack);
  }
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
  errormsg = do_break(cstack);
  }
  goto switch_break___0;
  case_84___0: /* CIL Label */ 
  {
  errormsg = do_endwhile(cstack);
  }
  goto switch_break___0;
  case_128___0: /* CIL Label */ 
  {
  do_let(& ea);
  }
  goto switch_break___0;
  case_257: /* CIL Label */ 
  {
  do_unlet(ea.arg, ea.forceit);
  }
  goto switch_break___0;
  case_93___0: /* CIL Label */ 
  {
  do_function(& ea, getline___0, cookie);
  }
  goto switch_break___0;
  case_66: /* CIL Label */ 
  {
  do_delfunction(ea.arg);
  }
  goto switch_break___0;
  case_198___0: /* CIL Label */ 
  {
  do_return(& ea);
  }
  goto switch_break___0;
  case_83: /* CIL Label */ 
  {
  emsg((char_u *)":endfunction not inside a function");
  }
  goto switch_break___0;
  case_104: /* CIL Label */ 
  {
  do_append(ea.line2 - 1L, getline___0, cookie, cstack->cs_whilelevel > 0);
  ex_no_reprint = 1;
  }
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
  do_append(ea.line2, getline___0, cookie, cstack->cs_whilelevel > 0);
  ex_no_reprint = 1;
  }
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
  do_change(ea.line1, ea.line2, getline___0, cookie, cstack->cs_whilelevel > 0);
  ex_no_reprint = 1;
  }
  goto switch_break___0;
  case_286: /* CIL Label */ 
  {
  do_z(ea.line2, ea.arg);
  ex_no_reprint = 1;
  }
  goto switch_break___0;
  case_116: /* CIL Label */ 
  {
  do_intro();
  }
  goto switch_break___0;
  case_150: /* CIL Label */ 
  {
  no_hlsearch = 1;
  redraw_all_later(40);
  }
  goto switch_break___0;
  case_229: /* CIL Label */ 
  if (ea.forceit) {
    {
    coladvance((colnr_t )2147483647);
    curwin->w_curswant = (colnr_t )2147483647;
    curwin->w_set_curswant = 0;
    }
  }
  restart_edit = 'i';
  goto switch_break___0;
  case_297: /* CIL Label */ 
  {
  get_crypt_key(1);
  }
  goto switch_break___0;
  case_164: /* CIL Label */ 
  {
  ex_options();
  }
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  if (! ea.skip) {
    errormsg = (char_u *)"Sorry, this command is not implemented";
  }
  switch_break___0: /* CIL Label */ ;
  }
  doend: 
  if (curwin->w_cursor.lnum == 0L) {
    curwin->w_cursor.lnum = (linenr_t )1;
  }
  if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
    if ((int )*errormsg != 0) {
      if (! did_emsg) {
        if (sourcing) {
          if ((unsigned long )errormsg != (unsigned long )IObuff) {
            {
            strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)errormsg));
            errormsg = IObuff;
            }
          }
          {
          strcat((char * __restrict  )((char *)errormsg), (char const   * __restrict  )((char *)": "));
          tmp___44 = strlen((char const   *)((char *)IObuff));
          strncat((char * __restrict  )((char *)errormsg), (char const   * __restrict  )((char *)*cmdlinep),
                  1025UL - tmp___44);
          }
        }
        {
        emsg(errormsg);
        }
      }
    }
  }
  if (ea.nextcmd) {
    if ((int )*(ea.nextcmd) == 0) {
      ea.nextcmd = (char_u *)((void *)0);
    }
  }
  return (ea.nextcmd);
}
}
static void goto_buffer(EXARG *eap , int start___0 , int dir , int count___2 ) 
{ 
  BUF *old_curbuf ;
  int tmp ;
  int tmp___0 ;

  {
  old_curbuf = curbuf;
  swap_exists_action = 1;
  if ((int )*(eap->cmd) == 115) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  {
  do_buffer(tmp, start___0, dir, count___2, eap->forceit);
  }
  if (swap_exists_action == 2) {
    if ((int )*(eap->cmd) == 115) {
      {
      close_window(curwin, 1);
      }
    } else {
      {
      swap_exists_action = 0;
      close_buffer(curwin, curbuf, 1, 0);
      tmp___0 = buf_valid(old_curbuf);
      }
      if (tmp___0) {
        if ((unsigned long )old_curbuf == (unsigned long )curbuf) {
          {
          old_curbuf = buflist_new((char_u *)((void *)0), (char_u *)((void *)0), 1L,
                                   1);
          }
        }
      } else {
        {
        old_curbuf = buflist_new((char_u *)((void *)0), (char_u *)((void *)0), 1L,
                                 1);
        }
      }
      {
      enter_buffer(old_curbuf);
      }
    }
  } else { //Added block
  if (swap_exists_action == 3) {
    {
    ml_recover();
    msg_puts((char_u *)"\n");
    cmdline_row = msg_row;
    do_modelines();
    }
  }
  }
  swap_exists_action = 0;
  return;
}
}
char_u *set_one_cmd_context(char_u *buff ) 
{ 
  char_u *p___0 ;
  char_u *cmd ;
  char_u *arg ;
  int i___0 ;
  CMDIDX cmdidx ;
  long argt ;
  int compl ;
  char_u delim ;
  int forceit ;
  int usefilter ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char_u *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  UCMD *c ;
  int j ;
  int k ;
  int matchlen ;
  int found ;
  int possible ;
  char_u *cp ;
  char_u *np___0 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  unsigned short const   **tmp___12 ;
  char_u *tmp___13 ;
  char_u *tmp___14 ;
  size_t tmp___15 ;
  int in_quote ;
  char_u *bow ;
  int tmp___16 ;
  int tmp___17 ;
  char_u *tmp___18 ;
  char_u *tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;
  char_u *tmp___22 ;
  char_u *tmp___23 ;
  char_u *tmp___24 ;
  char_u *tmp___25 ;
  char_u *tmp___26 ;
  char_u *tmp___27 ;
  char_u *tmp___28 ;
  char_u *tmp___29 ;

  {
  i___0 = 0;
  argt = 0L;
  compl = 0;
  forceit = 0;
  usefilter = 0;
  expand_pattern = buff;
  expand_context = 1;
  expand_set_path = 0;
  cmd = buff;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = vim_strchr((char_u *)" \t:|", (int )*cmd);
    }
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
  expand_pattern = cmd;
  if ((int )*cmd == 0) {
    return ((char_u *)((void *)0));
  }
  if ((int )*cmd == 34) {
    expand_context = 0;
    return ((char_u *)((void *)0));
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if ((int )*cmd != 0) {
      {
      tmp___2 = vim_isspace((int )*cmd);
      }
      if (! tmp___2) {
        {
        tmp___3 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___3 + (int )*cmd) & 2048)) {
          {
          tmp___4 = vim_strchr((char_u *)".$%\'/?-+,;", (int )*cmd);
          }
          if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
            goto while_break___0;
          }
        }
      }
    } else {
      goto while_break___0;
    }
    if ((int )*cmd == 39) {
      cmd ++;
      if ((int )*cmd == 0) {
        expand_context = 0;
      }
    } else { //Added block
    if ((int )*cmd == 47) {
      goto _L;
    } else { //Added block
    if ((int )*cmd == 63) {
      _L: 
      tmp___0 = cmd;
      cmd ++;
      delim = *tmp___0;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if ((int )*cmd != 0) {
          if (! ((int )*cmd != (int )delim)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        tmp___1 = cmd;
        cmd ++;
        if ((int )*tmp___1 == 92) {
          if ((int )*cmd != 0) {
            cmd ++;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      if ((int )*cmd == 0) {
        expand_context = 0;
      }
    }
    }
    }
    if ((int )*cmd != 0) {
      cmd ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  cmd = skipwhite(cmd);
  expand_pattern = cmd;
  }
  if ((int )*cmd == 0) {
    return ((char_u *)((void *)0));
  }
  if ((int )*cmd == 34) {
    expand_context = 0;
    return ((char_u *)((void *)0));
  }
  if ((int )*cmd == 124) {
    return (cmd + 1);
  } else { //Added block
  if ((int )*cmd == 10) {
    return (cmd + 1);
  }
  }
  if ((int )*cmd == 107) {
    cmdidx = (CMDIDX )124;
    p___0 = cmd + 1;
  } else {
    p___0 = cmd;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
      tmp___5 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___5 + (int )*p___0) & 1024)) {
        if (! ((int )*p___0 == 42)) {
          goto while_break___2;
        }
      }
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    if ((unsigned long )p___0 == (unsigned long )cmd) {
      {
      tmp___6 = vim_strchr((char_u *)"@*!=><&~#", (int )*p___0);
      }
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        p___0 ++;
      }
    }
    i___0 = (int )(p___0 - cmd);
    if (i___0 == 0) {
      expand_context = -1;
      return ((char_u *)((void *)0));
    }
    cmdidx = (CMDIDX )0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! ((int )cmdidx < 299)) {
        goto while_break___3;
      }
      {
      tmp___7 = strncmp((char const   *)((char *)cmdnames[(int )cmdidx].cmd_name),
                        (char const   *)((char *)cmd), (size_t )i___0);
      }
      if (tmp___7 == 0) {
        goto while_break___3;
      }
      cmdidx = (CMDIDX )((int )cmdidx + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
    if ((int )*(cmd + 0) >= 65) {
      if ((int )*(cmd + 0) <= 90) {
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
          tmp___8 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___8 + (int )*p___0) & 8)) {
            if (! ((int )*p___0 == 42)) {
              goto while_break___4;
            }
          }
          p___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        i___0 = (int )(p___0 - cmd);
      }
    }
  }
  if ((int )*p___0 == 0) {
    {
    tmp___9 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___9 + (int )*(p___0 + -1)) & 8) {
      return ((char_u *)((void *)0));
    }
  }
  if ((int )cmdidx == 299) {
    if ((int )*cmd == 115) {
      {
      tmp___13 = vim_strchr((char_u *)"cgriI", (int )*(cmd + 1));
      }
      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
        cmdidx = (CMDIDX )202;
        p___0 = cmd + 1;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if ((int )*(cmd + 0) >= 65) {
      if ((int )*(cmd + 0) <= 90) {
        c = (UCMD *)ucmds.ga_data + 0;
        matchlen = 0;
        found = 0;
        possible = 0;
        j = 0;
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          if (! (j < ucmds.ga_len)) {
            goto while_break___5;
          }
          cp = cmd;
          np___0 = c->uc_name;
          k = 0;
          {
          while (1) {
            while_continue___6: /* CIL Label */ ;
            if (k < i___0) {
              if ((int )*np___0 != 0) {
                tmp___10 = cp;
                cp ++;
                tmp___11 = np___0;
                np___0 ++;
                if (! ((int )*tmp___10 == (int )*tmp___11)) {
                  goto while_break___6;
                }
              } else {
                goto while_break___6;
              }
            } else {
              goto while_break___6;
            }
            k ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          if (k == i___0) {
            goto _L___0;
          } else { //Added block
          if ((int )*np___0 == 0) {
            {
            tmp___12 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___12 + (int )*(cmd + k)) & 2048) {
              _L___0: 
              if (k == i___0) {
                if (found) {
                  expand_context = -1;
                  return ((char_u *)((void *)0));
                }
              }
              if (! found) {
                if (k == i___0) {
                  found = 1;
                } else {
                  possible = 1;
                }
                cmdidx = (CMDIDX )-1;
                argt = c->uc_argt;
                compl = c->uc_compl;
                matchlen = k;
                if (k == i___0) {
                  if ((int )*np___0 == 0) {
                    goto while_break___5;
                  }
                }
              }
            }
          }
          }
          j ++;
          c ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        if (found) {
          p___0 += matchlen - i___0;
        } else { //Added block
        if (possible) {
          p___0 += matchlen - i___0;
        }
        }
      }
    }
    }
  }
  if ((int )cmdidx == 299) {
    expand_context = -1;
    return ((char_u *)((void *)0));
  }
  expand_context = 0;
  if ((int )*p___0 == 33) {
    forceit = 1;
    p___0 ++;
  }
  if ((int )cmdidx != -1) {
    argt = (long )cmdnames[(int )cmdidx].cmd_argt;
  }
  {
  arg = skipwhite(p___0);
  }
  if ((int )cmdidx == 272) {
    goto _L___2;
  } else { //Added block
  if ((int )cmdidx == 260) {
    _L___2: 
    if ((int )*arg == 62) {
      arg ++;
      if ((int )*arg == 62) {
        arg ++;
      }
      {
      arg = skipwhite(arg);
      }
    } else { //Added block
    if ((int )*arg == 33) {
      if ((int )cmdidx == 272) {
        arg ++;
        usefilter = 1;
      }
    }
    }
  }
  }
  if ((int )cmdidx == 191) {
    usefilter = forceit;
    if ((int )*arg == 33) {
      arg ++;
      usefilter = 1;
    }
  }
  if ((int )cmdidx == 291) {
    goto _L___3;
  } else { //Added block
  if ((int )cmdidx == 293) {
    _L___3: 
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      if (! ((int )*arg == (int )*cmd)) {
        goto while_break___7;
      }
      arg ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
    arg = skipwhite(arg);
    }
  }
  }
  if (argt & 32768L) {
    if (! usefilter) {
      if ((int )*arg == 43) {
        {
        p___0 = arg + 1;
        arg = skip_cmd_arg(arg);
        }
        if ((int )*arg == 0) {
          return (p___0);
        }
        {
        arg = skipwhite(arg);
        }
      }
    }
  }
  if (argt & 256L) {
    if (! usefilter) {
      p___0 = arg;
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        if (! *p___0) {
          goto while_break___8;
        }
        if ((int )*p___0 == 22) {
          if ((int )*(p___0 + 1) != 0) {
            p___0 ++;
          }
        } else { //Added block
        if ((int )*p___0 == 34) {
          if (! (argt & 2048L)) {
            goto _L___4;
          } else {
            goto _L___5;
          }
        } else { //Added block
        _L___5: 
        if ((int )*p___0 == 124) {
          goto _L___4;
        } else { //Added block
        if ((int )*p___0 == 10) {
          _L___4: 
          if ((int )*(p___0 - 1) != 92) {
            if ((int )*p___0 == 124) {
              return (p___0 + 1);
            } else { //Added block
            if ((int )*p___0 == 10) {
              return (p___0 + 1);
            }
            }
            return ((char_u *)((void *)0));
          }
        }
        }
        }
        }
        p___0 ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  if (! (argt & 4L)) {
    if ((int )*arg != 0) {
      {
      tmp___14 = vim_strchr((char_u *)"|\"", (int )*arg);
      }
      if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
        return ((char_u *)((void *)0));
      }
    }
  }
  {
  tmp___15 = strlen((char const   *)((char *)buff));
  p___0 = buff + tmp___15;
  }
  {
  while (1) {
    while_continue___9: /* CIL Label */ ;
    if ((unsigned long )p___0 != (unsigned long )arg) {
      if ((int )*p___0 != 32) {
        if (! ((int )*p___0 != 9)) {
          goto while_break___9;
        }
      } else {
        goto while_break___9;
      }
    } else {
      goto while_break___9;
    }
    p___0 --;
  }
  while_break___9: /* CIL Label */ ;
  }
  if ((int )*p___0 == 32) {
    p___0 ++;
  } else { //Added block
  if ((int )*p___0 == 9) {
    p___0 ++;
  }
  }
  expand_pattern = p___0;
  if (argt & 8L) {
    {
    in_quote = 0;
    bow = (char_u *)((void *)0);
    expand_pattern = skipwhite(arg);
    p___0 = expand_pattern;
    }
    {
    while (1) {
      while_continue___10: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break___10;
      }
      if ((int )*p___0 == 92) {
        if (*(p___0 + 1)) {
          p___0 ++;
        } else {
          goto _L___7;
        }
      } else { //Added block
      _L___7: 
      if ((int )*p___0 == 32) {
        goto _L___6;
      } else { //Added block
      if ((int )*p___0 == 9) {
        _L___6: 
        {
        p___0 = skipwhite(p___0);
        }
        if (in_quote) {
          bow = p___0;
        } else {
          expand_pattern = p___0;
        }
        p___0 --;
      } else { //Added block
      if ((int )*p___0 == 96) {
        if (! in_quote) {
          expand_pattern = p___0;
          bow = p___0 + 1;
        }
        in_quote = ! in_quote;
      }
      }
      }
      }
      p___0 ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    if ((unsigned long )bow != (unsigned long )((void *)0)) {
      if (in_quote) {
        expand_pattern = bow;
      }
    }
    expand_context = 2;
  }
  {
  if ((int )cmdidx == 33) {
    goto case_33;
  }
  if ((int )cmdidx == 36) {
    goto case_33;
  }
  if ((int )cmdidx == 99) {
    goto case_99;
  }
  if ((int )cmdidx == 55) {
    goto case_55;
  }
  if ((int )cmdidx == 52) {
    goto case_52;
  }
  if ((int )cmdidx == 65) {
    goto case_65;
  }
  if ((int )cmdidx == 94) {
    goto case_94;
  }
  if ((int )cmdidx == 261) {
    goto case_94;
  }
  if ((int )cmdidx == 289) {
    goto case_289;
  }
  if ((int )cmdidx == 202) {
    goto case_289;
  }
  if ((int )cmdidx == 117) {
    goto case_117;
  }
  if ((int )cmdidx == 73) {
    goto case_117;
  }
  if ((int )cmdidx == 109) {
    goto case_117;
  }
  if ((int )cmdidx == 70) {
    goto case_117;
  }
  if ((int )cmdidx == 108) {
    goto case_117;
  }
  if ((int )cmdidx == 69) {
    goto case_117;
  }
  if ((int )cmdidx == 118) {
    goto case_117;
  }
  if ((int )cmdidx == 74) {
    goto case_117;
  }
  if ((int )cmdidx == 9) {
    goto case_9;
  }
  if ((int )cmdidx == 71) {
    goto case_71;
  }
  if ((int )cmdidx == 214) {
    goto case_214;
  }
  if ((int )cmdidx == 240) {
    goto case_240;
  }
  if ((int )cmdidx == 228) {
    goto case_240;
  }
  if ((int )cmdidx == 177) {
    goto case_240;
  }
  if ((int )cmdidx == 252) {
    goto case_240;
  }
  if ((int )cmdidx == 231) {
    goto case_240;
  }
  if ((int )cmdidx == 184) {
    goto case_240;
  }
  if ((int )cmdidx == 246) {
    goto case_240;
  }
  if ((int )cmdidx == 230) {
    goto case_240;
  }
  if ((int )cmdidx == 179) {
    goto case_240;
  }
  if ((int )cmdidx == 10) {
    goto case_10;
  }
  if ((int )cmdidx == 236) {
    goto case_236;
  }
  if ((int )cmdidx == 128) {
    goto case_128;
  }
  if ((int )cmdidx == 107) {
    goto case_128;
  }
  if ((int )cmdidx == 80) {
    goto case_128;
  }
  if ((int )cmdidx == 275) {
    goto case_128;
  }
  if ((int )cmdidx == 76) {
    goto case_128;
  }
  if ((int )cmdidx == 78) {
    goto case_128;
  }
  if ((int )cmdidx == 86) {
    goto case_128;
  }
  if ((int )cmdidx == 31) {
    goto case_128;
  }
  if ((int )cmdidx == 198) {
    goto case_128;
  }
  if ((int )cmdidx == 257) {
    goto case_257;
  }
  if ((int )cmdidx == 93) {
    goto case_93;
  }
  if ((int )cmdidx == 66) {
    goto case_93;
  }
  if ((int )cmdidx == 77) {
    goto case_77;
  }
  if ((int )cmdidx == 101) {
    goto case_101;
  }
  if ((int )cmdidx == 16) {
    goto case_16;
  }
  if ((int )cmdidx == 26) {
    goto case_16;
  }
  if ((int )cmdidx == 12) {
    goto case_12;
  }
  if ((int )cmdidx == 206) {
    goto case_12;
  }
  if ((int )cmdidx == -1) {
    goto case_neg_1;
  }
  if ((int )cmdidx == 133) {
    goto case_133;
  }
  if ((int )cmdidx == 149) {
    goto case_133;
  }
  if ((int )cmdidx == 144) {
    goto case_133;
  }
  if ((int )cmdidx == 147) {
    goto case_133;
  }
  if ((int )cmdidx == 265) {
    goto case_133;
  }
  if ((int )cmdidx == 268) {
    goto case_133;
  }
  if ((int )cmdidx == 158) {
    goto case_133;
  }
  if ((int )cmdidx == 162) {
    goto case_133;
  }
  if ((int )cmdidx == 110) {
    goto case_133;
  }
  if ((int )cmdidx == 113) {
    goto case_133;
  }
  if ((int )cmdidx == 41) {
    goto case_133;
  }
  if ((int )cmdidx == 47) {
    goto case_133;
  }
  if ((int )cmdidx == 258) {
    goto case_258;
  }
  if ((int )cmdidx == 155) {
    goto case_258;
  }
  if ((int )cmdidx == 270) {
    goto case_258;
  }
  if ((int )cmdidx == 165) {
    goto case_258;
  }
  if ((int )cmdidx == 119) {
    goto case_258;
  }
  if ((int )cmdidx == 61) {
    goto case_258;
  }
  if ((int )cmdidx == 1) {
    goto case_1;
  }
  if ((int )cmdidx == 151) {
    goto case_1;
  }
  if ((int )cmdidx == 29) {
    goto case_1;
  }
  if ((int )cmdidx == 48) {
    goto case_1;
  }
  if ((int )cmdidx == 105) {
    goto case_1;
  }
  if ((int )cmdidx == 114) {
    goto case_1;
  }
  if ((int )cmdidx == 255) {
    goto case_255;
  }
  if ((int )cmdidx == 62) {
    goto case_255;
  }
  if ((int )cmdidx == 120) {
    goto case_255;
  }
  if ((int )cmdidx == 136) {
    goto case_136;
  }
  if ((int )cmdidx == 152) {
    goto case_136;
  }
  if ((int )cmdidx == 259) {
    goto case_136;
  }
  if ((int )cmdidx == 4) {
    goto case_136;
  }
  if ((int )cmdidx == 5) {
    goto case_136;
  }
  if ((int )cmdidx == 11) {
    goto case_136;
  }
  if ((int )cmdidx == 146) {
    goto case_136;
  }
  if ((int )cmdidx == 148) {
    goto case_136;
  }
  if ((int )cmdidx == 156) {
    goto case_136;
  }
  if ((int )cmdidx == 267) {
    goto case_136;
  }
  if ((int )cmdidx == 269) {
    goto case_136;
  }
  if ((int )cmdidx == 271) {
    goto case_136;
  }
  if ((int )cmdidx == 160) {
    goto case_136;
  }
  if ((int )cmdidx == 163) {
    goto case_136;
  }
  if ((int )cmdidx == 166) {
    goto case_136;
  }
  if ((int )cmdidx == 112) {
    goto case_136;
  }
  if ((int )cmdidx == 115) {
    goto case_136;
  }
  if ((int )cmdidx == 121) {
    goto case_136;
  }
  if ((int )cmdidx == 43) {
    goto case_136;
  }
  if ((int )cmdidx == 49) {
    goto case_136;
  }
  if ((int )cmdidx == 63) {
    goto case_136;
  }
  if ((int )cmdidx == 248) {
    goto case_136;
  }
  if ((int )cmdidx == 253) {
    goto case_136;
  }
  if ((int )cmdidx == 245) {
    goto case_136;
  }
  if ((int )cmdidx == 81) {
    goto case_136;
  }
  goto switch_default;
  case_33: /* CIL Label */ 
  case_36: /* CIL Label */ 
  expand_context = 3;
  goto switch_break;
  case_99: /* CIL Label */ 
  expand_context = 8;
  expand_pattern = arg;
  goto switch_break;
  case_55: /* CIL Label */ 
  return (arg);
  case_52: /* CIL Label */ 
  {
  while (1) {
    while_continue___11: /* CIL Label */ ;
    if (! ((int )*arg == 45)) {
      goto while_break___11;
    }
    {
    arg ++;
    p___0 = skiptowhite(arg);
    }
    if ((int )*p___0 == 0) {
      {
      p___0 = vim_strchr(arg, '=');
      }
      if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
        expand_context = 23;
        expand_pattern = arg;
        return ((char_u *)((void *)0));
      }
      {
      tmp___17 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"complete"),
                             (size_t )(p___0 - arg));
      }
      if (tmp___17 == 0) {
        expand_context = 25;
        expand_pattern = p___0 + 1;
        return ((char_u *)((void *)0));
      } else {
        {
        tmp___16 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"nargs"),
                               (size_t )(p___0 - arg));
        }
        if (tmp___16 == 0) {
          expand_context = 24;
          expand_pattern = p___0 + 1;
          return ((char_u *)((void *)0));
        }
      }
      return ((char_u *)((void *)0));
    }
    {
    arg = skipwhite(p___0);
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
  p___0 = skiptowhite(arg);
  }
  if ((int )*p___0 == 0) {
    expand_context = 22;
    expand_pattern = arg;
    goto switch_break;
  }
  {
  tmp___18 = skipwhite(p___0);
  }
  return (tmp___18);
  case_65: /* CIL Label */ 
  expand_context = 22;
  expand_pattern = arg;
  goto switch_break;
  case_94: /* CIL Label */ 
  case_261: /* CIL Label */ 
  delim = *arg;
  if (delim) {
    arg ++;
  }
  {
  while (1) {
    while_continue___12: /* CIL Label */ ;
    if ((int )*(arg + 0) != 0) {
      if (! ((int )*(arg + 0) != (int )delim)) {
        goto while_break___12;
      }
    } else {
      goto while_break___12;
    }
    if ((int )*(arg + 0) == 92) {
      if ((int )*(arg + 1) != 0) {
        arg ++;
      }
    }
    arg ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  if ((int )*(arg + 0) != 0) {
    return (arg + 1);
  }
  goto switch_break;
  case_289: /* CIL Label */ 
  case_202: /* CIL Label */ 
  delim = *arg;
  if (delim) {
    arg ++;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___13: /* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break___13;
    }
    {
    while (1) {
      while_continue___14: /* CIL Label */ ;
      if ((int )*(arg + 0) != 0) {
        if (! ((int )*(arg + 0) != (int )delim)) {
          goto while_break___14;
        }
      } else {
        goto while_break___14;
      }
      if ((int )*(arg + 0) == 92) {
        if ((int )*(arg + 1) != 0) {
          arg ++;
        }
      }
      arg ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    if ((int )*(arg + 0) != 0) {
      arg ++;
    }
    i___0 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___15: /* CIL Label */ ;
    if (*(arg + 0)) {
      {
      tmp___19 = vim_strchr((char_u *)"|\"#", (int )*(arg + 0));
      }
      if (! ((unsigned long )tmp___19 == (unsigned long )((void *)0))) {
        goto while_break___15;
      }
    } else {
      goto while_break___15;
    }
    arg ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  if ((int )*(arg + 0) != 0) {
    return (arg);
  }
  goto switch_break;
  case_117: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_74: /* CIL Label */ 
  {
  tmp___20 = skipdigits(arg);
  arg = skipwhite(tmp___20);
  }
  if ((int )*arg == 47) {
    arg ++;
    {
    while (1) {
      while_continue___16: /* CIL Label */ ;
      if (*arg) {
        if (! ((int )*arg != 47)) {
          goto while_break___16;
        }
      } else {
        goto while_break___16;
      }
      if ((int )*arg == 92) {
        if ((int )*(arg + 1) != 0) {
          arg ++;
        }
      }
      arg ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    if (*arg) {
      {
      arg = skipwhite(arg + 1);
      }
      if (*arg) {
        {
        tmp___21 = vim_strchr((char_u *)"|\"\n", (int )*arg);
        }
        if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
          expand_context = 0;
        } else {
          return (arg);
        }
      } else {
        return (arg);
      }
    }
  }
  goto switch_break;
  case_9: /* CIL Label */ 
  {
  tmp___22 = set_context_in_autocmd(arg, 0);
  }
  return (tmp___22);
  case_71: /* CIL Label */ 
  {
  tmp___23 = set_context_in_autocmd(arg, 1);
  }
  return (tmp___23);
  case_214: /* CIL Label */ 
  {
  set_context_in_set_cmd(arg);
  }
  goto switch_break;
  case_240: /* CIL Label */ 
  case_228: /* CIL Label */ 
  case_177: /* CIL Label */ 
  case_252: /* CIL Label */ 
  case_231: /* CIL Label */ 
  case_184: /* CIL Label */ 
  case_246: /* CIL Label */ 
  case_230: /* CIL Label */ 
  case_179: /* CIL Label */ 
  expand_context = 6;
  expand_pattern = arg;
  goto switch_break;
  case_10: /* CIL Label */ 
  expand_context = 14;
  expand_pattern = arg;
  goto switch_break;
  case_236: /* CIL Label */ 
  {
  set_context_in_syntax_cmd(arg);
  }
  goto switch_break;
  case_128: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_275: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_198: /* CIL Label */ 
  {
  set_context_for_expression(arg, cmdidx);
  }
  goto switch_break;
  case_257: /* CIL Label */ 
  {
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
    expand_pattern = vim_strchr(arg, ' ');
    }
    if (! ((unsigned long )expand_pattern != (unsigned long )((void *)0))) {
      goto while_break___17;
    }
    arg = expand_pattern + 1;
  }
  while_break___17: /* CIL Label */ ;
  }
  expand_context = 15;
  expand_pattern = arg;
  goto switch_break;
  case_93: /* CIL Label */ 
  case_66: /* CIL Label */ 
  expand_context = 19;
  expand_pattern = arg;
  goto switch_break;
  case_77: /* CIL Label */ 
  expand_context = 13;
  expand_pattern = arg;
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  set_context_in_highlight_cmd(arg);
  }
  goto switch_break;
  case_16: /* CIL Label */ 
  case_26: /* CIL Label */ 
  {
  while (1) {
    while_continue___18: /* CIL Label */ ;
    {
    expand_pattern = vim_strchr(arg, ' ');
    }
    if (! ((unsigned long )expand_pattern != (unsigned long )((void *)0))) {
      goto while_break___18;
    }
    arg = expand_pattern + 1;
  }
  while_break___18: /* CIL Label */ ;
  }
  case_12: /* CIL Label */ 
  case_206: /* CIL Label */ 
  expand_context = 9;
  expand_pattern = arg;
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  if (compl != 0) {
    if (! (argt & 8L)) {
      if (compl == 11) {
        {
        tmp___24 = set_context_in_menu_cmd(cmd, arg, forceit);
        }
        return (tmp___24);
      }
      if (compl == 1) {
        return (arg);
      }
      {
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
        expand_pattern = vim_strchr(arg, ' ');
        }
        if (! ((unsigned long )expand_pattern != (unsigned long )((void *)0))) {
          goto while_break___19;
        }
        arg = expand_pattern + 1;
      }
      while_break___19: /* CIL Label */ ;
      }
      expand_context = compl;
      expand_pattern = arg;
    }
  }
  goto switch_break;
  case_133: /* CIL Label */ 
  case_149: /* CIL Label */ 
  case_144: /* CIL Label */ 
  case_147: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_268: /* CIL Label */ 
  case_158: /* CIL Label */ 
  case_162: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_47: /* CIL Label */ 
  {
  tmp___25 = set_context_in_map_cmd(cmd, arg, forceit, 0, 0, cmdidx);
  }
  return (tmp___25);
  case_258: /* CIL Label */ 
  case_155: /* CIL Label */ 
  case_270: /* CIL Label */ 
  case_165: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_61: /* CIL Label */ 
  {
  tmp___26 = set_context_in_map_cmd(cmd, arg, forceit, 0, 1, cmdidx);
  }
  return (tmp___26);
  case_1: /* CIL Label */ 
  case_151: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
  tmp___27 = set_context_in_map_cmd(cmd, arg, forceit, 1, 0, cmdidx);
  }
  return (tmp___27);
  case_255: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_120: /* CIL Label */ 
  {
  tmp___28 = set_context_in_map_cmd(cmd, arg, forceit, 1, 1, cmdidx);
  }
  return (tmp___28);
  case_136: /* CIL Label */ 
  case_152: /* CIL Label */ 
  case_259: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_146: /* CIL Label */ 
  case_148: /* CIL Label */ 
  case_156: /* CIL Label */ 
  case_267: /* CIL Label */ 
  case_269: /* CIL Label */ 
  case_271: /* CIL Label */ 
  case_160: /* CIL Label */ 
  case_163: /* CIL Label */ 
  case_166: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_248: /* CIL Label */ 
  case_253: /* CIL Label */ 
  case_245: /* CIL Label */ 
  case_81: /* CIL Label */ 
  {
  tmp___29 = set_context_in_menu_cmd(cmd, arg, forceit);
  }
  return (tmp___29);
  switch_default: /* CIL Label */ 
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
static linenr_t get_address(char_u **ptr , int skip ) 
{ 
  int c ;
  int i___0 ;
  long n ;
  char_u *cmd ;
  FPOS pos___0 ;
  FPOS *fp___0 ;
  linenr_t lnum ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char_u *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  {
  cmd = skipwhite(*ptr);
  lnum = (linenr_t )2147483647;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    if ((int )*cmd == 46) {
      goto case_46;
    }
    if ((int )*cmd == 36) {
      goto case_36;
    }
    if ((int )*cmd == 39) {
      goto case_39;
    }
    if ((int )*cmd == 47) {
      goto case_47;
    }
    if ((int )*cmd == 63) {
      goto case_47;
    }
    if ((int )*cmd == 92) {
      goto case_92;
    }
    goto switch_default;
    case_46: /* CIL Label */ 
    cmd ++;
    lnum = curwin->w_cursor.lnum;
    goto switch_break;
    case_36: /* CIL Label */ 
    cmd ++;
    lnum = curbuf->b_ml.ml_line_count;
    goto switch_break;
    case_39: /* CIL Label */ 
    cmd ++;
    if ((int )*cmd == 0) {
      cmd = (char_u *)((void *)0);
      goto error;
    }
    if (skip) {
      cmd ++;
    } else {
      {
      fp___0 = getmark((int )*cmd, 0);
      cmd ++;
      tmp = check_mark(fp___0);
      }
      if (tmp == 0) {
        cmd = (char_u *)((void *)0);
        goto error;
      }
      lnum = fp___0->lnum;
    }
    goto switch_break;
    case_47: /* CIL Label */ 
    case_63: /* CIL Label */ 
    tmp___0 = cmd;
    cmd ++;
    c = (int )*tmp___0;
    if (skip) {
      {
      cmd = skip_regexp(cmd, c, p_magic);
      }
      if ((int )*cmd == c) {
        cmd ++;
      }
    } else {
      pos___0 = curwin->w_cursor;
      if (lnum != 2147483647L) {
        curwin->w_cursor.lnum = lnum;
      }
      if (c == 47) {
        curwin->w_cursor.col = (colnr_t )2147483647;
      } else {
        curwin->w_cursor.col = (colnr_t )0;
      }
      {
      searchcmdlen = 0;
      tmp___1 = do_search((OPARG *)((void *)0), c, cmd, 1L, 300);
      }
      if (! tmp___1) {
        curwin->w_cursor = pos___0;
        cmd = (char_u *)((void *)0);
        goto error;
      }
      lnum = curwin->w_cursor.lnum;
      curwin->w_cursor = pos___0;
      cmd += searchcmdlen;
    }
    goto switch_break;
    case_92: /* CIL Label */ 
    cmd ++;
    if ((int )*cmd == 38) {
      i___0 = 1;
    } else { //Added block
    if ((int )*cmd == 63) {
      i___0 = 0;
    } else { //Added block
    if ((int )*cmd == 47) {
      i___0 = 0;
    } else {
      {
      emsg(e_backslash);
      cmd = (char_u *)((void *)0);
      }
      goto error;
    }
    }
    }
    if (! skip) {
      if (lnum != 2147483647L) {
        pos___0.lnum = lnum;
      } else {
        pos___0.lnum = curwin->w_cursor.lnum;
      }
      if ((int )*cmd != 63) {
        pos___0.col = (colnr_t )2147483647;
      } else {
        pos___0.col = (colnr_t )0;
      }
      if ((int )*cmd == 63) {
        tmp___2 = -1;
      } else {
        tmp___2 = 1;
      }
      {
      tmp___3 = searchit(curbuf, & pos___0, tmp___2, (char_u *)"", 1L, 268, i___0);
      }
      if (tmp___3 == 1) {
        lnum = pos___0.lnum;
      } else {
        cmd = (char_u *)((void *)0);
        goto error;
      }
    }
    cmd ++;
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    tmp___4 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___4 + (int )*cmd) & 2048) {
      {
      lnum = getdigits(& cmd);
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      cmd = skipwhite(cmd);
      }
      if ((int )*cmd != 45) {
        if ((int )*cmd != 43) {
          {
          tmp___5 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___5 + (int )*cmd) & 2048)) {
            goto while_break___0;
          }
        }
      }
      if (lnum == 2147483647L) {
        lnum = curwin->w_cursor.lnum;
      }
      {
      tmp___7 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___7 + (int )*cmd) & 2048) {
        i___0 = '+';
      } else {
        tmp___6 = cmd;
        cmd ++;
        i___0 = (int )*tmp___6;
      }
      {
      tmp___8 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___8 + (int )*cmd) & 2048) {
        {
        n = getdigits(& cmd);
        }
      } else {
        n = 1L;
      }
      if (i___0 == 45) {
        lnum -= n;
      } else {
        lnum += n;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (! ((int )*cmd == 47)) {
      if (! ((int )*cmd == 63)) {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  *ptr = cmd;
  return (lnum);
}
}
static char_u *invalid_range(EXARG *eap ) 
{ 


  {
  if (eap->line1 < 0L) {
    return (e_invrange);
  } else { //Added block
  if (eap->line2 < 0L) {
    return (e_invrange);
  } else { //Added block
  if (eap->line1 > eap->line2) {
    return (e_invrange);
  } else { //Added block
  if (eap->argt & 1L) {
    if (! (eap->argt & 16384L)) {
      if (eap->line2 > curbuf->b_ml.ml_line_count) {
        return (e_invrange);
      }
    }
  }
  }
  }
  }
  return ((char_u *)((void *)0));
}
}
static void correct_range(EXARG *eap ) 
{ 


  {
  if (! (eap->argt & 4096L)) {
    if (eap->line1 == 0L) {
      eap->line1 = (linenr_t )1;
    }
    if (eap->line2 == 0L) {
      eap->line2 = (linenr_t )1;
    }
  }
  return;
}
}
int expand_filename(EXARG *eap , char_u **cmdlinep , char_u **errormsgp ) 
{ 
  int has_wildcards ;
  char_u *repl ;
  int srclen ;
  char_u *p___0 ;
  int n ;
  char_u *tmp ;
  char_u *l ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;

  {
  {
  has_wildcards = mch_has_wildcard(eap->arg);
  p___0 = eap->arg;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp = vim_strchr((char_u *)"%#<", (int )*p___0);
    }
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      p___0 ++;
      goto __Cont;
    }
    {
    repl = eval_vars(p___0, & srclen, & eap->do_ecmd_lnum, errormsgp, eap->arg);
    }
    if ((unsigned long )*errormsgp != (unsigned long )((void *)0)) {
      return (0);
    }
    if ((unsigned long )repl == (unsigned long )((void *)0)) {
      p___0 += srclen;
      goto __Cont;
    }
    if (eap->argt & 16L) {
      if (! eap->usefilter) {
        l = repl;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! *l) {
            goto while_break___0;
          }
          {
          tmp___0 = vim_strchr(escape_chars, (int )*l);
          }
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
            {
            l = vim_strsave_escaped(repl, escape_chars);
            }
            if ((unsigned long )l != (unsigned long )((void *)0)) {
              {
              vim_free((void *)repl);
              repl = l;
              }
            }
            goto while_break___0;
          }
          l ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
    p___0 = repl_cmdline(eap, p___0, srclen, repl, cmdlinep);
    vim_free((void *)repl);
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      return (0);
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  if (eap->argt & 16L) {
    if (! eap->usefilter) {
      n = 1;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (n <= 2)) {
          goto while_break___1;
        }
        if (n == 2) {
          if (! has_wildcards) {
            p___0 = eap->arg;
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              if (! *p___0) {
                goto while_break___2;
              }
              if (*(p___0 + 1)) {
                if ((int )*p___0 == 92) {
                  p___0 ++;
                } else { //Added block
                if ((int )*p___0 == 22) {
                  p___0 ++;
                } else {
                  goto _L;
                }
                }
              } else { //Added block
              _L: 
              if ((int )*p___0 == 32) {
                *errormsgp = (char_u *)"Only one file name allowed";
                return (0);
              } else { //Added block
              if ((int )*p___0 == 9) {
                *errormsgp = (char_u *)"Only one file name allowed";
                return (0);
              }
              }
              }
              p___0 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
          if (! has_wildcards) {
            {
            backslash_halve(eap->arg);
            }
          }
        }
        if (has_wildcards) {
          if (n == 1) {
            {
            tmp___1 = vim_strchr(eap->arg, '$');
            }
            if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
              {
              expand_env(eap->arg, NameBuff, 1024);
              has_wildcards = mch_has_wildcard(NameBuff);
              p___0 = NameBuff;
              }
            } else {
              {
              tmp___2 = vim_strchr(eap->arg, '~');
              }
              if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
                {
                expand_env(eap->arg, NameBuff, 1024);
                has_wildcards = mch_has_wildcard(NameBuff);
                p___0 = NameBuff;
                }
              } else {
                p___0 = (char_u *)((void *)0);
              }
            }
          } else {
            {
            expand_context = 2;
            p___0 = ExpandOne(eap->arg, (char_u *)((void *)0), 17, 2);
            }
            if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
              return (0);
            }
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            tmp___3 = strlen((char const   *)((char *)eap->arg));
            repl_cmdline(eap, eap->arg, (int )tmp___3, p___0, cmdlinep);
            }
            if (n == 2) {
              {
              vim_free((void *)p___0);
              }
            }
          }
        }
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return (1);
}
}
static char_u *repl_cmdline(EXARG *eap , char_u *src , int srclen , char_u *repl ,
                            char_u **cmdlinep ) 
{ 
  int len___0 ;
  int i___0 ;
  char_u *new_cmdline ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
  tmp = strlen((char const   *)((char *)repl));
  len___0 = (int )tmp;
  tmp___0 = strlen((char const   *)((char *)*cmdlinep));
  i___0 = (int )((tmp___0 + (size_t )len___0) + 3UL);
  }
  if (eap->nextcmd) {
    {
    tmp___1 = strlen((char const   *)((char *)eap->nextcmd));
    i___0 = (int )((size_t )i___0 + tmp___1);
    }
  }
  {
  new_cmdline = alloc((unsigned int )i___0);
  }
  if ((unsigned long )new_cmdline == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  i___0 = (int )(src - *cmdlinep);
  memmove((void *)((char *)new_cmdline), (void const   *)((char *)*cmdlinep), (size_t )i___0);
  memmove((void *)((char *)(new_cmdline + i___0)), (void const   *)((char *)repl),
          (size_t )len___0);
  i___0 += len___0;
  strcpy((char * __restrict  )((char *)(new_cmdline + i___0)), (char const   * __restrict  )((char *)(src + srclen)));
  src = new_cmdline + i___0;
  }
  if (eap->nextcmd) {
    {
    tmp___2 = strlen((char const   *)((char *)new_cmdline));
    i___0 = (int )(tmp___2 + 1UL);
    strcpy((char * __restrict  )((char *)(new_cmdline + i___0)), (char const   * __restrict  )((char *)eap->nextcmd));
    eap->nextcmd = new_cmdline + i___0;
    }
  }
  eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);
  eap->arg = new_cmdline + (eap->arg - *cmdlinep);
  if ((unsigned long )eap->do_ecmd_cmd != (unsigned long )((void *)0)) {
    eap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);
  }
  {
  vim_free((void *)*cmdlinep);
  *cmdlinep = new_cmdline;
  }
  return (src);
}
}
void separate_nextcmd(EXARG *eap ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  char_u *tmp___0 ;

  {
  p___0 = eap->arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == 22) {
      if (eap->argt & 8200L) {
        p___0 ++;
      } else {
        {
        strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)(p___0 + 1)));
        }
      }
      if ((int )*p___0 == 0) {
        goto while_break;
      }
    } else { //Added block
    if ((int )*p___0 == 34) {
      if (! (eap->argt & 2048L)) {
        if ((int )eap->cmdidx != 294) {
          if ((int )eap->cmdidx != 290) {
            goto _L___0;
          } else {
            goto _L___2;
          }
        } else { //Added block
        _L___2: 
        if ((unsigned long )p___0 != (unsigned long )eap->arg) {
          goto _L___0;
        } else {
          goto _L___3;
        }
        }
      } else {
        goto _L___3;
      }
    } else { //Added block
    _L___3: 
    if ((int )*p___0 == 124) {
      goto _L___0;
    } else { //Added block
    if ((int )*p___0 == 10) {
      _L___0: 
      {
      tmp___0 = vim_strchr(p_cpo, 'b');
      }
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        goto _L;
      } else { //Added block
      if (! (eap->argt & 8192L)) {
        _L: 
        if ((int )*(p___0 - 1) == 92) {
          {
          tmp = strlen((char const   *)((char *)p___0));
          memmove((void *)((char *)(p___0 - 1)), (void const   *)((char *)p___0),
                  tmp + 1UL);
          p___0 --;
          }
        } else {
          {
          eap->nextcmd = check_nextcmd(p___0);
          *p___0 = (char_u )'\000';
          }
          goto while_break;
        }
      } else {
        {
        eap->nextcmd = check_nextcmd(p___0);
        *p___0 = (char_u )'\000';
        }
        goto while_break;
      }
      }
    }
    }
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (! (eap->argt & 2048L)) {
    {
    del_trailing_spaces(eap->arg);
    }
  }
  return;
}
}
int autowrite(BUF *buf___3 , int forceit ) 
{ 
  int tmp ;

  {
  if (! p_aw) {
    return (0);
  } else { //Added block
  if (! p_write) {
    return (0);
  } else { //Added block
  if (! forceit) {
    if (buf___3->b_p_ro) {
      return (0);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    return (0);
  }
  }
  }
  }
  {
  tmp = buf_write_all(buf___3);
  }
  return (tmp);
}
}
void autowrite_all(void) 
{ 
  BUF *buf___3 ;
  int tmp ;
  int tmp___0 ;

  {
  if (! p_aw) {
    return;
  } else { //Added block
  if (! p_write) {
    return;
  }
  }
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! buf___3) {
      goto while_break;
    }
    {
    tmp___0 = buf_changed(buf___3);
    }
    if (tmp___0) {
      if (! buf___3->b_p_ro) {
        {
        buf_write_all(buf___3);
        tmp = buf_valid(buf___3);
        }
        if (! tmp) {
          buf___3 = firstbuf;
        }
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int check_changed(BUF *buf___3 , int checkaw , int mult_win , int forceit , int allbuf ) 
{ 
  BUF *buf2 ;
  int count___2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! forceit) {
    {
    tmp___1 = buf_changed(buf___3);
    }
    if (tmp___1) {
      if (mult_win) {
        goto _L___1;
      } else { //Added block
      if (buf___3->b_nwindows <= 1) {
        _L___1: 
        if (! checkaw) {
          goto _L___0;
        } else {
          {
          tmp___2 = autowrite(buf___3, forceit);
          }
          if (tmp___2 == 0) {
            _L___0: 
            if (p_confirm) {
              goto _L;
            } else { //Added block
            if (confirm) {
              _L: 
              if (p_write) {
                count___2 = 0;
                if (allbuf) {
                  buf2 = firstbuf;
                  {
                  while (1) {
                    while_continue: /* CIL Label */ ;
                    if (! ((unsigned long )buf2 != (unsigned long )((void *)0))) {
                      goto while_break;
                    }
                    {
                    tmp = buf_changed(buf2);
                    }
                    if (tmp) {
                      if ((unsigned long )buf2->b_ffname != (unsigned long )((void *)0)) {
                        count___2 ++;
                      }
                    }
                    buf2 = buf2->b_next;
                  }
                  while_break: /* CIL Label */ ;
                  }
                }
                {
                dialog_changed(buf___3, count___2 > 1);
                tmp___0 = buf_changed(buf___3);
                }
                return (tmp___0);
              }
            }
            }
            {
            emsg(e_nowrtmsg);
            }
            return (1);
          }
        }
      }
      }
    }
  }
  return (0);
}
}
void dialog_changed(BUF *buf___3 , int checkall ) 
{ 
  char_u buff[1025] ;
  int ret ;
  BUF *buf2 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
    tmp = buf___3->b_fname;
  } else {
    tmp = (char_u *)"Untitled";
  }
  {
  dialog_msg(buff, (char *)"Save changes to \"%.*s\"?", tmp);
  }
  if (checkall) {
    {
    ret = vim_dialog_yesnoallcancel(4, (char_u *)((void *)0), buff, 1);
    }
  } else {
    {
    ret = vim_dialog_yesnocancel(4, (char_u *)((void *)0), buff, 1);
    }
  }
  if (ret == 2) {
    if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
      {
      buf_write_all(buf___3);
      }
    }
  } else { //Added block
  if (ret == 3) {
    {
    unchanged(buf___3, 1);
    }
  } else { //Added block
  if (ret == 5) {
    buf2 = firstbuf;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )buf2 != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {
      tmp___1 = buf_changed(buf2);
      }
      if (tmp___1) {
        if ((unsigned long )buf2->b_ffname != (unsigned long )((void *)0)) {
          if (! buf2->b_p_ro) {
            if ((unsigned long )buf2->b_fname != (unsigned long )((void *)0)) {
              {
              buf_write_all(buf2);
              }
            }
            {
            tmp___0 = buf_valid(buf2);
            }
            if (! tmp___0) {
              buf2 = firstbuf;
            }
          }
        }
      }
      buf2 = buf2->b_next;
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if (ret == 6) {
    buf2 = firstbuf;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )buf2 != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      unchanged(buf2, 1);
      buf2 = buf2->b_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  }
  }
  }
  return;
}
}
int can_abandon(BUF *buf___3 , int forceit ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (p_hid) {
    tmp___1 = 1;
  } else {
    {
    tmp = buf_changed(buf___3);
    }
    if (tmp) {
      if (buf___3->b_nwindows > 1) {
        tmp___1 = 1;
      } else {
        {
        tmp___0 = autowrite(buf___3, forceit);
        }
        if (tmp___0 == 1) {
          tmp___1 = 1;
        } else { //Added block
        if (forceit) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
        }
      }
    } else {
      tmp___1 = 1;
    }
  }
  return (tmp___1);
}
}
int check_changed_any(int hidden ) 
{ 
  BUF *buf___3 ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! hidden) {
      {
      tmp___0 = buf_changed(curbuf);
      }
      if (tmp___0) {
        buf___3 = curbuf;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
        if (! hidden) {
          goto _L;
        } else { //Added block
        if (buf___3->b_nwindows == 0) {
          _L: 
          {
          tmp = buf_changed(buf___3);
          }
          if (tmp) {
            goto while_break___0;
          }
        }
        }
        buf___3 = buf___3->b_next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      return (0);
    }
    if (p_confirm) {
      goto _L___1;
    } else { //Added block
    if (confirm) {
      _L___1: 
      {
      tmp___1 = check_changed(buf___3, 0, 1, 0, 1);
      }
      if (tmp___1) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  exiting = 0;
  if (! p_confirm) {
    if (! confirm) {
      if (vgetc_busy) {
        msg_row = cmdline_row;
        msg_col = 0;
        msg_didout = 0;
      }
      if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
        tmp___2 = (char_u *)"No File";
      } else {
        tmp___2 = buf___3->b_fname;
      }
      {
      tmp___3 = emsg2((char_u *)"No write since last change for buffer \"%s\"", tmp___2);
      }
      if (tmp___3) {
        {
        save = no_wait_return;
        no_wait_return = 0;
        wait_return(0);
        no_wait_return = save;
        }
      }
    }
  }
  {
  do_buffer(0, 1, 1, buf___3->b_fnum, 0);
  }
  return (1);
}
}
int check_fname(void) 
{ 


  {
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    {
    emsg(e_noname);
    }
    return (0);
  }
  return (1);
}
}
int buf_write_all(BUF *buf___3 ) 
{ 
  int retval ;
  BUF *old_curbuf ;

  {
  {
  old_curbuf = curbuf;
  retval = buf_write(buf___3, buf___3->b_ffname, buf___3->b_fname, (linenr_t )1, buf___3->b_ml.ml_line_count,
                     0, 0, 1, 0);
  }
  if ((unsigned long )curbuf != (unsigned long )old_curbuf) {
    {
    msg((char_u *)"Warning: Entered other buffer unexpectedly (check autocommands)");
    }
  }
  return (retval);
}
}
static char_u *getargcmd(char_u **argp ) 
{ 
  char_u *arg ;
  char_u *command ;
  char_u *tmp ;
  int tmp___0 ;

  {
  arg = *argp;
  command = (char_u *)((void *)0);
  if ((int )*arg == 43) {
    {
    arg ++;
    tmp___0 = vim_isspace((int )*arg);
    }
    if (tmp___0) {
      command = (char_u *)"$";
    } else {
      {
      command = arg;
      arg = skip_cmd_arg(command);
      }
      if (*arg) {
        tmp = arg;
        arg ++;
        *tmp = (char_u )'\000';
      }
    }
    {
    arg = skipwhite(arg);
    *argp = arg;
    }
  }
  return (command);
}
}
static char_u *skip_cmd_arg(char_u *p___0 ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      {
      tmp = vim_isspace((int )*p___0);
      }
      if (tmp) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 92) {
      if ((int )*(p___0 + 1) != 0) {
        p___0 ++;
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
int rem_backslash(char_u *str___1 ) 
{ 
  int tmp ;

  {
  if ((int )*(str___1 + 0) == 92) {
    if ((int )*(str___1 + 1) != 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void backslash_halve(char_u *p___0 ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp = rem_backslash(p___0);
    }
    if (tmp) {
      {
      strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)(p___0 + 1)));
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
char_u *backslash_halve_save(char_u *p___0 ) 
{ 
  char_u *res ;

  {
  {
  res = vim_strsave(p___0);
  }
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    return (p___0);
  }
  {
  backslash_halve(res);
  }
  return (res);
}
}
static void do_make(char_u *arg , char_u *errorformat ) 
{ 
  char_u *name___1 ;
  char_u *cmd ;
  unsigned int len___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  autowrite_all();
  name___1 = get_mef_name(1);
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return;
  }
  {
  unlink((char const   *)((char *)name___1));
  tmp = strlen((char const   *)((char *)p_shq));
  tmp___0 = strlen((char const   *)((char *)arg));
  len___0 = (unsigned int )((tmp * 2UL + tmp___0) + 1UL);
  }
  if ((int )*p_sp != 0) {
    {
    tmp___1 = strlen((char const   *)((char *)p_sp));
    tmp___2 = strlen((char const   *)((char *)name___1));
    len___0 = (unsigned int )((size_t )len___0 + ((tmp___1 + tmp___2) + 2UL));
    }
  }
  {
  cmd = alloc(len___0);
  }
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
    return;
  }
  if ((int )*p_sp == 0) {
    {
    sprintf((char * __restrict  )((char *)cmd), (char const   * __restrict  )"%s%s%s",
            p_shq, arg, p_shq);
    }
  } else {
    {
    sprintf((char * __restrict  )((char *)cmd), (char const   * __restrict  )"%s%s%s %s %s",
            p_shq, arg, p_shq, p_sp, name___1);
    }
  }
  if (msg_col != 0) {
    {
    msg_putchar('\n');
    }
  }
  {
  msg_puts((char_u *)":!");
  msg_outtrans(cmd);
  }
  if ((int )*p_sp != 0) {
    tmp___3 = 8;
  } else {
    tmp___3 = 0;
  }
  {
  do_shell(cmd, tmp___3);
  tmp___4 = qf_init(name___1, errorformat);
  }
  if (tmp___4 > 0) {
    {
    qf_jump(0, 0, 0);
    }
  }
  {
  unlink((char const   *)((char *)name___1));
  vim_free((void *)name___1);
  vim_free((void *)cmd);
  }
  return;
}
}
static int start  =    -1;
static int off  =    0;
static char_u *get_mef_name(int newname ) 
{ 
  char_u *p___0 ;
  char_u *name___1 ;
  char_u *tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;

  {
  if ((int )*p_mef == 0) {
    {
    emsg((char_u *)"makeef option not set");
    }
    return ((char_u *)((void *)0));
  }
  p___0 = p_mef;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == 35) {
      if ((int )*(p___0 + 1) == 35) {
        goto while_break;
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*p___0 == 0) {
    {
    tmp = vim_strsave(p_mef);
    }
    return (tmp);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (newname) {
      if (start == -1) {
        {
        tmp___0 = mch_get_pid();
        start = (int )tmp___0;
        }
      }
      off ++;
    }
    {
    tmp___1 = strlen((char const   *)((char *)p_mef));
    name___1 = alloc((unsigned int )tmp___1 + 30U);
    }
    if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
      goto while_break___0;
    }
    {
    strcpy((char * __restrict  )((char *)name___1), (char const   * __restrict  )((char *)p_mef));
    sprintf((char * __restrict  )((char *)name___1 + (p___0 - p_mef)), (char const   * __restrict  )"%d%d",
            start, off);
    strcat((char * __restrict  )((char *)name___1), (char const   * __restrict  )((char *)(p___0 + 2)));
    }
    if (! newname) {
      goto while_break___0;
    } else {
      {
      tmp___2 = mch_getperm(name___1);
      }
      if (tmp___2 < 0L) {
        goto while_break___0;
      }
    }
    {
    vim_free((void *)name___1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return (name___1);
}
}
static void do_cfile(EXARG *eap ) 
{ 
  int tmp ;

  {
  if ((int )*(eap->arg) != 0) {
    {
    set_string_option_direct((char_u *)"ef", -1, eap->arg, 1);
    }
  }
  {
  tmp = qf_init(p_ef, p_efm);
  }
  if (tmp > 0) {
    {
    qf_jump(0, 0, eap->forceit);
    }
  }
  return;
}
}
static int do_arglist(char_u *str___1 ) 
{ 
  int new_count ;
  char_u **new_files ;
  int exp_count ;
  char_u **exp_files ;
  char_u **t ;
  char_u *p___0 ;
  int inquote ;
  int inbacktick ;
  int i___0 ;
  WIN *win ;
  char_u *tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  new_count = 0;
  new_files = (char_u **)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *str___1) {
      goto while_break;
    }
    {
    tmp = lalloc(sizeof(char_u *) * (unsigned long )(new_count + 1), 1);
    t = (char_u **)tmp;
    }
    if ((unsigned long )t != (unsigned long )((void *)0)) {
      i___0 = new_count;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        i___0 --;
        if (! (i___0 >= 0)) {
          goto while_break___0;
        }
        *(t + i___0) = *(new_files + i___0);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    vim_free((void *)new_files);
    }
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      return (0);
    }
    new_files = t;
    tmp___0 = new_count;
    new_count ++;
    *(new_files + tmp___0) = str___1;
    inquote = 0;
    inbacktick = 0;
    p___0 = str___1;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! *str___1) {
        goto while_break___1;
      }
      {
      tmp___4 = rem_backslash(str___1);
      }
      if (tmp___4) {
        tmp___1 = p___0;
        p___0 ++;
        str___1 ++;
        *tmp___1 = *str___1;
      } else {
        if (! inquote) {
          if (! inbacktick) {
            {
            tmp___2 = vim_isspace((int )*str___1);
            }
            if (tmp___2) {
              goto while_break___1;
            }
          }
        }
        if (! inquote) {
          if ((int )*str___1 == 96) {
            inbacktick ^= 1;
          }
        }
        if (! inbacktick) {
          if ((int )*str___1 == 34) {
            inquote ^= 1;
          } else {
            tmp___3 = p___0;
            p___0 ++;
            *tmp___3 = *str___1;
          }
        } else {
          tmp___3 = p___0;
          p___0 ++;
          *tmp___3 = *str___1;
        }
      }
      str___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    str___1 = skipwhite(str___1);
    *p___0 = (char_u )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  i___0 = expand_wildcards(new_count, new_files, & exp_count, & exp_files, 15);
  vim_free((void *)new_files);
  }
  if (i___0 == 0) {
    return (0);
  }
  if (exp_count == 0) {
    {
    emsg(e_nomatch);
    }
    return (0);
  }
  {
  FreeWild(arg_file_count, arg_files);
  arg_files = exp_files;
  arg_file_count = exp_count;
  arg_had_last = 0;
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (i___0 < arg_file_count)) {
      goto while_break___2;
    }
    {
    buflist_add(*(arg_files + i___0));
    i___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  win = firstwin;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break___3;
    }
    {
    check_arg_idx(win);
    win = win->w_next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  return (1);
}
}
void check_arg_idx(WIN *win ) 
{ 
  int tmp ;

  {
  if (arg_file_count > 1) {
    if ((unsigned long )(win->w_buffer)->b_ffname == (unsigned long )((void *)0)) {
      win->w_arg_idx_invalid = 1;
    } else { //Added block
    if (win->w_arg_idx >= arg_file_count) {
      win->w_arg_idx_invalid = 1;
    } else {
      {
      tmp = fullpathcmp(*(arg_files + win->w_arg_idx), (win->w_buffer)->b_ffname,
                        1);
      }
      if (tmp & 1) {
        win->w_arg_idx_invalid = 0;
      } else {
        win->w_arg_idx_invalid = 1;
      }
    }
    }
  } else {
    win->w_arg_idx_invalid = 0;
  }
  return;
}
}
int ends_excmd(int c ) 
{ 
  int tmp ;

  {
  if (c == 0) {
    tmp = 1;
  } else { //Added block
  if (c == 124) {
    tmp = 1;
  } else { //Added block
  if (c == 34) {
    tmp = 1;
  } else { //Added block
  if (c == 10) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  }
  return (tmp);
}
}
char_u *find_nextcmd(char_u *p___0 ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*p___0 != 124) {
      if (! ((int )*p___0 != 10)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 0) {
      return ((char_u *)((void *)0));
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0 + 1);
}
}
char_u *check_nextcmd(char_u *p___0 ) 
{ 


  {
  {
  p___0 = skipwhite(p___0);
  }
  if ((int )*p___0 == 124) {
    return (p___0 + 1);
  } else { //Added block
  if ((int )*p___0 == 10) {
    return (p___0 + 1);
  } else {
    return ((char_u *)((void *)0));
  }
  }
}
}
static int check_more(int message , int forceit ) 
{ 
  int n ;
  char_u buff[1025] ;
  int tmp ;
  int tmp___0 ;

  {
  n = (arg_file_count - curwin->w_arg_idx) - 1;
  if (! forceit) {
    {
    tmp___0 = only_one_window();
    }
    if (tmp___0) {
      if (arg_file_count > 1) {
        if (! arg_had_last) {
          if (n >= 0) {
            if (quitmore == 0) {
              if (message) {
                if (p_confirm) {
                  goto _L;
                } else { //Added block
                if (confirm) {
                  _L: 
                  if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
                    {
                    sprintf((char * __restrict  )((char *)(buff)), (char const   * __restrict  )"%d more files to edit.  Quit anyway?",
                            n);
                    tmp = vim_dialog_yesno(4, (char_u *)((void *)0), buff, 1);
                    }
                    if (tmp == 2) {
                      return (1);
                    }
                    return (0);
                  }
                }
                }
                {
                emsgn((char_u *)"%ld more files to edit", (long )n);
                quitmore = 2;
                }
              }
              return (0);
            }
          }
        }
      }
    }
  }
  return (1);
}
}
static char_u *get_one_sourceline(struct source_cookie *sp ) ;
int do_source(char_u *fname , int check_other , int is_vimrc ) 
{ 
  struct source_cookie cookie ;
  char_u *save_sourcing_name ;
  linenr_t save_sourcing_lnum ;
  char_u *p___0 ;
  char_u *fname_exp ;
  int retval ;
  void *save_funccalp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  retval = 0;
  fname_exp = expand_env_save(fname);
  }
  if ((unsigned long )fname_exp == (unsigned long )((void *)0)) {
    goto theend;
  }
  {
  cookie.fp = fopen((char const   * __restrict  )((char *)fname_exp), (char const   * __restrict  )"r");
  }
  if ((unsigned long )cookie.fp == (unsigned long )((void *)0)) {
    if (check_other) {
      {
      p___0 = gettail(fname_exp);
      }
      if ((int )*p___0 == 46) {
        goto _L___0;
      } else { //Added block
      if ((int )*p___0 == 95) {
        _L___0: 
        {
        tmp = strcasecmp((char const   *)((char *)(p___0 + 1)), (char const   *)((char *)"vimrc"));
        }
        if (tmp == 0) {
          goto _L;
        } else {
          {
          tmp___0 = strcasecmp((char const   *)((char *)(p___0 + 1)), (char const   *)((char *)"gvimrc"));
          }
          if (tmp___0 == 0) {
            goto _L;
          } else {
            {
            tmp___1 = strcasecmp((char const   *)((char *)(p___0 + 1)), (char const   *)((char *)"exrc"));
            }
            if (tmp___1 == 0) {
              _L: 
              if ((int )*p___0 == 95) {
                *p___0 = (char_u )'.';
              } else {
                *p___0 = (char_u )'_';
              }
              {
              cookie.fp = fopen((char const   * __restrict  )((char *)fname_exp),
                                (char const   * __restrict  )"r");
              }
            }
          }
        }
      }
      }
    }
  }
  if ((unsigned long )cookie.fp == (unsigned long )((void *)0)) {
    if (p_verbose > 0L) {
      {
      smsg((char_u *)"could not source \"%s\"", fname);
      }
    }
    goto theend;
  }
  if (p_verbose > 0L) {
    {
    smsg((char_u *)"sourcing \"%s\"", fname);
    }
  }
  if (is_vimrc) {
    {
    vimrc_found();
    }
  }
  {
  cookie.nextline = (char_u *)((void *)0);
  save_sourcing_name = sourcing_name;
  save_sourcing_lnum = sourcing_lnum;
  sourcing_name = fname_exp;
  sourcing_lnum = (linenr_t )0;
  save_funccalp = save_funccal();
  do_cmdline((char_u *)((void *)0), & getsourceline, (void *)(& cookie), 7);
  retval = 1;
  fclose(cookie.fp);
  vim_free((void *)cookie.nextline);
  }
  if (got_int) {
    {
    emsg(e_interr);
    }
  }
  {
  sourcing_name = save_sourcing_name;
  sourcing_lnum = save_sourcing_lnum;
  restore_funccal(save_funccalp);
  }
  if (p_verbose > 0L) {
    {
    smsg((char_u *)"finished sourcing \"%s\"", fname);
    }
  }
  theend: 
  {
  vim_free((void *)fname_exp);
  }
  return (retval);
}
}
char_u *getsourceline(int c , void *cookie , int indent ) 
{ 
  struct source_cookie *sp ;
  char_u *line ;
  char_u *p___0 ;
  char_u *s ;
  size_t tmp ;
  size_t tmp___0 ;
  char_u *tmp___1 ;

  {
  sp = (struct source_cookie *)cookie;
  if ((unsigned long )sp->nextline == (unsigned long )((void *)0)) {
    {
    line = get_one_sourceline(sp);
    }
  } else {
    line = sp->nextline;
    sp->nextline = (char_u *)((void *)0);
    sourcing_lnum ++;
  }
  if ((unsigned long )line != (unsigned long )((void *)0)) {
    {
    tmp___1 = vim_strchr(p_cpo, 'C');
    }
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      sourcing_lnum --;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        sp->nextline = get_one_sourceline(sp);
        }
        if ((unsigned long )sp->nextline == (unsigned long )((void *)0)) {
          goto while_break;
        }
        {
        p___0 = skipwhite(sp->nextline);
        }
        if ((int )*p___0 != 92) {
          goto while_break;
        }
        {
        tmp = strlen((char const   *)((char *)line));
        tmp___0 = strlen((char const   *)((char *)p___0));
        s = alloc((unsigned int )((int )(tmp + tmp___0)));
        }
        if ((unsigned long )s == (unsigned long )((void *)0)) {
          goto while_break;
        }
        {
        strcpy((char * __restrict  )((char *)s), (char const   * __restrict  )((char *)line));
        strcat((char * __restrict  )((char *)s), (char const   * __restrict  )((char *)(p___0 + 1)));
        vim_free((void *)line);
        line = s;
        vim_free((void *)sp->nextline);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return (line);
}
}
static char_u *get_one_sourceline(struct source_cookie *sp ) 
{ 
  struct growarray ga ;
  int len___0 ;
  int c ;
  char_u *buf___3 ;
  int have_read ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
  have_read = 0;
  ga_init2(& ga, 1, 200);
  sourcing_lnum ++;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = ga_grow(& ga, 80);
    }
    if (tmp == 0) {
      goto while_break;
    }
    {
    buf___3 = (char_u *)ga.ga_data;
    tmp___0 = fgets((char * __restrict  )((char *)buf___3 + ga.ga_len), ga.ga_room,
                    (FILE * __restrict  )sp->fp);
    }
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      goto while_break;
    } else { //Added block
    if (got_int) {
      goto while_break;
    }
    }
    {
    tmp___1 = strlen((char const   *)((char *)buf___3));
    len___0 = (int )tmp___1;
    have_read = 1;
    ga.ga_room -= len___0 - ga.ga_len;
    ga.ga_len = len___0;
    }
    if (ga.ga_room == 1) {
      if ((int )*(buf___3 + (len___0 - 1)) != 10) {
        goto __Cont;
      }
    }
    if (len___0 >= 1) {
      if ((int )*(buf___3 + (len___0 - 1)) == 10) {
        c = len___0 - 2;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (c >= 0) {
            if (! ((int )*(buf___3 + c) == 22)) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
          c --;
        }
        while_break___0: /* CIL Label */ ;
        }
        if ((len___0 & 1) != (c & 1)) {
          sourcing_lnum ++;
          goto __Cont;
        }
        *(buf___3 + (len___0 - 1)) = (char_u )'\000';
      }
    }
    {
    line_breakcheck();
    }
    goto while_break;
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  if (have_read) {
    return ((char_u *)ga.ga_data);
  }
  {
  vim_free(ga.ga_data);
  }
  return ((char_u *)((void *)0));
}
}
char_u *get_command_name(int idx ) 
{ 
  char_u *tmp ;

  {
  if (idx >= 299) {
    {
    tmp = get_user_command_name(idx);
    }
    return (tmp);
  }
  return (cmdnames[idx].cmd_name);
}
}
static int uc_add_command(char_u *name___1 , size_t name_len , char_u *rep , long argt ,
                          long def , int compl , int force ) ;
static void uc_list(char_u *name___1 , size_t name_len ) ;
static int uc_scan_attr(char_u *attr , size_t len___0 , long *argt , long *def , int *compl ) ;
static char_u *uc_split_args(char_u *arg , size_t *lenp ) ;
static size_t uc_check_code(char_u *code , size_t len___0 , char_u *buf___3 , UCMD *cmd ,
                            EXARG *eap , char_u **split_buf , size_t *split_len ) ;
static int uc_add_command(char_u *name___1 , size_t name_len , char_u *rep , long argt ,
                          long def , int compl , int force ) 
{ 
  UCMD *cmd ;
  char_u *p___0 ;
  int i___0 ;
  int cmp ;
  char_u *rep_buf ;
  size_t len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  cmp = 1;
  rep_buf = (char_u *)((void *)0);
  replace_termcodes(rep, & rep_buf, 0, 0);
  }
  if ((unsigned long )rep_buf == (unsigned long )((void *)0)) {
    {
    rep_buf = vim_strsave(rep);
    }
    if ((unsigned long )rep_buf == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  cmd = (UCMD *)ucmds.ga_data + 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < ucmds.ga_len)) {
      goto while_break;
    }
    {
    tmp = strlen((char const   *)((char *)cmd->uc_name));
    len___0 = tmp;
    cmp = strncmp((char const   *)((char *)name___1), (char const   *)((char *)cmd->uc_name),
                  name_len);
    }
    if (cmp == 0) {
      if (name_len < len___0) {
        cmp = -1;
      } else { //Added block
      if (name_len > len___0) {
        cmp = 1;
      }
      }
    }
    if (cmp == 0) {
      if (! force) {
        {
        emsg((char_u *)"Command already exists: use ! to redefine");
        }
        goto fail;
      }
      {
      vim_free((void *)cmd->uc_rep);
      cmd->uc_rep = (char_u *)0;
      }
      goto while_break;
    }
    if (cmp < 0) {
      goto while_break;
    }
    cmd ++;
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (cmp != 0) {
    {
    tmp___0 = ga_grow(& ucmds, 1);
    }
    if (tmp___0 != 1) {
      goto fail;
    }
    {
    p___0 = vim_strnsave(name___1, (int )name_len);
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      goto fail;
    }
    {
    cmd = (UCMD *)ucmds.ga_data + i___0;
    memmove((void *)((char *)(cmd + 1)), (void const   *)((char *)cmd), (unsigned long )(ucmds.ga_len - i___0) * sizeof(UCMD ));
    (ucmds.ga_len) ++;
    (ucmds.ga_room) --;
    cmd->uc_name = p___0;
    }
  }
  cmd->uc_rep = rep_buf;
  cmd->uc_argt = argt;
  cmd->uc_def = def;
  cmd->uc_compl = compl;
  return (1);
  fail: 
  {
  vim_free((void *)rep_buf);
  }
  return (0);
}
}
static void uc_list(char_u *name___1 , size_t name_len ) 
{ 
  int i___0 ;
  int found ;
  char *s ;
  UCMD *cmd ;
  int len___0 ;
  long a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;

  {
  found = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < ucmds.ga_len)) {
      goto while_break;
    }
    {
    cmd = (UCMD *)ucmds.ga_data + i___0;
    a = cmd->uc_argt;
    tmp = strncmp((char const   *)((char *)name___1), (char const   *)((char *)cmd->uc_name),
                  name_len);
    }
    if (tmp != 0) {
      goto __Cont;
    }
    if (! found) {
      {
      msg_puts_title((char_u *)"\n   Name        Args Range Complete  Definition");
      }
    }
    {
    found = 1;
    msg_putchar('\n');
    }
    if (a & 2L) {
      tmp___0 = '!';
    } else {
      tmp___0 = ' ';
    }
    {
    msg_putchar(tmp___0);
    }
    if (a & 512L) {
      tmp___1 = '\"';
    } else {
      tmp___1 = ' ';
    }
    {
    msg_putchar(tmp___1);
    msg_putchar(' ');
    msg_outtrans_attr(cmd->uc_name, highlight_attr[2]);
    tmp___2 = strlen((char const   *)((char *)cmd->uc_name));
    len___0 = (int )(tmp___2 + 3UL);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      msg_putchar(' ');
      len___0 ++;
      }
      if (! (len___0 < 15)) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    len___0 = 0;
    {
    if ((int )(a & 148L) == 0) {
      goto case_0;
    }
    if ((int )(a & 148L) == 4) {
      goto case_4;
    }
    if ((int )(a & 148L) == 20) {
      goto case_20;
    }
    if ((int )(a & 148L) == 132) {
      goto case_132;
    }
    if ((int )(a & 148L) == 148) {
      goto case_148;
    }
    goto switch_break;
    case_0: /* CIL Label */ 
    tmp___3 = len___0;
    len___0 ++;
    *(IObuff + tmp___3) = (char_u )'0';
    goto switch_break;
    case_4: /* CIL Label */ 
    tmp___4 = len___0;
    len___0 ++;
    *(IObuff + tmp___4) = (char_u )'*';
    goto switch_break;
    case_20: /* CIL Label */ 
    tmp___5 = len___0;
    len___0 ++;
    *(IObuff + tmp___5) = (char_u )'?';
    goto switch_break;
    case_132: /* CIL Label */ 
    tmp___6 = len___0;
    len___0 ++;
    *(IObuff + tmp___6) = (char_u )'+';
    goto switch_break;
    case_148: /* CIL Label */ 
    tmp___7 = len___0;
    len___0 ++;
    *(IObuff + tmp___7) = (char_u )'1';
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      tmp___8 = len___0;
      len___0 ++;
      *(IObuff + tmp___8) = (char_u )' ';
      if (! (len___0 < 5)) {
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    if (a & 1025L) {
      if (a & 1024L) {
        {
        sprintf((char * __restrict  )((char *)IObuff + len___0), (char const   * __restrict  )"%ldc",
                cmd->uc_def);
        tmp___9 = strlen((char const   *)((char *)(IObuff + len___0)));
        len___0 = (int )((size_t )len___0 + tmp___9);
        }
      } else { //Added block
      if (a & 32L) {
        tmp___10 = len___0;
        len___0 ++;
        *(IObuff + tmp___10) = (char_u )'%';
      } else { //Added block
      if (cmd->uc_def >= 0L) {
        {
        sprintf((char * __restrict  )((char *)IObuff + len___0), (char const   * __restrict  )"%ld",
                cmd->uc_def);
        tmp___11 = strlen((char const   *)((char *)(IObuff + len___0)));
        len___0 = (int )((size_t )len___0 + tmp___11);
        }
      } else {
        tmp___12 = len___0;
        len___0 ++;
        *(IObuff + tmp___12) = (char_u )'.';
      }
      }
      }
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      tmp___13 = len___0;
      len___0 ++;
      *(IObuff + tmp___13) = (char_u )' ';
      if (! (len___0 < 11)) {
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    if (cmd->uc_compl == 14) {
      goto case_14;
    }
    if (cmd->uc_compl == 9) {
      goto case_9;
    }
    if (cmd->uc_compl == 1) {
      goto case_1;
    }
    if (cmd->uc_compl == 3) {
      goto case_3;
    }
    if (cmd->uc_compl == 10) {
      goto case_10;
    }
    if (cmd->uc_compl == 2) {
      goto case_2;
    }
    if (cmd->uc_compl == 8) {
      goto case_8;
    }
    if (cmd->uc_compl == 13) {
      goto case_13;
    }
    if (cmd->uc_compl == 11) {
      goto case_11;
    }
    if (cmd->uc_compl == 4) {
      goto case_4___0;
    }
    if (cmd->uc_compl == 6) {
      goto case_6;
    }
    if (cmd->uc_compl == 17) {
      goto case_17;
    }
    if (cmd->uc_compl == 15) {
      goto case_15;
    }
    goto switch_default;
    case_14: /* CIL Label */ 
    s = (char *)"augroup";
    goto switch_break___0;
    case_9: /* CIL Label */ 
    s = (char *)"buffer";
    goto switch_break___0;
    case_1: /* CIL Label */ 
    s = (char *)"command";
    goto switch_break___0;
    case_3: /* CIL Label */ 
    s = (char *)"dir";
    goto switch_break___0;
    case_10: /* CIL Label */ 
    s = (char *)"event";
    goto switch_break___0;
    case_2: /* CIL Label */ 
    s = (char *)"file";
    goto switch_break___0;
    case_8: /* CIL Label */ 
    s = (char *)"help";
    goto switch_break___0;
    case_13: /* CIL Label */ 
    s = (char *)"highlight";
    goto switch_break___0;
    case_11: /* CIL Label */ 
    s = (char *)"menu";
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    s = (char *)"option";
    goto switch_break___0;
    case_6: /* CIL Label */ 
    s = (char *)"tag";
    goto switch_break___0;
    case_17: /* CIL Label */ 
    s = (char *)"tag_listfiles";
    goto switch_break___0;
    case_15: /* CIL Label */ 
    s = (char *)"var";
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    s = (char *)((void *)0);
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )((char *)(IObuff + len___0)), (char const   * __restrict  )s);
      tmp___14 = strlen((char const   *)s);
      len___0 = (int )((size_t )len___0 + tmp___14);
      }
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      tmp___15 = len___0;
      len___0 ++;
      *(IObuff + tmp___15) = (char_u )' ';
      if (! (len___0 < 21)) {
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    *(IObuff + len___0) = (char_u )'\000';
    msg_outtrans(IObuff);
    msg_outtrans(cmd->uc_rep);
    out_flush();
    ui_breakcheck();
    }
    __Cont: 
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (! found) {
    {
    msg((char_u *)"No user-defined commands found");
    }
  }
  return;
}
}
static int uc_scan_attr(char_u *attr , size_t len___0 , long *argt , long *def , int *compl ) 
{ 
  char_u *p___0 ;
  size_t i___0 ;
  char_u *val ;
  size_t vallen ;
  size_t attrlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char_u ch ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  if (len___0 == 0UL) {
    {
    emsg((char_u *)"No attribute specified");
    }
    return (0);
  }
  {
  tmp___18 = strncasecmp((char const   *)((char *)attr), (char const   *)((char *)"bang"),
                         len___0);
  }
  if (tmp___18 == 0) {
    *argt |= 2L;
  } else {
    {
    tmp___17 = strncasecmp((char const   *)((char *)attr), (char const   *)((char *)"register"),
                           len___0);
    }
    if (tmp___17 == 0) {
      *argt |= 512L;
    } else {
      val = (char_u *)((void *)0);
      vallen = (size_t )0;
      attrlen = len___0;
      i___0 = (size_t )0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < len___0)) {
          goto while_break;
        }
        if ((int )*(attr + i___0) == 61) {
          val = attr + (i___0 + 1UL);
          vallen = (len___0 - i___0) - 1UL;
          attrlen = i___0;
          goto while_break;
        }
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
      tmp___16 = strncasecmp((char const   *)((char *)attr), (char const   *)((char *)"nargs"),
                             attrlen);
      }
      if (tmp___16 == 0) {
        if (vallen == 1UL) {
          if (! ((int )*val == 48)) {
            if ((int )*val == 49) {
              *argt |= 148L;
            } else { //Added block
            if ((int )*val == 42) {
              *argt |= 4L;
            } else { //Added block
            if ((int )*val == 63) {
              *argt |= 20L;
            } else { //Added block
            if ((int )*val == 43) {
              *argt |= 132L;
            } else {
              goto wrong_nargs;
            }
            }
            }
            }
          }
        } else {
          wrong_nargs: 
          {
          emsg((char_u *)"Invalid number of arguments");
          }
          return (0);
        }
      } else {
        {
        tmp___15 = strncasecmp((char const   *)((char *)attr), (char const   *)((char *)"range"),
                               attrlen);
        }
        if (tmp___15 == 0) {
          *argt |= 1L;
          if (vallen == 1UL) {
            if ((int )*val == 37) {
              *argt |= 32L;
            } else {
              goto _L;
            }
          } else { //Added block
          _L: 
          if ((unsigned long )val != (unsigned long )((void *)0)) {
            p___0 = val;
            if (*def >= 0L) {
              two_count: 
              {
              emsg((char_u *)"Count cannot be specified twice");
              }
              return (0);
            }
            {
            *def = getdigits(& p___0);
            *argt |= 20480L;
            }
            if ((unsigned long )p___0 != (unsigned long )(val + vallen)) {
              invalid_count: 
              {
              emsg((char_u *)"Invalid default value for count");
              }
              return (0);
            }
          }
          }
        } else {
          {
          tmp___14 = strncasecmp((char const   *)((char *)attr), (char const   *)((char *)"count"),
                                 attrlen);
          }
          if (tmp___14 == 0) {
            *argt |= 21504L;
            if ((unsigned long )val != (unsigned long )((void *)0)) {
              p___0 = val;
              if (*def >= 0L) {
                goto two_count;
              }
              {
              *def = getdigits(& p___0);
              }
              if ((unsigned long )p___0 != (unsigned long )(val + vallen)) {
                goto invalid_count;
              }
            }
            if (*def < 0L) {
              *def = 0L;
            }
          } else {
            {
            tmp___13 = strncasecmp((char const   *)((char *)attr), (char const   *)((char *)"complete"),
                                   attrlen);
            }
            if (tmp___13 == 0) {
              if ((unsigned long )val == (unsigned long )((void *)0)) {
                {
                emsg((char_u *)"argument required for complete");
                }
                return (0);
              }
              {
              tmp___12 = strncmp((char const   *)((char *)val), (char const   *)((char *)"augroup"),
                                 vallen);
              }
              if (tmp___12 == 0) {
                *compl = 14;
              } else {
                {
                tmp___11 = strncasecmp((char const   *)((char *)val), (char const   *)((char *)"buffer"),
                                       vallen);
                }
                if (tmp___11 == 0) {
                  *argt |= 65536L;
                  *compl = 9;
                } else {
                  {
                  tmp___10 = strncmp((char const   *)((char *)val), (char const   *)((char *)"command"),
                                     vallen);
                  }
                  if (tmp___10 == 0) {
                    *compl = 1;
                  } else {
                    {
                    tmp___9 = strncmp((char const   *)((char *)val), (char const   *)((char *)"dir"),
                                      vallen);
                    }
                    if (tmp___9 == 0) {
                      *argt |= 8L;
                      *compl = 3;
                    } else {
                      {
                      tmp___8 = strncmp((char const   *)((char *)val), (char const   *)((char *)"event"),
                                        vallen);
                      }
                      if (tmp___8 == 0) {
                        *compl = 10;
                      } else {
                        {
                        tmp___7 = strncmp((char const   *)((char *)val), (char const   *)((char *)"expression"),
                                          vallen);
                        }
                        if (tmp___7 == 0) {
                          *compl = 20;
                        } else {
                          {
                          tmp___6 = strncasecmp((char const   *)((char *)val), (char const   *)((char *)"file"),
                                                vallen);
                          }
                          if (tmp___6 == 0) {
                            *argt |= 8L;
                            *compl = 2;
                          } else {
                            {
                            tmp___5 = strncmp((char const   *)((char *)val), (char const   *)((char *)"help"),
                                              vallen);
                            }
                            if (tmp___5 == 0) {
                              *compl = 8;
                            } else {
                              {
                              tmp___4 = strncmp((char const   *)((char *)val), (char const   *)((char *)"highlight"),
                                                vallen);
                              }
                              if (tmp___4 == 0) {
                                *compl = 13;
                              } else {
                                {
                                tmp___3 = strncmp((char const   *)((char *)val), (char const   *)((char *)"menu"),
                                                  vallen);
                                }
                                if (tmp___3 == 0) {
                                  *compl = 11;
                                } else {
                                  {
                                  tmp___2 = strncmp((char const   *)((char *)val),
                                                    (char const   *)((char *)"option"),
                                                    vallen);
                                  }
                                  if (tmp___2 == 0) {
                                    *compl = 4;
                                  } else {
                                    {
                                    tmp___1 = strncmp((char const   *)((char *)val),
                                                      (char const   *)((char *)"tag"),
                                                      vallen);
                                    }
                                    if (tmp___1 == 0) {
                                      *compl = 6;
                                    } else {
                                      {
                                      tmp___0 = strncmp((char const   *)((char *)val),
                                                        (char const   *)((char *)"tag_listfiles"),
                                                        vallen);
                                      }
                                      if (tmp___0 == 0) {
                                        *compl = 17;
                                      } else {
                                        {
                                        tmp = strncmp((char const   *)((char *)val),
                                                      (char const   *)((char *)"var"),
                                                      vallen);
                                        }
                                        if (tmp == 0) {
                                          *compl = 15;
                                        } else {
                                          {
                                          emsg2((char_u *)"Invalid complete value: %s",
                                                val);
                                          }
                                          return (0);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              {
              ch = *(attr + len___0);
              *(attr + len___0) = (char_u )'\000';
              emsg2((char_u *)"Invalid attribute: %s", attr);
              *(attr + len___0) = ch;
              }
              return (0);
            }
          }
        }
      }
    }
  }
  return (1);
}
}
static void do_command(EXARG *eap ) 
{ 
  char_u *name___1 ;
  char_u *end ;
  char_u *p___0 ;
  long argt ;
  long def ;
  int compl ;
  int has_attr ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  argt = 0L;
  def = -1L;
  compl = 0;
  has_attr = (int )*(eap->arg + 0) == 45;
  p___0 = eap->arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*p___0 == 45)) {
      goto while_break;
    }
    {
    p___0 ++;
    end = skiptowhite(p___0);
    tmp = uc_scan_attr(p___0, (size_t )(end - p___0), & argt, & def, & compl);
    }
    if (tmp == 0) {
      return;
    }
    {
    p___0 = skipwhite(end);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  name___1 = p___0;
  tmp___1 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___1 + (int )*p___0) & 1024) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___0 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___0 + (int )*p___0) & 8)) {
        goto while_break___0;
      }
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  tmp___2 = ends_excmd((int )*p___0);
  }
  if (! tmp___2) {
    if (! ((int )*p___0 == 32)) {
      if (! ((int )*p___0 == 9)) {
        {
        emsg((char_u *)"Invalid command name");
        }
        return;
      }
    }
  }
  {
  end = p___0;
  p___0 = skipwhite(end);
  }
  if (! has_attr) {
    {
    tmp___3 = ends_excmd((int )*p___0);
    }
    if (tmp___3) {
      {
      uc_list(name___1, (size_t )(end - name___1));
      }
      return;
    }
  }
  {
  tmp___4 = __ctype_b_loc();
  }
  if (! ((int const   )*(*tmp___4 + (int )*name___1) & 256)) {
    {
    emsg((char_u *)"User defined commands must start with an uppercase letter");
    }
    return;
  }
  {
  uc_add_command(name___1, (size_t )(end - name___1), p___0, argt, def, compl, eap->forceit);
  }
  return;
}
}
static void do_comclear(void) 
{ 
  int i___0 ;
  UCMD *cmd ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < ucmds.ga_len)) {
      goto while_break;
    }
    {
    cmd = (UCMD *)ucmds.ga_data + i___0;
    vim_free((void *)cmd->uc_name);
    vim_free((void *)cmd->uc_rep);
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  ga_clear(& ucmds);
  }
  return;
}
}
static void do_delcommand(EXARG *eap ) 
{ 
  int i___0 ;
  UCMD *cmd ;
  int cmp ;

  {
  i___0 = 0;
  cmd = (UCMD *)ucmds.ga_data + 0;
  cmp = -1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < ucmds.ga_len)) {
      goto while_break;
    }
    {
    cmp = strcmp((char const   *)((char *)eap->arg), (char const   *)((char *)cmd->uc_name));
    }
    if (cmp <= 0) {
      goto while_break;
    }
    i___0 ++;
    cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (cmp != 0) {
    {
    emsg2((char_u *)"No such user-defined command: %s", eap->arg);
    }
    return;
  }
  {
  vim_free((void *)cmd->uc_name);
  vim_free((void *)cmd->uc_rep);
  (ucmds.ga_len) --;
  (ucmds.ga_room) ++;
  }
  if (i___0 < ucmds.ga_len) {
    {
    memmove((void *)((char *)cmd), (void const   *)((char *)(cmd + 1)), (unsigned long )(ucmds.ga_len - i___0) * sizeof(UCMD ));
    }
  }
  return;
}
}
static char_u *uc_split_args(char_u *arg , size_t *lenp ) 
{ 
  char_u *buf___3 ;
  char_u *p___0 ;
  char_u *q ;
  int len___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;

  {
  p___0 = arg;
  len___0 = 2;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == 92) {
      if ((int )*(p___0 + 1) == 32) {
        len___0 ++;
        p___0 += 2;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*p___0 == 92) {
      len___0 += 2;
      p___0 ++;
    } else { //Added block
    if ((int )*p___0 == 34) {
      len___0 += 2;
      p___0 ++;
    } else { //Added block
    if ((int )*p___0 == 32) {
      len___0 += 3;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((int )*p___0 == 32)) {
          goto while_break___0;
        }
        p___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      len___0 ++;
      p___0 ++;
    }
    }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  buf___3 = alloc((unsigned int )(len___0 + 1));
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    *lenp = (size_t )0;
    return (buf___3);
  }
  p___0 = arg;
  q = buf___3;
  tmp = q;
  q ++;
  *tmp = (char_u )'\"';
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break___1;
    }
    if ((int )*(p___0 + 0) == 92) {
      if ((int )*(p___0 + 1) == 32) {
        tmp___0 = q;
        q ++;
        *tmp___0 = *(p___0 + 1);
        p___0 += 2;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if ((int )*p___0 == 92) {
      goto _L___0;
    } else { //Added block
    if ((int )*p___0 == 34) {
      _L___0: 
      tmp___1 = q;
      q ++;
      *tmp___1 = (char_u )'\\';
      tmp___2 = q;
      q ++;
      tmp___3 = p___0;
      p___0 ++;
      *tmp___2 = *tmp___3;
    } else { //Added block
    if ((int )*p___0 == 32) {
      tmp___4 = q;
      q ++;
      *tmp___4 = (char_u )'\"';
      tmp___5 = q;
      q ++;
      *tmp___5 = (char_u )',';
      tmp___6 = q;
      q ++;
      *tmp___6 = (char_u )'\"';
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! ((int )*p___0 == 32)) {
          goto while_break___2;
        }
        p___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      tmp___7 = q;
      q ++;
      tmp___8 = p___0;
      p___0 ++;
      *tmp___7 = *tmp___8;
    }
    }
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  tmp___9 = q;
  q ++;
  *tmp___9 = (char_u )'\"';
  *q = (char_u )0;
  *lenp = (size_t )len___0;
  return (buf___3);
}
}
static size_t uc_check_code(char_u *code , size_t len___0 , char_u *buf___3 , UCMD *cmd ,
                            EXARG *eap , char_u **split_buf , size_t *split_len ) 
{ 
  size_t result___0 ;
  char_u *p___0 ;
  size_t l ;
  int quote ;
  enum __anonenum_type_169 type ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  char_u *tmp___12 ;
  char num_buf[20] ;
  long num ;
  linenr_t tmp___13 ;
  linenr_t tmp___14 ;
  linenr_t tmp___15 ;
  size_t num_len ;
  char_u *tmp___16 ;
  char_u *tmp___17 ;
  char_u *tmp___18 ;

  {
  {
  result___0 = (size_t )0;
  p___0 = code + 1;
  l = len___0 - 2UL;
  quote = 0;
  type = (enum __anonenum_type_169 )7;
  tmp = vim_strchr((char_u *)"qQfF", (int )*p___0);
  }
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    if ((int )*(p___0 + 1) == 45) {
      if ((int )*p___0 == 113) {
        quote = 1;
      } else { //Added block
      if ((int )*p___0 == 81) {
        quote = 1;
      } else {
        quote = 2;
      }
      }
      p___0 += 2;
      l -= 2UL;
    }
  }
  {
  tmp___6 = strncasecmp((char const   *)((char *)p___0), (char const   *)((char *)"args"),
                        l);
  }
  if (tmp___6 == 0) {
    type = (enum __anonenum_type_169 )0;
  } else {
    {
    tmp___5 = strncasecmp((char const   *)((char *)p___0), (char const   *)((char *)"bang"),
                          l);
    }
    if (tmp___5 == 0) {
      type = (enum __anonenum_type_169 )1;
    } else {
      {
      tmp___4 = strncasecmp((char const   *)((char *)p___0), (char const   *)((char *)"count"),
                            l);
      }
      if (tmp___4 == 0) {
        type = (enum __anonenum_type_169 )2;
      } else {
        {
        tmp___3 = strncasecmp((char const   *)((char *)p___0), (char const   *)((char *)"line1"),
                              l);
        }
        if (tmp___3 == 0) {
          type = (enum __anonenum_type_169 )3;
        } else {
          {
          tmp___2 = strncasecmp((char const   *)((char *)p___0), (char const   *)((char *)"line2"),
                                l);
          }
          if (tmp___2 == 0) {
            type = (enum __anonenum_type_169 )4;
          } else {
            {
            tmp___1 = strncasecmp((char const   *)((char *)p___0), (char const   *)((char *)"lt"),
                                  l);
            }
            if (tmp___1 == 0) {
              type = (enum __anonenum_type_169 )6;
            } else {
              {
              tmp___0 = strncasecmp((char const   *)((char *)p___0), (char const   *)((char *)"register"),
                                    l);
              }
              if (tmp___0 == 0) {
                type = (enum __anonenum_type_169 )5;
              }
            }
          }
        }
      }
    }
  }
  {
  if ((unsigned int )type == 0U) {
    goto case_0;
  }
  if ((unsigned int )type == 1U) {
    goto case_1___0;
  }
  if ((unsigned int )type == 3U) {
    goto case_3;
  }
  if ((unsigned int )type == 4U) {
    goto case_3;
  }
  if ((unsigned int )type == 2U) {
    goto case_3;
  }
  if ((unsigned int )type == 5U) {
    goto case_5;
  }
  if ((unsigned int )type == 6U) {
    goto case_6;
  }
  goto switch_default;
  case_0: /* CIL Label */ 
  if ((int )*(eap->arg) == 0) {
    if (quote == 1) {
      result___0 = (size_t )2;
      if (buf___3) {
        {
        strcpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)"\'\'"));
        }
      }
    } else {
      result___0 = (size_t )0;
    }
    goto switch_break;
  }
  {
  if (quote == 0) {
    goto case_0___0;
  }
  if (quote == 1) {
    goto case_1;
  }
  if (quote == 2) {
    goto case_2;
  }
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
  result___0 = strlen((char const   *)((char *)eap->arg));
  }
  if (buf___3) {
    {
    strcpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)eap->arg));
    }
  }
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
  tmp___7 = strlen((char const   *)((char *)eap->arg));
  result___0 = tmp___7 + 2UL;
  p___0 = eap->arg;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == 92) {
      result___0 ++;
    } else { //Added block
    if ((int )*p___0 == 34) {
      result___0 ++;
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (buf___3) {
    tmp___8 = buf___3;
    buf___3 ++;
    *tmp___8 = (char_u )'\"';
    p___0 = eap->arg;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break___0;
      }
      if ((int )*p___0 == 92) {
        tmp___9 = buf___3;
        buf___3 ++;
        *tmp___9 = (char_u )'\\';
      } else { //Added block
      if ((int )*p___0 == 34) {
        tmp___9 = buf___3;
        buf___3 ++;
        *tmp___9 = (char_u )'\\';
      }
      }
      tmp___10 = buf___3;
      buf___3 ++;
      *tmp___10 = *p___0;
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    *buf___3 = (char_u )'\"';
  }
  goto switch_break___0;
  case_2: /* CIL Label */ 
  if ((unsigned long )*split_buf == (unsigned long )((void *)0)) {
    {
    *split_buf = uc_split_args(eap->arg, split_len);
    }
  }
  result___0 = *split_len;
  if (buf___3) {
    if (result___0 != 0UL) {
      {
      strcpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)*split_buf));
      }
    }
  }
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  goto switch_break;
  case_1___0: /* CIL Label */ 
  if (eap->forceit) {
    result___0 = (size_t )1;
  } else {
    result___0 = (size_t )0;
  }
  if (quote) {
    result___0 += 2UL;
  }
  if (buf___3) {
    if (quote) {
      tmp___11 = buf___3;
      buf___3 ++;
      *tmp___11 = (char_u )'\"';
    }
    if (eap->forceit) {
      tmp___12 = buf___3;
      buf___3 ++;
      *tmp___12 = (char_u )'!';
    }
    if (quote) {
      *buf___3 = (char_u )'\"';
    }
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  if ((unsigned int )type == 3U) {
    tmp___15 = eap->line1;
  } else {
    if ((unsigned int )type == 4U) {
      tmp___14 = eap->line2;
    } else {
      if (eap->addr_count > 0) {
        tmp___13 = eap->line2;
      } else {
        tmp___13 = cmd->uc_def;
      }
      tmp___14 = tmp___13;
    }
    tmp___15 = tmp___14;
  }
  {
  num = tmp___15;
  sprintf((char * __restrict  )(num_buf), (char const   * __restrict  )"%ld", num);
  num_len = strlen((char const   *)(num_buf));
  result___0 = num_len;
  }
  if (quote) {
    result___0 += 2UL;
  }
  if (buf___3) {
    if (quote) {
      tmp___16 = buf___3;
      buf___3 ++;
      *tmp___16 = (char_u )'\"';
    }
    {
    strcpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )(num_buf));
    buf___3 += num_len;
    }
    if (quote) {
      *buf___3 = (char_u )'\"';
    }
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  if (eap->regname) {
    result___0 = (size_t )1;
  } else {
    result___0 = (size_t )0;
  }
  if (quote) {
    result___0 += 2UL;
  }
  if (buf___3) {
    if (quote) {
      tmp___17 = buf___3;
      buf___3 ++;
      *tmp___17 = (char_u )'\'';
    }
    if (eap->regname) {
      tmp___18 = buf___3;
      buf___3 ++;
      *tmp___18 = (char_u )eap->regname;
    }
    if (quote) {
      *buf___3 = (char_u )'\'';
    }
  }
  goto switch_break;
  case_6: /* CIL Label */ 
  result___0 = (size_t )1;
  if (buf___3) {
    *buf___3 = (char_u )'<';
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  result___0 = len___0;
  if (buf___3) {
    {
    strncpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)code),
            len___0);
    }
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (result___0);
}
}
static void do_ucmd(UCMD *cmd , EXARG *eap ) 
{ 
  char_u *buf___3 ;
  char_u *p___0 ;
  char_u *q ;
  char_u *start___0 ;
  char_u *end ;
  size_t len___0 ;
  size_t totlen ;
  size_t split_len ;
  char_u *split_buf ;
  size_t tmp ;

  {
  split_len = (size_t )0;
  split_buf = (char_u *)((void *)0);
  buf___3 = (char_u *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    p___0 = cmd->uc_rep;
    q = buf___3;
    totlen = (size_t )0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      start___0 = vim_strchr(p___0, '<');
      }
      if ((unsigned long )start___0 != (unsigned long )((void *)0)) {
        {
        end = vim_strchr(start___0 + 1, '>');
        }
        if (! ((unsigned long )end != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      end ++;
      len___0 = (size_t )(start___0 - p___0);
      if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
        totlen += len___0;
      } else {
        {
        memmove((void *)((char *)q), (void const   *)((char *)p___0), len___0);
        q += len___0;
        }
      }
      {
      len___0 = uc_check_code(start___0, (size_t )(end - start___0), q, cmd, eap,
                              & split_buf, & split_len);
      }
      if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
        totlen += len___0;
      } else {
        q += len___0;
      }
      p___0 = end;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )((char *)q), (char const   * __restrict  )((char *)p___0));
      }
      goto while_break;
    }
    {
    tmp = strlen((char const   *)((char *)p___0));
    totlen += tmp;
    buf___3 = alloc((unsigned int )(totlen + 1UL));
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      {
      vim_free((void *)split_buf);
      }
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  do_cmdline(buf___3, (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
             3);
  vim_free((void *)buf___3);
  vim_free((void *)split_buf);
  }
  return;
}
}
static char_u *get_user_command_name(int idx ) 
{ 
  int i___0 ;

  {
  i___0 = idx - 299;
  if (i___0 >= ucmds.ga_len) {
    return ((char_u *)((void *)0));
  }
  return (((UCMD *)ucmds.ga_data + i___0)->uc_name);
}
}
char_u *get_user_commands(int idx ) 
{ 


  {
  if (idx >= ucmds.ga_len) {
    return ((char_u *)((void *)0));
  }
  return (((UCMD *)ucmds.ga_data + idx)->uc_name);
}
}
static char *user_cmd_flags[6]  = {      (char *)"nargs",      (char *)"complete",      (char *)"range",      (char *)"count", 
        (char *)"bang",      (char *)"register"};
char_u *get_user_cmd_flags(int idx ) 
{ 


  {
  if ((unsigned long )idx >= sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0])) {
    return ((char_u *)((void *)0));
  }
  return ((char_u *)user_cmd_flags[idx]);
}
}
static char *user_cmd_nargs[5]  = {      (char *)"0",      (char *)"1",      (char *)"*",      (char *)"?", 
        (char *)"+"};
char_u *get_user_cmd_nargs(int idx ) 
{ 


  {
  if ((unsigned long )idx >= sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0])) {
    return ((char_u *)((void *)0));
  }
  return ((char_u *)user_cmd_nargs[idx]);
}
}
static char *user_cmd_complete[13]  = 
  {      (char *)"augroup",      (char *)"buffer",      (char *)"command",      (char *)"dir", 
        (char *)"event",      (char *)"file",      (char *)"help",      (char *)"highlight", 
        (char *)"menu",      (char *)"option",      (char *)"tag",      (char *)"tag_listfiles", 
        (char *)"var"};
char_u *get_user_cmd_complete(int idx ) 
{ 


  {
  if ((unsigned long )idx >= sizeof(user_cmd_complete) / sizeof(user_cmd_complete[0])) {
    return ((char_u *)((void *)0));
  }
  return ((char_u *)user_cmd_complete[idx]);
}
}
void not_exiting(void) 
{ 


  {
  {
  exiting = 0;
  settmode(2);
  }
  return;
}
}
static void do_quit(EXARG *eap ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  tmp = check_more(0, eap->forceit);
  }
  if (tmp == 1) {
    {
    tmp___0 = only_one_window();
    }
    if (tmp___0) {
      exiting = 1;
    }
  }
  if (! p_hid) {
    {
    tmp___3 = check_changed(curbuf, 0, 0, eap->forceit, 0);
    }
    if (tmp___3) {
      {
      not_exiting();
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    {
    tmp___4 = check_more(1, eap->forceit);
    }
    if (tmp___4 == 0) {
      {
      not_exiting();
      }
    } else {
      {
      tmp___5 = only_one_window();
      }
      if (tmp___5) {
        {
        tmp___6 = check_changed_any(eap->forceit);
        }
        if (tmp___6) {
          {
          not_exiting();
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
        {
        tmp___1 = only_one_window();
        }
        if (tmp___1) {
          {
          getout(0);
          }
        }
        if (! p_hid) {
          tmp___2 = 1;
        } else { //Added block
        if (eap->forceit) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
        }
        {
        close_window(curwin, tmp___2);
        }
      }
    }
  }
  return;
}
}
static void do_quit_all(int forceit ) 
{ 
  int tmp ;

  {
  exiting = 1;
  if (forceit) {
    {
    getout(0);
    }
  } else {
    {
    tmp = check_changed_any(0);
    }
    if (! tmp) {
      {
      getout(0);
      }
    }
  }
  {
  not_exiting();
  }
  return;
}
}
static void do_close(EXARG *eap , WIN *win ) 
{ 
  int need_hide ;
  BUF *buf___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  buf___3 = win->w_buffer;
  tmp = buf_changed(buf___3);
  }
  if (tmp) {
    if (buf___3->b_nwindows <= 1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  need_hide = tmp___0;
  if (need_hide) {
    if (! p_hid) {
      if (! eap->forceit) {
        if (p_confirm) {
          goto _L;
        } else { //Added block
        if (confirm) {
          _L: 
          if (p_write) {
            {
            dialog_changed(buf___3, 0);
            tmp___1 = buf_changed(buf___3);
            }
            if (tmp___1) {
              return;
            }
          } else {
            {
            emsg(e_nowrtmsg);
            }
            return;
          }
        } else {
          {
          emsg(e_nowrtmsg);
          }
          return;
        }
        }
      }
    }
  }
  if (! need_hide) {
    if (! p_hid) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  {
  close_window(win, tmp___2);
  }
  return;
}
}
static void do_pclose(EXARG *eap ) 
{ 
  WIN *win ;

  {
  win = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (win->w_preview) {
      {
      do_close(eap, win);
      }
      goto while_break;
    }
    win = win->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void do_suspend(int forceit ) 
{ 
  int tmp ;

  {
  {
  tmp = check_restricted();
  }
  if (! tmp) {
    if (! forceit) {
      {
      autowrite_all();
      }
    }
    {
    windgoto((int )Rows - 1, 0);
    out_char((unsigned int )'\n');
    out_flush();
    stoptermcap();
    out_flush();
    mch_restore_title(3);
    ui_suspend();
    maketitle();
    resettitle();
    starttermcap();
    scroll_start();
    must_redraw = 50;
    set_winsize(0, 0, 0);
    }
  }
  return;
}
}
static void do_exit(EXARG *eap ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  tmp = check_more(0, eap->forceit);
  }
  if (tmp == 1) {
    {
    tmp___0 = only_one_window();
    }
    if (tmp___0) {
      exiting = 1;
    }
  }
  if ((int )eap->cmdidx == 280) {
    goto _L___1;
  } else {
    {
    tmp___2 = curbuf_changed();
    }
    if (tmp___2) {
      _L___1: 
      {
      tmp___3 = do_write(eap);
      }
      if (tmp___3 == 0) {
        {
        not_exiting();
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      {
      tmp___4 = check_more(1, eap->forceit);
      }
      if (tmp___4 == 0) {
        {
        not_exiting();
        }
      } else {
        {
        tmp___5 = only_one_window();
        }
        if (tmp___5) {
          {
          tmp___6 = check_changed_any(eap->forceit);
          }
          if (tmp___6) {
            {
            not_exiting();
            }
          } else {
            goto _L;
          }
        } else {
          _L: 
          {
          tmp___1 = only_one_window();
          }
          if (tmp___1) {
            {
            getout(0);
            }
          }
          {
          close_window(curwin, ! p_hid);
          }
        }
      }
    }
  }
  return;
}
}
static void do_print(EXARG *eap ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! got_int)) {
      goto while_break;
    }
    if ((int )eap->cmdidx == 154) {
      tmp = 1;
    } else { //Added block
    if ((int )eap->cmdidx == 288) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
    {
    print_line(eap->line1, tmp);
    (eap->line1) ++;
    }
    if (eap->line1 > eap->line2) {
      goto while_break;
    }
    {
    out_flush();
    ui_breakcheck();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  setpcmark();
  curwin->w_cursor.lnum = eap->line2;
  beginline(6);
  ex_no_reprint = 1;
  }
  return;
}
}
void do_argfile(EXARG *eap , int argn ) 
{ 
  int other ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (argn < 0) {
    goto _L___0;
  } else { //Added block
  if (argn >= arg_file_count) {
    _L___0: 
    if (arg_file_count <= 1) {
      {
      emsg((char_u *)"There is only one file to edit");
      }
    } else { //Added block
    if (argn < 0) {
      {
      emsg((char_u *)"Cannot go before first file");
      }
    } else {
      {
      emsg((char_u *)"Cannot go beyond last file");
      }
    }
    }
  } else {
    {
    setpcmark();
    }
    if ((int )*(eap->cmd) == 115) {
      {
      tmp = win_split(0, 0, 0);
      }
      if (tmp == 0) {
        return;
      }
    } else {
      other = 1;
      if (p_hid) {
        {
        p___0 = fix_fname(*(arg_files + argn));
        other = otherfile(p___0);
        vim_free((void *)p___0);
        }
      }
      if (! p_hid) {
        goto _L;
      } else { //Added block
      if (! other) {
        _L: 
        {
        tmp___0 = check_changed(curbuf, 1, ! other, eap->forceit, 0);
        }
        if (tmp___0) {
          return;
        }
      }
      }
    }
    curwin->w_arg_idx = argn;
    if (argn == arg_file_count - 1) {
      arg_had_last = 1;
    }
    if (p_hid) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if (eap->forceit) {
      tmp___2 = 8;
    } else {
      tmp___2 = 0;
    }
    {
    do_ecmd(0, *(arg_files + curwin->w_arg_idx), (char_u *)((void *)0), eap->do_ecmd_cmd,
            (linenr_t )-1, tmp___1 + tmp___2);
    }
  }
  }
  return;
}
}
static void do_next(EXARG *eap ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if (p_hid) {
    goto _L;
  } else { //Added block
  if ((int )eap->cmdidx == 220) {
    goto _L;
  } else {
    {
    tmp___0 = check_changed(curbuf, 1, 0, eap->forceit, 0);
    }
    if (! tmp___0) {
      _L: 
      if ((int )*(eap->arg) != 0) {
        {
        tmp = do_arglist(eap->arg);
        }
        if (tmp == 0) {
          return;
        }
        i___0 = 0;
      } else {
        i___0 = curwin->w_arg_idx + (int )eap->line2;
      }
      {
      do_argfile(eap, i___0);
      }
    }
  }
  }
  return;
}
}
static void do_recover(EXARG *eap ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = check_changed(curbuf, 0, 1, eap->forceit, 0);
  }
  if (! tmp) {
    if ((int )*(eap->arg) == 0) {
      {
      ml_recover();
      }
    } else {
      {
      tmp___0 = setfname(eap->arg, (char_u *)((void *)0), 1);
      }
      if (tmp___0 == 1) {
        {
        ml_recover();
        }
      }
    }
  }
  return;
}
}
static void do_args(EXARG *eap ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = ends_excmd((int )*(eap->arg));
  }
  if (tmp___0) {
    if (arg_file_count == 0) {
      {
      tmp = check_fname();
      }
      if (tmp == 1) {
        {
        smsg((char_u *)"[%s]", curbuf->b_ffname);
        }
      }
    } else {
      {
      gotocmdline(1);
      i___0 = 0;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < arg_file_count)) {
          goto while_break;
        }
        if (i___0 == curwin->w_arg_idx) {
          {
          msg_putchar('[');
          }
        }
        {
        msg_outtrans(*(arg_files + i___0));
        }
        if (i___0 == curwin->w_arg_idx) {
          {
          msg_putchar(']');
          }
        }
        {
        msg_putchar(' ');
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
    do_next(eap);
    }
  }
  return;
}
}
static void do_splitview(EXARG *eap ) 
{ 
  WIN *old_curwin___0 ;
  char_u *fname ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  fname = (char_u *)((void *)0);
  old_curwin___0 = curwin;
  if ((int )eap->cmdidx == 215) {
    {
    tmp = strlen((char const   *)((char *)eap->arg));
    fname = find_file_in_path(eap->arg, (int )tmp, 1, 1L);
    }
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      goto theend;
    }
    eap->arg = fname;
  }
  if (eap->addr_count) {
    tmp___0 = (int )eap->line2;
  } else {
    tmp___0 = 0;
  }
  {
  tmp___1 = win_split(tmp___0, 0, 0);
  }
  if (tmp___1 != 0) {
    {
    do_exedit(eap, old_curwin___0);
    }
  }
  theend: 
  {
  vim_free((void *)fname);
  }
  return;
}
}
static void do_resize(EXARG *eap ) 
{ 
  int n ;
  long tmp ;

  {
  {
  tmp = atol((char const   *)((char *)eap->arg));
  n = (int )tmp;
  }
  if ((int )*(eap->arg) == 45) {
    n += curwin->w_height;
  } else { //Added block
  if ((int )*(eap->arg) == 43) {
    n += curwin->w_height;
  } else { //Added block
  if (n == 0) {
    n = 9999;
  }
  }
  }
  {
  win_setheight(n);
  }
  return;
}
}
static void do_find(EXARG *eap ) 
{ 
  char_u *fname ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)eap->arg));
  fname = find_file_in_path(eap->arg, (int )tmp, 1, 1L);
  }
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    {
    eap->arg = fname;
    do_exedit(eap, (WIN *)((void *)0));
    vim_free((void *)fname);
    }
  }
  return;
}
}
static void do_exedit(EXARG *eap , WIN *old_curwin___0 ) 
{ 
  int n ;
  int need_hide ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  if (exmode_active) {
    if ((int )eap->cmdidx == 263) {
      goto _L;
    } else { //Added block
    if ((int )eap->cmdidx == 264) {
      _L: 
      exmode_active = 0;
      if ((int )*(eap->arg) == 0) {
        return;
      }
    }
    }
  }
  if ((int )eap->cmdidx == 143) {
    if ((int )*(eap->arg) == 0) {
      {
      setpcmark();
      }
      if (eap->forceit) {
        tmp = 8;
      } else {
        tmp = 0;
      }
      {
      do_ecmd(0, (char_u *)((void *)0), (char_u *)((void *)0), eap->do_ecmd_cmd, (linenr_t )1,
              1 + tmp);
      }
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if ((int )eap->cmdidx != 224) {
    goto _L___1;
  } else { //Added block
  if ((int )*(eap->arg) != 0) {
    _L___1: 
    n = readonlymode;
    if ((int )eap->cmdidx == 264) {
      readonlymode = 1;
    } else { //Added block
    if ((int )eap->cmdidx == 234) {
      readonlymode = 1;
    }
    }
    {
    setpcmark();
    }
    if (p_hid) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
    if (eap->forceit) {
      tmp___4 = 8;
    } else {
      tmp___4 = 0;
    }
    if ((int )eap->cmdidx == 15) {
      tmp___5 = 16;
    } else {
      tmp___5 = 0;
    }
    {
    tmp___6 = do_ecmd(0, eap->arg, (char_u *)((void *)0), eap->do_ecmd_cmd, eap->do_ecmd_lnum,
                      (tmp___3 + tmp___4) + tmp___5);
    }
    if (tmp___6 == 0) {
      if ((int )eap->cmdidx == 224) {
        {
        tmp___0 = buf_changed(curwin->w_buffer);
        }
        if (tmp___0) {
          if ((curwin->w_buffer)->b_nwindows <= 1) {
            tmp___1 = 1;
          } else {
            tmp___1 = 0;
          }
        } else {
          tmp___1 = 0;
        }
        need_hide = tmp___1;
        if (! need_hide) {
          goto _L___0;
        } else { //Added block
        if (p_hid) {
          _L___0: 
          if (! need_hide) {
            if (! p_hid) {
              tmp___2 = 1;
            } else {
              tmp___2 = 0;
            }
          } else {
            tmp___2 = 0;
          }
          {
          close_window(curwin, tmp___2);
          }
        }
        }
      }
    }
    readonlymode = n;
  } else {
    if ((unsigned long )eap->do_ecmd_cmd != (unsigned long )((void *)0)) {
      {
      do_cmdline(eap->do_ecmd_cmd, (char_u *(*)(int  , void * , int  ))((void *)0),
                 (void *)0, 1);
      }
    }
    {
    n = curwin->w_arg_idx_invalid;
    check_arg_idx(curwin);
    }
    if (n != curwin->w_arg_idx_invalid) {
      {
      maketitle();
      }
    }
    {
    update_screen(40);
    }
  }
  }
  }
  if ((int )eap->cmdidx == 143) {
    goto _L___3;
  } else { //Added block
  if ((int )eap->cmdidx == 224) {
    _L___3: 
    if ((int )*(eap->arg) != 0) {
      if ((unsigned long )curwin != (unsigned long )old_curwin___0) {
        {
        tmp___7 = win_valid(old_curwin___0);
        }
        if (tmp___7) {
          if ((unsigned long )old_curwin___0->w_buffer != (unsigned long )curbuf) {
            old_curwin___0->w_alt_fnum = curbuf->b_fnum;
          }
        }
      }
    }
  }
  }
  ex_no_reprint = 1;
  return;
}
}
static void do_swapname(void) 
{ 


  {
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    {
    msg((char_u *)"No swap file");
    }
  } else { //Added block
  if ((unsigned long )(curbuf->b_ml.ml_mfp)->mf_fname == (unsigned long )((void *)0)) {
    {
    msg((char_u *)"No swap file");
    }
  } else {
    {
    msg((curbuf->b_ml.ml_mfp)->mf_fname);
    }
  }
  }
  return;
}
}
static void do_syncbind(void) 
{ 
  WIN *wp ;
  long topline ;
  long y ;
  linenr_t old_linenr ;
  char_u ctrl_o[2] ;

  {
  {
  old_linenr = curwin->w_cursor.lnum;
  setpcmark();
  }
  if (curwin->w_p_scb) {
    topline = curwin->w_topline;
    wp = firstwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! wp) {
        goto while_break;
      }
      if (wp->w_p_scb) {
        if (wp->w_buffer) {
          y = (wp->w_buffer)->b_ml.ml_line_count - p_so;
          if (topline > y) {
            topline = y;
          }
        }
      }
      wp = wp->w_next;
    }
    while_break: /* CIL Label */ ;
    }
    if (topline < 1L) {
      topline = 1L;
    }
  } else {
    topline = 1L;
  }
  wp = curwin;
  curwin = firstwin;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! curwin) {
      goto while_break___0;
    }
    if (curwin->w_p_scb) {
      y = topline - curwin->w_topline;
      if (y > 0L) {
        {
        scrollup(y);
        }
      } else {
        {
        scrolldown(- y);
        }
      }
      {
      curwin->w_scbind_pos = topline;
      redraw_later(10);
      cursor_correct();
      curwin->w_redr_status = 1;
      }
    }
    curwin = curwin->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  curwin = wp;
  if (curwin->w_p_scb) {
    {
    did_syncbind = 1;
    checkpcmark();
    }
    if (old_linenr != curwin->w_cursor.lnum) {
      {
      ctrl_o[0] = (char_u )15;
      ctrl_o[1] = (char_u )0;
      ins_typebuf(ctrl_o, -1, 0, 1);
      }
    }
  }
  return;
}
}
static void do_read(EXARG *eap ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  if (eap->usefilter) {
    {
    do_bang(1, eap->line1, eap->line2, 0, eap->arg, 0, 1);
    }
  } else {
    {
    tmp = u_save(eap->line2, eap->line2 + 1L);
    }
    if (tmp == 0) {
      return;
    }
    if ((int )*(eap->arg) == 0) {
      {
      tmp___0 = check_fname();
      }
      if (tmp___0 == 0) {
        return;
      }
      {
      i___0 = readfile(curbuf->b_ffname, curbuf->b_fname, eap->line2, (linenr_t )0,
                       (linenr_t )2147483647, 0);
      }
    } else {
      {
      tmp___1 = vim_strchr(p_cpo, 'a');
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
        setaltfname(eap->arg, eap->arg, (linenr_t )1);
        }
      }
      {
      i___0 = readfile(eap->arg, (char_u *)((void *)0), eap->line2, (linenr_t )0,
                       (linenr_t )2147483647, 0);
      }
    }
    if (i___0 == 0) {
      {
      emsg2(e_notopen, eap->arg);
      }
    } else {
      {
      update_screen(40);
      }
    }
  }
  return;
}
}
static char_u *prev_dir  =    (char_u *)((void *)0);
static void do_cd(EXARG *eap ) 
{ 
  char_u *new_dir ;
  char_u *tofree ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  new_dir = eap->arg;
  tmp = strcmp((char const   *)((char *)eap->arg), (char const   *)((char *)"-"));
  }
  if (tmp == 0) {
    if ((unsigned long )prev_dir == (unsigned long )((void *)0)) {
      {
      emsg((char_u *)"No previous directory");
      }
      return;
    }
    new_dir = prev_dir;
  }
  {
  tofree = prev_dir;
  tmp___0 = mch_dirname(NameBuff, 1024);
  }
  if (tmp___0 == 1) {
    {
    prev_dir = vim_strsave(NameBuff);
    }
  } else {
    prev_dir = (char_u *)((void *)0);
  }
  if ((int )*new_dir == 0) {
    {
    expand_env((char_u *)"$HOME", NameBuff, 1024);
    new_dir = NameBuff;
    }
  }
  if ((unsigned long )new_dir == (unsigned long )((void *)0)) {
    {
    emsg(e_failed);
    }
  } else {
    {
    tmp___1 = chdir((char const   *)((char *)new_dir));
    }
    if (tmp___1) {
      {
      emsg(e_failed);
      }
    } else {
      {
      shorten_fnames(1);
      }
    }
  }
  {
  vim_free((void *)tofree);
  }
  return;
}
}
static void do_pwd(void) 
{ 
  int tmp ;

  {
  {
  tmp = mch_dirname(NameBuff, 1024);
  }
  if (tmp == 1) {
    {
    msg(NameBuff);
    }
  } else {
    {
    emsg(e_unknown);
    }
  }
  return;
}
}
static void do_sleep(EXARG *eap ) 
{ 
  int n ;
  int tmp ;
  long tmp___0 ;

  {
  {
  tmp = cursor_valid();
  }
  if (tmp) {
    n = (curwin->w_winpos + curwin->w_wrow) - msg_scrolled;
    if (n >= 0) {
      {
      windgoto(n, curwin->w_wcol);
      }
    }
  }
  {
  cursor_on();
  out_flush();
  }
  if ((int )*(eap->arg) == 109) {
    tmp___0 = 1L;
  } else {
    tmp___0 = 1000L;
  }
  {
  ui_delay(eap->line2 * tmp___0, 1);
  }
  return;
}
}
static void do_exmap(EXARG *eap , int isabbrev ) 
{ 
  int mode ;
  char_u *cmdp ;
  char_u *ambigstr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  cmdp = eap->cmd;
  if (eap->forceit) {
    tmp = 1;
  } else { //Added block
  if (isabbrev) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  {
  mode = get_map_mode(& cmdp, tmp);
  }
  if ((int )*cmdp == 110) {
    tmp___0 = 2;
  } else {
    tmp___0 = (int )*cmdp == 117;
  }
  {
  tmp___1 = do_map(tmp___0, eap->arg, mode, isabbrev, & ambigstr);
  }
  {
  if (tmp___1 == 1) {
    goto case_1;
  }
  if (tmp___1 == 2) {
    goto case_2;
  }
  if (tmp___1 == 3) {
    goto case_3;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  emsg(e_invarg);
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  if (isabbrev) {
    tmp___2 = e_noabbr;
  } else {
    tmp___2 = e_nomap;
  }
  {
  emsg(tmp___2);
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  ambigstr = translate_mapping(ambigstr, 0);
  }
  if ((unsigned long )ambigstr == (unsigned long )((void *)0)) {
    {
    emsg((char_u *)"Ambiguous mapping");
    }
  } else {
    {
    emsg2((char_u *)"Ambiguous mapping, conflicts with \"%s\"", ambigstr);
    }
  }
  {
  vim_free((void *)ambigstr);
  }
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
static void do_winsize(char_u *arg ) 
{ 
  int w___0 ;
  int h ;
  long tmp ;
  long tmp___0 ;

  {
  {
  tmp = getdigits(& arg);
  w___0 = (int )tmp;
  arg = skipwhite(arg);
  tmp___0 = getdigits(& arg);
  h = (int )tmp___0;
  set_winsize(w___0, h, 1);
  }
  return;
}
}
static void do_winpos(char_u *arg ) 
{ 
  int x___0 ;
  int y ;
  long tmp ;
  long tmp___0 ;

  {
  if ((int )*arg == 0) {
    {
    emsg((char_u *)"Obtaining window position not implemented for this platform");
    }
  } else {
    {
    tmp = getdigits(& arg);
    x___0 = (int )tmp;
    arg = skipwhite(arg);
    tmp___0 = getdigits(& arg);
    y = (int )tmp___0;
    }
    if (*(term_strings[47])) {
      {
      term_set_winpos(x___0, y);
      }
    }
  }
  return;
}
}
static void do_exops(EXARG *eap ) 
{ 
  OPARG oa ;

  {
  {
  clear_oparg(& oa);
  oa.regname = eap->regname;
  oa.start.lnum = eap->line1;
  oa.end.lnum = eap->line2;
  oa.line_count = (eap->line2 - eap->line1) + 1L;
  oa.motion_type = 1;
  }
  if ((int )eap->cmdidx != 285) {
    {
    setpcmark();
    curwin->w_cursor.lnum = eap->line1;
    beginline(6);
    }
  }
  {
  if ((int )eap->cmdidx == 64) {
    goto case_64;
  }
  if ((int )eap->cmdidx == 285) {
    goto case_285;
  }
  goto switch_default;
  case_64: /* CIL Label */ 
  {
  oa.op_type = 1;
  op_delete(& oa);
  }
  goto switch_break;
  case_285: /* CIL Label */ 
  {
  oa.op_type = 2;
  op_yank(& oa, 0, 1);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  if ((int )eap->cmdidx == 293) {
    oa.op_type = 5;
  } else {
    oa.op_type = 4;
  }
  {
  op_shift(& oa, 0, eap->amount);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
static void do_copymove(EXARG *eap ) 
{ 
  long n ;
  int tmp ;

  {
  {
  n = get_address(& eap->arg, 0);
  }
  if ((unsigned long )eap->arg == (unsigned long )((void *)0)) {
    eap->nextcmd = (char_u *)((void *)0);
    return;
  }
  if (n == 2147483647L) {
    {
    emsg(e_invaddr);
    }
    return;
  } else { //Added block
  if (n < 0L) {
    {
    emsg(e_invaddr);
    }
    return;
  } else { //Added block
  if (n > curbuf->b_ml.ml_line_count) {
    {
    emsg(e_invaddr);
    }
    return;
  }
  }
  }
  if ((int )eap->cmdidx == 130) {
    {
    tmp = do_move(eap->line1, eap->line2, n);
    }
    if (tmp == 0) {
      return;
    }
  } else {
    {
    do_copy(eap->line1, eap->line2, n);
    }
  }
  {
  u_clearline();
  beginline(6);
  update_screen(40);
  }
  return;
}
}
static void do_exjoin(EXARG *eap ) 
{ 


  {
  curwin->w_cursor.lnum = eap->line1;
  if (eap->line1 == eap->line2) {
    if (eap->addr_count >= 2) {
      return;
    }
    if (eap->line2 == curbuf->b_ml.ml_line_count) {
      {
      beep_flush();
      }
      return;
    }
    (eap->line2) ++;
  }
  {
  do_do_join((eap->line2 - eap->line1) + 1L, ! eap->forceit, 0);
  beginline(5);
  }
  return;
}
}
static void do_exat(EXARG *eap ) 
{ 
  int c ;
  int save_efr ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  curwin->w_cursor.lnum = eap->line2;
  c = (int )*(eap->arg);
  if (c == 0) {
    c = '@';
  } else { //Added block
  if (c == 42) {
    if ((int )*(eap->cmd) == 42) {
      c = '@';
    }
  }
  }
  {
  tmp___0 = vim_strchr(p_cpo, 'e');
  tmp___1 = do_execreg(c, 1, (unsigned long )tmp___0 != (unsigned long )((void *)0));
  }
  if (tmp___1 == 0) {
    {
    beep_flush();
    }
  } else {
    save_efr = exec_from_reg;
    exec_from_reg = 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = vpeekc();
      }
      if (! (tmp == 58)) {
        goto while_break;
      }
      {
      do_cmdline((char_u *)((void *)0), & getexline, (void *)0, 3);
      }
    }
    while_break: /* CIL Label */ ;
    }
    exec_from_reg = save_efr;
  }
  return;
}
}
static void do_redir(EXARG *eap ) 
{ 
  char *mode ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = strcasecmp((char const   *)((char *)eap->arg), (char const   *)((char *)"END"));
  }
  if (tmp___1 == 0) {
    {
    close_redir();
    }
  } else { //Added block
  if ((int )*(eap->arg) == 62) {
    (eap->arg) ++;
    if ((int )*(eap->arg) == 62) {
      (eap->arg) ++;
      mode = (char *)"a";
    } else {
      mode = (char *)"w";
    }
    {
    eap->arg = skipwhite(eap->arg);
    close_redir();
    redir_fd = open_exfile(eap, mode);
    }
  } else { //Added block
  if ((int )*(eap->arg) == 64) {
    {
    close_redir();
    tmp___0 = __ctype_b_loc();
    (eap->arg) ++;
    }
    if ((int const   )*(*tmp___0 + (int )*(eap->arg)) & 1024) {
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + (int )*(eap->arg)) & 512) {
        {
        write_reg_contents((int )*(eap->arg), (char_u *)"");
        }
      }
      {
      redir_reg = toupper((int )*(eap->arg));
      }
    } else {
      {
      emsg(e_invarg);
      }
    }
  } else {
    {
    emsg(e_invarg);
    }
  }
  }
  }
  return;
}
}
static void close_redir(void) 
{ 


  {
  if ((unsigned long )redir_fd != (unsigned long )((void *)0)) {
    {
    fclose(redir_fd);
    redir_fd = (FILE *)((void *)0);
    }
  }
  redir_reg = 0;
  return;
}
}
static void do_mkrc(EXARG *eap , char_u *defname ) 
{ 
  FILE *fd ;
  int failed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u dirnow[1024] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u tbuf[1024] ;
  int tmp___6 ;

  {
  if ((int )*(eap->arg) == 0) {
    eap->arg = defname;
  }
  {
  fd = open_exfile(eap, (char *)"w");
  }
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    if ((int )eap->cmdidx == 140) {
      {
      fputs((char const   * __restrict  )"version 5.0", (FILE * __restrict  )fd);
      put_eol(fd);
      }
    } else { //Added block
    if ((int )eap->cmdidx == 139) {
      {
      fputs((char const   * __restrict  )"version 5.0", (FILE * __restrict  )fd);
      put_eol(fd);
      }
    }
    }
    if (p_cp) {
      {
      fputs((char const   * __restrict  )"set compatible", (FILE * __restrict  )fd);
      }
    } else {
      {
      fputs((char const   * __restrict  )"set nocompatible", (FILE * __restrict  )fd);
      }
    }
    {
    put_eol(fd);
    failed = 0;
    }
    if ((int )eap->cmdidx != 139) {
      goto _L;
    } else {
      {
      tmp___2 = vim_strchr(p_sessopt, 't');
      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        _L: 
        {
        tmp = makemap(fd);
        }
        if (tmp == 0) {
          tmp___1 = 1;
        } else {
          {
          tmp___0 = makeset(fd);
          }
          if (tmp___0 == 0) {
            tmp___1 = 1;
          } else {
            tmp___1 = 0;
          }
        }
        failed = tmp___1;
      }
    }
    if ((int )eap->cmdidx == 139) {
      if (! failed) {
        {
        tmp___3 = mch_dirname(dirnow, 1024);
        }
        if (tmp___3 == 0) {
          dirnow[0] = (char_u )'\000';
        }
        {
        vim_chdirfile(eap->arg);
        shorten_fnames(1);
        tmp___4 = makeopens(fd);
        failed |= tmp___4 == 0;
        }
        if (dirnow[0]) {
          {
          chdir((char const   *)((char *)(dirnow)));
          shorten_fnames(1);
          }
        }
      }
    }
    {
    tmp___5 = fclose(fd);
    failed |= tmp___5;
    }
    if (failed) {
      {
      emsg(e_write);
      }
    } else { //Added block
    if ((int )eap->cmdidx == 139) {
      {
      tmp___6 = mch_FullName(eap->arg, tbuf, 1024, 0);
      }
      if (tmp___6 == 1) {
        {
        set_vim_var_string(6, tbuf);
        }
      }
    }
    }
  }
  return;
}
}
static FILE *open_exfile(EXARG *eap , char *mode ) 
{ 
  FILE *fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = mch_isdir(eap->arg);
  }
  if (tmp) {
    {
    emsg2((char_u *)"\"%s\" is a directory", eap->arg);
    }
    return ((FILE *)((void *)0));
  }
  if (! eap->forceit) {
    if ((int )*mode != 97) {
      {
      tmp___0 = vim_fexists(eap->arg);
      }
      if (tmp___0) {
        {
        emsg2((char_u *)"\"%s\" exists (use ! to override)", eap->arg);
        }
        return ((FILE *)((void *)0));
      }
    }
  }
  {
  fd = fopen((char const   * __restrict  )((char *)eap->arg), (char const   * __restrict  )mode);
  }
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
    emsg2((char_u *)"Cannot open \"%s\" for writing", eap->arg);
    }
  }
  return (fd);
}
}
static void do_setmark(EXARG *eap ) 
{ 
  FPOS pos___0 ;
  int tmp ;

  {
  if ((int )*(eap->arg) == 0) {
    {
    emsg(e_argreq);
    }
  } else { //Added block
  if ((int )*(eap->arg + 1) != 0) {
    {
    emsg(e_trailing);
    }
  } else {
    {
    pos___0 = curwin->w_cursor;
    curwin->w_cursor.lnum = eap->line2;
    beginline(5);
    tmp = setmark((int )*(eap->arg));
    }
    if (tmp == 0) {
      {
      emsg((char_u *)"Argument must be a letter or forward/backward quote");
      }
    }
    curwin->w_cursor = pos___0;
  }
  }
  return;
}
}
static int depth___0  =    0;
static void do_normal(EXARG *eap ) 
{ 
  OPARG oa ;
  int len___0 ;
  int save_msg_scroll ;
  int save_restart_edit ;
  int save_msg_didout ;
  linenr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  save_msg_scroll = msg_scroll;
  save_restart_edit = restart_edit;
  save_msg_didout = msg_didout;
  if ((long )depth___0 >= p_mmd) {
    {
    emsg((char_u *)"Recursive use of :normal too deep");
    }
    return;
  }
  if (vgetc_busy) {
    {
    emsg((char_u *)"Cannot use :normal from event handler");
    }
    return;
  }
  depth___0 ++;
  msg_scroll = 0;
  restart_edit = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    clear_oparg(& oa);
    }
    if (eap->addr_count != 0) {
      tmp = eap->line1;
      (eap->line1) ++;
      curwin->w_cursor.lnum = tmp;
      curwin->w_cursor.col = (colnr_t )0;
    }
    len___0 = typelen;
    if (eap->forceit) {
      tmp___0 = -1;
    } else {
      tmp___0 = 0;
    }
    {
    ins_typebuf(eap->arg, tmp___0, 0, 1);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___1 = stuff_empty();
      }
      if (tmp___1) {
        {
        tmp___2 = typebuf_typed();
        }
        if (tmp___2) {
          goto while_break___0;
        } else { //Added block
        if (typelen > len___0) {
          _L: 
          if (! (! got_int)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        }
      } else {
        goto _L;
      }
      {
      adjust_cursor();
      update_topline();
      }
      if (! curwin->w_p_wrap) {
        {
        validate_cursor();
        }
      }
      {
      update_curswant();
      normal_cmd(& oa, 0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (eap->addr_count > 0) {
      if (eap->line1 <= eap->line2) {
        if (! (! got_int)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  depth___0 --;
  msg_scroll = save_msg_scroll;
  restart_edit = save_restart_edit;
  msg_didout |= save_msg_didout;
  return;
}
}
static char_u *do_findpat(EXARG *eap , int action ) 
{ 
  int whole ;
  long n ;
  char_u *p___0 ;
  char_u *errormsg ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
  whole = 1;
  errormsg = (char_u *)((void *)0);
  n = 1L;
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + (int )*(eap->arg)) & 2048) {
    {
    n = getdigits(& eap->arg);
    eap->arg = skipwhite(eap->arg);
    }
  }
  if ((int )*(eap->arg) == 47) {
    {
    whole = 0;
    (eap->arg) ++;
    p___0 = skip_regexp(eap->arg, '/', p_magic);
    }
    if (*p___0) {
      {
      tmp___0 = p___0;
      p___0 ++;
      *tmp___0 = (char_u )'\000';
      p___0 = skipwhite(p___0);
      tmp___1 = ends_excmd((int )*p___0);
      }
      if (tmp___1) {
        {
        eap->nextcmd = check_nextcmd(p___0);
        }
      } else {
        errormsg = e_trailing;
      }
    }
  }
  if (! eap->skip) {
    if ((int )*(eap->cmd) == 100) {
      tmp___2 = 2;
    } else {
      tmp___2 = 1;
    }
    {
    tmp___3 = strlen((char const   *)((char *)eap->arg));
    find_pattern_in_path(eap->arg, 0, (int )tmp___3, whole, ! eap->forceit, tmp___2,
                         n, action, eap->line1, eap->line2);
    }
  }
  return (errormsg);
}
}
static void do_ex_tag(EXARG *eap , int dt , int preview ) 
{ 
  int tmp ;

  {
  if (preview) {
    g_do_tagpreview = (int )p_pvh;
  }
  if (eap->addr_count) {
    tmp = (int )eap->line2;
  } else {
    tmp = 1;
  }
  {
  do_tag((char_u *)"", dt, tmp, eap->forceit, 1);
  }
  return;
}
}
static char_u *do_if(EXARG *eap , struct condstack *cstack ) 
{ 
  char_u *errormsg ;
  int error ;
  int skip ;
  int result___0 ;
  int tmp ;

  {
  errormsg = (char_u *)((void *)0);
  if (cstack->cs_idx == 49) {
    errormsg = (char_u *)":if nesting too deep";
  } else {
    (cstack->cs_idx) ++;
    cstack->cs_flags[cstack->cs_idx] = (char)0;
    if (cstack->cs_idx > 0) {
      if (! ((int )cstack->cs_flags[cstack->cs_idx - 1] & 2)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    {
    skip = tmp;
    result___0 = eval_to_bool(eap->arg, & error, & eap->nextcmd, skip);
    }
    if (! skip) {
      if (result___0) {
        cstack->cs_flags[cstack->cs_idx] = (char)3;
      }
      if (error) {
        (cstack->cs_idx) --;
      }
    }
  }
  return (errormsg);
}
}
static char_u *do_else(EXARG *eap , struct condstack *cstack ) 
{ 
  char_u *errormsg ;
  int error ;
  int skip ;
  int result___0 ;
  int tmp ;

  {
  errormsg = (char_u *)((void *)0);
  if (cstack->cs_idx < 0) {
    goto _L;
  } else { //Added block
  if ((int )cstack->cs_flags[cstack->cs_idx] & 4) {
    _L: 
    if ((int )eap->cmdidx == 79) {
      errormsg = (char_u *)":else without :if";
    } else {
      errormsg = (char_u *)":elseif without :if";
    }
  } else {
    if (cstack->cs_idx > 0) {
      if (! ((int )cstack->cs_flags[cstack->cs_idx - 1] & 2)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    skip = tmp;
    if (! skip) {
      if ((int )cstack->cs_flags[cstack->cs_idx] & 1) {
        cstack->cs_flags[cstack->cs_idx] = (char)1;
        skip = 1;
      } else {
        cstack->cs_flags[cstack->cs_idx] = (char)2;
      }
    }
    if ((int )eap->cmdidx == 80) {
      {
      result___0 = eval_to_bool(eap->arg, & error, & eap->nextcmd, skip);
      }
      if (! skip) {
        if ((int )cstack->cs_flags[cstack->cs_idx] & 2) {
          if (result___0) {
            cstack->cs_flags[cstack->cs_idx] = (char)3;
          } else {
            cstack->cs_flags[cstack->cs_idx] = (char)0;
          }
          if (error) {
            (cstack->cs_idx) --;
          }
        }
      }
    }
  }
  }
  return (errormsg);
}
}
static char_u *do_while(EXARG *eap , struct condstack *cstack ) 
{ 
  char_u *errormsg ;
  int error ;
  int skip ;
  int result___0 ;
  int tmp ;

  {
  errormsg = (char_u *)((void *)0);
  if (cstack->cs_idx == 49) {
    errormsg = (char_u *)":while nesting too deep";
  } else {
    if (! cstack->cs_had_while) {
      (cstack->cs_idx) ++;
      (cstack->cs_whilelevel) ++;
      cstack->cs_line[cstack->cs_idx] = -1;
    }
    cstack->cs_flags[cstack->cs_idx] = (char)4;
    if (cstack->cs_idx > 0) {
      if (! ((int )cstack->cs_flags[cstack->cs_idx - 1] & 2)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    {
    skip = tmp;
    result___0 = eval_to_bool(eap->arg, & error, & eap->nextcmd, skip);
    }
    if (! skip) {
      if (result___0) {
        if (! error) {
          cstack->cs_flags[cstack->cs_idx] = (char )((int )cstack->cs_flags[cstack->cs_idx] | 3);
        }
      }
      cstack->cs_had_while = (char)1;
    }
  }
  return (errormsg);
}
}
static char_u *do_continue(struct condstack *cstack ) 
{ 
  char_u *errormsg ;

  {
  errormsg = (char_u *)((void *)0);
  if (cstack->cs_whilelevel <= 0) {
    errormsg = (char_u *)":continue without :while";
  } else { //Added block
  if (cstack->cs_idx < 0) {
    errormsg = (char_u *)":continue without :while";
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (cstack->cs_idx > 0) {
        if (! (! ((int )cstack->cs_flags[cstack->cs_idx] & 4))) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      (cstack->cs_idx) --;
    }
    while_break: /* CIL Label */ ;
    }
    cstack->cs_had_continue = (char)1;
  }
  }
  return (errormsg);
}
}
static char_u *do_break(struct condstack *cstack ) 
{ 
  char_u *errormsg ;
  int idx ;

  {
  errormsg = (char_u *)((void *)0);
  if (cstack->cs_whilelevel <= 0) {
    errormsg = (char_u *)":break without :while";
  } else { //Added block
  if (cstack->cs_idx < 0) {
    errormsg = (char_u *)":break without :while";
  } else {
    idx = cstack->cs_idx;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (idx >= 0)) {
        goto while_break;
      }
      cstack->cs_flags[idx] = (char )((int )cstack->cs_flags[idx] & -3);
      if ((int )cstack->cs_flags[idx] & 4) {
        goto while_break;
      }
      idx --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  }
  return (errormsg);
}
}
static char_u *do_endwhile(struct condstack *cstack ) 
{ 
  char_u *errormsg ;

  {
  errormsg = (char_u *)((void *)0);
  if (cstack->cs_whilelevel <= 0) {
    errormsg = (char_u *)":endwhile without :while";
  } else { //Added block
  if (cstack->cs_idx < 0) {
    errormsg = (char_u *)":endwhile without :while";
  } else {
    if (! ((int )cstack->cs_flags[cstack->cs_idx] & 4)) {
      errormsg = (char_u *)":endwhile without :while";
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (cstack->cs_idx >= 0) {
          if (! (! ((int )cstack->cs_flags[cstack->cs_idx] & 4))) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        (cstack->cs_idx) --;
      }
      while_break: /* CIL Label */ ;
      }
    }
    cstack->cs_had_endwhile = (char)1;
  }
  }
  return (errormsg);
}
}
static int has_while_cmd(char_u *p___0 ) 
{ 


  {
  {
  p___0 = skipwhite(p___0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*p___0 == 58)) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  p___0 = skipwhite(p___0);
  }
  if ((int )*(p___0 + 0) == 119) {
    if ((int )*(p___0 + 1) == 104) {
      return (1);
    }
  }
  return (0);
}
}
static char *spec_str[9]  = 
  {      (char *)"%",      (char *)"#",      (char *)"<cword>",      (char *)"<cWORD>", 
        (char *)"<cfile>",      (char *)"<sfile>",      (char *)"<afile>",      (char *)"<abuf>", 
        (char *)"<amatch>"};
char_u *eval_vars(char_u *src , int *usedlen , linenr_t *lnump , char_u **errormsg ,
                  char_u *srcstart ) 
{ 
  int i___0 ;
  char_u *s ;
  char_u *result___0 ;
  char_u *resultbuf ;
  int resultlen ;
  BUF *buf___3 ;
  int valid ;
  int spec_idx ;
  char_u abuf_nr[30] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;

  {
  resultbuf = (char_u *)((void *)0);
  valid = 3;
  *errormsg = (char_u *)((void *)0);
  spec_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )spec_idx < sizeof(spec_str) / sizeof(char *))) {
      goto while_break;
    }
    {
    tmp = strlen((char const   *)spec_str[spec_idx]);
    *usedlen = (int )tmp;
    tmp___0 = strncmp((char const   *)((char *)src), (char const   *)spec_str[spec_idx],
                      (size_t )*usedlen);
    }
    if (tmp___0 == 0) {
      goto while_break;
    }
    spec_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )spec_idx == sizeof(spec_str) / sizeof(char *)) {
    *usedlen = 1;
    return ((char_u *)((void *)0));
  }
  if ((unsigned long )src > (unsigned long )srcstart) {
    if ((int )*(src + -1) == 92) {
      {
      *usedlen = 0;
      strcpy((char * __restrict  )((char *)(src - 1)), (char const   * __restrict  )((char *)src));
      }
      return ((char_u *)((void *)0));
    }
  }
  if (spec_idx == 2) {
    goto _L;
  } else { //Added block
  if (spec_idx == 3) {
    _L: 
    if (spec_idx == 2) {
      tmp___1 = 3;
    } else {
      tmp___1 = 2;
    }
    {
    resultlen = find_ident_under_cursor(& result___0, tmp___1);
    }
    if (resultlen == 0) {
      *errormsg = (char_u *)"";
      return ((char_u *)((void *)0));
    }
  } else {
    {
    if (spec_idx == 0) {
      goto case_0;
    }
    if (spec_idx == 1) {
      goto case_1;
    }
    if (spec_idx == 4) {
      goto case_4;
    }
    if (spec_idx == 6) {
      goto case_6;
    }
    if (spec_idx == 7) {
      goto case_7;
    }
    if (spec_idx == 8) {
      goto case_8;
    }
    if (spec_idx == 5) {
      goto case_5;
    }
    goto switch_break;
    case_0: /* CIL Label */ 
    if ((unsigned long )curbuf->b_fname == (unsigned long )((void *)0)) {
      result___0 = (char_u *)"";
      valid = 0;
    } else {
      result___0 = curbuf->b_fname;
    }
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    s = src + 1;
    tmp___2 = getdigits(& s);
    i___0 = (int )tmp___2;
    *usedlen = (int )(s - src);
    buf___3 = buflist_findnr(i___0);
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      *errormsg = (char_u *)"No alternate file name to substitute for \'#\'";
      return ((char_u *)((void *)0));
    }
    if ((unsigned long )lnump != (unsigned long )((void *)0)) {
      *lnump = (linenr_t )-1;
    }
    if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
      result___0 = (char_u *)"";
      valid = 0;
    } else {
      result___0 = buf___3->b_fname;
    }
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    result___0 = file_name_at_cursor(5, 1L);
    }
    if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
      *errormsg = (char_u *)"";
      return ((char_u *)((void *)0));
    }
    resultbuf = result___0;
    goto switch_break;
    case_6: /* CIL Label */ 
    result___0 = autocmd_fname;
    if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
      *errormsg = (char_u *)"no autocommand file name to substitute for \"<afile>\"";
      return ((char_u *)((void *)0));
    }
    goto switch_break;
    case_7: /* CIL Label */ 
    if (autocmd_bufnr <= 0) {
      *errormsg = (char_u *)"no autocommand buffer number to substitute for \"<abuf>\"";
      return ((char_u *)((void *)0));
    }
    {
    sprintf((char * __restrict  )((char *)(abuf_nr)), (char const   * __restrict  )"%d",
            autocmd_bufnr);
    result___0 = abuf_nr;
    }
    goto switch_break;
    case_8: /* CIL Label */ 
    result___0 = autocmd_match;
    if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
      *errormsg = (char_u *)"no autocommand match name to substitute for \"<amatch>\"";
      return ((char_u *)((void *)0));
    }
    goto switch_break;
    case_5: /* CIL Label */ 
    result___0 = sourcing_name;
    if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
      *errormsg = (char_u *)"no :source file name to substitute for \"<sfile>\"";
      return ((char_u *)((void *)0));
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    tmp___3 = strlen((char const   *)((char *)result___0));
    resultlen = (int )tmp___3;
    }
    if ((int )*(src + *usedlen) == 60) {
      {
      (*usedlen) ++;
      s = vim_strrchr(result___0, '.');
      }
      if ((unsigned long )s != (unsigned long )((void *)0)) {
        {
        tmp___4 = gettail(result___0);
        }
        if ((unsigned long )s >= (unsigned long )tmp___4) {
          resultlen = (int )(s - result___0);
        }
      }
    } else {
      {
      tmp___5 = modify_fname(src, usedlen, & result___0, & resultbuf, & resultlen);
      valid |= tmp___5;
      }
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        *errormsg = (char_u *)"";
        return ((char_u *)((void *)0));
      }
    }
  }
  }
  if (resultlen == 0) {
    goto _L___0;
  } else { //Added block
  if (valid != 3) {
    _L___0: 
    if (valid != 3) {
      *errormsg = (char_u *)"Empty file name for \'%\' or \'#\', only works with \":p:h\"";
    } else {
      *errormsg = (char_u *)"Evaluates to an empty string";
    }
    result___0 = (char_u *)((void *)0);
  } else {
    {
    result___0 = vim_strnsave(result___0, resultlen);
    }
  }
  }
  {
  vim_free((void *)resultbuf);
  }
  return (result___0);
}
}
char_u *expand_sfile(char_u *arg ) 
{ 
  char_u *errormsg ;
  int len___0 ;
  char_u *result___0 ;
  char_u *newres ;
  char_u *repl ;
  int srclen ;
  char_u *p___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
  result___0 = vim_strsave(arg);
  }
  if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  p___0 = result___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp___2 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"<sfile>"),
                      (size_t )7);
    }
    if (tmp___2) {
      p___0 ++;
    } else {
      {
      repl = eval_vars(p___0, & srclen, (linenr_t *)((void *)0), & errormsg, result___0);
      }
      if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
        if (*errormsg) {
          {
          emsg(errormsg);
          }
        }
        {
        vim_free((void *)result___0);
        }
        return ((char_u *)((void *)0));
      }
      if ((unsigned long )repl == (unsigned long )((void *)0)) {
        p___0 += srclen;
        goto __Cont;
      }
      {
      tmp = strlen((char const   *)((char *)result___0));
      tmp___0 = strlen((char const   *)((char *)repl));
      len___0 = (int )(((tmp - (size_t )srclen) + tmp___0) + 1UL);
      newres = alloc((unsigned int )len___0);
      }
      if ((unsigned long )newres == (unsigned long )((void *)0)) {
        {
        vim_free((void *)repl);
        vim_free((void *)result___0);
        }
        return ((char_u *)((void *)0));
      }
      {
      memmove((void *)((char *)newres), (void const   *)((char *)result___0), (size_t )(p___0 - result___0));
      strcpy((char * __restrict  )((char *)(newres + (p___0 - result___0))), (char const   * __restrict  )((char *)repl));
      tmp___1 = strlen((char const   *)((char *)newres));
      len___0 = (int )tmp___1;
      strcat((char * __restrict  )((char *)newres), (char const   * __restrict  )((char *)(p___0 + srclen)));
      vim_free((void *)repl);
      vim_free((void *)result___0);
      result___0 = newres;
      p___0 = newres + len___0;
      }
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  return (result___0);
}
}
static int makeopens(FILE *fd ) 
{ 
  BUF *buf___3 ;
  int dont_save_help ;
  int only_save_windows ;
  int nr ;
  int cnr ;
  int restore_size ;
  WIN *wp ;
  char *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char_u *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;

  {
  {
  dont_save_help = 0;
  only_save_windows = 1;
  nr = 0;
  cnr = 0;
  restore_size = 1;
  tmp = strstr((char const   *)((char *)p_sessopt), "he");
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    dont_save_help = 1;
  }
  {
  tmp___0 = vim_strchr(p_sessopt, 'f');
  }
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    only_save_windows = 0;
  }
  {
  tmp___1 = fputs((char const   * __restrict  )"let v:this_session=expand(\"<sfile>:p\")",
                  (FILE * __restrict  )fd);
  }
  if (tmp___1 < 0) {
    return (0);
  } else {
    {
    tmp___2 = put_eol(fd);
    }
    if (tmp___2 == 0) {
      return (0);
    }
  }
  {
  tmp___4 = vim_strchr(p_sessopt, 'g');
  }
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
    tmp___3 = store_session_globals(fd);
    }
    if (tmp___3 == 0) {
      return (0);
    }
  }
  {
  tmp___5 = fputs((char const   * __restrict  )"1,9999bd", (FILE * __restrict  )fd);
  }
  if (tmp___5 < 0) {
    return (0);
  } else {
    {
    tmp___6 = put_eol(fd);
    }
    if (tmp___6 == 0) {
      return (0);
    }
  }
  {
  tmp___7 = fputs((char const   * __restrict  )"execute \"cd \" . expand(\"<sfile>:p:h\")",
                  (FILE * __restrict  )fd);
  }
  if (tmp___7 < 0) {
    return (0);
  } else {
    {
    tmp___8 = put_eol(fd);
    }
    if (tmp___8 == 0) {
      return (0);
    }
  }
  {
  tmp___9 = fputs((char const   * __restrict  )"let shmsave = &shortmess | set shortmess=aoO",
                  (FILE * __restrict  )fd);
  }
  if (tmp___9 < 0) {
    return (0);
  } else {
    {
    tmp___10 = put_eol(fd);
    }
    if (tmp___10 == 0) {
      return (0);
    }
  }
  if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
    {
    tmp___11 = ses_fname_line(fd, (char *)"e", curwin->w_cursor.lnum, curbuf);
    }
    if (tmp___11 == 0) {
      return (0);
    }
  }
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (only_save_windows) {
      if (buf___3->b_nwindows == 0) {
        goto __Cont;
      }
    }
    if (buf___3->b_help) {
      if (dont_save_help) {
        goto __Cont;
      }
    }
    if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
      if ((unsigned long )buf___3 != (unsigned long )curbuf) {
        {
        tmp___12 = ses_fname_line(fd, (char *)"badd", (buf___3->b_winfpos)->wl_fpos.lnum,
                                  buf___3);
        }
        if (tmp___12 == 0) {
          return (0);
        }
      }
    }
    __Cont: 
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___17 = strstr((char const   *)((char *)p_sessopt), "re");
  }
  if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
    {
    tmp___13 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"set lines=%ld",
                       Rows);
    }
    if (tmp___13 < 0) {
      return (0);
    } else {
      {
      tmp___14 = put_eol(fd);
      }
      if (tmp___14 == 0) {
        return (0);
      }
    }
    {
    tmp___15 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"set columns=%ld",
                       Columns);
    }
    if (tmp___15 < 0) {
      return (0);
    } else {
      {
      tmp___16 = put_eol(fd);
      }
      if (tmp___16 == 0) {
        return (0);
      }
    }
  }
  {
  tmp___18 = fputs((char const   * __restrict  )"let sbsave = &splitbelow | set splitbelow",
                   (FILE * __restrict  )fd);
  }
  if (tmp___18 < 0) {
    return (0);
  } else {
    {
    tmp___19 = put_eol(fd);
    }
    if (tmp___19 == 0) {
      return (0);
    }
  }
  wp = firstwin;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    nr ++;
    if ((unsigned long )(wp->w_buffer)->b_fname == (unsigned long )((void *)0)) {
      {
      tmp___21 = vim_strchr(p_sessopt, 'k');
      }
      if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
        restore_size = 0;
        nr --;
        goto __Cont___0;
      } else { //Added block
      if (nr != 1) {
        {
        tmp___20 = fputs((char const   * __restrict  )"new", (FILE * __restrict  )fd);
        }
        if (tmp___20 < 0) {
          return (0);
        }
      }
      }
    } else { //Added block
    if ((wp->w_buffer)->b_help) {
      if (dont_save_help) {
        restore_size = 0;
        nr --;
        goto __Cont___0;
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (nr == 1) {
        {
        tmp___22 = fputs((char const   * __restrict  )"b ", (FILE * __restrict  )fd);
        }
        if (tmp___22 < 0) {
          return (0);
        }
      } else {
        {
        tmp___23 = fputs((char const   * __restrict  )"sb ", (FILE * __restrict  )fd);
        }
        if (tmp___23 < 0) {
          return (0);
        }
      }
      if ((unsigned long )(wp->w_buffer)->b_ffname != (unsigned long )((void *)0)) {
        {
        tmp___24 = ses_fname(fd, wp->w_buffer);
        }
        if (tmp___24 == 0) {
          return (0);
        }
      }
    }
    }
    {
    tmp___25 = put_eol(fd);
    }
    if (tmp___25 == 0) {
      return (0);
    }
    if (nr > 1) {
      if ((unsigned long )wp->w_next != (unsigned long )((void *)0)) {
        {
        tmp___26 = fputs((char const   * __restrict  )"normal \027_", (FILE * __restrict  )fd);
        }
        if (tmp___26 < 0) {
          return (0);
        } else {
          {
          tmp___27 = put_eol(fd);
          }
          if (tmp___27 == 0) {
            return (0);
          }
        }
      }
    }
    if ((unsigned long )curwin == (unsigned long )wp) {
      cnr = nr;
    }
    __Cont___0: 
    wp = wp->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp___28 = fputs((char const   * __restrict  )"let &splitbelow = sbsave", (FILE * __restrict  )fd);
  }
  if (tmp___28 < 0) {
    return (0);
  } else {
    {
    tmp___29 = put_eol(fd);
    }
    if (tmp___29 == 0) {
      return (0);
    }
  }
  if (nr > 1) {
    if (restore_size) {
      {
      tmp___46 = strstr((char const   *)((char *)p_sessopt), "nsi");
      }
      if ((unsigned long )tmp___46 != (unsigned long )((void *)0)) {
        {
        tmp___30 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"if (&lines == %ld)",
                           Rows);
        }
        if (tmp___30 < 0) {
          return (0);
        } else {
          {
          tmp___31 = put_eol(fd);
          }
          if (tmp___31 == 0) {
            return (0);
          }
        }
        {
        tmp___32 = fputs((char const   * __restrict  )"  normal \027t", (FILE * __restrict  )fd);
        }
        if (tmp___32 < 0) {
          return (0);
        } else {
          {
          tmp___33 = put_eol(fd);
          }
          if (tmp___33 == 0) {
            return (0);
          }
        }
        wp = firstwin;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
            goto while_break___1;
          }
          if ((unsigned long )wp != (unsigned long )firstwin) {
            {
            tmp___34 = fputs((char const   * __restrict  )"  normal \027j", (FILE * __restrict  )fd);
            }
            if (tmp___34 < 0) {
              return (0);
            } else {
              {
              tmp___35 = put_eol(fd);
              }
              if (tmp___35 == 0) {
                return (0);
              }
            }
          }
          {
          tmp___36 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"  resize %ld",
                             (long )wp->w_height);
          }
          if (tmp___36 < 0) {
            return (0);
          } else {
            {
            tmp___37 = put_eol(fd);
            }
            if (tmp___37 == 0) {
              return (0);
            }
          }
          wp = wp->w_next;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        tmp___38 = fputs((char const   * __restrict  )"else", (FILE * __restrict  )fd);
        }
        if (tmp___38 < 0) {
          return (0);
        } else {
          {
          tmp___39 = put_eol(fd);
          }
          if (tmp___39 == 0) {
            return (0);
          }
        }
        {
        tmp___40 = fputs((char const   * __restrict  )"  normal \027=", (FILE * __restrict  )fd);
        }
        if (tmp___40 < 0) {
          return (0);
        } else {
          {
          tmp___41 = put_eol(fd);
          }
          if (tmp___41 == 0) {
            return (0);
          }
        }
        {
        tmp___42 = fputs((char const   * __restrict  )"endif", (FILE * __restrict  )fd);
        }
        if (tmp___42 < 0) {
          return (0);
        } else {
          {
          tmp___43 = put_eol(fd);
          }
          if (tmp___43 == 0) {
            return (0);
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      {
      tmp___44 = fputs((char const   * __restrict  )"normal \027=", (FILE * __restrict  )fd);
      }
      if (tmp___44 < 0) {
        return (0);
      } else {
        {
        tmp___45 = put_eol(fd);
        }
        if (tmp___45 == 0) {
          return (0);
        }
      }
    }
  }
  {
  tmp___47 = fputs((char const   * __restrict  )"normal \027t", (FILE * __restrict  )fd);
  }
  if (tmp___47 < 0) {
    return (0);
  }
  wp = firstwin;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break___2;
    }
    if ((unsigned long )wp != (unsigned long )firstwin) {
      {
      tmp___48 = fputs((char const   * __restrict  )"normal \027j", (FILE * __restrict  )fd);
      }
      if (tmp___48 < 0) {
        return (0);
      }
    }
    if ((unsigned long )(wp->w_buffer)->b_fname != (unsigned long )((void *)0)) {
      {
      tmp___49 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%ldGzt%ldG0",
                         wp->w_topline, wp->w_cursor.lnum);
      }
      if (tmp___49 < 0) {
        return (0);
      }
      if (wp->w_cursor.col > 0U) {
        {
        tmp___50 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%dl",
                           wp->w_cursor.col);
        }
        if (tmp___50 < 0) {
          return (0);
        }
      }
    }
    {
    tmp___51 = put_eol(fd);
    }
    if (tmp___51 == 0) {
      return (0);
    }
    wp = wp->w_next;
  }
  while_break___2: /* CIL Label */ ;
  }
  if (nr > 1) {
    {
    tmp___52 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"normal %d\027w",
                       cnr);
    }
    if (tmp___52 < 0) {
      return (0);
    } else {
      {
      tmp___53 = put_eol(fd);
      }
      if (tmp___53 == 0) {
        return (0);
      }
    }
  }
  {
  tmp___54 = fputs((char const   * __restrict  )"let &shortmess = shmsave", (FILE * __restrict  )fd);
  }
  if (tmp___54 < 0) {
    return (0);
  } else {
    {
    tmp___55 = put_eol(fd);
    }
    if (tmp___55 == 0) {
      return (0);
    }
  }
  {
  tmp___56 = fputs((char const   * __restrict  )"let sessionextra=expand(\"<sfile>:p:r\").\"x.vim\"",
                   (FILE * __restrict  )fd);
  }
  if (tmp___56 < 0) {
    return (0);
  } else {
    {
    tmp___57 = put_eol(fd);
    }
    if (tmp___57 == 0) {
      return (0);
    }
  }
  {
  tmp___58 = fputs((char const   * __restrict  )"if file_readable(sessionextra)",
                   (FILE * __restrict  )fd);
  }
  if (tmp___58 < 0) {
    return (0);
  } else {
    {
    tmp___59 = put_eol(fd);
    }
    if (tmp___59 == 0) {
      return (0);
    }
  }
  {
  tmp___60 = fputs((char const   * __restrict  )"\texecute \"source \" . sessionextra",
                   (FILE * __restrict  )fd);
  }
  if (tmp___60 < 0) {
    return (0);
  } else {
    {
    tmp___61 = put_eol(fd);
    }
    if (tmp___61 == 0) {
      return (0);
    }
  }
  {
  tmp___62 = fputs((char const   * __restrict  )"endif", (FILE * __restrict  )fd);
  }
  if (tmp___62 < 0) {
    return (0);
  } else {
    {
    tmp___63 = put_eol(fd);
    }
    if (tmp___63 == 0) {
      return (0);
    }
  }
  return (1);
}
}
static int ses_fname_line(FILE *fd , char *cmd , linenr_t lnum , BUF *buf___3 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s +%ld ",
                cmd, lnum);
  }
  if (tmp < 0) {
    return (0);
  }
  {
  tmp___0 = ses_fname(fd, buf___3);
  }
  if (tmp___0 == 0) {
    return (0);
  } else {
    {
    tmp___1 = put_eol(fd);
    }
    if (tmp___1 == 0) {
      return (0);
    }
  }
  return (1);
}
}
static int ses_fname(FILE *fd , BUF *buf___3 ) 
{ 
  int c ;
  char_u *name___1 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  if ((unsigned long )buf___3->b_sfname != (unsigned long )((void *)0)) {
    name___1 = buf___3->b_sfname;
  } else {
    name___1 = buf___3->b_ffname;
  }
  {
  tmp___2 = strstr((char const   *)((char *)p_sessopt), "sl");
  }
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *name___1) {
        goto while_break;
      }
      tmp = name___1;
      name___1 ++;
      c = (int )*tmp;
      if (c == 92) {
        c = '/';
      }
      {
      tmp___0 = _IO_putc(c, fd);
      }
      if (tmp___0 != c) {
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    tmp___1 = fputs((char const   * __restrict  )((char *)name___1), (FILE * __restrict  )fd);
    }
    if (tmp___1 < 0) {
      return (0);
    }
  }
  return (1);
}
}
int put_eol(FILE *fd ) 
{ 
  int tmp ;

  {
  {
  tmp = _IO_putc('\n', fd);
  }
  if (tmp < 0) {
    return (0);
  }
  return (1);
}
}
static void cmd_source(char_u *fname , int forceit ) 
{ 
  int tmp ;

  {
  if ((int )*fname == 0) {
    {
    emsg(e_argreq);
    }
  } else { //Added block
  if (forceit) {
    {
    openscript(fname);
    }
  } else {
    {
    tmp = do_source(fname, 0, 0);
    }
    if (tmp == 0) {
      {
      emsg2(e_notopen, fname);
      }
    }
  }
  }
  return;
}
}
void dialog_msg(char_u *buff , char *format , char_u *fname ) 
{ 
  int len___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    fname = (char_u *)"Untitled";
  }
  {
  tmp = strlen((char const   *)format);
  tmp___0 = strlen((char const   *)((char *)fname));
  len___0 = (int )(tmp + tmp___0);
  }
  if (len___0 >= 1025) {
    {
    tmp___1 = strlen((char const   *)format);
    sprintf((char * __restrict  )((char *)buff), (char const   * __restrict  )format,
            (int )(1025UL - tmp___1), fname);
    }
  } else {
    {
    tmp___2 = strlen((char const   *)((char *)fname));
    sprintf((char * __restrict  )((char *)buff), (char const   * __restrict  )format,
            (int )tmp___2, fname);
    }
  }
  return;
}
}
static void ex_behave(char_u *arg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = strcmp((char const   *)((char *)arg), (char const   *)((char *)"mswin"));
  }
  if (tmp___0 == 0) {
    {
    set_option_value((char_u *)"selection", 0L, (char_u *)"exclusive");
    set_option_value((char_u *)"selectmode", 0L, (char_u *)"mouse,key");
    set_option_value((char_u *)"mousemodel", 0L, (char_u *)"popup");
    set_option_value((char_u *)"keymodel", 0L, (char_u *)"startsel,stopsel");
    }
  } else {
    {
    tmp = strcmp((char const   *)((char *)arg), (char const   *)((char *)"xterm"));
    }
    if (tmp == 0) {
      {
      set_option_value((char_u *)"selection", 0L, (char_u *)"inclusive");
      set_option_value((char_u *)"selectmode", 0L, (char_u *)"");
      set_option_value((char_u *)"mousemodel", 0L, (char_u *)"extend");
      set_option_value((char_u *)"keymodel", 0L, (char_u *)"");
      }
    } else {
      {
      emsg2(e_invarg2, arg);
      }
    }
  }
  return;
}
}
static void ex_filetype(char_u *arg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = strcmp((char const   *)((char *)arg), (char const   *)((char *)"on"));
  }
  if (tmp___0 == 0) {
    {
    do_source((char_u *)"$VIMRUNTIME/filetype.vim", 0, 0);
    }
  } else {
    {
    tmp = strcmp((char const   *)((char *)arg), (char const   *)((char *)"off"));
    }
    if (tmp == 0) {
      {
      do_source((char_u *)"$VIMRUNTIME/ftoff.vim", 0, 0);
      }
    } else {
      {
      emsg2(e_invarg2, arg);
      }
    }
  }
  return;
}
}
static void ex_options(void) 
{ 


  {
  {
  cmd_source((char_u *)"$VIMRUNTIME/optwin.vim", 0);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-18TzbvMo.i","-O0")
int cmdline_crypt ;
int quit_more ;
int msg_no_more ;
int mouse_row  ;
int mouse_col  ;
int maptick ;
int redir_off ;
int save_p_ls ;
int wild_menu_showing ;
char_u wim_flags[4]  ;
char_u e_nomatch2[13] ;
char_u e_toomany[20] ;
long p_hi  ;
int p_is  ;
long p_ls  ;
long p_wc  ;
long p_wcm  ;
int p_wmnu  ;
int put_on_cmdline(char_u *str___1 , int len___0 , int redraw ) ;
void redrawcmdline(void) ;
void compute_cmdrow(void) ;
int ExpandGeneric(vim_regexp *prog , int *num_file , char_u ***file , char_u *(*func)(int  ) ) ;
void remove_key_from_history(void) ;
int get_list_range(char_u **str___1 , int *num1 , int *num2 ) ;
char_u *get_augroup_name(int idx ) ;
char_u *get_event_name(int idx ) ;
int inchar(char_u *buf___3 , int maxlen , long wait_time ) ;
int ExpandMappings(vim_regexp *prog , int *num_file , char_u ***file ) ;
char_u *get_menu_name(int idx ) ;
char_u *get_menu_names(int idx ) ;
int msg_outtrans_len(char_u *str___1 , int len___0 ) ;
void msg_puts_long_attr(char_u *longstr , int attr ) ;
void msg_check(void) ;
int match_suffix(char_u *fname ) ;
void vim_strncpy(char_u *to , char_u *from , int len___0 ) ;
int cmdline_paste(int regname___0 , int literally ) ;
int ExpandSettings(vim_regexp *prog , int *num_file , char_u ***file ) ;
int ExpandOldSetting(int *num_file , char_u ***file ) ;
void win_redr_status_matches(int num_matches___0 , char_u **matches___0 , int match ) ;
void screen_down(void) ;
char_u *get_syntax_name(int idx ) ;
int expand_tags(int tagnames , char_u *pat , int *num_file , char_u ***file ) ;
void last_status(void) ;
static struct cmdline_info ccline  ;
static int cmd_numfiles  =    -1;
static char_u **cmd_files  =    (char_u **)((void *)0);
static struct hist_entry *history[4]  = {      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0)};
static int hisidx[4]  = {      -1,      -1,      -1,      -1};
static int hisnum[4]  = {      0,      0,      0,      0};
static int hislen  =    0;
static int hist_char2type(int c ) ;
static void init_history(void) ;
static int in_history(int type , char_u *str___1 , int move_to_front ) ;
static int calc_hist_idx(int histype , int num ) ;
static int cmdline_charsize(int idx ) ;
static void set_cmdspos(void) ;
static void set_cmdspos_cursor(void) ;
static void alloc_cmdbuff(int len___0 ) ;
static int realloc_cmdbuff(int len___0 ) ;
static void putcmdline(int c ) ;
static void cmdline_del(int from ) ;
static void redrawcmdprompt(void) ;
static void redrawcmd(void) ;
static void cursorcmd(void) ;
static int ccheck_abbr(int c ) ;
static int nextwild(int type , int options___0 ) ;
static int showmatches(int wildmenu ) ;
static void set_expand_context(void) ;
static int ExpandFromContext(char_u *pat , int *num_file , char_u ***file , int files_only ,
                             int options___0 ) ;
char_u *getcmdline(int firstc , long count___2 , int indent ) 
{ 
  int c ;
  int cc___0 ;
  int i___0 ;
  int j ;
  char_u *p___0 ;
  int hiscnt ;
  char_u *lookfor ;
  int gotesc ;
  int do_abbr ;
  int histype ;
  FPOS old_cursor ;
  colnr_t old_curswant ;
  colnr_t old_leftcol___0 ;
  linenr_t old_topline___0 ;
  linenr_t old_botline ;
  int did_incsearch ;
  int incsearch_postponed ;
  int did_wild_list ;
  int wim_index ;
  int res ;
  int save_msg_scroll ;
  int save_State ;
  int some_key_typed ;
  int ignore_drag_release ;
  int break_ctrl_c ;
  int tmp ;
  int skt ;
  int found ;
  char_u upseg[5] ;
  int found___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int found___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  int p_wmnu_save ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  struct cmdline_info save_ccline ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char_u *tmp___32 ;
  int tmp___33 ;

  {
  lookfor = (char_u *)((void *)0);
  gotesc = 0;
  did_incsearch = 0;
  incsearch_postponed = 0;
  did_wild_list = 0;
  wim_index = 0;
  save_msg_scroll = msg_scroll;
  save_State = State;
  some_key_typed = 0;
  ignore_drag_release = 1;
  break_ctrl_c = 0;
  if (firstc == -1) {
    firstc = '\000';
    break_ctrl_c = 1;
  }
  ccline.overstrike = 0;
  old_cursor = curwin->w_cursor;
  old_curswant = curwin->w_curswant;
  old_leftcol___0 = curwin->w_leftcol;
  old_topline___0 = curwin->w_topline;
  old_botline = curwin->w_botline;
  if (firstc == 64) {
    ccline.cmdfirstc = 0;
  } else {
    ccline.cmdfirstc = firstc;
  }
  ccline.cmdindent = indent;
  if (exmode_active) {
    tmp = 250;
  } else {
    tmp = 0;
  }
  {
  alloc_cmdbuff(tmp);
  }
  if ((unsigned long )ccline.cmdbuff == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  ccline.cmdpos = 0;
  ccline.cmdlen = ccline.cmdpos;
  redir_off = 1;
  i___0 = msg_scrolled;
  msg_scrolled = 0;
  gotocmdline(1);
  msg_scrolled += i___0;
  redrawcmdprompt();
  set_cmdspos();
  expand_context = 0;
  msg_scroll = 0;
  State = 8;
  setmouse();
  init_history();
  hiscnt = hislen;
  histype = hist_char2type(firstc);
  do_digraph(-1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    quit_more = 0;
    cursorcmd();
    c = safe_vgetc();
    }
    if (KeyTyped) {
      some_key_typed = 1;
    }
    if (c == 3) {
      goto _L;
    } else { //Added block
    if (c == intr_char) {
      _L: 
      if (firstc != 64) {
        if (! break_ctrl_c) {
          if (! global_busy) {
            got_int = 0;
          }
        }
      }
    }
    }
    if (lookfor) {
      if (c != 253 + (5 << 8)) {
        if (c != 253 + (4 << 8)) {
          if (c != 107 + (100 << 8)) {
            if (c != 107 + (117 << 8)) {
              if (c != 107 + (78 << 8)) {
                if (c != 107 + (80 << 8)) {
                  if (c != 75 + (53 << 8)) {
                    if (c != 75 + (51 << 8)) {
                      if (c != 107 + (108 << 8)) {
                        if (c != 107 + (114 << 8)) {
                          if (cmd_numfiles > 0) {
                            {
                            vim_free((void *)lookfor);
                            lookfor = (char_u *)((void *)0);
                            }
                          } else { //Added block
                          if (c != 16) {
                            if (c != 14) {
                              {
                              vim_free((void *)lookfor);
                              lookfor = (char_u *)((void *)0);
                              }
                            }
                          }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ((long )c != p_wc) {
      if (c == 253 + (53 << 8)) {
        if (cmd_numfiles != -1) {
          c = 16;
        }
      }
    }
    if (did_wild_list) {
      if (p_wmnu) {
        if (c == 107 + (108 << 8)) {
          c = 16;
        } else { //Added block
        if (c == 107 + (114 << 8)) {
          c = 14;
        }
        }
      }
    }
    if (expand_context == 21) {
      if (p_wmnu) {
        if (ccline.cmdpos > 1) {
          if ((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)) == 46) {
            if ((int )*(ccline.cmdbuff + (ccline.cmdpos - 2)) != 92) {
              if (c == 10) {
                c = 107 + (100 << 8);
              } else { //Added block
              if (c == 13) {
                c = 107 + (100 << 8);
              } else { //Added block
              if (c == 75 + (65 << 8)) {
                c = 107 + (100 << 8);
              }
              }
              }
            }
          }
        }
      }
    }
    if (cmd_numfiles != -1) {
      if ((long )c == p_wc) {
        if (! KeyTyped) {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if ((long )c != p_wcm) {
        if (c != 14) {
          if (c != 16) {
            if (c != 1) {
              if (c != 12) {
                {
                ExpandOne((char_u *)((void *)0), (char_u *)((void *)0), 0, 1);
                did_wild_list = 0;
                }
                if (! p_wmnu) {
                  expand_context = 0;
                } else { //Added block
                if (c != 107 + (117 << 8)) {
                  if (c != 107 + (100 << 8)) {
                    expand_context = 0;
                  }
                }
                }
                wim_index = 0;
                if (p_wmnu) {
                  if (wild_menu_showing) {
                    skt = KeyTyped;
                    if (wild_menu_showing == 2) {
                      {
                      cmdline_row --;
                      redrawcmd();
                      }
                    } else { //Added block
                    if (save_p_ls != -1) {
                      {
                      p_ls = (long )save_p_ls;
                      last_status();
                      update_screen(10);
                      redrawcmd();
                      save_p_ls = -1;
                      }
                    } else {
                      {
                      win_redr_status(lastwin);
                      }
                    }
                    }
                    KeyTyped = skt;
                    wild_menu_showing = 0;
                  }
                }
              }
            }
          }
        }
      }
      }
    }
    if (expand_context == 21) {
      if (p_wmnu) {
        if ((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)) == 46) {
          if (c == 107 + (100 << 8)) {
            c = (int )p_wc;
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if (c == 107 + (117 << 8)) {
          found = 0;
          j = (int )(expand_pattern - ccline.cmdbuff);
          i___0 = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            j --;
            if (! (j > 0)) {
              goto while_break___0;
            }
            if ((int )*(ccline.cmdbuff + j) == 32) {
              if ((int )*(ccline.cmdbuff + (j - 1)) != 92) {
                i___0 = j + 1;
                goto while_break___0;
              }
            }
            if ((int )*(ccline.cmdbuff + j) == 46) {
              if ((int )*(ccline.cmdbuff + (j - 1)) != 92) {
                if (found) {
                  i___0 = j + 1;
                  goto while_break___0;
                } else {
                  found = 1;
                }
              }
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          if (i___0 > 0) {
            {
            cmdline_del(i___0);
            }
          }
          c = (int )p_wc;
          expand_context = 0;
        }
        }
      }
    }
    if (expand_context == 2) {
      if (p_wmnu) {
        upseg[0] = (char_u )'/';
        upseg[1] = (char_u )'.';
        upseg[2] = (char_u )'.';
        upseg[3] = (char_u )'/';
        upseg[4] = (char_u )'\000';
        if ((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)) == 47) {
          if (c == 107 + (100 << 8)) {
            if ((int )*(ccline.cmdbuff + (ccline.cmdpos - 2)) != 46) {
              c = (int )p_wc;
            } else { //Added block
            if ((int )*(ccline.cmdbuff + (ccline.cmdpos - 3)) != 46) {
              c = (int )p_wc;
            } else {
              goto _L___4;
            }
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          {
          tmp___5 = strncmp((char const   *)((char *)expand_pattern), (char const   *)((char *)(upseg + 1)),
                            (size_t )3);
          }
          if (tmp___5 == 0) {
            if (c == 107 + (100 << 8)) {
              found___0 = 0;
              j = ccline.cmdpos;
              i___0 = (int )(expand_pattern - ccline.cmdbuff);
              {
              while (1) {
                while_continue___1: /* CIL Label */ ;
                j --;
                if (! (j > i___0)) {
                  goto while_break___1;
                }
                {
                tmp___0 = vim_ispathsep((int )*(ccline.cmdbuff + j));
                }
                if (tmp___0) {
                  found___0 = 1;
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
              if (found___0) {
                if ((int )*(ccline.cmdbuff + (j - 1)) == 46) {
                  if ((int )*(ccline.cmdbuff + (j - 2)) == 46) {
                    {
                    tmp___1 = vim_ispathsep((int )*(ccline.cmdbuff + (j - 3)));
                    }
                    if (tmp___1) {
                      {
                      cmdline_del(j - 2);
                      c = (int )p_wc;
                      }
                    } else { //Added block
                    if (j == i___0 + 2) {
                      {
                      cmdline_del(j - 2);
                      c = (int )p_wc;
                      }
                    }
                    }
                  }
                }
              }
            } else {
              goto _L___2;
            }
          } else { //Added block
          _L___2: 
          if (c == 107 + (117 << 8)) {
            found___1 = 0;
            j = ccline.cmdpos - 1;
            i___0 = (int )(expand_pattern - ccline.cmdbuff);
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              j --;
              if (! (j > i___0)) {
                goto while_break___2;
              }
              {
              tmp___2 = vim_ispathsep((int )*(ccline.cmdbuff + j));
              }
              if (tmp___2) {
                if (found___1) {
                  i___0 = j + 1;
                  goto while_break___2;
                } else {
                  found___1 = 1;
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            if (! found___1) {
              j = i___0;
            } else {
              {
              tmp___4 = strncmp((char const   *)((char *)(ccline.cmdbuff + j)), (char const   *)((char *)(upseg)),
                                (size_t )4);
              }
              if (tmp___4 == 0) {
                j += 4;
              } else {
                {
                tmp___3 = strncmp((char const   *)((char *)(ccline.cmdbuff + j)),
                                  (char const   *)((char *)(upseg + 1)), (size_t )3);
                }
                if (tmp___3 == 0) {
                  if (j == i___0) {
                    j += 3;
                  } else {
                    j = 0;
                  }
                } else {
                  j = 0;
                }
              }
            }
            if (j > 0) {
              {
              cmdline_del(j);
              put_on_cmdline(upseg + 1, 3, 0);
              }
            } else { //Added block
            if (ccline.cmdpos > i___0) {
              {
              cmdline_del(i___0);
              }
            }
            }
            c = (int )p_wc;
          }
          }
        }
      }
    }
    if (c == 28) {
      {
      c = safe_vgetc();
      }
      if (c != 14) {
        {
        vungetc(c);
        c = 28;
        }
      } else {
        gotesc = 1;
        goto returncmd;
      }
    }
    {
    c = do_digraph(c);
    }
    if (c == 10) {
      goto _L___6;
    } else { //Added block
    if (c == 13) {
      goto _L___6;
    } else { //Added block
    if (c == 75 + (65 << 8)) {
      goto _L___6;
    } else { //Added block
    if (c == 27) {
      if (! KeyTyped) {
        goto _L___6;
      } else {
        {
        tmp___7 = vim_strchr(p_cpo, 'x');
        }
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
          _L___6: 
          {
          gotesc = 0;
          tmp___6 = ccheck_abbr(c + 256);
          }
          if (tmp___6) {
            goto cmdline_changed;
          }
          {
          windgoto(msg_row, 0);
          out_flush();
          }
          goto while_break;
        }
      }
    }
    }
    }
    }
    if ((long )c == p_wc) {
      if (! gotesc) {
        if (KeyTyped) {
          goto _L___9;
        } else {
          goto _L___11;
        }
      } else {
        goto _L___11;
      }
    } else { //Added block
    _L___11: 
    if ((long )c == p_wcm) {
      _L___9: 
      if (cmd_numfiles > 0) {
        if (cmd_numfiles > 1) {
          if (! did_wild_list) {
            if ((int )wim_flags[wim_index] & 4) {
              {
              showmatches(0);
              redrawcmd();
              did_wild_list = 1;
              }
            }
          }
        }
        if ((int )wim_flags[wim_index] & 2) {
          {
          res = nextwild(7, 8);
          }
        } else { //Added block
        if ((int )wim_flags[wim_index] & 1) {
          {
          res = nextwild(4, 8);
          }
        } else {
          res = 1;
        }
        }
      } else {
        wim_index = 0;
        j = ccline.cmdpos;
        if ((int )wim_flags[0] & 2) {
          {
          res = nextwild(7, 8);
          }
        } else {
          {
          res = nextwild(3, 8);
          }
        }
        if (got_int) {
          {
          vpeekc();
          got_int = 0;
          ExpandOne((char_u *)((void *)0), (char_u *)((void *)0), 0, 1);
          expand_context = 0;
          }
          goto cmdline_changed;
        }
        if (res == 1) {
          if (cmd_numfiles > 1) {
            if ((int )wim_flags[0] == 2) {
              if (ccline.cmdpos == j) {
                wim_index = 1;
              }
            }
            if ((int )wim_flags[wim_index] & 4) {
              goto _L___7;
            } else { //Added block
            if (p_wmnu) {
              if (((int )wim_flags[wim_index] & 1) != 0) {
                _L___7: 
                if (! ((int )wim_flags[0] & 2)) {
                  {
                  p_wmnu_save = p_wmnu;
                  p_wmnu = 0;
                  nextwild(5, 0);
                  p_wmnu = p_wmnu_save;
                  }
                }
                if (p_wmnu) {
                  if (((int )wim_flags[wim_index] & 4) == 0) {
                    tmp___8 = 1;
                  } else {
                    tmp___8 = 0;
                  }
                } else {
                  tmp___8 = 0;
                }
                {
                showmatches(tmp___8);
                redrawcmd();
                did_wild_list = 1;
                }
                if ((int )wim_flags[wim_index] & 2) {
                  {
                  nextwild(7, 8);
                  }
                } else { //Added block
                if ((int )wim_flags[wim_index] & 1) {
                  {
                  nextwild(4, 8);
                  }
                }
                }
              } else {
                {
                vim_beep();
                }
              }
            } else {
              {
              vim_beep();
              }
            }
            }
          } else {
            goto _L___8;
          }
        } else { //Added block
        _L___8: 
        if (cmd_numfiles == -1) {
          expand_context = 0;
        }
        }
      }
      if (wim_index < 3) {
        wim_index ++;
      }
      if (c == 27) {
        gotesc = 1;
      }
      if (res == 1) {
        goto cmdline_changed;
      }
    }
    }
    gotesc = 0;
    if (c == 253 + (53 << 8)) {
      if (KeyTyped) {
        {
        tmp___9 = nextwild(3, 0);
        }
        if (tmp___9 == 1) {
          {
          tmp___10 = nextwild(5, 0);
          }
          if (tmp___10 == 1) {
            {
            tmp___11 = nextwild(5, 0);
            }
            if (tmp___11 == 1) {
              goto cmdline_changed;
            }
          }
        }
      }
    }
    if (c == 0) {
      c = '\n';
    } else { //Added block
    if (c == 255 + (88 << 8)) {
      c = '\n';
    }
    }
    do_abbr = 1;
    {
    if (c == 107 + (98 << 8)) {
      goto case_exp;
    }
    if (c == 8) {
      goto case_exp;
    }
    if (c == 107 + (68 << 8)) {
      goto case_exp;
    }
    if (c == 253 + (70 << 8)) {
      goto case_exp;
    }
    if (c == 23) {
      goto case_exp;
    }
    if (c == 107 + (73 << 8)) {
      goto case_exp___2;
    }
    if (c == 253 + (69 << 8)) {
      goto case_exp___2;
    }
    if (c == 21) {
      goto case_21;
    }
    if (c == 27) {
      goto case_27;
    }
    if (c == 3) {
      goto case_27;
    }
    if (c == 18) {
      goto case_18;
    }
    if (c == 4) {
      goto case_4;
    }
    if (c == 107 + (114 << 8)) {
      goto case_exp___4;
    }
    if (c == 37 + (105 << 8)) {
      goto case_exp___4;
    }
    if (c == 107 + (108 << 8)) {
      goto case_exp___6;
    }
    if (c == 35 + (52 << 8)) {
      goto case_exp___6;
    }
    if (c == 253 + (51 << 8)) {
      goto case_exp___8;
    }
    if (c == 253 + (46 << 8)) {
      goto case_exp___8;
    }
    if (c == 253 + (47 << 8)) {
      goto case_exp___8;
    }
    if (c == 253 + (45 << 8)) {
      goto case_exp___11;
    }
    if (c == 253 + (43 << 8)) {
      goto case_exp___12;
    }
    if (c == 253 + (44 << 8)) {
      goto case_exp___12;
    }
    if (c == 253 + (49 << 8)) {
      goto case_exp___12;
    }
    if (c == 253 + (50 << 8)) {
      goto case_exp___12;
    }
    if (c == 253 + (42 << 8)) {
      goto case_exp___16;
    }
    if (c == 253 + (48 << 8)) {
      goto case_exp___16;
    }
    if (c == 253 + (67 << 8)) {
      goto case_exp___18;
    }
    if (c == 253 + (68 << 8)) {
      goto case_exp___18;
    }
    if (c == 245 + (88 << 8)) {
      goto case_exp___20;
    }
    if (c == 2) {
      goto case_2;
    }
    if (c == 107 + (104 << 8)) {
      goto case_2;
    }
    if (c == 75 + (49 << 8)) {
      goto case_2;
    }
    if (c == 253 + (60 << 8)) {
      goto case_2;
    }
    if (c == 35 + (50 << 8)) {
      goto case_2;
    }
    if (c == 5) {
      goto case_5;
    }
    if (c == 64 + (55 << 8)) {
      goto case_5;
    }
    if (c == 75 + (52 << 8)) {
      goto case_5;
    }
    if (c == 253 + (59 << 8)) {
      goto case_5;
    }
    if (c == 42 + (55 << 8)) {
      goto case_5;
    }
    if (c == 1) {
      goto case_1;
    }
    if (c == 12) {
      goto case_12;
    }
    if (c == 14) {
      goto case_14;
    }
    if (c == 16) {
      goto case_14;
    }
    if (c == 107 + (117 << 8)) {
      goto case_exp___29;
    }
    if (c == 107 + (100 << 8)) {
      goto case_exp___29;
    }
    if (c == 253 + (4 << 8)) {
      goto case_exp___29;
    }
    if (c == 253 + (5 << 8)) {
      goto case_exp___29;
    }
    if (c == 107 + (80 << 8)) {
      goto case_exp___29;
    }
    if (c == 75 + (51 << 8)) {
      goto case_exp___29;
    }
    if (c == 107 + (78 << 8)) {
      goto case_exp___29;
    }
    if (c == 75 + (53 << 8)) {
      goto case_exp___29;
    }
    if (c == 22) {
      goto case_22;
    }
    if (c == 17) {
      goto case_22;
    }
    if (c == 11) {
      goto case_11;
    }
    if (c == 75 + (54 << 8)) {
      goto case_exp___37;
    }
    if (c == 75 + (55 << 8)) {
      goto case_exp___38;
    }
    if (c == 75 + (56 << 8)) {
      goto case_exp___39;
    }
    if (c == 75 + (57 << 8)) {
      goto case_exp___40;
    }
    goto switch_default;
    case_exp: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
    case_23: /* CIL Label */ 
    if (c == 253 + (70 << 8)) {
      c = 107 + (68 << 8);
    }
    if (c == 107 + (68 << 8)) {
      if (ccline.cmdpos != ccline.cmdlen) {
        (ccline.cmdpos) ++;
      }
    }
    if (ccline.cmdpos > 0) {
      j = ccline.cmdpos;
      if (c == 23) {
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (ccline.cmdpos) {
            {
            tmp___12 = vim_isspace((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)));
            }
            if (! tmp___12) {
              goto while_break___3;
            }
          } else {
            goto while_break___3;
          }
          (ccline.cmdpos) --;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
        i___0 = vim_iswordc((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)));
        }
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          if (ccline.cmdpos) {
            {
            tmp___13 = vim_isspace((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)));
            }
            if (tmp___13) {
              goto while_break___4;
            } else {
              {
              tmp___14 = vim_iswordc((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)));
              }
              if (! (tmp___14 == i___0)) {
                goto while_break___4;
              }
            }
          } else {
            goto while_break___4;
          }
          (ccline.cmdpos) --;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        (ccline.cmdpos) --;
      }
      ccline.cmdlen -= j - ccline.cmdpos;
      i___0 = ccline.cmdpos;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! (i___0 < ccline.cmdlen)) {
          goto while_break___5;
        }
        tmp___15 = i___0;
        i___0 ++;
        tmp___16 = j;
        j ++;
        *(ccline.cmdbuff + tmp___15) = *(ccline.cmdbuff + tmp___16);
      }
      while_break___5: /* CIL Label */ ;
      }
      {
      redrawcmd();
      }
    } else { //Added block
    if (ccline.cmdlen == 0) {
      if (c != 23) {
        if ((unsigned long )ccline.cmdprompt == (unsigned long )((void *)0)) {
          if (indent == 0) {
            {
            vim_free((void *)ccline.cmdbuff);
            ccline.cmdbuff = (char_u *)((void *)0);
            msg_col = 0;
            msg_putchar(' ');
            redraw_cmdline = 1;
            }
            goto returncmd;
          }
        }
      }
    }
    }
    goto cmdline_changed;
    case_exp___2: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
    ccline.overstrike = ! ccline.overstrike;
    goto cmdline_not_changed;
    case_21: /* CIL Label */ 
    {
    ccline.cmdpos = 0;
    ccline.cmdlen = 0;
    redrawcmd();
    }
    goto cmdline_changed;
    case_27: /* CIL Label */ 
    case_3: /* CIL Label */ 
    gotesc = 1;
    goto returncmd;
    case_18: /* CIL Label */ 
    {
    putcmdline('\"');
    no_mapping ++;
    c = safe_vgetc();
    i___0 = c;
    }
    if (c == 18) {
      {
      c = safe_vgetc();
      }
    }
    no_mapping --;
    if (c == 61) {
      if (ccline.cmdfirstc == 61) {
        {
        beep_flush();
        c = '\033';
        }
      } else {
        {
        save_ccline = ccline;
        ccline.cmdbuff = (char_u *)((void *)0);
        ccline.cmdprompt = (char_u *)((void *)0);
        c = get_expr_register();
        ccline = save_ccline;
        }
      }
    }
    if (c != 27) {
      {
      cmdline_paste(c, i___0 == 18);
      }
    }
    {
    redrawcmd();
    }
    goto cmdline_changed;
    case_4: /* CIL Label */ 
    {
    tmp___17 = showmatches(0);
    }
    if (tmp___17 == 0) {
      goto switch_break;
    }
    {
    redrawcmd();
    }
    goto __Cont;
    case_exp___4: /* CIL Label */ 
    case_exp___5: /* CIL Label */ 
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (! (! (ccline.cmdpos >= ccline.cmdlen))) {
        goto while_break___6;
      }
      {
      i___0 = cmdline_charsize(ccline.cmdpos);
      }
      if (KeyTyped) {
        if ((long )(ccline.cmdspos + i___0) >= Columns * Rows) {
          goto while_break___6;
        }
      }
      ccline.cmdspos += i___0;
      (ccline.cmdpos) ++;
      if (c == 37 + (105 << 8)) {
        goto _L___12;
      } else { //Added block
      if (mod_mask & 4) {
        _L___12: 
        if (! ((int )*(ccline.cmdbuff + ccline.cmdpos) != 32)) {
          goto while_break___6;
        }
      } else {
        goto while_break___6;
      }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    goto cmdline_not_changed;
    case_exp___6: /* CIL Label */ 
    case_exp___7: /* CIL Label */ 
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      if (! (! (ccline.cmdpos <= 0))) {
        goto while_break___7;
      }
      {
      (ccline.cmdpos) --;
      tmp___18 = cmdline_charsize(ccline.cmdpos);
      ccline.cmdspos -= tmp___18;
      }
      if (c == 35 + (52 << 8)) {
        goto _L___13;
      } else { //Added block
      if (mod_mask & 4) {
        _L___13: 
        if (! ((int )*(ccline.cmdbuff + (ccline.cmdpos - 1)) != 32)) {
          goto while_break___7;
        }
      } else {
        goto while_break___7;
      }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    goto cmdline_not_changed;
    case_exp___8: /* CIL Label */ 
    case_exp___9: /* CIL Label */ 
    case_exp___10: /* CIL Label */ 
    goto cmdline_not_changed;
    case_exp___11: /* CIL Label */ 
    {
    tmp___19 = mouse_has('c');
    }
    if (! tmp___19) {
      goto cmdline_not_changed;
    }
    {
    cmdline_paste(0, 1);
    redrawcmd();
    }
    goto cmdline_changed;
    case_exp___12: /* CIL Label */ 
    case_exp___13: /* CIL Label */ 
    case_exp___14: /* CIL Label */ 
    case_exp___15: /* CIL Label */ 
    if (ignore_drag_release) {
      goto cmdline_not_changed;
    }
    case_exp___16: /* CIL Label */ 
    case_exp___17: /* CIL Label */ 
    if (c == 253 + (44 << 8)) {
      ignore_drag_release = 1;
    } else { //Added block
    if (c == 253 + (50 << 8)) {
      ignore_drag_release = 1;
    } else {
      ignore_drag_release = 0;
    }
    }
    {
    tmp___20 = mouse_has('c');
    }
    if (! tmp___20) {
      goto cmdline_not_changed;
    }
    {
    set_cmdspos();
    ccline.cmdpos = 0;
    }
    {
    while (1) {
      while_continue___8: /* CIL Label */ ;
      if (! (ccline.cmdpos < ccline.cmdlen)) {
        goto while_break___8;
      }
      {
      i___0 = cmdline_charsize(ccline.cmdpos);
      }
      if ((long )mouse_row <= (long )cmdline_row + (long )ccline.cmdspos / Columns) {
        if ((long )mouse_col < (long )ccline.cmdspos % Columns + (long )i___0) {
          goto while_break___8;
        }
      }
      ccline.cmdspos += i___0;
      (ccline.cmdpos) ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    goto cmdline_not_changed;
    case_exp___18: /* CIL Label */ 
    case_exp___19: /* CIL Label */ 
    goto cmdline_not_changed;
    case_exp___20: /* CIL Label */ 
    goto cmdline_not_changed;
    case_2: /* CIL Label */ 
    case_exp___21: /* CIL Label */ 
    case_exp___22: /* CIL Label */ 
    case_exp___23: /* CIL Label */ 
    case_exp___24: /* CIL Label */ 
    {
    ccline.cmdpos = 0;
    set_cmdspos();
    }
    goto cmdline_not_changed;
    case_5: /* CIL Label */ 
    case_exp___25: /* CIL Label */ 
    case_exp___26: /* CIL Label */ 
    case_exp___27: /* CIL Label */ 
    case_exp___28: /* CIL Label */ 
    {
    ccline.cmdpos = ccline.cmdlen;
    *(ccline.cmdbuff + ccline.cmdlen) = (char_u )'\000';
    set_cmdspos_cursor();
    }
    goto cmdline_not_changed;
    case_1: /* CIL Label */ 
    {
    tmp___21 = nextwild(6, 0);
    }
    if (tmp___21 == 0) {
      goto switch_break;
    }
    goto cmdline_changed;
    case_12: /* CIL Label */ 
    {
    tmp___22 = nextwild(7, 0);
    }
    if (tmp___22 == 0) {
      goto switch_break;
    }
    goto cmdline_changed;
    case_14: /* CIL Label */ 
    case_16: /* CIL Label */ 
    if (cmd_numfiles > 0) {
      if (c == 16) {
        tmp___23 = 5;
      } else {
        tmp___23 = 4;
      }
      {
      tmp___24 = nextwild(tmp___23, 0);
      }
      if (tmp___24 == 0) {
        goto switch_break;
      }
      goto cmdline_changed;
    }
    case_exp___29: /* CIL Label */ 
    case_exp___30: /* CIL Label */ 
    case_exp___31: /* CIL Label */ 
    case_exp___32: /* CIL Label */ 
    case_exp___33: /* CIL Label */ 
    case_exp___34: /* CIL Label */ 
    case_exp___35: /* CIL Label */ 
    case_exp___36: /* CIL Label */ 
    if (hislen == 0) {
      goto cmdline_not_changed;
    } else { //Added block
    if (firstc == 0) {
      goto cmdline_not_changed;
    }
    }
    i___0 = hiscnt;
    *(ccline.cmdbuff + ccline.cmdlen) = (char_u )'\000';
    if ((unsigned long )lookfor == (unsigned long )((void *)0)) {
      {
      lookfor = vim_strsave(ccline.cmdbuff);
      }
      if ((unsigned long )lookfor == (unsigned long )((void *)0)) {
        goto cmdline_not_changed;
      }
      *(lookfor + ccline.cmdpos) = (char_u )'\000';
    }
    {
    tmp___25 = strlen((char const   *)((char *)lookfor));
    j = (int )tmp___25;
    }
    {
    while (1) {
      while_continue___9: /* CIL Label */ ;
      if (c == 107 + (117 << 8)) {
        goto _L___15;
      } else { //Added block
      if (c == 253 + (4 << 8)) {
        goto _L___15;
      } else { //Added block
      if (c == 16) {
        goto _L___15;
      } else { //Added block
      if (c == 107 + (80 << 8)) {
        goto _L___15;
      } else { //Added block
      if (c == 75 + (51 << 8)) {
        _L___15: 
        if (hiscnt == hislen) {
          hiscnt = hisidx[histype];
        } else { //Added block
        if (hiscnt == 0) {
          if (hisidx[histype] != hislen - 1) {
            hiscnt = hislen - 1;
          } else {
            goto _L___14;
          }
        } else { //Added block
        _L___14: 
        if (hiscnt != hisidx[histype] + 1) {
          hiscnt --;
        } else {
          hiscnt = i___0;
          goto while_break___9;
        }
        }
        }
      } else {
        if (hiscnt == hisidx[histype]) {
          hiscnt = hislen;
          goto while_break___9;
        }
        if (hiscnt == hislen) {
          goto while_break___9;
        }
        if (hiscnt == hislen - 1) {
          hiscnt = 0;
        } else {
          hiscnt ++;
        }
      }
      }
      }
      }
      }
      if (hiscnt < 0) {
        hiscnt = i___0;
        goto while_break___9;
      } else { //Added block
      if ((unsigned long )(history[histype] + hiscnt)->hisstr == (unsigned long )((void *)0)) {
        hiscnt = i___0;
        goto while_break___9;
      }
      }
      if (c != 107 + (117 << 8)) {
        if (c != 107 + (100 << 8)) {
          goto while_break___9;
        } else {
          goto _L___16;
        }
      } else { //Added block
      _L___16: 
      if (hiscnt == i___0) {
        goto while_break___9;
      } else {
        {
        tmp___26 = strncmp((char const   *)((char *)(history[histype] + hiscnt)->hisstr),
                           (char const   *)((char *)lookfor), (size_t )j);
        }
        if (tmp___26 == 0) {
          goto while_break___9;
        }
      }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    if (hiscnt != i___0) {
      {
      vim_free((void *)ccline.cmdbuff);
      }
      if (hiscnt == hislen) {
        p___0 = lookfor;
      } else {
        p___0 = (history[histype] + hiscnt)->hisstr;
      }
      {
      tmp___27 = strlen((char const   *)((char *)p___0));
      alloc_cmdbuff((int )tmp___27);
      }
      if ((unsigned long )ccline.cmdbuff == (unsigned long )((void *)0)) {
        goto returncmd;
      }
      {
      strcpy((char * __restrict  )((char *)ccline.cmdbuff), (char const   * __restrict  )((char *)p___0));
      tmp___28 = strlen((char const   *)((char *)ccline.cmdbuff));
      ccline.cmdlen = (int )tmp___28;
      ccline.cmdpos = ccline.cmdlen;
      redrawcmd();
      }
      goto cmdline_changed;
    }
    {
    beep_flush();
    }
    goto cmdline_not_changed;
    case_22: /* CIL Label */ 
    case_17: /* CIL Label */ 
    {
    ignore_drag_release = 1;
    putcmdline('^');
    c = get_literal();
    do_abbr = 0;
    }
    goto switch_break;
    case_11: /* CIL Label */ 
    {
    ignore_drag_release = 1;
    putcmdline('?');
    no_mapping ++;
    allow_keys ++;
    c = safe_vgetc();
    no_mapping --;
    allow_keys --;
    }
    if (c != 27) {
      if (c >= 512) {
        goto switch_break;
      }
      {
      tmp___29 = charsize(c);
      }
      if (tmp___29 == 1) {
        {
        putcmdline(c);
        }
      }
      {
      no_mapping ++;
      allow_keys ++;
      cc___0 = safe_vgetc();
      no_mapping --;
      allow_keys --;
      }
      if (cc___0 != 27) {
        {
        c = getdigraph(c, cc___0, 1);
        }
        goto switch_break;
      }
    }
    {
    redrawcmd();
    }
    goto cmdline_not_changed;
    case_exp___37: /* CIL Label */ 
    c = '+';
    goto switch_break;
    case_exp___38: /* CIL Label */ 
    c = '-';
    goto switch_break;
    case_exp___39: /* CIL Label */ 
    c = '/';
    goto switch_break;
    case_exp___40: /* CIL Label */ 
    c = '*';
    goto switch_break;
    switch_default: /* CIL Label */ 
    if (c == intr_char) {
      gotesc = 1;
      goto returncmd;
    }
    if (! (c >= 512)) {
      mod_mask = 0;
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    if (do_abbr) {
      if (c >= 512) {
        goto _L___17;
      } else {
        {
        tmp___30 = vim_iswordc(c);
        }
        if (! tmp___30) {
          _L___17: 
          {
          tmp___31 = ccheck_abbr(c);
          }
          if (tmp___31) {
            goto cmdline_changed;
          }
        }
      }
    }
    if (c >= 512) {
      {
      tmp___32 = get_special_key_name(c, mod_mask);
      put_on_cmdline(tmp___32, -1, 1);
      }
    } else { //Added block
    if (mod_mask != 0) {
      {
      tmp___32 = get_special_key_name(c, mod_mask);
      put_on_cmdline(tmp___32, -1, 1);
      }
    } else {
      {
      *(IObuff + 0) = (char_u )c;
      put_on_cmdline(IObuff, 1, 1);
      }
    }
    }
    goto cmdline_changed;
    cmdline_not_changed: 
    if (! incsearch_postponed) {
      goto __Cont;
    }
    cmdline_changed: 
    if (p_is) {
      if (firstc == 47) {
        goto _L___18;
      } else { //Added block
      if (firstc == 63) {
        _L___18: 
        {
        tmp___33 = char_avail();
        }
        if (tmp___33) {
          incsearch_postponed = 1;
          goto __Cont;
        }
        incsearch_postponed = 0;
        curwin->w_cursor = old_cursor;
        if (ccline.cmdlen == 0) {
          i___0 = 0;
        } else {
          {
          *(ccline.cmdbuff + ccline.cmdlen) = (char_u )'\000';
          emsg_off ++;
          i___0 = do_search((OPARG *)((void *)0), firstc, ccline.cmdbuff, count___2,
                            1168);
          emsg_off --;
          }
        }
        if (i___0) {
          highlight_match = 1;
        } else {
          highlight_match = 0;
        }
        {
        curwin->w_leftcol = old_leftcol___0;
        curwin->w_topline = old_topline___0;
        curwin->w_botline = old_botline;
        update_topline();
        curwin->w_cursor.col += (colnr_t )search_match_len;
        validate_cursor();
        curwin->w_cursor.col -= (colnr_t )search_match_len;
        validate_cursor();
        update_screen(40);
        redrawcmdline();
        did_incsearch = 1;
        }
      }
      }
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  returncmd: 
  if (did_incsearch) {
    {
    curwin->w_cursor = old_cursor;
    curwin->w_curswant = old_curswant;
    curwin->w_leftcol = old_leftcol___0;
    curwin->w_topline = old_topline___0;
    curwin->w_botline = old_botline;
    highlight_match = 0;
    validate_cursor();
    redraw_later(40);
    }
  }
  if ((unsigned long )ccline.cmdbuff != (unsigned long )((void *)0)) {
    *(ccline.cmdbuff + ccline.cmdlen) = (char_u )'\000';
    if (ccline.cmdlen) {
      if (firstc) {
        if (some_key_typed) {
          goto _L___19;
        } else { //Added block
        if (histype == 1) {
          _L___19: 
          {
          add_to_history(histype, ccline.cmdbuff, 1);
          }
          if (firstc == 58) {
            {
            vim_free((void *)new_last_cmdline);
            new_last_cmdline = vim_strsave(ccline.cmdbuff);
            }
          }
        }
        }
      }
    }
    if (gotesc) {
      {
      vim_free((void *)ccline.cmdbuff);
      ccline.cmdbuff = (char_u *)((void *)0);
      msg((char_u *)"");
      redraw_cmdline = 1;
      }
    }
  }
  {
  msg_check();
  msg_scroll = save_msg_scroll;
  redir_off = 0;
  }
  if (some_key_typed) {
    need_wait_return = 0;
  }
  {
  State = save_State;
  setmouse();
  }
  return (ccline.cmdbuff);
}
}
char_u *getcmdline_prompt(int firstc , char_u *prompt , int attr ) 
{ 
  char_u *s ;
  struct cmdline_info save_ccline ;

  {
  {
  save_ccline = ccline;
  ccline.cmdbuff = (char_u *)((void *)0);
  ccline.cmdprompt = prompt;
  ccline.cmdattr = attr;
  s = getcmdline(firstc, 1L, 0);
  ccline = save_ccline;
  }
  return (s);
}
}
static int cmdline_charsize(int idx ) 
{ 
  int tmp ;

  {
  if (cmdline_crypt) {
    return (1);
  }
  {
  tmp = charsize((int )*(ccline.cmdbuff + idx));
  }
  return (tmp);
}
}
static void set_cmdspos(void) 
{ 


  {
  if (ccline.cmdfirstc) {
    ccline.cmdspos = 1 + ccline.cmdindent;
  } else {
    ccline.cmdspos = ccline.cmdindent;
  }
  return;
}
}
static void set_cmdspos_cursor(void) 
{ 
  int i___0 ;
  int m ;
  int c ;

  {
  {
  set_cmdspos();
  }
  if (KeyTyped) {
    m = (int )(Columns * Rows);
  } else {
    m = 2147483647;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (i___0 < ccline.cmdlen) {
      if (! (i___0 < ccline.cmdpos)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (cmdline_crypt) {
      c = 1;
    } else {
      {
      c = charsize((int )*(ccline.cmdbuff + i___0));
      }
    }
    ccline.cmdspos += c;
    if (ccline.cmdspos >= m) {
      ccline.cmdpos = i___0 - 1;
      ccline.cmdspos -= c;
      goto while_break;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
char_u *getexline(int c , void *dummy , int indent ) 
{ 
  int tmp ;
  char_u *tmp___0 ;

  {
  if (exec_from_reg) {
    {
    tmp = vpeekc();
    }
    if (tmp == 58) {
      {
      vgetc();
      }
    }
  }
  {
  tmp___0 = getcmdline(c, 1L, indent);
  }
  return (tmp___0);
}
}
char_u *getexmodeline(int c , void *dummy , int indent ) 
{ 
  struct growarray line_ga ;
  int len___0 ;
  int off___0 ;
  char_u *p___0 ;
  int finished ;
  int tmp ;
  int tmp___0 ;

  {
  {
  off___0 = 0;
  finished = 0;
  cursor_on();
  compute_cmdrow();
  }
  if (msg_col) {
    {
    msg_putchar('\n');
    }
  }
  if (c == 58) {
    {
    msg_putchar(':');
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp = indent;
      indent --;
      if (! (tmp > 0)) {
        goto while_break;
      }
      {
      msg_putchar(' ');
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  ga_init2(& line_ga, 1, 30);
  got_int = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! got_int) {
      if (! (! finished)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    tmp___0 = ga_grow(& line_ga, 40);
    }
    if (tmp___0 == 0) {
      goto while_break___0;
    }
    {
    p___0 = (char_u *)line_ga.ga_data + line_ga.ga_len;
    len___0 = inchar(p___0 + off___0, 3, -1L);
    }
    if (len___0 < 0) {
      goto while_continue___0;
    }
    if ((int )*p___0 == 128) {
      goto _L;
    } else { //Added block
    if ((int )*p___0 == 155) {
      _L: 
      if (off___0 + len___0 < 3) {
        off___0 += len___0;
        goto while_continue___0;
      }
    }
    }
    len___0 += off___0;
    off___0 = 0;
    line_ga.ga_len += len___0;
    line_ga.ga_room -= len___0;
    p___0 = (char_u *)line_ga.ga_data + line_ga.ga_len;
    if (line_ga.ga_len) {
      if ((int )*(p___0 + -1) == 10) {
        finished = 1;
        (line_ga.ga_len) --;
        p___0 --;
        *p___0 = (char_u )'\000';
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  screen_down();
  msg_didout = 0;
  msg_col = 0;
  }
  if ((long )msg_row < Rows - 1L) {
    msg_row ++;
  }
  emsg_on_display = 0;
  if (got_int) {
    {
    ga_clear(& line_ga);
    }
  }
  return ((char_u *)line_ga.ga_data);
}
}
static void alloc_cmdbuff(int len___0 ) 
{ 


  {
  if (len___0 < 80) {
    len___0 = 100;
  } else {
    len___0 += 20;
  }
  {
  ccline.cmdbuff = alloc((unsigned int )len___0);
  ccline.cmdbufflen = len___0;
  }
  return;
}
}
static int realloc_cmdbuff(int len___0 ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = ccline.cmdbuff;
  alloc_cmdbuff(len___0);
  }
  if ((unsigned long )ccline.cmdbuff == (unsigned long )((void *)0)) {
    ccline.cmdbuff = p___0;
    return (0);
  }
  {
  memmove((void *)((char *)ccline.cmdbuff), (void const   *)((char *)p___0), (size_t )ccline.cmdlen);
  vim_free((void *)p___0);
  }
  return (1);
}
}
static void putcmdline(int c ) 
{ 
  char_u buf___3[1] ;

  {
  {
  msg_no_more = 1;
  buf___3[0] = (char_u )c;
  msg_outtrans_len(buf___3, 1);
  msg_outtrans_len(ccline.cmdbuff + ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);
  msg_no_more = 0;
  cursorcmd();
  }
  return;
}
}
int put_on_cmdline(char_u *str___1 , int len___0 , int redraw ) 
{ 
  int retval ;
  int i___0 ;
  int m ;
  int c ;
  size_t tmp ;

  {
  if (len___0 < 0) {
    {
    tmp = strlen((char const   *)((char *)str___1));
    len___0 = (int )tmp;
    }
  }
  if ((ccline.cmdlen + len___0) + 1 >= ccline.cmdbufflen) {
    {
    retval = realloc_cmdbuff(ccline.cmdlen + len___0);
    }
  } else {
    retval = 1;
  }
  if (retval == 1) {
    if (! ccline.overstrike) {
      {
      memmove((void *)((char *)((ccline.cmdbuff + ccline.cmdpos) + len___0)), (void const   *)((char *)(ccline.cmdbuff + ccline.cmdpos)),
              (size_t )(ccline.cmdlen - ccline.cmdpos));
      ccline.cmdlen += len___0;
      }
    } else { //Added block
    if (ccline.cmdpos + len___0 > ccline.cmdlen) {
      ccline.cmdlen = ccline.cmdpos + len___0;
    }
    }
    {
    memmove((void *)((char *)(ccline.cmdbuff + ccline.cmdpos)), (void const   *)((char *)str___1),
            (size_t )len___0);
    }
    if (redraw) {
      if (cmdline_crypt) {
        i___0 = ccline.cmdpos;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (i___0 < ccline.cmdlen)) {
            goto while_break;
          }
          {
          msg_putchar('*');
          i___0 ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
        msg_no_more = 1;
        msg_outtrans_len(ccline.cmdbuff + ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);
        msg_no_more = 0;
        }
      }
    }
    if (KeyTyped) {
      m = (int )(Columns * Rows);
    } else {
      m = 2147483647;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < len___0)) {
        goto while_break___0;
      }
      if (cmdline_crypt) {
        c = 1;
      } else {
        {
        c = charsize((int )*(str___1 + i___0));
        }
      }
      if (ccline.cmdspos + c >= m) {
        goto while_break___0;
      }
      (ccline.cmdpos) ++;
      ccline.cmdspos += c;
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  if (redraw) {
    {
    msg_check();
    }
  }
  return (retval);
}
}
static void cmdline_del(int from ) 
{ 


  {
  {
  memmove((void *)((char *)(ccline.cmdbuff + from)), (void const   *)((char *)(ccline.cmdbuff + ccline.cmdpos)),
          (size_t )(ccline.cmdlen - ccline.cmdpos));
  ccline.cmdlen -= ccline.cmdpos - from;
  ccline.cmdpos = from;
  }
  return;
}
}
void redrawcmdline(void) 
{ 


  {
  {
  need_wait_return = 0;
  compute_cmdrow();
  redrawcmd();
  cursorcmd();
  }
  return;
}
}
static void redrawcmdprompt(void) 
{ 
  int i___0 ;

  {
  if (ccline.cmdfirstc) {
    {
    msg_putchar(ccline.cmdfirstc);
    }
  }
  if ((unsigned long )ccline.cmdprompt != (unsigned long )((void *)0)) {
    {
    msg_puts_attr(ccline.cmdprompt, ccline.cmdattr);
    ccline.cmdindent = msg_col;
    }
  } else {
    i___0 = ccline.cmdindent;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 > 0)) {
        goto while_break;
      }
      {
      msg_putchar(' ');
      i___0 --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
static void redrawcmd(void) 
{ 
  int i___0 ;

  {
  {
  msg_start();
  redrawcmdprompt();
  }
  if (cmdline_crypt) {
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < ccline.cmdlen)) {
        goto while_break;
      }
      {
      msg_putchar('*');
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    msg_clr_eos();
    }
  } else {
    {
    msg_no_more = 1;
    msg_outtrans_len(ccline.cmdbuff, ccline.cmdlen);
    msg_clr_eos();
    msg_no_more = 0;
    }
  }
  {
  set_cmdspos_cursor();
  msg_scroll = 0;
  skip_redraw = 0;
  }
  return;
}
}
void compute_cmdrow(void) 
{ 


  {
  if (exmode_active) {
    cmdline_row = (int )(Rows - 1L);
  } else { //Added block
  if (msg_scrolled) {
    cmdline_row = (int )(Rows - 1L);
  } else {
    cmdline_row = (lastwin->w_winpos + lastwin->w_height) + lastwin->w_status_height;
  }
  }
  return;
}
}
static void cursorcmd(void) 
{ 


  {
  msg_row = cmdline_row + ccline.cmdspos / (int )Columns;
  msg_col = ccline.cmdspos % (int )Columns;
  if ((long )msg_row >= Rows) {
    msg_row = (int )(Rows - 1L);
  }
  {
  windgoto(msg_row, msg_col);
  }
  return;
}
}
void gotocmdline(int clr ) 
{ 


  {
  {
  msg_start();
  msg_col = 0;
  }
  if (clr) {
    {
    msg_clr_eos();
    }
  }
  {
  windgoto(cmdline_row, 0);
  }
  return;
}
}
static int ccheck_abbr(int c ) 
{ 
  int tmp ;

  {
  if (p_paste) {
    return (0);
  } else { //Added block
  if (no_abbr) {
    return (0);
  }
  }
  {
  tmp = check_abbr(c, ccline.cmdbuff, ccline.cmdpos, 0);
  }
  return (tmp);
}
}
static int nextwild(int type , int options___0 ) 
{ 
  int i___0 ;
  int j ;
  char_u *p1 ;
  char_u *p2 ;
  int oldlen ;
  int difflen ;
  int v ;
  char_u *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  if (cmd_numfiles == -1) {
    {
    set_expand_context();
    }
  }
  if (expand_context == -1) {
    {
    beep_flush();
    }
    return (1);
  }
  if (expand_context == 0) {
    return (0);
  }
  {
  msg_puts((char_u *)"...");
  out_flush();
  i___0 = (int )(expand_pattern - ccline.cmdbuff);
  oldlen = ccline.cmdpos - i___0;
  }
  if (type == 4) {
    {
    p2 = ExpandOne((char_u *)((void *)0), (char_u *)((void *)0), 0, type);
    }
  } else { //Added block
  if (type == 5) {
    {
    p2 = ExpandOne((char_u *)((void *)0), (char_u *)((void *)0), 0, type);
    }
  } else {
    {
    p1 = addstar(ccline.cmdbuff + i___0, oldlen, expand_context);
    }
    if ((unsigned long )p1 == (unsigned long )((void *)0)) {
      p2 = (char_u *)((void *)0);
    } else {
      {
      tmp = vim_strnsave(ccline.cmdbuff + i___0, oldlen);
      p2 = ExpandOne(p1, tmp, 210 | options___0, type);
      vim_free((void *)p1);
      }
      if ((unsigned long )p2 != (unsigned long )((void *)0)) {
        if (type == 7) {
          j = 0;
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (! (j < oldlen)) {
              goto while_break;
            }
            if ((int )*(ccline.cmdbuff + (i___0 + j)) == 42) {
              goto while_break;
            } else { //Added block
            if ((int )*(ccline.cmdbuff + (i___0 + j)) == 63) {
              goto while_break;
            }
            }
            j ++;
          }
          while_break: /* CIL Label */ ;
          }
          {
          tmp___0 = strlen((char const   *)((char *)p2));
          }
          if ((int )tmp___0 < j) {
            {
            vim_free((void *)p2);
            p2 = (char_u *)((void *)0);
            }
          }
        }
      }
    }
  }
  }
  if ((unsigned long )p2 != (unsigned long )((void *)0)) {
    if (! got_int) {
      {
      tmp___1 = strlen((char const   *)((char *)p2));
      difflen = (int )(tmp___1 - (size_t )oldlen);
      }
      if (ccline.cmdlen + difflen > ccline.cmdbufflen - 4) {
        {
        v = realloc_cmdbuff(ccline.cmdlen + difflen);
        expand_pattern = ccline.cmdbuff + i___0;
        }
      } else {
        v = 1;
      }
      if (v == 1) {
        {
        vim_strncpy(ccline.cmdbuff + (ccline.cmdpos + difflen), ccline.cmdbuff + ccline.cmdpos,
                    ccline.cmdlen - ccline.cmdpos);
        tmp___2 = strlen((char const   *)((char *)p2));
        strncpy((char * __restrict  )((char *)(ccline.cmdbuff + i___0)), (char const   * __restrict  )((char *)p2),
                tmp___2);
        ccline.cmdlen += difflen;
        ccline.cmdpos += difflen;
        }
      }
    }
  }
  {
  vim_free((void *)p2);
  redrawcmd();
  }
  if (expand_context == 16) {
    if ((unsigned long )p2 == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  if (cmd_numfiles <= 0) {
    if ((unsigned long )p2 == (unsigned long )((void *)0)) {
      {
      beep_flush();
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (cmd_numfiles == 1) {
    {
    ExpandOne((char_u *)((void *)0), (char_u *)((void *)0), 0, 1);
    }
  }
  }
  return (1);
}
}
static int findex  ;
static char_u *orig_save  =    (char_u *)((void *)0);
char_u *ExpandOne(char_u *str___1 , char_u *orig , int options___0 , int mode ) 
{ 
  char_u *ss ;
  int i___0 ;
  int non_suf_match ;
  long_u len___0 ;
  char_u *p___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;

  {
  ss = (char_u *)((void *)0);
  if (mode == 4) {
    goto _L;
  } else { //Added block
  if (mode == 5) {
    _L: 
    if (cmd_numfiles > 0) {
      if (mode == 5) {
        if (findex == -1) {
          findex = cmd_numfiles;
        }
        findex --;
      } else {
        findex ++;
      }
      if (findex < 0) {
        if ((unsigned long )orig_save == (unsigned long )((void *)0)) {
          findex = cmd_numfiles - 1;
        } else {
          findex = -1;
        }
      }
      if (findex >= cmd_numfiles) {
        if ((unsigned long )orig_save == (unsigned long )((void *)0)) {
          findex = 0;
        } else {
          findex = -1;
        }
      }
      if (p_wmnu) {
        {
        win_redr_status_matches(cmd_numfiles, cmd_files, findex);
        }
      }
      if (findex == -1) {
        {
        tmp = vim_strsave(orig_save);
        }
        return (tmp);
      }
      {
      tmp___0 = vim_strsave(*(cmd_files + findex));
      }
      return (tmp___0);
    } else {
      return ((char_u *)((void *)0));
    }
  }
  }
  if (cmd_numfiles != -1) {
    if (mode != 6) {
      if (mode != 7) {
        {
        FreeWild(cmd_numfiles, cmd_files);
        cmd_numfiles = -1;
        vim_free((void *)orig_save);
        orig_save = (char_u *)((void *)0);
        }
      }
    }
  }
  findex = 0;
  if (mode == 1) {
    return ((char_u *)((void *)0));
  }
  if (cmd_numfiles == -1) {
    {
    vim_free((void *)orig_save);
    orig_save = orig;
    tmp___3 = ExpandFromContext(str___1, & cmd_numfiles, & cmd_files, 0, options___0);
    }
    if (! (tmp___3 == 0)) {
      if (cmd_numfiles == 0) {
        if (! (options___0 & 64)) {
          {
          emsg2(e_nomatch2, str___1);
          }
        }
      } else {
        if (options___0 & 2) {
          {
          tilde_replace(str___1, cmd_numfiles, cmd_files);
          }
        }
        if (options___0 & 128) {
          if (expand_context == 2) {
            goto _L___0;
          } else { //Added block
          if (expand_context == 9) {
            goto _L___0;
          } else { //Added block
          if (expand_context == 3) {
            _L___0: 
            i___0 = 0;
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              if (! (i___0 < cmd_numfiles)) {
                goto while_break;
              }
              if (expand_set_path) {
                {
                p___0 = vim_strsave_escaped(*(cmd_files + i___0), (char_u *)" ");
                }
                if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                  {
                  vim_free((void *)*(cmd_files + i___0));
                  *(cmd_files + i___0) = p___0;
                  }
                }
              }
              {
              p___0 = vim_strsave_escaped(*(cmd_files + i___0), (char_u *)" *?[{`$\\%#\'\"|");
              }
              if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                {
                vim_free((void *)*(cmd_files + i___0));
                *(cmd_files + i___0) = p___0;
                }
              }
              if ((int )*(str___1 + 0) == 92) {
                if ((int )*(str___1 + 1) == 126) {
                  if ((int )*(*(cmd_files + i___0) + 0) == 126) {
                    {
                    tmp___1 = strlen((char const   *)((char *)*(cmd_files + i___0)));
                    p___0 = alloc((unsigned int )(tmp___1 + 2UL));
                    }
                    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                      {
                      *(p___0 + 0) = (char_u )'\\';
                      strcpy((char * __restrict  )((char *)(p___0 + 1)), (char const   * __restrict  )((char *)*(cmd_files + i___0)));
                      vim_free((void *)*(cmd_files + i___0));
                      *(cmd_files + i___0) = p___0;
                      }
                    }
                  }
                }
              }
              i___0 ++;
            }
            while_break: /* CIL Label */ ;
            }
            expand_set_path = 0;
          } else { //Added block
          if (expand_context == 6) {
            i___0 = 0;
            {
            while (1) {
              while_continue___0: /* CIL Label */ ;
              if (! (i___0 < cmd_numfiles)) {
                goto while_break___0;
              }
              {
              p___0 = vim_strsave_escaped(*(cmd_files + i___0), (char_u *)"\\|\"");
              }
              if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                {
                vim_free((void *)*(cmd_files + i___0));
                *(cmd_files + i___0) = p___0;
                }
              }
              i___0 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          }
          }
          }
        }
        if (mode != 6) {
          if (mode != 7) {
            if (cmd_numfiles) {
              non_suf_match = cmd_numfiles;
            } else {
              non_suf_match = 1;
            }
            if (expand_context == 2) {
              goto _L___1;
            } else { //Added block
            if (expand_context == 3) {
              _L___1: 
              if (cmd_numfiles > 1) {
                non_suf_match = 0;
                i___0 = 0;
                {
                while (1) {
                  while_continue___1: /* CIL Label */ ;
                  if (! (i___0 < 2)) {
                    goto while_break___1;
                  }
                  {
                  tmp___2 = match_suffix(*(cmd_files + i___0));
                  }
                  if (tmp___2) {
                    non_suf_match ++;
                  }
                  i___0 ++;
                }
                while_break___1: /* CIL Label */ ;
                }
              }
            }
            }
            if (non_suf_match != 1) {
              if (! (options___0 & 64)) {
                {
                emsg(e_toomany);
                }
              } else { //Added block
              if (! (options___0 & 8)) {
                {
                beep_flush();
                }
              }
              }
            }
            if (non_suf_match != 1) {
              if (! (mode == 2)) {
                {
                ss = vim_strsave(*(cmd_files + 0));
                }
              }
            } else {
              {
              ss = vim_strsave(*(cmd_files + 0));
              }
            }
          }
        }
      }
    }
  }
  if (mode == 7) {
    if (cmd_numfiles > 0) {
      len___0 = (long_u )0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! *(*(cmd_files + 0) + len___0)) {
          goto while_break___2;
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (! (i___0 < cmd_numfiles)) {
            goto while_break___3;
          }
          if ((int )*(*(cmd_files + i___0) + len___0) != (int )*(*(cmd_files + 0) + len___0)) {
            goto while_break___3;
          }
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        if (i___0 < cmd_numfiles) {
          if (! (options___0 & 8)) {
            {
            vim_beep();
            }
          }
          goto while_break___2;
        }
        len___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      ss = alloc((unsigned int )len___0 + 1U);
      }
      if (ss) {
        {
        strncpy((char * __restrict  )((char *)ss), (char const   * __restrict  )((char *)*(cmd_files + 0)),
                len___0);
        *(ss + len___0) = (char_u )'\000';
        }
      }
      findex = -1;
    }
  }
  if (mode == 6) {
    if (cmd_numfiles > 0) {
      len___0 = (long_u )0;
      i___0 = 0;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! (i___0 < cmd_numfiles)) {
          goto while_break___4;
        }
        {
        tmp___4 = strlen((char const   *)((char *)*(cmd_files + i___0)));
        len___0 += tmp___4 + 1UL;
        i___0 ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      ss = lalloc(len___0, 1);
      }
      if ((unsigned long )ss != (unsigned long )((void *)0)) {
        *ss = (char_u )'\000';
        i___0 = 0;
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          if (! (i___0 < cmd_numfiles)) {
            goto while_break___5;
          }
          {
          strcat((char * __restrict  )((char *)ss), (char const   * __restrict  )((char *)*(cmd_files + i___0)));
          }
          if (i___0 != cmd_numfiles - 1) {
            if (options___0 & 4) {
              tmp___5 = "\n";
            } else {
              tmp___5 = " ";
            }
            {
            strcat((char * __restrict  )((char *)ss), (char const   * __restrict  )((char *)tmp___5));
            }
          }
          i___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
  }
  if (mode == 2) {
    {
    FreeWild(cmd_numfiles, cmd_files);
    cmd_numfiles = -1;
    }
  } else { //Added block
  if (mode == 6) {
    {
    FreeWild(cmd_numfiles, cmd_files);
    cmd_numfiles = -1;
    }
  }
  }
  return (ss);
}
}
void tilde_replace(char_u *orig_pat , int num_files , char_u **files ) 
{ 
  int i___0 ;
  char_u *p___0 ;
  int tmp ;

  {
  if ((int )*(orig_pat + 0) == 126) {
    {
    tmp = vim_ispathsep((int )*(orig_pat + 1));
    }
    if (tmp) {
      i___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < num_files)) {
          goto while_break;
        }
        {
        p___0 = home_replace_save((BUF *)((void *)0), *(files + i___0));
        }
        if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
          {
          vim_free((void *)*(files + i___0));
          *(files + i___0) = p___0;
          }
        }
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
static int showmatches(int wildmenu ) 
{ 
  char_u *file_str ;
  int num_files ;
  char_u **files_found ;
  int i___0 ;
  int j ;
  int k ;
  int maxlen ;
  int lines___0 ;
  int columns ;
  char_u *p___0 ;
  int lastlen ;
  int attr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  file_str = (char_u *)((void *)0);
  if (cmd_numfiles == -1) {
    {
    set_expand_context();
    }
    if (expand_context == -1) {
      {
      beep_flush();
      }
      return (1);
    }
    if (expand_context == 0) {
      return (0);
    }
    {
    file_str = addstar(expand_pattern, (int )((ccline.cmdbuff + ccline.cmdpos) - expand_pattern),
                       expand_context);
    }
    if ((unsigned long )file_str == (unsigned long )((void *)0)) {
      return (1);
    }
    {
    tmp = ExpandFromContext(file_str, & num_files, & files_found, 0, 80);
    }
    if (tmp == 0) {
      num_files = 0;
      files_found = (char_u **)"";
    }
  } else {
    num_files = cmd_numfiles;
    files_found = cmd_files;
  }
  if (! wildmenu) {
    {
    msg_didany = 0;
    msg_start();
    msg_putchar('\n');
    out_flush();
    cmdline_row = msg_row;
    msg_didany = 0;
    msg_start();
    }
  }
  if (got_int) {
    got_int = 0;
  } else { //Added block
  if (wildmenu) {
    {
    win_redr_status_matches(num_files, files_found, 0);
    }
  } else {
    maxlen = 0;
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < num_files)) {
        goto while_break;
      }
      if (expand_context == 2) {
        {
        home_replace((BUF *)((void *)0), *(files_found + i___0), NameBuff, 1024, 1);
        j = vim_strsize(NameBuff);
        }
      } else { //Added block
      if (expand_context == 9) {
        {
        home_replace((BUF *)((void *)0), *(files_found + i___0), NameBuff, 1024, 1);
        j = vim_strsize(NameBuff);
        }
      } else {
        {
        j = vim_strsize(*(files_found + i___0));
        }
      }
      }
      if (j > maxlen) {
        maxlen = j;
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    if (expand_context == 17) {
      lines___0 = num_files;
    } else {
      maxlen += 2;
      columns = ((int )Columns + 2) / maxlen;
      if (columns < 1) {
        columns = 1;
      }
      lines___0 = ((num_files + columns) - 1) / columns;
    }
    attr = highlight_attr[2];
    if (expand_context == 17) {
      {
      msg_puts_attr((char_u *)"tagname", highlight_attr[13]);
      msg_clr_eos();
      msg_advance(maxlen - 3);
      msg_puts_attr((char_u *)" kind file\n", highlight_attr[13]);
      }
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < lines___0)) {
        goto while_break___0;
      }
      lastlen = 999;
      k = i___0;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (k < num_files)) {
          goto while_break___1;
        }
        if (expand_context == 17) {
          {
          msg_outtrans_attr(*(files_found + k), highlight_attr[2]);
          tmp___0 = strlen((char const   *)((char *)*(files_found + k)));
          p___0 = (*(files_found + k) + tmp___0) + 1;
          msg_advance(maxlen + 1);
          msg_puts(p___0);
          msg_advance(maxlen + 3);
          msg_puts_long_attr(p___0 + 2, highlight_attr[2]);
          }
          goto while_break___1;
        }
        j = maxlen - lastlen;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          j --;
          if (! (j >= 0)) {
            goto while_break___2;
          }
          {
          msg_putchar(' ');
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        if (expand_context == 2) {
          {
          j = mch_isdir(*(files_found + k));
          home_replace((BUF *)((void *)0), *(files_found + k), NameBuff, 1024, 1);
          p___0 = NameBuff;
          }
        } else { //Added block
        if (expand_context == 9) {
          {
          j = mch_isdir(*(files_found + k));
          home_replace((BUF *)((void *)0), *(files_found + k), NameBuff, 1024, 1);
          p___0 = NameBuff;
          }
        } else {
          j = 0;
          p___0 = *(files_found + k);
        }
        }
        if (j) {
          tmp___1 = attr;
        } else {
          tmp___1 = 0;
        }
        {
        lastlen = msg_outtrans_attr(p___0, tmp___1);
        k += lines___0;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      if (msg_col > 0) {
        {
        msg_clr_eos();
        msg_putchar('\n');
        }
      }
      {
      out_flush();
      }
      if (got_int) {
        got_int = 0;
        goto while_break___0;
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    cmdline_row = msg_row;
  }
  }
  if (cmd_numfiles == -1) {
    {
    vim_free((void *)file_str);
    FreeWild(num_files, files_found);
    }
  }
  return (1);
}
}
char_u *addstar(char_u *fname , int len___0 , int context ) 
{ 
  char_u *retval ;
  int i___0 ;
  int j ;
  int new_len ;
  char_u *tail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;

  {
  if (context != 2) {
    if (context != 3) {
      if (context == 8) {
        {
        retval = vim_strnsave(fname, len___0);
        }
      } else {
        new_len = len___0 + 2;
        i___0 = 0;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (i___0 < len___0)) {
            goto while_break;
          }
          if ((int )*(fname + i___0) == 42) {
            new_len ++;
          } else { //Added block
          if ((int )*(fname + i___0) == 126) {
            new_len ++;
          }
          }
          if (context == 9) {
            if ((int )*(fname + i___0) == 46) {
              new_len ++;
            }
          }
          i___0 ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
        retval = alloc((unsigned int )new_len);
        }
        if ((unsigned long )retval != (unsigned long )((void *)0)) {
          *(retval + 0) = (char_u )'^';
          j = 1;
          i___0 = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (i___0 < len___0)) {
              goto while_break___0;
            }
            if ((int )*(fname + i___0) == 92) {
              i___0 ++;
              if (i___0 == len___0) {
                goto while_break___0;
              }
            }
            {
            if ((int )*(fname + i___0) == 42) {
              goto case_42;
            }
            if ((int )*(fname + i___0) == 126) {
              goto case_126;
            }
            if ((int )*(fname + i___0) == 63) {
              goto case_63;
            }
            if ((int )*(fname + i___0) == 46) {
              goto case_46;
            }
            goto switch_break;
            case_42: /* CIL Label */ 
            tmp = j;
            j ++;
            *(retval + tmp) = (char_u )'.';
            goto switch_break;
            case_126: /* CIL Label */ 
            tmp___0 = j;
            j ++;
            *(retval + tmp___0) = (char_u )'\\';
            goto switch_break;
            case_63: /* CIL Label */ 
            *(retval + j) = (char_u )'.';
            goto __Cont;
            case_46: /* CIL Label */ 
            if (context == 9) {
              tmp___1 = j;
              j ++;
              *(retval + tmp___1) = (char_u )'\\';
            }
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
            *(retval + j) = *(fname + i___0);
            __Cont: 
            i___0 ++;
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          *(retval + j) = (char_u )'\000';
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    retval = alloc((unsigned int )(len___0 + 4));
    }
    if ((unsigned long )retval != (unsigned long )((void *)0)) {
      {
      strncpy((char * __restrict  )((char *)retval), (char const   * __restrict  )((char *)fname),
              (size_t )len___0);
      *(retval + len___0) = (char_u )'\000';
      tail = gettail(retval);
      }
      if ((int )*tail != 126) {
        {
        tmp___3 = vim_strchr(tail, '$');
        }
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
          {
          tmp___4 = vim_strchr(retval, '`');
          }
          if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
            tmp___2 = len___0;
            len___0 ++;
            *(retval + tmp___2) = (char_u )'*';
          }
        }
      }
      *(retval + len___0) = (char_u )'\000';
    }
  }
  return (retval);
}
}
static void set_expand_context(void) 
{ 
  char_u *nextcomm ;
  int old_char___0 ;

  {
  old_char___0 = '\000';
  if (ccline.cmdfirstc != 58) {
    expand_context = 0;
    return;
  }
  if (ccline.cmdpos < ccline.cmdlen) {
    old_char___0 = (int )*(ccline.cmdbuff + ccline.cmdpos);
  }
  *(ccline.cmdbuff + ccline.cmdpos) = (char_u )'\000';
  nextcomm = ccline.cmdbuff;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )nextcomm != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    nextcomm = set_one_cmd_context(nextcomm);
    }
  }
  while_break: /* CIL Label */ ;
  }
  *(ccline.cmdbuff + ccline.cmdpos) = (char_u )old_char___0;
  return;
}
}
static int ExpandFromContext(char_u *pat , int *num_file , char_u ***file , int files_only ,
                             int options___0 ) 
{ 
  vim_regexp *prog ;
  int ret ;
  int flags___0 ;
  int tmp ;
  int free_pat ;
  int i___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  flags___0 = 0;
  if (! files_only) {
    flags___0 |= 1;
  }
  if (options___0 & 1) {
    flags___0 |= 4;
  }
  if (options___0 & 16) {
    flags___0 |= 8;
  }
  if (options___0 & 32) {
    flags___0 |= 16;
  }
  if (options___0 & 64) {
    flags___0 |= 32;
  }
  if (expand_context == 2) {
    {
    tmp = expand_wildcards(1, & pat, num_file, file, flags___0 | 2);
    }
    return (tmp);
  } else { //Added block
  if (expand_context == 3) {
    free_pat = 0;
    if (expand_set_path) {
      {
      free_pat = 1;
      pat = vim_strsave(pat);
      i___0 = 0;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! *(pat + i___0)) {
          goto while_break;
        }
        if ((int )*(pat + i___0) == 92) {
          if ((int )*(pat + (i___0 + 1)) == 92) {
            if ((int )*(pat + (i___0 + 2)) == 92) {
              if ((int )*(pat + (i___0 + 3)) == 32) {
                {
                strcpy((char * __restrict  )((char *)(pat + i___0)), (char const   * __restrict  )((char *)((pat + i___0) + 3)));
                }
              }
            }
          }
        }
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
    ret = expand_wildcards(1, & pat, num_file, file, (flags___0 | 1) & -3);
    }
    if (free_pat) {
      {
      vim_free((void *)pat);
      }
    }
    return (ret);
  }
  }
  *file = (char_u **)"";
  *num_file = 0;
  if (expand_context == 8) {
    {
    tmp___0 = find_help_tags(pat, num_file, file);
    }
    return (tmp___0);
  }
  if (expand_context == 7) {
    {
    tmp___1 = ExpandOldSetting(num_file, file);
    }
    return (tmp___1);
  }
  {
  set_reg_ic(pat);
  }
  if (expand_context == 9) {
    {
    tmp___2 = ExpandBufnames(pat, num_file, file, options___0);
    }
    return (tmp___2);
  } else { //Added block
  if (expand_context == 6) {
    {
    tmp___3 = expand_tags(expand_context == 6, pat, num_file, file);
    }
    return (tmp___3);
  } else { //Added block
  if (expand_context == 17) {
    {
    tmp___3 = expand_tags(expand_context == 6, pat, num_file, file);
    }
    return (tmp___3);
  }
  }
  }
  {
  prog = vim_regcomp(pat, p_magic);
  }
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    return (0);
  }
  if (expand_context == 1) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_command_name);
    }
  } else { //Added block
  if (expand_context == 4) {
    {
    ret = ExpandSettings(prog, num_file, file);
    }
  } else { //Added block
  if (expand_context == 5) {
    {
    ret = ExpandSettings(prog, num_file, file);
    }
  } else { //Added block
  if (expand_context == 22) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_user_commands);
    }
  } else { //Added block
  if (expand_context == 23) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_user_cmd_flags);
    }
  } else { //Added block
  if (expand_context == 24) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_user_cmd_nargs);
    }
  } else { //Added block
  if (expand_context == 25) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_user_cmd_complete);
    }
  } else { //Added block
  if (expand_context == 15) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_user_var_name);
    }
  } else { //Added block
  if (expand_context == 18) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_function_name);
    }
  } else { //Added block
  if (expand_context == 19) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_user_func_name);
    }
  } else { //Added block
  if (expand_context == 20) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_expr_name);
    }
  } else { //Added block
  if (expand_context == 16) {
    {
    ret = ExpandMappings(prog, num_file, file);
    }
  } else { //Added block
  if (expand_context == 11) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_menu_name);
    }
  } else { //Added block
  if (expand_context == 21) {
    {
    ret = ExpandGeneric(prog, num_file, file, & get_menu_names);
    }
  } else { //Added block
  if (expand_context == 12) {
    {
    reg_ic = 1;
    ret = ExpandGeneric(prog, num_file, file, & get_syntax_name);
    }
  } else { //Added block
  if (expand_context == 13) {
    {
    reg_ic = 1;
    ret = ExpandGeneric(prog, num_file, file, & get_highlight_name);
    }
  } else { //Added block
  if (expand_context == 10) {
    {
    reg_ic = 1;
    ret = ExpandGeneric(prog, num_file, file, & get_event_name);
    }
  } else { //Added block
  if (expand_context == 14) {
    {
    reg_ic = 1;
    ret = ExpandGeneric(prog, num_file, file, & get_augroup_name);
    }
  } else {
    ret = 0;
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  {
  vim_free((void *)prog);
  }
  return (ret);
}
}
int ExpandGeneric(vim_regexp *prog , int *num_file , char_u ***file , char_u *(*func)(int  ) ) 
{ 
  int i___0 ;
  int count___2 ;
  int loop ;
  char_u *str___1 ;
  size_t tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  count___2 = 0;
  loop = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (loop <= 1)) {
      goto while_break;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      str___1 = (*func)(i___0);
      }
      if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
        goto while_break___0;
      }
      if ((int )*str___1 == 0) {
        goto __Cont;
      }
      {
      tmp___0 = vim_regexec(prog, str___1, 1);
      }
      if (tmp___0) {
        if (loop) {
          {
          str___1 = vim_strsave_escaped(str___1, (char_u *)" \t\\.");
          *(*file + count___2) = str___1;
          }
          if ((unsigned long )func == (unsigned long )(& get_menu_names)) {
            if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
              {
              tmp = strlen((char const   *)((char *)str___1));
              str___1 += tmp - 1UL;
              }
              if ((int )*str___1 == 1) {
                *str___1 = (char_u )'.';
              }
            }
          }
        }
        count___2 ++;
      }
      __Cont: 
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (loop == 0) {
      if (count___2 == 0) {
        return (1);
      }
      {
      *num_file = count___2;
      tmp___1 = alloc((unsigned int )((unsigned long )count___2 * sizeof(char_u *)));
      *file = (char_u **)tmp___1;
      }
      if ((unsigned long )*file == (unsigned long )((void *)0)) {
        *file = (char_u **)"";
        return (0);
      }
      count___2 = 0;
    }
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int hist_char2type(int c ) 
{ 


  {
  if (c == 58) {
    return (0);
  }
  if (c == 61) {
    return (2);
  }
  if (c == 64) {
    return (3);
  }
  return (1);
}
}
static char *history_names[5]  = {      (char *)"cmd",      (char *)"search",      (char *)"expr",      (char *)"input", 
        (char *)((void *)0)};
static void init_history(void) 
{ 
  int newlen ;
  struct hist_entry *temp ;
  int i___0 ;
  int j ;
  int type ;
  char_u *tmp ;

  {
  newlen = (int )p_hi;
  if (newlen != hislen) {
    type = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (type < 4)) {
        goto while_break;
      }
      if (newlen) {
        {
        tmp = lalloc((unsigned long )newlen * sizeof(struct hist_entry ), 1);
        temp = (struct hist_entry *)tmp;
        }
        if ((unsigned long )temp == (unsigned long )((void *)0)) {
          if (type == 0) {
            newlen = hislen;
            goto while_break;
          }
          newlen = 0;
          type = -1;
          goto __Cont;
        }
      } else {
        temp = (struct hist_entry *)((void *)0);
      }
      if (newlen == 0) {
        goto _L;
      } else { //Added block
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        _L: 
        if (hisidx[type] < 0) {
          i___0 = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (i___0 < newlen)) {
              goto while_break___0;
            }
            (temp + i___0)->hisnum = 0;
            (temp + i___0)->hisstr = (char_u *)((void *)0);
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else { //Added block
        if (newlen > hislen) {
          i___0 = 0;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (i___0 <= hisidx[type])) {
              goto while_break___1;
            }
            *(temp + i___0) = *(history[type] + i___0);
            i___0 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          j = i___0;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! (i___0 <= newlen - (hislen - hisidx[type]))) {
              goto while_break___2;
            }
            (temp + i___0)->hisnum = 0;
            (temp + i___0)->hisstr = (char_u *)((void *)0);
            i___0 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if (! (j < hislen)) {
              goto while_break___3;
            }
            *(temp + i___0) = *(history[type] + j);
            i___0 ++;
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
          j = hisidx[type];
          i___0 = newlen - 1;
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (i___0 >= 0) {
              *(temp + i___0) = *(history[type] + j);
            } else {
              {
              vim_free((void *)(history[type] + j)->hisstr);
              }
            }
            j --;
            if (j < 0) {
              j = hislen - 1;
            }
            if (j == hisidx[type]) {
              goto while_break___4;
            }
            i___0 --;
          }
          while_break___4: /* CIL Label */ ;
          }
          hisidx[type] = newlen - 1;
        }
        }
        {
        vim_free((void *)history[type]);
        history[type] = temp;
        }
      }
      }
      __Cont: 
      type ++;
    }
    while_break: /* CIL Label */ ;
    }
    hislen = newlen;
  }
  return;
}
}
static int in_history(int type , char_u *str___1 , int move_to_front ) 
{ 
  int i___0 ;
  int last_i ;
  int tmp ;

  {
  last_i = -1;
  if (hisidx[type] < 0) {
    return (0);
  }
  i___0 = hisidx[type];
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )(history[type] + i___0)->hisstr == (unsigned long )((void *)0)) {
      return (0);
    }
    {
    tmp = strcmp((char const   *)((char *)str___1), (char const   *)((char *)(history[type] + i___0)->hisstr));
    }
    if (tmp == 0) {
      if (! move_to_front) {
        return (1);
      }
      last_i = i___0;
      goto while_break;
    }
    i___0 --;
    if (i___0 < 0) {
      i___0 = hislen - 1;
    }
    if (! (i___0 != hisidx[type])) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (last_i >= 0) {
    str___1 = (history[type] + i___0)->hisstr;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 != hisidx[type])) {
        goto while_break___0;
      }
      i___0 ++;
      if (i___0 >= hislen) {
        i___0 = 0;
      }
      *(history[type] + last_i) = *(history[type] + i___0);
      last_i = i___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    (history[type] + i___0)->hisstr = str___1;
    (hisnum[type]) ++;
    (history[type] + i___0)->hisnum = hisnum[type];
    return (1);
  }
  return (0);
}
}
int get_histtype(char_u *name___1 ) 
{ 
  int i___0 ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  {
  tmp = strlen((char const   *)((char *)name___1));
  len___0 = (int )tmp;
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )history_names[i___0] != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp___0 = strncasecmp((char const   *)((char *)name___1), (char const   *)history_names[i___0],
                          (size_t )len___0);
    }
    if (tmp___0 == 0) {
      return (i___0);
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___2 = vim_strchr((char_u *)":=@?/", (int )*(name___1 + 0));
  }
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    if ((int )*(name___1 + 1) == 0) {
      {
      tmp___1 = hist_char2type((int )*(name___1 + 0));
      }
      return (tmp___1);
    }
  }
  return (-1);
}
}
static int last_maptick  =    -1;
void add_to_history(int histype , char_u *new_entry , int in_map ) 
{ 
  struct hist_entry *hisptr ;
  int tmp ;

  {
  if (hislen == 0) {
    return;
  }
  if (histype == 1) {
    if (in_map) {
      if (maptick == last_maptick) {
        {
        hisptr = history[1] + hisidx[1];
        vim_free((void *)hisptr->hisstr);
        hisptr->hisstr = (char_u *)((void *)0);
        hisptr->hisnum = 0;
        (hisnum[histype]) --;
        (hisidx[1]) --;
        }
        if (hisidx[1] < 0) {
          hisidx[1] = hislen - 1;
        }
      }
      last_maptick = -1;
    }
  }
  {
  tmp = in_history(histype, new_entry, 1);
  }
  if (! tmp) {
    (hisidx[histype]) ++;
    if (hisidx[histype] == hislen) {
      hisidx[histype] = 0;
    }
    {
    hisptr = history[histype] + hisidx[histype];
    vim_free((void *)hisptr->hisstr);
    hisptr->hisstr = vim_strsave(new_entry);
    (hisnum[histype]) ++;
    hisptr->hisnum = hisnum[histype];
    }
    if (histype == 1) {
      if (in_map) {
        last_maptick = maptick;
      }
    }
  }
  return;
}
}
int get_history_idx(int histype ) 
{ 


  {
  if (hislen == 0) {
    return (-1);
  } else { //Added block
  if (histype < 0) {
    return (-1);
  } else { //Added block
  if (histype >= 4) {
    return (-1);
  } else { //Added block
  if (hisidx[histype] < 0) {
    return (-1);
  }
  }
  }
  }
  return ((history[histype] + hisidx[histype])->hisnum);
}
}
static int calc_hist_idx(int histype , int num ) 
{ 
  int i___0 ;
  struct hist_entry *hist ;

  {
  if (hislen == 0) {
    return (-1);
  } else { //Added block
  if (histype < 0) {
    return (-1);
  } else { //Added block
  if (histype >= 4) {
    return (-1);
  } else {
    i___0 = hisidx[histype];
    if (i___0 < 0) {
      return (-1);
    } else { //Added block
    if (num == 0) {
      return (-1);
    }
    }
  }
  }
  }
  hist = history[histype];
  if (num > 0) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((hist + i___0)->hisnum > num)) {
        goto while_break;
      }
      i___0 --;
      if (i___0 < 0) {
        i___0 += hislen;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if ((hist + i___0)->hisnum == num) {
      if ((unsigned long )(hist + i___0)->hisstr != (unsigned long )((void *)0)) {
        return (i___0);
      }
    }
  } else { //Added block
  if (- num <= hislen) {
    i___0 += num + 1;
    if (i___0 < 0) {
      i___0 += hislen;
    }
    if ((unsigned long )(hist + i___0)->hisstr != (unsigned long )((void *)0)) {
      return (i___0);
    }
  }
  }
  return (-1);
}
}
char_u *get_history_entry(int histype , int idx ) 
{ 


  {
  {
  idx = calc_hist_idx(histype, idx);
  }
  if (idx >= 0) {
    return ((history[histype] + idx)->hisstr);
  } else {
    return ((char_u *)"");
  }
}
}
int clr_history(int histype ) 
{ 
  int i___0 ;
  struct hist_entry *hisptr ;
  struct hist_entry *tmp ;
  int tmp___0 ;

  {
  if (hislen != 0) {
    if (histype >= 0) {
      if (histype < 4) {
        hisptr = history[histype];
        i___0 = hislen;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          tmp___0 = i___0;
          i___0 --;
          if (! tmp___0) {
            goto while_break;
          }
          {
          vim_free((void *)hisptr->hisstr);
          hisptr->hisnum = 0;
          tmp = hisptr;
          hisptr ++;
          tmp->hisstr = (char_u *)((void *)0);
          }
        }
        while_break: /* CIL Label */ ;
        }
        hisidx[histype] = -1;
        hisnum[histype] = 0;
        return (1);
      }
    }
  }
  return (0);
}
}
int del_history_entry(int histype , char_u *str___1 ) 
{ 
  vim_regexp *prog ;
  struct hist_entry *hisptr ;
  int idx ;
  int i___0 ;
  int last ;
  int found ;
  int tmp ;

  {
  prog = (vim_regexp *)((void *)0);
  found = 0;
  if (hislen != 0) {
    if (histype >= 0) {
      if (histype < 4) {
        if ((int )*str___1 != 0) {
          idx = hisidx[histype];
          if (idx >= 0) {
            {
            prog = vim_regcomp(str___1, 1);
            }
            if (prog) {
              last = idx;
              i___0 = last;
              {
              while (1) {
                while_continue: /* CIL Label */ ;
                hisptr = history[histype] + i___0;
                if ((unsigned long )hisptr->hisstr == (unsigned long )((void *)0)) {
                  goto while_break;
                }
                {
                tmp = vim_regexec(prog, hisptr->hisstr, 1);
                }
                if (tmp) {
                  {
                  found = 1;
                  vim_free((void *)hisptr->hisstr);
                  hisptr->hisstr = (char_u *)((void *)0);
                  hisptr->hisnum = 0;
                  }
                } else {
                  if (i___0 != last) {
                    *(history[histype] + last) = *hisptr;
                    hisptr->hisstr = (char_u *)((void *)0);
                    hisptr->hisnum = 0;
                  }
                  last --;
                  if (last < 0) {
                    last += hislen;
                  }
                }
                i___0 --;
                if (i___0 < 0) {
                  i___0 += hislen;
                }
                if (! (i___0 != idx)) {
                  goto while_break;
                }
              }
              while_break: /* CIL Label */ ;
              }
              if ((unsigned long )(history[histype] + idx)->hisstr == (unsigned long )((void *)0)) {
                hisidx[histype] = -1;
              }
            }
          }
        }
      }
    }
  }
  if (prog) {
    {
    vim_free((void *)prog);
    }
  }
  return (found);
}
}
int del_history_idx(int histype , int idx ) 
{ 
  int i___0 ;
  int j ;

  {
  {
  i___0 = calc_hist_idx(histype, idx);
  }
  if (i___0 < 0) {
    return (0);
  }
  {
  idx = hisidx[histype];
  vim_free((void *)(history[histype] + i___0)->hisstr);
  }
  if (histype == 1) {
    if (maptick == last_maptick) {
      if (i___0 == idx) {
        last_maptick = -1;
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 != idx)) {
      goto while_break;
    }
    j = (i___0 + 1) % hislen;
    *(history[histype] + i___0) = *(history[histype] + j);
    i___0 = j;
  }
  while_break: /* CIL Label */ ;
  }
  (history[histype] + i___0)->hisstr = (char_u *)((void *)0);
  (history[histype] + i___0)->hisnum = 0;
  i___0 --;
  if (i___0 < 0) {
    i___0 += hislen;
  }
  hisidx[histype] = i___0;
  return (1);
}
}
void remove_key_from_history(void) 
{ 
  char_u *p___0 ;
  int i___0 ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  i___0 = hisidx[0];
  if (i___0 < 0) {
    return;
  }
  p___0 = (history[0] + i___0)->hisstr;
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break;
      }
      {
      tmp___0 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"key"),
                        (size_t )3);
      }
      if (tmp___0 == 0) {
        {
        tmp___1 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___1 + (int )*(p___0 + 3)) & 512)) {
          {
          p___0 = vim_strchr(p___0 + 3, '=');
          }
          if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
            goto while_break;
          }
          p___0 ++;
          i___0 = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (*(p___0 + i___0)) {
              if ((int )*(p___0 + i___0) == 32) {
                goto while_break___0;
              } else { //Added block
              if ((int )*(p___0 + i___0) == 9) {
                goto while_break___0;
              }
              }
            } else {
              goto while_break___0;
            }
            if ((int )*(p___0 + i___0) == 92) {
              if (*(p___0 + (i___0 + 1))) {
                i___0 ++;
              }
            }
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
          tmp = strlen((char const   *)((char *)(p___0 + i___0)));
          memmove((void *)((char *)p___0), (void const   *)((char *)(p___0 + i___0)),
                  tmp + 1UL);
          p___0 --;
          }
        }
      }
      p___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
int get_list_range(char_u **str___1 , int *num1 , int *num2 ) 
{ 
  int len___0 ;
  int first___0 ;
  long num ;
  unsigned short const   **tmp ;

  {
  {
  first___0 = 0;
  *str___1 = skipwhite(*str___1);
  }
  if ((int )*(*str___1) == 45) {
    {
    vim_str2nr(*str___1, (int *)((void *)0), & len___0, 0, 0, & num, (unsigned long *)((void *)0));
    *str___1 += len___0;
    *num1 = (int )num;
    first___0 = 1;
    }
  } else {
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )*(*str___1)) & 2048) {
      {
      vim_str2nr(*str___1, (int *)((void *)0), & len___0, 0, 0, & num, (unsigned long *)((void *)0));
      *str___1 += len___0;
      *num1 = (int )num;
      first___0 = 1;
      }
    }
  }
  {
  *str___1 = skipwhite(*str___1);
  }
  if ((int )*(*str___1) == 44) {
    {
    *str___1 = skipwhite(*str___1 + 1);
    vim_str2nr(*str___1, (int *)((void *)0), & len___0, 0, 0, & num, (unsigned long *)((void *)0));
    }
    if (len___0 > 0) {
      {
      *num2 = (int )num;
      *str___1 = skipwhite(*str___1 + len___0);
      }
    } else { //Added block
    if (! first___0) {
      return (0);
    }
    }
  } else { //Added block
  if (first___0) {
    *num2 = *num1;
  }
  }
  return (1);
}
}
void do_history(char_u *arg ) 
{ 
  struct hist_entry *hist ;
  int histype1 ;
  int histype2 ;
  int hisidx1 ;
  int hisidx2 ;
  int idx ;
  int i___0 ;
  int j ;
  int k ;
  char_u *end ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  histype1 = 0;
  histype2 = 0;
  hisidx1 = 1;
  hisidx2 = -1;
  if (hislen == 0) {
    {
    msg((char_u *)"\'history\' option is zero");
    }
    return;
  }
  {
  tmp___3 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___3 + (int )*arg) & 2048) {
    end = arg;
  } else { //Added block
  if ((int )*arg == 45) {
    end = arg;
  } else { //Added block
  if ((int )*arg == 44) {
    end = arg;
  } else {
    end = arg;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp + (int )*end) & 1024)) {
        {
        tmp___0 = vim_strchr((char_u *)":=@/?", (int )*end);
        }
        if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
          goto while_break;
        }
      }
      end ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    i___0 = (int )*end;
    *end = (char_u )'\000';
    histype1 = get_histtype(arg);
    }
    if (histype1 == -1) {
      {
      tmp___1 = strlen((char const   *)((char *)arg));
      tmp___2 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"all"),
                            tmp___1);
      }
      if (tmp___2 == 0) {
        histype1 = 0;
        histype2 = 3;
      } else {
        {
        *end = (char_u )i___0;
        emsg(e_trailing);
        }
        return;
      }
    } else {
      histype2 = histype1;
    }
    *end = (char_u )i___0;
  }
  }
  }
  {
  tmp___4 = get_list_range(& end, & hisidx1, & hisidx2);
  }
  if (tmp___4) {
    if ((int )*end != 0) {
      {
      emsg(e_trailing);
      }
      return;
    }
  } else {
    {
    emsg(e_trailing);
    }
    return;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! got_int) {
      if (! (histype1 <= histype2)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"\n      #  "));
    tmp___5 = strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )history_names[histype1]);
    strcat((char * __restrict  )tmp___5, (char const   * __restrict  )((char *)" history"));
    msg_puts_title(IObuff);
    idx = hisidx[histype1];
    hist = history[histype1];
    j = hisidx1;
    k = hisidx2;
    }
    if (j < 0) {
      if (- j > hislen) {
        j = 0;
      } else {
        j = (hist + (((hislen + j) + idx) + 1) % hislen)->hisnum;
      }
    }
    if (k < 0) {
      if (- k > hislen) {
        k = 0;
      } else {
        k = (hist + (((hislen + k) + idx) + 1) % hislen)->hisnum;
      }
    }
    if (idx >= 0) {
      if (j <= k) {
        i___0 = idx + 1;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (! got_int)) {
            goto while_break___1;
          }
          if (i___0 == hislen) {
            i___0 = 0;
          }
          if ((unsigned long )(hist + i___0)->hisstr != (unsigned long )((void *)0)) {
            if ((hist + i___0)->hisnum >= j) {
              if ((hist + i___0)->hisnum <= k) {
                {
                msg_putchar('\n');
                }
                if (i___0 == idx) {
                  tmp___6 = '>';
                } else {
                  tmp___6 = ' ';
                }
                {
                sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%c%6d  %s",
                        tmp___6, (hist + i___0)->hisnum, (hist + i___0)->hisstr);
                msg_outtrans(IObuff);
                out_flush();
                }
              }
            }
          }
          if (i___0 == idx) {
            goto while_break___1;
          }
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    histype1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
static char_u **viminfo_history[4]  = {      (char_u **)((void *)0),      (char_u **)((void *)0),      (char_u **)((void *)0),      (char_u **)((void *)0)};
static int viminfo_hisidx[4]  = {      0,      0,      0,      0};
static int viminfo_hislen[4]  = {      0,      0,      0,      0};
static int viminfo_add_at_front  =    0;
static int hist_type2char(int type , int use_question ) ;
static int hist_type2char(int type , int use_question ) 
{ 


  {
  if (type == 0) {
    return (':');
  }
  if (type == 1) {
    if (use_question) {
      return ('?');
    } else {
      return ('/');
    }
  }
  if (type == 2) {
    return ('=');
  }
  return ('@');
}
}
void prepare_viminfo_history(int asklen ) 
{ 
  int i___0 ;
  int num ;
  int type ;
  int len___0 ;
  char_u *tmp ;

  {
  {
  init_history();
  viminfo_add_at_front = asklen != 0;
  }
  if (asklen > hislen) {
    asklen = hislen;
  }
  type = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (type < 4)) {
      goto while_break;
    }
    i___0 = 0;
    num = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < hislen)) {
        goto while_break___0;
      }
      if ((unsigned long )(history[type] + i___0)->hisstr == (unsigned long )((void *)0)) {
        num ++;
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    len___0 = asklen;
    if (num > len___0) {
      len___0 = num;
    }
    if (len___0 <= 0) {
      viminfo_history[type] = (char_u **)((void *)0);
    } else {
      {
      tmp = lalloc((unsigned long )len___0 * sizeof(char_u *), 0);
      viminfo_history[type] = (char_u **)tmp;
      }
    }
    if ((unsigned long )viminfo_history[type] == (unsigned long )((void *)0)) {
      len___0 = 0;
    }
    viminfo_hislen[type] = len___0;
    viminfo_hisidx[type] = 0;
    type ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int read_viminfo_history(char_u *line , FILE *fp___0 ) 
{ 
  int type ;
  char_u *val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  type = hist_char2type((int )*(line + 0));
  }
  if (viminfo_hisidx[type] < viminfo_hislen[type]) {
    {
    val = viminfo_readstring(line + 1, fp___0);
    }
    if ((unsigned long )val != (unsigned long )((void *)0)) {
      {
      tmp___0 = in_history(type, val, viminfo_add_at_front);
      }
      if (tmp___0) {
        {
        vim_free((void *)val);
        }
      } else {
        tmp = viminfo_hisidx[type];
        (viminfo_hisidx[type]) ++;
        *(viminfo_history[type] + tmp) = val;
      }
    }
  }
  {
  tmp___1 = vim_fgets(line, 512, fp___0);
  }
  return (tmp___1);
}
}
void finish_viminfo_history(void) 
{ 
  int idx ;
  int i___0 ;
  int type ;
  int tmp ;

  {
  type = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (type < 4)) {
      goto while_break;
    }
    if ((unsigned long )history[type] == (unsigned long )((void *)0)) {
      return;
    }
    idx = hisidx[type] + viminfo_hisidx[type];
    if (idx >= hislen) {
      idx -= hislen;
    } else { //Added block
    if (idx < 0) {
      idx = hislen - 1;
    }
    }
    if (viminfo_add_at_front) {
      hisidx[type] = idx;
    } else {
      if (hisidx[type] == -1) {
        hisidx[type] = hislen - 1;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (! ((unsigned long )(history[type] + idx)->hisstr != (unsigned long )((void *)0)))) {
          goto while_break___0;
        }
        idx ++;
        if (idx == hislen) {
          idx = 0;
        }
        if (! (idx != hisidx[type])) {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      if (idx != hisidx[type]) {
        idx --;
        if (idx < 0) {
          idx = hislen - 1;
        }
      }
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i___0 < viminfo_hisidx[type])) {
        goto while_break___1;
      }
      {
      vim_free((void *)(history[type] + idx)->hisstr);
      (history[type] + idx)->hisstr = *(viminfo_history[type] + i___0);
      idx --;
      }
      if (idx < 0) {
        idx = hislen - 1;
      }
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    idx ++;
    idx %= hislen;
    i___0 = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (i___0 < viminfo_hisidx[type])) {
        goto while_break___2;
      }
      tmp = idx;
      idx ++;
      (hisnum[type]) ++;
      (history[type] + tmp)->hisnum = hisnum[type];
      idx %= hislen;
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    vim_free((void *)viminfo_history[type]);
    viminfo_history[type] = (char_u **)((void *)0);
    type ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void write_viminfo_history(FILE *fp___0 ) 
{ 
  int i___0 ;
  int type ;
  int num_saved ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  init_history();
  }
  if (hislen == 0) {
    return;
  }
  type = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (type < 4)) {
      goto while_break;
    }
    {
    tmp = hist_type2char(type, 0);
    num_saved = get_viminfo_parameter(tmp);
    }
    if (num_saved == 0) {
      goto __Cont;
    }
    if (num_saved < 0) {
      num_saved = hislen;
    }
    if (type == 0) {
      tmp___2 = "Command Line";
    } else {
      if (type == 1) {
        tmp___1 = "Search String";
      } else {
        if (type == 2) {
          tmp___0 = "Expression";
        } else {
          tmp___0 = "Input Line";
        }
        tmp___1 = tmp___0;
      }
      tmp___2 = tmp___1;
    }
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# %s History (newest to oldest):\n",
            tmp___2);
    }
    if (num_saved > hislen) {
      num_saved = hislen;
    }
    i___0 = hisidx[type];
    if (i___0 >= 0) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        tmp___4 = num_saved;
        num_saved --;
        if (! tmp___4) {
          goto while_break___0;
        }
        if ((unsigned long )(history[type] + i___0)->hisstr != (unsigned long )((void *)0)) {
          {
          tmp___3 = hist_type2char(type, 1);
          _IO_putc(tmp___3, fp___0);
          viminfo_writestring(fp___0, (history[type] + i___0)->hisstr);
          }
        }
        i___0 --;
        if (i___0 < 0) {
          i___0 = hislen - 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: 
    type ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-t_UM_gnV.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
int recoverymode ;
int p_bk  ;
char_u *p_bdir  ;
char_u *p_bex  ;
char_u *p_ei  ;
char_u *p_pm  ;
int p_wb  ;
void filemess(BUF *buf___3 , char_u *name___1 , char_u *s , int attr ) ;
char_u *modname(char_u *fname , char_u *ext , int prepend_dot ) ;
void check_timestamps(int focus ) ;
void vim_deltempdir(void) ;
int check_ei(void) ;
int has_cursorhold(void) ;
int match_file_pat(char_u *pattern , char_u *fname , char_u *sfname , char_u *tail ,
                   int allow_dirs ) ;
void mf_fullname(MEMFILE *mfp ) ;
void check_need_swap(int newfile ) ;
char_u *get_file_in_dir(char_u *fname , char_u *dname ) ;
char_u *msg_may_trunc(int force , char_u *s ) ;
void add_pathsep(char_u *p___0 ) ;
int gen_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) ;
void do_outofmem_msg(void) ;
int decrypt_byte(void) ;
int update_keys(int c ) ;
void crypt_init_keys(char_u *passwd ) ;
void screenclear(void) ;
void u_unchanged(BUF *buf___3 ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
static void aucmd_prepbuf(struct aco_save *aco ) ;
static void aucmd_restbuf(struct aco_save *aco ) ;
static void check_marks_read(void) ;
static void set_file_time(char_u *fname , time_t atime , time_t mtime ) ;
static void msg_add_fname(BUF *buf___3 , char_u *fname ) ;
static int msg_add_fileformat(int eol_type ) ;
static void msg_add_lines(int insert_space , long lnum , long nchars ) ;
static void msg_add_eol(void) ;
static int check_mtime(BUF *buf___3 , struct stat *st ) ;
static int time_differs(long t1 , long t2 ) ;
static int write_buf(int fd , char_u *buf___3 , int len___0 , int docrypt ) ;
static linenr_t write_no_eol_lnum  =    (linenr_t )0;
void filemess(BUF *buf___3 , char_u *name___1 , char_u *s , int attr ) 
{ 
  int msg_scroll_save ;
  int tmp ;
  char_u *tmp___0 ;

  {
  {
  msg_add_fname(buf___3, name___1);
  strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s));
  msg_scroll_save = msg_scroll;
  tmp = shortmess('O');
  }
  if (tmp) {
    msg_scroll = 0;
  }
  if (! msg_scroll) {
    {
    check_for_delay(0);
    }
  }
  {
  msg_start();
  msg_scroll = msg_scroll_save;
  tmp___0 = msg_may_trunc(0, IObuff);
  msg_outtrans_attr(tmp___0, attr);
  msg_clr_eos();
  out_flush();
  }
  return;
}
}
int readfile(char_u *fname , char_u *sfname , linenr_t from , linenr_t lines_to_skip ,
             linenr_t lines_to_read , int flags___0 ) 
{ 
  int fd ;
  int newfile ;
  int check_readonly___0 ;
  int filtering ;
  int read_stdin ;
  char_u c ;
  linenr_t lnum ;
  char_u *ptr ;
  char_u *buffer ;
  char_u *new_buffer ;
  char_u *line_start ;
  int wasempty ;
  colnr_t len___0 ;
  long size ;
  char_u *p___0 ;
  long filesize ;
  char_u *cryptkey ;
  int split ;
  linenr_t linecnt ;
  int error ;
  int ff_error ;
  long linerest ;
  int perm ;
  int fileformat ;
  struct stat st ;
  int file_readonly ;
  linenr_t skip_count ;
  linenr_t read_count ;
  int msg_save ;
  linenr_t read_no_eol_lnum ;
  int try_mac ;
  char_u *tmp ;
  int try_dos ;
  char_u *tmp___0 ;
  int try_unix ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int m ;
  int n ;
  BUF *old_curbuf ;
  int tmp___12 ;
  int tmp___13 ;
  char_u tmp___14 ;
  int tmp___15 ;
  linenr_t tmp___16 ;
  __off_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int m___0 ;
  int n___0 ;

  {
  {
  newfile = flags___0 & 1;
  filtering = flags___0 & 2;
  read_stdin = flags___0 & 4;
  lnum = from;
  ptr = (char_u *)((void *)0);
  buffer = (char_u *)((void *)0);
  new_buffer = (char_u *)((void *)0);
  line_start = (char_u *)((void *)0);
  cryptkey = (char_u *)((void *)0);
  split = 0;
  error = 0;
  ff_error = -1;
  perm = 0;
  msg_save = msg_scroll;
  read_no_eol_lnum = (linenr_t )0;
  tmp = vim_strchr(p_ffs, 'm');
  try_mac = (unsigned long )tmp != (unsigned long )((void *)0);
  tmp___0 = vim_strchr(p_ffs, 'd');
  try_dos = (unsigned long )tmp___0 != (unsigned long )((void *)0);
  tmp___1 = vim_strchr(p_ffs, 'x');
  try_unix = (unsigned long )tmp___1 != (unsigned long )((void *)0);
  write_no_eol_lnum = (linenr_t )0;
  }
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    if (! filtering) {
      if (! read_stdin) {
        {
        tmp___3 = vim_strchr(p_cpo, 'f');
        }
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
          {
          tmp___2 = setfname(fname, sfname, 0);
          }
          if (tmp___2 == 1) {
            curbuf->b_flags |= 8;
          }
        }
      }
    }
  }
  {
  tmp___4 = shortmess('o');
  }
  if (tmp___4) {
    msg_scroll = 0;
  } else { //Added block
  if (curbuf->b_help) {
    msg_scroll = 0;
  } else {
    msg_scroll = 1;
  }
  }
  if ((unsigned long )sfname == (unsigned long )((void *)0)) {
    sfname = fname;
  }
  fname = sfname;
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    if ((int )*fname != 0) {
      {
      tmp___5 = strlen((char const   *)((char *)fname));
      tmp___6 = vim_ispathsep((int )*((fname + tmp___5) - 1));
      }
      if (tmp___6) {
        {
        filemess(curbuf, fname, (char_u *)"Illegal file name", 0);
        msg_end();
        msg_scroll = msg_save;
        }
        return (0);
      }
    }
  }
  if (! read_stdin) {
    {
    tmp___7 = mch_getperm(fname);
    perm = (int )tmp___7;
    }
    if (perm >= 0) {
      if (! ((perm & 61440) == 32768)) {
        if (! ((perm & 61440) == 4096)) {
          if (! ((perm & 61440) == 49152)) {
            if ((perm & 61440) == 16384) {
              {
              filemess(curbuf, fname, (char_u *)"is a directory", 0);
              }
            } else {
              {
              filemess(curbuf, fname, (char_u *)"is not a file", 0);
              }
            }
            {
            msg_end();
            msg_scroll = msg_save;
            }
            return (0);
          }
        }
      }
    }
  }
  if (newfile) {
    if (*p_ffs) {
      {
      tmp___8 = default_fileformat();
      set_fileformat(tmp___8);
      }
    }
  }
  if (newfile) {
    if (curbuf->b_flags & 2) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
  } else {
    tmp___9 = 0;
  }
  check_readonly___0 = tmp___9;
  if (check_readonly___0) {
    if (! readonlymode) {
      curbuf->b_p_ro = 0;
    }
  }
  if (newfile) {
    if (! read_stdin) {
      {
      tmp___10 = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
      }
      if (tmp___10 >= 0) {
        curbuf->b_mtime = st.st_mtim.tv_sec;
        curbuf->b_mtime_read = st.st_mtim.tv_sec;
        if ((unsigned long )(curbuf->b_ml.ml_mfp)->mf_fname != (unsigned long )((void *)0)) {
          {
          mch_setperm((curbuf->b_ml.ml_mfp)->mf_fname, (long )((st.st_mode & 511U) | 384U));
          }
        }
      } else {
        curbuf->b_mtime = 0L;
        curbuf->b_mtime_read = 0L;
      }
      curbuf->b_flags &= -49;
    }
  }
  file_readonly = 0;
  if (read_stdin) {
    fd = 0;
  } else {
    if (! (perm & 146)) {
      file_readonly = 1;
    } else {
      {
      tmp___11 = access((char const   *)((char *)fname), 2);
      }
      if (tmp___11) {
        file_readonly = 1;
      }
    }
    {
    fd = open((char const   *)((char *)fname), 0, 0);
    }
  }
  if (fd < 0) {
    msg_scroll = msg_save;
    if (newfile) {
      if (perm < 0) {
        {
        curbuf->b_flags |= 16;
        check_need_swap(newfile);
        filemess(curbuf, sfname, (char_u *)"[New File]", 0);
        check_marks_read();
        apply_autocmds((EVENT_T )6, sfname, sfname, 0, curbuf);
        curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
        }
        return (1);
      } else {
        {
        filemess(curbuf, sfname, (char_u *)"[Permission Denied]", 0);
        }
      }
    }
    return (0);
  }
  if (check_readonly___0) {
    if (file_readonly) {
      curbuf->b_p_ro = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (curbuf->b_help) {
    curbuf->b_p_ro = 1;
  }
  }
  if (newfile) {
    curbuf->b_p_eol = 1;
  }
  {
  check_need_swap(newfile);
  }
  if (swap_exists_action == 2) {
    {
    close(fd);
    }
    return (0);
  }
  no_wait_return ++;
  if (from == 0L) {
    curbuf->b_op_start.lnum = (linenr_t )1;
  } else {
    curbuf->b_op_start.lnum = from;
  }
  curbuf->b_op_start.col = (colnr_t )0;
  m = msg_scroll;
  n = msg_scrolled;
  old_curbuf = curbuf;
  if (! read_stdin) {
    {
    close(fd);
    }
  }
  msg_scroll = 1;
  if (filtering) {
    {
    apply_autocmds((EVENT_T )22, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else { //Added block
  if (read_stdin) {
    {
    apply_autocmds((EVENT_T )29, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else { //Added block
  if (newfile) {
    {
    apply_autocmds((EVENT_T )8, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else {
    {
    apply_autocmds((EVENT_T )17, sfname, sfname, 0, (BUF *)((void *)0));
    }
  }
  }
  }
  if (msg_scrolled == n) {
    msg_scroll = m;
  }
  if (! read_stdin) {
    if ((unsigned long )curbuf != (unsigned long )old_curbuf) {
      goto _L___0;
    } else {
      {
      fd = open((char const   *)((char *)fname), 0, 0);
      }
      if (fd < 0) {
        _L___0: 
        no_wait_return --;
        msg_scroll = msg_save;
        if (fd < 0) {
          {
          emsg((char_u *)"*ReadPre autocommands made the file unreadable");
          }
        } else {
          {
          emsg((char_u *)"*ReadPre autocommands must not change current buffer");
          }
        }
        return (0);
      }
    }
  }
  wasempty = curbuf->b_ml.ml_flags & 1;
  if (! recoverymode) {
    if (! filtering) {
      if (read_stdin) {
        {
        printf((char const   * __restrict  )"%s", "Vim: Reading from stdin...\n");
        }
      } else {
        {
        filemess(curbuf, sfname, (char_u *)"", 0);
        }
      }
    }
  }
  msg_scroll = 0;
  if (curbuf->b_p_bin) {
    fileformat = 0;
  } else { //Added block
  if ((int )*p_ffs == 0) {
    {
    fileformat = get_fileformat(curbuf);
    }
  } else {
    fileformat = -1;
  }
  }
  linecnt = curbuf->b_ml.ml_line_count;
  retry: 
  linerest = 0L;
  filesize = 0L;
  skip_count = lines_to_skip;
  read_count = lines_to_read;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! error) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    size = 65536L;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (size >= 10L)) {
        goto while_break___0;
      }
      {
      new_buffer = lalloc((long_u )((size + linerest) + 1L), 0);
      }
      if ((unsigned long )new_buffer != (unsigned long )((void *)0)) {
        goto while_break___0;
      }
      size = (long )((long_u )size >> 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
      {
      do_outofmem_msg();
      error = 1;
      }
      goto while_break;
    }
    if (linerest) {
      {
      memmove((void *)((char *)new_buffer), (void const   *)((char *)(ptr - linerest)),
              (size_t )linerest);
      }
    }
    {
    vim_free((void *)buffer);
    buffer = new_buffer;
    ptr = buffer + linerest;
    line_start = buffer;
    size = read(fd, (void *)((char *)ptr), (size_t )size);
    }
    if (size <= 0L) {
      if (size < 0L) {
        error = 1;
      }
      goto while_break;
    }
    if (filesize == 0L) {
      {
      tmp___12 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"VimCrypt~01!"),
                         (size_t )12);
      }
      if (tmp___12 == 0) {
        if ((unsigned long )cryptkey == (unsigned long )((void *)0)) {
          if (*(curbuf->b_p_key)) {
            cryptkey = curbuf->b_p_key;
          } else {
            {
            cryptkey = get_crypt_key(newfile);
            }
            if ((unsigned long )cryptkey != (unsigned long )((void *)0)) {
              if ((int )*cryptkey == 0) {
                if ((unsigned long )cryptkey != (unsigned long )curbuf->b_p_key) {
                  {
                  vim_free((void *)cryptkey);
                  }
                }
                cryptkey = (char_u *)((void *)0);
              }
            }
          }
        }
        if ((unsigned long )cryptkey != (unsigned long )((void *)0)) {
          {
          crypt_init_keys(cryptkey);
          filesize += 12L;
          size -= 12L;
          memmove((void *)((char *)ptr), (void const   *)((char *)(ptr + 12)), (size_t )size);
          }
        }
      } else { //Added block
      if (newfile) {
        if (*(curbuf->b_p_key)) {
          if (! starting) {
            {
            set_option_value((char_u *)"key", 0L, (char_u *)"");
            }
          }
        }
      }
      }
    }
    if ((unsigned long )cryptkey != (unsigned long )((void *)0)) {
      p___0 = ptr;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((unsigned long )p___0 < (unsigned long )(ptr + size))) {
          goto while_break___1;
        }
        {
        tmp___13 = decrypt_byte();
        tmp___14 = (char_u )((int )*p___0 ^ tmp___13);
        *p___0 = tmp___14;
        update_keys((int )tmp___14);
        p___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    filesize += size;
    if (fileformat == -1) {
      if (try_dos) {
        goto _L___1;
      } else { //Added block
      if (try_unix) {
        _L___1: 
        p___0 = ptr;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! ((unsigned long )p___0 < (unsigned long )(ptr + size))) {
            goto while_break___2;
          }
          if ((int )*p___0 == 10) {
            if (! try_unix) {
              fileformat = 1;
            } else { //Added block
            if (try_dos) {
              if ((unsigned long )p___0 > (unsigned long )ptr) {
                if ((int )*(p___0 + -1) == 13) {
                  fileformat = 1;
                } else {
                  fileformat = 0;
                }
              } else {
                fileformat = 0;
              }
            } else {
              fileformat = 0;
            }
            }
            goto while_break___2;
          }
          p___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        if (fileformat == 0) {
          if (try_mac) {
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              if ((unsigned long )p___0 >= (unsigned long )ptr) {
                if (! ((int )*p___0 != 13)) {
                  goto while_break___3;
                }
              } else {
                goto while_break___3;
              }
              p___0 --;
            }
            while_break___3: /* CIL Label */ ;
            }
            if ((unsigned long )p___0 >= (unsigned long )ptr) {
              p___0 = ptr;
              {
              while (1) {
                while_continue___4: /* CIL Label */ ;
                if (! ((unsigned long )p___0 < (unsigned long )(ptr + size))) {
                  goto while_break___4;
                }
                if ((int )*p___0 == 10) {
                  try_unix ++;
                } else { //Added block
                if ((int )*p___0 == 13) {
                  try_mac ++;
                }
                }
                p___0 ++;
              }
              while_break___4: /* CIL Label */ ;
              }
              if (try_mac > try_unix) {
                fileformat = 2;
              }
            }
          }
        }
      }
      }
      if (fileformat == -1) {
        if (try_mac) {
          fileformat = 2;
        }
      }
      if (fileformat == -1) {
        {
        fileformat = default_fileformat();
        }
      }
      if (newfile) {
        {
        set_fileformat(fileformat);
        }
      }
    }
    if (fileformat == 2) {
      ptr --;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        ptr ++;
        size --;
        if (! (size >= 0L)) {
          goto while_break___5;
        }
        c = *ptr;
        if ((int )c != 0) {
          if ((int )c != 13) {
            if ((int )c != 10) {
              goto while_continue___5;
            }
          }
        }
        if ((int )c == 0) {
          *ptr = (char_u )'\n';
        } else { //Added block
        if ((int )c == 10) {
          *ptr = (char_u )'\r';
        } else {
          if (skip_count == 0L) {
            {
            *ptr = (char_u )'\000';
            len___0 = (colnr_t )((ptr - line_start) + 1L);
            tmp___15 = ml_append(lnum, line_start, len___0, newfile);
            }
            if (tmp___15 == 0) {
              error = 1;
              goto while_break___5;
            }
            lnum ++;
            read_count --;
            if (read_count == 0L) {
              error = 1;
              line_start = ptr;
              goto while_break___5;
            }
          } else {
            skip_count --;
          }
          line_start = ptr + 1;
        }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
      ptr --;
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        ptr ++;
        size --;
        if (! (size >= 0L)) {
          goto while_break___6;
        }
        c = *ptr;
        if ((int )c != 0) {
          if ((int )c != 10) {
            goto while_continue___6;
          }
        }
        if ((int )c == 0) {
          *ptr = (char_u )'\n';
        } else {
          if (skip_count == 0L) {
            *ptr = (char_u )'\000';
            len___0 = (colnr_t )((ptr - line_start) + 1L);
            if (fileformat == 1) {
              if ((int )*(ptr + -1) == 13) {
                *(ptr + -1) = (char_u )'\000';
                len___0 --;
              } else { //Added block
              if (ff_error != 1) {
                if (try_unix) {
                  if (! read_stdin) {
                    {
                    tmp___17 = lseek(fd, 0L, 0);
                    }
                    if (tmp___17 == 0L) {
                      {
                      while (1) {
                        while_continue___7: /* CIL Label */ ;
                        if (! (lnum > from)) {
                          goto while_break___7;
                        }
                        {
                        tmp___16 = lnum;
                        lnum --;
                        ml_delete(tmp___16, 0);
                        }
                      }
                      while_break___7: /* CIL Label */ ;
                      }
                      fileformat = 0;
                      if (newfile) {
                        {
                        set_fileformat(0);
                        }
                      }
                      goto retry;
                    } else {
                      ff_error = 1;
                    }
                  } else {
                    ff_error = 1;
                  }
                } else {
                  ff_error = 1;
                }
              }
              }
            }
            {
            tmp___18 = ml_append(lnum, line_start, len___0, newfile);
            }
            if (tmp___18 == 0) {
              error = 1;
              goto while_break___6;
            }
            lnum ++;
            read_count --;
            if (read_count == 0L) {
              error = 1;
              line_start = ptr;
              goto while_break___6;
            }
          } else {
            skip_count --;
          }
          line_start = ptr + 1;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
    linerest = ptr - line_start;
    ui_breakcheck();
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (error) {
    if (read_count == 0L) {
      error = 0;
    }
  }
  if (! error) {
    if (! got_int) {
      if (linerest != 0L) {
        if (! curbuf->b_p_bin) {
          if (fileformat == 1) {
            if ((int )*line_start == 26) {
              if (! ((unsigned long )ptr == (unsigned long )(line_start + 1))) {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          if (newfile) {
            curbuf->b_p_eol = 0;
          }
          {
          *ptr = (char_u )'\000';
          tmp___19 = ml_append(lnum, line_start, (colnr_t )((ptr - line_start) + 1L),
                               newfile);
          }
          if (tmp___19 == 0) {
            error = 1;
          } else {
            lnum ++;
            read_no_eol_lnum = lnum;
          }
        }
      }
    }
  }
  if (lnum != from) {
    if (! newfile) {
      {
      changed();
      }
    }
  }
  {
  invalidate_botline();
  changed_line_abv_curs();
  }
  if (newfile) {
    curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
  }
  if ((unsigned long )cryptkey != (unsigned long )curbuf->b_p_key) {
    {
    vim_free((void *)cryptkey);
    }
  }
  {
  close(fd);
  vim_free((void *)buffer);
  no_wait_return --;
  }
  if (! recoverymode) {
    if (newfile) {
      if (wasempty) {
        if (! (curbuf->b_ml.ml_flags & 1)) {
          {
          ml_delete(curbuf->b_ml.ml_line_count, 0);
          linecnt --;
          }
        }
      }
    }
    linecnt = curbuf->b_ml.ml_line_count - linecnt;
    if (filesize == 0L) {
      linecnt = (linenr_t )0;
    }
    if (! newfile) {
      {
      mark_adjust(from + 1L, (linenr_t )2147483647, linecnt, 0L);
      }
    }
    if (read_stdin) {
      {
      settmode(2);
      starttermcap();
      screenclear();
      }
    }
    if (got_int) {
      {
      filemess(curbuf, sfname, e_interr, 0);
      msg_scroll = msg_save;
      check_marks_read();
      }
      return (1);
    }
    if (! filtering) {
      {
      msg_add_fname(curbuf, sfname);
      c = (char_u )0;
      }
      if ((perm & 61440) == 4096) {
        {
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"[fifo/socket]"));
        c = (char_u )1;
        }
      }
      if (curbuf->b_p_ro) {
        {
        tmp___22 = shortmess('r');
        }
        if (tmp___22) {
          tmp___21 = "[RO]";
        } else {
          tmp___21 = "[readonly]";
        }
        {
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___21));
        c = (char_u )1;
        }
      }
      if (read_no_eol_lnum) {
        {
        msg_add_eol();
        c = (char_u )1;
        }
      }
      if (ff_error == 1) {
        {
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"[CR missing]"));
        c = (char_u )1;
        }
      }
      if (ff_error == 2) {
        {
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"[NL found]"));
        c = (char_u )1;
        }
      }
      if (split) {
        {
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"[long lines split]"));
        c = (char_u )1;
        }
      }
      if ((unsigned long )cryptkey != (unsigned long )((void *)0)) {
        {
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"[crypted]"));
        c = (char_u )1;
        }
      }
      if (error) {
        {
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"[READ ERRORS]"));
        c = (char_u )1;
        }
      }
      {
      tmp___23 = msg_add_fileformat(fileformat);
      }
      if (tmp___23) {
        c = (char_u )1;
      }
      {
      msg_add_lines((int )c, linecnt, filesize);
      keep_msg = msg_trunc_attr(IObuff, 0, 0);
      keep_msg_attr = 0;
      }
      if (read_stdin) {
        goto _L___5;
      } else { //Added block
      if (restart_edit != 0) {
        _L___5: 
        if ((unsigned long )keep_msg != (unsigned long )((void *)0)) {
          {
          strncpy((char * __restrict  )((char *)(msg_buf)), (char const   * __restrict  )((char *)keep_msg),
                  (size_t )80);
          msg_buf[79] = (char_u )'\000';
          keep_msg = msg_buf;
          }
        } else {
          keep_msg = (char_u *)((void *)0);
        }
      } else {
        keep_msg = (char_u *)((void *)0);
      }
      }
    }
    if (error) {
      if (newfile) {
        curbuf->b_p_ro = 1;
      }
    }
    {
    u_clearline();
    }
    if (exmode_active) {
      curwin->w_cursor.lnum = from + linecnt;
    } else {
      curwin->w_cursor.lnum = from + 1L;
    }
    {
    check_cursor_lnum();
    beginline(5);
    curbuf->b_op_start.lnum = from + 1L;
    curbuf->b_op_start.col = (colnr_t )0;
    curbuf->b_op_end.lnum = from + linecnt;
    curbuf->b_op_end.col = (colnr_t )0;
    }
  }
  {
  msg_scroll = msg_save;
  check_marks_read();
  m___0 = msg_scroll;
  n___0 = msg_scrolled;
  write_no_eol_lnum = read_no_eol_lnum;
  msg_scroll = 1;
  }
  if (filtering) {
    {
    apply_autocmds((EVENT_T )21, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else { //Added block
  if (read_stdin) {
    {
    apply_autocmds((EVENT_T )28, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else { //Added block
  if (newfile) {
    {
    apply_autocmds((EVENT_T )7, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else {
    {
    apply_autocmds((EVENT_T )16, sfname, sfname, 0, (BUF *)((void *)0));
    }
  }
  }
  }
  if (msg_scrolled == n___0) {
    msg_scroll = m___0;
  }
  if (recoverymode) {
    if (error) {
      return (0);
    }
  }
  return (1);
}
}
static void check_marks_read(void) 
{ 
  int tmp ;

  {
  if (! curbuf->b_marks_read) {
    {
    tmp = get_viminfo_parameter('\'');
    }
    if (tmp > 0) {
      {
      read_viminfo((char_u *)((void *)0), 0, 1, 0);
      curbuf->b_marks_read = 1;
      }
    }
  }
  return;
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
static void set_file_time(char_u *fname , time_t atime , time_t mtime ) 
{ 
  struct utimbuf buf___3 ;

  {
  {
  buf___3.actime = atime;
  buf___3.modtime = mtime;
  utime((char const   *)((char *)fname), (struct utimbuf  const  *)(& buf___3));
  }
  return;
}
}
int buf_write(BUF *buf___3 , char_u *fname , char_u *sfname , linenr_t start___0 ,
              linenr_t end , int append , int forceit , int reset_changed , int filtering ) 
{ 
  int fd ;
  char_u *backup ;
  char_u *ffname ;
  char_u *s ;
  char_u *ptr ;
  char_u c ;
  int len___0 ;
  linenr_t lnum ;
  long nchars ;
  char_u *errmsg ;
  char_u *buffer ;
  char_u smallbuf[256] ;
  char_u *backup_ext ;
  int bufsize ;
  long perm ;
  int retval ;
  int newfile ;
  int msg_save ;
  int overwriting ;
  int no_eol ;
  struct stat st_old ;
  int made_writable ;
  int whole ;
  int tmp ;
  linenr_t old_line_count ;
  int attr ;
  int fileformat ;
  int encrypted ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct aco_save aco ;
  BUF *save_buf ;
  int buf_ffname ;
  int buf_sfname ;
  int buf_fname_f ;
  int buf_fname_s ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int bfd ;
  int buflen ;
  char_u copybuf[8193] ;
  char_u *wp ;
  int some_error ;
  struct stat st_new ;
  char_u *dirp ;
  char_u *rootname ;
  int did_set_shortname ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  ssize_t tmp___15 ;
  int tmp___16 ;
  __uid_t tmp___17 ;
  char_u *tmp___18 ;
  int tmp___19 ;
  __uid_t tmp___20 ;
  __gid_t tmp___21 ;
  char_u *tmp___22 ;
  struct stat st ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;
  char_u *tmp___30 ;
  char_u *tmp___31 ;
  int tmp___32 ;
  char_u *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char_u copybuf___0[8193] ;
  int bfd___0 ;
  int buflen___0 ;
  int tmp___37 ;
  ssize_t tmp___38 ;
  int tmp___39 ;
  char const   *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char const   *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char *org ;
  int tmp___48 ;
  char_u *tmp___49 ;
  struct stat st___0 ;
  int tmp___50 ;
  int empty_fd ;
  long tmp___51 ;
  int tmp___52 ;
  struct aco_save aco___0 ;
  BUF *save_buf___0 ;
  int tmp___53 ;

  {
  backup = (char_u *)((void *)0);
  errmsg = (char_u *)((void *)0);
  retval = 1;
  newfile = 0;
  msg_save = msg_scroll;
  no_eol = 0;
  made_writable = 0;
  if (start___0 == 1L) {
    if (end == buf___3->b_ml.ml_line_count) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  whole = tmp;
  old_line_count = buf___3->b_ml.ml_line_count;
  encrypted = 0;
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    return (0);
  } else { //Added block
  if ((int )*fname == 0) {
    return (0);
  }
  }
  if (reset_changed) {
    if (whole) {
      if ((unsigned long )buf___3 == (unsigned long )curbuf) {
        if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
          if (! filtering) {
            {
            tmp___1 = vim_strchr(p_cpo, 'F');
            }
            if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
              {
              apply_autocmds((EVENT_T )1, (char_u *)((void *)0), (char_u *)((void *)0),
                             0, curbuf);
              tmp___0 = setfname(fname, sfname, 0);
              }
              if (tmp___0 == 1) {
                curbuf->b_flags |= 8;
              }
              {
              apply_autocmds((EVENT_T )0, (char_u *)((void *)0), (char_u *)((void *)0),
                             0, curbuf);
              }
            }
          }
        }
      }
    }
  }
  if ((unsigned long )sfname == (unsigned long )((void *)0)) {
    sfname = fname;
  }
  ffname = fname;
  fname = sfname;
  if ((int )*p_bex == 0) {
    backup_ext = (char_u *)".bak";
  } else {
    backup_ext = p_bex;
  }
  if ((unsigned long )buf___3->b_ffname != (unsigned long )((void *)0)) {
    {
    tmp___2 = strcmp((char const   *)((char *)ffname), (char const   *)((char *)buf___3->b_ffname));
    }
    if (tmp___2 == 0) {
      overwriting = 1;
    } else {
      overwriting = 0;
    }
  } else {
    overwriting = 0;
  }
  {
  tmp___3 = check_secure();
  }
  if (tmp___3) {
    return (0);
  }
  if (exiting) {
    {
    settmode(0);
    }
  }
  no_wait_return ++;
  buf___3->b_op_start.lnum = start___0;
  buf___3->b_op_start.col = (colnr_t )0;
  buf___3->b_op_end.lnum = end;
  buf___3->b_op_end.col = (colnr_t )0;
  buf_ffname = 0;
  buf_sfname = 0;
  buf_fname_f = 0;
  buf_fname_s = 0;
  if ((unsigned long )ffname == (unsigned long )buf___3->b_ffname) {
    buf_ffname = 1;
  }
  if ((unsigned long )sfname == (unsigned long )buf___3->b_sfname) {
    buf_sfname = 1;
  }
  if ((unsigned long )fname == (unsigned long )buf___3->b_ffname) {
    buf_fname_f = 1;
  }
  if ((unsigned long )fname == (unsigned long )buf___3->b_sfname) {
    buf_fname_s = 1;
  }
  {
  save_buf = curbuf;
  curbuf = buf___3;
  aucmd_prepbuf(& aco);
  }
  if (append) {
    {
    apply_autocmds((EVENT_T )14, fname, fname, 0, curbuf);
    }
  } else { //Added block
  if (filtering) {
    {
    apply_autocmds((EVENT_T )24, (char_u *)((void *)0), fname, 0, curbuf);
    }
  } else { //Added block
  if (reset_changed) {
    if (whole) {
      {
      apply_autocmds((EVENT_T )12, fname, fname, 0, curbuf);
      }
    } else {
      {
      apply_autocmds((EVENT_T )20, fname, fname, 0, curbuf);
      }
    }
  } else {
    {
    apply_autocmds((EVENT_T )20, fname, fname, 0, curbuf);
    }
  }
  }
  }
  {
  aucmd_restbuf(& aco);
  tmp___4 = buf_valid(buf___3);
  }
  if (tmp___4) {
    if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      {
      curbuf = curwin->w_buffer;
      no_wait_return --;
      msg_scroll = msg_save;
      emsg((char_u *)"Autocommands deleted or unloaded buffer to be written");
      }
      return (0);
    }
  } else {
    {
    curbuf = curwin->w_buffer;
    no_wait_return --;
    msg_scroll = msg_save;
    emsg((char_u *)"Autocommands deleted or unloaded buffer to be written");
    }
    return (0);
  }
  if ((unsigned long )curbuf == (unsigned long )buf___3) {
    {
    tmp___5 = buf_valid(save_buf);
    }
    if (tmp___5) {
      ((curwin->w_buffer)->b_nwindows) --;
      curbuf = save_buf;
      curwin->w_buffer = save_buf;
      (curbuf->b_nwindows) ++;
    } else {
      curbuf = curwin->w_buffer;
    }
  } else {
    curbuf = curwin->w_buffer;
  }
  if (buf___3->b_ml.ml_line_count != old_line_count) {
    if (whole) {
      end = buf___3->b_ml.ml_line_count;
    } else { //Added block
    if (buf___3->b_ml.ml_line_count > old_line_count) {
      end += buf___3->b_ml.ml_line_count - old_line_count;
    } else {
      end -= old_line_count - buf___3->b_ml.ml_line_count;
      if (end < start___0) {
        {
        no_wait_return --;
        msg_scroll = msg_save;
        emsg((char_u *)"Autocommand changed number of lines in unexpected way");
        }
        return (0);
      }
    }
    }
  }
  if (buf_ffname) {
    ffname = buf___3->b_ffname;
  }
  if (buf_sfname) {
    sfname = buf___3->b_sfname;
  }
  if (buf_fname_f) {
    fname = buf___3->b_ffname;
  }
  if (buf_fname_s) {
    fname = buf___3->b_sfname;
  }
  {
  tmp___6 = shortmess('o');
  }
  if (tmp___6) {
    msg_scroll = 0;
  } else {
    msg_scroll = 1;
  }
  if (! filtering) {
    {
    filemess(buf___3, fname, (char_u *)"", 0);
    }
  }
  {
  msg_scroll = 0;
  buffer = alloc(8192U);
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    buffer = smallbuf;
    bufsize = 256;
  } else {
    bufsize = 8192;
  }
  {
  st_old.st_ino = (__ino_t )0;
  st_old.st_dev = st_old.st_ino;
  perm = -1L;
  tmp___7 = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st_old));
  }
  if (tmp___7 < 0) {
    newfile = 1;
  } else {
    if (! ((st_old.st_mode & 61440U) == 32768U)) {
      if ((st_old.st_mode & 61440U) == 16384U) {
        errmsg = (char_u *)"is a directory";
      } else {
        errmsg = (char_u *)"is not a file";
      }
      goto fail;
    }
    if (overwriting) {
      {
      retval = check_mtime(buf___3, & st_old);
      }
      if (retval == 0) {
        goto fail;
      }
    }
    perm = (long )st_old.st_mode;
  }
  if (! append) {
    if (! filtering) {
      if (perm >= 0L) {
        if (p_wb) {
          goto _L___0;
        } else { //Added block
        if (p_bk) {
          goto _L___0;
        } else { //Added block
        if ((int )*p_pm != 0) {
          _L___0: 
          {
          fd = open((char const   *)((char *)fname), 0, 0);
          }
          if (fd >= 0) {
            some_error = 0;
            dirp = p_bdir;
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              if (! *dirp) {
                goto while_break;
              }
              {
              st_new.st_ino = (__ino_t )0;
              st_new.st_dev = st_new.st_ino;
              st_new.st_gid = (__gid_t )0;
              copy_option_part(& dirp, copybuf, 8192, (char *)",");
              rootname = get_file_in_dir(fname, copybuf);
              }
              if ((unsigned long )rootname == (unsigned long )((void *)0)) {
                some_error = 1;
                goto nobackup;
              }
              did_set_shortname = 0;
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (buf___3->b_p_sn) {
                  tmp___8 = 1;
                } else { //Added block
                if (buf___3->b_shortname) {
                  tmp___8 = 1;
                } else {
                  tmp___8 = 0;
                }
                }
                {
                backup = buf_modname(tmp___8, rootname, backup_ext, 0);
                }
                if ((unsigned long )backup == (unsigned long )((void *)0)) {
                  {
                  some_error = 1;
                  vim_free((void *)rootname);
                  }
                  goto nobackup;
                }
                {
                tmp___12 = stat((char const   * __restrict  )((char *)backup), (struct stat * __restrict  )(& st_new));
                }
                if (tmp___12 >= 0) {
                  if (st_new.st_dev == st_old.st_dev) {
                    if (st_new.st_ino == st_old.st_ino) {
                      {
                      vim_free((void *)backup);
                      backup = (char_u *)((void *)0);
                      }
                      if (! buf___3->b_shortname) {
                        if (! buf___3->b_p_sn) {
                          buf___3->b_shortname = 1;
                          did_set_shortname = 1;
                          goto __Cont;
                        }
                      }
                      if (did_set_shortname) {
                        buf___3->b_shortname = 0;
                      }
                      goto while_break___0;
                    }
                  }
                  if (! p_bk) {
                    {
                    tmp___9 = strlen((char const   *)((char *)backup));
                    tmp___10 = strlen((char const   *)((char *)backup_ext));
                    wp = ((backup + tmp___9) - 1) - tmp___10;
                    }
                    if ((unsigned long )wp < (unsigned long )backup) {
                      wp = backup;
                    }
                    *wp = (char_u )'z';
                    {
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
                      if ((int )*wp > 97) {
                        {
                        tmp___11 = stat((char const   * __restrict  )((char *)backup),
                                        (struct stat * __restrict  )(& st_new));
                        }
                        if (! (tmp___11 >= 0)) {
                          goto while_break___1;
                        }
                      } else {
                        goto while_break___1;
                      }
                      *wp = (char_u )((int )*wp - 1);
                    }
                    while_break___1: /* CIL Label */ ;
                    }
                    if ((int )*wp == 97) {
                      {
                      vim_free((void *)backup);
                      backup = (char_u *)((void *)0);
                      }
                    }
                  }
                }
                goto while_break___0;
                __Cont: ;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              vim_free((void *)rootname);
              }
              if ((unsigned long )backup != (unsigned long )((void *)0)) {
                {
                unlink((char const   *)((char *)backup));
                bfd = open((char const   *)((char *)backup), 193, 438);
                }
                if (bfd < 0) {
                  {
                  vim_free((void *)backup);
                  backup = (char_u *)((void *)0);
                  }
                } else {
                  {
                  mch_setperm(backup, perm & 511L);
                  }
                  if (st_new.st_gid != st_old.st_gid) {
                    {
                    tmp___13 = fchown(bfd, (uid_t )-1, st_old.st_gid);
                    }
                    if (tmp___13 != 0) {
                      {
                      mch_setperm(backup, (perm & 455L) | ((perm & 7L) << 3));
                      }
                    }
                  }
                  {
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
                    {
                    tmp___15 = read(fd, (void *)((char *)(copybuf)), (size_t )8192);
                    buflen = (int )tmp___15;
                    }
                    if (! (buflen > 0)) {
                      goto while_break___2;
                    }
                    {
                    tmp___14 = write_buf(bfd, copybuf, buflen, 0);
                    }
                    if (tmp___14 == 0) {
                      errmsg = (char_u *)"Can\'t write to backup file (use ! to override)";
                      goto while_break___2;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
                  {
                  tmp___16 = close(bfd);
                  }
                  if (tmp___16 < 0) {
                    if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
                      errmsg = (char_u *)"Close error for backup file (use ! to override)";
                    }
                  }
                  if (buflen < 0) {
                    errmsg = (char_u *)"Can\'t read file for backup (use ! to override)";
                  }
                  {
                  set_file_time(backup, st_old.st_atim.tv_sec, st_old.st_mtim.tv_sec);
                  }
                  goto while_break;
                }
              }
            }
            while_break: /* CIL Label */ ;
            }
            nobackup: 
            {
            close(fd);
            }
            if ((unsigned long )backup == (unsigned long )((void *)0)) {
              if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
                errmsg = (char_u *)"Cannot create backup file (use ! to override)";
              }
            }
            if (some_error) {
              goto _L;
            } else { //Added block
            if (errmsg) {
              _L: 
              if (! forceit) {
                retval = 0;
                goto fail;
              }
            }
            }
            errmsg = (char_u *)((void *)0);
          }
        }
        }
        }
      }
    }
  }
  if (forceit) {
    {
    tmp___17 = getuid();
    }
    if (st_old.st_uid == tmp___17) {
      if (perm >= 0L) {
        if (! (perm & 128L)) {
          {
          tmp___18 = vim_strchr(p_cpo, 'W');
          }
          if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
            {
            perm |= 128L;
            mch_setperm(fname, perm);
            made_writable = 1;
            }
          }
        }
      }
    }
  }
  if (forceit) {
    if (overwriting) {
      buf___3->b_p_ro = 0;
    }
  }
  if (reset_changed) {
    if (! newfile) {
      {
      tmp___19 = otherfile(ffname);
      }
      if (! tmp___19) {
        if (exiting) {
          if (! ((unsigned long )backup != (unsigned long )((void *)0))) {
            {
            ml_preserve(buf___3, 0);
            }
          }
        } else {
          {
          ml_preserve(buf___3, 0);
          }
        }
      }
    }
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (append) {
      if (forceit) {
        tmp___25 = 1088;
      } else {
        tmp___25 = 1024;
      }
      tmp___26 = tmp___25;
    } else {
      tmp___26 = 576;
    }
    {
    fd = open((char const   *)((char *)fname), 1 | tmp___26, 438);
    }
    if (! (fd < 0)) {
      goto while_break___3;
    }
    if (! errmsg) {
      errmsg = (char_u *)"Can\'t open file for writing";
      if (forceit) {
        {
        tmp___22 = vim_strchr(p_cpo, 'W');
        }
        if ((unsigned long )tmp___22 == (unsigned long )((void *)0)) {
          if (! (perm & 128L)) {
            made_writable = 1;
          }
          {
          perm |= 128L;
          tmp___20 = getuid();
          }
          if (st_old.st_uid != tmp___20) {
            perm &= 511L;
          } else {
            {
            tmp___21 = getgid();
            }
            if (st_old.st_gid != tmp___21) {
              perm &= 511L;
            }
          }
          if (! append) {
            {
            unlink((char const   *)((char *)fname));
            }
          }
          goto while_continue___3;
        }
      }
    }
    if ((unsigned long )backup != (unsigned long )((void *)0)) {
      {
      tmp___23 = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
      }
      if (tmp___23 < 0) {
        {
        vim_rename(backup, fname);
        }
      }
      {
      tmp___24 = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
      }
      if (tmp___24 >= 0) {
        {
        unlink((char const   *)((char *)backup));
        }
      }
    }
    goto fail;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  errmsg = (char_u *)((void *)0);
  fileformat = get_fileformat(buf___3);
  }
  if (end > buf___3->b_ml.ml_line_count) {
    end = buf___3->b_ml.ml_line_count;
  }
  len___0 = 0;
  s = buffer;
  nchars = 0L;
  if (buf___3->b_ml.ml_flags & 1) {
    start___0 = end + 1L;
  }
  if (*(buf___3->b_p_key)) {
    {
    crypt_init_keys(buf___3->b_p_key);
    encrypted = 1;
    tmp___27 = write_buf(fd, (char_u *)"VimCrypt~01!", 12, 0);
    }
    if (tmp___27 == 0) {
      end = (linenr_t )0;
    }
  }
  lnum = start___0;
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    if (! (lnum <= end)) {
      goto while_break___4;
    }
    {
    tmp___28 = ml_get_buf(buf___3, lnum, 0);
    ptr = tmp___28 - 1;
    }
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      ptr ++;
      c = *ptr;
      if (! ((int )c != 0)) {
        goto while_break___5;
      }
      if ((int )c == 10) {
        *s = (char_u )'\000';
      } else { //Added block
      if ((int )c == 13) {
        if (fileformat == 2) {
          *s = (char_u )'\n';
        } else {
          *s = c;
        }
      } else {
        *s = c;
      }
      }
      s ++;
      len___0 ++;
      if (len___0 != bufsize) {
        goto while_continue___5;
      }
      {
      tmp___29 = write_buf(fd, buffer, bufsize, encrypted);
      }
      if (tmp___29 == 0) {
        end = (linenr_t )0;
        goto while_break___5;
      }
      nchars += (long )bufsize;
      s = buffer;
      len___0 = 0;
    }
    while_break___5: /* CIL Label */ ;
    }
    if (end == 0L) {
      lnum ++;
      no_eol = 1;
      goto while_break___4;
    } else { //Added block
    if (lnum == end) {
      if (buf___3->b_p_bin) {
        if (lnum == write_no_eol_lnum) {
          lnum ++;
          no_eol = 1;
          goto while_break___4;
        } else { //Added block
        if (lnum == buf___3->b_ml.ml_line_count) {
          if (! buf___3->b_p_eol) {
            lnum ++;
            no_eol = 1;
            goto while_break___4;
          }
        }
        }
      }
    }
    }
    if (fileformat == 0) {
      tmp___30 = s;
      s ++;
      *tmp___30 = (char_u )'\n';
    } else {
      tmp___31 = s;
      s ++;
      *tmp___31 = (char_u )'\r';
      if (fileformat == 1) {
        len___0 ++;
        if (len___0 == bufsize) {
          {
          tmp___32 = write_buf(fd, buffer, bufsize, encrypted);
          }
          if (tmp___32 == 0) {
            end = (linenr_t )0;
            goto while_break___4;
          }
          nchars += (long )bufsize;
          s = buffer;
          len___0 = 0;
        }
        tmp___33 = s;
        s ++;
        *tmp___33 = (char_u )'\n';
      }
    }
    len___0 ++;
    if (len___0 == bufsize) {
      if (end) {
        {
        tmp___34 = write_buf(fd, buffer, bufsize, encrypted);
        }
        if (tmp___34 == 0) {
          end = (linenr_t )0;
          goto while_break___4;
        }
        nchars += (long )bufsize;
        s = buffer;
        len___0 = 0;
      }
    }
    lnum ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  if (len___0) {
    if (end) {
      {
      tmp___35 = write_buf(fd, buffer, len___0, encrypted);
      }
      if (tmp___35 == 0) {
        end = (linenr_t )0;
      }
      nchars += (long )len___0;
    }
  }
  {
  tmp___36 = close(fd);
  }
  if (tmp___36 != 0) {
    errmsg = (char_u *)"Close failed";
    goto fail;
  }
  if (made_writable) {
    perm &= -129L;
  }
  if (perm >= 0L) {
    {
    mch_setperm(fname, perm);
    }
  }
  if (end == 0L) {
    errmsg = (char_u *)"write error (file system full?)";
    if ((unsigned long )backup != (unsigned long )((void *)0)) {
      {
      bfd___0 = open((char const   *)((char *)backup), 0, 0);
      }
      if (bfd___0 >= 0) {
        {
        fd = open((char const   *)((char *)fname), 577, 438);
        }
        if (fd >= 0) {
          {
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
            tmp___38 = read(bfd___0, (void *)((char *)(copybuf___0)), (size_t )8192);
            buflen___0 = (int )tmp___38;
            }
            if (! (buflen___0 > 0)) {
              goto while_break___6;
            }
            {
            tmp___37 = write_buf(fd, copybuf___0, buflen___0, 0);
            }
            if (tmp___37 == 0) {
              goto while_break___6;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
          tmp___39 = close(fd);
          }
          if (tmp___39 >= 0) {
            if (buflen___0 == 0) {
              end = (linenr_t )1;
            }
          }
        }
        {
        close(bfd___0);
        }
      }
    }
    goto fail;
  }
  lnum -= start___0;
  no_wait_return --;
  if (! filtering) {
    {
    msg_add_fname(buf___3, fname);
    c = (char_u )0;
    }
    if (newfile) {
      {
      tmp___42 = shortmess('n');
      }
      if (tmp___42) {
        tmp___41 = "[New]";
      } else {
        tmp___41 = "[New File]";
      }
      {
      strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___41));
      c = (char_u )1;
      }
    }
    if (no_eol) {
      {
      msg_add_eol();
      c = (char_u )1;
      }
    }
    {
    tmp___43 = msg_add_fileformat(fileformat);
    }
    if (tmp___43) {
      c = (char_u )1;
    }
    if (encrypted) {
      {
      strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"[crypted]"));
      c = (char_u )1;
      }
    }
    {
    msg_add_lines((int )c, lnum, nchars);
    tmp___47 = shortmess('W');
    }
    if (! tmp___47) {
      {
      tmp___46 = shortmess('w');
      }
      if (tmp___46) {
        tmp___45 = " [w]";
      } else {
        tmp___45 = " written";
      }
      {
      strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___45));
      }
    }
    {
    keep_msg = msg_trunc_attr(IObuff, 0, 0);
    keep_msg_attr = 0;
    }
  }
  if (reset_changed) {
    if (whole) {
      {
      unchanged(buf___3, 1);
      u_unchanged(buf___3);
      }
    }
  }
  if (! exiting) {
    if (overwriting) {
      {
      ml_timestamp(buf___3);
      buf___3->b_flags &= -89;
      }
    }
  }
  if (*p_pm) {
    if (buf___3->b_p_sn) {
      tmp___48 = 1;
    } else { //Added block
    if (buf___3->b_shortname) {
      tmp___48 = 1;
    } else {
      tmp___48 = 0;
    }
    }
    {
    tmp___49 = buf_modname(tmp___48, fname, p_pm, 0);
    org = (char *)tmp___49;
    }
    if ((unsigned long )backup != (unsigned long )((void *)0)) {
      if ((unsigned long )org == (unsigned long )((void *)0)) {
        {
        emsg((char_u *)"patchmode: can\'t save original file");
        }
      } else {
        {
        tmp___50 = stat((char const   * __restrict  )org, (struct stat * __restrict  )(& st___0));
        }
        if (tmp___50 < 0) {
          {
          vim_rename(backup, (char_u *)org);
          vim_free((void *)backup);
          backup = (char_u *)((void *)0);
          set_file_time((char_u *)org, st_old.st_atim.tv_sec, st_old.st_mtim.tv_sec);
          }
        }
      }
    } else { //Added block
    if ((unsigned long )org == (unsigned long )((void *)0)) {
      {
      emsg((char_u *)"patchmode: can\'t touch empty original file");
      }
    } else {
      {
      empty_fd = open((char const   *)org, 192, 438);
      }
      if (empty_fd < 0) {
        {
        emsg((char_u *)"patchmode: can\'t touch empty original file");
        }
      } else {
        {
        close(empty_fd);
        }
      }
    }
    }
    if ((unsigned long )org != (unsigned long )((void *)0)) {
      {
      tmp___51 = mch_getperm(fname);
      mch_setperm((char_u *)org, tmp___51 & 511L);
      vim_free((void *)org);
      }
    }
  }
  if (! p_bk) {
    if ((unsigned long )backup != (unsigned long )((void *)0)) {
      {
      tmp___52 = unlink((char const   *)((char *)backup));
      }
      if (tmp___52 != 0) {
        {
        emsg((char_u *)"Can\'t delete backup file");
        }
      }
    }
  }
  goto nofail;
  fail: 
  no_wait_return --;
  nofail: 
  {
  vim_free((void *)backup);
  }
  if ((unsigned long )buffer != (unsigned long )(smallbuf)) {
    {
    vim_free((void *)buffer);
    }
  }
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
    {
    attr = highlight_attr[3];
    msg_add_fname(buf___3, fname);
    strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)errmsg));
    emsg(IObuff);
    retval = 0;
    }
    if (end == 0L) {
      {
      msg_puts_attr((char_u *)"\nWARNING: Original file may be lost or damaged\n",
                    attr | 4096);
      msg_puts_attr((char_u *)"don\'t quit the editor until the file is successfully written!",
                    attr | 4096);
      }
    }
  }
  {
  msg_scroll = msg_save;
  write_no_eol_lnum = (linenr_t )0;
  save_buf___0 = curbuf;
  curbuf = buf___3;
  aucmd_prepbuf(& aco___0);
  }
  if (append) {
    {
    apply_autocmds((EVENT_T )13, fname, fname, 0, curbuf);
    }
  } else { //Added block
  if (filtering) {
    {
    apply_autocmds((EVENT_T )23, (char_u *)((void *)0), fname, 0, curbuf);
    }
  } else { //Added block
  if (reset_changed) {
    if (whole) {
      {
      apply_autocmds((EVENT_T )11, fname, fname, 0, curbuf);
      }
    } else {
      {
      apply_autocmds((EVENT_T )19, fname, fname, 0, curbuf);
      }
    }
  } else {
    {
    apply_autocmds((EVENT_T )19, fname, fname, 0, curbuf);
    }
  }
  }
  }
  {
  aucmd_restbuf(& aco___0);
  }
  if ((unsigned long )curbuf == (unsigned long )buf___3) {
    {
    tmp___53 = buf_valid(save_buf___0);
    }
    if (tmp___53) {
      ((curwin->w_buffer)->b_nwindows) --;
      curbuf = save_buf___0;
      curwin->w_buffer = save_buf___0;
      (curbuf->b_nwindows) ++;
    } else {
      curbuf = curwin->w_buffer;
    }
  } else {
    curbuf = curwin->w_buffer;
  }
  return (retval);
}
}
static void msg_add_fname(BUF *buf___3 , char_u *fname ) 
{ 


  {
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    fname = (char_u *)"-stdin-";
  }
  {
  home_replace(buf___3, fname, IObuff + 1, 1024, 1);
  *(IObuff + 0) = (char_u )'\"';
  strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"\" "));
  }
  return;
}
}
static int msg_add_fileformat(int eol_type ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  if (eol_type == 1) {
    {
    tmp___1 = shortmess('x');
    }
    if (tmp___1) {
      tmp___0 = "[dos]";
    } else {
      tmp___0 = "[dos format]";
    }
    {
    strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___0));
    }
    return (1);
  }
  if (eol_type == 2) {
    {
    tmp___4 = shortmess('x');
    }
    if (tmp___4) {
      tmp___3 = "[mac]";
    } else {
      tmp___3 = "[mac format]";
    }
    {
    strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___3));
    }
    return (1);
  }
  return (0);
}
}
static void msg_add_lines(int insert_space , long lnum , long nchars ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  char_u *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = strlen((char const   *)((char *)IObuff));
  p___0 = IObuff + tmp;
  }
  if (insert_space) {
    tmp___0 = p___0;
    p___0 ++;
    *tmp___0 = (char_u )' ';
  }
  {
  tmp___3 = shortmess('l');
  }
  if (tmp___3) {
    {
    sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )"%ldL, %ldC",
            lnum, nchars);
    }
  } else {
    {
    tmp___1 = plural(nchars);
    tmp___2 = plural(lnum);
    sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )"%ld line%s, %ld character%s",
            lnum, tmp___2, nchars, tmp___1);
    }
  }
  return;
}
}
static void msg_add_eol(void) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = shortmess('i');
  }
  if (tmp___1) {
    tmp___0 = "[noeol]";
  } else {
    tmp___0 = "[Incomplete last line]";
  }
  {
  strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___0));
  }
  return;
}
}
static int check_mtime(BUF *buf___3 , struct stat *st ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (buf___3->b_mtime_read != 0L) {
    {
    tmp___0 = time_differs(st->st_mtim.tv_sec, buf___3->b_mtime_read);
    }
    if (tmp___0) {
      {
      msg_scroll = 1;
      msg_attr((char_u *)"WARNING: The file has been changed since reading it!!!",
               highlight_attr[3]);
      tmp = ask_yesno((char_u *)"Do you really want to write to it", 1);
      }
      if (tmp == 110) {
        return (0);
      }
      msg_scroll = 0;
    }
  }
  return (1);
}
}
static int time_differs(long t1 , long t2 ) 
{ 
  int tmp ;

  {
  if (t1 - t2 > 1L) {
    tmp = 1;
  } else { //Added block
  if (t2 - t1 > 1L) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
static int write_buf(int fd , char_u *buf___3 , int len___0 , int docrypt ) 
{ 
  int wlen ;
  int ztemp ;
  int t ;
  int i___0 ;
  ssize_t tmp ;

  {
  if (docrypt) {
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < len___0)) {
        goto while_break;
      }
      {
      ztemp = (int )*(buf___3 + i___0);
      t = decrypt_byte();
      update_keys(ztemp);
      *(buf___3 + i___0) = (char_u )(t ^ ztemp);
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! len___0) {
      goto while_break___0;
    }
    {
    tmp = write(fd, (void const   *)((char *)buf___3), (size_t )len___0);
    wlen = (int )tmp;
    }
    if (wlen <= 0) {
      return (0);
    }
    len___0 -= wlen;
    buf___3 += wlen;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (1);
}
}
char_u *shorten_fname(char_u *full_path , char_u *dir_name ) 
{ 
  int len___0 ;
  char_u *p___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )full_path == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  tmp = strlen((char const   *)((char *)dir_name));
  len___0 = (int )tmp;
  tmp___1 = strncmp((char const   *)((char *)dir_name), (char const   *)((char *)full_path),
                    (size_t )len___0);
  }
  if (tmp___1 == 0) {
    {
    p___0 = full_path + len___0;
    tmp___0 = vim_ispathsep((int )*p___0);
    }
    if (tmp___0) {
      p___0 ++;
    } else {
      p___0 = (char_u *)((void *)0);
    }
  } else {
    p___0 = (char_u *)((void *)0);
  }
  return (p___0);
}
}
void shorten_fnames(int force ) 
{ 
  char_u dirname[1024] ;
  BUF *buf___3 ;
  char_u *p___0 ;
  int tmp ;

  {
  {
  mch_dirname(dirname, 1024);
  buf___3 = firstbuf;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
      if (force) {
        goto _L;
      } else { //Added block
      if ((unsigned long )buf___3->b_sfname == (unsigned long )((void *)0)) {
        goto _L;
      } else {
        {
        tmp = mch_isFullName(buf___3->b_sfname);
        }
        if (tmp) {
          _L: 
          {
          vim_free((void *)buf___3->b_sfname);
          buf___3->b_sfname = (char_u *)((void *)0);
          p___0 = shorten_fname(buf___3->b_ffname, dirname);
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            buf___3->b_sfname = vim_strsave(p___0);
            buf___3->b_fname = buf___3->b_sfname;
            }
          }
          if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
            buf___3->b_fname = buf___3->b_ffname;
          } else { //Added block
          if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
            buf___3->b_fname = buf___3->b_ffname;
          }
          }
          {
          mf_fullname(buf___3->b_ml.ml_mfp);
          }
        }
      }
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  status_redraw_all();
  }
  return;
}
}
char_u *modname(char_u *fname , char_u *ext , int prepend_dot ) 
{ 
  int tmp ;
  char_u *tmp___0 ;

  {
  if (curbuf->b_p_sn) {
    tmp = 1;
  } else { //Added block
  if (curbuf->b_shortname) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  {
  tmp___0 = buf_modname(tmp, fname, ext, prepend_dot);
  }
  return (tmp___0);
}
}
char_u *buf_modname(int shortname , char_u *fname , char_u *ext , int prepend_dot ) 
{ 
  char_u *retval ;
  char_u *s ;
  char_u *e ;
  char_u *ptr ;
  int fnamelen ;
  int extlen ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;

  {
  {
  tmp = strlen((char const   *)((char *)ext));
  extlen = (int )tmp;
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if ((int )*fname == 0) {
    _L: 
    {
    retval = alloc((unsigned int )((1024 + extlen) + 3));
    }
    if ((unsigned long )retval == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    {
    tmp___0 = mch_dirname(retval, 1024);
    }
    if (tmp___0 == 0) {
      {
      vim_free((void *)retval);
      }
      return ((char_u *)((void *)0));
    } else {
      {
      tmp___1 = strlen((char const   *)((char *)retval));
      fnamelen = (int )tmp___1;
      }
      if (fnamelen == 0) {
        {
        vim_free((void *)retval);
        }
        return ((char_u *)((void *)0));
      }
    }
    {
    tmp___3 = vim_ispathsep((int )*(retval + (fnamelen - 1)));
    }
    if (! tmp___3) {
      tmp___2 = fnamelen;
      fnamelen ++;
      *(retval + tmp___2) = (char_u )'/';
      *(retval + fnamelen) = (char_u )'\000';
    }
    prepend_dot = 0;
  } else {
    {
    tmp___4 = strlen((char const   *)((char *)fname));
    fnamelen = (int )tmp___4;
    retval = alloc((unsigned int )((fnamelen + extlen) + 3));
    }
    if ((unsigned long )retval == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    {
    strcpy((char * __restrict  )((char *)retval), (char const   * __restrict  )((char *)fname));
    }
  }
  }
  ptr = retval + fnamelen;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ptr >= (unsigned long )retval)) {
      goto while_break;
    }
    if ((int )*ext == 46) {
      if (shortname) {
        if ((int )*ptr == 46) {
          *ptr = (char_u )'_';
        }
      }
    }
    {
    tmp___5 = vim_ispathsep((int )*ptr);
    }
    if (tmp___5) {
      goto while_break;
    }
    ptr --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  ptr ++;
  tmp___6 = strlen((char const   *)((char *)ptr));
  }
  if (tmp___6 > 250UL) {
    *(ptr + 250) = (char_u )'\000';
  }
  {
  tmp___7 = strlen((char const   *)((char *)ptr));
  s = ptr + tmp___7;
  }
  if (shortname) {
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      goto _L___0;
    } else { //Added block
    if ((int )*fname == 0) {
      goto _L___0;
    } else {
      {
      tmp___11 = strlen((char const   *)((char *)fname));
      tmp___12 = vim_ispathsep((int )*(fname + (tmp___11 - 1UL)));
      }
      if (tmp___12) {
        _L___0: 
        if ((int )*ext == 46) {
          tmp___8 = s;
          s ++;
          *tmp___8 = (char_u )'_';
        }
      } else { //Added block
      if ((int )*ext == 46) {
        if ((size_t )(s - ptr) > 8UL) {
          s = ptr + 8;
          *s = (char_u )'\000';
        }
      } else {
        {
        e = vim_strchr(ptr, '.');
        }
        if ((unsigned long )e == (unsigned long )((void *)0)) {
          tmp___9 = s;
          s ++;
          *tmp___9 = (char_u )'.';
        } else {
          {
          tmp___10 = strlen((char const   *)((char *)e));
          }
          if ((int )tmp___10 + extlen > 4) {
            s = (e + 4) - extlen;
          }
        }
      }
      }
    }
    }
  }
  {
  strcpy((char * __restrict  )((char *)s), (char const   * __restrict  )((char *)ext));
  }
  if (prepend_dot) {
    if (! shortname) {
      {
      e = gettail(retval);
      }
      if ((int )*e != 46) {
        {
        tmp___13 = strlen((char const   *)((char *)e));
        memmove((void *)((char *)(e + 1)), (void const   *)((char *)e), tmp___13 + 1UL);
        *e = (char_u )'.';
        }
      }
    }
  }
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    {
    tmp___14 = strcmp((char const   *)((char *)fname), (char const   *)((char *)retval));
    }
    if (tmp___14 == 0) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        s --;
        if (! ((unsigned long )s >= (unsigned long )ptr)) {
          goto while_break___0;
        }
        if ((int )*s != 95) {
          *s = (char_u )'_';
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      if ((unsigned long )s < (unsigned long )ptr) {
        *ptr = (char_u )'v';
      }
    }
  }
  return (retval);
}
}
int vim_fgets(char_u *buf___3 , int size , FILE *fp___0 ) 
{ 
  char *eof ;
  char tbuf[200] ;

  {
  {
  *(buf___3 + (size - 2)) = (char_u )'\000';
  eof = fgets((char * __restrict  )((char *)buf___3), size, (FILE * __restrict  )fp___0);
  }
  if ((int )*(buf___3 + (size - 2)) != 0) {
    if ((int )*(buf___3 + (size - 2)) != 10) {
      *(buf___3 + (size - 1)) = (char_u )'\000';
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        tbuf[198] = (char )'\000';
        fgets((char * __restrict  )(tbuf), 200, (FILE * __restrict  )fp___0);
        }
        if ((int )tbuf[198] != 0) {
          if (! ((int )tbuf[198] != 10)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return ((unsigned long )eof == (unsigned long )((void *)0));
}
}
int vim_rename(char_u *from , char_u *to ) 
{ 
  int fd_in ;
  int fd_out ;
  int n ;
  char *errmsg ;
  char *buffer ;
  int tmp ;
  char_u *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
  errmsg = (char *)((void *)0);
  unlink((char const   *)((char *)to));
  tmp = rename((char const   *)((char *)from), (char const   *)((char *)to));
  }
  if (tmp == 0) {
    return (0);
  }
  {
  fd_in = open((char const   *)((char *)from), 0, 0);
  }
  if (fd_in == -1) {
    return (-1);
  }
  {
  fd_out = open((char const   *)((char *)to), 193, 438);
  }
  if (fd_out == -1) {
    {
    close(fd_in);
    }
    return (-1);
  }
  {
  tmp___0 = alloc(8192U);
  buffer = (char *)tmp___0;
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
    close(fd_in);
    close(fd_out);
    }
    return (-1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___2 = read(fd_in, (void *)buffer, (size_t )8192);
    n = (int )tmp___2;
    }
    if (! (n > 0)) {
      goto while_break;
    }
    {
    tmp___1 = write(fd_out, (void const   *)buffer, (size_t )n);
    }
    if (tmp___1 != (ssize_t )n) {
      errmsg = (char *)"writing to";
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)buffer);
  close(fd_in);
  tmp___3 = close(fd_out);
  }
  if (tmp___3 < 0) {
    errmsg = (char *)"closing";
  }
  if (n < 0) {
    errmsg = (char *)"reading";
    to = from;
  }
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
    {
    sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Error %s \'%s\'",
            errmsg, to);
    emsg(IObuff);
    }
    return (-1);
  }
  {
  unlink((char const   *)((char *)from));
  }
  return (0);
}
}
static int already_warned  =    0;
void check_timestamps(int focus ) 
{ 
  BUF *buf___3 ;
  int put_nl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  put_nl = 0;
  tmp___0 = stuff_empty();
  }
  if (tmp___0) {
    if (global_busy) {
      need_check_timestamps = 1;
    } else {
      {
      tmp___1 = typebuf_typed();
      }
      if (tmp___1) {
        if (autocmd_busy) {
          need_check_timestamps = 1;
        } else {
          no_wait_return ++;
          already_warned = 0;
          buf___3 = firstbuf;
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
              goto while_break;
            }
            {
            tmp = buf_check_timestamp(buf___3, focus);
            put_nl |= tmp;
            buf___3 = buf___3->b_next;
            }
          }
          while_break: /* CIL Label */ ;
          }
          no_wait_return --;
          need_check_timestamps = 0;
          if (need_wait_return) {
            if (put_nl) {
              {
              msg_puts((char_u *)"\n");
              out_flush();
              }
            }
          }
        }
      } else {
        need_check_timestamps = 1;
      }
    }
  } else {
    need_check_timestamps = 1;
  }
  return;
}
}
int buf_check_timestamp(BUF *buf___3 , int focus ) 
{ 
  struct stat st ;
  int retval ;
  int message_put ;
  char_u *path ;
  char_u *tbuf ;
  char *mesg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  message_put = 0;
  mesg = (char *)((void *)0);
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    return (0);
  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return (0);
  }
  }
  if (! (buf___3->b_flags & 8)) {
    if (buf___3->b_mtime != 0L) {
      {
      retval = stat((char const   * __restrict  )((char *)buf___3->b_ffname), (struct stat * __restrict  )(& st));
      }
      if (retval < 0) {
        goto _L___0;
      } else { //Added block
      if (retval >= 0) {
        {
        tmp___1 = time_differs(st.st_mtim.tv_sec, buf___3->b_mtime);
        }
        if (tmp___1) {
          _L___0: 
          if (retval < 0) {
            buf___3->b_mtime = 0L;
          } else {
            buf___3->b_mtime = st.st_mtim.tv_sec;
          }
          {
          tmp = apply_autocmds((EVENT_T )15, buf___3->b_fname, buf___3->b_fname, 0,
                               buf___3);
          }
          if (! tmp) {
            if (retval < 0) {
              mesg = (char *)"Warning: File \"%s\" no longer available";
            } else {
              mesg = (char *)"Warning: File \"%s\" has changed since editing started";
            }
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (buf___3->b_flags & 16) {
    if (! (buf___3->b_flags & 32)) {
      {
      tmp___0 = vim_fexists(buf___3->b_ffname);
      }
      if (tmp___0) {
        mesg = (char *)"Warning: File \"%s\" has been created after editing started";
        buf___3->b_flags |= 32;
      }
    }
  }
  }
  if ((unsigned long )mesg != (unsigned long )((void *)0)) {
    {
    path = home_replace_save(buf___3, buf___3->b_fname);
    }
    if ((unsigned long )path != (unsigned long )((void *)0)) {
      {
      tmp___2 = strlen((char const   *)((char *)path));
      tbuf = alloc((unsigned int )tmp___2 + 65U);
      sprintf((char * __restrict  )((char *)tbuf), (char const   * __restrict  )mesg,
              path);
      }
      if (State > 257) {
        {
        emsg(tbuf);
        message_put = 1;
        }
      } else { //Added block
      if (State == 8) {
        {
        emsg(tbuf);
        message_put = 1;
        }
      } else { //Added block
      if (already_warned) {
        {
        emsg(tbuf);
        message_put = 1;
        }
      } else {
        if (! autocmd_busy) {
          {
          msg_start();
          msg_puts_attr(tbuf, highlight_attr[3] + 4096);
          msg_clr_eos();
          msg_end();
          out_flush();
          ui_delay(1000L, 1);
          redraw_cmdline = 0;
          }
        }
        already_warned = 1;
      }
      }
      }
      {
      vim_free((void *)path);
      vim_free((void *)tbuf);
      }
    }
  }
  return (message_put);
}
}
void write_lnum_adjust(linenr_t offset ) 
{ 


  {
  if (write_no_eol_lnum) {
    write_no_eol_lnum += offset;
  }
  return;
}
}
static char_u *vim_tempdir  =    (char_u *)((void *)0);
static long temp_count  =    0L;
void vim_deltempdir(void) 
{ 
  char_u **files ;
  int file_count ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;

  {
  if ((unsigned long )vim_tempdir != (unsigned long )((void *)0)) {
    {
    sprintf((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )"%s*",
            vim_tempdir);
    tmp = gen_expand_wildcards(1, & NameBuff, & file_count, & files, 35);
    }
    if (tmp == 1) {
      i___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < file_count)) {
          goto while_break;
        }
        {
        unlink((char const   *)((char *)*(files + i___0)));
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
      FreeWild(file_count, files);
      }
    }
    {
    tmp___0 = gettail(NameBuff);
    *(tmp___0 + -1) = (char_u )'\000';
    rmdir((char const   *)((char *)NameBuff));
    vim_free((void *)vim_tempdir);
    vim_tempdir = (char_u *)((void *)0);
    }
  }
  return;
}
}
static char *tempdirs[4]  = {      (char *)"$TMPDIR",      (char *)"/tmp",      (char *)".",      (char *)"$HOME"};
char_u *vim_tempname(int extra_char ) 
{ 
  char_u itmp[256] ;
  int i___0 ;
  long nr ;
  long off___0 ;
  long tmp ;
  time_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  char_u *tmp___6 ;

  {
  if ((unsigned long )vim_tempdir == (unsigned long )((void *)0)) {
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )i___0 < sizeof(tempdirs) / sizeof(char *))) {
        goto while_break;
      }
      {
      expand_env((char_u *)tempdirs[i___0], itmp, 236);
      tmp___4 = mch_isdir(itmp);
      }
      if (tmp___4) {
        {
        add_pathsep(itmp);
        tmp = mch_get_pid();
        tmp___0 = time((time_t *)((void *)0));
        nr = (tmp + tmp___0) % 1000000L;
        off___0 = 0L;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (off___0 < 10000L)) {
            goto while_break___0;
          }
          {
          tmp___1 = strlen((char const   *)((char *)(itmp)));
          sprintf((char * __restrict  )((char *)(itmp) + tmp___1), (char const   * __restrict  )"v%ld",
                  nr + off___0);
          tmp___2 = mkdir((char const   *)((char *)(itmp)), (__mode_t )448);
          }
          if (tmp___2 == 0) {
            {
            add_pathsep(itmp);
            vim_tempdir = FullName_save(itmp, 0);
            }
            goto while_break___0;
          }
          {
          tmp___3 = __errno_location();
          }
          if (*tmp___3 != 17) {
            goto while_break___0;
          }
          off___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        if ((unsigned long )vim_tempdir != (unsigned long )((void *)0)) {
          goto while_break;
        }
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if ((unsigned long )vim_tempdir != (unsigned long )((void *)0)) {
    {
    tmp___5 = temp_count;
    temp_count ++;
    sprintf((char * __restrict  )((char *)(itmp)), (char const   * __restrict  )"%s%ld",
            vim_tempdir, tmp___5);
    tmp___6 = vim_strsave(itmp);
    }
    return (tmp___6);
  }
  return ((char_u *)((void *)0));
}
}
static struct event_name event_names[43]  = 
  {      {(char *)"BufCreate", (EVENT_T )0}, 
        {(char *)"BufDelete", (EVENT_T )1}, 
        {(char *)"BufEnter", (EVENT_T )2}, 
        {(char *)"BufFilePost", (EVENT_T )3}, 
        {(char *)"BufFilePre", (EVENT_T )4}, 
        {(char *)"BufHidden", (EVENT_T )10}, 
        {(char *)"BufLeave", (EVENT_T )5}, 
        {(char *)"BufNewFile", (EVENT_T )6}, 
        {(char *)"BufReadPost", (EVENT_T )7}, 
        {(char *)"BufReadPre", (EVENT_T )8}, 
        {(char *)"BufRead", (EVENT_T )7}, 
        {(char *)"BufUnload", (EVENT_T )9}, 
        {(char *)"BufWritePost", (EVENT_T )11}, 
        {(char *)"BufWritePre", (EVENT_T )12}, 
        {(char *)"BufWrite", (EVENT_T )12}, 
        {(char *)"CursorHold", (EVENT_T )39}, 
        {(char *)"FileAppendPost", (EVENT_T )13}, 
        {(char *)"FileAppendPre", (EVENT_T )14}, 
        {(char *)"FileChangedShell", (EVENT_T )15}, 
        {(char *)"FileEncoding", (EVENT_T )38}, 
        {(char *)"FileReadPost", (EVENT_T )16}, 
        {(char *)"FileReadPre", (EVENT_T )17}, 
        {(char *)"FileType", (EVENT_T )18}, 
        {(char *)"FileWritePost", (EVENT_T )19}, 
        {(char *)"FileWritePre", (EVENT_T )20}, 
        {(char *)"FilterReadPost", (EVENT_T )21}, 
        {(char *)"FilterReadPre", (EVENT_T )22}, 
        {(char *)"FilterWritePost", (EVENT_T )23}, 
        {(char *)"FilterWritePre", (EVENT_T )24}, 
        {(char *)"FocusGained", (EVENT_T )25}, 
        {(char *)"FocusLost", (EVENT_T )26}, 
        {(char *)"GUIEnter", (EVENT_T )27}, 
        {(char *)"StdinReadPost", (EVENT_T )28}, 
        {(char *)"StdinReadPre", (EVENT_T )29}, 
        {(char *)"Syntax", (EVENT_T )30}, 
        {(char *)"TermChanged", (EVENT_T )31}, 
        {(char *)"User", (EVENT_T )32}, 
        {(char *)"VimEnter", (EVENT_T )33}, 
        {(char *)"VimLeave", (EVENT_T )34}, 
        {(char *)"VimLeavePre", (EVENT_T )35}, 
        {(char *)"WinEnter", (EVENT_T )36}, 
        {(char *)"WinLeave", (EVENT_T )37}, 
        {(char *)((void *)0), (EVENT_T )0}};
static AutoPat *first_autopat[40]  = 
  {      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0)};
struct growarray augroups  =    {0, 0, (int )sizeof(char_u *), 10, (void *)0};
static int current_augroup  =    -1;
static int au_need_clean  =    0;
static void show_autocmd(AutoPat *ap , EVENT_T event ) ;
static void au_remove_pat(AutoPat *ap ) ;
static void au_remove_cmds(AutoPat *ap ) ;
static void au_cleanup(void) ;
static int au_new_group(char_u *name___1 ) ;
static int au_find_group(char_u *name___1 ) ;
static EVENT_T event_name2nr(char_u *start___0 , char_u **end ) ;
static char_u *event_nr2name(EVENT_T event ) ;
static char_u *find_end_event(char_u *arg ) ;
static int event_ignored(EVENT_T event ) ;
static int au_get_grouparg(char_u **argp ) ;
static int do_autocmd_event(EVENT_T event , char_u *pat , int nested , char_u *cmd ,
                            int forceit , int group ) ;
static char_u *getnextac(int c , void *cookie , int indent ) ;
static int apply_autocmds_group(EVENT_T event , char_u *fname , char_u *fname_io ,
                                int force , int group , BUF *buf___3 ) ;
static void auto_next_pat(AutoPatCmd *apc , int stop_at_last ) ;
static EVENT_T last_event  ;
static int last_group  ;
static void show_autocmd(AutoPat *ap , EVENT_T event ) 
{ 
  AutoCmd *ac ;
  char_u *tmp ;

  {
  if (got_int) {
    return;
  }
  if ((unsigned long )ap->pat == (unsigned long )((void *)0)) {
    return;
  }
  {
  msg_putchar('\n');
  }
  if (got_int) {
    return;
  }
  if ((unsigned int )event != (unsigned int )last_event) {
    goto _L;
  } else { //Added block
  if (ap->group != last_group) {
    _L: 
    if (ap->group != -1) {
      {
      msg_puts_attr(*((char_u **)augroups.ga_data + ap->group), highlight_attr[13]);
      msg_puts((char_u *)"  ");
      }
    }
    {
    tmp = event_nr2name(event);
    msg_puts_attr(tmp, highlight_attr[13]);
    last_event = event;
    last_group = ap->group;
    msg_putchar('\n');
    }
    if (got_int) {
      return;
    }
  }
  }
  {
  msg_col = 4;
  msg_outtrans(ap->pat);
  ac = ap->cmds;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ac != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )ac->cmd != (unsigned long )((void *)0)) {
      if (msg_col >= 14) {
        {
        msg_putchar('\n');
        }
      }
      msg_col = 14;
      if (got_int) {
        return;
      }
      {
      msg_outtrans(ac->cmd);
      }
      if (got_int) {
        return;
      }
      if ((unsigned long )ac->next != (unsigned long )((void *)0)) {
        {
        msg_putchar('\n');
        }
        if (got_int) {
          return;
        }
      }
    }
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void au_remove_pat(AutoPat *ap ) 
{ 


  {
  {
  vim_free((void *)ap->pat);
  ap->pat = (char_u *)((void *)0);
  au_need_clean = 1;
  }
  return;
}
}
static void au_remove_cmds(AutoPat *ap ) 
{ 
  AutoCmd *ac ;

  {
  ac = ap->cmds;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )ac != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    vim_free((void *)ac->cmd);
    ac->cmd = (char_u *)((void *)0);
    ac = ac->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  au_need_clean = 1;
  return;
}
}
static void au_cleanup(void) 
{ 
  AutoPat *ap ;
  AutoPat **prev_ap ;
  AutoCmd *ac ;
  AutoCmd **prev_ac ;
  EVENT_T event ;

  {
  if (autocmd_busy) {
    return;
  } else { //Added block
  if (! au_need_clean) {
    return;
  }
  }
  event = (EVENT_T )0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )event < 40)) {
      goto while_break;
    }
    prev_ap = & first_autopat[(int )event];
    ap = *prev_ap;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )ap != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      prev_ac = & ap->cmds;
      ac = *prev_ac;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((unsigned long )ac != (unsigned long )((void *)0))) {
          goto while_break___1;
        }
        if ((unsigned long )ap->pat == (unsigned long )((void *)0)) {
          {
          *prev_ac = ac->next;
          vim_free((void *)ac->cmd);
          vim_free((void *)ac);
          }
        } else { //Added block
        if ((unsigned long )ac->cmd == (unsigned long )((void *)0)) {
          {
          *prev_ac = ac->next;
          vim_free((void *)ac->cmd);
          vim_free((void *)ac);
          }
        } else {
          prev_ac = & ac->next;
        }
        }
        ac = *prev_ac;
      }
      while_break___1: /* CIL Label */ ;
      }
      if ((unsigned long )ap->pat == (unsigned long )((void *)0)) {
        {
        *prev_ap = ap->next;
        vim_free((void *)ap->reg_pat);
        vim_free((void *)ap);
        }
      } else {
        prev_ap = & ap->next;
      }
      ap = *prev_ap;
    }
    while_break___0: /* CIL Label */ ;
    }
    event = (EVENT_T )((int )event + 1);
  }
  while_break: /* CIL Label */ ;
  }
  au_need_clean = 0;
  return;
}
}
static int au_new_group(char_u *name___1 ) 
{ 
  int i___0 ;
  int tmp ;

  {
  {
  i___0 = au_find_group(name___1);
  }
  if (i___0 == -2) {
    {
    tmp = ga_grow(& augroups, 1);
    }
    if (tmp == 0) {
      return (-2);
    }
    {
    i___0 = augroups.ga_len;
    *((char_u **)augroups.ga_data + i___0) = vim_strsave(name___1);
    }
    if ((unsigned long )*((char_u **)augroups.ga_data + i___0) == (unsigned long )((void *)0)) {
      return (-2);
    }
    (augroups.ga_len) ++;
    (augroups.ga_room) --;
  }
  return (i___0);
}
}
static int au_find_group(char_u *name___1 ) 
{ 
  int i___0 ;
  int tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < augroups.ga_len)) {
      goto while_break;
    }
    if ((unsigned long )*((char_u **)augroups.ga_data + i___0) != (unsigned long )((void *)0)) {
      {
      tmp = strcmp((char const   *)((char *)*((char_u **)augroups.ga_data + i___0)),
                   (char const   *)((char *)name___1));
      }
      if (tmp == 0) {
        return (i___0);
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-2);
}
}
void do_augroup(char_u *arg ) 
{ 
  int i___0 ;
  int tmp ;

  {
  {
  tmp = strcasecmp((char const   *)((char *)arg), (char const   *)((char *)"end"));
  }
  if (tmp == 0) {
    current_augroup = -1;
  } else { //Added block
  if (*arg) {
    {
    i___0 = au_new_group(arg);
    }
    if (i___0 != -2) {
      current_augroup = i___0;
    }
  } else {
    {
    msg_start();
    i___0 = 0;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < augroups.ga_len)) {
        goto while_break;
      }
      if ((unsigned long )*((char_u **)augroups.ga_data + i___0) != (unsigned long )((void *)0)) {
        {
        msg_puts(*((char_u **)augroups.ga_data + i___0));
        msg_puts((char_u *)"  ");
        }
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    msg_clr_eos();
    msg_end();
    }
  }
  }
  return;
}
}
static EVENT_T event_name2nr(char_u *start___0 , char_u **end ) 
{ 
  char_u *p___0 ;
  int i___0 ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  p___0 = start___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if ((int )*p___0 == 32) {
        goto while_break;
      } else { //Added block
      if ((int )*p___0 == 9) {
        goto while_break;
      } else { //Added block
      if (! ((int )*p___0 != 44)) {
        goto while_break;
      }
      }
      }
    } else {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )event_names[i___0].name != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    tmp = strlen((char const   *)event_names[i___0].name);
    len___0 = (int )tmp;
    }
    if ((long )len___0 == p___0 - start___0) {
      {
      tmp___0 = strncasecmp((char const   *)event_names[i___0].name, (char const   *)((char *)start___0),
                            (size_t )len___0);
      }
      if (tmp___0 == 0) {
        goto while_break___0;
      }
    }
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((int )*p___0 == 44) {
    p___0 ++;
  }
  *end = p___0;
  if ((unsigned long )event_names[i___0].name == (unsigned long )((void *)0)) {
    return ((EVENT_T )40);
  }
  return (event_names[i___0].event);
}
}
static char_u *event_nr2name(EVENT_T event ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )event_names[i___0].name != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned int )event_names[i___0].event == (unsigned int )event) {
      return ((char_u *)event_names[i___0].name);
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char_u *)"Unknown");
}
}
static char_u *find_end_event(char_u *arg ) 
{ 
  char_u *pat ;
  char_u *p___0 ;
  EVENT_T tmp ;

  {
  if ((int )*arg == 42) {
    if (*(arg + 1)) {
      if (! ((int )*(arg + 1) == 32)) {
        if (! ((int )*(arg + 1) == 9)) {
          {
          emsg2((char_u *)"Illegal character after *: %s", arg);
          }
          return ((char_u *)((void *)0));
        }
      }
    }
    pat = arg + 1;
  } else {
    pat = arg;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (*pat) {
        if ((int )*pat == 32) {
          goto while_break;
        } else { //Added block
        if ((int )*pat == 9) {
          goto while_break;
        }
        }
      } else {
        goto while_break;
      }
      {
      tmp = event_name2nr(pat, & p___0);
      }
      if ((int )tmp >= 40) {
        {
        emsg2((char_u *)"No such event: %s", pat);
        }
        return ((char_u *)((void *)0));
      }
      pat = p___0;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (pat);
}
}
static int event_ignored(EVENT_T event ) 
{ 
  char_u *p___0 ;
  int tmp ;
  EVENT_T tmp___0 ;

  {
  {
  p___0 = p_ei;
  tmp = strcasecmp((char const   *)((char *)p_ei), (char const   *)((char *)"all"));
  }
  if (tmp == 0) {
    return (1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp___0 = event_name2nr(p___0, & p___0);
    }
    if ((unsigned int )tmp___0 == (unsigned int )event) {
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int check_ei(void) 
{ 
  char_u *p___0 ;
  int tmp ;
  EVENT_T tmp___0 ;

  {
  {
  p___0 = p_ei;
  tmp = strcasecmp((char const   *)((char *)p_ei), (char const   *)((char *)"all"));
  }
  if (tmp == 0) {
    return (1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp___0 = event_name2nr(p___0, & p___0);
    }
    if ((unsigned int )tmp___0 == 40U) {
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
void do_autocmd(char_u *arg , int forceit ) 
{ 
  char_u *pat ;
  char_u *envpat ;
  char_u *cmd ;
  EVENT_T event ;
  int need_free ;
  int nested ;
  int group ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  EVENT_T tmp___4 ;
  int tmp___5 ;

  {
  {
  envpat = (char_u *)((void *)0);
  need_free = 0;
  nested = 0;
  group = au_get_grouparg(& arg);
  }
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return;
  }
  {
  pat = find_end_event(arg);
  }
  if ((unsigned long )pat == (unsigned long )((void *)0)) {
    return;
  }
  {
  pat = skipwhite(pat);
  cmd = pat;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*cmd) {
      if ((int )*cmd == 32) {
        goto _L;
      } else { //Added block
      if ((int )*cmd == 9) {
        _L: 
        if (! ((int )*(cmd + -1) == 92)) {
          goto while_break;
        }
      }
      }
    } else {
      goto while_break;
    }
    cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (*cmd) {
    tmp = cmd;
    cmd ++;
    *tmp = (char_u )'\000';
  }
  {
  tmp___0 = vim_strchr(pat, '$');
  }
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    goto _L___0;
  } else {
    {
    tmp___1 = vim_strchr(pat, '~');
    }
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      _L___0: 
      {
      envpat = expand_env_save(pat);
      }
      if ((unsigned long )envpat != (unsigned long )((void *)0)) {
        pat = envpat;
      }
    }
  }
  {
  cmd = skipwhite(cmd);
  }
  if ((int )*cmd != 0) {
    {
    tmp___2 = strncmp((char const   *)((char *)cmd), (char const   *)((char *)"nested"),
                      (size_t )6);
    }
    if (tmp___2 == 0) {
      if ((int )*(cmd + 6) == 32) {
        {
        nested = 1;
        cmd = skipwhite(cmd + 6);
        }
      } else { //Added block
      if ((int )*(cmd + 6) == 9) {
        {
        nested = 1;
        cmd = skipwhite(cmd + 6);
        }
      }
      }
    }
  }
  if ((int )*cmd != 0) {
    {
    cmd = expand_sfile(cmd);
    }
    if ((unsigned long )cmd == (unsigned long )((void *)0)) {
      return;
    }
    need_free = 1;
  }
  if (! forceit) {
    if ((int )*cmd == 0) {
      {
      msg_puts_title((char_u *)"\n--- Auto-Commands ---");
      }
    }
  }
  last_event = (EVENT_T )-1;
  last_group = -2;
  if ((int )*arg == 42) {
    goto _L___1;
  } else { //Added block
  if ((int )*arg == 0) {
    _L___1: 
    event = (EVENT_T )0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((int )event < 40)) {
        goto while_break___0;
      }
      {
      tmp___3 = do_autocmd_event(event, pat, nested, cmd, forceit, group);
      }
      if (tmp___3 == 0) {
        goto while_break___0;
      }
      event = (EVENT_T )((int )event + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (*arg) {
        if ((int )*arg == 32) {
          goto while_break___1;
        } else { //Added block
        if ((int )*arg == 9) {
          goto while_break___1;
        }
        }
      } else {
        goto while_break___1;
      }
      {
      tmp___4 = event_name2nr(arg, & arg);
      tmp___5 = do_autocmd_event(tmp___4, pat, nested, cmd, forceit, group);
      }
      if (tmp___5 == 0) {
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  }
  if (need_free) {
    {
    vim_free((void *)cmd);
    }
  }
  {
  vim_free((void *)envpat);
  }
  return;
}
}
static int au_get_grouparg(char_u **argp ) 
{ 
  char_u *group_name ;
  char_u *p___0 ;
  char_u *arg ;
  int group ;

  {
  {
  arg = *argp;
  group = -3;
  p___0 = skiptowhite(arg);
  }
  if ((unsigned long )p___0 > (unsigned long )arg) {
    {
    group_name = vim_strnsave(arg, (int )(p___0 - arg));
    }
    if ((unsigned long )group_name == (unsigned long )((void *)0)) {
      return (-2);
    }
    {
    group = au_find_group(group_name);
    }
    if (group == -2) {
      group = -3;
    } else {
      {
      *argp = skipwhite(p___0);
      }
    }
    {
    vim_free((void *)group_name);
    }
  }
  return (group);
}
}
static int do_autocmd_event(EVENT_T event , char_u *pat , int nested , char_u *cmd ,
                            int forceit , int group ) 
{ 
  AutoPat *ap ;
  AutoPat **prev_ap ;
  AutoCmd *ac ;
  AutoCmd **prev_ac ;
  int brace_level ;
  char_u *endpat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  if ((int )*pat == 0) {
    ap = first_autopat[(int )event];
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )ap != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if (forceit) {
        if (group == -3) {
          tmp = current_augroup;
        } else {
          tmp = group;
        }
        if (ap->group == tmp) {
          {
          au_remove_pat(ap);
          }
        }
      } else { //Added block
      if (group == -3) {
        {
        show_autocmd(ap, event);
        }
      } else { //Added block
      if (ap->group == group) {
        {
        show_autocmd(ap, event);
        }
      }
      }
      }
      ap = ap->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *pat) {
      goto while_break___0;
    }
    brace_level = 0;
    endpat = pat;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (*endpat) {
        if (! ((int )*endpat != 44)) {
          if (! brace_level) {
            if (! ((int )*(endpat + -1) == 92)) {
              goto while_break___1;
            }
          }
        }
      } else {
        goto while_break___1;
      }
      if ((int )*endpat == 123) {
        brace_level ++;
      } else { //Added block
      if ((int )*endpat == 125) {
        brace_level --;
      }
      }
      endpat ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((unsigned long )pat == (unsigned long )endpat) {
      goto __Cont;
    }
    prev_ap = & first_autopat[(int )event];
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      ap = *prev_ap;
      if (! ((unsigned long )ap != (unsigned long )((void *)0))) {
        goto while_break___2;
      }
      if ((unsigned long )ap->pat != (unsigned long )((void *)0)) {
        if (group == -3) {
          tmp___0 = current_augroup;
        } else {
          tmp___0 = group;
        }
        if (ap->group == tmp___0) {
          goto _L;
        } else { //Added block
        if (group == -3) {
          if (! forceit) {
            if ((int )*cmd == 0) {
              _L: 
              if ((long )ap->patlen == endpat - pat) {
                {
                tmp___1 = strncmp((char const   *)((char *)pat), (char const   *)((char *)ap->pat),
                                  (size_t )ap->patlen);
                }
                if (tmp___1 == 0) {
                  if (forceit) {
                    if ((int )*cmd != 0) {
                      if ((unsigned long )ap->next == (unsigned long )((void *)0)) {
                        {
                        au_remove_cmds(ap);
                        }
                        goto while_break___2;
                      }
                    }
                    {
                    au_remove_pat(ap);
                    }
                  } else { //Added block
                  if ((int )*cmd == 0) {
                    {
                    show_autocmd(ap, event);
                    }
                  } else { //Added block
                  if ((unsigned long )ap->next == (unsigned long )((void *)0)) {
                    goto while_break___2;
                  }
                  }
                  }
                }
              }
            }
          }
        }
        }
      }
      prev_ap = & ap->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    if ((int )*cmd != 0) {
      if ((unsigned long )ap == (unsigned long )((void *)0)) {
        {
        tmp___2 = alloc((unsigned int )sizeof(AutoPat ));
        ap = (AutoPat *)tmp___2;
        }
        if ((unsigned long )ap == (unsigned long )((void *)0)) {
          return (0);
        }
        {
        ap->pat = vim_strnsave(pat, (int )(endpat - pat));
        ap->patlen = (int )(endpat - pat);
        }
        if ((unsigned long )ap->pat == (unsigned long )((void *)0)) {
          {
          vim_free((void *)ap);
          }
          return (0);
        }
        {
        ap->reg_pat = file_pat_to_reg_pat(pat, endpat, & ap->allow_dirs, 1);
        }
        if ((unsigned long )ap->reg_pat == (unsigned long )((void *)0)) {
          {
          vim_free((void *)ap->pat);
          vim_free((void *)ap);
          }
          return (0);
        }
        ap->cmds = (AutoCmd *)((void *)0);
        *prev_ap = ap;
        ap->next = (struct AutoPat *)((void *)0);
        if (group == -3) {
          ap->group = current_augroup;
        } else {
          ap->group = group;
        }
      }
      prev_ac = & ap->cmds;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        ac = *prev_ac;
        if (! ((unsigned long )ac != (unsigned long )((void *)0))) {
          goto while_break___3;
        }
        prev_ac = & ac->next;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      tmp___3 = alloc((unsigned int )sizeof(AutoCmd ));
      ac = (AutoCmd *)tmp___3;
      }
      if ((unsigned long )ac == (unsigned long )((void *)0)) {
        return (0);
      }
      {
      ac->cmd = vim_strsave(cmd);
      }
      if ((unsigned long )ac->cmd == (unsigned long )((void *)0)) {
        {
        vim_free((void *)ac);
        }
        return (0);
      }
      ac->next = (struct AutoCmd *)((void *)0);
      *prev_ac = ac;
      if ((unsigned int )event == 15U) {
        ac->nested = (char)0;
      } else {
        ac->nested = (char )nested;
      }
    }
    __Cont: 
    if ((int )*endpat == 44) {
      pat = endpat + 1;
    } else {
      pat = endpat;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  au_cleanup();
  }
  return (1);
}
}
int do_doautocmd(char_u *arg , int do_msg ) 
{ 
  char_u *fname ;
  int nothing_done ;
  int group ;
  EVENT_T tmp ;
  int tmp___0 ;

  {
  {
  nothing_done = 1;
  group = au_get_grouparg(& arg);
  }
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return (0);
  }
  if ((int )*arg == 42) {
    {
    emsg((char_u *)"Can\'t execute autocommands for ALL events");
    }
    return (0);
  }
  {
  fname = find_end_event(arg);
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  fname = skipwhite(fname);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*arg) {
      if ((int )*arg == 32) {
        goto while_break;
      } else { //Added block
      if ((int )*arg == 9) {
        goto while_break;
      }
      }
    } else {
      goto while_break;
    }
    {
    tmp = event_name2nr(arg, & arg);
    tmp___0 = apply_autocmds_group(tmp, fname, (char_u *)((void *)0), 1, group, curbuf);
    }
    if (tmp___0) {
      nothing_done = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (nothing_done) {
    if (do_msg) {
      {
      msg((char_u *)"No matching autocommands");
      }
    }
  }
  return (1);
}
}
void do_autoall(char_u *arg ) 
{ 
  int retval ;
  struct aco_save aco ;

  {
  curbuf = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )curbuf != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )curbuf->b_ml.ml_mfp != (unsigned long )((void *)0)) {
      {
      aucmd_prepbuf(& aco);
      retval = do_doautocmd(arg, 0);
      do_modelines();
      aucmd_restbuf(& aco);
      }
      if (retval == 0) {
        goto while_break;
      }
    }
    curbuf = curbuf->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  curbuf = curwin->w_buffer;
  adjust_cursor();
  }
  return;
}
}
static void aucmd_prepbuf(struct aco_save *aco ) 
{ 
  WIN *win ;

  {
  if ((unsigned long )curwin->w_buffer == (unsigned long )curbuf) {
    win = curwin;
  } else {
    win = firstwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )win != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if ((unsigned long )win->w_buffer == (unsigned long )curbuf) {
        goto while_break;
      }
      win = win->w_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if ((unsigned long )win != (unsigned long )((void *)0)) {
    aco->save_curwin = curwin;
    curwin = win;
  } else {
    aco->save_curwin = (WIN *)((void *)0);
    aco->save_buf = curwin->w_buffer;
    ((aco->save_buf)->b_nwindows) --;
    curwin->w_buffer = curbuf;
    (curbuf->b_nwindows) ++;
    aco->save_cursor = curwin->w_cursor;
    curwin->w_cursor.lnum = (linenr_t )1;
    curwin->w_cursor.col = (colnr_t )0;
    aco->save_topline = curwin->w_topline;
    curwin->w_topline = (linenr_t )1;
  }
  return;
}
}
static void aucmd_restbuf(struct aco_save *aco ) 
{ 
  int len___0 ;
  int tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )aco->save_curwin != (unsigned long )((void *)0)) {
    {
    tmp = win_valid(aco->save_curwin);
    }
    if (tmp) {
      curwin = aco->save_curwin;
    }
  } else {
    {
    tmp___2 = buf_valid(aco->save_buf);
    }
    if (tmp___2) {
      ((curwin->w_buffer)->b_nwindows) --;
      curwin->w_buffer = aco->save_buf;
      ((aco->save_buf)->b_nwindows) ++;
      if (aco->save_cursor.lnum <= (aco->save_buf)->b_ml.ml_line_count) {
        {
        curwin->w_cursor = aco->save_cursor;
        tmp___0 = ml_get_buf(aco->save_buf, curwin->w_cursor.lnum, 0);
        tmp___1 = strlen((char const   *)((char *)tmp___0));
        len___0 = (int )tmp___1;
        }
        if (len___0 == 0) {
          curwin->w_cursor.col = (colnr_t )0;
        } else { //Added block
        if ((int )curwin->w_cursor.col >= len___0) {
          curwin->w_cursor.col = (colnr_t )(len___0 - 1);
        }
        }
      } else {
        curwin->w_cursor.lnum = (aco->save_buf)->b_ml.ml_line_count;
        curwin->w_cursor.col = (colnr_t )0;
      }
      if (aco->save_topline <= (aco->save_buf)->b_ml.ml_line_count) {
        curwin->w_topline = aco->save_topline;
      } else {
        curwin->w_topline = (aco->save_buf)->b_ml.ml_line_count;
      }
    }
  }
  return;
}
}
static int autocmd_nested  =    0;
int apply_autocmds(EVENT_T event , char_u *fname , char_u *fname_io , int force ,
                   BUF *buf___3 ) 
{ 
  int tmp ;

  {
  {
  tmp = apply_autocmds_group(event, fname, fname_io, force, -3, buf___3);
  }
  return (tmp);
}
}
int has_cursorhold(void) 
{ 


  {
  return ((unsigned long )first_autopat[39] != (unsigned long )((void *)0));
}
}
static int nesting  =    0;
static int apply_autocmds_group(EVENT_T event , char_u *fname , char_u *fname_io ,
                                int force , int group , BUF *buf___3 ) 
{ 
  char_u *sfname ;
  char_u *tail ;
  int temp ;
  int save_changed ;
  BUF *old_curbuf ;
  int retval ;
  char_u *save_sourcing_name ;
  linenr_t save_sourcing_lnum ;
  char_u *save_autocmd_fname ;
  int save_autocmd_bufnr ;
  char_u *save_autocmd_match ;
  int save_autocmd_busy ;
  int save_autocmd_nested ;
  AutoPatCmd patcmd ;
  AutoPat *ap ;
  void *save_funccalp ;
  int tmp ;

  {
  sfname = (char_u *)((void *)0);
  retval = 0;
  if ((unsigned long )first_autopat[(int )event] == (unsigned long )((void *)0)) {
    return (retval);
  }
  if (autocmd_busy) {
    if (! force) {
      if (! autocmd_nested) {
        return (retval);
      }
    }
  }
  {
  tmp = event_ignored(event);
  }
  if (tmp) {
    return (retval);
  }
  if (nesting == 10) {
    {
    emsg((char_u *)"autocommand nesting too deep");
    }
    return (retval);
  }
  if (autocmd_no_enter) {
    if ((unsigned int )event == 36U) {
      return (retval);
    } else { //Added block
    if ((unsigned int )event == 2U) {
      return (retval);
    } else {
      goto _L;
    }
    }
  } else { //Added block
  _L: 
  if (autocmd_no_leave) {
    if ((unsigned int )event == 37U) {
      return (retval);
    } else { //Added block
    if ((unsigned int )event == 5U) {
      return (retval);
    }
    }
  }
  }
  save_autocmd_fname = autocmd_fname;
  save_autocmd_bufnr = autocmd_bufnr;
  save_autocmd_match = autocmd_match;
  save_autocmd_busy = autocmd_busy;
  save_autocmd_nested = autocmd_nested;
  save_changed = curbuf->b_changed;
  old_curbuf = curbuf;
  if ((unsigned long )fname_io == (unsigned long )((void *)0)) {
    if ((unsigned long )fname != (unsigned long )((void *)0)) {
      if ((int )*fname != 0) {
        autocmd_fname = fname;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      autocmd_fname = buf___3->b_fname;
    } else {
      autocmd_fname = (char_u *)((void *)0);
    }
    }
  } else {
    autocmd_fname = fname_io;
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    autocmd_bufnr = 0;
  } else {
    autocmd_bufnr = buf___3->b_fnum;
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    goto _L___1;
  } else { //Added block
  if ((int )*fname == 0) {
    _L___1: 
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      fname = (char_u *)((void *)0);
    } else {
      if ((unsigned long )buf___3->b_sfname != (unsigned long )((void *)0)) {
        {
        sfname = vim_strsave(buf___3->b_sfname);
        }
      }
      fname = buf___3->b_ffname;
    }
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      fname = (char_u *)"";
    }
    {
    fname = vim_strsave(fname);
    }
  } else {
    {
    sfname = vim_strsave(fname);
    }
    if ((unsigned int )event == 18U) {
      {
      fname = vim_strsave(fname);
      }
    } else { //Added block
    if ((unsigned int )event == 30U) {
      {
      fname = vim_strsave(fname);
      }
    } else {
      {
      fname = FullName_save(fname, 0);
      }
    }
    }
  }
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    {
    vim_free((void *)sfname);
    }
    return (0);
  }
  {
  autocmd_match = fname;
  temp = RedrawingDisabled;
  RedrawingDisabled = 1;
  save_sourcing_name = sourcing_name;
  sourcing_name = (char_u *)((void *)0);
  save_sourcing_lnum = sourcing_lnum;
  sourcing_lnum = (linenr_t )0;
  save_funccalp = save_funccal();
  }
  if (! autocmd_busy) {
    {
    save_search_patterns();
    saveRedobuff();
    did_filetype = 0;
    }
  }
  autocmd_busy = 1;
  nesting ++;
  if ((unsigned int )event == 18U) {
    did_filetype = 1;
  }
  {
  tail = gettail(fname);
  patcmd.curpat = first_autopat[(int )event];
  patcmd.nextcmd = (AutoCmd *)((void *)0);
  patcmd.group = group;
  patcmd.fname = fname;
  patcmd.sfname = sfname;
  patcmd.tail = tail;
  patcmd.event = event;
  auto_next_pat(& patcmd, 0);
  }
  if ((unsigned long )patcmd.curpat != (unsigned long )((void *)0)) {
    retval = 1;
    ap = patcmd.curpat;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )ap->next != (unsigned long )((void *)0))) {
        goto while_break;
      }
      ap->last = (char)0;
      ap = ap->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
    ap->last = (char)1;
    check_lnums(1);
    do_cmdline((char_u *)((void *)0), & getnextac, (void *)(& patcmd), 7);
    }
  }
  {
  RedrawingDisabled = temp;
  autocmd_busy = save_autocmd_busy;
  autocmd_nested = save_autocmd_nested;
  vim_free((void *)sourcing_name);
  sourcing_name = save_sourcing_name;
  sourcing_lnum = save_sourcing_lnum;
  autocmd_fname = save_autocmd_fname;
  autocmd_bufnr = save_autocmd_bufnr;
  autocmd_match = save_autocmd_match;
  restore_funccal(save_funccalp);
  vim_free((void *)fname);
  vim_free((void *)sfname);
  nesting --;
  }
  if (! autocmd_busy) {
    {
    restore_search_patterns();
    restoreRedobuff();
    did_filetype = 0;
    }
  }
  if ((unsigned long )curbuf == (unsigned long )old_curbuf) {
    if ((unsigned int )event == 7U) {
      curbuf->b_changed = save_changed;
    } else { //Added block
    if ((unsigned int )event == 11U) {
      curbuf->b_changed = save_changed;
    } else { //Added block
    if ((unsigned int )event == 13U) {
      curbuf->b_changed = save_changed;
    } else { //Added block
    if ((unsigned int )event == 34U) {
      curbuf->b_changed = save_changed;
    } else { //Added block
    if ((unsigned int )event == 35U) {
      curbuf->b_changed = save_changed;
    }
    }
    }
    }
    }
  }
  {
  au_cleanup();
  }
  return (retval);
}
}
static void auto_next_pat(AutoPatCmd *apc , int stop_at_last ) 
{ 
  AutoPat *ap ;
  AutoCmd *cp ;
  char_u *name___1 ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  vim_free((void *)sourcing_name);
  sourcing_name = (char_u *)((void *)0);
  ap = apc->curpat;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )ap != (unsigned long )((void *)0)) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    apc->curpat = (AutoPat *)((void *)0);
    if ((unsigned long )ap->pat != (unsigned long )((void *)0)) {
      if ((unsigned long )ap->cmds != (unsigned long )((void *)0)) {
        if (apc->group == -3) {
          goto _L;
        } else { //Added block
        if (apc->group == ap->group) {
          _L: 
          {
          tmp___0 = match_file_pat(ap->reg_pat, apc->fname, apc->sfname, apc->tail,
                                   (int )ap->allow_dirs);
          }
          if (tmp___0) {
            {
            name___1 = event_nr2name(apc->event);
            tmp = strlen((char const   *)((char *)name___1));
            sourcing_name = alloc((unsigned int )((tmp + (size_t )ap->patlen) + 25UL));
            }
            if ((unsigned long )sourcing_name != (unsigned long )((void *)0)) {
              {
              sprintf((char * __restrict  )((char *)sourcing_name), (char const   * __restrict  )"%s Auto commands for \"%s\"",
                      (char *)name___1, (char *)ap->pat);
              }
              if (p_verbose >= 8L) {
                {
                smsg((char_u *)"Executing %s", sourcing_name);
                }
              }
            }
            apc->curpat = ap;
            apc->nextcmd = ap->cmds;
            cp = ap->cmds;
            {
            while (1) {
              while_continue___0: /* CIL Label */ ;
              if (! ((unsigned long )cp->next != (unsigned long )((void *)0))) {
                goto while_break___0;
              }
              cp->last = (char)0;
              cp = cp->next;
            }
            while_break___0: /* CIL Label */ ;
            }
            cp->last = (char)1;
          }
          {
          line_breakcheck();
          }
          if ((unsigned long )apc->curpat != (unsigned long )((void *)0)) {
            goto while_break;
          }
        }
        }
      }
    }
    if (stop_at_last) {
      if (ap->last) {
        goto while_break;
      }
    }
    ap = ap->next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char_u *getnextac(int c , void *cookie , int indent ) 
{ 
  AutoPatCmd *acp ;
  char_u *retval ;

  {
  acp = (AutoPatCmd *)cookie;
  if ((unsigned long )acp->curpat == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )acp->nextcmd != (unsigned long )((void *)0)) {
        if (! ((unsigned long )(acp->nextcmd)->cmd == (unsigned long )((void *)0))) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      if ((acp->nextcmd)->last) {
        acp->nextcmd = (AutoCmd *)((void *)0);
      } else {
        acp->nextcmd = (acp->nextcmd)->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )acp->nextcmd != (unsigned long )((void *)0)) {
      goto while_break;
    }
    if ((acp->curpat)->last) {
      acp->curpat = (AutoPat *)((void *)0);
    } else {
      acp->curpat = (acp->curpat)->next;
    }
    if ((unsigned long )acp->curpat != (unsigned long )((void *)0)) {
      {
      auto_next_pat(acp, 1);
      }
    }
    if ((unsigned long )acp->curpat == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (p_verbose >= 9L) {
    {
    msg_scroll = 1;
    smsg((char_u *)"autocommand %s", (acp->nextcmd)->cmd);
    msg_puts((char_u *)"\n");
    cmdline_row = msg_row;
    }
  }
  {
  retval = vim_strsave((acp->nextcmd)->cmd);
  autocmd_nested = (int )(acp->nextcmd)->nested;
  }
  if ((acp->nextcmd)->last) {
    acp->nextcmd = (AutoCmd *)((void *)0);
  } else {
    acp->nextcmd = (acp->nextcmd)->next;
  }
  return (retval);
}
}
char_u *get_augroup_name(int idx ) 
{ 


  {
  if (idx == augroups.ga_len) {
    return ((char_u *)"END");
  }
  if (idx >= augroups.ga_len) {
    return ((char_u *)((void *)0));
  }
  if ((unsigned long )*((char_u **)augroups.ga_data + idx) == (unsigned long )((void *)0)) {
    return ((char_u *)"");
  }
  return (*((char_u **)augroups.ga_data + idx));
}
}
static int include_groups  =    0;
char_u *set_context_in_autocmd(char_u *arg , int doautocmd ) 
{ 
  char_u *p___0 ;
  int group ;

  {
  {
  include_groups = 0;
  group = au_get_grouparg(& arg);
  }
  if (group == -2) {
    return ((char_u *)((void *)0));
  }
  p___0 = arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if ((int )*p___0 == 32) {
        goto while_break;
      } else { //Added block
      if ((int )*p___0 == 9) {
        goto while_break;
      }
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 44) {
      arg = p___0 + 1;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*p___0 == 0) {
    if (group == -3) {
      include_groups = 1;
    }
    expand_context = 10;
    expand_pattern = arg;
    return ((char_u *)((void *)0));
  }
  {
  arg = skipwhite(p___0);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (*arg) {
      if ((int )*arg == 32) {
        goto _L;
      } else { //Added block
      if ((int )*arg == 9) {
        _L: 
        if (! ((int )*(arg + -1) == 92)) {
          goto while_break___0;
        }
      }
      }
    } else {
      goto while_break___0;
    }
    arg ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (*arg) {
    return (arg);
  }
  if (doautocmd) {
    expand_context = 2;
  } else {
    expand_context = 0;
  }
  return ((char_u *)((void *)0));
}
}
char_u *get_event_name(int idx ) 
{ 


  {
  if (idx < augroups.ga_len) {
    if (! include_groups) {
      return ((char_u *)"");
    } else { //Added block
    if ((unsigned long )*((char_u **)augroups.ga_data + idx) == (unsigned long )((void *)0)) {
      return ((char_u *)"");
    }
    }
    return (*((char_u **)augroups.ga_data + idx));
  }
  return ((char_u *)event_names[idx - augroups.ga_len].name);
}
}
int match_file_pat(char_u *pattern , char_u *fname , char_u *sfname , char_u *tail ,
                   int allow_dirs ) 
{ 
  vim_regexp *prog ;
  int result___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  result___0 = 0;
  reg_ic = 0;
  prog = vim_regcomp(pattern, 1);
  }
  if ((unsigned long )prog != (unsigned long )((void *)0)) {
    if (allow_dirs) {
      {
      tmp = vim_regexec(prog, fname, 1);
      }
      if (tmp) {
        result___0 = 1;
      } else { //Added block
      if ((unsigned long )sfname != (unsigned long )((void *)0)) {
        {
        tmp___0 = vim_regexec(prog, sfname, 1);
        }
        if (tmp___0) {
          result___0 = 1;
        } else {
          goto _L;
        }
      } else {
        goto _L;
      }
      }
    } else { //Added block
    _L: 
    if (! allow_dirs) {
      {
      tmp___1 = vim_regexec(prog, tail, 1);
      }
      if (tmp___1) {
        result___0 = 1;
      }
    }
    }
  }
  {
  vim_free((void *)prog);
  }
  return (result___0);
}
}
char_u *file_pat_to_reg_pat(char_u *pat , char_u *pat_end , char *allow_dirs , int no_bslash ) 
{ 
  int size ;
  char_u *endp ;
  char_u *reg_pat ;
  char_u *p___0 ;
  int i___0 ;
  int nested ;
  int add_dollar ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  nested = 0;
  add_dollar = 1;
  if ((unsigned long )allow_dirs != (unsigned long )((void *)0)) {
    *allow_dirs = (char)0;
  }
  size = 2;
  p___0 = pat;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0 < (unsigned long )pat_end)) {
      goto while_break;
    }
    {
    if ((int )*p___0 == 42) {
      goto case_42;
    }
    if ((int )*p___0 == 46) {
      goto case_42;
    }
    if ((int )*p___0 == 44) {
      goto case_42;
    }
    if ((int )*p___0 == 123) {
      goto case_42;
    }
    if ((int )*p___0 == 125) {
      goto case_42;
    }
    if ((int )*p___0 == 126) {
      goto case_42;
    }
    goto switch_default;
    case_42: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_126: /* CIL Label */ 
    size += 2;
    goto switch_break;
    switch_default: /* CIL Label */ 
    size ++;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  reg_pat = alloc((unsigned int )(size + 1));
  }
  if ((unsigned long )reg_pat == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  i___0 = 0;
  if ((int )*(pat + 0) == 42) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((int )*(pat + 0) == 42) {
        if (! ((unsigned long )pat < (unsigned long )(pat_end - 1))) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      pat ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    tmp = i___0;
    i___0 ++;
    *(reg_pat + tmp) = (char_u )'^';
  }
  endp = pat_end - 1;
  if ((int )*endp == 42) {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (endp - pat > 0L) {
        if (! ((int )*endp == 42)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      endp --;
    }
    while_break___1: /* CIL Label */ ;
    }
    add_dollar = 0;
  }
  p___0 = pat;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (*p___0) {
      if (nested >= 0) {
        if (! ((unsigned long )p___0 <= (unsigned long )endp)) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
    } else {
      goto while_break___2;
    }
    {
    if ((int )*p___0 == 42) {
      goto case_42___0;
    }
    if ((int )*p___0 == 46) {
      goto case_46___0;
    }
    if ((int )*p___0 == 126) {
      goto case_46___0;
    }
    if ((int )*p___0 == 63) {
      goto case_63;
    }
    if ((int )*p___0 == 92) {
      goto case_92;
    }
    if ((int )*p___0 == 123) {
      goto case_123___0;
    }
    if ((int )*p___0 == 125) {
      goto case_125___0;
    }
    if ((int )*p___0 == 44) {
      goto case_44___0;
    }
    goto switch_default___0;
    case_42___0: /* CIL Label */ 
    tmp___0 = i___0;
    i___0 ++;
    *(reg_pat + tmp___0) = (char_u )'.';
    tmp___1 = i___0;
    i___0 ++;
    *(reg_pat + tmp___1) = (char_u )'*';
    goto switch_break___0;
    case_46___0: /* CIL Label */ 
    case_126___0: /* CIL Label */ 
    tmp___2 = i___0;
    i___0 ++;
    *(reg_pat + tmp___2) = (char_u )'\\';
    tmp___3 = i___0;
    i___0 ++;
    *(reg_pat + tmp___3) = *p___0;
    goto switch_break___0;
    case_63: /* CIL Label */ 
    tmp___4 = i___0;
    i___0 ++;
    *(reg_pat + tmp___4) = (char_u )'.';
    goto switch_break___0;
    case_92: /* CIL Label */ 
    if ((int )*(p___0 + 1) == 0) {
      goto switch_break___0;
    }
    p___0 ++;
    if ((int )*p___0 == 63) {
      tmp___5 = i___0;
      i___0 ++;
      *(reg_pat + tmp___5) = (char_u )'?';
    } else { //Added block
    if ((int )*p___0 == 44) {
      tmp___6 = i___0;
      i___0 ++;
      *(reg_pat + tmp___6) = (char_u )',';
    } else {
      if ((unsigned long )allow_dirs != (unsigned long )((void *)0)) {
        {
        tmp___7 = vim_ispathsep((int )*p___0);
        }
        if (tmp___7) {
          *allow_dirs = (char)1;
        }
      }
      tmp___8 = i___0;
      i___0 ++;
      *(reg_pat + tmp___8) = (char_u )'\\';
      tmp___9 = i___0;
      i___0 ++;
      *(reg_pat + tmp___9) = *p___0;
    }
    }
    goto switch_break___0;
    case_123___0: /* CIL Label */ 
    tmp___10 = i___0;
    i___0 ++;
    *(reg_pat + tmp___10) = (char_u )'\\';
    tmp___11 = i___0;
    i___0 ++;
    *(reg_pat + tmp___11) = (char_u )'(';
    nested ++;
    goto switch_break___0;
    case_125___0: /* CIL Label */ 
    tmp___12 = i___0;
    i___0 ++;
    *(reg_pat + tmp___12) = (char_u )'\\';
    tmp___13 = i___0;
    i___0 ++;
    *(reg_pat + tmp___13) = (char_u )')';
    nested --;
    goto switch_break___0;
    case_44___0: /* CIL Label */ 
    if (nested) {
      tmp___14 = i___0;
      i___0 ++;
      *(reg_pat + tmp___14) = (char_u )'\\';
      tmp___15 = i___0;
      i___0 ++;
      *(reg_pat + tmp___15) = (char_u )'|';
    } else {
      tmp___16 = i___0;
      i___0 ++;
      *(reg_pat + tmp___16) = (char_u )',';
    }
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    if ((unsigned long )allow_dirs != (unsigned long )((void *)0)) {
      {
      tmp___17 = vim_ispathsep((int )*p___0);
      }
      if (tmp___17) {
        *allow_dirs = (char)1;
      }
    }
    tmp___18 = i___0;
    i___0 ++;
    *(reg_pat + tmp___18) = *p___0;
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    p___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  if (add_dollar) {
    tmp___19 = i___0;
    i___0 ++;
    *(reg_pat + tmp___19) = (char_u )'$';
  }
  *(reg_pat + i___0) = (char_u )'\000';
  if (nested != 0) {
    if (nested < 0) {
      {
      emsg((char_u *)"Missing {.");
      }
    } else {
      {
      emsg((char_u *)"Missing }.");
      }
    }
    {
    vim_free((void *)reg_pat);
    reg_pat = (char_u *)((void *)0);
    }
  }
  return (reg_pat);
}
}
#pragma merger("0","/tmp/cil-Pa4aaib1.i","-O0")
extern int _IO_getc(_IO_FILE *__fp ) ;
FPOS VIsual  ;
int VIsual_select ;
int redo_VIsual_busy ;
int Exec_reg ;
char_u *typebuf ;
int typebuflen  ;
int typeoff  ;
int KeyStuffed  ;
FILE *scriptin[15]  ;
int curscript ;
FILE *scriptout ;
int did_outofmem_msg ;
int did_swapwrite_msg ;
int undo_off ;
char_u e_nesting[24] ;
char_u e_toocompl[20] ;
char_u *p_pt  ;
int p_remap  ;
int p_timeout  ;
long p_tm  ;
int p_ttimeout  ;
long p_ttm  ;
long p_uc  ;
char_u *get_recorded(void) ;
void flush_buffers(int typeahead ) ;
void stuffnumReadbuff(long n ) ;
int start_redo(long count___2 , int old_redo ) ;
int typebuf_maplen(void) ;
void del_typebuf(int len___0 , int offset ) ;
int save_typebuf(void) ;
void updatescript(int c ) ;
int putescstr(FILE *fd , char_u *str___1 , int set ) ;
void check_map_keycodes(void) ;
void init_mappings(void) ;
void ml_sync_all(int check_file , int check_char ) ;
int msg_outtrans_special(char_u *str___1 , int from ) ;
int get_keystroke(void) ;
int get_real_state(void) ;
void push_showcmd(void) ;
void pop_showcmd(void) ;
void unshowmode(int force ) ;
int add_termcap_entry(char_u *name___1 , int force ) ;
int check_termcode(int max_offset , char_u *buf___3 , int buflen ) ;
int ui_inchar(char_u *buf___3 , int maxlen , long wtime ) ;
static struct buffheader stuffbuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader old_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader save_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader save_old_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader recordbuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static int block_redo  =    0;
static struct mapblock *maphash[256]  ;
static int maphash_valid  =    0;
static struct mapblock *first_abbr  =    (struct mapblock *)((void *)0);
static char_u *noremapbuf  =    (char_u *)((void *)0);
static char_u typebuf_init[265]  ;
static char_u noremapbuf_init[265]  ;
static int typemaplen  =    0;
static int no_abbr_cnt  =    0;
static int last_recorded_len  =    0;
static void free_buff(struct buffheader *buf___3 ) ;
static char_u *get_bufcont(struct buffheader *buffer , int dozero ) ;
static void add_buff(struct buffheader *buf___3 , char_u *s ) ;
static void add_num_buff(struct buffheader *buf___3 , long n ) ;
static void add_char_buff(struct buffheader *buf___3 , int c ) ;
static int read_stuff(int advance ) ;
static void start_stuff(void) ;
static int read_redo(int init , int old_redo ) ;
static void copy_redo(int old_redo ) ;
static void init_typebuf(void) ;
static void gotchars(char_u *s , int len___0 ) ;
static void may_sync_undo(void) ;
static void closescript(void) ;
static int vgetorpeek(int advance ) ;
static void map_free(struct mapblock **mpp ) ;
static void validate_maphash(void) ;
static void showmap(struct mapblock *mp ) ;
static void free_buff(struct buffheader *buf___3 ) 
{ 
  struct bufblock *p___0 ;
  struct bufblock *np___0 ;

  {
  p___0 = buf___3->bh_first.b_next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    np___0 = p___0->b_next;
    vim_free((void *)p___0);
    p___0 = np___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  buf___3->bh_first.b_next = (struct bufblock *)((void *)0);
  return;
}
}
static char_u *get_bufcont(struct buffheader *buffer , int dozero ) 
{ 
  long_u count___2 ;
  char_u *p___0 ;
  char_u *p2 ;
  char_u *str___1 ;
  struct bufblock *bp___0 ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  count___2 = (long_u )0;
  p___0 = (char_u *)((void *)0);
  bp___0 = buffer->bh_first.b_next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )bp___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = strlen((char const   *)((char *)(bp___0->b_str)));
    count___2 += tmp;
    bp___0 = bp___0->b_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (count___2) {
    goto _L;
  } else { //Added block
  if (dozero) {
    _L: 
    {
    p___0 = lalloc(count___2 + 1UL, 1);
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      p2 = p___0;
      bp___0 = buffer->bh_first.b_next;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )bp___0 != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
        str___1 = bp___0->b_str;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! *str___1) {
            goto while_break___1;
          }
          tmp___0 = p2;
          p2 ++;
          tmp___1 = str___1;
          str___1 ++;
          *tmp___0 = *tmp___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        bp___0 = bp___0->b_next;
      }
      while_break___0: /* CIL Label */ ;
      }
      *p2 = (char_u )'\000';
    }
  }
  }
  return (p___0);
}
}
char_u *get_recorded(void) 
{ 
  char_u *p___0 ;
  size_t len___0 ;

  {
  {
  p___0 = get_bufcont(& recordbuff, 1);
  free_buff(& recordbuff);
  len___0 = strlen((char const   *)((char *)p___0));
  }
  if ((int )len___0 >= last_recorded_len) {
    len___0 -= (size_t )last_recorded_len;
    *(p___0 + len___0) = (char_u )'\000';
  }
  if (len___0 > 0UL) {
    if (restart_edit) {
      if ((int )*(p___0 + (len___0 - 1UL)) == 15) {
        *(p___0 + (len___0 - 1UL)) = (char_u )'\000';
      }
    }
  }
  return (p___0);
}
}
char_u *get_inserted(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_bufcont(& redobuff, 0);
  }
  return (tmp);
}
}
static void add_buff(struct buffheader *buf___3 , char_u *s ) 
{ 
  struct bufblock *p___0 ;
  long_u n ;
  long_u len___0 ;
  char_u *tmp ;

  {
  {
  n = strlen((char const   *)((char *)s));
  }
  if (n == 0UL) {
    return;
  }
  if ((unsigned long )buf___3->bh_first.b_next == (unsigned long )((void *)0)) {
    buf___3->bh_space = 0;
    buf___3->bh_curr = & buf___3->bh_first;
  } else { //Added block
  if ((unsigned long )buf___3->bh_curr == (unsigned long )((void *)0)) {
    {
    emsg((char_u *)"Add to read buffer");
    }
    return;
  } else { //Added block
  if (buf___3->bh_index != 0) {
    {
    strcpy((char * __restrict  )((char *)((buf___3->bh_first.b_next)->b_str)), (char const   * __restrict  )((char *)((buf___3->bh_first.b_next)->b_str + buf___3->bh_index)));
    }
  }
  }
  }
  buf___3->bh_index = 0;
  if (buf___3->bh_space >= (int )n) {
    {
    strcat((char * __restrict  )((char *)((buf___3->bh_curr)->b_str)), (char const   * __restrict  )((char *)s));
    buf___3->bh_space = (int )((long_u )buf___3->bh_space - n);
    }
  } else {
    if (n < 20UL) {
      len___0 = (long_u )20;
    } else {
      len___0 = n;
    }
    {
    tmp = lalloc(sizeof(struct bufblock ) + len___0, 1);
    p___0 = (struct bufblock *)tmp;
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      return;
    }
    {
    buf___3->bh_space = (int )(len___0 - n);
    strcpy((char * __restrict  )((char *)(p___0->b_str)), (char const   * __restrict  )((char *)s));
    p___0->b_next = (buf___3->bh_curr)->b_next;
    (buf___3->bh_curr)->b_next = p___0;
    buf___3->bh_curr = p___0;
    }
  }
  return;
}
}
static void add_num_buff(struct buffheader *buf___3 , long n ) 
{ 
  char_u number[32] ;

  {
  {
  sprintf((char * __restrict  )((char *)(number)), (char const   * __restrict  )"%ld",
          n);
  add_buff(buf___3, number);
  }
  return;
}
}
static void add_char_buff(struct buffheader *buf___3 , int c ) 
{ 
  char_u temp[4] ;
  int tmp ;

  {
  if (c >= 512) {
    goto _L;
  } else { //Added block
  if (c == 128) {
    goto _L;
  } else { //Added block
  if (c == 0) {
    _L: 
    temp[0] = (char_u )128;
    if (c == 128) {
      temp[1] = (char_u )254;
    } else {
      if (c == 0) {
        tmp = 255;
      } else {
        tmp = c & 255;
      }
      temp[1] = (char_u )tmp;
    }
    if (c == 128) {
      temp[2] = (char_u )'X';
    } else { //Added block
    if (c == 0) {
      temp[2] = (char_u )'X';
    } else {
      temp[2] = (char_u )(((unsigned int )c >> 8) & 255U);
    }
    }
    temp[3] = (char_u )'\000';
  } else {
    temp[0] = (char_u )c;
    temp[1] = (char_u )'\000';
  }
  }
  }
  {
  add_buff(buf___3, temp);
  }
  return;
}
}
static int read_stuff(int advance ) 
{ 
  char_u c ;
  struct bufblock *curr ;

  {
  if ((unsigned long )stuffbuff.bh_first.b_next == (unsigned long )((void *)0)) {
    return ('\000');
  }
  curr = stuffbuff.bh_first.b_next;
  c = curr->b_str[stuffbuff.bh_index];
  if (advance) {
    (stuffbuff.bh_index) ++;
    if ((int )curr->b_str[stuffbuff.bh_index] == 0) {
      {
      stuffbuff.bh_first.b_next = curr->b_next;
      vim_free((void *)curr);
      stuffbuff.bh_index = 0;
      }
    }
  }
  return ((int )c);
}
}
static void start_stuff(void) 
{ 


  {
  if ((unsigned long )stuffbuff.bh_first.b_next != (unsigned long )((void *)0)) {
    stuffbuff.bh_curr = & stuffbuff.bh_first;
    stuffbuff.bh_space = 0;
  }
  return;
}
}
int stuff_empty(void) 
{ 


  {
  return ((unsigned long )stuffbuff.bh_first.b_next == (unsigned long )((void *)0));
}
}
void flush_buffers(int typeahead ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  init_typebuf();
  start_stuff();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = read_stuff(1);
    }
    if (! (tmp != 0)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (typeahead) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___0 = inchar(typebuf, typebuflen - 1, 10L);
      }
      if (! tmp___0) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    typeoff = 50;
    typelen = 0;
  } else {
    typeoff += typemaplen;
    typelen -= typemaplen;
  }
  typemaplen = 0;
  no_abbr_cnt = 0;
  return;
}
}
void ResetRedobuff(void) 
{ 


  {
  if (! block_redo) {
    {
    free_buff(& old_redobuff);
    old_redobuff = redobuff;
    redobuff.bh_first.b_next = (struct bufblock *)((void *)0);
    }
  }
  return;
}
}
static int save_level  =    0;
void saveRedobuff(void) 
{ 
  int tmp ;

  {
  tmp = save_level;
  save_level ++;
  if (tmp == 0) {
    save_redobuff = redobuff;
    redobuff.bh_first.b_next = (struct bufblock *)((void *)0);
    save_old_redobuff = old_redobuff;
    old_redobuff.bh_first.b_next = (struct bufblock *)((void *)0);
  }
  return;
}
}
void restoreRedobuff(void) 
{ 


  {
  save_level --;
  if (save_level == 0) {
    {
    free_buff(& redobuff);
    redobuff = save_redobuff;
    free_buff(& old_redobuff);
    old_redobuff = save_old_redobuff;
    }
  }
  return;
}
}
void AppendToRedobuff(char_u *s ) 
{ 


  {
  if (! block_redo) {
    {
    add_buff(& redobuff, s);
    }
  }
  return;
}
}
void AppendCharToRedobuff(int c ) 
{ 


  {
  if (! block_redo) {
    {
    add_char_buff(& redobuff, c);
    }
  }
  return;
}
}
void AppendNumberToRedobuff(long n ) 
{ 


  {
  if (! block_redo) {
    {
    add_num_buff(& redobuff, n);
    }
  }
  return;
}
}
void stuffReadbuff(char_u *s ) 
{ 


  {
  {
  add_buff(& stuffbuff, s);
  }
  return;
}
}
void stuffcharReadbuff(int c ) 
{ 


  {
  {
  add_char_buff(& stuffbuff, c);
  }
  return;
}
}
void stuffnumReadbuff(long n ) 
{ 


  {
  {
  add_num_buff(& stuffbuff, n);
  }
  return;
}
}
static struct bufblock *bp  ;
static char_u *p  ;
static int read_redo(int init , int old_redo ) 
{ 
  int c ;
  int tmp ;

  {
  if (init) {
    if (old_redo) {
      bp = old_redobuff.bh_first.b_next;
    } else {
      bp = redobuff.bh_first.b_next;
    }
    if ((unsigned long )bp == (unsigned long )((void *)0)) {
      return (0);
    }
    p = bp->b_str;
    return (1);
  }
  c = (int )*p;
  if (c != 0) {
    if (c == 128) {
      if ((int )*(p + 1) == 254) {
        c = 128;
      } else {
        if ((int )*(p + 1) == 255) {
          tmp = 255 + (88 << 8);
        } else {
          tmp = (int )*(p + 1) + ((int )*(p + 2) << 8);
        }
        c = tmp;
      }
      p += 2;
    }
    p ++;
    if ((int )*p == 0) {
      if ((unsigned long )bp->b_next != (unsigned long )((void *)0)) {
        bp = bp->b_next;
        p = bp->b_str;
      }
    }
  }
  return (c);
}
}
static void copy_redo(int old_redo ) 
{ 
  int c ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    c = read_redo(0, old_redo);
    }
    if (! (c != 0)) {
      goto while_break;
    }
    {
    stuffcharReadbuff(c);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int start_redo(long count___2 , int old_redo ) 
{ 
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  tmp = read_redo(1, old_redo);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  c = read_redo(0, old_redo);
  }
  if (c == 34) {
    {
    add_buff(& stuffbuff, (char_u *)"\"");
    c = read_redo(0, old_redo);
    }
    if (c >= 49) {
      if (c < 57) {
        c ++;
      }
    }
    {
    add_char_buff(& stuffbuff, c);
    c = read_redo(0, old_redo);
    }
  }
  if (c == 118) {
    {
    VIsual = curwin->w_cursor;
    VIsual_active = 1;
    VIsual_reselect = 1;
    redo_VIsual_busy = 1;
    c = read_redo(0, old_redo);
    }
  }
  if (count___2) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp___0 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___0 + c) & 2048)) {
        goto while_break;
      }
      {
      c = read_redo(0, old_redo);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    add_num_buff(& stuffbuff, count___2);
    }
  }
  {
  add_char_buff(& stuffbuff, c);
  copy_redo(old_redo);
  }
  return (1);
}
}
int start_redo_ins(void) 
{ 
  int c ;
  int tmp ;
  char_u *tmp___0 ;

  {
  {
  tmp = read_redo(1, 0);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  start_stuff();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    c = read_redo(0, 0);
    }
    if (! (c != 0)) {
      goto while_break;
    }
    {
    tmp___0 = vim_strchr((char_u *)"AaIiRrOo", c);
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      if (c == 79) {
        {
        stuffReadbuff((char_u *)"\n");
        }
      } else { //Added block
      if (c == 111) {
        {
        stuffReadbuff((char_u *)"\n");
        }
      }
      }
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  copy_redo(0);
  block_redo = 1;
  }
  return (1);
}
}
void stop_redo_ins(void) 
{ 


  {
  block_redo = 0;
  return;
}
}
static void init_typebuf(void) 
{ 


  {
  if ((unsigned long )typebuf == (unsigned long )((void *)0)) {
    typebuf = typebuf_init;
    noremapbuf = noremapbuf_init;
    typebuflen = 265;
    typelen = 0;
    typeoff = 0;
  }
  return;
}
}
int ins_typebuf(char_u *str___1 , int noremap , int offset , int nottyped ) 
{ 
  char_u *s1 ;
  char_u *s2 ;
  int newlen ;
  int addlen ;
  int i___0 ;
  int newoff ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  init_typebuf();
  tmp = strlen((char const   *)((char *)str___1));
  addlen = (int )tmp;
  }
  if (offset == 0) {
    if (addlen <= typeoff) {
      {
      typeoff -= addlen;
      memmove((void *)((char *)(typebuf + typeoff)), (void const   *)((char *)str___1),
              (size_t )addlen);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    newoff = 54;
    newlen = ((typelen + addlen) + newoff) + 216;
    if (newlen < 0) {
      {
      emsg(e_toocompl);
      setcursor();
      }
      return (0);
    }
    {
    s1 = alloc((unsigned int )newlen);
    }
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
      return (0);
    }
    {
    s2 = alloc((unsigned int )newlen);
    }
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
      {
      vim_free((void *)s1);
      }
      return (0);
    }
    {
    typebuflen = newlen;
    memmove((void *)((char *)(s1 + newoff)), (void const   *)((char *)(typebuf + typeoff)),
            (size_t )offset);
    memmove((void *)((char *)((s1 + newoff) + offset)), (void const   *)((char *)str___1),
            (size_t )addlen);
    memmove((void *)((char *)(((s1 + newoff) + offset) + addlen)), (void const   *)((char *)((typebuf + typeoff) + offset)),
            (size_t )((typelen - offset) + 1));
    }
    if ((unsigned long )typebuf != (unsigned long )(typebuf_init)) {
      {
      vim_free((void *)typebuf);
      }
    }
    {
    typebuf = s1;
    memmove((void *)((char *)(s2 + newoff)), (void const   *)((char *)(noremapbuf + typeoff)),
            (size_t )offset);
    memmove((void *)((char *)(((s2 + newoff) + offset) + addlen)), (void const   *)((char *)((noremapbuf + typeoff) + offset)),
            (size_t )(typelen - offset));
    }
    if ((unsigned long )noremapbuf != (unsigned long )(noremapbuf_init)) {
      {
      vim_free((void *)noremapbuf);
      }
    }
    noremapbuf = s2;
    typeoff = newoff;
  }
  typelen += addlen;
  if (noremap < 0) {
    noremap = addlen;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < addlen)) {
      goto while_break;
    }
    tmp___0 = noremap;
    noremap --;
    *(noremapbuf + ((typeoff + i___0) + offset)) = (char_u )(tmp___0 > 0);
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (nottyped) {
    typemaplen += addlen;
  }
  if (no_abbr_cnt) {
    if (offset == 0) {
      no_abbr_cnt += addlen;
    }
  }
  return (1);
}
}
int typebuf_typed(void) 
{ 


  {
  return (typemaplen == 0);
}
}
int typebuf_maplen(void) 
{ 


  {
  return (typemaplen);
}
}
void del_typebuf(int len___0 , int offset ) 
{ 
  int i___0 ;

  {
  typelen -= len___0;
  if (offset == 0) {
    if (typebuflen - (typeoff + len___0) >= 153) {
      typeoff += len___0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    i___0 = typeoff + offset;
    if (typeoff > 50) {
      {
      memmove((void *)((char *)(typebuf + 50)), (void const   *)((char *)(typebuf + typeoff)),
              (size_t )offset);
      memmove((void *)((char *)(noremapbuf + 50)), (void const   *)((char *)(noremapbuf + typeoff)),
              (size_t )offset);
      typeoff = 50;
      }
    }
    {
    memmove((void *)((char *)((typebuf + typeoff) + offset)), (void const   *)((char *)((typebuf + i___0) + len___0)),
            (size_t )((typelen - offset) + 1));
    memmove((void *)((char *)((noremapbuf + typeoff) + offset)), (void const   *)((char *)((noremapbuf + i___0) + len___0)),
            (size_t )(typelen - offset));
    }
  }
  if (typemaplen > offset) {
    if (typemaplen < offset + len___0) {
      typemaplen = offset;
    } else {
      typemaplen -= len___0;
    }
  }
  if (no_abbr_cnt > offset) {
    if (no_abbr_cnt < offset + len___0) {
      no_abbr_cnt = offset;
    } else {
      no_abbr_cnt -= len___0;
    }
  }
  return;
}
}
static void gotchars(char_u *s , int len___0 ) 
{ 
  int c ;
  char_u buf___3[2] ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if (Recording) {
    last_recorded_len += len___0;
  }
  buf___3[1] = (char_u )'\000';
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___0 = len___0;
    len___0 --;
    if (! tmp___0) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    c = (int )*tmp;
    updatescript(c);
    }
    if (Recording) {
      {
      buf___3[0] = (char_u )c;
      add_buff(& recordbuff, buf___3);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  may_sync_undo();
  maptick ++;
  }
  return;
}
}
static void may_sync_undo(void) 
{ 


  {
  if (! (State & 24)) {
    goto _L;
  } else { //Added block
  if (arrow_used) {
    _L: 
    if ((unsigned long )scriptin[curscript] == (unsigned long )((void *)0)) {
      if (! no_u_sync) {
        {
        u_sync();
        }
      }
    }
  }
  }
  return;
}
}
static char_u *sv_typebuf[15]  ;
static char_u *sv_noremapbuf[15]  ;
static int sv_typebuflen[15]  ;
static int sv_typeoff[15]  ;
static int sv_typelen[15]  ;
static int sv_typemaplen[15]  ;
static int sv_no_abbr_cnt[15]  ;
int save_typebuf(void) 
{ 


  {
  {
  init_typebuf();
  sv_typebuf[curscript] = typebuf;
  sv_noremapbuf[curscript] = noremapbuf;
  sv_typebuflen[curscript] = typebuflen;
  sv_typeoff[curscript] = typeoff;
  sv_typelen[curscript] = typelen;
  sv_typemaplen[curscript] = typemaplen;
  sv_no_abbr_cnt[curscript] = no_abbr_cnt;
  typebuf = alloc(265U);
  noremapbuf = alloc(265U);
  typebuflen = 265;
  typeoff = 0;
  typelen = 0;
  typemaplen = 0;
  no_abbr_cnt = 0;
  }
  if ((unsigned long )typebuf == (unsigned long )((void *)0)) {
    {
    closescript();
    }
    return (0);
  } else { //Added block
  if ((unsigned long )noremapbuf == (unsigned long )((void *)0)) {
    {
    closescript();
    }
    return (0);
  }
  }
  return (1);
}
}
int openscript(char_u *name___1 ) 
{ 
  int oldcurscript ;
  OPARG oa ;
  int save_State ;
  FILE *tmp ;
  int tmp___0 ;

  {
  if (curscript + 1 == 15) {
    {
    emsg(e_nesting);
    }
    return (0);
  }
  if ((unsigned long )scriptin[curscript] != (unsigned long )((void *)0)) {
    curscript ++;
  }
  {
  expand_env(name___1, NameBuff, 1024);
  tmp = fopen((char const   * __restrict  )((char *)NameBuff), (char const   * __restrict  )"r");
  scriptin[curscript] = tmp;
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    emsg2(e_notopen, name___1);
    }
    if (curscript) {
      curscript --;
    }
    return (0);
  }
  {
  tmp___0 = save_typebuf();
  }
  if (tmp___0 == 0) {
    return (0);
  }
  if (global_busy) {
    {
    clear_oparg(& oa);
    save_State = State;
    State = 1;
    oldcurscript = curscript;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      adjust_cursor();
      normal_cmd(& oa, 0);
      vpeekc();
      }
      if (! ((unsigned long )scriptin[oldcurscript] != (unsigned long )((void *)0))) {
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    State = save_State;
  }
  return (1);
}
}
static void closescript(void) 
{ 


  {
  {
  vim_free((void *)typebuf);
  vim_free((void *)noremapbuf);
  typebuf = sv_typebuf[curscript];
  noremapbuf = sv_noremapbuf[curscript];
  typebuflen = sv_typebuflen[curscript];
  typelen = sv_typelen[curscript];
  typeoff = sv_typeoff[curscript];
  typemaplen = sv_typemaplen[curscript];
  no_abbr_cnt = sv_no_abbr_cnt[curscript];
  fclose(scriptin[curscript]);
  scriptin[curscript] = (FILE *)((void *)0);
  }
  if (curscript) {
    curscript --;
  }
  return;
}
}
int using_script(void) 
{ 


  {
  return ((unsigned long )scriptin[curscript] != (unsigned long )((void *)0));
}
}
static int count___0  =    0;
void updatescript(int c ) 
{ 


  {
  if (c) {
    if (scriptout) {
      {
      _IO_putc(c, scriptout);
      }
    }
  }
  if (c == 0) {
    {
    ml_sync_all(c == 0, 1);
    count___0 = 0;
    }
  } else { //Added block
  if (p_uc > 0L) {
    count___0 ++;
    if ((long )count___0 >= p_uc) {
      {
      ml_sync_all(c == 0, 1);
      count___0 = 0;
      }
    }
  }
  }
  return;
}
}
static int old_char  =    -1;
int vgetc(void) 
{ 
  int c ;
  int c2 ;
  int tmp ;

  {
  mod_mask = 0;
  last_recorded_len = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (mod_mask) {
      no_mapping ++;
      allow_keys ++;
    }
    {
    c = vgetorpeek(1);
    }
    if (mod_mask) {
      no_mapping --;
      allow_keys --;
    }
    if (c == 128) {
      {
      no_mapping ++;
      c2 = vgetorpeek(1);
      c = vgetorpeek(1);
      no_mapping --;
      }
      if (c2 == 252) {
        mod_mask = c;
        goto __Cont;
      }
      if (c2 == 254) {
        c = 128;
      } else {
        if (c2 == 255) {
          tmp = 255 + (88 << 8);
        } else {
          tmp = c2 + (c << 8);
        }
        c = tmp;
      }
    }
    return (c);
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
int safe_vgetc(void) 
{ 
  int c ;

  {
  {
  c = vgetc();
  }
  if (c == 0) {
    {
    c = get_keystroke();
    }
  }
  return (c);
}
}
int vpeekc(void) 
{ 
  int tmp ;

  {
  {
  tmp = vgetorpeek(0);
  }
  return (tmp);
}
}
int char_avail(void) 
{ 
  int retval ;

  {
  {
  no_mapping ++;
  retval = vgetorpeek(0);
  no_mapping --;
  }
  return (retval != 0);
}
}
void vungetc(int c ) 
{ 


  {
  old_char = c;
  return;
}
}
static int vgetorpeek(int advance ) 
{ 
  int c ;
  int c1 ;
  int keylen ;
  char_u *s ;
  struct mapblock *mp ;
  int timedout ;
  int mapdepth ;
  int mode_deleted ;
  int local_State ;
  int mlen ;
  int max_mlen ;
  int i___0 ;
  int new_wcol ;
  int new_wrow ;
  int n ;
  int old_wcol ;
  int old_wrow ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  colnr_t col ;
  colnr_t vcol ;
  char_u *ptr ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;

  {
  timedout = 0;
  mapdepth = 0;
  mode_deleted = 0;
  if (vgetc_busy) {
    return ('\000');
  }
  {
  local_State = get_real_state();
  }
  if (old_char >= 0) {
    c = old_char;
    if (advance) {
      old_char = -1;
    }
    return (c);
  }
  vgetc_busy = 1;
  if (advance) {
    KeyStuffed = 0;
  }
  {
  init_typebuf();
  start_stuff();
  }
  if (advance) {
    if (typemaplen == 0) {
      Exec_reg = 0;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    c = read_stuff(advance);
    }
    if (c != 0) {
      if (! got_int) {
        if (advance) {
          KeyTyped = 0;
          KeyStuffed = 1;
        }
        if (no_abbr_cnt == 0) {
          no_abbr_cnt = 1;
        }
      } else {
        goto _L___9;
      }
    } else {
      _L___9: 
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (typemaplen) {
          {
          line_breakcheck();
          }
        } else {
          {
          ui_breakcheck();
          }
        }
        keylen = 0;
        if (got_int) {
          {
          c = inchar(typebuf, typebuflen - 1, 0L);
          }
          if (c) {
            goto _L;
          } else { //Added block
          if (typemaplen) {
            _L: 
            if (State & 24) {
              c = '\033';
            } else {
              c = 3;
            }
          } else {
            c = 3;
          }
          }
          {
          flush_buffers(1);
          }
          goto while_break___0;
        } else { //Added block
        if (typelen > 0) {
          mp = (struct mapblock *)((void *)0);
          max_mlen = 0;
          if (! timedout) {
            if (no_mapping == 0) {
              if (maphash_valid) {
                if (typemaplen == 0) {
                  goto _L___4;
                } else { //Added block
                if (p_remap) {
                  if ((int )*(noremapbuf + typeoff) == 0) {
                    _L___4: 
                    if (p_paste) {
                      if (! (State & 24)) {
                        goto _L___3;
                      }
                    } else { //Added block
                    _L___3: 
                    if (State == 1537) {
                      if (! ((int )*(typebuf + typeoff) == 13)) {
                        if (! ((int )*(typebuf + typeoff) == 32)) {
                          goto _L___2;
                        }
                      }
                    } else { //Added block
                    _L___2: 
                    if (State != 1792) {
                      if (State != 3072) {
                        if (ctrl_x_mode) {
                          {
                          tmp___1 = vim_is_ctrl_x_key((int )*(typebuf + typeoff));
                          }
                          if (! tmp___1) {
                            goto _L___1;
                          }
                        } else {
                          _L___1: 
                          c1 = (int )*(typebuf + typeoff);
                          if (local_State & 7) {
                            tmp = c1;
                          } else {
                            tmp = c1 ^ 128;
                          }
                          mp = maphash[tmp];
                          {
                          while (1) {
                            while_continue___1: /* CIL Label */ ;
                            if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
                              goto while_break___1;
                            }
                            if ((int )*(mp->m_keys + 0) == c1) {
                              if (mp->m_mode & local_State) {
                                mlen = 1;
                                {
                                while (1) {
                                  while_continue___2: /* CIL Label */ ;
                                  if (! (mlen < typelen)) {
                                    goto while_break___2;
                                  }
                                  if ((int )*(mp->m_keys + mlen) != (int )*(typebuf + (typeoff + mlen))) {
                                    goto while_break___2;
                                  }
                                  mlen ++;
                                }
                                while_break___2: /* CIL Label */ ;
                                }
                                keylen = mp->m_keylen;
                                if (mlen == keylen) {
                                  goto _L___0;
                                } else { //Added block
                                if (mlen == typelen) {
                                  if (typelen < keylen) {
                                    _L___0: 
                                    s = noremapbuf + typeoff;
                                    n = mlen;
                                    {
                                    while (1) {
                                      while_continue___3: /* CIL Label */ ;
                                      n --;
                                      if (! (n >= 0)) {
                                        goto while_break___3;
                                      }
                                      tmp___0 = s;
                                      s ++;
                                      if (*tmp___0) {
                                        goto while_break___3;
                                      }
                                    }
                                    while_break___3: /* CIL Label */ ;
                                    }
                                    if (n >= 0) {
                                      goto __Cont;
                                    }
                                    if (keylen > typelen) {
                                      keylen = -2;
                                    }
                                    goto while_break___1;
                                  }
                                }
                                }
                                if (max_mlen < mlen) {
                                  max_mlen = mlen;
                                }
                              }
                            }
                            __Cont: 
                            mp = mp->m_next;
                          }
                          while_break___1: /* CIL Label */ ;
                          }
                        }
                      }
                    }
                    }
                    }
                  }
                }
                }
              }
            }
          }
          if ((int )*p_pt != 0) {
            if ((unsigned long )mp == (unsigned long )((void *)0)) {
              if (State & 17) {
                mlen = 0;
                {
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  if (mlen < typelen) {
                    if (! *(p_pt + mlen)) {
                      goto while_break___4;
                    }
                  } else {
                    goto while_break___4;
                  }
                  if ((int )*(p_pt + mlen) != (int )*(typebuf + (typeoff + mlen))) {
                    goto while_break___4;
                  }
                  mlen ++;
                }
                while_break___4: /* CIL Label */ ;
                }
                if ((int )*(p_pt + mlen) == 0) {
                  if (mlen > typemaplen) {
                    {
                    gotchars((typebuf + typeoff) + typemaplen, mlen - typemaplen);
                    }
                  }
                  {
                  del_typebuf(mlen, 0);
                  set_option_value((char_u *)"paste", (long )(! p_paste), (char_u *)((void *)0));
                  }
                  if (! (State & 16)) {
                    {
                    msg_col = 0;
                    msg_row = (int )(Rows - 1L);
                    msg_clr_eos();
                    }
                  }
                  {
                  showmode();
                  setcursor();
                  }
                  goto __Cont___0;
                }
                if (mlen == typelen) {
                  keylen = -2;
                } else { //Added block
                if (max_mlen < mlen) {
                  max_mlen = mlen + 1;
                }
                }
              }
            }
          }
          if ((unsigned long )mp == (unsigned long )((void *)0)) {
            if (keylen != -2) {
              if (no_mapping == 0) {
                goto _L___6;
              } else { //Added block
              if (allow_keys != 0) {
                _L___6: 
                if (typemaplen == 0) {
                  goto _L___5;
                } else { //Added block
                if (p_remap) {
                  if (! *(noremapbuf + typeoff)) {
                    _L___5: 
                    if (! timedout) {
                      {
                      keylen = check_termcode(max_mlen + 1, (char_u *)((void *)0),
                                              0);
                      }
                      if (keylen < 0) {
                        if (typelen == typemaplen) {
                          keylen = 0;
                        }
                      }
                    } else {
                      keylen = 0;
                    }
                  } else {
                    keylen = 0;
                  }
                } else {
                  keylen = 0;
                }
                }
              } else {
                keylen = 0;
              }
              }
              if (keylen == 0) {
                c = (int )*(typebuf + typeoff) & 255;
                if (advance) {
                  if (typemaplen) {
                    KeyTyped = 0;
                  } else {
                    {
                    KeyTyped = 1;
                    gotchars(typebuf + typeoff, 1);
                    }
                  }
                  {
                  del_typebuf(1, 0);
                  }
                }
                goto while_break___0;
              }
              if (keylen > 0) {
                goto __Cont___0;
              }
              keylen = -1;
            }
          }
          if (keylen >= 0) {
            if (keylen <= typelen) {
              if (keylen > typemaplen) {
                {
                gotchars((typebuf + typeoff) + typemaplen, keylen - typemaplen);
                }
              }
              {
              del_typebuf(keylen, 0);
              mapdepth ++;
              }
              if ((long )mapdepth >= p_mmd) {
                {
                emsg((char_u *)"recursive mapping");
                }
                if (State == 8) {
                  {
                  redrawcmdline();
                  }
                } else {
                  {
                  setcursor();
                  }
                }
                {
                flush_buffers(0);
                mapdepth = 0;
                c = -1;
                }
                goto while_break___0;
              }
              if (VIsual_active) {
                if (VIsual_select) {
                  {
                  VIsual_select = 0;
                  ins_typebuf((char_u *)"\200\365X", -1, 0, 1);
                  }
                }
              }
              if (mp->m_noremap) {
                tmp___5 = -1;
              } else {
                {
                tmp___4 = strncmp((char const   *)((char *)mp->m_str), (char const   *)((char *)mp->m_keys),
                                  (size_t )keylen);
                }
                if (tmp___4) {
                  tmp___3 = 0;
                } else {
                  tmp___3 = 1;
                }
                tmp___5 = tmp___3;
              }
              {
              tmp___6 = ins_typebuf(mp->m_str, tmp___5, 0, 1);
              }
              if (tmp___6 == 0) {
                c = -1;
                goto while_break___0;
              }
              goto __Cont___0;
            }
          }
        }
        }
        c = 0;
        new_wcol = curwin->w_wcol;
        new_wrow = curwin->w_wrow;
        if (advance) {
          if (typelen == 1) {
            if ((int )*(typebuf + typeoff) == 27) {
              if (! no_mapping) {
                if (typemaplen == 0) {
                  if (State & 16) {
                    if (p_timeout) {
                      goto _L___7;
                    } else { //Added block
                    if (keylen == -1) {
                      if (p_ttimeout) {
                        _L___7: 
                        {
                        c = inchar((typebuf + typeoff) + typelen, 3, 25L);
                        }
                        if (c == 0) {
                          if (p_smd) {
                            {
                            unshowmode(1);
                            mode_deleted = 1;
                            }
                          }
                          {
                          validate_cursor();
                          old_wcol = curwin->w_wcol;
                          old_wrow = curwin->w_wrow;
                          }
                          if (curwin->w_cursor.col != 0U) {
                            if (curwin->w_wcol) {
                              if (did_ai) {
                                {
                                tmp___7 = 0;
                                curwin->w_wcol = tmp___7;
                                vcol = (colnr_t )tmp___7;
                                col = vcol;
                                ptr = ml_get_curline();
                                }
                                {
                                while (1) {
                                  while_continue___5: /* CIL Label */ ;
                                  if (! (col < curwin->w_cursor.col)) {
                                    goto while_break___5;
                                  }
                                  if (! ((int )*(ptr + col) == 32)) {
                                    if (! ((int )*(ptr + col) == 9)) {
                                      curwin->w_wcol = (int )vcol;
                                    }
                                  }
                                  {
                                  tmp___8 = lbr_chartabsize(ptr + col, vcol);
                                  vcol += (colnr_t )tmp___8;
                                  col ++;
                                  }
                                }
                                while_break___5: /* CIL Label */ ;
                                }
                                if (curwin->w_p_nu) {
                                  curwin->w_wcol += 8;
                                }
                              } else {
                                (curwin->w_wcol) --;
                              }
                            } else { //Added block
                            if (curwin->w_p_wrap) {
                              if (curwin->w_wrow) {
                                (curwin->w_wrow) --;
                                curwin->w_wcol = (int )(Columns - 1L);
                              }
                            }
                            }
                          }
                          {
                          setcursor();
                          out_flush();
                          new_wcol = curwin->w_wcol;
                          new_wrow = curwin->w_wrow;
                          curwin->w_wcol = old_wcol;
                          curwin->w_wrow = old_wrow;
                          }
                        }
                      }
                    }
                    }
                  }
                }
              }
            }
          }
        }
        if (c < 0) {
          goto __Cont___0;
        }
        typelen += c;
        if (typelen >= typemaplen + 50) {
          timedout = 1;
          goto __Cont___0;
        }
        i___0 = 0;
        if (typelen > 0) {
          if (State & 17) {
            if (advance) {
              if (! exmode_active) {
                {
                old_wcol = curwin->w_wcol;
                old_wrow = curwin->w_wrow;
                curwin->w_wcol = new_wcol;
                curwin->w_wrow = new_wrow;
                push_showcmd();
                }
                if (typelen > 10) {
                  i___0 = typelen - 10;
                }
                {
                while (1) {
                  while_continue___6: /* CIL Label */ ;
                  if (! (i___0 < typelen)) {
                    goto while_break___6;
                  }
                  {
                  tmp___9 = i___0;
                  i___0 ++;
                  add_to_showcmd((int )*(typebuf + (typeoff + tmp___9)));
                  }
                }
                while_break___6: /* CIL Label */ ;
                }
                curwin->w_wcol = old_wcol;
                curwin->w_wrow = old_wrow;
              }
            }
          }
        }
        if (! advance) {
          tmp___12 = 0L;
        } else {
          if (typelen == 0) {
            tmp___11 = -1L;
          } else { //Added block
          if (p_timeout) {
            goto _L___8;
          } else { //Added block
          if (p_ttimeout) {
            if (keylen == -1) {
              _L___8: 
              if (keylen == -1) {
                if (p_ttm >= 0L) {
                  tmp___10 = p_ttm;
                } else {
                  tmp___10 = p_tm;
                }
              } else {
                tmp___10 = p_tm;
              }
              tmp___11 = tmp___10;
            } else {
              tmp___11 = -1L;
            }
          } else {
            tmp___11 = -1L;
          }
          }
          }
          tmp___12 = tmp___11;
        }
        {
        c = inchar((typebuf + typeoff) + typelen, ((typebuflen - typeoff) - typelen) - 1,
                   tmp___12);
        }
        if (i___0) {
          {
          pop_showcmd();
          }
        }
        if (c < 0) {
          goto __Cont___0;
        }
        if (c == 0) {
          if (! advance) {
            goto while_break___0;
          }
          if (typelen) {
            timedout = 1;
            goto __Cont___0;
          }
        } else {
          {
          while (1) {
            while_continue___7: /* CIL Label */ ;
            if (! ((int )*(typebuf + (typeoff + typelen)) != 0)) {
              goto while_break___7;
            }
            tmp___13 = typelen;
            typelen ++;
            *(noremapbuf + (typeoff + tmp___13)) = (char_u )0;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
        __Cont___0: ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    if (! (c < 0)) {
      if (advance) {
        if (! (c == 0)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (advance) {
    if (p_smd) {
      if (State & 16) {
        if (c == 27) {
          if (! mode_deleted) {
            if (! no_mapping) {
              if (typelen) {
                if (! KeyTyped) {
                  redraw_cmdline = 1;
                } else {
                  {
                  unshowmode(0);
                  }
                }
              } else {
                {
                unshowmode(0);
                }
              }
            } else {
              goto _L___11;
            }
          } else {
            goto _L___11;
          }
        } else { //Added block
        _L___11: 
        if (c != 27) {
          if (mode_deleted) {
            if (typelen) {
              if (! KeyTyped) {
                redraw_cmdline = 1;
              } else {
                {
                showmode();
                }
              }
            } else {
              {
              showmode();
              }
            }
          }
        }
        }
      }
    }
  }
  vgetc_busy = 0;
  return (c);
}
}
int inchar(char_u *buf___3 , int maxlen , long wait_time ) 
{ 
  int len___0 ;
  int retesc ;
  int c ;
  int i___0 ;
  char_u dum[154] ;
  int tmp ;
  int tmp___0 ;

  {
  len___0 = 0;
  retesc = 0;
  if (wait_time == -1L) {
    {
    cursor_on();
    out_flush();
    }
  } else { //Added block
  if (wait_time > 100L) {
    {
    cursor_on();
    out_flush();
    }
  }
  }
  if (State != 1537) {
    did_outofmem_msg = 0;
    did_swapwrite_msg = 0;
  }
  undo_off = 0;
  c = -1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )scriptin[curscript] != (unsigned long )((void *)0)) {
      if (! (c < 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (got_int) {
      goto _L;
    } else {
      {
      c = _IO_getc(scriptin[curscript]);
      }
      if (c < 0) {
        _L: 
        {
        closescript();
        }
        if (got_int) {
          retesc = 1;
        } else {
          return (-1);
        }
      } else {
        *(buf___3 + 0) = (char_u )c;
        len___0 = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (c < 0) {
    if (got_int) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp = ui_inchar(dum, 153, 0L);
        }
        if (! tmp) {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      return (retesc);
    }
    {
    out_flush();
    len___0 = ui_inchar(buf___3, maxlen / 3, wait_time);
    }
  }
  i___0 = len___0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break___1;
    }
    if ((int )*(buf___3 + 0) == 0) {
      goto _L___0;
    } else { //Added block
    if ((int )*(buf___3 + 0) == 128) {
      if (c < 0) {
        _L___0: 
        {
        memmove((void *)((char *)(buf___3 + 3)), (void const   *)((char *)(buf___3 + 1)),
                (size_t )i___0);
        }
        if ((int )*(buf___3 + 0) == 128) {
          *(buf___3 + 2) = (char_u )'X';
        } else { //Added block
        if ((int )*(buf___3 + 0) == 0) {
          *(buf___3 + 2) = (char_u )'X';
        } else {
          *(buf___3 + 2) = (char_u )(((unsigned int )*(buf___3 + 0) >> 8) & 255U);
        }
        }
        if ((int )*(buf___3 + 0) == 128) {
          *(buf___3 + 1) = (char_u )254;
        } else {
          if ((int )*(buf___3 + 0) == 0) {
            tmp___0 = 255;
          } else {
            tmp___0 = (int )*(buf___3 + 0) & 255;
          }
          *(buf___3 + 1) = (char_u )tmp___0;
        }
        *(buf___3 + 0) = (char_u )128;
        buf___3 += 2;
        len___0 += 2;
      }
    }
    }
    buf___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  *buf___3 = (char_u )'\000';
  return (len___0);
}
}
int do_map(int maptype , char_u *keys___0 , int mode , int abbrev , char_u **ambig ) 
{ 
  struct mapblock *mp ;
  struct mapblock **mpp ;
  char_u *arg ;
  char_u *p___0 ;
  int n ;
  int len___0 ;
  char_u *newstr ;
  int hasarg ;
  int haskey ;
  int did_it ;
  int round ;
  char_u *keys_buf ;
  char_u *arg_buf ;
  int retval ;
  int do_backslash ;
  int hash ;
  int new_hash ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  size_t tmp___10 ;

  {
  {
  len___0 = 0;
  did_it = 0;
  keys_buf = (char_u *)((void *)0);
  arg_buf = (char_u *)((void *)0);
  retval = 0;
  validate_maphash();
  p___0 = keys___0;
  tmp = vim_strchr(p_cpo, 'B');
  do_backslash = (unsigned long )tmp == (unsigned long )((void *)0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if (! (maptype == 1)) {
        if ((int )*p___0 == 32) {
          goto while_break;
        } else { //Added block
        if ((int )*p___0 == 9) {
          goto while_break;
        }
        }
      }
    } else {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == 22) {
      goto _L;
    } else { //Added block
    if (do_backslash) {
      if ((int )*(p___0 + 0) == 92) {
        _L: 
        if ((int )*(p___0 + 1) != 0) {
          p___0 ++;
        }
      }
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*p___0 != 0) {
    tmp___0 = p___0;
    p___0 ++;
    *tmp___0 = (char_u )'\000';
  }
  {
  p___0 = skipwhite(p___0);
  arg = p___0;
  hasarg = (int )*arg != 0;
  haskey = (int )*keys___0 != 0;
  }
  if (maptype == 1) {
    if (! haskey) {
      retval = 1;
      goto theend;
    }
  }
  if (haskey) {
    {
    keys___0 = replace_termcodes(keys___0, & keys_buf, 1, 1);
    }
  }
  if (hasarg) {
    {
    tmp___1 = strcasecmp((char const   *)((char *)arg), (char const   *)((char *)"<nop>"));
    }
    if (tmp___1 == 0) {
      arg = (char_u *)"";
    } else {
      {
      arg = replace_termcodes(arg, & arg_buf, 0, 1);
      }
    }
  }
  if (haskey) {
    {
    tmp___2 = strlen((char const   *)((char *)keys___0));
    len___0 = (int )tmp___2;
    }
    if (len___0 > 50) {
      retval = 1;
      goto theend;
    }
    if (abbrev) {
      if (maptype != 1) {
        {
        tmp___5 = vim_iswordc((int )*(keys___0 + (len___0 - 1)));
        }
        if (tmp___5) {
          n = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (n < len___0 - 2)) {
              goto while_break___0;
            }
            {
            tmp___3 = vim_iswordc((int )*(keys___0 + n));
            tmp___4 = vim_iswordc((int )*(keys___0 + (len___0 - 2)));
            }
            if (tmp___3 != tmp___4) {
              retval = 1;
              goto theend;
            }
            n ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        n = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (n < len___0)) {
            goto while_break___1;
          }
          if ((int )*(keys___0 + n) == 32) {
            retval = 1;
            goto theend;
          } else { //Added block
          if ((int )*(keys___0 + n) == 9) {
            retval = 1;
            goto theend;
          }
          }
          n ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  if (haskey) {
    if (hasarg) {
      if (abbrev) {
        no_abbr = 0;
      }
    }
  }
  if (! haskey) {
    {
    msg_start();
    }
  } else { //Added block
  if (maptype != 1) {
    if (! hasarg) {
      {
      msg_start();
      }
    }
  }
  }
  round = 0;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (round == 0) {
      goto _L___0;
    } else { //Added block
    if (maptype == 1) {
      _L___0: 
      if (round <= 1) {
        if (! did_it) {
          if (! (! got_int)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
    } else {
      goto while_break___2;
    }
    }
    hash = 0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (hash < 256) {
        if (! (! got_int)) {
          goto while_break___3;
        }
      } else {
        goto while_break___3;
      }
      if (abbrev) {
        if (hash) {
          goto while_break___3;
        }
        mpp = & first_abbr;
      } else {
        mpp = & maphash[hash];
      }
      mp = *mpp;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if ((unsigned long )mp != (unsigned long )((void *)0)) {
          if (! (! got_int)) {
            goto while_break___4;
          }
        } else {
          goto while_break___4;
        }
        if (! (mp->m_mode & mode)) {
          mpp = & mp->m_next;
          goto __Cont;
        }
        if (! haskey) {
          {
          showmap(mp);
          did_it = 1;
          }
        } else {
          if (round) {
            {
            tmp___6 = strlen((char const   *)((char *)mp->m_str));
            n = (int )tmp___6;
            p___0 = mp->m_str;
            }
          } else {
            n = mp->m_keylen;
            p___0 = mp->m_keys;
          }
          if (n < len___0) {
            tmp___7 = n;
          } else {
            tmp___7 = len___0;
          }
          {
          tmp___8 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)keys___0),
                            (size_t )tmp___7);
          }
          if (! tmp___8) {
            if (maptype == 1) {
              if (n != len___0) {
                mpp = & mp->m_next;
                goto __Cont;
              }
              mp->m_mode &= ~ mode;
              did_it = 1;
            } else { //Added block
            if (! hasarg) {
              {
              showmap(mp);
              did_it = 1;
              }
            } else { //Added block
            if (n != len___0) {
              if (abbrev) {
                mpp = & mp->m_next;
                goto __Cont;
              }
              if ((unsigned long )ambig != (unsigned long )((void *)0)) {
                *ambig = p___0;
              }
              retval = 3;
              goto theend;
            } else {
              mp->m_mode &= ~ mode;
              if (mp->m_mode == 0) {
                if (! did_it) {
                  {
                  newstr = vim_strsave(arg);
                  }
                  if ((unsigned long )newstr == (unsigned long )((void *)0)) {
                    retval = 4;
                    goto theend;
                  }
                  {
                  vim_free((void *)mp->m_str);
                  mp->m_str = newstr;
                  mp->m_noremap = maptype;
                  mp->m_mode = mode;
                  did_it = 1;
                  }
                }
              }
            }
            }
            }
            if (mp->m_mode == 0) {
              {
              map_free(mpp);
              }
              goto __Cont;
            }
            if (mp->m_mode & 7) {
              new_hash = (int )*(mp->m_keys + 0);
            } else {
              new_hash = (int )*(mp->m_keys + 0) ^ 128;
            }
            if (! abbrev) {
              if (new_hash != hash) {
                *mpp = mp->m_next;
                mp->m_next = maphash[new_hash];
                maphash[new_hash] = mp;
                goto __Cont;
              }
            }
          }
        }
        mpp = & mp->m_next;
        __Cont: 
        mp = *mpp;
      }
      while_break___4: /* CIL Label */ ;
      }
      hash ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    round ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  if (maptype == 1) {
    if (! did_it) {
      retval = 2;
    }
    goto theend;
  }
  if (! haskey) {
    goto _L___1;
  } else { //Added block
  if (! hasarg) {
    _L___1: 
    if (! did_it) {
      if (abbrev) {
        {
        msg((char_u *)"No abbreviation found");
        }
      } else {
        {
        msg((char_u *)"No mapping found");
        }
      }
    }
    goto theend;
  }
  }
  if (did_it) {
    goto theend;
  }
  {
  tmp___9 = alloc((unsigned int )sizeof(struct mapblock ));
  mp = (struct mapblock *)tmp___9;
  }
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
    retval = 4;
    goto theend;
  }
  {
  mp->m_keys = vim_strsave(keys___0);
  mp->m_str = vim_strsave(arg);
  }
  if ((unsigned long )mp->m_keys == (unsigned long )((void *)0)) {
    {
    vim_free((void *)mp->m_keys);
    vim_free((void *)mp->m_str);
    vim_free((void *)mp);
    retval = 4;
    }
    goto theend;
  } else { //Added block
  if ((unsigned long )mp->m_str == (unsigned long )((void *)0)) {
    {
    vim_free((void *)mp->m_keys);
    vim_free((void *)mp->m_str);
    vim_free((void *)mp);
    retval = 4;
    }
    goto theend;
  }
  }
  {
  tmp___10 = strlen((char const   *)((char *)mp->m_keys));
  mp->m_keylen = (int )tmp___10;
  mp->m_noremap = maptype;
  mp->m_mode = mode;
  }
  if (abbrev) {
    mp->m_next = first_abbr;
    first_abbr = mp;
  } else {
    if (mp->m_mode & 7) {
      n = (int )*(mp->m_keys + 0);
    } else {
      n = (int )*(mp->m_keys + 0) ^ 128;
    }
    mp->m_next = maphash[n];
    maphash[n] = mp;
  }
  theend: 
  {
  vim_free((void *)keys_buf);
  vim_free((void *)arg_buf);
  }
  return (retval);
}
}
static void map_free(struct mapblock **mpp ) 
{ 
  struct mapblock *mp ;

  {
  {
  mp = *mpp;
  vim_free((void *)mp->m_keys);
  vim_free((void *)mp->m_str);
  *mpp = mp->m_next;
  vim_free((void *)mp);
  }
  return;
}
}
static void validate_maphash(void) 
{ 


  {
  if (! maphash_valid) {
    {
    memset((void *)(maphash), 0, sizeof(maphash));
    maphash_valid = 1;
    }
  }
  return;
}
}
int get_map_mode(char_u **cmdp , int forceit ) 
{ 
  char_u *p___0 ;
  int modec ;
  int mode ;
  char_u *tmp ;

  {
  p___0 = *cmdp;
  tmp = p___0;
  p___0 ++;
  modec = (int )*tmp;
  if (modec == 105) {
    mode = 16;
  } else { //Added block
  if (modec == 99) {
    mode = 8;
  } else { //Added block
  if (modec == 110) {
    if ((int )*p___0 != 111) {
      mode = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (modec == 118) {
    mode = 2;
  } else { //Added block
  if (modec == 111) {
    mode = 4;
  } else {
    p___0 --;
    if (forceit) {
      mode = 24;
    } else {
      mode = 7;
    }
  }
  }
  }
  }
  }
  *cmdp = p___0;
  return (mode);
}
}
void map_clear(char_u *cmdp , int forceit , int abbr ) 
{ 
  struct mapblock *mp ;
  struct mapblock **mpp ;
  int mode ;
  int hash ;
  int new_hash ;

  {
  {
  validate_maphash();
  mode = get_map_mode(& cmdp, forceit);
  hash = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (hash < 256)) {
      goto while_break;
    }
    if (abbr) {
      if (hash) {
        goto while_break;
      }
      mpp = & first_abbr;
    } else {
      mpp = & maphash[hash];
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )*mpp != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      mp = *mpp;
      if (mp->m_mode & mode) {
        mp->m_mode &= ~ mode;
        if (mp->m_mode == 0) {
          {
          map_free(mpp);
          }
          goto while_continue___0;
        }
        if (mp->m_mode & 7) {
          new_hash = (int )*(mp->m_keys + 0);
        } else {
          new_hash = (int )*(mp->m_keys + 0) ^ 128;
        }
        if (! abbr) {
          if (new_hash != hash) {
            *mpp = mp->m_next;
            mp->m_next = maphash[new_hash];
            maphash[new_hash] = mp;
            goto while_continue___0;
          }
        }
      }
      mpp = & mp->m_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    hash ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void showmap(struct mapblock *mp ) 
{ 
  int len___0 ;

  {
  len___0 = 1;
  if (msg_didout) {
    {
    msg_putchar('\n');
    }
  }
  if ((mp->m_mode & 24) == 24) {
    {
    msg_putchar('!');
    }
  } else { //Added block
  if (mp->m_mode & 16) {
    {
    msg_putchar('i');
    }
  } else { //Added block
  if (mp->m_mode & 8) {
    {
    msg_putchar('c');
    }
  } else { //Added block
  if ((mp->m_mode & 7) == 7) {
    {
    msg_putchar(' ');
    }
  } else {
    len___0 = 0;
    if (mp->m_mode & 1) {
      {
      msg_putchar('n');
      len___0 ++;
      }
    }
    if (mp->m_mode & 4) {
      {
      msg_putchar('o');
      len___0 ++;
      }
    }
    if (mp->m_mode & 2) {
      {
      msg_putchar('v');
      len___0 ++;
      }
    }
  }
  }
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    len___0 ++;
    if (! (len___0 <= 3)) {
      goto while_break;
    }
    {
    msg_putchar(' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  len___0 = msg_outtrans_special(mp->m_keys, 1);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    msg_putchar(' ');
    len___0 ++;
    }
    if (! (len___0 < 12)) {
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (mp->m_noremap) {
    {
    msg_puts_attr((char_u *)"*", highlight_attr[0]);
    }
  } else {
    {
    msg_putchar(' ');
    }
  }
  if ((int )*(mp->m_str) == 0) {
    {
    msg_puts_attr((char_u *)"<Nop>", highlight_attr[0]);
    }
  } else {
    {
    msg_outtrans_special(mp->m_str, 0);
    }
  }
  {
  out_flush();
  }
  return;
}
}
static int expand_mapmodes  =    0;
static int expand_isabbrev  =    0;
char_u *set_context_in_map_cmd(char_u *cmd , char_u *arg , int forceit , int isabbrev ,
                               int isunmap , CMDIDX cmdidx ) 
{ 
  int tmp ;

  {
  if (forceit) {
    if ((int )cmdidx != 133) {
      if ((int )cmdidx != 258) {
        expand_context = 0;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (isunmap) {
      if (forceit) {
        tmp = 1;
      } else { //Added block
      if (isabbrev) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      }
      {
      expand_mapmodes = get_map_mode(& cmd, tmp);
      }
    } else {
      expand_mapmodes = 24;
      if (! isabbrev) {
        expand_mapmodes += 7;
      }
    }
    expand_isabbrev = isabbrev;
    expand_context = 16;
    expand_pattern = arg;
  }
  return ((char_u *)((void *)0));
}
}
static int compare_mkeys(void const   *s1 , void const   *s2 ) ;
static int compare_mkeys(void const   *s1 , void const   *s2 ) 
{ 
  int tmp ;

  {
  {
  tmp = strcmp((char const   *)*((char **)s1), (char const   *)*((char **)s2));
  }
  return (tmp);
}
}
int ExpandMappings(vim_regexp *prog , int *num_file , char_u ***file ) 
{ 
  struct mapblock *mp ;
  int hash ;
  int count___2 ;
  int round ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u **ptr1 ;
  char_u **ptr2 ;
  char_u **ptr3 ;
  char_u **tmp___2 ;
  char_u **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  validate_maphash();
  *num_file = 0;
  *file = (char_u **)((void *)0);
  round = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (round <= 2)) {
      goto while_break;
    }
    count___2 = 0;
    hash = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (hash < 256)) {
        goto while_break___0;
      }
      if (expand_isabbrev) {
        if (hash) {
          goto while_break___0;
        }
        mp = first_abbr;
      } else {
        mp = maphash[hash];
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! mp) {
          goto while_break___1;
        }
        if (mp->m_mode & expand_mapmodes) {
          {
          p___0 = translate_mapping(mp->m_keys, 1);
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            tmp___0 = vim_regexec(prog, p___0, 1);
            }
            if (tmp___0) {
              if (round == 1) {
                count___2 ++;
              } else {
                tmp = count___2;
                count___2 ++;
                *(*file + tmp) = p___0;
                p___0 = (char_u *)((void *)0);
              }
            }
          }
          {
          vim_free((void *)p___0);
          }
        }
        mp = mp->m_next;
      }
      while_break___1: /* CIL Label */ ;
      }
      hash ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (count___2 == 0) {
      goto while_break;
    }
    if (round == 1) {
      {
      tmp___1 = alloc((unsigned int )((unsigned long )count___2 * sizeof(char_u *)));
      *file = (char_u **)tmp___1;
      }
      if ((unsigned long )*file == (unsigned long )((void *)0)) {
        {
        vim_free((void *)prog);
        }
        return (0);
      }
    }
    round ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  qsort((void *)*file, (size_t )count___2, sizeof(char_u *), & compare_mkeys);
  ptr1 = *file;
  ptr2 = ptr1 + 1;
  ptr3 = ptr1 + count___2;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! ((unsigned long )ptr2 < (unsigned long )ptr3)) {
      goto while_break___2;
    }
    {
    tmp___4 = strcmp((char const   *)((char *)*ptr1), (char const   *)((char *)*ptr2));
    }
    if (tmp___4) {
      ptr1 ++;
      tmp___2 = ptr2;
      ptr2 ++;
      *ptr1 = *tmp___2;
    } else {
      {
      tmp___3 = ptr2;
      ptr2 ++;
      vim_free((void *)*tmp___3);
      count___2 --;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  *num_file = count___2;
  if (count___2 == 0) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  return (tmp___5);
}
}
int check_abbr(int c , char_u *ptr , int col , int mincol ) 
{ 
  int len___0 ;
  int j ;
  char_u tb[4] ;
  struct mapblock *mp ;
  int is_id ;
  int vim_abbr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
  is_id = 1;
  if (no_abbr_cnt) {
    return (0);
  }
  if (col == 0) {
    return (0);
  }
  {
  tmp = vim_iswordc((int )*(ptr + (col - 1)));
  }
  if (tmp) {
    vim_abbr = 0;
    if (col > 1) {
      {
      is_id = vim_iswordc((int )*(ptr + (col - 2)));
      }
    }
  } else {
    vim_abbr = 1;
  }
  len___0 = col - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (len___0 > 0) {
      {
      tmp___0 = vim_isspace((int )*(ptr + (len___0 - 1)));
      }
      if (tmp___0) {
        goto while_break;
      } else { //Added block
      if (! vim_abbr) {
        {
        tmp___1 = vim_iswordc((int )*(ptr + (len___0 - 1)));
        }
        if (! (is_id == tmp___1)) {
          goto while_break;
        }
      }
      }
    } else {
      goto while_break;
    }
    len___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  if (len___0 < mincol) {
    len___0 = mincol;
  }
  if (len___0 < col) {
    ptr += len___0;
    len___0 = col - len___0;
    mp = first_abbr;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! mp) {
        goto while_break___0;
      }
      if (mp->m_mode & State) {
        if (mp->m_keylen == len___0) {
          {
          tmp___2 = strncmp((char const   *)((char *)mp->m_keys), (char const   *)((char *)ptr),
                            (size_t )len___0);
          }
          if (! tmp___2) {
            goto while_break___0;
          }
        }
      }
      mp = mp->m_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (mp) {
      j = 0;
      if (c != 29) {
        if (c >= 512) {
          goto _L;
        } else { //Added block
        if (c == 128) {
          _L: 
          tmp___3 = j;
          j ++;
          tb[tmp___3] = (char_u )128;
          tmp___4 = j;
          j ++;
          if (c == 128) {
            tb[tmp___4] = (char_u )254;
          } else {
            if (c == 0) {
              tmp___5 = 255;
            } else {
              tmp___5 = c & 255;
            }
            tb[tmp___4] = (char_u )tmp___5;
          }
          if (c == 128) {
            c = 'X';
          } else { //Added block
          if (c == 0) {
            c = 'X';
          } else {
            c = (int )(((unsigned int )c >> 8) & 255U);
          }
          }
        } else { //Added block
        if (c < 256) {
          if (c < 32) {
            tmp___6 = j;
            j ++;
            tb[tmp___6] = (char_u )22;
          } else { //Added block
          if (c > 126) {
            tmp___6 = j;
            j ++;
            tb[tmp___6] = (char_u )22;
          }
          }
        }
        }
        }
        {
        tmp___7 = j;
        j ++;
        tb[tmp___7] = (char_u )c;
        tb[j] = (char_u )'\000';
        ins_typebuf(tb, 1, 0, 1);
        }
      }
      if (mp->m_noremap) {
        tmp___8 = -1;
      } else {
        tmp___8 = 0;
      }
      {
      ins_typebuf(mp->m_str, tmp___8, 0, 1);
      tmp___9 = strlen((char const   *)((char *)mp->m_str));
      no_abbr_cnt = (int )((size_t )no_abbr_cnt + ((tmp___9 + (size_t )j) + 1UL));
      tb[0] = (char_u )8;
      tb[1] = (char_u )'\000';
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        tmp___10 = len___0;
        len___0 --;
        if (! tmp___10) {
          goto while_break___1;
        }
        {
        ins_typebuf(tb, 1, 0, 1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      return (1);
    }
  }
  return (0);
}
}
int makemap(FILE *fd ) 
{ 
  struct mapblock *mp ;
  char_u c1 ;
  char_u c2 ;
  char_u *p___0 ;
  char *cmd ;
  int abbr ;
  int hash ;
  int did_cpo ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
  did_cpo = 0;
  validate_maphash();
  abbr = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (abbr < 2)) {
      goto while_break;
    }
    hash = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (hash < 256)) {
        goto while_break___0;
      }
      if (abbr) {
        if (hash) {
          goto while_break___0;
        }
        mp = first_abbr;
      } else {
        mp = maphash[hash];
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! mp) {
          goto while_break___1;
        }
        c1 = (char_u )'\000';
        c2 = (char_u )'\000';
        if (abbr) {
          cmd = (char *)"abbr";
        } else {
          cmd = (char *)"map";
        }
        {
        if (mp->m_mode == 7) {
          goto case_7;
        }
        if (mp->m_mode == 1) {
          goto case_1;
        }
        if (mp->m_mode == 2) {
          goto case_2;
        }
        if (mp->m_mode == 4) {
          goto case_4;
        }
        if (mp->m_mode == 3) {
          goto case_3;
        }
        if (mp->m_mode == 6) {
          goto case_6;
        }
        if (mp->m_mode == 5) {
          goto case_5;
        }
        if (mp->m_mode == 24) {
          goto case_24;
        }
        if (mp->m_mode == 8) {
          goto case_8;
        }
        if (mp->m_mode == 16) {
          goto case_16;
        }
        goto switch_default;
        case_7: /* CIL Label */ 
        goto switch_break;
        case_1: /* CIL Label */ 
        c1 = (char_u )'n';
        goto switch_break;
        case_2: /* CIL Label */ 
        c1 = (char_u )'v';
        goto switch_break;
        case_4: /* CIL Label */ 
        c1 = (char_u )'o';
        goto switch_break;
        case_3: /* CIL Label */ 
        c1 = (char_u )'n';
        c2 = (char_u )'v';
        goto switch_break;
        case_6: /* CIL Label */ 
        c1 = (char_u )'v';
        c2 = (char_u )'o';
        goto switch_break;
        case_5: /* CIL Label */ 
        c1 = (char_u )'n';
        c2 = (char_u )'o';
        goto switch_break;
        case_24: /* CIL Label */ 
        if (! abbr) {
          cmd = (char *)"map!";
        }
        goto switch_break;
        case_8: /* CIL Label */ 
        c1 = (char_u )'c';
        goto switch_break;
        case_16: /* CIL Label */ 
        c1 = (char_u )'i';
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
        emsg((char_u *)"makemap: Illegal mode");
        }
        return (0);
        switch_break: /* CIL Label */ ;
        }
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! did_cpo) {
            if ((int )*(mp->m_str) == 0) {
              did_cpo = 1;
            } else {
              i___0 = 0;
              {
              while (1) {
                while_continue___3: /* CIL Label */ ;
                if (! (i___0 < 2)) {
                  goto while_break___3;
                }
                if (i___0) {
                  p___0 = mp->m_str;
                } else {
                  p___0 = mp->m_keys;
                }
                {
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  if (! *p___0) {
                    goto while_break___4;
                  }
                  if ((int )*p___0 == 128) {
                    did_cpo = 1;
                  } else { //Added block
                  if ((int )*p___0 == 10) {
                    did_cpo = 1;
                  }
                  }
                  p___0 ++;
                }
                while_break___4: /* CIL Label */ ;
                }
                i___0 ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
            if (did_cpo) {
              {
              tmp = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"let cpo_save=&cpo");
              }
              if (tmp < 0) {
                return (0);
              } else {
                {
                tmp___0 = put_eol(fd);
                }
                if (tmp___0 < 0) {
                  return (0);
                } else {
                  {
                  tmp___1 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"set cpo=B");
                  }
                  if (tmp___1 < 0) {
                    return (0);
                  } else {
                    {
                    tmp___2 = put_eol(fd);
                    }
                    if (tmp___2 < 0) {
                      return (0);
                    }
                  }
                }
              }
            }
          }
          if (c1) {
            {
            tmp___3 = _IO_putc((int )c1, fd);
            }
            if (tmp___3 < 0) {
              return (0);
            }
          }
          if (mp->m_noremap) {
            {
            tmp___4 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"nore");
            }
            if (tmp___4 < 0) {
              return (0);
            }
          }
          {
          tmp___5 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )cmd);
          }
          if (tmp___5 < 0) {
            return (0);
          }
          {
          tmp___6 = _IO_putc(' ', fd);
          }
          if (tmp___6 < 0) {
            return (0);
          } else {
            {
            tmp___7 = putescstr(fd, mp->m_keys, 0);
            }
            if (tmp___7 == 0) {
              return (0);
            } else {
              {
              tmp___8 = _IO_putc(' ', fd);
              }
              if (tmp___8 < 0) {
                return (0);
              } else {
                {
                tmp___9 = putescstr(fd, mp->m_str, 0);
                }
                if (tmp___9 == 0) {
                  return (0);
                } else {
                  {
                  tmp___10 = put_eol(fd);
                  }
                  if (tmp___10 < 0) {
                    return (0);
                  }
                }
              }
            }
          }
          c1 = c2;
          c2 = (char_u )'\000';
          if (! c1) {
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        mp = mp->m_next;
      }
      while_break___1: /* CIL Label */ ;
      }
      hash ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    abbr ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (did_cpo) {
    {
    tmp___11 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"let &cpo=cpo_save");
    }
    if (tmp___11 < 0) {
      return (0);
    } else {
      {
      tmp___12 = put_eol(fd);
      }
      if (tmp___12 < 0) {
        return (0);
      } else {
        {
        tmp___13 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"unlet cpo_save");
        }
        if (tmp___13 < 0) {
          return (0);
        } else {
          {
          tmp___14 = put_eol(fd);
          }
          if (tmp___14 < 0) {
            return (0);
          }
        }
      }
    }
  }
  return (1);
}
}
int putescstr(FILE *fd , char_u *str___1 , int set ) 
{ 
  int c ;
  int modifiers ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((int )*str___1 == 0) {
    if (! set) {
      {
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"<Nop>");
      }
      return (1);
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *str___1) {
      goto while_break;
    }
    c = (int )*str___1;
    if (c == 128) {
      if (! set) {
        modifiers = 0;
        if ((int )*(str___1 + 1) == 252) {
          modifiers = (int )*(str___1 + 2);
          str___1 += 3;
          c = (int )*str___1;
        }
        if (c == 128) {
          if ((int )*(str___1 + 1) == 254) {
            c = 128;
          } else {
            if ((int )*(str___1 + 1) == 255) {
              tmp = 255 + (88 << 8);
            } else {
              tmp = (int )*(str___1 + 1) + ((int )*(str___1 + 2) << 8);
            }
            c = tmp;
          }
          str___1 += 2;
        }
        if (c >= 512) {
          {
          tmp___0 = get_special_key_name(c, modifiers);
          fprintf((FILE * __restrict  )fd, (char const   * __restrict  )((char *)tmp___0));
          }
          goto __Cont;
        } else { //Added block
        if (modifiers) {
          {
          tmp___0 = get_special_key_name(c, modifiers);
          fprintf((FILE * __restrict  )fd, (char const   * __restrict  )((char *)tmp___0));
          }
          goto __Cont;
        }
        }
      }
    }
    if (c == 10) {
      if (set) {
        {
        fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\\\026\n");
        }
      } else {
        {
        fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"<NL>");
        }
      }
      goto __Cont;
    }
    if (set) {
      if (c == 32) {
        goto _L___1;
      } else { //Added block
      if (c == 9) {
        goto _L___1;
      } else { //Added block
      if (c == 34) {
        goto _L___1;
      } else { //Added block
      if (c == 92) {
        _L___1: 
        {
        tmp___1 = _IO_putc('\\', fd);
        }
        if (tmp___1 < 0) {
          return (0);
        }
      } else {
        goto _L___0;
      }
      }
      }
      }
    } else { //Added block
    _L___0: 
    if (c < 32) {
      goto _L;
    } else { //Added block
    if (c > 126) {
      goto _L;
    } else { //Added block
    if (c == 124) {
      goto _L;
    } else { //Added block
    if (! set) {
      if (c == 60) {
        _L: 
        {
        tmp___2 = _IO_putc(22, fd);
        }
        if (tmp___2 < 0) {
          return (0);
        }
      }
    }
    }
    }
    }
    }
    {
    tmp___3 = _IO_putc(c, fd);
    }
    if (tmp___3 < 0) {
      return (0);
    }
    __Cont: 
    str___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
void check_map_keycodes(void) 
{ 
  struct mapblock *mp ;
  char_u *p___0 ;
  int i___0 ;
  char_u buf___3[3] ;
  char_u *save_name ;
  int abbr ;
  int hash ;

  {
  {
  validate_maphash();
  save_name = sourcing_name;
  sourcing_name = (char_u *)"mappings";
  abbr = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (abbr < 2)) {
      goto while_break;
    }
    hash = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (hash < 256)) {
        goto while_break___0;
      }
      if (abbr) {
        if (hash) {
          goto while_break___0;
        }
        mp = first_abbr;
      } else {
        mp = maphash[hash];
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
          goto while_break___1;
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (i___0 <= 1)) {
            goto while_break___2;
          }
          if (i___0 == 0) {
            p___0 = mp->m_keys;
          } else {
            p___0 = mp->m_str;
          }
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if (! *p___0) {
              goto while_break___3;
            }
            if ((int )*p___0 == 128) {
              p___0 ++;
              if ((int )*p___0 < 128) {
                {
                buf___3[0] = *(p___0 + 0);
                buf___3[1] = *(p___0 + 1);
                buf___3[2] = (char_u )'\000';
                add_termcap_entry(buf___3, 0);
                }
              }
              p___0 ++;
            }
            p___0 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        mp = mp->m_next;
      }
      while_break___1: /* CIL Label */ ;
      }
      hash ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    abbr ++;
  }
  while_break: /* CIL Label */ ;
  }
  sourcing_name = save_name;
  return;
}
}
char_u *check_map(char_u *keys___0 , int mode , int exact ) 
{ 
  int hash ;
  int len___0 ;
  int minlen ;
  struct mapblock *mp ;
  struct mapblock **mpp ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  validate_maphash();
  tmp = strlen((char const   *)((char *)keys___0));
  len___0 = (int )tmp;
  hash = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (hash < 256)) {
      goto while_break;
    }
    mpp = & maphash[hash];
    mp = *mpp;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      if (mp->m_keylen < len___0) {
        minlen = mp->m_keylen;
      } else {
        minlen = len___0;
      }
      if (mp->m_mode & mode) {
        if (! exact) {
          goto _L;
        } else { //Added block
        if (mp->m_keylen == len___0) {
          _L: 
          {
          tmp___0 = strncmp((char const   *)((char *)mp->m_keys), (char const   *)((char *)keys___0),
                            (size_t )minlen);
          }
          if (tmp___0 == 0) {
            return (mp->m_str);
          }
        }
        }
      }
      mpp = & mp->m_next;
      mp = *mpp;
    }
    while_break___0: /* CIL Label */ ;
    }
    hash ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
static struct initmap initmappings[20]  = 
  {      {(char_u *)"<xF1> <F1>", 7}, 
        {(char_u *)"<xF1> <F1>", 24}, 
        {(char_u *)"<xF2> <F2>", 7}, 
        {(char_u *)"<xF2> <F2>", 24}, 
        {(char_u *)"<xF3> <F3>", 7}, 
        {(char_u *)"<xF3> <F3>", 24}, 
        {(char_u *)"<xF4> <F4>", 7}, 
        {(char_u *)"<xF4> <F4>", 24}, 
        {(char_u *)"<S-xF1> <S-F1>", 7}, 
        {(char_u *)"<S-xF1> <S-F1>", 24}, 
        {(char_u *)"<S-xF2> <S-F2>", 7}, 
        {(char_u *)"<S-xF2> <S-F2>", 24}, 
        {(char_u *)"<S-xF3> <S-F3>", 7}, 
        {(char_u *)"<S-xF3> <S-F3>", 24}, 
        {(char_u *)"<S-xF4> <S-F4>", 7}, 
        {(char_u *)"<S-xF4> <S-F4>", 24}, 
        {(char_u *)"<xEND> <END>", 7}, 
        {(char_u *)"<xEND> <END>", 24}, 
        {(char_u *)"<xHOME> <HOME>", 7}, 
        {(char_u *)"<xHOME> <HOME>", 24}};
void init_mappings(void) 
{ 
  char_u *cpo_save ;
  int i___0 ;
  char_u *s ;

  {
  cpo_save = p_cpo;
  p_cpo = (char_u *)"";
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )i___0 < sizeof(initmappings) / sizeof(struct initmap ))) {
      goto while_break;
    }
    {
    s = vim_strsave(initmappings[i___0].arg);
    }
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
      do_map(0, s, initmappings[i___0].mode, 0, (char_u **)((void *)0));
      vim_free((void *)s);
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  p_cpo = cpo_save;
  return;
}
}
#pragma merger("0","/tmp/cil-lsfeYdVO.i","-O0")
#pragma merger("0","/tmp/cil-Woe45Uju.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
long Rows  =    2L;
long Columns  =    12L;
char_u *NextScreen  =    (char_u *)((void *)0);
char_u **LinePointers  =    (char_u **)((void *)0);
int screen_Rows  =    0;
int screen_Columns  =    0;
int mod_mask  =    0;
int redraw_cmdline  =    0;
int clear_cmdline  =    0;
int cmdline_crypt  =    0;
int exec_from_reg  =    0;
int modified  =    0;
int tag_modified  =    0;
int screen_cleared  =    0;
colnr_t dollar_vcol  =    (colnr_t )0;
int expand_context  =    -2;
char_u *expand_pattern  =    (char_u *)((void *)0);
int expand_set_path  =    0;
int completion_length  =    0;
int continue_status  =    0;
int completion_interrupted  =    0;
char_u *keep_msg  =    (char_u *)((void *)0);
int keep_msg_attr  =    0;
int need_fileinfo  =    0;
int msg_scroll  =    0;
int msg_didout  =    0;
int msg_didany  =    0;
int msg_nowait  =    0;
int emsg_off  =    0;
int emsg_on_display  =    0;
int rc_did_emsg  =    0;
int no_wait_return  =    0;
int need_wait_return  =    0;
int quit_more  =    0;
int more_back  =    0;
int more_back_used  =    0;
int newline_on_exit  =    0;
int intr_char  =    0;
int vgetc_busy  =    0;
int didset_vim  =    0;
int didset_vimruntime  =    0;
int lines_left  =    -1;
int msg_no_more  =    0;
char_u *sourcing_name  =    (char_u *)((void *)0);
linenr_t sourcing_lnum  =    (linenr_t )0;
int scroll_region  =    0;
int highlight_match  =    0;
int no_smartcase  =    0;
int need_check_timestamps  =    0;
int highlight_user[9]  ;
int highlight_stlnc[9]  ;
int cterm_normal_fg_color  =    0;
int cterm_normal_fg_bold  =    0;
int cterm_normal_bg_color  =    0;
int autocmd_busy  =    0;
int autocmd_no_enter  =    0;
int autocmd_no_leave  =    0;
int did_filetype  =    0;
BUF *au_new_curbuf  =    (BUF *)((void *)0);
int mouse_past_bottom  =    0;
int mouse_past_eol  =    0;
int mouse_dragging  =    0;
VimMenu *root_menu  =    (VimMenu *)((void *)0);
int sys_menu  =    0;
VimClipboard clipboard  ;
BUF *firstbuf  =    (BUF *)((void *)0);
BUF *lastbuf  =    (BUF *)((void *)0);
BUF *curbuf  =    (BUF *)((void *)0);
int arg_had_last  =    0;
int ru_col  ;
int ru_wid  ;
int starting  =    2;
int exiting  =    0;
int full_screen  =    0;
int restricted  =    0;
int secure  =    0;
int sandbox  =    0;
int silent_mode  =    0;
int VIsual_active  =    0;
int VIsual_select  =    0;
int VIsual_mode  =    'v';
int redo_VIsual_busy  =    0;
int did_ai  =    0;
colnr_t ai_col  =    (colnr_t )0;
int end_comment_pending  =    '\000';
int did_syncbind  =    0;
int did_si  =    0;
int can_si  =    0;
int can_si_back  =    0;
int orig_line_count  =    0;
int vr_lines_changed  =    0;
colnr_t vr_virtcol  =    (colnr_t )2147483647;
int vr_virtoffset  =    0;
int State  =    1;
int exmode_active  =    0;
int ex_no_reprint  =    0;
int Recording  =    0;
int Exec_reg  =    0;
int finish_op  =    0;
int no_mapping  =    0;
int allow_keys  =    0;
int no_u_sync  =    0;
int restart_edit  =    0;
char_u *edit_submode  =    (char_u *)((void *)0);
char_u *edit_submode_extra  =    (char_u *)((void *)0);
int ctrl_x_mode  =    0;
int no_abbr  =    1;
int fo_do_comments  =    0;
int confirm  =    0;
int swap_exists_action  =    0;
int RedrawingDisabled  =    0;
int readonlymode  =    0;
int recoverymode  =    0;
char_u *typebuf  =    (char_u *)((void *)0);
int maptick  =    0;
int must_redraw  =    0;
int skip_redraw  =    0;
int do_redraw  =    0;
int need_highlight_changed  =    1;
char_u *use_viminfo  =    (char_u *)((void *)0);
int curscript  =    0;
FILE *scriptout  =    (FILE *)((void *)0);
int read_cmd_fd  =    0;
int got_int  =    0;
int termcap_active  =    0;
int bangredo  =    0;
int reg_ic  =    0;
int reg_syn  =    0;
int did_outofmem_msg  =    0;
int did_swapwrite_msg  =    0;
int undo_off  =    0;
int global_busy  =    0;
int need_start_insertmode  =    0;
char_u *last_cmdline  =    (char_u *)((void *)0);
char_u *new_last_cmdline  =    (char_u *)((void *)0);
char_u *autocmd_fname  =    (char_u *)((void *)0);
int autocmd_bufnr  =    0;
char_u *autocmd_match  =    (char_u *)((void *)0);
int postponed_split  =    0;
int g_do_tagpreview  =    0;
int replace_offset  =    0;
char_u *escape_chars  =    (char_u *)" \t\\\"|";
char_u *help_save_isk  =    (char_u *)((void *)0);
long help_save_ts  =    0L;
int keep_help_flag  =    0;
char_u *empty_option  =    (char_u *)"";
int redir_off  =    0;
FILE *redir_fd  =    (FILE *)((void *)0);
int redir_reg  =    0;
int save_p_ls  =    -1;
int wild_menu_showing  =    0;
char *longVersion ;
int lcs_eol  =    '$';
int lcs_ext  =    '\000';
int lcs_tab1  =    '\000';
int lcs_tab2  =    '\000';
int lcs_trail  =    '\000';
char_u no_lines_msg[23]  = 
  {      (char_u )'-',      (char_u )'-',      (char_u )'N',      (char_u )'o', 
        (char_u )' ',      (char_u )'l',      (char_u )'i',      (char_u )'n', 
        (char_u )'e',      (char_u )'s',      (char_u )' ',      (char_u )'i', 
        (char_u )'n',      (char_u )' ',      (char_u )'b',      (char_u )'u', 
        (char_u )'f',      (char_u )'f',      (char_u )'e',      (char_u )'r', 
        (char_u )'-',      (char_u )'-',      (char_u )'\000'};
int stl_syntax  =    0;
int no_hlsearch  =    0;
char *xterm_display  =    (char *)((void *)0);
Display *xterm_dpy  =    (Display *)((void *)0);
XtAppContext app_context  =    (XtAppContext )((void *)0);
char_u e_abort[16]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'b',      (char_u )'o',      (char_u )'r', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_argreq[18]  = 
  {      (char_u )'A',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )' ',      (char_u )'r',      (char_u )'e',      (char_u )'q', 
        (char_u )'u',      (char_u )'i',      (char_u )'r',      (char_u )'e', 
        (char_u )'d',      (char_u )'\000'};
char_u e_backslash[34]  = 
  {      (char_u )'\\',      (char_u )' ',      (char_u )'s',      (char_u )'h', 
        (char_u )'o',      (char_u )'u',      (char_u )'l',      (char_u )'d', 
        (char_u )' ',      (char_u )'b',      (char_u )'e',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )' ',      (char_u )'b',      (char_u )'y',      (char_u )' ', 
        (char_u )'/',      (char_u )',',      (char_u )' ',      (char_u )'?', 
        (char_u )' ',      (char_u )'o',      (char_u )'r',      (char_u )' ', 
        (char_u )'&',      (char_u )'\000'};
char_u e_curdir[65]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'a',      (char_u )'l',      (char_u )'l',      (char_u )'o', 
        (char_u )'w',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'f',      (char_u )'r',      (char_u )'o',      (char_u )'m', 
        (char_u )' ',      (char_u )'e',      (char_u )'x',      (char_u )'r', 
        (char_u )'c',      (char_u )'/',      (char_u )'v',      (char_u )'i', 
        (char_u )'m',      (char_u )'r',      (char_u )'c',      (char_u )' ', 
        (char_u )'i',      (char_u )'n',      (char_u )' ',      (char_u )'c', 
        (char_u )'u',      (char_u )'r',      (char_u )'r',      (char_u )'e', 
        (char_u )'n',      (char_u )'t',      (char_u )' ',      (char_u )'d', 
        (char_u )'i',      (char_u )'r',      (char_u )' ',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'t',      (char_u )'a', 
        (char_u )'g',      (char_u )' ',      (char_u )'s',      (char_u )'e', 
        (char_u )'a',      (char_u )'r',      (char_u )'c',      (char_u )'h', 
        (char_u )'\000'};
char_u e_exists[32]  = 
  {      (char_u )'F',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'e',      (char_u )'x',      (char_u )'i', 
        (char_u )'s',      (char_u )'t',      (char_u )'s',      (char_u )' ', 
        (char_u )'(',      (char_u )'u',      (char_u )'s',      (char_u )'e', 
        (char_u )' ',      (char_u )'!',      (char_u )' ',      (char_u )'t', 
        (char_u )'o',      (char_u )' ',      (char_u )'o',      (char_u )'v', 
        (char_u )'e',      (char_u )'r',      (char_u )'r',      (char_u )'i', 
        (char_u )'d',      (char_u )'e',      (char_u )')',      (char_u )'\000'};
char_u e_failed[15]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'f',      (char_u )'a',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_internal[15]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'t',      (char_u )'e', 
        (char_u )'r',      (char_u )'n',      (char_u )'a',      (char_u )'l', 
        (char_u )' ',      (char_u )'e',      (char_u )'r',      (char_u )'r', 
        (char_u )'o',      (char_u )'r',      (char_u )'\000'};
char_u e_interr[12]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'t',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'u',      (char_u )'p', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_invaddr[16]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'d',      (char_u )'d',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'\000'};
char_u e_invarg[17]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )'\000'};
char_u e_invarg2[21]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )':',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_invexpr2[23]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'e',      (char_u )'x',      (char_u )'p',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'i', 
        (char_u )'o',      (char_u )'n',      (char_u )':',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_invrange[14]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'r',      (char_u )'a',      (char_u )'n',      (char_u )'g', 
        (char_u )'e',      (char_u )'\000'};
char_u e_invcmd[16]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'\000'};
char_u e_letunexp[33]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'e',      (char_u )'x', 
        (char_u )'p',      (char_u )'e',      (char_u )'c',      (char_u )'t', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'c', 
        (char_u )'h',      (char_u )'a',      (char_u )'r',      (char_u )'a', 
        (char_u )'c',      (char_u )'t',      (char_u )'e',      (char_u )'r', 
        (char_u )'s',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )'f',      (char_u )'o',      (char_u )'r',      (char_u )'e', 
        (char_u )' ',      (char_u )'\'',      (char_u )'=',      (char_u )'\'', 
        (char_u )'\000'};
char_u e_markinval[29]  = 
  {      (char_u )'M',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )' ',      (char_u )'h',      (char_u )'a',      (char_u )'s', 
        (char_u )' ',      (char_u )'i',      (char_u )'n',      (char_u )'v', 
        (char_u )'a',      (char_u )'l',      (char_u )'i',      (char_u )'d', 
        (char_u )' ',      (char_u )'l',      (char_u )'i',      (char_u )'n', 
        (char_u )'e',      (char_u )' ',      (char_u )'n',      (char_u )'u', 
        (char_u )'m',      (char_u )'b',      (char_u )'e',      (char_u )'r', 
        (char_u )'\000'};
char_u e_marknotset[13]  = 
  {      (char_u )'M',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )' ',      (char_u )'n',      (char_u )'o',      (char_u )'t', 
        (char_u )' ',      (char_u )'s',      (char_u )'e',      (char_u )'t', 
        (char_u )'\000'};
char_u e_nesting[24]  = 
  {      (char_u )'S',      (char_u )'c',      (char_u )'r',      (char_u )'i', 
        (char_u )'p',      (char_u )'t',      (char_u )'s',      (char_u )' ', 
        (char_u )'n',      (char_u )'e',      (char_u )'s',      (char_u )'t', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'t', 
        (char_u )'o',      (char_u )'o',      (char_u )' ',      (char_u )'d', 
        (char_u )'e',      (char_u )'e',      (char_u )'p',      (char_u )'\000'};
char_u e_noalt[18]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'a', 
        (char_u )'l',      (char_u )'t',      (char_u )'e',      (char_u )'r', 
        (char_u )'n',      (char_u )'a',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'\000'};
char_u e_noabbr[21]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'s', 
        (char_u )'u',      (char_u )'c',      (char_u )'h',      (char_u )' ', 
        (char_u )'a',      (char_u )'b',      (char_u )'b',      (char_u )'r', 
        (char_u )'e',      (char_u )'v',      (char_u )'i',      (char_u )'a', 
        (char_u )'t',      (char_u )'i',      (char_u )'o',      (char_u )'n', 
        (char_u )'\000'};
char_u e_nobang[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'!', 
        (char_u )' ',      (char_u )'a',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )'\000'};
char_u e_nogvim[49]  = 
  {      (char_u )'G',      (char_u )'U',      (char_u )'I',      (char_u )' ', 
        (char_u )'c',      (char_u )'a',      (char_u )'n',      (char_u )'n', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'b', 
        (char_u )'e',      (char_u )' ',      (char_u )'u',      (char_u )'s', 
        (char_u )'e',      (char_u )'d',      (char_u )':',      (char_u )' ', 
        (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'a',      (char_u )'b', 
        (char_u )'l',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'t',      (char_u )' ',      (char_u )'c', 
        (char_u )'o',      (char_u )'m',      (char_u )'p',      (char_u )'i', 
        (char_u )'l',      (char_u )'e',      (char_u )' ',      (char_u )'t', 
        (char_u )'i',      (char_u )'m',      (char_u )'e',      (char_u )'\n', 
        (char_u )'\000'};
char_u e_nohebrew[52]  = 
  {      (char_u )'H',      (char_u )'e',      (char_u )'b',      (char_u )'r', 
        (char_u )'e',      (char_u )'w',      (char_u )' ',      (char_u )'c', 
        (char_u )'a',      (char_u )'n',      (char_u )'n',      (char_u )'o', 
        (char_u )'t',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )' ',      (char_u )'u',      (char_u )'s',      (char_u )'e', 
        (char_u )'d',      (char_u )':',      (char_u )' ',      (char_u )'N', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'e', 
        (char_u )'n',      (char_u )'a',      (char_u )'b',      (char_u )'l', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'a', 
        (char_u )'t',      (char_u )' ',      (char_u )'c',      (char_u )'o', 
        (char_u )'m',      (char_u )'p',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'t',      (char_u )'i', 
        (char_u )'m',      (char_u )'e',      (char_u )'\n',      (char_u )'\000'};
char_u e_nofarsi[51]  = 
  {      (char_u )'F',      (char_u )'a',      (char_u )'r',      (char_u )'s', 
        (char_u )'i',      (char_u )' ',      (char_u )'c',      (char_u )'a', 
        (char_u )'n',      (char_u )'n',      (char_u )'o',      (char_u )'t', 
        (char_u )' ',      (char_u )'b',      (char_u )'e',      (char_u )' ', 
        (char_u )'u',      (char_u )'s',      (char_u )'e',      (char_u )'d', 
        (char_u )':',      (char_u )' ',      (char_u )'N',      (char_u )'o', 
        (char_u )'t',      (char_u )' ',      (char_u )'e',      (char_u )'n', 
        (char_u )'a',      (char_u )'b',      (char_u )'l',      (char_u )'e', 
        (char_u )'d',      (char_u )' ',      (char_u )'a',      (char_u )'t', 
        (char_u )' ',      (char_u )'c',      (char_u )'o',      (char_u )'m', 
        (char_u )'p',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'t',      (char_u )'i',      (char_u )'m', 
        (char_u )'e',      (char_u )'\n',      (char_u )'\000'};
char_u e_noinstext[21]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'i', 
        (char_u )'n',      (char_u )'s',      (char_u )'e',      (char_u )'r', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'t',      (char_u )'e',      (char_u )'x',      (char_u )'t', 
        (char_u )' ',      (char_u )'y',      (char_u )'e',      (char_u )'t', 
        (char_u )'\000'};
char_u e_nolastcmd[25]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'l',      (char_u )'i',      (char_u )'n',      (char_u )'e', 
        (char_u )'\000'};
char_u e_nomap[16]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'s', 
        (char_u )'u',      (char_u )'c',      (char_u )'h',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'p',      (char_u )'p', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )'\000'};
char_u e_nomatch[9]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )'c',      (char_u )'h', 
        (char_u )'\000'};
char_u e_nomatch2[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )'c',      (char_u )'h', 
        (char_u )':',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_noname[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'n',      (char_u )'a',      (char_u )'m',      (char_u )'e', 
        (char_u )'\000'};
char_u e_nopresub[42]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'s',      (char_u )'u',      (char_u )'b',      (char_u )'s', 
        (char_u )'t',      (char_u )'i',      (char_u )'t',      (char_u )'u', 
        (char_u )'t',      (char_u )'e',      (char_u )' ',      (char_u )'r', 
        (char_u )'e',      (char_u )'g',      (char_u )'u',      (char_u )'l', 
        (char_u )'a',      (char_u )'r',      (char_u )' ',      (char_u )'e', 
        (char_u )'x',      (char_u )'p',      (char_u )'r',      (char_u )'e', 
        (char_u )'s',      (char_u )'s',      (char_u )'i',      (char_u )'o', 
        (char_u )'n',      (char_u )'\000'};
char_u e_noprev[20]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'\000'};
char_u e_noprevre[31]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'r',      (char_u )'e',      (char_u )'g',      (char_u )'u', 
        (char_u )'l',      (char_u )'a',      (char_u )'r',      (char_u )' ', 
        (char_u )'e',      (char_u )'x',      (char_u )'p',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'i', 
        (char_u )'o',      (char_u )'n',      (char_u )'\000'};
char_u e_norange[17]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'r', 
        (char_u )'a',      (char_u )'n',      (char_u )'g',      (char_u )'e', 
        (char_u )' ',      (char_u )'a',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )'\000'};
char_u e_noroom[16]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'o',      (char_u )'u', 
        (char_u )'g',      (char_u )'h',      (char_u )' ',      (char_u )'r', 
        (char_u )'o',      (char_u )'o',      (char_u )'m',      (char_u )'\000'};
char_u e_notcreate[21]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'c',      (char_u )'r', 
        (char_u )'e',      (char_u )'a',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_notmp[25]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'g',      (char_u )'e', 
        (char_u )'t',      (char_u )' ',      (char_u )'t',      (char_u )'e', 
        (char_u )'m',      (char_u )'p',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'n',      (char_u )'a',      (char_u )'m',      (char_u )'e', 
        (char_u )'\000'};
char_u e_notopen[19]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'o',      (char_u )'p', 
        (char_u )'e',      (char_u )'n',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_notread[19]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'r',      (char_u )'e', 
        (char_u )'a',      (char_u )'d',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_nowrtmsg[47]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'w', 
        (char_u )'r',      (char_u )'i',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'s',      (char_u )'i',      (char_u )'n', 
        (char_u )'c',      (char_u )'e',      (char_u )' ',      (char_u )'l', 
        (char_u )'a',      (char_u )'s',      (char_u )'t',      (char_u )' ', 
        (char_u )'c',      (char_u )'h',      (char_u )'a',      (char_u )'n', 
        (char_u )'g',      (char_u )'e',      (char_u )' ',      (char_u )'(', 
        (char_u )'u',      (char_u )'s',      (char_u )'e',      (char_u )' ', 
        (char_u )'!',      (char_u )' ',      (char_u )'t',      (char_u )'o', 
        (char_u )' ',      (char_u )'o',      (char_u )'v',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'i',      (char_u )'d', 
        (char_u )'e',      (char_u )')',      (char_u )'\000'};
char_u e_null[14]  = 
  {      (char_u )'N',      (char_u )'u',      (char_u )'l',      (char_u )'l', 
        (char_u )' ',      (char_u )'a',      (char_u )'r',      (char_u )'g', 
        (char_u )'u',      (char_u )'m',      (char_u )'e',      (char_u )'n', 
        (char_u )'t',      (char_u )'\000'};
char_u e_number[16]  = 
  {      (char_u )'N',      (char_u )'u',      (char_u )'m',      (char_u )'b', 
        (char_u )'e',      (char_u )'r',      (char_u )' ',      (char_u )'e', 
        (char_u )'x',      (char_u )'p',      (char_u )'e',      (char_u )'c', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_openerrf[24]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'o',      (char_u )'p', 
        (char_u )'e',      (char_u )'n',      (char_u )' ',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )'f',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_outofmem[15]  = 
  {      (char_u )'O',      (char_u )'u',      (char_u )'t',      (char_u )' ', 
        (char_u )'o',      (char_u )'f',      (char_u )' ',      (char_u )'m', 
        (char_u )'e',      (char_u )'m',      (char_u )'o',      (char_u )'r', 
        (char_u )'y',      (char_u )'!',      (char_u )'\000'};
char_u e_patnotf[18]  = 
  {      (char_u )'P',      (char_u )'a',      (char_u )'t',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'n',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'u',      (char_u )'n', 
        (char_u )'d',      (char_u )'\000'};
char_u e_patnotf2[22]  = 
  {      (char_u )'P',      (char_u )'a',      (char_u )'t',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'n',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'u',      (char_u )'n', 
        (char_u )'d',      (char_u )':',      (char_u )' ',      (char_u )'%', 
        (char_u )'s',      (char_u )'\000'};
char_u e_positive[26]  = 
  {      (char_u )'A',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )' ',      (char_u )'m',      (char_u )'u',      (char_u )'s', 
        (char_u )'t',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )' ',      (char_u )'p',      (char_u )'o',      (char_u )'s', 
        (char_u )'i',      (char_u )'t',      (char_u )'i',      (char_u )'v', 
        (char_u )'e',      (char_u )'\000'};
char_u e_quickfix[10]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'E', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )'s',      (char_u )'\000'};
char_u e_re_damg[21]  = 
  {      (char_u )'D',      (char_u )'a',      (char_u )'m',      (char_u )'a', 
        (char_u )'g',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'t',      (char_u )'c', 
        (char_u )'h',      (char_u )' ',      (char_u )'s',      (char_u )'t', 
        (char_u )'r',      (char_u )'i',      (char_u )'n',      (char_u )'g', 
        (char_u )'\000'};
char_u e_re_corr[25]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'r',      (char_u )'r', 
        (char_u )'u',      (char_u )'p',      (char_u )'t',      (char_u )'e', 
        (char_u )'d',      (char_u )' ',      (char_u )'r',      (char_u )'e', 
        (char_u )'g',      (char_u )'e',      (char_u )'x',      (char_u )'p', 
        (char_u )' ',      (char_u )'p',      (char_u )'r',      (char_u )'o', 
        (char_u )'g',      (char_u )'r',      (char_u )'a',      (char_u )'m', 
        (char_u )'\000'};
char_u e_readonly[45]  = 
  {      (char_u )'\'',      (char_u )'r',      (char_u )'e',      (char_u )'a', 
        (char_u )'d',      (char_u )'o',      (char_u )'n',      (char_u )'l', 
        (char_u )'y',      (char_u )'\'',      (char_u )' ',      (char_u )'o', 
        (char_u )'p',      (char_u )'t',      (char_u )'i',      (char_u )'o', 
        (char_u )'n',      (char_u )' ',      (char_u )'i',      (char_u )'s', 
        (char_u )' ',      (char_u )'s',      (char_u )'e',      (char_u )'t', 
        (char_u )' ',      (char_u )'(',      (char_u )'u',      (char_u )'s', 
        (char_u )'e',      (char_u )' ',      (char_u )'!',      (char_u )' ', 
        (char_u )'t',      (char_u )'o',      (char_u )' ',      (char_u )'o', 
        (char_u )'v',      (char_u )'e',      (char_u )'r',      (char_u )'r', 
        (char_u )'i',      (char_u )'d',      (char_u )'e',      (char_u )')', 
        (char_u )'\000'};
char_u e_readonlyvar[35]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'n', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'s', 
        (char_u )'e',      (char_u )'t',      (char_u )' ',      (char_u )'r', 
        (char_u )'e',      (char_u )'a',      (char_u )'d',      (char_u )'-', 
        (char_u )'o',      (char_u )'n',      (char_u )'l',      (char_u )'y', 
        (char_u )' ',      (char_u )'v',      (char_u )'a',      (char_u )'r', 
        (char_u )'i',      (char_u )'a',      (char_u )'b',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'\"',      (char_u )'%', 
        (char_u )'s',      (char_u )'\"',      (char_u )'\000'};
char_u e_readerrf[30]  = 
  {      (char_u )'E',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'w',      (char_u )'h', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'r',      (char_u )'e',      (char_u )'a',      (char_u )'d', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )' ', 
        (char_u )'e',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'\000'};
char_u e_sandbox[23]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'a',      (char_u )'l',      (char_u )'l',      (char_u )'o', 
        (char_u )'w',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'i',      (char_u )'n',      (char_u )' ',      (char_u )'s', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'b', 
        (char_u )'o',      (char_u )'x',      (char_u )'\000'};
char_u e_scroll[20]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'s',      (char_u )'c',      (char_u )'r',      (char_u )'o', 
        (char_u )'l',      (char_u )'l',      (char_u )' ',      (char_u )'s', 
        (char_u )'i',      (char_u )'z',      (char_u )'e',      (char_u )'\000'};
char_u e_tagformat[31]  = 
  {      (char_u )'F',      (char_u )'o',      (char_u )'r',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )' ',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )' ',      (char_u )'i',      (char_u )'n',      (char_u )' ', 
        (char_u )'t',      (char_u )'a',      (char_u )'g',      (char_u )'s', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'\"',      (char_u )'%', 
        (char_u )'s',      (char_u )'\"',      (char_u )'\000'};
char_u e_tagstack[16]  = 
  {      (char_u )'t',      (char_u )'a',      (char_u )'g',      (char_u )' ', 
        (char_u )'s',      (char_u )'t',      (char_u )'a',      (char_u )'c', 
        (char_u )'k',      (char_u )' ',      (char_u )'e',      (char_u )'m', 
        (char_u )'p',      (char_u )'t',      (char_u )'y',      (char_u )'\000'};
char_u e_toocompl[20]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'t',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'p', 
        (char_u )'l',      (char_u )'e',      (char_u )'x',      (char_u )'\000'};
char_u e_toombra[12]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'\\',      (char_u )'(',      (char_u )'\000'};
char_u e_toomket[12]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'\\',      (char_u )')',      (char_u )'\000'};
char_u e_toomsbra[11]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'[',      (char_u )'\000'};
char_u e_toomany[20]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'n',      (char_u )'a', 
        (char_u )'m',      (char_u )'e',      (char_u )'s',      (char_u )'\000'};
char_u e_trailing[20]  = 
  {      (char_u )'T',      (char_u )'r',      (char_u )'a',      (char_u )'i', 
        (char_u )'l',      (char_u )'i',      (char_u )'n',      (char_u )'g', 
        (char_u )' ',      (char_u )'c',      (char_u )'h',      (char_u )'a', 
        (char_u )'r',      (char_u )'a',      (char_u )'c',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'s',      (char_u )'\000'};
char_u e_umark[13]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'k',      (char_u )'n', 
        (char_u )'o',      (char_u )'w',      (char_u )'n',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )'\000'};
char_u e_unknown[8]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'k',      (char_u )'n', 
        (char_u )'o',      (char_u )'w',      (char_u )'n',      (char_u )'\000'};
char_u e_write[20]  = 
  {      (char_u )'E',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'w',      (char_u )'h', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'w',      (char_u )'r',      (char_u )'i',      (char_u )'t', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )'\000'};
char_u e_zerocount[11]  = 
  {      (char_u )'Z',      (char_u )'e',      (char_u )'r',      (char_u )'o', 
        (char_u )' ',      (char_u )'c',      (char_u )'o',      (char_u )'u', 
        (char_u )'n',      (char_u )'t',      (char_u )'\000'};
char_u *p_bs  ;
char_u *p_bg  ;
char_u *p_bsdir  ;
char_u *p_breakat  ;
char_u *p_cb  ;
long p_ch  ;
char_u *p_def  ;
char_u *p_dir  ;
char_u *p_dy  ;
char_u *p_ep  ;
int p_eb  ;
int p_ek  ;
int p_exrc  ;
char_u *p_fp  ;
char_u *p_hl  ;
char_u *p_inc  ;
char_u *p_kp  ;
char_u *p_lcs  ;
int p_lz  ;
long p_mat  ;
long p_mm  ;
long p_mmt  ;
char_u *p_mouse  ;
char_u *p_mousem  ;
long p_mouset  ;
int p_more  ;
char_u *p_para  ;
char_u *p_path  ;
char_u *p_ruf  ;
long p_sj  ;
char_u *p_sbo  ;
char_u *p_sections  ;
int p_secure  ;
char_u *p_slm  ;
char_u *p_sh  ;
char_u *p_shcf  ;
char_u *p_sxq  ;
char_u *p_stl  ;
int p_sr  ;
char_u *p_shm  ;
int p_sc  ;
int p_sft  ;
long p_ss  ;
char_u *p_su  ;
char_u *p_sws  ;
int p_tbs  ;
long p_tl  ;
int p_tr  ;
char_u *p_tags  ;
int p_tgst  ;
int p_terse  ;
int p_ta  ;
int p_to  ;
char_u *p_titleold  ;
int p_tbi  ;
int p_tf  ;
long p_ttyscroll  ;
char_u *p_ttym  ;
long p_ul  ;
long p_ut  ;
int p_vb  ;
char_u *p_wig  ;
int p_wiv  ;
char_u *p_wim  ;
long p_wh  ;
long p_wmh  ;
long p_wd  ;
void mch_windinit(void) ;
void reset_signals(void) ;
int mch_check_win(int argc , char **argv ) ;
int mch_input_isatty(void) ;
void mch_windexit(int r ) ;
int process_env(char_u *env , int is_viminit ) ;
int recover_names(char_u **fname , int list , int nr ) ;
void init_yank(void) ;
void set_init_1(void) ;
void set_init_2(void) ;
void set_init_3(void) ;
void set_options_bin(int oldval , int newval ) ;
void change_compatible(int on ) ;
void screen_start(void) ;
void screenalloc(int clear ) ;
void init_highlight(int both ) ;
void termcapinit(char_u *name___1 ) ;
void scroll_region_reset(void) ;
int ui_get_winsize(void) ;
void clip_init(int can_use ) ;
void list_version(void) ;
int win_count(void) ;
int make_windows(int count___2 ) ;
void win_equal(WIN *next_curwin , int redraw ) ;
WIN *win_alloc(WIN *after ) ;
static void mainerr(int n , char_u *str___1 ) ;
static void main_msg(char *s ) ;
static void usage(void) ;
static int file_owned(char *fname ) ;
static int get_number_arg(char_u *p___0 , int *idx , int def ) ;
static char *errors___0[5]  = {      (char *)"Unknown option",      (char *)"Too many edit arguments",      (char *)"Argument missing after",      (char *)"Garbage after option", 
        (char *)"Too many \"+command\" or \"-c command\" arguments"};
static void mainerr(int n , char_u *str___1 ) 
{ 


  {
  {
  reset_signals();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", longVersion);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", errors___0[n]);
  }
  if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", ": \"");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)str___1);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "\"");
    }
  }
  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "\nMore info with: \"vim -h\"\n");
  mch_windexit(1);
  }
  return;
}
}
static void main_msg(char *s ) 
{ 


  {
  {
  printf((char const   * __restrict  )"%s", "   ");
  printf((char const   * __restrict  )"%s", s);
  printf((char const   * __restrict  )"%s", "\n");
  }
  return;
}
}
static char_u *use[4]  = {      (char_u *)"[file ..]       edit specified file(s)",      (char_u *)"-               read text from stdin",      (char_u *)"-t tag          edit file where tag is defined",      (char_u *)"-q [errorfile]  edit file with first error"};
static void usage(void) 
{ 
  int i___0 ;

  {
  {
  reset_signals();
  printf((char const   * __restrict  )"%s", longVersion);
  printf((char const   * __restrict  )"%s", "\nusage:");
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    printf((char const   * __restrict  )"%s", " vim [options] ");
    printf((char const   * __restrict  )"%s", (char *)use[i___0]);
    }
    if ((unsigned long )i___0 == sizeof(use) / sizeof(char_u *) - 1UL) {
      goto while_break;
    }
    {
    printf((char const   * __restrict  )"%s", "\n   or:");
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  printf((char const   * __restrict  )"%s", "\n\nOptions:\n");
  main_msg((char *)"--\t\t\tEnd of options");
  main_msg((char *)"-v\t\t\tVi mode (like \"vi\")");
  main_msg((char *)"-e\t\t\tEx mode (like \"ex\")");
  main_msg((char *)"-s\t\t\tSilent (batch) mode (only for \"ex\")");
  main_msg((char *)"-R\t\t\tReadonly mode (like \"view\")");
  main_msg((char *)"-Z\t\t\tRestricted mode (like \"rvim\")");
  main_msg((char *)"-m\t\t\tModifications (writing files) not allowed");
  main_msg((char *)"-b\t\t\tBinary mode");
  main_msg((char *)"-l\t\t\tLisp mode");
  main_msg((char *)"-C\t\t\tCompatible with Vi: \'compatible\'");
  main_msg((char *)"-N\t\t\tNot fully Vi compatible: \'nocompatible\'");
  main_msg((char *)"-V[N]\t\tVerbose level");
  main_msg((char *)"-n\t\t\tNo swap file, use memory only");
  main_msg((char *)"-r\t\t\tList swap files and exit");
  main_msg((char *)"-r (with file name)\tRecover crashed session");
  main_msg((char *)"-L\t\t\tSame as -r");
  main_msg((char *)"-T <terminal>\tSet terminal type to <terminal>");
  main_msg((char *)"-o[N]\t\tOpen N windows (default: one for each file)");
  main_msg((char *)"+\t\t\tStart at end of file");
  main_msg((char *)"+<lnum>\t\tStart at line <lnum>");
  main_msg((char *)"-c <command>\t\tExecute <command> first");
  main_msg((char *)"-s <scriptin>\tRead commands from script file <scriptin>");
  main_msg((char *)"-w <scriptout>\tAppend commands to script file <scriptout>");
  main_msg((char *)"-W <scriptout>\tWrite commands to script file <scriptout>");
  main_msg((char *)"-u <vimrc>\t\tUse <vimrc> instead of any .vimrc");
  main_msg((char *)"-x\t\t\tEdit encrypted files");
  main_msg((char *)"-i <viminfo>\t\tUse <viminfo> instead of .viminfo");
  main_msg((char *)"-h\t\t\tprint Help (this message) and exit");
  main_msg((char *)"--version\t\tprint version information and exit");
  mch_windexit(1);
  }
  return;
}
}
static int file_owned(char *fname ) 
{ 
  struct stat s ;
  uid_t uid ;
  __uid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = getuid();
  uid = tmp;
  tmp___0 = stat((char const   * __restrict  )fname, (struct stat * __restrict  )(& s));
  }
  if (tmp___0 != 0) {
    tmp___2 = 0;
  } else { //Added block
  if (s.st_uid != uid) {
    tmp___2 = 0;
  } else {
    {
    tmp___1 = lstat((char const   * __restrict  )fname, (struct stat * __restrict  )(& s));
    }
    if (tmp___1 != 0) {
      tmp___2 = 0;
    } else { //Added block
    if (s.st_uid != uid) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    }
  }
  }
  return (tmp___2);
}
}
static void check_swap_exists_action(void) ;
static void check_swap_exists_action(void) 
{ 


  {
  if (swap_exists_action == 2) {
    {
    getout(1);
    }
  }
  if (swap_exists_action == 3) {
    {
    msg_scroll = 1;
    ml_recover();
    msg_puts((char_u *)"\n");
    cmdline_row = msg_row;
    do_modelines();
    }
  }
  return;
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
int main(int argc , char **argv ) 
{ 
  char_u *initstr ;
  char_u *term ;
  char_u *fname ;
  char_u *tagname ;
  char_u *use_vimrc ;
  char_u *use_ef ;
  int ask_for_key ;
  int n_commands ;
  char_u *commands[10] ;
  int no_swap_file ;
  int c ;
  int i___0 ;
  int bin_mode ;
  int window_count ;
  int arg_idx ;
  int had_minmin ;
  int argv_idx ;
  int want_full_screen ;
  int want_argument ;
  int edit_type ;
  int stdout_isatty ;
  int input_isatty ;
  OPARG oa ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char_u *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
  {
  term = (char_u *)((void *)0);
  fname = (char_u *)((void *)0);
  tagname = (char_u *)((void *)0);
  use_vimrc = (char_u *)((void *)0);
  use_ef = (char_u *)((void *)0);
  ask_for_key = 0;
  n_commands = 0;
  no_swap_file = 0;
  bin_mode = 0;
  window_count = 1;
  arg_idx = 0;
  had_minmin = 0;
  want_full_screen = 1;
  edit_type = 0;
  setlocale(6, "");
  IObuff = alloc(1025U);
  }
  if ((unsigned long )IObuff == (unsigned long )((void *)0)) {
    {
    mch_windexit(0);
    }
  } else {
    {
    NameBuff = alloc(1024U);
    }
    if ((unsigned long )NameBuff == (unsigned long )((void *)0)) {
      {
      mch_windexit(0);
      }
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < argc)) {
      goto while_break;
    }
    {
    tmp = strcmp((char const   *)*(argv + i___0), (char const   *)((char *)"-display"));
    }
    if (tmp == 0) {
      xterm_display = *(argv + (i___0 + 1));
      goto while_break;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  clip_init(0);
  tmp___0 = mch_check_win(argc, argv);
  stdout_isatty = tmp___0 != 0;
  curwin = win_alloc((WIN *)((void *)0));
  }
  if ((unsigned long )curwin == (unsigned long )((void *)0)) {
    {
    mch_windexit(0);
    }
  } else {
    {
    curbuf = buflist_new((char_u *)((void *)0), (char_u *)((void *)0), 1L, 0);
    }
    if ((unsigned long )curbuf == (unsigned long )((void *)0)) {
      {
      mch_windexit(0);
      }
    }
  }
  {
  curwin->w_buffer = curbuf;
  curbuf->b_nwindows = 1;
  win_init(curwin);
  init_yank();
  init_homedir();
  set_init_1();
  initstr = gettail((char_u *)*(argv + 0));
  }
  if ((int )*(initstr + 0) == 114) {
    restricted = 1;
    initstr ++;
  }
  if ((int )*(initstr + 0) == 103) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)(e_nogvim));
    mch_windexit(2);
    }
  }
  {
  tmp___1 = strncmp((char const   *)((char *)initstr), (char const   *)((char *)"view"),
                    (size_t )4);
  }
  if (tmp___1 == 0) {
    readonlymode = 1;
    curbuf->b_p_ro = 1;
    p_uc = 10000L;
  }
  {
  tmp___2 = strncmp((char const   *)((char *)initstr), (char const   *)((char *)"ex"),
                    (size_t )2);
  }
  if (tmp___2 == 0) {
    {
    exmode_active = 1;
    change_compatible(1);
    }
  }
  {
  argv ++;
  argc --;
  tmp___3 = alloc((unsigned int )(sizeof(char_u *) * (unsigned long )(argc + 1)));
  arg_files = (char_u **)tmp___3;
  }
  if ((unsigned long )arg_files == (unsigned long )((void *)0)) {
    {
    mch_windexit(2);
    }
  }
  arg_file_count = 0;
  argv_idx = 1;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (argc > 0)) {
      goto while_break___0;
    }
    if ((int )*(*(argv + 0) + 0) == 43) {
      if (! had_minmin) {
        if (n_commands >= 10) {
          {
          mainerr(4, (char_u *)((void *)0));
          }
        }
        argv_idx = -1;
        if ((int )*(*(argv + 0) + 1) == 0) {
          tmp___4 = n_commands;
          n_commands ++;
          commands[tmp___4] = (char_u *)"$";
        } else {
          tmp___5 = n_commands;
          n_commands ++;
          commands[tmp___5] = (char_u *)(*(argv + 0) + 1);
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((int )*(*(argv + 0) + 0) == 45) {
      if (! had_minmin) {
        want_argument = 0;
        tmp___6 = argv_idx;
        argv_idx ++;
        c = (int )*(*(argv + 0) + tmp___6);
        {
        if (c == 0) {
          goto case_0;
        }
        if (c == 45) {
          goto case_45;
        }
        if (c == 98) {
          goto case_98;
        }
        if (c == 67) {
          goto case_67;
        }
        if (c == 101) {
          goto case_101;
        }
        if (c == 102) {
          goto case_102;
        }
        if (c == 103) {
          goto case_103;
        }
        if (c == 70) {
          goto case_70;
        }
        if (c == 104) {
          goto case_104;
        }
        if (c == 72) {
          goto case_72;
        }
        if (c == 108) {
          goto case_108;
        }
        if (c == 109) {
          goto case_109;
        }
        if (c == 78) {
          goto case_78;
        }
        if (c == 110) {
          goto case_110;
        }
        if (c == 111) {
          goto case_111;
        }
        if (c == 113) {
          goto case_113;
        }
        if (c == 82) {
          goto case_82;
        }
        if (c == 114) {
          goto case_114;
        }
        if (c == 76) {
          goto case_114;
        }
        if (c == 115) {
          goto case_115;
        }
        if (c == 116) {
          goto case_116;
        }
        if (c == 86) {
          goto case_86;
        }
        if (c == 118) {
          goto case_118;
        }
        if (c == 119) {
          goto case_119;
        }
        if (c == 120) {
          goto case_120;
        }
        if (c == 90) {
          goto case_90;
        }
        if (c == 99) {
          goto case_99;
        }
        if (c == 100) {
          goto case_99;
        }
        if (c == 105) {
          goto case_99;
        }
        if (c == 84) {
          goto case_99;
        }
        if (c == 117) {
          goto case_99;
        }
        if (c == 85) {
          goto case_99;
        }
        if (c == 87) {
          goto case_99;
        }
        goto switch_default;
        case_0: /* CIL Label */ 
        if (exmode_active) {
          silent_mode = 1;
        } else {
          if (edit_type != 0) {
            {
            mainerr(1, (char_u *)*(argv + 0));
            }
          }
          edit_type = 2;
          read_cmd_fd = 2;
        }
        argv_idx = -1;
        goto switch_break;
        case_45: /* CIL Label */ 
        {
        tmp___7 = strcmp((char const   *)(*(argv + 0) + argv_idx), (char const   *)((char *)"help"));
        }
        if (tmp___7 == 0) {
          {
          usage();
          }
        }
        {
        tmp___8 = strcmp((char const   *)(*(argv + 0) + argv_idx), (char const   *)((char *)"version"));
        }
        if (tmp___8 == 0) {
          {
          Columns = 80L;
          list_version();
          mch_windexit(1);
          }
        }
        if (*(*(argv + 0) + argv_idx)) {
          {
          mainerr(0, (char_u *)*(argv + 0));
          }
        }
        had_minmin = 1;
        argv_idx = -1;
        goto switch_break;
        case_98: /* CIL Label */ 
        bin_mode = 1;
        goto switch_break;
        case_67: /* CIL Label */ 
        {
        change_compatible(1);
        }
        goto switch_break;
        case_101: /* CIL Label */ 
        exmode_active = 1;
        goto switch_break;
        case_102: /* CIL Label */ 
        goto switch_break;
        case_103: /* CIL Label */ 
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)(e_nogvim));
        mch_windexit(2);
        }
        goto switch_break;
        case_70: /* CIL Label */ 
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)(e_nofarsi));
        mch_windexit(2);
        }
        goto switch_break;
        case_104: /* CIL Label */ 
        {
        usage();
        }
        goto switch_break;
        case_72: /* CIL Label */ 
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)(e_nohebrew));
        mch_windexit(2);
        }
        goto switch_break;
        case_108: /* CIL Label */ 
        curbuf->b_p_lisp = 1;
        p_sm = 1;
        goto switch_break;
        case_109: /* CIL Label */ 
        p_write = 0;
        goto switch_break;
        case_78: /* CIL Label */ 
        {
        change_compatible(0);
        }
        goto switch_break;
        case_110: /* CIL Label */ 
        no_swap_file = 1;
        goto switch_break;
        case_111: /* CIL Label */ 
        {
        window_count = get_number_arg((char_u *)*(argv + 0), & argv_idx, 0);
        }
        goto switch_break;
        case_113: /* CIL Label */ 
        if (edit_type != 0) {
          {
          mainerr(1, (char_u *)*(argv + 0));
          }
        }
        edit_type = 4;
        if (*(*(argv + 0) + argv_idx)) {
          use_ef = (char_u *)*(argv + 0) + argv_idx;
          argv_idx = -1;
        } else { //Added block
        if (argc > 1) {
          want_argument = 1;
        }
        }
        goto switch_break;
        case_82: /* CIL Label */ 
        readonlymode = 1;
        curbuf->b_p_ro = 1;
        p_uc = 10000L;
        goto switch_break;
        case_114: /* CIL Label */ 
        case_76: /* CIL Label */ 
        recoverymode = 1;
        goto switch_break;
        case_115: /* CIL Label */ 
        if (exmode_active) {
          silent_mode = 1;
        } else {
          want_argument = 1;
        }
        goto switch_break;
        case_116: /* CIL Label */ 
        if (edit_type != 0) {
          {
          mainerr(1, (char_u *)*(argv + 0));
          }
        }
        edit_type = 3;
        if (*(*(argv + 0) + argv_idx)) {
          tagname = (char_u *)*(argv + 0) + argv_idx;
          argv_idx = -1;
        } else {
          want_argument = 1;
        }
        goto switch_break;
        case_86: /* CIL Label */ 
        {
        tmp___9 = get_number_arg((char_u *)*(argv + 0), & argv_idx, 10);
        p_verbose = (long )tmp___9;
        }
        goto switch_break;
        case_118: /* CIL Label */ 
        exmode_active = 0;
        goto switch_break;
        case_119: /* CIL Label */ 
        {
        tmp___10 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___10 + (int )*((char_u *)*(argv + 0) + argv_idx)) & 2048) {
          argv_idx = -1;
          goto switch_break;
        }
        want_argument = 1;
        goto switch_break;
        case_120: /* CIL Label */ 
        ask_for_key = 1;
        goto switch_break;
        case_90: /* CIL Label */ 
        restricted = 1;
        goto switch_break;
        case_99: /* CIL Label */ 
        case_100: /* CIL Label */ 
        case_105: /* CIL Label */ 
        case_84: /* CIL Label */ 
        case_117: /* CIL Label */ 
        case_85: /* CIL Label */ 
        case_87: /* CIL Label */ 
        want_argument = 1;
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
        mainerr(0, (char_u *)*(argv + 0));
        }
        switch_break: /* CIL Label */ ;
        }
        if (want_argument) {
          if ((int )*(*(argv + 0) + argv_idx) != 0) {
            {
            mainerr(3, (char_u *)*(argv + 0));
            }
          }
          argc --;
          if (argc < 1) {
            {
            mainerr(2, (char_u *)*(argv + 0));
            }
          }
          argv ++;
          argv_idx = -1;
          {
          if (c == 99) {
            goto case_99___0;
          }
          if (c == 113) {
            goto case_113___0;
          }
          if (c == 105) {
            goto case_105___0;
          }
          if (c == 115) {
            goto case_115___0;
          }
          if (c == 116) {
            goto case_116___0;
          }
          if (c == 84) {
            goto case_84___0;
          }
          if (c == 117) {
            goto case_117___0;
          }
          if (c == 85) {
            goto case_85___0;
          }
          if (c == 119) {
            goto case_119___0;
          }
          if (c == 87) {
            goto case_119___0;
          }
          goto switch_break___0;
          case_99___0: /* CIL Label */ 
          if (n_commands >= 10) {
            {
            mainerr(4, (char_u *)((void *)0));
            }
          }
          tmp___11 = n_commands;
          n_commands ++;
          commands[tmp___11] = (char_u *)*(argv + 0);
          goto switch_break___0;
          case_113___0: /* CIL Label */ 
          use_ef = (char_u *)*(argv + 0);
          goto switch_break___0;
          case_105___0: /* CIL Label */ 
          use_viminfo = (char_u *)*(argv + 0);
          goto switch_break___0;
          case_115___0: /* CIL Label */ 
          if ((unsigned long )scriptin[0] != (unsigned long )((void *)0)) {
            {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "Attempt to open script file again: \"");
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    *(argv + -1));
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    " ");
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    *(argv + 0));
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "\"\n");
            mch_windexit(2);
            }
          }
          {
          scriptin[0] = fopen((char const   * __restrict  )*(argv + 0), (char const   * __restrict  )"r");
          }
          if ((unsigned long )scriptin[0] == (unsigned long )((void *)0)) {
            {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "Cannot open \"");
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    *(argv + 0));
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "\" for reading\n");
            mch_windexit(2);
            }
          }
          {
          tmp___12 = save_typebuf();
          }
          if (tmp___12 == 0) {
            {
            mch_windexit(2);
            }
          }
          goto switch_break___0;
          case_116___0: /* CIL Label */ 
          tagname = (char_u *)*(argv + 0);
          goto switch_break___0;
          case_84___0: /* CIL Label */ 
          term = (char_u *)*(argv + 0);
          goto switch_break___0;
          case_117___0: /* CIL Label */ 
          use_vimrc = (char_u *)*(argv + 0);
          goto switch_break___0;
          case_85___0: /* CIL Label */ 
          goto switch_break___0;
          case_119___0: /* CIL Label */ 
          case_87___0: /* CIL Label */ 
          if ((unsigned long )scriptout != (unsigned long )((void *)0)) {
            {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "Attempt to open script file again: \"");
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    *(argv + -1));
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    " ");
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    *(argv + 0));
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "\"\n");
            mch_windexit(2);
            }
          }
          if (c == 119) {
            tmp___13 = "a";
          } else {
            tmp___13 = "w";
          }
          {
          scriptout = fopen((char const   * __restrict  )*(argv + 0), (char const   * __restrict  )tmp___13);
          }
          if ((unsigned long )scriptout == (unsigned long )((void *)0)) {
            {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "cannot open \"");
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    *(argv + 0));
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "\" for output\n");
            mch_windexit(2);
            }
          }
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      argv_idx = -1;
      if (edit_type != 0) {
        if (edit_type != 1) {
          {
          mainerr(1, (char_u *)*(argv + 0));
          }
        }
      }
      {
      edit_type = 1;
      *(arg_files + arg_file_count) = vim_strsave((char_u *)*(argv + 0));
      }
      if ((unsigned long )*(arg_files + arg_file_count) != (unsigned long )((void *)0)) {
        arg_file_count ++;
      }
    }
    }
    if (argv_idx <= 0) {
      argc --;
      argv ++;
      argv_idx = 1;
    } else { //Added block
    if ((int )*(*(argv + 0) + argv_idx) == 0) {
      argc --;
      argv ++;
      argv_idx = 1;
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (arg_file_count > 0) {
    fname = *(arg_files + 0);
  }
  if (arg_file_count > 1) {
    {
    printf((char const   * __restrict  )"%d files to edit\n", arg_file_count);
    }
  }
  RedrawingDisabled = 1;
  if (recoverymode) {
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      want_full_screen = 0;
    }
  }
  {
  mch_windinit();
  input_isatty = mch_input_isatty();
  }
  if (exmode_active) {
    if (! input_isatty) {
      silent_mode = 1;
    }
  } else { //Added block
  if (want_full_screen) {
    if (! stdout_isatty) {
      goto _L___1;
    } else { //Added block
    if (! input_isatty) {
      _L___1: 
      if (! stdout_isatty) {
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "Vim: Warning: Output is not to a terminal\n");
        }
      }
      if (! input_isatty) {
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "Vim: Warning: Input is not from a terminal\n");
        }
      }
      {
      out_flush();
      ui_delay(2000L, 1);
      }
    }
    }
  }
  }
  if (want_full_screen) {
    {
    termcapinit(term);
    screen_start();
    }
  }
  {
  screenalloc(0);
  ui_get_winsize();
  screenalloc(0);
  set_init_2();
  firstwin->w_height = (int )(Rows - 1L);
  cmdline_row = (int )(Rows - 1L);
  }
  if (full_screen) {
    if (edit_type != 2) {
      {
      msg_start();
      }
    }
  }
  {
  msg_scroll = 1;
  no_wait_return = 1;
  init_mappings();
  init_highlight(1);
  }
  if ((unsigned long )use_vimrc != (unsigned long )((void *)0)) {
    {
    tmp___15 = strcmp((char const   *)((char *)use_vimrc), (char const   *)((char *)"NONE"));
    }
    if (! (tmp___15 == 0)) {
      {
      tmp___14 = do_source(use_vimrc, 0, 0);
      }
      if (tmp___14 != 1) {
        {
        emsg2((char_u *)"Cannot read from \"%s\"", use_vimrc);
        }
      }
    }
  } else { //Added block
  if (! silent_mode) {
    {
    do_source((char_u *)"$VIM/vimrc", 0, 0);
    tmp___20 = process_env((char_u *)"VIMINIT", 1);
    }
    if (tmp___20 != 1) {
      {
      tmp___16 = do_source((char_u *)"$HOME/.vimrc", 1, 1);
      }
      if (tmp___16 == 0) {
        {
        tmp___17 = process_env((char_u *)"EXINIT", 0);
        }
        if (tmp___17 == 0) {
          {
          tmp___18 = do_source((char_u *)"$HOME/.exrc", 0, 0);
          }
          if (tmp___18 == 0) {
            tmp___19 = 1;
          } else {
            tmp___19 = 0;
          }
        } else {
          tmp___19 = 0;
        }
      } else {
        tmp___19 = 0;
      }
    }
    if (p_exrc) {
      {
      tmp___21 = file_owned((char *)".vimrc");
      }
      if (! tmp___21) {
        secure = p_secure;
      }
      {
      i___0 = 0;
      tmp___22 = fullpathcmp((char_u *)"$HOME/.vimrc", (char_u *)".vimrc", 0);
      }
      if (tmp___22 != 1) {
        {
        tmp___23 = fullpathcmp((char_u *)"$VIM/vimrc", (char_u *)".vimrc", 0);
        }
        if (tmp___23 != 1) {
          {
          i___0 = do_source((char_u *)".vimrc", 1, 1);
          }
        }
      }
      if (i___0 == 0) {
        {
        tmp___24 = file_owned((char *)".exrc");
        }
        if (tmp___24) {
          secure = 0;
        } else {
          secure = p_secure;
        }
        {
        tmp___25 = fullpathcmp((char_u *)"$HOME/.exrc", (char_u *)".exrc", 0);
        }
        if (tmp___25 != 1) {
          {
          do_source((char_u *)".exrc", 0, 0);
          }
        }
      }
    }
    if (secure == 2) {
      need_wait_return = 1;
    }
    secure = 0;
  }
  }
  if (recoverymode) {
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      {
      recover_names((char_u **)((void *)0), 1, 0);
      mch_windexit(0);
      }
    }
  }
  {
  set_init_3();
  }
  if (no_swap_file) {
    p_uc = 0L;
  }
  if (bin_mode) {
    {
    set_options_bin(curbuf->b_p_bin, 1);
    curbuf->b_p_bin = 1;
    }
  }
  if ((int )*p_viminfo != 0) {
    {
    read_viminfo((char_u *)((void *)0), 1, 0, 0);
    }
  }
  if (edit_type == 4) {
    if ((unsigned long )use_ef != (unsigned long )((void *)0)) {
      {
      set_string_option_direct((char_u *)"ef", -1, use_ef, 1);
      }
    }
    {
    tmp___26 = qf_init(p_ef, p_efm);
    }
    if (tmp___26 < 0) {
      {
      out_char((unsigned int )'\n');
      mch_windexit(3);
      }
    }
  }
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    {
    setfname(fname, (char_u *)((void *)0), 1);
    arg_idx ++;
    }
  }
  starting = 1;
  no_wait_return = 0;
  if (! exmode_active) {
    msg_scroll = 0;
  }
  if (edit_type == 2) {
    if (! recoverymode) {
      {
      swap_exists_action = 1;
      no_wait_return = 1;
      i___0 = msg_didany;
      open_buffer(1);
      no_wait_return = 0;
      msg_didany = i___0;
      check_swap_exists_action();
      swap_exists_action = 0;
      close(0);
      dup(2);
      }
    }
  }
  {
  settmode(2);
  }
  if (need_wait_return) {
    {
    wait_return(1);
    }
  } else { //Added block
  if (msg_didany) {
    {
    wait_return(1);
    }
  }
  }
  {
  starttermcap();
  setmouse();
  }
  if (scroll_region) {
    {
    scroll_region_reset();
    }
  }
  {
  scroll_start();
  }
  if (exmode_active) {
    must_redraw = 50;
  } else {
    {
    screenclear();
    }
  }
  if (ask_for_key) {
    {
    get_crypt_key(1);
    }
  }
  no_wait_return = 1;
  if (window_count == 0) {
    window_count = arg_file_count;
  }
  if (window_count > 1) {
    if ((unsigned long )firstwin->w_next == (unsigned long )((void *)0)) {
      {
      window_count = make_windows(window_count);
      }
    } else {
      {
      window_count = win_count();
      }
    }
  } else {
    window_count = 1;
  }
  if (recoverymode) {
    {
    msg_scroll = 1;
    ml_recover();
    msg_scroll = 0;
    }
    if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      {
      getout(1);
      }
    }
    {
    do_modelines();
    }
  } else {
    swap_exists_action = 1;
    autocmd_no_enter ++;
    autocmd_no_leave ++;
    curwin = firstwin;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned long )curwin != (unsigned long )((void *)0))) {
        goto while_break___1;
      }
      curbuf = curwin->w_buffer;
      if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
        {
        open_buffer(0);
        check_swap_exists_action();
        curwin = firstwin;
        }
      }
      {
      ui_breakcheck();
      }
      if (got_int) {
        {
        vgetc();
        }
        goto while_break___1;
      }
      curwin = curwin->w_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    autocmd_no_enter --;
    autocmd_no_leave --;
    swap_exists_action = 0;
    curwin = firstwin;
    curbuf = curwin->w_buffer;
  }
  if (exmode_active) {
    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
  }
  {
  apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  setpcmark();
  }
  if (edit_type == 4) {
    {
    qf_jump(0, 0, 0);
    }
  }
  autocmd_no_enter ++;
  autocmd_no_leave ++;
  i___0 = 1;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (i___0 < window_count)) {
      goto while_break___2;
    }
    if ((unsigned long )curwin->w_next == (unsigned long )((void *)0)) {
      goto while_break___2;
    }
    {
    win_enter(curwin->w_next, 0);
    }
    if ((unsigned long )curbuf == (unsigned long )firstwin->w_buffer) {
      goto _L___2;
    } else { //Added block
    if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
      _L___2: 
      curwin->w_arg_idx = arg_idx;
      if (arg_idx < arg_file_count) {
        tmp___27 = *(arg_files + arg_idx);
      } else {
        tmp___27 = (char_u *)((void *)0);
      }
      {
      do_ecmd(0, tmp___27, (char_u *)((void *)0), (char_u *)((void *)0), (linenr_t )0,
              1);
      }
      if (arg_idx == arg_file_count - 1) {
        arg_had_last = 1;
      }
      arg_idx ++;
    }
    }
    {
    ui_breakcheck();
    }
    if (got_int) {
      {
      vgetc();
      }
      goto while_break___2;
    }
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  autocmd_no_enter --;
  win_enter(firstwin, 0);
  autocmd_no_leave --;
  }
  if (window_count > 1) {
    {
    win_equal(curwin, 0);
    }
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (arg_idx < arg_file_count)) {
      goto while_break___3;
    }
    {
    tmp___28 = arg_idx;
    arg_idx ++;
    buflist_add(*(arg_files + tmp___28));
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  shorten_fnames(0);
  }
  if (tagname) {
    {
    strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"ta "));
    strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tagname));
    do_cmdline(IObuff, (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
               3);
    }
  }
  if (n_commands > 0) {
    curwin->w_cursor.lnum = (linenr_t )0;
    sourcing_name = (char_u *)"command line";
    i___0 = 0;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! (i___0 < n_commands)) {
        goto while_break___4;
      }
      {
      do_cmdline(commands[i___0], (char_u *(*)(int  , void * , int  ))((void *)0),
                 (void *)0, 3);
      i___0 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    sourcing_name = (char_u *)((void *)0);
    if (curwin->w_cursor.lnum == 0L) {
      curwin->w_cursor.lnum = (linenr_t )1;
    }
    if (edit_type == 4) {
      {
      qf_jump(0, 0, 0);
      }
    }
  }
  {
  RedrawingDisabled = 0;
  redraw_later(40);
  no_wait_return = 0;
  starting = 0;
  }
  if (p_im) {
    need_start_insertmode = 1;
  }
  {
  apply_autocmds((EVENT_T )33, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if (restart_edit) {
    {
    stuffReadbuff((char_u *)"\034\016");
    }
  }
  {
  clear_oparg(& oa);
  }
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
    tmp___30 = stuff_empty();
    }
    if (tmp___30) {
      if (need_check_timestamps) {
        {
        check_timestamps(0);
        }
      }
      if (need_wait_return) {
        {
        wait_return(0);
        }
      }
      if (need_start_insertmode) {
        {
        tmp___29 = goto_im();
        }
        if (tmp___29) {
          {
          need_start_insertmode = 0;
          stuffReadbuff((char_u *)"i");
          need_fileinfo = 0;
          }
        }
      }
    }
    if (got_int) {
      if (! global_busy) {
        if (! quit_more) {
          {
          vgetc();
          }
        }
        got_int = 0;
      }
    }
    if (! exmode_active) {
      msg_scroll = 0;
    }
    quit_more = 0;
    if (skip_redraw) {
      skip_redraw = 0;
    } else { //Added block
    if (exmode_active) {
      skip_redraw = 0;
    } else { //Added block
    if (do_redraw) {
      goto _L___3;
    } else {
      {
      tmp___31 = stuff_empty();
      }
      if (tmp___31) {
        _L___3: 
        {
        update_topline();
        validate_cursor();
        }
        if (VIsual_active) {
          {
          update_curbuf(20);
          }
        } else { //Added block
        if (must_redraw) {
          {
          update_screen(must_redraw);
          }
        } else { //Added block
        if (redraw_cmdline) {
          {
          showmode();
          }
        } else { //Added block
        if (clear_cmdline) {
          {
          showmode();
          }
        }
        }
        }
        }
        {
        redraw_statuslines();
        }
        if ((unsigned long )keep_msg != (unsigned long )((void *)0)) {
          {
          msg_attr(keep_msg, keep_msg_attr);
          }
        }
        if (need_fileinfo) {
          {
          fileinfo(0, 1, 0);
          need_fileinfo = 0;
          }
        }
        {
        emsg_on_display = 0;
        msg_didany = 0;
        do_redraw = 0;
        showruler(0);
        setcursor();
        cursor_on();
        }
      }
    }
    }
    }
    {
    update_curswant();
    }
    if (exmode_active) {
      {
      do_exmode();
      }
    } else {
      {
      normal_cmd(& oa, 1);
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  return (0);
}
}
static int get_number_arg(char_u *p___0 , int *idx , int def ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  tmp___0 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___0 + (int )*(p___0 + *idx)) & 2048) {
    {
    def = atoi((char const   *)((char *)(p___0 + *idx)));
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp + (int )*(p___0 + *idx)) & 2048)) {
        goto while_break;
      }
      (*idx) ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (def);
}
}
int process_env(char_u *env , int is_viminit ) 
{ 
  char_u *initstr ;
  char_u *save_sourcing_name ;
  linenr_t save_sourcing_lnum ;
  char *tmp ;

  {
  {
  tmp = getenv((char const   *)((char *)env));
  initstr = (char_u *)tmp;
  }
  if ((unsigned long )initstr != (unsigned long )((void *)0)) {
    if ((int )*initstr != 0) {
      if (is_viminit) {
        {
        vimrc_found();
        }
      }
      {
      save_sourcing_name = sourcing_name;
      save_sourcing_lnum = sourcing_lnum;
      sourcing_name = env;
      sourcing_lnum = (linenr_t )0;
      do_cmdline(initstr, (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
                 3);
      sourcing_name = save_sourcing_name;
      sourcing_lnum = save_sourcing_lnum;
      }
      return (1);
    }
  }
  return (0);
}
}
void getout(int r ) 
{ 


  {
  {
  exiting = 1;
  windgoto((int )Rows - 1, 0);
  apply_autocmds((EVENT_T )35, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if ((int )*p_viminfo != 0) {
    {
    msg_didany = 0;
    write_viminfo((char_u *)((void *)0), 0);
    }
    if (msg_didany) {
      {
      no_wait_return = 0;
      wait_return(0);
      }
    }
  }
  {
  apply_autocmds((EVENT_T )34, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  windgoto((int )Rows - 1, 0);
  mch_windexit(r);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-XFp4uAh1.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
FPOS *movemark(int count___2 ) ;
char_u *fm_getname(struct filemark *fmark , int lead_len ) ;
void qf_mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) ;
static struct filemark namedfm[36]  ;
static char_u *namedfm_names[36]  ;
static char_u *mark_line(FPOS *mp , int lead_len ) ;
static void show_one_mark(int c , char_u *arg , FPOS *p___0 , char_u *name___1 , int current ) ;
static void cleanup_jumplist(void) ;
int setmark(int c ) 
{ 
  int i___0 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  if (c == 39) {
    {
    setpcmark();
    curwin->w_prev_pcmark = curwin->w_pcmark;
    }
    return (1);
  } else { //Added block
  if (c == 96) {
    {
    setpcmark();
    curwin->w_prev_pcmark = curwin->w_pcmark;
    }
    return (1);
  }
  }
  if (c > 122) {
    return (0);
  }
  {
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + c) & 512) {
    i___0 = c - 97;
    curbuf->b_namedm[i___0] = curwin->w_cursor;
    return (1);
  }
  {
  tmp___0 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___0 + c) & 256) {
    i___0 = c - 65;
    namedfm[i___0].mark = curwin->w_cursor;
    namedfm[i___0].fnum = curbuf->b_fnum;
    return (1);
  }
  return (0);
}
}
void setpcmark(void) 
{ 
  int i___0 ;

  {
  if (global_busy) {
    return;
  }
  curwin->w_prev_pcmark = curwin->w_pcmark;
  curwin->w_pcmark = curwin->w_cursor;
  (curwin->w_jumplistlen) ++;
  if (curwin->w_jumplistlen > 50) {
    curwin->w_jumplistlen = 50;
    i___0 = 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < 50)) {
        goto while_break;
      }
      curwin->w_jumplist[i___0 - 1] = curwin->w_jumplist[i___0];
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  curwin->w_jumplistidx = curwin->w_jumplistlen - 1;
  curwin->w_jumplist[curwin->w_jumplistidx].mark = curwin->w_pcmark;
  curwin->w_jumplist[curwin->w_jumplistidx].fnum = curbuf->b_fnum;
  (curwin->w_jumplistidx) ++;
  return;
}
}
void checkpcmark(void) 
{ 


  {
  if (curwin->w_prev_pcmark.lnum != 0L) {
    if (curwin->w_pcmark.lnum == curwin->w_cursor.lnum) {
      if (curwin->w_pcmark.col == curwin->w_cursor.col) {
        curwin->w_pcmark = curwin->w_prev_pcmark;
        curwin->w_prev_pcmark.lnum = (linenr_t )0;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (curwin->w_pcmark.lnum == 0L) {
      curwin->w_pcmark = curwin->w_prev_pcmark;
      curwin->w_prev_pcmark.lnum = (linenr_t )0;
    }
    }
  }
  return;
}
}
FPOS *movemark(int count___2 ) 
{ 
  FPOS *pos___0 ;
  struct filemark *jmp ;
  int tmp ;
  BUF *tmp___0 ;
  int tmp___1 ;

  {
  {
  cleanup_jumplist();
  }
  if (curwin->w_jumplistlen == 0) {
    return ((FPOS *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (curwin->w_jumplistidx + count___2 < 0) {
      return ((FPOS *)((void *)0));
    } else { //Added block
    if (curwin->w_jumplistidx + count___2 >= curwin->w_jumplistlen) {
      return ((FPOS *)((void *)0));
    }
    }
    if (curwin->w_jumplistidx == curwin->w_jumplistlen) {
      {
      setpcmark();
      (curwin->w_jumplistidx) --;
      }
      if (curwin->w_jumplistidx + count___2 < 0) {
        return ((FPOS *)((void *)0));
      }
    }
    curwin->w_jumplistidx += count___2;
    jmp = curwin->w_jumplist + curwin->w_jumplistidx;
    if (jmp->fnum != curbuf->b_fnum) {
      {
      tmp___0 = buflist_findnr(jmp->fnum);
      }
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        if (count___2 < 0) {
          tmp = -1;
        } else {
          tmp = 1;
        }
        count___2 += tmp;
        goto __Cont;
      }
      {
      tmp___1 = buflist_getfile(jmp->fnum, jmp->mark.lnum, 0, 0);
      }
      if (tmp___1 == 0) {
        return ((FPOS *)((void *)0));
      }
      curwin->w_cursor.lnum = jmp->mark.lnum;
      curwin->w_cursor.col = jmp->mark.col;
      pos___0 = (FPOS *)-1;
    } else {
      pos___0 = & jmp->mark;
    }
    return (pos___0);
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
static FPOS pos_copy  ;
FPOS *getmark(int c , int changefile ) 
{ 
  FPOS *posp ;
  FPOS *startp ;
  FPOS *endp ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  posp = (FPOS *)((void *)0);
  if (! (c > 126)) {
    if (c == 39) {
      pos_copy = curwin->w_pcmark;
      posp = & pos_copy;
    } else { //Added block
    if (c == 96) {
      pos_copy = curwin->w_pcmark;
      posp = & pos_copy;
    } else { //Added block
    if (c == 34) {
      posp = & curbuf->b_last_cursor;
    } else { //Added block
    if (c == 91) {
      posp = & curbuf->b_op_start;
    } else { //Added block
    if (c == 93) {
      posp = & curbuf->b_op_end;
    } else { //Added block
    if (c == 60) {
      goto _L___0;
    } else { //Added block
    if (c == 62) {
      _L___0: 
      startp = & curbuf->b_visual_start;
      endp = & curbuf->b_visual_end;
      if (startp->lnum != endp->lnum) {
        tmp = startp->lnum < endp->lnum;
      } else {
        tmp = startp->col < endp->col;
      }
      if ((c == 60) == tmp) {
        posp = startp;
      } else {
        posp = endp;
      }
      if (curbuf->b_visual_mode == 86) {
        pos_copy = *posp;
        posp = & pos_copy;
        if (c == 60) {
          pos_copy.col = (colnr_t )0;
        } else {
          pos_copy.col = (colnr_t )2147483647;
        }
      }
    } else {
      {
      tmp___4 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___4 + c) & 512) {
        posp = & curbuf->b_namedm[c - 97];
      } else {
        {
        tmp___2 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___2 + c) & 256) {
          goto _L;
        } else {
          {
          tmp___3 = vim_isdigit(c);
          }
          if (tmp___3) {
            _L: 
            {
            tmp___0 = vim_isdigit(c);
            }
            if (tmp___0) {
              c = (c - 48) + 26;
            } else {
              c -= 65;
            }
            posp = & namedfm[c].mark;
            if (namedfm[c].fnum == 0) {
              if ((unsigned long )namedfm_names[c] != (unsigned long )((void *)0)) {
                {
                expand_env(namedfm_names[c], NameBuff, 1024);
                mch_dirname(IObuff, 1025);
                p___0 = shorten_fname(NameBuff, IObuff);
                buflist_new(NameBuff, p___0, (linenr_t )1, 0);
                }
              }
            }
            if (namedfm[c].fnum != curbuf->b_fnum) {
              if (namedfm[c].mark.lnum != 0L) {
                if (changefile) {
                  if (namedfm[c].fnum) {
                    {
                    tmp___1 = buflist_getfile(namedfm[c].fnum, namedfm[c].mark.lnum,
                                              1, 0);
                    }
                    if (tmp___1 == 1) {
                      curwin->w_cursor.lnum = namedfm[c].mark.lnum;
                      curwin->w_cursor.col = namedfm[c].mark.col;
                      return ((FPOS *)-1);
                    }
                  }
                }
              }
              posp = & pos_copy;
              pos_copy.lnum = (linenr_t )0;
            }
          }
        }
      }
    }
    }
    }
    }
    }
    }
    }
  }
  return (posp);
}
}
void fmarks_check_names(BUF *buf___3 ) 
{ 
  char_u *name___1 ;
  int i___0 ;
  int tmp ;

  {
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    return;
  }
  {
  name___1 = home_replace_save(buf___3, buf___3->b_ffname);
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break;
    }
    if (namedfm[i___0].fnum == 0) {
      if ((unsigned long )namedfm_names[i___0] != (unsigned long )((void *)0)) {
        {
        tmp = strcmp((char const   *)((char *)name___1), (char const   *)((char *)namedfm_names[i___0]));
        }
        if (tmp == 0) {
          {
          namedfm[i___0].fnum = buf___3->b_fnum;
          vim_free((void *)namedfm_names[i___0]);
          namedfm_names[i___0] = (char_u *)((void *)0);
          }
        }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)name___1);
  }
  return;
}
}
int check_mark(FPOS *pos___0 ) 
{ 


  {
  if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
    {
    emsg(e_umark);
    }
    return (0);
  }
  if (pos___0->lnum == 0L) {
    {
    emsg(e_marknotset);
    }
    return (0);
  }
  if (pos___0->lnum > curbuf->b_ml.ml_line_count) {
    {
    emsg(e_markinval);
    }
    return (0);
  }
  return (1);
}
}
static int i  =    -1;
void clrallmarks(BUF *buf___3 ) 
{ 


  {
  if (i == -1) {
    i = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i < 27)) {
        goto while_break;
      }
      namedfm[i].mark.lnum = (linenr_t )0;
      namedfm_names[i] = (char_u *)((void *)0);
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  i = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < 26)) {
      goto while_break___0;
    }
    buf___3->b_namedm[i].lnum = (linenr_t )0;
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  buf___3->b_op_start.lnum = (linenr_t )0;
  buf___3->b_op_end.lnum = (linenr_t )0;
  buf___3->b_last_cursor.lnum = (linenr_t )1;
  buf___3->b_last_cursor.col = (colnr_t )0;
  return;
}
}
char_u *fm_getname(struct filemark *fmark , int lead_len ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  if (fmark->fnum == curbuf->b_fnum) {
    {
    tmp = mark_line(& fmark->mark, lead_len);
    }
    return (tmp);
  }
  {
  tmp___0 = buflist_nr2name(fmark->fnum, 0, 1);
  }
  return (tmp___0);
}
}
static char_u *mark_line(FPOS *mp , int lead_len ) 
{ 
  char_u *s ;
  char_u *p___0 ;
  int len___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  if (mp->lnum == 0L) {
    {
    tmp = vim_strsave((char_u *)"-invalid-");
    }
    return (tmp);
  } else { //Added block
  if (mp->lnum > curbuf->b_ml.ml_line_count) {
    {
    tmp = vim_strsave((char_u *)"-invalid-");
    }
    return (tmp);
  }
  }
  {
  tmp___0 = ml_get(mp->lnum);
  tmp___1 = skipwhite(tmp___0);
  s = vim_strnsave(tmp___1, (int )Columns);
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  len___0 = 0;
  p___0 = s;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*p___0 != 0)) {
      goto while_break;
    }
    {
    tmp___2 = charsize((int )*p___0);
    len___0 += tmp___2;
    }
    if ((long )len___0 >= Columns - (long )lead_len) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  *p___0 = (char_u )'\000';
  return (s);
}
}
void do_marks(char_u *arg ) 
{ 
  int i___0 ;
  char_u *name___1 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    if ((int )*arg == 0) {
      arg = (char_u *)((void *)0);
    }
  }
  {
  show_one_mark('\'', arg, & curwin->w_pcmark, (char_u *)((void *)0), 1);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 26)) {
      goto while_break;
    }
    {
    show_one_mark(i___0 + 97, arg, & curbuf->b_namedm[i___0], (char_u *)((void *)0),
                  1);
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break___0;
    }
    if (namedfm[i___0].fnum) {
      {
      tmp = fm_getname(& namedfm[i___0], 15);
      name___1 = tmp;
      }
    } else {
      name___1 = namedfm_names[i___0];
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
      if (i___0 >= 26) {
        tmp___0 = (i___0 - 26) + 48;
      } else {
        tmp___0 = i___0 + 65;
      }
      {
      show_one_mark(tmp___0, arg, & namedfm[i___0].mark, name___1, namedfm[i___0].fnum == curbuf->b_fnum);
      }
      if (namedfm[i___0].fnum) {
        {
        vim_free((void *)name___1);
        }
      }
    }
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  show_one_mark('\"', arg, & curbuf->b_last_cursor, (char_u *)((void *)0), 1);
  show_one_mark('[', arg, & curbuf->b_op_start, (char_u *)((void *)0), 1);
  show_one_mark(']', arg, & curbuf->b_op_end, (char_u *)((void *)0), 1);
  show_one_mark('<', arg, & curbuf->b_visual_start, (char_u *)((void *)0), 1);
  show_one_mark('>', arg, & curbuf->b_visual_end, (char_u *)((void *)0), 1);
  show_one_mark(-1, arg, (FPOS *)((void *)0), (char_u *)((void *)0), 0);
  }
  return;
}
}
static int did_title  =    0;
static void show_one_mark(int c , char_u *arg , FPOS *p___0 , char_u *name___1 , int current ) 
{ 
  int mustfree ;
  int tmp ;
  char_u *tmp___0 ;

  {
  mustfree = 0;
  if (c == -1) {
    if (did_title) {
      did_title = 0;
    } else { //Added block
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      msg((char_u *)"No marks set");
      }
    } else {
      {
      emsg2((char_u *)"No marks matching \"%s\"", arg);
      }
    }
    }
  } else { //Added block
  if (! got_int) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      goto _L;
    } else {
      {
      tmp___0 = vim_strchr(arg, c);
      }
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        _L: 
        if (p___0->lnum != 0L) {
          if (! did_title) {
            {
            msg_puts_title((char_u *)"\nmark line  col file/text");
            did_title = 1;
            }
          }
          {
          msg_putchar('\n');
          }
          if (! got_int) {
            {
            sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )" %c %6ld %4d ",
                    c, p___0->lnum, p___0->col);
            msg_outtrans(IObuff);
            }
            if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
              if (current) {
                {
                name___1 = mark_line(p___0, 15);
                mustfree = 1;
                }
              }
            }
            if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
              if (current) {
                tmp = highlight_attr[2];
              } else {
                tmp = 0;
              }
              {
              msg_outtrans_attr(name___1, tmp);
              }
              if (mustfree) {
                {
                vim_free((void *)name___1);
                }
              }
            }
          }
          {
          out_flush();
          }
        }
      }
    }
  }
  }
  return;
}
}
void do_jumps(void) 
{ 
  int i___0 ;
  char_u *name___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  cleanup_jumplist();
  msg_puts_title((char_u *)"\n jump line  col file/text");
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < curwin->w_jumplistlen)) {
      goto while_break;
    }
    if (curwin->w_jumplist[i___0].mark.lnum != 0L) {
      {
      name___1 = fm_getname(& curwin->w_jumplist[i___0], 16);
      }
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      {
      msg_putchar('\n');
      }
      if (i___0 > curwin->w_jumplistidx) {
        tmp = i___0 - curwin->w_jumplistidx;
      } else {
        tmp = curwin->w_jumplistidx - i___0;
      }
      if (i___0 == curwin->w_jumplistidx) {
        tmp___0 = '>';
      } else {
        tmp___0 = ' ';
      }
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%c %2d %5ld %4d ",
              tmp___0, tmp, curwin->w_jumplist[i___0].mark.lnum, curwin->w_jumplist[i___0].mark.col);
      msg_outtrans(IObuff);
      }
      if (curwin->w_jumplist[i___0].fnum == curbuf->b_fnum) {
        tmp___1 = highlight_attr[2];
      } else {
        tmp___1 = 0;
      }
      {
      msg_outtrans_attr(name___1, tmp___1);
      vim_free((void *)name___1);
      }
    }
    {
    out_flush();
    }
    __Cont: 
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (curwin->w_jumplistidx == curwin->w_jumplistlen) {
    {
    msg_puts((char_u *)"\n>");
    }
  }
  return;
}
}
void mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) 
{ 
  int i___0 ;
  int fnum ;
  linenr_t *lp ;
  WIN *win ;

  {
  fnum = curbuf->b_fnum;
  if (line2 < line1) {
    if (amount_after == 0L) {
      return;
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 26)) {
      goto while_break;
    }
    lp = & curbuf->b_namedm[i___0].lnum;
    if (*lp >= line1) {
      if (*lp <= line2) {
        if (amount == 2147483647L) {
          *lp = (linenr_t )0;
        } else {
          *lp += amount;
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (amount_after) {
      if (*lp > line2) {
        *lp += amount_after;
      }
    }
    }
    if (namedfm[i___0].fnum == fnum) {
      lp = & namedfm[i___0].mark.lnum;
      if (*lp >= line1) {
        if (*lp <= line2) {
          if (amount == 2147483647L) {
            *lp = (linenr_t )0;
          } else {
            *lp += amount;
          }
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if (amount_after) {
        if (*lp > line2) {
          *lp += amount_after;
        }
      }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  i___0 = 26;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break___0;
    }
    if (namedfm[i___0].fnum == fnum) {
      lp = & namedfm[i___0].mark.lnum;
      if (*lp >= line1) {
        if (*lp <= line2) {
          if (amount == 2147483647L) {
            *lp = (linenr_t )0;
          } else {
            *lp += amount;
          }
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (amount_after) {
        if (*lp > line2) {
          *lp += amount_after;
        }
      }
      }
    }
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  lp = & curwin->w_pcmark.lnum;
  if (*lp >= line1) {
    if (*lp <= line2) {
      if (amount == 2147483647L) {
        *lp = (linenr_t )0;
      } else {
        *lp += amount;
      }
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if (amount_after) {
    if (*lp > line2) {
      *lp += amount_after;
    }
  }
  }
  lp = & curwin->w_prev_pcmark.lnum;
  if (*lp >= line1) {
    if (*lp <= line2) {
      if (amount == 2147483647L) {
        *lp = (linenr_t )0;
      } else {
        *lp += amount;
      }
    } else {
      goto _L___3;
    }
  } else { //Added block
  _L___3: 
  if (amount_after) {
    if (*lp > line2) {
      *lp += amount_after;
    }
  }
  }
  lp = & curbuf->b_visual_start.lnum;
  if (*lp >= line1) {
    if (*lp <= line2) {
      if (amount == 2147483647L) {
        *lp = line1;
      } else {
        *lp += amount;
      }
    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: 
  if (amount_after) {
    if (*lp > line2) {
      *lp += amount_after;
    }
  }
  }
  lp = & curbuf->b_visual_end.lnum;
  if (*lp >= line1) {
    if (*lp <= line2) {
      if (amount == 2147483647L) {
        *lp = line1;
      } else {
        *lp += amount;
      }
    } else {
      goto _L___5;
    }
  } else { //Added block
  _L___5: 
  if (amount_after) {
    if (*lp > line2) {
      *lp += amount_after;
    }
  }
  }
  win = firstwin;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break___1;
    }
    if ((unsigned long )win->w_buffer == (unsigned long )curbuf) {
      i___0 = 0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (i___0 < win->w_tagstacklen)) {
          goto while_break___2;
        }
        if (win->w_tagstack[i___0].fmark.fnum == fnum) {
          lp = & win->w_tagstack[i___0].fmark.mark.lnum;
          if (*lp >= line1) {
            if (*lp <= line2) {
              if (amount == 2147483647L) {
                *lp = line1;
              } else {
                *lp += amount;
              }
            } else {
              goto _L___6;
            }
          } else { //Added block
          _L___6: 
          if (amount_after) {
            if (*lp > line2) {
              *lp += amount_after;
            }
          }
          }
        }
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    win = win->w_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  qf_mark_adjust(line1, line2, amount, amount_after);
  win = firstwin;
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break___3;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! (i___0 < win->w_jumplistlen)) {
        goto while_break___4;
      }
      if (win->w_jumplist[i___0].fnum == fnum) {
        lp = & win->w_jumplist[i___0].mark.lnum;
        if (*lp >= line1) {
          if (*lp <= line2) {
            if (amount == 2147483647L) {
              *lp = line1;
            } else {
              *lp += amount;
            }
          } else {
            goto _L___7;
          }
        } else { //Added block
        _L___7: 
        if (amount_after) {
          if (*lp > line2) {
            *lp += amount_after;
          }
        }
        }
      }
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    if ((unsigned long )win != (unsigned long )curwin) {
      if ((unsigned long )win->w_buffer == (unsigned long )curbuf) {
        if (win->w_topline >= line1) {
          if (win->w_topline <= line2) {
            if (amount == 2147483647L) {
              if (line1 <= 1L) {
                win->w_topline = (linenr_t )1;
              } else {
                win->w_topline = line1 - 1L;
              }
            } else {
              win->w_topline += amount;
            }
          } else {
            goto _L___8;
          }
        } else { //Added block
        _L___8: 
        if (amount_after) {
          if (win->w_topline > line2) {
            win->w_topline += amount_after;
          }
        }
        }
        if (win->w_cursor.lnum >= line1) {
          if (win->w_cursor.lnum <= line2) {
            if (amount == 2147483647L) {
              if (line1 <= 1L) {
                win->w_cursor.lnum = (linenr_t )1;
              } else {
                win->w_cursor.lnum = line1 - 1L;
              }
              win->w_cursor.col = (colnr_t )0;
            } else {
              win->w_cursor.lnum += amount;
            }
          } else {
            goto _L___9;
          }
        } else { //Added block
        _L___9: 
        if (amount_after) {
          if (win->w_cursor.lnum > line2) {
            win->w_cursor.lnum += amount_after;
          }
        }
        }
      }
    }
    win = win->w_next;
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
static void cleanup_jumplist(void) 
{ 
  int i___0 ;
  int from ;
  int to ;
  int tmp ;

  {
  to = 0;
  from = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (from < curwin->w_jumplistlen)) {
      goto while_break;
    }
    if (curwin->w_jumplistidx == from) {
      curwin->w_jumplistidx = to;
    }
    i___0 = from + 1;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < curwin->w_jumplistlen)) {
        goto while_break___0;
      }
      if (curwin->w_jumplist[i___0].fnum == curwin->w_jumplist[from].fnum) {
        if (curwin->w_jumplist[i___0].mark.lnum == curwin->w_jumplist[from].mark.lnum) {
          goto while_break___0;
        }
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (i___0 >= curwin->w_jumplistlen) {
      tmp = to;
      to ++;
      curwin->w_jumplist[tmp] = curwin->w_jumplist[from];
    }
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (curwin->w_jumplistidx == curwin->w_jumplistlen) {
    curwin->w_jumplistidx = to;
  }
  curwin->w_jumplistlen = to;
  return;
}
}
void set_last_cursor(WIN *win ) 
{ 


  {
  (win->w_buffer)->b_last_cursor = win->w_cursor;
  return;
}
}
int read_viminfo_filemark(char_u *line , FILE *fp___0 , int force ) 
{ 
  int idx ;
  char_u *str___1 ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  long tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
  str___1 = line + 1;
  if ((int )*str___1 > 127) {
    goto _L___0;
  } else {
    {
    tmp___2 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___2 + (int )*str___1) & 2048) {
      _L___1: 
      {
      tmp___0 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___0 + (int )*str___1) & 2048) {
        idx = ((int )*str___1 - 48) + 26;
      } else {
        idx = (int )*str___1 - 65;
      }
      if (namedfm[idx].mark.lnum == 0L) {
        goto _L;
      } else { //Added block
      if (force) {
        _L: 
        {
        str___1 = skipwhite(str___1 + 1);
        namedfm[idx].mark.lnum = getdigits(& str___1);
        str___1 = skipwhite(str___1);
        tmp___1 = getdigits(& str___1);
        namedfm[idx].mark.col = (colnr_t )tmp___1;
        str___1 = skipwhite(str___1);
        namedfm_names[idx] = viminfo_readstring(str___1, fp___0);
        }
      }
      }
    } else {
      {
      tmp___3 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___3 + (int )*str___1) & 256) {
        goto _L___1;
      } else {
        _L___0: 
        {
        tmp = viminfo_error((char *)"Illegal file mark name", line);
        }
        if (tmp) {
          return (1);
        }
      }
    }
  }
  {
  tmp___4 = vim_fgets(line, 512, fp___0);
  }
  return (tmp___4);
}
}
void write_viminfo_filemarks(FILE *fp___0 ) 
{ 
  int i___0 ;
  char_u *name___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = get_viminfo_parameter('\'');
  }
  if (tmp == 0) {
    return;
  }
  {
  fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# File marks:\n");
  }
  if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
    {
    tmp___3 = removable(curbuf->b_ffname);
    }
    if (! tmp___3) {
      {
      name___1 = buflist_nr2name(curbuf->b_fnum, 1, 0);
      i___0 = 26;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < 35)) {
          goto while_break;
        }
        if (namedfm[i___0].mark.lnum == curwin->w_cursor.lnum) {
          if ((unsigned long )namedfm_names[i___0] == (unsigned long )((void *)0)) {
            tmp___2 = namedfm[i___0].fnum == curbuf->b_fnum;
          } else {
            if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
              {
              tmp___0 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)namedfm_names[i___0]));
              }
              if (tmp___0 == 0) {
                tmp___1 = 1;
              } else {
                tmp___1 = 0;
              }
            } else {
              tmp___1 = 0;
            }
            tmp___2 = tmp___1;
          }
          if (tmp___2) {
            goto while_break;
          }
        }
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
      vim_free((void *)name___1);
      vim_free((void *)namedfm_names[i___0]);
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i___0 > 26)) {
          goto while_break___0;
        }
        namedfm[i___0] = namedfm[i___0 - 1];
        namedfm_names[i___0] = namedfm_names[i___0 - 1];
        i___0 --;
      }
      while_break___0: /* CIL Label */ ;
      }
      namedfm[26].mark = curwin->w_cursor;
      namedfm[26].fnum = curbuf->b_fnum;
      namedfm_names[26] = (char_u *)((void *)0);
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break___1;
    }
    if (namedfm[i___0].mark.lnum == 0L) {
      goto __Cont;
    }
    if (namedfm[i___0].fnum) {
      {
      name___1 = buflist_nr2name(namedfm[i___0].fnum, 1, 0);
      }
    } else {
      name___1 = namedfm_names[i___0];
    }
    if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    if (i___0 < 26) {
      tmp___4 = i___0 + 65;
    } else {
      tmp___4 = (i___0 - 26) + 48;
    }
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\'%c  %ld  %ld  ",
            tmp___4, namedfm[i___0].mark.lnum, (long )namedfm[i___0].mark.col);
    viminfo_writestring(fp___0, name___1);
    }
    if (namedfm[i___0].fnum) {
      {
      vim_free((void *)name___1);
      }
    }
    __Cont: 
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
int removable(char_u *name___1 ) 
{ 
  char_u *p___0 ;
  char_u part[51] ;
  int retval ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  retval = 0;
  name___1 = home_replace_save((BUF *)((void *)0), name___1);
  }
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    p___0 = p_viminfo;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break;
      }
      {
      copy_option_part(& p___0, part, 51, (char *)", ");
      }
      if ((int )part[0] == 114) {
        {
        tmp = strlen((char const   *)((char *)(part + 1)));
        tmp___0 = strncasecmp((char const   *)((char *)(part + 1)), (char const   *)((char *)name___1),
                              tmp);
        }
        if (tmp___0 == 0) {
          retval = 1;
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)name___1);
    }
  }
  return (retval);
}
}
int write_viminfo_marks(FILE *fp_out ) 
{ 
  int count___2 ;
  BUF *buf___3 ;
  WIN *win ;
  int is_mark_set ;
  int i___0 ;
  int tmp ;

  {
  win = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    set_last_cursor(win);
    win = win->w_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"\n# History of marks within files (newest to oldest):\n");
  count___2 = 0;
  buf___3 = firstbuf;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    if (buf___3->b_marks_read) {
      if (buf___3->b_last_cursor.lnum != 0L) {
        is_mark_set = 1;
      } else {
        is_mark_set = 0;
        i___0 = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (i___0 < 26)) {
            goto while_break___1;
          }
          if (buf___3->b_namedm[i___0].lnum != 0L) {
            is_mark_set = 1;
            goto while_break___1;
          }
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      if (is_mark_set) {
        if ((unsigned long )buf___3->b_ffname != (unsigned long )((void *)0)) {
          if ((int )*(buf___3->b_ffname + 0) != 0) {
            {
            tmp = removable(buf___3->b_ffname);
            }
            if (! tmp) {
              {
              home_replace((BUF *)((void *)0), buf___3->b_ffname, IObuff, 1025, 1);
              fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"\n> ");
              viminfo_writestring(fp_out, IObuff);
              }
              if (buf___3->b_last_cursor.lnum != 0L) {
                {
                fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"\t\"\t%ld\t%d\n",
                        buf___3->b_last_cursor.lnum, buf___3->b_last_cursor.col);
                }
              }
              i___0 = 0;
              {
              while (1) {
                while_continue___2: /* CIL Label */ ;
                if (! (i___0 < 26)) {
                  goto while_break___2;
                }
                if (buf___3->b_namedm[i___0].lnum != 0L) {
                  {
                  fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"\t%c\t%ld\t%d\n",
                          97 + i___0, buf___3->b_namedm[i___0].lnum, buf___3->b_namedm[i___0].col);
                  }
                }
                i___0 ++;
              }
              while_break___2: /* CIL Label */ ;
              }
              count___2 ++;
            }
          }
        }
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (count___2);
}
}
void copy_viminfo_marks(char_u *line , FILE *fp_in , FILE *fp_out , int count___2 ,
                        int eof ) 
{ 
  BUF *buf___3 ;
  int num_marked_files ;
  int load_marks ;
  int copy_marks_out ;
  char_u *str___1 ;
  int i___0 ;
  char_u *p___0 ;
  char_u *name_buf ;
  long lnum ;
  int col ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  name_buf = alloc(512U);
  }
  if ((unsigned long )name_buf == (unsigned long )((void *)0)) {
    return;
  }
  {
  num_marked_files = get_viminfo_parameter('\'');
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! eof) {
      if (! (count___2 < num_marked_files)) {
        if (! ((unsigned long )fp_out == (unsigned long )((void *)0))) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
    if ((int )*(line + 0) != 62) {
      if ((int )*(line + 0) != 10) {
        if ((int )*(line + 0) != 13) {
          if ((int )*(line + 0) != 35) {
            {
            tmp = viminfo_error((char *)"Missing \'>\'", line);
            }
            if (tmp) {
              goto while_break;
            }
          }
        }
      }
      {
      eof = vim_fgets(line, 512, fp_in);
      }
      goto while_continue;
    }
    {
    str___1 = skipwhite(line + 1);
    str___1 = viminfo_readstring(str___1, fp_in);
    }
    if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
      goto while_continue;
    }
    {
    tmp___0 = strlen((char const   *)((char *)str___1));
    p___0 = str___1 + tmp___0;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )p___0 != (unsigned long )str___1) {
        if (! ((int )*p___0 == 0)) {
          {
          tmp___1 = vim_isspace((int )*p___0);
          }
          if (! tmp___1) {
            goto while_break___0;
          }
        }
      } else {
        goto while_break___0;
      }
      p___0 --;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (*p___0) {
      p___0 ++;
    }
    *p___0 = (char_u )'\000';
    copy_marks_out = 0;
    load_marks = copy_marks_out;
    if ((unsigned long )fp_out == (unsigned long )((void *)0)) {
      if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
        {
        home_replace((BUF *)((void *)0), curbuf->b_ffname, name_buf, 512, 1);
        tmp___2 = strcmp((char const   *)((char *)str___1), (char const   *)((char *)name_buf));
        }
        if (tmp___2 == 0) {
          load_marks = 1;
        }
      }
    } else {
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
          goto while_break___1;
        }
        if ((unsigned long )buf___3->b_ffname != (unsigned long )((void *)0)) {
          {
          home_replace((BUF *)((void *)0), buf___3->b_ffname, name_buf, 512, 1);
          tmp___3 = strcmp((char const   *)((char *)str___1), (char const   *)((char *)name_buf));
          }
          if (tmp___3 == 0) {
            goto while_break___1;
          }
        }
        buf___3 = buf___3->b_next;
      }
      while_break___1: /* CIL Label */ ;
      }
      if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
        {
        copy_marks_out = 1;
        fputs((char const   * __restrict  )"\n> ", (FILE * __restrict  )fp_out);
        viminfo_writestring(fp_out, str___1);
        count___2 ++;
        }
      } else { //Added block
      if (! buf___3->b_marks_read) {
        {
        copy_marks_out = 1;
        fputs((char const   * __restrict  )"\n> ", (FILE * __restrict  )fp_out);
        viminfo_writestring(fp_out, str___1);
        count___2 ++;
        }
      }
      }
    }
    {
    vim_free((void *)str___1);
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
      eof = vim_fgets(line, 512, fp_in);
      }
      if (eof) {
        goto while_break___2;
      } else { //Added block
      if (! ((int )*(line + 0) == 9)) {
        goto while_break___2;
      }
      }
      if (load_marks) {
        if ((int )*(line + 1) != 0) {
          {
          sscanf((char const   * __restrict  )((char *)line + 2), (char const   * __restrict  )"%ld %d",
                 & lnum, & col);
          }
        }
        if ((int )*(line + 1) == 34) {
          curbuf->b_last_cursor.lnum = lnum;
          curbuf->b_last_cursor.col = (colnr_t )col;
        } else {
          i___0 = (int )*(line + 1) - 97;
          if (i___0 >= 0) {
            if (i___0 < 26) {
              curbuf->b_namedm[i___0].lnum = lnum;
              curbuf->b_namedm[i___0].col = (colnr_t )col;
            }
          }
        }
      } else { //Added block
      if (copy_marks_out) {
        {
        fputs((char const   * __restrict  )((char *)line), (FILE * __restrict  )fp_out);
        }
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    if (load_marks) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)name_buf);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-bWye6avC.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
extern int fsync(int __fd ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
void mch_hide(char_u *name___1 ) ;
MEMFILE *mf_open(char_u *fname , int trunc_file ) ;
int mf_open_file(MEMFILE *mfp , char_u *fname ) ;
void mf_close(MEMFILE *mfp , int del_file ) ;
void mf_close_file(BUF *buf___3 , int getlines ) ;
BHDR *mf_new(MEMFILE *mfp , int negative , int page_count ) ;
BHDR *mf_get(MEMFILE *mfp , blocknr_t nr , int page_count ) ;
void mf_put(MEMFILE *mfp , BHDR *hp , int dirty , int infile ) ;
void mf_free(MEMFILE *mfp , BHDR *hp ) ;
int mf_sync(MEMFILE *mfp , int flags___0 ) ;
int mf_release_all(void) ;
blocknr_t mf_trans_del(MEMFILE *mfp , blocknr_t old_nr ) ;
void mf_set_ffname(MEMFILE *mfp ) ;
int mf_need_trans(MEMFILE *mfp ) ;
void ml_open_file(BUF *buf___3 ) ;
int ui_char_avail(void) ;
static long_u total_mem_used  =    (long_u )0;
static int dont_release  =    0;
static void mf_ins_hash(MEMFILE *mfp , BHDR *hp ) ;
static void mf_rem_hash(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_find_hash(MEMFILE *mfp , blocknr_t nr ) ;
static void mf_ins_used(MEMFILE *mfp , BHDR *hp ) ;
static void mf_rem_used(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_release(MEMFILE *mfp , int page_count ) ;
static BHDR *mf_alloc_bhdr(MEMFILE *mfp , int page_count ) ;
static void mf_free_bhdr(BHDR *hp ) ;
static void mf_ins_free(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_rem_free(MEMFILE *mfp ) ;
static int mf_read(MEMFILE *mfp , BHDR *hp ) ;
static int mf_write(MEMFILE *mfp , BHDR *hp ) ;
static int mf_trans_add(MEMFILE *mfp , BHDR *hp ) ;
static void mf_do_open(MEMFILE *mfp , char_u *fname , int trunc_file ) ;
MEMFILE *mf_open(char_u *fname , int trunc_file ) 
{ 
  MEMFILE *mfp ;
  int i___0 ;
  off_t size ;
  struct stat stf ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = alloc((unsigned int )sizeof(MEMFILE ));
  mfp = (MEMFILE *)tmp;
  }
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    return ((MEMFILE *)((void *)0));
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    mfp->mf_fname = (char_u *)((void *)0);
    mfp->mf_ffname = (char_u *)((void *)0);
    mfp->mf_fd = -1;
  } else {
    {
    mf_do_open(mfp, fname, trunc_file);
    }
    if (mfp->mf_fd < 0) {
      {
      vim_free((void *)mfp);
      }
      return ((MEMFILE *)((void *)0));
    }
  }
  mfp->mf_free_first = (BHDR *)((void *)0);
  mfp->mf_used_first = (BHDR *)((void *)0);
  mfp->mf_used_last = (BHDR *)((void *)0);
  mfp->mf_dirty = 0;
  mfp->mf_used_count = 0U;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 64)) {
      goto while_break;
    }
    mfp->mf_hash[i___0] = (BHDR *)((void *)0);
    mfp->mf_trans[i___0] = (NR_TRANS *)((void *)0);
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  mfp->mf_page_size = 4096U;
  if (mfp->mf_fd >= 0) {
    {
    tmp___0 = fstat(mfp->mf_fd, & stf);
    }
    if (tmp___0 == 0) {
      if (stf.st_blksize >= 1048L) {
        if (stf.st_blksize <= 50000L) {
          mfp->mf_page_size = (unsigned int )stf.st_blksize;
        }
      }
    }
  }
  if (mfp->mf_fd < 0) {
    mfp->mf_blocknr_max = (blocknr_t )0;
  } else { //Added block
  if (trunc_file) {
    mfp->mf_blocknr_max = (blocknr_t )0;
  } else {
    {
    size = lseek(mfp->mf_fd, 0L, 2);
    }
    if (size <= 0L) {
      mfp->mf_blocknr_max = (blocknr_t )0;
    } else {
      mfp->mf_blocknr_max = ((size + (off_t )mfp->mf_page_size) - 1L) / (off_t )mfp->mf_page_size;
    }
  }
  }
  mfp->mf_blocknr_min = (blocknr_t )-1;
  mfp->mf_neg_count = (blocknr_t )0;
  mfp->mf_infile_count = mfp->mf_blocknr_max;
  mfp->mf_used_count_max = (unsigned int )((p_mm * 1024L) / (long )mfp->mf_page_size);
  return (mfp);
}
}
int mf_open_file(MEMFILE *mfp , char_u *fname ) 
{ 


  {
  {
  mf_do_open(mfp, fname, 1);
  }
  if (mfp->mf_fd < 0) {
    return (0);
  }
  mfp->mf_dirty = 1;
  return (1);
}
}
void mf_close(MEMFILE *mfp , int del_file ) 
{ 
  BHDR *hp ;
  BHDR *nextp ;
  NR_TRANS *tp ;
  NR_TRANS *tpnext ;
  int i___0 ;
  int tmp ;
  BHDR *tmp___0 ;

  {
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    return;
  }
  if (mfp->mf_fd >= 0) {
    {
    tmp = close(mfp->mf_fd);
    }
    if (tmp < 0) {
      {
      emsg((char_u *)"Close error on swap file");
      }
    }
  }
  if (del_file) {
    if ((unsigned long )mfp->mf_fname != (unsigned long )((void *)0)) {
      {
      unlink((char const   *)((char *)mfp->mf_fname));
      }
    }
  }
  hp = mfp->mf_used_first;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    total_mem_used -= (long_u )((unsigned int )hp->bh_page_count * mfp->mf_page_size);
    nextp = hp->bh_next;
    mf_free_bhdr(hp);
    hp = nextp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )mfp->mf_free_first != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    tmp___0 = mf_rem_free(mfp);
    vim_free((void *)tmp___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (i___0 < 64)) {
      goto while_break___1;
    }
    tp = mfp->mf_trans[i___0];
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
        goto while_break___2;
      }
      {
      tpnext = tp->nt_next;
      vim_free((void *)tp);
      tp = tpnext;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  vim_free((void *)mfp->mf_fname);
  vim_free((void *)mfp->mf_ffname);
  vim_free((void *)mfp);
  }
  return;
}
}
void mf_close_file(BUF *buf___3 , int getlines ) 
{ 
  MEMFILE *mfp ;
  linenr_t lnum ;
  int tmp ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    return;
  } else { //Added block
  if (mfp->mf_fd < 0) {
    return;
  }
  }
  if (getlines) {
    dont_release = 1;
    lnum = (linenr_t )1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (lnum <= buf___3->b_ml.ml_line_count)) {
        goto while_break;
      }
      {
      ml_get_buf(buf___3, lnum, 0);
      lnum ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    dont_release = 0;
  }
  {
  tmp = close(mfp->mf_fd);
  }
  if (tmp < 0) {
    {
    emsg((char_u *)"Close error on swap file");
    }
  }
  mfp->mf_fd = -1;
  if ((unsigned long )mfp->mf_fname != (unsigned long )((void *)0)) {
    {
    unlink((char const   *)((char *)mfp->mf_fname));
    vim_free((void *)mfp->mf_fname);
    vim_free((void *)mfp->mf_ffname);
    mfp->mf_fname = (char_u *)((void *)0);
    mfp->mf_ffname = (char_u *)((void *)0);
    }
  }
  return;
}
}
BHDR *mf_new(MEMFILE *mfp , int negative , int page_count ) 
{ 
  BHDR *hp ;
  BHDR *freep ;
  char_u *p___0 ;
  char_u *tmp ;
  blocknr_t tmp___0 ;

  {
  {
  hp = mf_release(mfp, page_count);
  freep = mfp->mf_free_first;
  }
  if (! negative) {
    if ((unsigned long )freep != (unsigned long )((void *)0)) {
      if (freep->bh_page_count >= page_count) {
        if (freep->bh_page_count > page_count) {
          if ((unsigned long )hp == (unsigned long )((void *)0)) {
            {
            hp = mf_alloc_bhdr(mfp, page_count);
            }
            if ((unsigned long )hp == (unsigned long )((void *)0)) {
              return ((BHDR *)((void *)0));
            }
          }
          hp->bh_bnum = freep->bh_bnum;
          freep->bh_bnum += (blocknr_t )page_count;
          freep->bh_page_count -= page_count;
        } else { //Added block
        if ((unsigned long )hp == (unsigned long )((void *)0)) {
          {
          tmp = alloc(mfp->mf_page_size * (unsigned int )page_count);
          p___0 = tmp;
          }
          if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
            return ((BHDR *)((void *)0));
          }
          {
          hp = mf_rem_free(mfp);
          hp->bh_data = p___0;
          }
        } else {
          {
          freep = mf_rem_free(mfp);
          hp->bh_bnum = freep->bh_bnum;
          vim_free((void *)freep);
          }
        }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
      hp = mf_alloc_bhdr(mfp, page_count);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
        return ((BHDR *)((void *)0));
      }
    }
    if (negative) {
      tmp___0 = mfp->mf_blocknr_min;
      (mfp->mf_blocknr_min) --;
      hp->bh_bnum = tmp___0;
      (mfp->mf_neg_count) ++;
    } else {
      hp->bh_bnum = mfp->mf_blocknr_max;
      mfp->mf_blocknr_max += (blocknr_t )page_count;
    }
  }
  {
  hp->bh_flags = (char)3;
  mfp->mf_dirty = 1;
  hp->bh_page_count = page_count;
  mf_ins_used(mfp, hp);
  mf_ins_hash(mfp, hp);
  memset((void *)((char *)hp->bh_data), 0, (size_t )mfp->mf_page_size);
  }
  return (hp);
}
}
BHDR *mf_get(MEMFILE *mfp , blocknr_t nr , int page_count ) 
{ 
  BHDR *hp ;
  int tmp ;

  {
  if (nr >= mfp->mf_blocknr_max) {
    return ((BHDR *)((void *)0));
  } else { //Added block
  if (nr <= mfp->mf_blocknr_min) {
    return ((BHDR *)((void *)0));
  }
  }
  {
  hp = mf_find_hash(mfp, nr);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    if (nr < 0L) {
      return ((BHDR *)((void *)0));
    } else { //Added block
    if (nr >= mfp->mf_infile_count) {
      return ((BHDR *)((void *)0));
    }
    }
    {
    hp = mf_release(mfp, page_count);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
      hp = mf_alloc_bhdr(mfp, page_count);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
        return ((BHDR *)((void *)0));
      }
    }
    {
    hp->bh_bnum = nr;
    hp->bh_flags = (char)0;
    hp->bh_page_count = page_count;
    tmp = mf_read(mfp, hp);
    }
    if (tmp == 0) {
      {
      mf_free_bhdr(hp);
      }
      return ((BHDR *)((void *)0));
    }
  } else {
    {
    mf_rem_used(mfp, hp);
    mf_rem_hash(mfp, hp);
    }
  }
  {
  hp->bh_flags = (char )((int )hp->bh_flags | 2);
  mf_ins_used(mfp, hp);
  mf_ins_hash(mfp, hp);
  }
  return (hp);
}
}
void mf_put(MEMFILE *mfp , BHDR *hp , int dirty , int infile ) 
{ 
  int flags___0 ;

  {
  flags___0 = (int )hp->bh_flags;
  if ((flags___0 & 2) == 0) {
    {
    emsg((char_u *)"block was not locked");
    }
  }
  flags___0 &= -3;
  if (dirty) {
    flags___0 |= 1;
    mfp->mf_dirty = 1;
  }
  hp->bh_flags = (char )flags___0;
  if (infile) {
    {
    mf_trans_add(mfp, hp);
    }
  }
  return;
}
}
void mf_free(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  {
  vim_free((void *)hp->bh_data);
  mf_rem_hash(mfp, hp);
  mf_rem_used(mfp, hp);
  }
  if (hp->bh_bnum < 0L) {
    {
    vim_free((void *)hp);
    (mfp->mf_neg_count) --;
    }
  } else {
    {
    mf_ins_free(mfp, hp);
    }
  }
  return;
}
}
int mf_sync(MEMFILE *mfp , int flags___0 ) 
{ 
  int status ;
  BHDR *hp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (mfp->mf_fd < 0) {
    mfp->mf_dirty = 0;
    return (0);
  }
  status = 1;
  hp = mfp->mf_used_last;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (flags___0 & 1) {
      goto _L___0;
    } else { //Added block
    if (hp->bh_bnum >= 0L) {
      _L___0: 
      if ((int )hp->bh_flags & 1) {
        if (status == 1) {
          goto _L;
        } else { //Added block
        if (hp->bh_bnum >= 0L) {
          if (hp->bh_bnum < mfp->mf_infile_count) {
            _L: 
            if (flags___0 & 8) {
              if (hp->bh_bnum != 0L) {
                goto __Cont;
              }
            }
            {
            tmp = mf_write(mfp, hp);
            }
            if (tmp == 0) {
              if (status == 0) {
                goto while_break;
              }
              status = 0;
            }
            if (flags___0 & 2) {
              {
              tmp___0 = ui_char_avail();
              }
              if (tmp___0) {
                goto while_break;
              }
            }
          }
        }
        }
      }
    }
    }
    __Cont: 
    hp = hp->bh_prev;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    mfp->mf_dirty = 0;
  } else { //Added block
  if (status == 0) {
    mfp->mf_dirty = 0;
  }
  }
  if (flags___0 & 4) {
    if ((int )*p_sws != 0) {
      {
      tmp___2 = strcmp((char const   *)((char *)p_sws), (char const   *)((char *)"fsync"));
      }
      if (tmp___2 == 0) {
        {
        tmp___1 = fsync(mfp->mf_fd);
        }
        if (tmp___1) {
          status = 0;
        }
      } else {
        {
        sync();
        }
      }
    }
  }
  return (status);
}
}
static void mf_ins_hash(MEMFILE *mfp , BHDR *hp ) 
{ 
  BHDR *hhp ;
  int hash ;

  {
  hash = (int )(hp->bh_bnum & 63L);
  hhp = mfp->mf_hash[hash];
  hp->bh_hash_next = hhp;
  hp->bh_hash_prev = (BHDR *)((void *)0);
  if ((unsigned long )hhp != (unsigned long )((void *)0)) {
    hhp->bh_hash_prev = hp;
  }
  mfp->mf_hash[hash] = hp;
  return;
}
}
static void mf_rem_hash(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  if ((unsigned long )hp->bh_hash_prev == (unsigned long )((void *)0)) {
    mfp->mf_hash[hp->bh_bnum & 63L] = hp->bh_hash_next;
  } else {
    (hp->bh_hash_prev)->bh_hash_next = hp->bh_hash_next;
  }
  if (hp->bh_hash_next) {
    (hp->bh_hash_next)->bh_hash_prev = hp->bh_hash_prev;
  }
  return;
}
}
static BHDR *mf_find_hash(MEMFILE *mfp , blocknr_t nr ) 
{ 
  BHDR *hp ;

  {
  hp = mfp->mf_hash[nr & 63L];
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (hp->bh_bnum == nr) {
      goto while_break;
    }
    hp = hp->bh_hash_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (hp);
}
}
static void mf_ins_used(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  hp->bh_next = mfp->mf_used_first;
  mfp->mf_used_first = hp;
  hp->bh_prev = (BHDR *)((void *)0);
  if ((unsigned long )hp->bh_next == (unsigned long )((void *)0)) {
    mfp->mf_used_last = hp;
  } else {
    (hp->bh_next)->bh_prev = hp;
  }
  mfp->mf_used_count += (unsigned int )hp->bh_page_count;
  total_mem_used += (long_u )((unsigned int )hp->bh_page_count * mfp->mf_page_size);
  return;
}
}
static void mf_rem_used(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  if ((unsigned long )hp->bh_next == (unsigned long )((void *)0)) {
    mfp->mf_used_last = hp->bh_prev;
  } else {
    (hp->bh_next)->bh_prev = hp->bh_prev;
  }
  if ((unsigned long )hp->bh_prev == (unsigned long )((void *)0)) {
    mfp->mf_used_first = hp->bh_next;
  } else {
    (hp->bh_prev)->bh_next = hp->bh_next;
  }
  mfp->mf_used_count -= (unsigned int )hp->bh_page_count;
  total_mem_used -= (long_u )((unsigned int )hp->bh_page_count * mfp->mf_page_size);
  return;
}
}
static BHDR *mf_release(MEMFILE *mfp , int page_count ) 
{ 
  BHDR *hp ;
  int need_release ;
  BUF *buf___3 ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  if (dont_release) {
    return ((BHDR *)((void *)0));
  }
  if (mfp->mf_used_count >= mfp->mf_used_count_max) {
    tmp = 1;
  } else { //Added block
  if (total_mem_used >> 10 >= (long_u )p_mmt) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  need_release = tmp;
  if (mfp->mf_fd < 0) {
    if (need_release) {
      if (p_uc) {
        buf___3 = firstbuf;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
            goto while_break;
          }
          if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )mfp) {
            goto while_break;
          }
          buf___3 = buf___3->b_next;
        }
        while_break: /* CIL Label */ ;
        }
        if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
          if (buf___3->b_may_swap) {
            {
            ml_open_file(buf___3);
            }
          }
        }
      }
    }
  }
  if (mfp->mf_fd < 0) {
    return ((BHDR *)((void *)0));
  } else { //Added block
  if (! need_release) {
    return ((BHDR *)((void *)0));
  }
  }
  hp = mfp->mf_used_last;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    if (! ((int )hp->bh_flags & 2)) {
      goto while_break___0;
    }
    hp = hp->bh_prev;
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    return ((BHDR *)((void *)0));
  }
  if ((int )hp->bh_flags & 1) {
    {
    tmp___0 = mf_write(mfp, hp);
    }
    if (tmp___0 == 0) {
      return ((BHDR *)((void *)0));
    }
  }
  {
  mf_rem_used(mfp, hp);
  mf_rem_hash(mfp, hp);
  }
  if (hp->bh_page_count != page_count) {
    {
    vim_free((void *)hp->bh_data);
    tmp___1 = alloc(mfp->mf_page_size * (unsigned int )page_count);
    hp->bh_data = tmp___1;
    }
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      vim_free((void *)hp);
      }
      return ((BHDR *)((void *)0));
    }
    hp->bh_page_count = page_count;
  }
  return (hp);
}
}
int mf_release_all(void) 
{ 
  BUF *buf___3 ;
  MEMFILE *mfp ;
  BHDR *hp ;
  int retval ;
  int tmp ;

  {
  retval = 0;
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    mfp = buf___3->b_ml.ml_mfp;
    if ((unsigned long )mfp != (unsigned long )((void *)0)) {
      if (mfp->mf_fd < 0) {
        if (buf___3->b_may_swap) {
          {
          ml_open_file(buf___3);
          }
        }
      }
      if (mfp->mf_fd >= 0) {
        hp = mfp->mf_used_last;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
            goto while_break___0;
          }
          if (! ((int )hp->bh_flags & 2)) {
            if (! ((int )hp->bh_flags & 1)) {
              {
              mf_rem_used(mfp, hp);
              mf_rem_hash(mfp, hp);
              mf_free_bhdr(hp);
              hp = mfp->mf_used_last;
              retval = 1;
              }
            } else {
              {
              tmp = mf_write(mfp, hp);
              }
              if (tmp != 0) {
                {
                mf_rem_used(mfp, hp);
                mf_rem_hash(mfp, hp);
                mf_free_bhdr(hp);
                hp = mfp->mf_used_last;
                retval = 1;
                }
              } else {
                hp = hp->bh_prev;
              }
            }
          } else {
            hp = hp->bh_prev;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (retval);
}
}
static BHDR *mf_alloc_bhdr(MEMFILE *mfp , int page_count ) 
{ 
  BHDR *hp ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  tmp___1 = alloc((unsigned int )sizeof(BHDR ));
  hp = (BHDR *)tmp___1;
  }
  if ((unsigned long )hp != (unsigned long )((void *)0)) {
    {
    tmp___0 = alloc(mfp->mf_page_size * (unsigned int )page_count);
    tmp = tmp___0;
    hp->bh_data = tmp;
    }
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
      vim_free((void *)hp);
      }
      return ((BHDR *)((void *)0));
    }
    hp->bh_page_count = page_count;
  }
  return (hp);
}
}
static void mf_free_bhdr(BHDR *hp ) 
{ 


  {
  {
  vim_free((void *)hp->bh_data);
  vim_free((void *)hp);
  }
  return;
}
}
static void mf_ins_free(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  hp->bh_next = mfp->mf_free_first;
  mfp->mf_free_first = hp;
  return;
}
}
static BHDR *mf_rem_free(MEMFILE *mfp ) 
{ 
  BHDR *hp ;

  {
  hp = mfp->mf_free_first;
  mfp->mf_free_first = hp->bh_next;
  return (hp);
}
}
static int mf_read(MEMFILE *mfp , BHDR *hp ) 
{ 
  off_t offset ;
  unsigned int page_size ;
  unsigned int size ;
  __off_t tmp ;
  ssize_t tmp___0 ;

  {
  if (mfp->mf_fd < 0) {
    return (0);
  }
  {
  page_size = mfp->mf_page_size;
  offset = (off_t )page_size * hp->bh_bnum;
  size = page_size * (unsigned int )hp->bh_page_count;
  tmp = lseek(mfp->mf_fd, offset, 0);
  }
  if (tmp != offset) {
    {
    emsg((char_u *)"Seek error in swap file read");
    }
    return (0);
  }
  {
  tmp___0 = read(mfp->mf_fd, (void *)((char *)hp->bh_data), (size_t )size);
  }
  if ((unsigned int )tmp___0 != size) {
    {
    emsg((char_u *)"Read error in swap file");
    }
    return (0);
  }
  return (1);
}
}
static int mf_write(MEMFILE *mfp , BHDR *hp ) 
{ 
  off_t offset ;
  blocknr_t nr ;
  BHDR *hp2 ;
  unsigned int page_size ;
  unsigned int page_count ;
  unsigned int size ;
  int tmp ;
  __off_t tmp___0 ;
  BHDR *tmp___1 ;
  ssize_t tmp___2 ;

  {
  if (mfp->mf_fd < 0) {
    return (0);
  }
  if (hp->bh_bnum < 0L) {
    {
    tmp = mf_trans_add(mfp, hp);
    }
    if (tmp == 0) {
      return (0);
    }
  }
  page_size = mfp->mf_page_size;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    nr = hp->bh_bnum;
    if (nr > mfp->mf_infile_count) {
      {
      nr = mfp->mf_infile_count;
      hp2 = mf_find_hash(mfp, nr);
      }
    } else {
      hp2 = hp;
    }
    {
    offset = (off_t )page_size * nr;
    tmp___0 = lseek(mfp->mf_fd, offset, 0);
    }
    if (tmp___0 != offset) {
      {
      emsg((char_u *)"Seek error in swap file write");
      }
      return (0);
    }
    if ((unsigned long )hp2 == (unsigned long )((void *)0)) {
      page_count = 1U;
    } else {
      page_count = (unsigned int )hp2->bh_page_count;
    }
    size = page_size * page_count;
    if ((unsigned long )hp2 == (unsigned long )((void *)0)) {
      tmp___1 = hp;
    } else {
      tmp___1 = hp2;
    }
    {
    tmp___2 = write(mfp->mf_fd, (void const   *)((char *)tmp___1->bh_data), (size_t )size);
    }
    if ((unsigned int )tmp___2 != size) {
      if (! did_swapwrite_msg) {
        {
        emsg((char_u *)"Write error in swap file");
        }
      }
      did_swapwrite_msg = 1;
      return (0);
    }
    did_swapwrite_msg = 0;
    if ((unsigned long )hp2 != (unsigned long )((void *)0)) {
      hp2->bh_flags = (char )((int )hp2->bh_flags & -2);
    }
    if (nr + (blocknr_t )page_count > mfp->mf_infile_count) {
      mfp->mf_infile_count = nr + (blocknr_t )page_count;
    }
    if (nr == hp->bh_bnum) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int mf_trans_add(MEMFILE *mfp , BHDR *hp ) 
{ 
  BHDR *freep ;
  blocknr_t new_bnum ;
  int hash ;
  NR_TRANS *np___0 ;
  int page_count ;
  char_u *tmp ;

  {
  if (hp->bh_bnum >= 0L) {
    return (1);
  }
  {
  tmp = alloc((unsigned int )sizeof(NR_TRANS ));
  np___0 = (NR_TRANS *)tmp;
  }
  if ((unsigned long )np___0 == (unsigned long )((void *)0)) {
    return (0);
  }
  freep = mfp->mf_free_first;
  page_count = hp->bh_page_count;
  if ((unsigned long )freep != (unsigned long )((void *)0)) {
    if (freep->bh_page_count >= page_count) {
      new_bnum = freep->bh_bnum;
      if (freep->bh_page_count > page_count) {
        freep->bh_bnum += (blocknr_t )page_count;
        freep->bh_page_count -= page_count;
      } else {
        {
        freep = mf_rem_free(mfp);
        vim_free((void *)freep);
        }
      }
    } else {
      new_bnum = mfp->mf_blocknr_max;
      mfp->mf_blocknr_max += (blocknr_t )page_count;
    }
  } else {
    new_bnum = mfp->mf_blocknr_max;
    mfp->mf_blocknr_max += (blocknr_t )page_count;
  }
  {
  np___0->nt_old_bnum = hp->bh_bnum;
  np___0->nt_new_bnum = new_bnum;
  mf_rem_hash(mfp, hp);
  hp->bh_bnum = new_bnum;
  mf_ins_hash(mfp, hp);
  hash = (int )(np___0->nt_old_bnum & 63L);
  np___0->nt_next = mfp->mf_trans[hash];
  mfp->mf_trans[hash] = np___0;
  }
  if ((unsigned long )np___0->nt_next != (unsigned long )((void *)0)) {
    (np___0->nt_next)->nt_prev = np___0;
  }
  np___0->nt_prev = (NR_TRANS *)((void *)0);
  return (1);
}
}
blocknr_t mf_trans_del(MEMFILE *mfp , blocknr_t old_nr ) 
{ 
  int hash ;
  NR_TRANS *np___0 ;
  blocknr_t new_bnum ;

  {
  hash = (int )(old_nr & 63L);
  np___0 = mfp->mf_trans[hash];
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )np___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (np___0->nt_old_bnum == old_nr) {
      goto while_break;
    }
    np___0 = np___0->nt_next;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )np___0 == (unsigned long )((void *)0)) {
    return (old_nr);
  }
  (mfp->mf_neg_count) --;
  new_bnum = np___0->nt_new_bnum;
  if ((unsigned long )np___0->nt_prev != (unsigned long )((void *)0)) {
    (np___0->nt_prev)->nt_next = np___0->nt_next;
  } else {
    mfp->mf_trans[hash] = np___0->nt_next;
  }
  if ((unsigned long )np___0->nt_next != (unsigned long )((void *)0)) {
    (np___0->nt_next)->nt_prev = np___0->nt_prev;
  }
  {
  vim_free((void *)np___0);
  }
  return (new_bnum);
}
}
void mf_set_ffname(MEMFILE *mfp ) 
{ 


  {
  {
  mfp->mf_ffname = FullName_save(mfp->mf_fname, 0);
  }
  return;
}
}
void mf_fullname(MEMFILE *mfp ) 
{ 


  {
  if ((unsigned long )mfp != (unsigned long )((void *)0)) {
    if ((unsigned long )mfp->mf_fname != (unsigned long )((void *)0)) {
      if ((unsigned long )mfp->mf_ffname != (unsigned long )((void *)0)) {
        {
        vim_free((void *)mfp->mf_fname);
        mfp->mf_fname = mfp->mf_ffname;
        mfp->mf_ffname = (char_u *)((void *)0);
        }
      }
    }
  }
  return;
}
}
int mf_need_trans(MEMFILE *mfp ) 
{ 
  int tmp ;

  {
  if ((unsigned long )mfp->mf_fname != (unsigned long )((void *)0)) {
    if (mfp->mf_neg_count > 0L) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static void mf_do_open(MEMFILE *mfp , char_u *fname , int trunc_file ) 
{ 
  int tmp ;

  {
  {
  mfp->mf_fname = fname;
  mf_set_ffname(mfp);
  }
  if (trunc_file) {
    {
    unlink((char const   *)((char *)mfp->mf_fname));
    }
  }
  if (trunc_file) {
    tmp = 194;
  } else {
    tmp = 0;
  }
  {
  mfp->mf_fd = open((char const   *)((char *)mfp->mf_fname), tmp, (mode_t )384);
  }
  if (mfp->mf_fd < 0) {
    {
    vim_free((void *)mfp->mf_fname);
    vim_free((void *)mfp->mf_ffname);
    mfp->mf_fname = (char_u *)((void *)0);
    mfp->mf_ffname = (char_u *)((void *)0);
    }
  } else {
    {
    mch_hide(mfp->mf_fname);
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-hl89qSPY.i","-O0")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
char *Version ;
int mch_get_uname(uid_t uid , char_u *s , int len___0 ) ;
void ml_open_files(void) ;
void ml_close_all(int del_file ) ;
void ml_close_notmod(void) ;
char_u *ml_get_pos(FPOS *pos___0 ) ;
int ml_line_alloced(void) ;
void ml_setdirty(BUF *buf___3 , int flag ) ;
void msg_outnum(long n ) ;
void msg_home_replace(char_u *fname ) ;
int get_number(int colon ) ;
char_u *concat_fnames(char_u *fname1 , char_u *fname2 , int sep ) ;
int get_user_name(char_u *buf___3 , int len___0 ) ;
static linenr_t lowest_marked  =    (linenr_t )0;
static void set_b0_fname(ZERO_BL *b0p , BUF *buf___3 ) ;
static void swapfile_info(char_u *fname ) ;
static int recov_file_names(char_u **names , char_u *path , int prepend_dot ) ;
static int ml_append_int(BUF *buf___3 , linenr_t lnum , char_u *line , colnr_t len___0 ,
                         int newfile , int mark ) ;
static int ml_delete_int(BUF *buf___3 , linenr_t lnum , int message ) ;
static char_u *findswapname(BUF *buf___3 , char_u **dirp , char_u *old_fname ) ;
static void ml_flush_line(BUF *buf___3 ) ;
static BHDR *ml_new_data(MEMFILE *mfp , int negative , int page_count ) ;
static BHDR *ml_new_ptr(MEMFILE *mfp ) ;
static BHDR *ml_find_line(BUF *buf___3 , linenr_t lnum , int action ) ;
static int ml_add_stack(BUF *buf___3 ) ;
static char_u *makeswapname(BUF *buf___3 , char_u *dir_name ) ;
static void ml_lineadd(BUF *buf___3 , int count___2 ) ;
static int b0_magic_wrong(ZERO_BL *b0p ) ;
static int fnamecmp_ino(char_u *fname_c , char_u *fname_s , long ino_block0 ) ;
static void long_to_char(long n , char_u *s ) ;
static long char_to_long(char_u *s ) ;
static char_u *make_percent_swname(char_u *dir , char_u *name___1 ) ;
static void ml_updatechunk(BUF *buf___3 , long line , int len___0 , int updtype ) ;
int ml_open(void) 
{ 
  MEMFILE *mfp ;
  BHDR *hp ;
  ZERO_BL *b0p ;
  PTR_BL *pp ;
  DATA_BL *dp ;
  long tmp ;

  {
  hp = (BHDR *)((void *)0);
  curbuf->b_ml.ml_stack_size = 0;
  curbuf->b_ml.ml_stack = (IPTR *)((void *)0);
  curbuf->b_ml.ml_stack_top = 0;
  curbuf->b_ml.ml_locked = (BHDR *)((void *)0);
  curbuf->b_ml.ml_line_lnum = (linenr_t )0;
  curbuf->b_ml.ml_chunksize = (ML_CHUNKSIZE *)((void *)0);
  if (p_uc) {
    if (curbuf->b_p_swf) {
      curbuf->b_may_swap = 1;
    } else {
      curbuf->b_may_swap = 0;
    }
  } else {
    curbuf->b_may_swap = 0;
  }
  {
  mfp = mf_open((char_u *)((void *)0), 1);
  }
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    goto error;
  }
  {
  curbuf->b_ml.ml_mfp = mfp;
  curbuf->b_ml.ml_flags = 1;
  curbuf->b_ml.ml_line_count = (linenr_t )1;
  hp = mf_new(mfp, 0, 1);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    goto error;
  }
  if (hp->bh_bnum != 0L) {
    {
    emsg((char_u *)"didn\'t get block nr 0?");
    }
    goto error;
  }
  b0p = (ZERO_BL *)hp->bh_data;
  b0p->b0_id[0] = (char_u )'b';
  b0p->b0_id[1] = (char_u )'0';
  if (curbuf->b_changed) {
    b0p->b0_fname[899] = (char_u )85;
  } else {
    b0p->b0_fname[899] = (char_u )0;
  }
  {
  b0p->b0_magic_long = 808530483L;
  b0p->b0_magic_int = 539042339;
  b0p->b0_magic_short = (short)4627;
  b0p->b0_magic_char = (char_u )85;
  strncpy((char * __restrict  )((char *)(b0p->b0_version)), (char const   * __restrict  )((char *)"VIM "),
          (size_t )4);
  strncpy((char * __restrict  )((char *)(b0p->b0_version + 4)), (char const   * __restrict  )Version,
          (size_t )6);
  set_b0_fname(b0p, curbuf);
  long_to_char((long )mfp->mf_page_size, b0p->b0_page_size);
  get_user_name(b0p->b0_uname, 40);
  b0p->b0_uname[39] = (char_u )'\000';
  mch_get_host_name(b0p->b0_hname, 40);
  b0p->b0_hname[39] = (char_u )'\000';
  tmp = mch_get_pid();
  long_to_char(tmp, b0p->b0_pid);
  mf_put(mfp, hp, 1, 0);
  }
  if (! curbuf->b_help) {
    {
    mf_sync(mfp, 0);
    }
  }
  {
  hp = ml_new_ptr(mfp);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    goto error;
  }
  if (hp->bh_bnum != 1L) {
    {
    emsg((char_u *)"didn\'t get block nr 1?");
    }
    goto error;
  }
  {
  pp = (PTR_BL *)hp->bh_data;
  pp->pb_count = (short_u )1;
  pp->pb_pointer[0].pe_bnum = (blocknr_t )2;
  pp->pb_pointer[0].pe_page_count = 1;
  pp->pb_pointer[0].pe_old_lnum = (linenr_t )1;
  pp->pb_pointer[0].pe_line_count = (linenr_t )1;
  mf_put(mfp, hp, 1, 0);
  hp = ml_new_data(mfp, 0, 1);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    goto error;
  }
  if (hp->bh_bnum != 2L) {
    {
    emsg((char_u *)"didn\'t get block nr 2?");
    }
    goto error;
  }
  dp = (DATA_BL *)hp->bh_data;
  (dp->db_txt_start) --;
  dp->db_index[0] = dp->db_txt_start;
  dp->db_free = (unsigned int )((unsigned long )dp->db_free - (1UL + sizeof(unsigned int )));
  dp->db_line_count = (linenr_t )1;
  *((char_u *)dp + dp->db_txt_start) = (char_u )'\000';
  return (1);
  error: 
  if ((unsigned long )mfp != (unsigned long )((void *)0)) {
    if (hp) {
      {
      mf_put(mfp, hp, 0, 0);
      }
    }
    {
    mf_close(mfp, 1);
    }
  }
  curbuf->b_ml.ml_mfp = (MEMFILE *)((void *)0);
  return (0);
}
}
void ml_setname(void) 
{ 
  int success___0 ;
  MEMFILE *mfp ;
  char_u *fname ;
  char_u *dirp ;
  int tmp ;
  int tmp___0 ;

  {
  success___0 = 0;
  mfp = curbuf->b_ml.ml_mfp;
  if (mfp->mf_fd < 0) {
    if (p_uc) {
      {
      ml_open_file(curbuf);
      }
    }
    return;
  }
  dirp = p_dir;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! ((int )*dirp == 0))) {
      goto while_break;
    }
    {
    fname = findswapname(curbuf, & dirp, mfp->mf_fname);
    }
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    {
    tmp = strcmp((char const   *)((char *)fname), (char const   *)((char *)mfp->mf_fname));
    }
    if (tmp == 0) {
      {
      vim_free((void *)fname);
      success___0 = 1;
      }
      goto while_break;
    }
    if (mfp->mf_fd >= 0) {
      {
      close(mfp->mf_fd);
      mfp->mf_fd = -1;
      }
    }
    {
    tmp___0 = vim_rename(mfp->mf_fname, fname);
    }
    if (tmp___0 == 0) {
      {
      success___0 = 1;
      vim_free((void *)mfp->mf_fname);
      mfp->mf_fname = fname;
      vim_free((void *)mfp->mf_ffname);
      mf_set_ffname(mfp);
      }
      goto while_break;
    }
    {
    vim_free((void *)fname);
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  if (mfp->mf_fd == -1) {
    {
    mfp->mf_fd = open((char const   *)((char *)mfp->mf_fname), 2, 0);
    }
    if (mfp->mf_fd < 0) {
      {
      emsg((char_u *)"Oops, lost the swap file!!!");
      }
      return;
    }
  }
  if (! success___0) {
    {
    emsg((char_u *)"Could not rename swap file");
    }
  }
  return;
}
}
void ml_open_files(void) 
{ 
  BUF *buf___3 ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (! buf___3->b_p_ro) {
      {
      ml_open_file(buf___3);
      }
    } else { //Added block
    if (buf___3->b_changed) {
      {
      ml_open_file(buf___3);
      }
    }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void ml_open_file(BUF *buf___3 ) 
{ 
  MEMFILE *mfp ;
  char_u *fname ;
  char_u *dirp ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    return;
  } else { //Added block
  if (mfp->mf_fd >= 0) {
    return;
  } else { //Added block
  if (! buf___3->b_p_swf) {
    return;
  }
  }
  }
  dirp = p_dir;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! ((int )*dirp == 0))) {
      goto while_break;
    }
    {
    fname = findswapname(buf___3, & dirp, (char_u *)((void *)0));
    }
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    {
    tmp___0 = mf_open_file(mfp, fname);
    }
    if (tmp___0 == 1) {
      {
      tmp = mf_sync(mfp, 8);
      }
      if (tmp == 1) {
        goto while_break;
      }
      {
      mf_close_file(buf___3, 0);
      }
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )mfp->mf_fname == (unsigned long )((void *)0)) {
    need_wait_return = 1;
    no_wait_return ++;
    if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
      tmp___1 = (char_u *)"No File";
    } else {
      tmp___1 = buf___3->b_fname;
    }
    {
    emsg2((char_u *)"Unable to open swap file for \"%s\", recovery impossible", tmp___1);
    no_wait_return --;
    }
  }
  buf___3->b_may_swap = 0;
  return;
}
}
void check_need_swap(int newfile ) 
{ 


  {
  if (curbuf->b_may_swap) {
    if (! curbuf->b_p_ro) {
      {
      ml_open_file(curbuf);
      }
    } else { //Added block
    if (! newfile) {
      {
      ml_open_file(curbuf);
      }
    }
    }
  }
  return;
}
}
void ml_close(BUF *buf___3 , int del_file ) 
{ 


  {
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return;
  }
  {
  mf_close(buf___3->b_ml.ml_mfp, del_file);
  }
  if (buf___3->b_ml.ml_line_lnum != 0L) {
    if (buf___3->b_ml.ml_flags & 2) {
      {
      vim_free((void *)buf___3->b_ml.ml_line_ptr);
      }
    }
  }
  {
  vim_free((void *)buf___3->b_ml.ml_stack);
  vim_free((void *)buf___3->b_ml.ml_chunksize);
  buf___3->b_ml.ml_chunksize = (ML_CHUNKSIZE *)((void *)0);
  buf___3->b_ml.ml_mfp = (MEMFILE *)((void *)0);
  }
  return;
}
}
void ml_close_all(int del_file ) 
{ 
  BUF *buf___3 ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    ml_close(buf___3, del_file);
    buf___3 = buf___3->b_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_deltempdir();
  }
  return;
}
}
void ml_close_notmod(void) 
{ 
  BUF *buf___3 ;
  int tmp ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = buf_changed(buf___3);
    }
    if (! tmp) {
      {
      ml_close(buf___3, 1);
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void ml_timestamp(BUF *buf___3 ) 
{ 
  MEMFILE *mfp ;
  BHDR *hp ;
  ZERO_BL *b0p ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    return;
  } else {
    {
    hp = mf_get(mfp, (blocknr_t )0, 1);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      return;
    }
  }
  b0p = (ZERO_BL *)hp->bh_data;
  if ((int )b0p->b0_id[0] != 98) {
    {
    emsg((char_u *)"ml_timestamp: Didn\'t get block 0??");
    }
  } else { //Added block
  if ((int )b0p->b0_id[1] != 48) {
    {
    emsg((char_u *)"ml_timestamp: Didn\'t get block 0??");
    }
  } else {
    {
    set_b0_fname(b0p, buf___3);
    }
  }
  }
  {
  mf_put(mfp, hp, 1, 0);
  }
  return;
}
}
static void set_b0_fname(ZERO_BL *b0p , BUF *buf___3 ) 
{ 
  struct stat st ;
  size_t flen ;
  size_t ulen ;
  char_u uname___0[40] ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    b0p->b0_fname[0] = (char_u )'\000';
  } else {
    {
    home_replace((BUF *)((void *)0), buf___3->b_ffname, b0p->b0_fname, 900, 1);
    }
    if ((int )b0p->b0_fname[0] == 126) {
      {
      flen = strlen((char const   *)((char *)(b0p->b0_fname)));
      tmp = get_user_name(uname___0, 40);
      }
      if (tmp == 0) {
        {
        strncpy((char * __restrict  )((char *)(b0p->b0_fname)), (char const   * __restrict  )((char *)buf___3->b_ffname),
                (size_t )900);
        }
      } else {
        {
        ulen = strlen((char const   *)((char *)(uname___0)));
        }
        if (ulen + flen > 899UL) {
          {
          strncpy((char * __restrict  )((char *)(b0p->b0_fname)), (char const   * __restrict  )((char *)buf___3->b_ffname),
                  (size_t )900);
          }
        } else {
          {
          memmove((void *)((char *)((b0p->b0_fname + ulen) + 1)), (void const   *)((char *)(b0p->b0_fname + 1)),
                  flen);
          memmove((void *)((char *)(b0p->b0_fname + 1)), (void const   *)((char *)(uname___0)),
                  ulen);
          }
        }
      }
    }
    {
    tmp___0 = stat((char const   * __restrict  )((char *)buf___3->b_ffname), (struct stat * __restrict  )(& st));
    }
    if (tmp___0 >= 0) {
      {
      long_to_char(st.st_mtim.tv_sec, b0p->b0_mtime);
      long_to_char((long )st.st_ino, b0p->b0_ino);
      buf___3->b_mtime = st.st_mtim.tv_sec;
      buf___3->b_mtime_read = st.st_mtim.tv_sec;
      }
    } else {
      {
      long_to_char(0L, b0p->b0_mtime);
      long_to_char(0L, b0p->b0_ino);
      buf___3->b_mtime = 0L;
      buf___3->b_mtime_read = 0L;
      }
    }
  }
  return;
}
}
void ml_recover(void) 
{ 
  BUF *buf___3 ;
  MEMFILE *mfp ;
  char_u *fname ;
  BHDR *hp ;
  ZERO_BL *b0p ;
  PTR_BL *pp ;
  DATA_BL *dp ;
  IPTR *ip ;
  blocknr_t bnum ;
  int page_count ;
  struct stat org_stat ;
  struct stat swp_stat ;
  int len___0 ;
  int directly ;
  linenr_t lnum ;
  char_u *p___0 ;
  int i___0 ;
  long error ;
  int cannot_open ;
  linenr_t line_count ;
  int has_error ;
  int idx ;
  int top ;
  int txt_start ;
  off_t size ;
  int called_from_main ;
  int serious_error ;
  long mtime ;
  int attr ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  linenr_t tmp___10 ;
  linenr_t tmp___11 ;
  linenr_t tmp___12 ;
  int tmp___13 ;
  linenr_t tmp___14 ;
  linenr_t tmp___15 ;
  linenr_t tmp___16 ;
  linenr_t tmp___17 ;
  linenr_t tmp___18 ;
  linenr_t tmp___19 ;

  {
  buf___3 = (BUF *)((void *)0);
  mfp = (MEMFILE *)((void *)0);
  hp = (BHDR *)((void *)0);
  serious_error = 1;
  recoverymode = 1;
  called_from_main = (unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0);
  attr = highlight_attr[3];
  fname = curbuf->b_fname;
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    fname = (char_u *)"";
  }
  {
  tmp = strlen((char const   *)((char *)fname));
  len___0 = (int )tmp;
  }
  if (len___0 >= 4) {
    {
    tmp___0 = strncasecmp((char const   *)((char *)((fname + len___0) - 4)), (char const   *)((char *)".sw"),
                          (size_t )3);
    }
    if (tmp___0 == 0) {
      {
      directly = 1;
      fname = vim_strsave(fname);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    directly = 0;
    len___0 = recover_names(& fname, 0, 0);
    }
    if (len___0 == 0) {
      {
      emsg2((char_u *)"No swap file found for %s", fname);
      }
      goto theend;
    }
    if (len___0 == 1) {
      i___0 = 1;
    } else {
      {
      recover_names(& fname, 1, 0);
      msg_putchar('\n');
      msg_puts((char_u *)"Enter number of swap file to use (0 to quit): ");
      i___0 = get_number(0);
      }
      if (i___0 < 1) {
        goto theend;
      } else { //Added block
      if (i___0 > len___0) {
        goto theend;
      }
      }
    }
    {
    recover_names(& fname, 0, i___0);
    }
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    goto theend;
  }
  if (called_from_main) {
    {
    tmp___1 = ml_open();
    }
    if (tmp___1 == 0) {
      {
      getout(1);
      }
    }
  }
  {
  tmp___2 = alloc((unsigned int )sizeof(BUF ));
  buf___3 = (BUF *)tmp___2;
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
    vim_free((void *)fname);
    }
    goto theend;
  }
  {
  buf___3->b_ml.ml_stack_size = 0;
  buf___3->b_ml.ml_stack = (IPTR *)((void *)0);
  buf___3->b_ml.ml_stack_top = 0;
  buf___3->b_ml.ml_line_lnum = (linenr_t )0;
  buf___3->b_ml.ml_locked = (BHDR *)((void *)0);
  buf___3->b_ml.ml_flags = 0;
  p___0 = vim_strsave(fname);
  mfp = mf_open(fname, 0);
  }
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    goto _L___0;
  } else { //Added block
  if (mfp->mf_fd < 0) {
    _L___0: 
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      {
      emsg2((char_u *)"Cannot open %s", p___0);
      vim_free((void *)p___0);
      }
    }
    goto theend;
  }
  }
  {
  vim_free((void *)p___0);
  buf___3->b_ml.ml_mfp = mfp;
  mfp->mf_page_size = 1048U;
  hp = mf_get(mfp, (blocknr_t )0, 1);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
    msg_start();
    msg_puts_attr((char_u *)"Unable to read block 0 from ", attr | 4096);
    msg_outtrans_attr(mfp->mf_fname, attr | 4096);
    msg_puts_attr((char_u *)"\nMaybe no changes were made or Vim did not update the swap file.",
                  attr | 4096);
    msg_end();
    }
    goto theend;
  }
  {
  b0p = (ZERO_BL *)hp->bh_data;
  tmp___3 = strncmp((char const   *)((char *)(b0p->b0_version)), (char const   *)((char *)"VIM 3.0"),
                    (size_t )7);
  }
  if (tmp___3 == 0) {
    {
    msg_start();
    msg_puts_attr((char_u *)"The file ", 4096);
    msg_outtrans_attr(mfp->mf_fname, 4096);
    msg_puts_attr((char_u *)" cannot be used with this version of Vim.\n", 4096);
    msg_puts_attr((char_u *)"Use Vim version 3.0.\n", 4096);
    msg_end();
    }
    goto theend;
  }
  if ((int )b0p->b0_id[0] != 98) {
    {
    emsg2((char_u *)"%s is not a swap file", mfp->mf_fname);
    }
    goto theend;
  } else { //Added block
  if ((int )b0p->b0_id[1] != 48) {
    {
    emsg2((char_u *)"%s is not a swap file", mfp->mf_fname);
    }
    goto theend;
  }
  }
  {
  tmp___4 = b0_magic_wrong(b0p);
  }
  if (tmp___4) {
    {
    msg_start();
    msg_puts_attr((char_u *)"The file ", attr | 4096);
    msg_outtrans_attr(mfp->mf_fname, attr | 4096);
    msg_puts_attr((char_u *)" cannot be used on this computer.\n", attr | 4096);
    msg_puts_attr((char_u *)"The file was created on ", attr | 4096);
    b0p->b0_fname[0] = (char_u )'\000';
    msg_puts_attr(b0p->b0_hname, attr | 4096);
    msg_puts_attr((char_u *)",\nor the file has been damaged.", attr | 4096);
    msg_end();
    }
    goto theend;
  }
  {
  tmp___6 = char_to_long(b0p->b0_page_size);
  }
  if (mfp->mf_page_size != (unsigned int )tmp___6) {
    {
    tmp___5 = char_to_long(b0p->b0_page_size);
    mfp->mf_page_size = (unsigned int )tmp___5;
    size = lseek(mfp->mf_fd, 0L, 2);
    }
    if (size <= 0L) {
      mfp->mf_blocknr_max = (blocknr_t )0;
    } else {
      mfp->mf_blocknr_max = size / (off_t )mfp->mf_page_size;
    }
    mfp->mf_infile_count = mfp->mf_blocknr_max;
  }
  if (directly) {
    {
    expand_env(b0p->b0_fname, NameBuff, 1024);
    tmp___7 = setfname(NameBuff, (char_u *)((void *)0), 1);
    }
    if (tmp___7 == 0) {
      goto theend;
    }
  }
  {
  home_replace((BUF *)((void *)0), mfp->mf_fname, NameBuff, 1024, 1);
  smsg((char_u *)"Using swap file \"%s\"", NameBuff);
  }
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    {
    strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)"No File"));
    }
  } else {
    {
    home_replace((BUF *)((void *)0), curbuf->b_ffname, NameBuff, 1024, 1);
    }
  }
  {
  smsg((char_u *)"Original file \"%s\"", NameBuff);
  msg_putchar('\n');
  mtime = char_to_long(b0p->b0_mtime);
  }
  if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
    {
    tmp___8 = stat((char const   * __restrict  )((char *)curbuf->b_ffname), (struct stat * __restrict  )(& org_stat));
    }
    if (tmp___8 != -1) {
      {
      tmp___9 = stat((char const   * __restrict  )((char *)mfp->mf_fname), (struct stat * __restrict  )(& swp_stat));
      }
      if (tmp___9 != -1) {
        if (org_stat.st_mtim.tv_sec > swp_stat.st_mtim.tv_sec) {
          {
          emsg((char_u *)"Warning: Original file may have been changed");
          }
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (org_stat.st_mtim.tv_sec != mtime) {
        {
        emsg((char_u *)"Warning: Original file may have been changed");
        }
      }
      }
    }
  }
  {
  out_flush();
  mf_put(mfp, hp, 0, 0);
  hp = (BHDR *)((void *)0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! (curbuf->b_ml.ml_flags & 1))) {
      goto while_break;
    }
    {
    ml_delete((linenr_t )1, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  bnum = (blocknr_t )1;
  page_count = 1;
  lnum = (linenr_t )0;
  line_count = (linenr_t )0;
  idx = 0;
  error = 0L;
  buf___3->b_ml.ml_stack_top = 0;
  buf___3->b_ml.ml_stack = (IPTR *)((void *)0);
  buf___3->b_ml.ml_stack_size = 0;
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    cannot_open = 1;
  } else {
    cannot_open = 0;
  }
  serious_error = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (! got_int)) {
      goto while_break___0;
    }
    if ((unsigned long )hp != (unsigned long )((void *)0)) {
      {
      mf_put(mfp, hp, 0, 0);
      }
    }
    {
    hp = mf_get(mfp, bnum, page_count);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      if (bnum == 1L) {
        {
        emsg2((char_u *)"Unable to read block 1 from %s", mfp->mf_fname);
        }
        goto theend;
      }
      {
      error ++;
      tmp___10 = lnum;
      lnum ++;
      ml_append(tmp___10, (char_u *)"???MANY LINES MISSING", (colnr_t )0, 1);
      }
    } else {
      pp = (PTR_BL *)hp->bh_data;
      if ((int )pp->pb_id == (112 << 8) + 116) {
        if (idx == 0) {
          if (line_count != 0L) {
            i___0 = 0;
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (! (i___0 < (int )pp->pb_count)) {
                goto while_break___1;
              }
              line_count -= pp->pb_pointer[i___0].pe_line_count;
              i___0 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            if (line_count != 0L) {
              {
              error ++;
              tmp___11 = lnum;
              lnum ++;
              ml_append(tmp___11, (char_u *)"???LINE COUNT WRONG", (colnr_t )0, 1);
              }
            }
          }
        }
        if ((int )pp->pb_count == 0) {
          {
          tmp___12 = lnum;
          lnum ++;
          ml_append(tmp___12, (char_u *)"???EMPTY BLOCK", (colnr_t )0, 1);
          error ++;
          }
        } else { //Added block
        if (idx < (int )pp->pb_count) {
          if (pp->pb_pointer[idx].pe_bnum < 0L) {
            if (! cannot_open) {
              {
              line_count = pp->pb_pointer[idx].pe_line_count;
              tmp___13 = readfile(curbuf->b_ffname, (char_u *)((void *)0), lnum, pp->pb_pointer[idx].pe_old_lnum - 1L,
                                  line_count, 0);
              }
              if (tmp___13 == 0) {
                cannot_open = 1;
              } else {
                lnum += line_count;
              }
            }
            if (cannot_open) {
              {
              error ++;
              tmp___14 = lnum;
              lnum ++;
              ml_append(tmp___14, (char_u *)"???LINES MISSING", (colnr_t )0, 1);
              }
            }
            idx ++;
            goto __Cont;
          }
          {
          top = ml_add_stack(buf___3);
          }
          if (top < 0) {
            error ++;
            goto while_break___0;
          }
          ip = buf___3->b_ml.ml_stack + top;
          ip->ip_bnum = bnum;
          ip->ip_index = idx;
          bnum = pp->pb_pointer[idx].pe_bnum;
          line_count = pp->pb_pointer[idx].pe_line_count;
          page_count = pp->pb_pointer[idx].pe_page_count;
          goto __Cont;
        }
        }
      } else {
        dp = (DATA_BL *)hp->bh_data;
        if ((int )dp->db_id != (100 << 8) + 97) {
          if (bnum == 1L) {
            {
            emsg2((char_u *)"Block 1 ID wrong (%s not a .swp file?)", mfp->mf_fname);
            }
            goto theend;
          }
          {
          error ++;
          tmp___15 = lnum;
          lnum ++;
          ml_append(tmp___15, (char_u *)"???BLOCK MISSING", (colnr_t )0, 1);
          }
        } else {
          has_error = 0;
          if ((unsigned int )page_count * mfp->mf_page_size != dp->db_txt_end) {
            {
            tmp___16 = lnum;
            lnum ++;
            ml_append(tmp___16, (char_u *)"??? from here until ???END lines may be messed up",
                      (colnr_t )0, 1);
            error ++;
            has_error = 1;
            dp->db_txt_end = (unsigned int )page_count * mfp->mf_page_size;
            }
          }
          *(((char_u *)dp + dp->db_txt_end) - 1) = (char_u )'\000';
          if (line_count != dp->db_line_count) {
            {
            tmp___17 = lnum;
            lnum ++;
            ml_append(tmp___17, (char_u *)"??? from here until ???END lines may have been inserted/deleted",
                      (colnr_t )0, 1);
            error ++;
            has_error = 1;
            }
          }
          i___0 = 0;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! ((linenr_t )i___0 < dp->db_line_count)) {
              goto while_break___2;
            }
            txt_start = (int )(dp->db_index[i___0] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
            if ((unsigned long )txt_start <= sizeof(DATA_BL ) - sizeof(unsigned int )) {
              p___0 = (char_u *)"???";
              error ++;
            } else { //Added block
            if (txt_start >= (int )dp->db_txt_end) {
              p___0 = (char_u *)"???";
              error ++;
            } else {
              p___0 = (char_u *)dp + txt_start;
            }
            }
            {
            tmp___18 = lnum;
            lnum ++;
            ml_append(tmp___18, p___0, (colnr_t )0, 1);
            i___0 ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          if (has_error) {
            {
            tmp___19 = lnum;
            lnum ++;
            ml_append(tmp___19, (char_u *)"???END", (colnr_t )0, 1);
            }
          }
        }
      }
    }
    if (buf___3->b_ml.ml_stack_top == 0) {
      goto while_break___0;
    }
    (buf___3->b_ml.ml_stack_top) --;
    ip = buf___3->b_ml.ml_stack + buf___3->b_ml.ml_stack_top;
    bnum = ip->ip_bnum;
    idx = ip->ip_index + 1;
    page_count = 1;
    __Cont: 
    {
    line_breakcheck();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  ml_delete(curbuf->b_ml.ml_line_count, 0);
  curbuf->b_flags |= 1;
  recoverymode = 0;
  }
  if (got_int) {
    {
    emsg((char_u *)"Recovery Interrupted");
    }
  } else { //Added block
  if (error) {
    {
    emsg((char_u *)"Errors detected while recovering; look for lines starting with ???");
    }
  } else {
    {
    msg((char_u *)"Recovery completed. You should check if everything is OK.");
    msg_puts((char_u *)"\n(You might want to write out this file under another name\n");
    msg_puts((char_u *)"and run diff with the original file to check for changes)\n");
    msg_puts((char_u *)"Delete the .swp file afterwards.\n\n");
    cmdline_row = msg_row;
    }
  }
  }
  theend: 
  recoverymode = 0;
  if ((unsigned long )mfp != (unsigned long )((void *)0)) {
    if ((unsigned long )hp != (unsigned long )((void *)0)) {
      {
      mf_put(mfp, hp, 0, 0);
      }
    }
    {
    mf_close(mfp, 0);
    }
  }
  {
  vim_free((void *)buf___3);
  }
  if (serious_error) {
    if (called_from_main) {
      {
      ml_close(curbuf, 1);
      }
    } else {
      {
      apply_autocmds((EVENT_T )7, (char_u *)((void *)0), curbuf->b_fname, 0, curbuf);
      }
    }
  } else {
    {
    apply_autocmds((EVENT_T )7, (char_u *)((void *)0), curbuf->b_fname, 0, curbuf);
    }
  }
  return;
}
}
int recover_names(char_u **fname , int list , int nr ) 
{ 
  int num_names ;
  char_u *names[6] ;
  char_u *tail ;
  char_u *p___0 ;
  int num_files ;
  int file_count ;
  char_u **files ;
  int i___0 ;
  char_u *dirp ;
  char_u *dir_name ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct stat st ;
  char_u *swapname ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;

  {
  file_count = 0;
  if (list) {
    {
    msg((char_u *)"Swap files found:");
    msg_putchar('\n');
    }
  }
  {
  tmp = strlen((char const   *)((char *)p_dir));
  dir_name = alloc((unsigned int )tmp + 1U);
  dirp = p_dir;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )dir_name != (unsigned long )((void *)0)) {
      if (! *dirp) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    copy_option_part(& dirp, dir_name, 31000, (char *)",");
    }
    if ((int )*(dir_name + 0) == 46) {
      if ((int )*(dir_name + 1) == 0) {
        if ((unsigned long )fname == (unsigned long )((void *)0)) {
          {
          names[0] = vim_strsave((char_u *)"*.sw?");
          names[1] = vim_strsave((char_u *)".*.sw?");
          names[2] = vim_strsave((char_u *)".sw?");
          num_names = 3;
          }
        } else { //Added block
        if ((unsigned long )*fname == (unsigned long )((void *)0)) {
          {
          names[0] = vim_strsave((char_u *)"*.sw?");
          names[1] = vim_strsave((char_u *)".*.sw?");
          names[2] = vim_strsave((char_u *)".sw?");
          num_names = 3;
          }
        } else {
          {
          num_names = recov_file_names(names, *fname, 1);
          }
        }
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      {
      names[0] = concat_fnames(dir_name, (char_u *)"*.sw?", 1);
      names[1] = concat_fnames(dir_name, (char_u *)".*.sw?", 1);
      names[2] = concat_fnames(dir_name, (char_u *)".sw?", 1);
      num_names = 3;
      }
    } else { //Added block
    if ((unsigned long )*fname == (unsigned long )((void *)0)) {
      {
      names[0] = concat_fnames(dir_name, (char_u *)"*.sw?", 1);
      names[1] = concat_fnames(dir_name, (char_u *)".*.sw?", 1);
      names[2] = concat_fnames(dir_name, (char_u *)".sw?", 1);
      num_names = 3;
      }
    } else {
      {
      tmp___0 = strlen((char const   *)((char *)dir_name));
      p___0 = dir_name + tmp___0;
      tmp___1 = vim_ispathsep((int )*(p___0 + -1));
      }
      if (tmp___1) {
        if ((int )*(p___0 + -1) == (int )*(p___0 + -2)) {
          {
          tail = make_percent_swname(dir_name, *fname);
          }
        } else {
          {
          tail = gettail(*fname);
          tail = concat_fnames(dir_name, tail, 1);
          }
        }
      } else {
        {
        tail = gettail(*fname);
        tail = concat_fnames(dir_name, tail, 1);
        }
      }
      if ((unsigned long )tail == (unsigned long )((void *)0)) {
        num_names = 0;
      } else {
        {
        num_names = recov_file_names(names, tail, 0);
        vim_free((void *)tail);
        }
      }
    }
    }
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < num_names)) {
        goto while_break___0;
      }
      if ((unsigned long )names[i___0] == (unsigned long )((void *)0)) {
        i___0 = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (i___0 < num_names)) {
            goto while_break___1;
          }
          {
          vim_free((void *)names[i___0]);
          i___0 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        num_names = 0;
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (num_names == 0) {
      num_files = 0;
    } else {
      {
      tmp___2 = expand_wildcards(num_names, names, & num_files, & files, 34);
      }
      if (tmp___2 == 0) {
        num_files = 0;
      }
    }
    if ((int )*dirp == 0) {
      if (file_count + num_files == 0) {
        if ((unsigned long )fname != (unsigned long )((void *)0)) {
          if ((unsigned long )*fname != (unsigned long )((void *)0)) {
            {
            swapname = modname(*fname, (char_u *)".swp", 1);
            }
            if ((unsigned long )swapname != (unsigned long )((void *)0)) {
              {
              tmp___4 = stat((char const   * __restrict  )((char *)swapname), (struct stat * __restrict  )(& st));
              }
              if (tmp___4 != -1) {
                {
                tmp___3 = alloc((unsigned int )sizeof(char_u *));
                files = (char_u **)tmp___3;
                }
                if ((unsigned long )files != (unsigned long )((void *)0)) {
                  *(files + 0) = swapname;
                  swapname = (char_u *)((void *)0);
                  num_files = 1;
                }
              }
              {
              vim_free((void *)swapname);
              }
            }
          }
        }
      }
    }
    if ((unsigned long )curbuf->b_ml.ml_mfp != (unsigned long )((void *)0)) {
      p___0 = (curbuf->b_ml.ml_mfp)->mf_fname;
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        i___0 = 0;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (i___0 < num_files)) {
            goto while_break___2;
          }
          {
          tmp___5 = fullpathcmp(p___0, *(files + i___0), 1);
          }
          if (tmp___5 & 1) {
            {
            vim_free((void *)*(files + i___0));
            num_files --;
            }
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              if (! (i___0 < num_files)) {
                goto while_break___3;
              }
              *(files + i___0) = *(files + (i___0 + 1));
              i___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    if (nr) {
      file_count += num_files;
      if (nr <= file_count) {
        {
        *fname = vim_strsave(*(files + (((nr - 1) + num_files) - file_count)));
        dirp = (char_u *)"";
        }
      }
    } else { //Added block
    if (list) {
      if ((int )*(dir_name + 0) == 46) {
        if ((int )*(dir_name + 1) == 0) {
          if ((unsigned long )fname == (unsigned long )((void *)0)) {
            {
            msg_puts((char_u *)"   In current directory:\n");
            }
          } else { //Added block
          if ((unsigned long )*fname == (unsigned long )((void *)0)) {
            {
            msg_puts((char_u *)"   In current directory:\n");
            }
          } else {
            {
            msg_puts((char_u *)"   Using specified name:\n");
            }
          }
          }
        } else {
          {
          msg_puts((char_u *)"   In directory ");
          msg_home_replace(dir_name);
          msg_puts((char_u *)":\n");
          }
        }
      } else {
        {
        msg_puts((char_u *)"   In directory ");
        msg_home_replace(dir_name);
        msg_puts((char_u *)":\n");
        }
      }
      if (num_files) {
        i___0 = 0;
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          if (! (i___0 < num_files)) {
            goto while_break___4;
          }
          {
          file_count ++;
          msg_outnum((long )file_count);
          msg_puts((char_u *)".    ");
          tmp___6 = gettail(*(files + i___0));
          msg_puts(tmp___6);
          msg_putchar('\n');
          swapfile_info(*(files + i___0));
          i___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
        msg_puts((char_u *)"      -- none --\n");
        }
      }
      {
      out_flush();
      }
    } else {
      file_count += num_files;
    }
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! (i___0 < num_names)) {
        goto while_break___5;
      }
      {
      vim_free((void *)names[i___0]);
      i___0 ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
    FreeWild(num_files, files);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)dir_name);
  }
  return (file_count);
}
}
static char_u *make_percent_swname(char_u *dir , char_u *name___1 ) 
{ 
  char_u *d ;
  char_u *s ;
  char_u *f ;
  char_u *p___0 ;
  char_u *tmp ;
  size_t tmp___0 ;
  int tmp___2 ;

  {
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    tmp = name___1;
  } else {
    tmp = (char_u *)"";
  }
  {
  f = fix_fname(tmp);
  d = (char_u *)((void *)0);
  }
  if ((unsigned long )f != (unsigned long )((void *)0)) {
    {
    tmp___0 = strlen((char const   *)((char *)f));
    s = alloc((unsigned int )(tmp___0 + 1UL));
    }
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      d = s;
      p___0 = f;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! *p___0) {
          goto while_break;
        }
        {
        tmp___2 = vim_ispathsep((int )*p___0);
        }
        if (tmp___2) {
          *d = (char_u )'%';
        } else {
          *d = *p___0;
        }
        p___0 ++;
        d ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
      *d = (char_u )0;
      d = concat_fnames(dir, s, 1);
      vim_free((void *)s);
      }
    }
    {
    vim_free((void *)f);
    }
  }
  return (d);
}
}
static int process_still_running  ;
static void swapfile_info(char_u *fname ) 
{ 
  struct stat st ;
  int fd ;
  struct block0 b0 ;
  time_t x___0 ;
  char *tmp ;
  char_u uname___0[40] ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;

  {
  {
  tmp___1 = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
  }
  if (tmp___1 != -1) {
    {
    msg_puts((char_u *)"             dated: ");
    x___0 = st.st_mtim.tv_sec;
    tmp = ctime((time_t const   *)(& x___0));
    msg_puts((char_u *)tmp);
    tmp___0 = mch_get_uname(st.st_uid, uname___0, 40);
    }
    if (tmp___0 == 1) {
      {
      msg_puts((char_u *)"          owned by: ");
      msg_outtrans(uname___0);
      msg_putchar('\n');
      }
    }
  }
  {
  fd = open((char const   *)((char *)fname), 0, 0);
  }
  if (fd >= 0) {
    {
    tmp___9 = read(fd, (void *)((char *)(& b0)), sizeof(b0));
    }
    if ((unsigned long )tmp___9 == sizeof(b0)) {
      {
      tmp___8 = strncmp((char const   *)((char *)(b0.b0_version)), (char const   *)((char *)"VIM 3.0"),
                        (size_t )7);
      }
      if (tmp___8 == 0) {
        {
        msg_puts((char_u *)"         [from Vim version 3.0]");
        }
      } else { //Added block
      if ((int )b0.b0_id[0] != 98) {
        {
        msg_puts((char_u *)"         [is not a swap file]");
        }
      } else { //Added block
      if ((int )b0.b0_id[1] != 48) {
        {
        msg_puts((char_u *)"         [is not a swap file]");
        }
      } else {
        {
        msg_puts((char_u *)"         file name: ");
        }
        if ((int )b0.b0_fname[0] == 0) {
          {
          msg_puts((char_u *)"[No File]");
          }
        } else {
          {
          msg_outtrans(b0.b0_fname);
          }
        }
        {
        msg_puts((char_u *)"\n          modified: ");
        }
        if (b0.b0_fname[899]) {
          tmp___2 = "YES";
        } else {
          tmp___2 = "no";
        }
        {
        msg_puts((char_u *)tmp___2);
        }
        if ((int )b0.b0_hname[0] != 0) {
          {
          msg_puts((char_u *)"\n         host name: ");
          msg_outtrans(b0.b0_hname);
          }
        }
        if ((int )b0.b0_uname[0] != 0) {
          {
          msg_puts((char_u *)"\n         user name: ");
          msg_outtrans(b0.b0_uname);
          }
        }
        {
        tmp___6 = char_to_long(b0.b0_pid);
        }
        if (tmp___6 != 0L) {
          {
          msg_puts((char_u *)"\n        process ID: ");
          tmp___3 = char_to_long(b0.b0_pid);
          msg_outnum(tmp___3);
          tmp___4 = char_to_long(b0.b0_pid);
          tmp___5 = kill((pid_t )tmp___4, 0);
          }
          if (tmp___5 == 0) {
            {
            msg_puts((char_u *)" (still running)");
            process_still_running = 1;
            }
          }
        }
        {
        tmp___7 = b0_magic_wrong(& b0);
        }
        if (tmp___7) {
          {
          msg_puts((char_u *)"\n         [not usable on this computer]");
          }
        }
      }
      }
      }
    } else {
      {
      msg_puts((char_u *)"         [cannot be read]");
      }
    }
    {
    close(fd);
    }
  } else {
    {
    msg_puts((char_u *)"         [cannot be opened]");
    }
  }
  {
  msg_putchar('\n');
  }
  return;
}
}
static int recov_file_names(char_u **names , char_u *path , int prepend_dot ) 
{ 
  int num_names ;
  char_u *p___0 ;
  int i___0 ;
  int shortname ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  shortname = curbuf->b_shortname;
  curbuf->b_shortname = 0;
  num_names = 0;
  if (prepend_dot) {
    {
    *(names + num_names) = modname(path, (char_u *)".sw?", 1);
    }
    if ((unsigned long )*(names + num_names) == (unsigned long )((void *)0)) {
      goto end;
    }
    num_names ++;
  }
  {
  *(names + num_names) = concat_fnames(path, (char_u *)".sw?", 0);
  }
  if ((unsigned long )*(names + num_names) == (unsigned long )((void *)0)) {
    goto end;
  }
  if (num_names >= 1) {
    {
    p___0 = *(names + (num_names - 1));
    tmp = strlen((char const   *)((char *)*(names + (num_names - 1))));
    tmp___0 = strlen((char const   *)((char *)*(names + num_names)));
    i___0 = (int )(tmp - tmp___0);
    }
    if (i___0 > 0) {
      p___0 += i___0;
    }
    {
    tmp___1 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)*(names + num_names)));
    }
    if (tmp___1 != 0) {
      num_names ++;
    } else {
      {
      vim_free((void *)*(names + num_names));
      }
    }
  } else {
    num_names ++;
  }
  {
  curbuf->b_shortname = 1;
  *(names + num_names) = modname(path, (char_u *)".sw?", 0);
  }
  if ((unsigned long )*(names + num_names) == (unsigned long )((void *)0)) {
    goto end;
  }
  {
  p___0 = *(names + num_names);
  tmp___2 = strlen((char const   *)((char *)*(names + num_names)));
  tmp___3 = strlen((char const   *)((char *)*(names + (num_names - 1))));
  i___0 = (int )(tmp___2 - tmp___3);
  }
  if (i___0 > 0) {
    p___0 += i___0;
  }
  {
  tmp___4 = strcmp((char const   *)((char *)*(names + (num_names - 1))), (char const   *)((char *)p___0));
  }
  if (tmp___4 == 0) {
    {
    vim_free((void *)*(names + num_names));
    }
  } else {
    num_names ++;
  }
  end: 
  curbuf->b_shortname = shortname;
  return (num_names);
}
}
void ml_sync_all(int check_file , int check_char ) 
{ 
  BUF *buf___3 ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      goto __Cont;
    } else { //Added block
    if ((unsigned long )(buf___3->b_ml.ml_mfp)->mf_fname == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    }
    {
    ml_flush_line(buf___3);
    ml_find_line(buf___3, (linenr_t )0, 2);
    tmp___0 = buf_changed(buf___3);
    }
    if (tmp___0) {
      if (check_file) {
        {
        tmp___1 = mf_need_trans(buf___3->b_ml.ml_mfp);
        }
        if (tmp___1) {
          if ((unsigned long )buf___3->b_ffname != (unsigned long )((void *)0)) {
            {
            tmp = stat((char const   * __restrict  )((char *)buf___3->b_ffname), (struct stat * __restrict  )(& st));
            }
            if (tmp == -1) {
              {
              ml_preserve(buf___3, 0);
              need_check_timestamps = 1;
              }
            } else { //Added block
            if (st.st_mtim.tv_sec != buf___3->b_mtime_read) {
              {
              ml_preserve(buf___3, 0);
              need_check_timestamps = 1;
              }
            }
            }
          }
        }
      }
    }
    if ((buf___3->b_ml.ml_mfp)->mf_dirty) {
      if (check_char) {
        tmp___2 = 2;
      } else {
        tmp___2 = 0;
      }
      {
      tmp___5 = buf_changed(buf___3);
      }
      if (tmp___5) {
        tmp___4 = 4;
      } else {
        tmp___4 = 0;
      }
      {
      mf_sync(buf___3->b_ml.ml_mfp, tmp___2 | tmp___4);
      }
      if (check_char) {
        {
        tmp___6 = ui_char_avail();
        }
        if (tmp___6) {
          goto while_break;
        }
      }
    }
    __Cont: 
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void ml_preserve(BUF *buf___3 , int message ) 
{ 
  BHDR *hp ;
  linenr_t lnum ;
  MEMFILE *mfp ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if ((unsigned long )mfp->mf_fname == (unsigned long )((void *)0)) {
    _L: 
    if (message) {
      {
      emsg((char_u *)"Cannot preserve, there is no swap file");
      }
    }
    return;
  }
  }
  {
  ml_flush_line(buf___3);
  ml_find_line(buf___3, (linenr_t )0, 2);
  status = mf_sync(mfp, 5);
  buf___3->b_ml.ml_stack_top = 0;
  tmp___1 = mf_need_trans(mfp);
  }
  if (tmp___1) {
    lnum = (linenr_t )1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = mf_need_trans(mfp);
      }
      if (tmp) {
        if (! (lnum <= buf___3->b_ml.ml_line_count)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      {
      hp = ml_find_line(buf___3, lnum, 19);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
        status = 0;
        goto theend;
      }
      lnum = buf___3->b_ml.ml_locked_high + 1L;
    }
    while_break: /* CIL Label */ ;
    }
    {
    ml_find_line(buf___3, (linenr_t )0, 2);
    tmp___0 = mf_sync(mfp, 5);
    }
    if (tmp___0 == 0) {
      status = 0;
    }
    buf___3->b_ml.ml_stack_top = 0;
  }
  theend: 
  if (message) {
    if (status == 1) {
      {
      msg((char_u *)"File preserved");
      }
    } else {
      {
      emsg((char_u *)"Preserve failed");
      }
    }
  }
  return;
}
}
char_u *ml_get(linenr_t lnum ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, lnum, 0);
  }
  return (tmp);
}
}
char_u *ml_get_pos(FPOS *pos___0 ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, pos___0->lnum, 0);
  }
  return (tmp + pos___0->col);
}
}
char_u *ml_get_curline(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, curwin->w_cursor.lnum, 0);
  }
  return (tmp);
}
}
char_u *ml_get_cursor(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, curwin->w_cursor.lnum, 0);
  }
  return (tmp + curwin->w_cursor.col);
}
}
char_u *ml_get_buf(BUF *buf___3 , linenr_t lnum , int will_change ) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  char_u *ptr ;

  {
  if (lnum > buf___3->b_ml.ml_line_count) {
    {
    emsgn((char_u *)"ml_get: invalid lnum: %ld", lnum);
    }
    errorret: 
    {
    strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"???"));
    }
    return (IObuff);
  }
  if (lnum <= 0L) {
    lnum = (linenr_t )1;
  }
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return ((char_u *)"");
  }
  if (buf___3->b_ml.ml_line_lnum != lnum) {
    {
    ml_flush_line(buf___3);
    hp = ml_find_line(buf___3, lnum, 19);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
      emsgn((char_u *)"ml_get: cannot find line %ld", lnum);
      }
      goto errorret;
    }
    dp = (DATA_BL *)hp->bh_data;
    ptr = (char_u *)dp + (dp->db_index[lnum - buf___3->b_ml.ml_locked_low] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
    buf___3->b_ml.ml_line_ptr = ptr;
    buf___3->b_ml.ml_line_lnum = lnum;
    buf___3->b_ml.ml_flags &= -3;
  }
  if (will_change) {
    buf___3->b_ml.ml_flags |= 12;
  }
  return (buf___3->b_ml.ml_line_ptr);
}
}
int ml_line_alloced(void) 
{ 


  {
  return (curbuf->b_ml.ml_flags & 2);
}
}
int ml_append(linenr_t lnum , char_u *line , colnr_t len___0 , int newfile ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (curbuf->b_syn_change_lnum > lnum + 1L) {
    curbuf->b_syn_change_lnum = lnum + 1L;
  }
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    {
    tmp = open_buffer(0);
    }
    if (tmp == 0) {
      return (0);
    }
  }
  if (curbuf->b_ml.ml_line_lnum != 0L) {
    {
    ml_flush_line(curbuf);
    }
  }
  {
  tmp___0 = ml_append_int(curbuf, lnum, line, len___0, newfile, 0);
  }
  return (tmp___0);
}
}
static int ml_append_int(BUF *buf___3 , linenr_t lnum , char_u *line , colnr_t len___0 ,
                         int newfile , int mark ) 
{ 
  int i___0 ;
  int line_count ;
  int offset ;
  int from ;
  int to ;
  int space_needed ;
  int page_size ;
  int page_count ;
  int db_idx ;
  BHDR *hp ;
  MEMFILE *mfp ;
  DATA_BL *dp ;
  PTR_BL *pp ;
  IPTR *ip ;
  size_t tmp ;
  linenr_t tmp___0 ;
  long line_count_left ;
  long line_count_right ;
  int page_count_left ;
  int page_count_right ;
  BHDR *hp_left ;
  BHDR *hp_right ;
  BHDR *hp_new ;
  int lines_moved ;
  int data_moved ;
  int total_moved ;
  DATA_BL *dp_right ;
  DATA_BL *dp_left ;
  int stack_idx ;
  int in_left ;
  int lineadd ;
  blocknr_t bnum_left ;
  blocknr_t bnum_right ;
  linenr_t lnum_left ;
  linenr_t lnum_right ;
  int pb_idx ;
  PTR_BL *pp_new ;

  {
  if (lnum > buf___3->b_ml.ml_line_count) {
    return (0);
  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return (0);
  }
  }
  if (lowest_marked) {
    if (lowest_marked > lnum) {
      lowest_marked = lnum + 1L;
    }
  }
  if (len___0 == 0U) {
    {
    tmp = strlen((char const   *)((char *)line));
    len___0 = (colnr_t )(tmp + 1UL);
    }
  }
  space_needed = (int )((unsigned long )len___0 + sizeof(unsigned int ));
  mfp = buf___3->b_ml.ml_mfp;
  page_size = (int )mfp->mf_page_size;
  if (lnum == 0L) {
    tmp___0 = (linenr_t )1;
  } else {
    tmp___0 = lnum;
  }
  {
  hp = ml_find_line(buf___3, tmp___0, 18);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    return (0);
  }
  buf___3->b_ml.ml_flags &= -2;
  if (lnum == 0L) {
    db_idx = -1;
  } else {
    db_idx = (int )(lnum - buf___3->b_ml.ml_locked_low);
  }
  line_count = (int )(buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low);
  dp = (DATA_BL *)hp->bh_data;
  if ((int )dp->db_free < space_needed) {
    if (db_idx == line_count - 1) {
      if (lnum < buf___3->b_ml.ml_line_count) {
        {
        (buf___3->b_ml.ml_locked_lineadd) --;
        (buf___3->b_ml.ml_locked_high) --;
        hp = ml_find_line(buf___3, lnum + 1L, 18);
        }
        if ((unsigned long )hp == (unsigned long )((void *)0)) {
          return (0);
        }
        db_idx = -1;
        line_count = (int )(buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low);
        dp = (DATA_BL *)hp->bh_data;
      }
    }
  }
  (buf___3->b_ml.ml_line_count) ++;
  if ((int )dp->db_free >= space_needed) {
    dp->db_txt_start -= len___0;
    dp->db_free -= (unsigned int )space_needed;
    (dp->db_line_count) ++;
    if (line_count > db_idx + 1) {
      if (db_idx < 0) {
        offset = (int )dp->db_txt_end;
      } else {
        offset = (int )(dp->db_index[db_idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
      }
      {
      memmove((void *)((char *)dp + dp->db_txt_start), (void const   *)(((char *)dp + dp->db_txt_start) + len___0),
              (size_t )((unsigned int )offset - (dp->db_txt_start + len___0)));
      i___0 = line_count - 1;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 > db_idx)) {
          goto while_break;
        }
        dp->db_index[i___0 + 1] = dp->db_index[i___0] - len___0;
        i___0 --;
      }
      while_break: /* CIL Label */ ;
      }
      dp->db_index[db_idx + 1] = (colnr_t )offset - len___0;
    } else {
      dp->db_index[db_idx + 1] = dp->db_txt_start;
    }
    {
    memmove((void *)((char *)dp + dp->db_index[db_idx + 1]), (void const   *)((char *)line),
            (size_t )len___0);
    }
    if (mark) {
      dp->db_index[db_idx + 1] |= 1U << (sizeof(unsigned int ) * 8UL - 1UL);
    }
    buf___3->b_ml.ml_flags |= 4;
    if (! newfile) {
      buf___3->b_ml.ml_flags |= 8;
    }
  } else {
    data_moved = 0;
    total_moved = 0;
    if (db_idx < 0) {
      lines_moved = 0;
      in_left = 1;
    } else {
      lines_moved = (line_count - db_idx) - 1;
      if (lines_moved == 0) {
        in_left = 0;
      } else {
        data_moved = (int )((dp->db_index[db_idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))) - dp->db_txt_start);
        total_moved = (int )((unsigned long )data_moved + (unsigned long )lines_moved * sizeof(unsigned int ));
        if ((int )dp->db_free + total_moved >= space_needed) {
          in_left = 1;
          space_needed = total_moved;
        } else {
          in_left = 0;
          space_needed += total_moved;
        }
      }
    }
    {
    page_count = (int )(((((unsigned long )space_needed + (sizeof(DATA_BL ) - sizeof(unsigned int ))) + (unsigned long )page_size) - 1UL) / (unsigned long )page_size);
    hp_new = ml_new_data(mfp, newfile, page_count);
    }
    if ((unsigned long )hp_new == (unsigned long )((void *)0)) {
      (buf___3->b_ml.ml_locked_lineadd) --;
      (buf___3->b_ml.ml_locked_high) --;
      return (0);
    }
    if (db_idx < 0) {
      hp_left = hp_new;
      hp_right = hp;
      line_count_left = 0L;
      line_count_right = (long )line_count;
    } else {
      hp_left = hp;
      hp_right = hp_new;
      line_count_left = (long )line_count;
      line_count_right = 0L;
    }
    dp_right = (DATA_BL *)hp_right->bh_data;
    dp_left = (DATA_BL *)hp_left->bh_data;
    bnum_left = hp_left->bh_bnum;
    bnum_right = hp_right->bh_bnum;
    page_count_left = hp_left->bh_page_count;
    page_count_right = hp_right->bh_page_count;
    if (! in_left) {
      dp_right->db_txt_start -= len___0;
      dp_right->db_free = (unsigned int )((unsigned long )dp_right->db_free - ((unsigned long )len___0 + sizeof(unsigned int )));
      dp_right->db_index[0] = dp_right->db_txt_start;
      if (mark) {
        dp_right->db_index[0] |= 1U << (sizeof(unsigned int ) * 8UL - 1UL);
      }
      {
      memmove((void *)((char *)dp_right + dp_right->db_txt_start), (void const   *)((char *)line),
              (size_t )len___0);
      line_count_right ++;
      }
    }
    if (lines_moved) {
      {
      dp_right->db_txt_start -= (unsigned int )data_moved;
      dp_right->db_free -= (unsigned int )total_moved;
      memmove((void *)((char *)dp_right + dp_right->db_txt_start), (void const   *)((char *)dp_left + dp_left->db_txt_start),
              (size_t )data_moved);
      offset = (int )(dp_right->db_txt_start - dp_left->db_txt_start);
      dp_left->db_txt_start += (unsigned int )data_moved;
      dp_left->db_free += (unsigned int )total_moved;
      to = (int )line_count_right;
      from = db_idx + 1;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((long )from < line_count_left)) {
          goto while_break___0;
        }
        dp_right->db_index[to] = dp->db_index[from] + (unsigned int )offset;
        from ++;
        to ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      line_count_right += (long )lines_moved;
      line_count_left -= (long )lines_moved;
    }
    if (in_left) {
      dp_left->db_txt_start -= len___0;
      dp_left->db_free = (unsigned int )((unsigned long )dp_left->db_free - ((unsigned long )len___0 + sizeof(unsigned int )));
      dp_left->db_index[line_count_left] = dp_left->db_txt_start;
      if (mark) {
        dp_left->db_index[line_count_left] |= 1U << (sizeof(unsigned int ) * 8UL - 1UL);
      }
      {
      memmove((void *)((char *)dp_left + dp_left->db_txt_start), (void const   *)((char *)line),
              (size_t )len___0);
      line_count_left ++;
      }
    }
    if (db_idx < 0) {
      lnum_left = lnum + 1L;
      lnum_right = (linenr_t )0;
    } else {
      lnum_left = (linenr_t )0;
      if (in_left) {
        lnum_right = lnum + 2L;
      } else {
        lnum_right = lnum + 1L;
      }
    }
    dp_left->db_line_count = line_count_left;
    dp_right->db_line_count = line_count_right;
    if (lines_moved) {
      buf___3->b_ml.ml_flags |= 4;
    } else { //Added block
    if (in_left) {
      buf___3->b_ml.ml_flags |= 4;
    }
    }
    if (! newfile) {
      if (db_idx >= 0) {
        if (in_left) {
          buf___3->b_ml.ml_flags |= 8;
        }
      }
    }
    {
    mf_put(mfp, hp_new, 1, 0);
    lineadd = buf___3->b_ml.ml_locked_lineadd;
    buf___3->b_ml.ml_locked_lineadd = 0;
    ml_find_line(buf___3, (linenr_t )0, 2);
    stack_idx = buf___3->b_ml.ml_stack_top - 1;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (stack_idx >= 0)) {
        goto while_break___1;
      }
      {
      ip = buf___3->b_ml.ml_stack + stack_idx;
      pb_idx = ip->ip_index;
      hp = mf_get(mfp, ip->ip_bnum, 1);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
        return (0);
      }
      pp = (PTR_BL *)hp->bh_data;
      if ((int )pp->pb_id != (112 << 8) + 116) {
        {
        emsg((char_u *)"pointer block id wrong 3");
        mf_put(mfp, hp, 0, 0);
        }
        return (0);
      }
      if ((int )pp->pb_count < (int )pp->pb_count_max) {
        if (pb_idx + 1 < (int )pp->pb_count) {
          {
          memmove((void *)((char *)(& pp->pb_pointer[pb_idx + 2])), (void const   *)((char *)(& pp->pb_pointer[pb_idx + 1])),
                  (size_t )(((int )pp->pb_count - pb_idx) - 1) * sizeof(PTR_EN ));
          }
        }
        pp->pb_count = (short_u )((int )pp->pb_count + 1);
        pp->pb_pointer[pb_idx].pe_line_count = line_count_left;
        pp->pb_pointer[pb_idx].pe_bnum = bnum_left;
        pp->pb_pointer[pb_idx].pe_page_count = page_count_left;
        pp->pb_pointer[pb_idx + 1].pe_line_count = line_count_right;
        pp->pb_pointer[pb_idx + 1].pe_bnum = bnum_right;
        pp->pb_pointer[pb_idx + 1].pe_page_count = page_count_right;
        if (lnum_left != 0L) {
          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;
        }
        if (lnum_right != 0L) {
          pp->pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;
        }
        {
        mf_put(mfp, hp, 1, 0);
        buf___3->b_ml.ml_stack_top = stack_idx + 1;
        }
        if (lineadd) {
          {
          (buf___3->b_ml.ml_stack_top) --;
          ml_lineadd(buf___3, lineadd);
          (buf___3->b_ml.ml_stack + buf___3->b_ml.ml_stack_top)->ip_high += (linenr_t )lineadd;
          (buf___3->b_ml.ml_stack_top) ++;
          }
        }
        goto while_break___1;
      } else {
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
          hp_new = ml_new_ptr(mfp);
          }
          if ((unsigned long )hp_new == (unsigned long )((void *)0)) {
            return (0);
          }
          pp_new = (PTR_BL *)hp_new->bh_data;
          if (hp->bh_bnum != 1L) {
            goto while_break___2;
          }
          {
          memmove((void *)((char *)pp_new), (void const   *)((char *)pp), (size_t )page_size);
          pp->pb_count = (short_u )1;
          pp->pb_pointer[0].pe_bnum = hp_new->bh_bnum;
          pp->pb_pointer[0].pe_line_count = buf___3->b_ml.ml_line_count;
          pp->pb_pointer[0].pe_old_lnum = (linenr_t )1;
          pp->pb_pointer[0].pe_page_count = 1;
          mf_put(mfp, hp, 1, 0);
          hp = hp_new;
          pp = pp_new;
          ip->ip_index = 0;
          stack_idx ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        total_moved = ((int )pp->pb_count - pb_idx) - 1;
        if (total_moved) {
          {
          memmove((void *)((char *)(& pp_new->pb_pointer[0])), (void const   *)((char *)(& pp->pb_pointer[pb_idx + 1])),
                  (size_t )total_moved * sizeof(PTR_EN ));
          pp_new->pb_count = (short_u )total_moved;
          pp->pb_count = (short_u )((int )pp->pb_count - (total_moved - 1));
          pp->pb_pointer[pb_idx + 1].pe_bnum = bnum_right;
          pp->pb_pointer[pb_idx + 1].pe_line_count = line_count_right;
          pp->pb_pointer[pb_idx + 1].pe_page_count = page_count_right;
          }
          if (lnum_right) {
            pp->pb_pointer[pb_idx + 1].pe_old_lnum = lnum_right;
          }
        } else {
          pp_new->pb_count = (short_u )1;
          pp_new->pb_pointer[0].pe_bnum = bnum_right;
          pp_new->pb_pointer[0].pe_line_count = line_count_right;
          pp_new->pb_pointer[0].pe_page_count = page_count_right;
          pp_new->pb_pointer[0].pe_old_lnum = lnum_right;
        }
        pp->pb_pointer[pb_idx].pe_bnum = bnum_left;
        pp->pb_pointer[pb_idx].pe_line_count = line_count_left;
        pp->pb_pointer[pb_idx].pe_page_count = page_count_left;
        if (lnum_left) {
          pp->pb_pointer[pb_idx].pe_old_lnum = lnum_left;
        }
        lnum_left = (linenr_t )0;
        lnum_right = (linenr_t )0;
        line_count_right = 0L;
        i___0 = 0;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (! (i___0 < (int )pp_new->pb_count)) {
            goto while_break___3;
          }
          line_count_right += pp_new->pb_pointer[i___0].pe_line_count;
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        line_count_left = 0L;
        i___0 = 0;
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          if (! (i___0 < (int )pp->pb_count)) {
            goto while_break___4;
          }
          line_count_left += pp->pb_pointer[i___0].pe_line_count;
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
        bnum_left = hp->bh_bnum;
        bnum_right = hp_new->bh_bnum;
        page_count_left = 1;
        page_count_right = 1;
        mf_put(mfp, hp, 1, 0);
        mf_put(mfp, hp_new, 1, 0);
        }
      }
      stack_idx --;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (stack_idx < 0) {
      {
      emsg((char_u *)"Updated too many blocks?");
      buf___3->b_ml.ml_stack_top = 0;
      }
    }
  }
  {
  ml_updatechunk(buf___3, lnum + 1L, (int )len___0, 1);
  }
  return (1);
}
}
int ml_replace(linenr_t lnum , char_u *line , int copy ) 
{ 
  int tmp ;

  {
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    return (0);
  }
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    {
    tmp = open_buffer(0);
    }
    if (tmp == 0) {
      return (0);
    }
  }
  if (curbuf->b_ml.ml_line_lnum != lnum) {
    {
    ml_flush_line(curbuf);
    }
  } else { //Added block
  if (curbuf->b_ml.ml_flags & 2) {
    {
    vim_free((void *)curbuf->b_ml.ml_line_ptr);
    }
  }
  }
  if (copy) {
    {
    line = vim_strsave(line);
    }
    if ((unsigned long )line == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  curbuf->b_ml.ml_line_ptr = line;
  curbuf->b_ml.ml_line_lnum = lnum;
  curbuf->b_ml.ml_flags = (curbuf->b_ml.ml_flags | 2) & -2;
  return (1);
}
}
int ml_delete(linenr_t lnum , int message ) 
{ 
  int tmp ;

  {
  if (curbuf->b_syn_change_lnum > lnum) {
    curbuf->b_syn_change_lnum = lnum;
  }
  {
  ml_flush_line(curbuf);
  tmp = ml_delete_int(curbuf, lnum, message);
  }
  return (tmp);
}
}
static int ml_delete_int(BUF *buf___3 , linenr_t lnum , int message ) 
{ 
  BHDR *hp ;
  MEMFILE *mfp ;
  DATA_BL *dp ;
  PTR_BL *pp ;
  IPTR *ip ;
  int count___2 ;
  int idx ;
  int stack_idx ;
  int text_start ;
  int line_start ;
  int line_size ;
  int i___0 ;

  {
  if (lnum < 1L) {
    return (0);
  } else { //Added block
  if (lnum > buf___3->b_ml.ml_line_count) {
    return (0);
  }
  }
  if (lowest_marked) {
    if (lowest_marked > lnum) {
      lowest_marked --;
    }
  }
  if (buf___3->b_ml.ml_line_count == 1L) {
    if (message) {
      keep_msg = no_lines_msg;
      keep_msg_attr = 0;
    }
    {
    i___0 = ml_replace((linenr_t )1, (char_u *)"", 1);
    buf___3->b_ml.ml_flags |= 1;
    }
    return (i___0);
  }
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  hp = ml_find_line(buf___3, lnum, 17);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    return (0);
  }
  dp = (DATA_BL *)hp->bh_data;
  count___2 = (int )((buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low) + 2L);
  idx = (int )(lnum - buf___3->b_ml.ml_locked_low);
  (buf___3->b_ml.ml_line_count) --;
  line_start = (int )(dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
  if (idx == 0) {
    line_size = (int )(dp->db_txt_end - (unsigned int )line_start);
  } else {
    line_size = (int )((dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))) - (unsigned int )line_start);
  }
  if (count___2 == 1) {
    {
    mf_free(mfp, hp);
    buf___3->b_ml.ml_locked = (BHDR *)((void *)0);
    stack_idx = buf___3->b_ml.ml_stack_top - 1;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (stack_idx >= 0)) {
        goto while_break;
      }
      {
      buf___3->b_ml.ml_stack_top = 0;
      ip = buf___3->b_ml.ml_stack + stack_idx;
      idx = ip->ip_index;
      hp = mf_get(mfp, ip->ip_bnum, 1);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
        return (0);
      }
      pp = (PTR_BL *)hp->bh_data;
      if ((int )pp->pb_id != (112 << 8) + 116) {
        {
        emsg((char_u *)"pointer block id wrong 4");
        mf_put(mfp, hp, 0, 0);
        }
        return (0);
      }
      pp->pb_count = (short_u )((int )pp->pb_count - 1);
      count___2 = (int )pp->pb_count;
      if (count___2 == 0) {
        {
        mf_free(mfp, hp);
        }
      } else {
        if (count___2 != idx) {
          {
          memmove((void *)((char *)(& pp->pb_pointer[idx])), (void const   *)((char *)(& pp->pb_pointer[idx + 1])),
                  (size_t )(count___2 - idx) * sizeof(PTR_EN ));
          }
        }
        {
        mf_put(mfp, hp, 1, 0);
        buf___3->b_ml.ml_stack_top = stack_idx;
        }
        if (buf___3->b_ml.ml_locked_lineadd) {
          {
          ml_lineadd(buf___3, buf___3->b_ml.ml_locked_lineadd);
          (buf___3->b_ml.ml_stack + buf___3->b_ml.ml_stack_top)->ip_high += (linenr_t )buf___3->b_ml.ml_locked_lineadd;
          }
        }
        (buf___3->b_ml.ml_stack_top) ++;
        goto while_break;
      }
      stack_idx --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    text_start = (int )dp->db_txt_start;
    memmove((void *)(((char *)dp + text_start) + line_size), (void const   *)((char *)dp + text_start),
            (size_t )(line_start - text_start));
    i___0 = idx;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < count___2 - 1)) {
        goto while_break___0;
      }
      dp->db_index[i___0] = dp->db_index[i___0 + 1] + (unsigned int )line_size;
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    dp->db_free = (unsigned int )((unsigned long )dp->db_free + ((unsigned long )line_size + sizeof(unsigned int )));
    dp->db_txt_start += (unsigned int )line_size;
    (dp->db_line_count) --;
    buf___3->b_ml.ml_flags |= 12;
  }
  {
  ml_updatechunk(buf___3, lnum, line_size, 2);
  }
  return (1);
}
}
void ml_setmarked(linenr_t lnum ) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;

  {
  if (lnum < 1L) {
    return;
  } else { //Added block
  if (lnum > curbuf->b_ml.ml_line_count) {
    return;
  } else { //Added block
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return;
  }
  }
  }
  if (lowest_marked == 0L) {
    lowest_marked = lnum;
  } else { //Added block
  if (lowest_marked > lnum) {
    lowest_marked = lnum;
  }
  }
  {
  hp = ml_find_line(curbuf, lnum, 19);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    return;
  }
  dp = (DATA_BL *)hp->bh_data;
  dp->db_index[lnum - curbuf->b_ml.ml_locked_low] |= 1U << (sizeof(unsigned int ) * 8UL - 1UL);
  curbuf->b_ml.ml_flags |= 4;
  return;
}
}
linenr_t ml_firstmarked(void) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  linenr_t lnum ;
  int i___0 ;

  {
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return ((linenr_t )0);
  }
  lnum = lowest_marked;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lnum <= curbuf->b_ml.ml_line_count)) {
      goto while_break;
    }
    {
    hp = ml_find_line(curbuf, lnum, 19);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      return ((linenr_t )0);
    }
    dp = (DATA_BL *)hp->bh_data;
    i___0 = (int )(lnum - curbuf->b_ml.ml_locked_low);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (lnum <= curbuf->b_ml.ml_locked_high)) {
        goto while_break___0;
      }
      if (dp->db_index[i___0] & (1U << (sizeof(unsigned int ) * 8UL - 1UL))) {
        dp->db_index[i___0] &= ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL));
        curbuf->b_ml.ml_flags |= 4;
        lowest_marked = lnum + 1L;
        return (lnum);
      }
      i___0 ++;
      lnum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((linenr_t )0);
}
}
void ml_clearmarked(void) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  linenr_t lnum ;
  int i___0 ;

  {
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return;
  }
  lnum = lowest_marked;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lnum <= curbuf->b_ml.ml_line_count)) {
      goto while_break;
    }
    {
    hp = ml_find_line(curbuf, lnum, 19);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      return;
    }
    dp = (DATA_BL *)hp->bh_data;
    i___0 = (int )(lnum - curbuf->b_ml.ml_locked_low);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (lnum <= curbuf->b_ml.ml_locked_high)) {
        goto while_break___0;
      }
      if (dp->db_index[i___0] & (1U << (sizeof(unsigned int ) * 8UL - 1UL))) {
        dp->db_index[i___0] &= ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL));
        curbuf->b_ml.ml_flags |= 4;
      }
      i___0 ++;
      lnum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  lowest_marked = (linenr_t )0;
  return;
}
}
static void ml_flush_line(BUF *buf___3 ) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  linenr_t lnum ;
  char_u *new_line ;
  char_u *old_line ;
  colnr_t new_len ;
  int old_len ;
  int extra ;
  int idx ;
  int start___0 ;
  int count___2 ;
  int i___0 ;
  size_t tmp ;

  {
  if (buf___3->b_ml.ml_line_lnum == 0L) {
    return;
  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return;
  }
  }
  if (buf___3->b_ml.ml_flags & 2) {
    {
    lnum = buf___3->b_ml.ml_line_lnum;
    new_line = buf___3->b_ml.ml_line_ptr;
    hp = ml_find_line(buf___3, lnum, 19);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
      emsgn((char_u *)"Cannot find line %ld", lnum);
      }
    } else {
      dp = (DATA_BL *)hp->bh_data;
      idx = (int )(lnum - buf___3->b_ml.ml_locked_low);
      start___0 = (int )(dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
      old_line = (char_u *)dp + start___0;
      if (idx == 0) {
        old_len = (int )(dp->db_txt_end - (unsigned int )start___0);
      } else {
        old_len = (int )((dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))) - (unsigned int )start___0);
      }
      {
      tmp = strlen((char const   *)((char *)new_line));
      new_len = (colnr_t )(tmp + 1UL);
      extra = (int )(new_len - (colnr_t )old_len);
      }
      if ((int )dp->db_free >= extra) {
        count___2 = (int )((buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low) + 1L);
        if (extra != 0) {
          if (idx < count___2 - 1) {
            {
            memmove((void *)(((char *)dp + dp->db_txt_start) - extra), (void const   *)((char *)dp + dp->db_txt_start),
                    (size_t )((unsigned int )start___0 - dp->db_txt_start));
            i___0 = idx + 1;
            }
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              if (! (i___0 < count___2)) {
                goto while_break;
              }
              dp->db_index[i___0] -= (unsigned int )extra;
              i___0 ++;
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
        {
        dp->db_index[idx] -= (unsigned int )extra;
        dp->db_free -= (unsigned int )extra;
        dp->db_txt_start -= (unsigned int )extra;
        memmove((void *)((char *)(old_line - extra)), (void const   *)((char *)new_line),
                (size_t )new_len);
        buf___3->b_ml.ml_flags |= 12;
        ml_updatechunk(buf___3, lnum, extra, 3);
        }
      } else {
        {
        ml_append_int(buf___3, lnum, new_line, new_len, 0, (int )(dp->db_index[idx] & (1U << (sizeof(unsigned int ) * 8UL - 1UL))));
        ml_delete_int(buf___3, lnum, 0);
        }
      }
    }
    {
    vim_free((void *)new_line);
    }
  }
  buf___3->b_ml.ml_line_lnum = (linenr_t )0;
  return;
}
}
static BHDR *ml_new_data(MEMFILE *mfp , int negative , int page_count ) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  unsigned int tmp ;

  {
  {
  hp = mf_new(mfp, negative, page_count);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    return ((BHDR *)((void *)0));
  }
  dp = (DATA_BL *)hp->bh_data;
  dp->db_id = (short_u )((100 << 8) + 97);
  tmp = (unsigned int )page_count * mfp->mf_page_size;
  dp->db_txt_end = tmp;
  dp->db_txt_start = tmp;
  dp->db_free = (unsigned int )((unsigned long )dp->db_txt_start - (sizeof(DATA_BL ) - sizeof(unsigned int )));
  dp->db_line_count = (linenr_t )0;
  return (hp);
}
}
static BHDR *ml_new_ptr(MEMFILE *mfp ) 
{ 
  BHDR *hp ;
  PTR_BL *pp ;

  {
  {
  hp = mf_new(mfp, 0, 1);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    return ((BHDR *)((void *)0));
  }
  pp = (PTR_BL *)hp->bh_data;
  pp->pb_id = (short_u )((112 << 8) + 116);
  pp->pb_count = (short_u )0;
  pp->pb_count_max = (short_u )(((unsigned long )mfp->mf_page_size - sizeof(PTR_BL )) / sizeof(PTR_EN ) + 1UL);
  return (hp);
}
}
static BHDR *ml_find_line(BUF *buf___3 , linenr_t lnum , int action ) 
{ 
  DATA_BL *dp ;
  PTR_BL *pp ;
  IPTR *ip ;
  BHDR *hp ;
  MEMFILE *mfp ;
  linenr_t t ;
  blocknr_t bnum ;
  blocknr_t bnum2 ;
  int dirty ;
  linenr_t low ;
  linenr_t high ;
  int top ;
  int page_count ;
  int idx ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if (buf___3->b_ml.ml_locked) {
    if (action & 16) {
      if (buf___3->b_ml.ml_locked_low <= lnum) {
        if (buf___3->b_ml.ml_locked_high >= lnum) {
          if (action == 18) {
            (buf___3->b_ml.ml_locked_lineadd) ++;
            (buf___3->b_ml.ml_locked_high) ++;
          } else { //Added block
          if (action == 17) {
            (buf___3->b_ml.ml_locked_lineadd) --;
            (buf___3->b_ml.ml_locked_high) --;
          }
          }
          return (buf___3->b_ml.ml_locked);
        }
      }
    }
    {
    mf_put(mfp, buf___3->b_ml.ml_locked, buf___3->b_ml.ml_flags & 4, buf___3->b_ml.ml_flags & 8);
    buf___3->b_ml.ml_locked = (BHDR *)((void *)0);
    }
    if (buf___3->b_ml.ml_locked_lineadd) {
      {
      ml_lineadd(buf___3, buf___3->b_ml.ml_locked_lineadd);
      }
    }
  }
  if (action == 2) {
    return ((BHDR *)((void *)0));
  }
  bnum = (blocknr_t )1;
  page_count = 1;
  low = (linenr_t )1;
  high = buf___3->b_ml.ml_line_count;
  if (action == 19) {
    top = buf___3->b_ml.ml_stack_top - 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (top >= 0)) {
        goto while_break;
      }
      ip = buf___3->b_ml.ml_stack + top;
      if (ip->ip_low <= lnum) {
        if (ip->ip_high >= lnum) {
          bnum = ip->ip_bnum;
          low = ip->ip_low;
          high = ip->ip_high;
          buf___3->b_ml.ml_stack_top = top;
          goto while_break;
        }
      }
      top --;
    }
    while_break: /* CIL Label */ ;
    }
    if (top < 0) {
      buf___3->b_ml.ml_stack_top = 0;
    }
  } else {
    buf___3->b_ml.ml_stack_top = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    hp = mf_get(mfp, bnum, page_count);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      goto error_noblock;
    }
    if (action == 18) {
      high ++;
    } else { //Added block
    if (action == 17) {
      high --;
    }
    }
    dp = (DATA_BL *)hp->bh_data;
    if ((int )dp->db_id == (100 << 8) + 97) {
      buf___3->b_ml.ml_locked = hp;
      buf___3->b_ml.ml_locked_low = low;
      buf___3->b_ml.ml_locked_high = high;
      buf___3->b_ml.ml_locked_lineadd = 0;
      buf___3->b_ml.ml_flags &= -13;
      return (hp);
    }
    pp = (PTR_BL *)dp;
    if ((int )pp->pb_id != (112 << 8) + 116) {
      {
      emsg((char_u *)"pointer block id wrong");
      }
      goto error_block;
    }
    {
    top = ml_add_stack(buf___3);
    }
    if (top < 0) {
      goto error_block;
    }
    ip = buf___3->b_ml.ml_stack + top;
    ip->ip_bnum = bnum;
    ip->ip_low = low;
    ip->ip_high = high;
    ip->ip_index = -1;
    dirty = 0;
    idx = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (idx < (int )pp->pb_count)) {
        goto while_break___1;
      }
      t = pp->pb_pointer[idx].pe_line_count;
      low += t;
      if (low > lnum) {
        ip->ip_index = idx;
        bnum = pp->pb_pointer[idx].pe_bnum;
        page_count = pp->pb_pointer[idx].pe_page_count;
        high = low - 1L;
        low -= t;
        if (bnum < 0L) {
          {
          bnum2 = mf_trans_del(mfp, bnum);
          }
          if (bnum != bnum2) {
            bnum = bnum2;
            pp->pb_pointer[idx].pe_bnum = bnum;
            dirty = 1;
          }
        }
        goto while_break___1;
      }
      idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (idx >= (int )pp->pb_count) {
      if (lnum > buf___3->b_ml.ml_line_count) {
        {
        emsgn((char_u *)"line number out of range: %ld past the end", lnum - buf___3->b_ml.ml_line_count);
        }
      } else {
        {
        emsgn((char_u *)"line count wrong in block %ld", bnum);
        }
      }
      goto error_block;
    }
    if (action == 17) {
      (pp->pb_pointer[idx].pe_line_count) --;
      dirty = 1;
    } else { //Added block
    if (action == 18) {
      (pp->pb_pointer[idx].pe_line_count) ++;
      dirty = 1;
    }
    }
    {
    mf_put(mfp, hp, dirty, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  error_block: 
  {
  mf_put(mfp, hp, 0, 0);
  }
  error_noblock: 
  if (action == 17) {
    {
    ml_lineadd(buf___3, 1);
    }
  } else { //Added block
  if (action == 18) {
    {
    ml_lineadd(buf___3, -1);
    }
  }
  }
  buf___3->b_ml.ml_stack_top = 0;
  return ((BHDR *)((void *)0));
}
}
static int ml_add_stack(BUF *buf___3 ) 
{ 
  int top ;
  IPTR *newstack ;
  char_u *tmp ;

  {
  top = buf___3->b_ml.ml_stack_top;
  if (top == buf___3->b_ml.ml_stack_size) {
    {
    tmp = alloc((unsigned int )sizeof(IPTR ) * (unsigned int )(buf___3->b_ml.ml_stack_size + 5));
    newstack = (IPTR *)tmp;
    }
    if ((unsigned long )newstack == (unsigned long )((void *)0)) {
      return (-1);
    }
    {
    memmove((void *)((char *)newstack), (void const   *)((char *)buf___3->b_ml.ml_stack),
            (size_t )top * sizeof(IPTR ));
    vim_free((void *)buf___3->b_ml.ml_stack);
    buf___3->b_ml.ml_stack = newstack;
    buf___3->b_ml.ml_stack_size += 5;
    }
  }
  (buf___3->b_ml.ml_stack_top) ++;
  return (top);
}
}
static void ml_lineadd(BUF *buf___3 , int count___2 ) 
{ 
  int idx ;
  IPTR *ip ;
  PTR_BL *pp ;
  MEMFILE *mfp ;
  BHDR *hp ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  idx = buf___3->b_ml.ml_stack_top - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (idx >= 0)) {
      goto while_break;
    }
    {
    ip = buf___3->b_ml.ml_stack + idx;
    hp = mf_get(mfp, ip->ip_bnum, 1);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      goto while_break;
    }
    pp = (PTR_BL *)hp->bh_data;
    if ((int )pp->pb_id != (112 << 8) + 116) {
      {
      mf_put(mfp, hp, 0, 0);
      emsg((char_u *)"pointer block id wrong 2");
      }
      goto while_break;
    }
    {
    pp->pb_pointer[ip->ip_index].pe_line_count += (linenr_t )count___2;
    ip->ip_high += (linenr_t )count___2;
    mf_put(mfp, hp, 1, 0);
    idx --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char_u *makeswapname(BUF *buf___3 , char_u *dir_name ) 
{ 
  char_u *r ;
  char_u *s ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = strlen((char const   *)((char *)dir_name));
  s = dir_name + tmp;
  tmp___0 = vim_ispathsep((int )*(s + -1));
  }
  if (tmp___0) {
    if ((int )*(s + -1) == (int )*(s + -2)) {
      {
      r = (char_u *)((void *)0);
      s = make_percent_swname(dir_name, buf___3->b_fname);
      }
      if ((unsigned long )s != (unsigned long )((void *)0)) {
        {
        r = modname(s, (char_u *)".swp", 0);
        vim_free((void *)s);
        }
      }
      return (r);
    }
  }
  if ((int )*(dir_name + 0) == 46) {
    if ((int )*(dir_name + 1) == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  if (buf___3->b_p_sn) {
    tmp___2 = 1;
  } else { //Added block
  if (buf___3->b_shortname) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  }
  {
  r = buf_modname(tmp___2, buf___3->b_fname, (char_u *)".swp", tmp___1);
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  s = get_file_in_dir(r, dir_name);
  vim_free((void *)r);
  }
  return (s);
}
}
char_u *get_file_in_dir(char_u *fname , char_u *dname ) 
{ 
  char_u *t ;
  char_u *tail ;
  char_u *retval ;
  int save_char ;
  int tmp ;

  {
  {
  tail = gettail(fname);
  }
  if ((int )*(dname + 0) == 46) {
    if ((int )*(dname + 1) == 0) {
      {
      retval = vim_strsave(fname);
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(dname + 0) == 46) {
    {
    tmp = vim_ispathsep((int )*(dname + 1));
    }
    if (tmp) {
      if ((unsigned long )tail == (unsigned long )fname) {
        {
        retval = concat_fnames(dname + 2, tail, 1);
        }
      } else {
        {
        save_char = (int )*tail;
        *tail = (char_u )'\000';
        t = concat_fnames(fname, dname + 2, 1);
        *tail = (char_u )save_char;
        }
        if ((unsigned long )t == (unsigned long )((void *)0)) {
          retval = (char_u *)((void *)0);
        } else {
          {
          retval = concat_fnames(t, tail, 1);
          vim_free((void *)t);
          }
        }
      }
    } else {
      {
      retval = concat_fnames(dname, tail, 1);
      }
    }
  } else {
    {
    retval = concat_fnames(dname, tail, 1);
    }
  }
  }
  return (retval);
}
}
static char_u *findswapname(BUF *buf___3 , char_u **dirp , char_u *old_fname ) 
{ 
  char_u *fname ;
  int n ;
  time_t x___0 ;
  char_u *dir_name ;
  int r ;
  FILE *dummyfd ;
  struct stat st ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char_u *tail ;
  char_u *fname2 ;
  struct stat s1 ;
  struct stat s2 ;
  int f1 ;
  int f2 ;
  int created1 ;
  int created2 ;
  int same ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  size_t tmp___8 ;
  char_u *tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int fd ;
  struct block0 b0 ;
  int differ ;
  long tmp___13 ;
  int tmp___14 ;
  ssize_t tmp___15 ;
  struct stat st___0 ;
  char *tmp___16 ;
  int tmp___17 ;
  char_u *name___1 ;
  size_t tmp___18 ;
  char_u *tmp___19 ;
  char_u *tmp___20 ;
  int tmp___21 ;
  char_u *tmp___22 ;

  {
  dummyfd = (FILE *)((void *)0);
  if (! buf___3->b_p_sn) {
    if (! buf___3->b_shortname) {
      if (buf___3->b_fname) {
        {
        tmp___0 = mch_getperm(buf___3->b_fname);
        }
        if (tmp___0 < 0L) {
          {
          tmp = lstat((char const   * __restrict  )((char *)buf___3->b_fname), (struct stat * __restrict  )(& st));
          }
          if (tmp == -1) {
            {
            dummyfd = fopen((char const   * __restrict  )((char *)buf___3->b_fname),
                            (char const   * __restrict  )"w");
            }
          } else { //Added block
          if ((st.st_mode & 61440U) != 40960U) {
            {
            dummyfd = fopen((char const   * __restrict  )((char *)buf___3->b_fname),
                            (char const   * __restrict  )"w");
            }
          }
          }
        }
      }
    }
  }
  {
  tmp___1 = strlen((char const   *)((char *)*dirp));
  dir_name = alloc((unsigned int )tmp___1 + 1U);
  }
  if ((unsigned long )dir_name != (unsigned long )((void *)0)) {
    {
    copy_option_part(dirp, dir_name, 31000, (char *)",");
    }
  }
  if ((unsigned long )dir_name == (unsigned long )((void *)0)) {
    fname = (char_u *)((void *)0);
  } else {
    {
    fname = makeswapname(buf___3, dir_name);
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! ((unsigned long )fname == (unsigned long )((void *)0)))) {
      goto while_break;
    }
    {
    tmp___2 = strlen((char const   *)((char *)fname));
    n = (int )tmp___2;
    }
    if (n == 0) {
      {
      vim_free((void *)fname);
      fname = (char_u *)((void *)0);
      }
      goto while_break;
    }
    if ((int )*(fname + (n - 2)) == 119) {
      if ((int )*(fname + (n - 1)) == 112) {
        if (! buf___3->b_p_sn) {
          if (! buf___3->b_shortname) {
            {
            created1 = 0;
            created2 = 0;
            same = 0;
            tail = gettail(buf___3->b_fname);
            tmp___7 = vim_strchr(tail, '.');
            }
            if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
              goto _L;
            } else {
              {
              tmp___8 = strlen((char const   *)((char *)tail));
              }
              if (tmp___8 > 8UL) {
                goto _L;
              } else {
                {
                tmp___9 = gettail(fname);
                }
                if ((int )*tmp___9 == 46) {
                  _L: 
                  {
                  fname2 = alloc((unsigned int )(n + 2));
                  }
                  if ((unsigned long )fname2 != (unsigned long )((void *)0)) {
                    {
                    strcpy((char * __restrict  )((char *)fname2), (char const   * __restrict  )((char *)fname));
                    tmp___4 = vim_strchr(tail, '.');
                    }
                    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
                      *(fname2 + (n - 1)) = (char_u )'x';
                    } else {
                      {
                      tmp___3 = gettail(fname);
                      }
                      if ((int )*tmp___3 == 46) {
                        *(fname2 + n) = (char_u )'x';
                        *(fname2 + (n + 1)) = (char_u )'\000';
                      } else {
                        *(fname2 + (n - 5)) = (char_u )((int )*(fname2 + (n - 5)) + 1);
                      }
                    }
                    {
                    f1 = open((char const   *)((char *)fname), 0, 0);
                    }
                    if (f1 < 0) {
                      {
                      f1 = open((char const   *)((char *)fname), 194, (mode_t )384);
                      created1 = 1;
                      }
                    }
                    if (f1 >= 0) {
                      {
                      f2 = open((char const   *)((char *)fname2), 0, 0);
                      }
                      if (f2 < 0) {
                        {
                        f2 = open((char const   *)((char *)fname2), 194, (mode_t )384);
                        created2 = 1;
                        }
                      }
                      if (f2 >= 0) {
                        {
                        tmp___5 = fstat(f1, & s1);
                        }
                        if (tmp___5 != -1) {
                          {
                          tmp___6 = fstat(f2, & s2);
                          }
                          if (tmp___6 != -1) {
                            if (s1.st_dev == s2.st_dev) {
                              if (s1.st_ino == s2.st_ino) {
                                same = 1;
                              }
                            }
                          }
                        }
                        {
                        close(f2);
                        }
                        if (created2) {
                          {
                          unlink((char const   *)((char *)fname2));
                          }
                        }
                      }
                      {
                      close(f1);
                      }
                      if (created1) {
                        {
                        unlink((char const   *)((char *)fname));
                        }
                      }
                    }
                    {
                    vim_free((void *)fname2);
                    }
                    if (same) {
                      {
                      buf___3->b_shortname = 1;
                      vim_free((void *)fname);
                      fname = makeswapname(buf___3, dir_name);
                      }
                      goto __Cont;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
    tmp___10 = mch_getperm(fname);
    }
    if (tmp___10 < 0L) {
      goto while_break;
    }
    if ((unsigned long )old_fname != (unsigned long )((void *)0)) {
      {
      tmp___11 = strcmp((char const   *)((char *)fname), (char const   *)((char *)old_fname));
      }
      if (tmp___11 == 0) {
        goto while_break;
      }
    }
    if ((int )*(fname + (n - 2)) == 119) {
      if ((int )*(fname + (n - 1)) == 112) {
        if (! buf___3->b_p_sn) {
          if (! buf___3->b_shortname) {
            {
            *(fname + (n - 1)) = (char_u )'x';
            tmp___12 = mch_getperm(fname);
            r = (int )tmp___12;
            *(fname + (n - 1)) = (char_u )'p';
            }
            if (r >= 0) {
              {
              buf___3->b_shortname = 1;
              vim_free((void *)fname);
              fname = makeswapname(buf___3, dir_name);
              }
              goto __Cont;
            }
          }
        }
        if (! recoverymode) {
          if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
            if (! buf___3->b_help) {
              {
              differ = 0;
              fd = open((char const   *)((char *)fname), 0, 0);
              }
              if (fd >= 0) {
                {
                tmp___15 = read(fd, (void *)((char *)(& b0)), sizeof(b0));
                }
                if ((unsigned long )tmp___15 == sizeof(b0)) {
                  {
                  expand_env(b0.b0_fname, NameBuff, 1024);
                  tmp___13 = char_to_long(b0.b0_ino);
                  tmp___14 = fnamecmp_ino(buf___3->b_ffname, NameBuff, tmp___13);
                  }
                  if (tmp___14) {
                    differ = 1;
                  }
                }
                {
                close(fd);
                }
              }
              if (differ == 0) {
                if (! (curbuf->b_flags & 1)) {
                  {
                  tmp___22 = vim_strchr(p_shm, 'A');
                  }
                  if ((unsigned long )tmp___22 == (unsigned long )((void *)0)) {
                    {
                    process_still_running = 0;
                    no_wait_return ++;
                    emsg((char_u *)"ATTENTION");
                    msg_puts((char_u *)"\nFound a swap file by the name \"");
                    msg_home_replace(fname);
                    msg_puts((char_u *)"\"\n");
                    swapfile_info(fname);
                    msg_puts((char_u *)"While opening file \"");
                    msg_outtrans(buf___3->b_fname);
                    msg_puts((char_u *)"\"\n");
                    tmp___17 = stat((char const   * __restrict  )((char *)buf___3->b_fname),
                                    (struct stat * __restrict  )(& st___0));
                    }
                    if (tmp___17 != -1) {
                      {
                      msg_puts((char_u *)"             dated: ");
                      x___0 = st___0.st_mtim.tv_sec;
                      tmp___16 = ctime((time_t const   *)(& x___0));
                      msg_puts((char_u *)tmp___16);
                      }
                    }
                    {
                    msg_puts((char_u *)"\n(1) Another program may be editing the same file.\n");
                    msg_puts((char_u *)"    If this is the case, be careful not to end up with two\n");
                    msg_puts((char_u *)"    different instances of the same file when making changes.\n");
                    msg_puts((char_u *)"    Quit, or continue with caution.\n");
                    msg_puts((char_u *)"\n(2) An edit session for this file crashed.\n");
                    msg_puts((char_u *)"    If this is the case, use \":recover\" or \"vim -r ");
                    msg_outtrans(buf___3->b_fname);
                    msg_puts((char_u *)"\"\n    to recover the changes (see \":help recovery)\".\n");
                    msg_puts((char_u *)"    If you did this already, delete the swap file \"");
                    msg_outtrans(fname);
                    msg_puts((char_u *)"\"\n    to avoid this message.\n\n");
                    cmdline_row = msg_row;
                    no_wait_return --;
                    got_int = 0;
                    }
                    if (swap_exists_action) {
                      {
                      tmp___18 = strlen((char const   *)((char *)fname));
                      name___1 = alloc((unsigned int )tmp___18 + 40U);
                      }
                      if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
                        {
                        strcpy((char * __restrict  )((char *)name___1), (char const   * __restrict  )((char *)"Swap file \""));
                        home_replace((BUF *)((void *)0), fname, name___1 + 11, 1000,
                                     1);
                        strcat((char * __restrict  )((char *)name___1), (char const   * __restrict  )((char *)"\" already exists!"));
                        }
                      }
                      if (process_still_running) {
                        tmp___19 = (char_u *)"&Open Read-Only\n&Edit anyway\n&Recover\n&Quit";
                      } else {
                        tmp___19 = (char_u *)"&Open Read-Only\n&Edit anyway\n&Recover\n&Quit\n&Delete it";
                      }
                      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
                        tmp___20 = (char_u *)"Swap file already exists!";
                      } else {
                        tmp___20 = name___1;
                      }
                      {
                      tmp___21 = do_dialog(2, (char_u *)"VIM - ATTENTION", tmp___20,
                                           tmp___19, 1);
                      }
                      {
                      if (tmp___21 == 1) {
                        goto case_1;
                      }
                      if (tmp___21 == 2) {
                        goto case_2;
                      }
                      if (tmp___21 == 3) {
                        goto case_3;
                      }
                      if (tmp___21 == 4) {
                        goto case_4;
                      }
                      if (tmp___21 == 5) {
                        goto case_5;
                      }
                      goto switch_break;
                      case_1: /* CIL Label */ 
                      buf___3->b_p_ro = 1;
                      goto switch_break;
                      case_2: /* CIL Label */ 
                      goto switch_break;
                      case_3: /* CIL Label */ 
                      swap_exists_action = 3;
                      goto switch_break;
                      case_4: /* CIL Label */ 
                      swap_exists_action = 2;
                      goto switch_break;
                      case_5: /* CIL Label */ 
                      {
                      unlink((char const   *)((char *)fname));
                      }
                      goto switch_break;
                      switch_break: /* CIL Label */ ;
                      }
                      {
                      vim_free((void *)name___1);
                      msg_scrolled = 0;
                      }
                    } else {
                      need_wait_return = 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ((int )*(fname + (n - 1)) == 97) {
      if ((int )*(fname + (n - 2)) == 97) {
        {
        emsg((char_u *)"Too many swap files found");
        vim_free((void *)fname);
        fname = (char_u *)((void *)0);
        }
        goto while_break;
      }
      *(fname + (n - 2)) = (char_u )((int )*(fname + (n - 2)) - 1);
      *(fname + (n - 1)) = (char_u )123;
    }
    *(fname + (n - 1)) = (char_u )((int )*(fname + (n - 1)) - 1);
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)dir_name);
  }
  if (dummyfd) {
    {
    fclose(dummyfd);
    unlink((char const   *)((char *)buf___3->b_fname));
    }
  }
  return (fname);
}
}
static int b0_magic_wrong(ZERO_BL *b0p ) 
{ 
  int tmp ;

  {
  if (b0p->b0_magic_long != 808530483L) {
    tmp = 1;
  } else { //Added block
  if (b0p->b0_magic_int != 539042339) {
    tmp = 1;
  } else { //Added block
  if ((int )b0p->b0_magic_short != 4627) {
    tmp = 1;
  } else { //Added block
  if ((int )b0p->b0_magic_char != 85) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  }
  return (tmp);
}
}
static int fnamecmp_ino(char_u *fname_c , char_u *fname_s , long ino_block0 ) 
{ 
  struct stat st ;
  ino_t ino_c ;
  ino_t ino_s ;
  char_u buf_c[1024] ;
  char_u buf_s[1024] ;
  int retval_c ;
  int retval_s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  ino_c = (ino_t )0;
  tmp = stat((char const   * __restrict  )((char *)fname_c), (struct stat * __restrict  )(& st));
  }
  if (tmp == 0) {
    ino_c = st.st_ino;
  }
  {
  tmp___0 = stat((char const   * __restrict  )((char *)fname_s), (struct stat * __restrict  )(& st));
  }
  if (tmp___0 == 0) {
    ino_s = st.st_ino;
  } else {
    ino_s = (ino_t )ino_block0;
  }
  if (ino_c) {
    if (ino_s) {
      return (ino_c != ino_s);
    }
  }
  {
  retval_c = mch_FullName(fname_c, buf_c, 1024, 1);
  retval_s = mch_FullName(fname_s, buf_s, 1024, 1);
  }
  if (retval_c == 1) {
    if (retval_s == 1) {
      {
      tmp___1 = strcmp((char const   *)((char *)(buf_c)), (char const   *)((char *)(buf_s)));
      }
      return (tmp___1 != 0);
    }
  }
  if (ino_s == 0UL) {
    if (ino_c == 0UL) {
      if (retval_c == 0) {
        if (retval_s == 0) {
          return (0);
        }
      }
    }
  }
  return (1);
}
}
static void long_to_char(long n , char_u *s ) 
{ 


  {
  *(s + 0) = (char_u )(n & 255L);
  n = (long )((unsigned int )n >> 8);
  *(s + 1) = (char_u )(n & 255L);
  n = (long )((unsigned int )n >> 8);
  *(s + 2) = (char_u )(n & 255L);
  n = (long )((unsigned int )n >> 8);
  *(s + 3) = (char_u )(n & 255L);
  return;
}
}
static long char_to_long(char_u *s ) 
{ 
  long retval ;

  {
  retval = (long )*(s + 3);
  retval <<= 8;
  retval += (long )*(s + 2);
  retval <<= 8;
  retval += (long )*(s + 1);
  retval <<= 8;
  retval += (long )*(s + 0);
  return (retval);
}
}
void ml_setdirty(BUF *buf___3 , int flag ) 
{ 
  BHDR *hp ;
  ZERO_BL *b0p ;

  {
  if (! buf___3->b_ml.ml_mfp) {
    return;
  }
  hp = (buf___3->b_ml.ml_mfp)->mf_used_last;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (hp->bh_bnum == 0L) {
      b0p = (ZERO_BL *)hp->bh_data;
      if (flag) {
        b0p->b0_fname[899] = (char_u )85;
      } else {
        b0p->b0_fname[899] = (char_u )0;
      }
      {
      hp->bh_flags = (char )((int )hp->bh_flags | 1);
      mf_sync(buf___3->b_ml.ml_mfp, 8);
      }
      goto while_break;
    }
    hp = hp->bh_prev;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static BUF *ml_upd_lastbuf  =    (BUF *)((void *)0);
static linenr_t ml_upd_lastline  ;
static linenr_t ml_upd_lastcurline  ;
static int ml_upd_lastcurix  ;
static void ml_updatechunk(BUF *buf___3 , long line , int len___0 , int updtype ) 
{ 
  linenr_t curline ;
  int curix ;
  long size ;
  ML_CHUNKSIZE *curchnk ;
  int rest ;
  BHDR *hp ;
  DATA_BL *dp ;
  char_u *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int count___2 ;
  int idx ;
  int text_end ;
  int linecnt ;

  {
  curline = ml_upd_lastcurline;
  curix = ml_upd_lastcurix;
  if (buf___3->b_ml.ml_usedchunks == -1) {
    return;
  } else { //Added block
  if (! len___0) {
    return;
  }
  }
  if ((unsigned long )buf___3->b_ml.ml_chunksize == (unsigned long )((void *)0)) {
    {
    tmp = alloc((unsigned int )sizeof(ML_CHUNKSIZE ) * 100U);
    buf___3->b_ml.ml_chunksize = (ML_CHUNKSIZE *)tmp;
    }
    if ((unsigned long )buf___3->b_ml.ml_chunksize == (unsigned long )((void *)0)) {
      buf___3->b_ml.ml_usedchunks = -1;
      return;
    }
    buf___3->b_ml.ml_numchunks = 100;
    buf___3->b_ml.ml_usedchunks = 1;
    (buf___3->b_ml.ml_chunksize + 0)->mlcs_numlines = 1;
    (buf___3->b_ml.ml_chunksize + 0)->mlcs_totalsize = 1;
  }
  if (updtype == 3) {
    if (buf___3->b_ml.ml_line_count == 1L) {
      {
      buf___3->b_ml.ml_usedchunks = 1;
      (buf___3->b_ml.ml_chunksize + 0)->mlcs_numlines = 1;
      tmp___0 = strlen((char const   *)((char *)buf___3->b_ml.ml_line_ptr));
      (buf___3->b_ml.ml_chunksize + 0)->mlcs_totalsize = (int )(tmp___0 + 1UL);
      }
      return;
    }
  }
  if ((unsigned long )buf___3 != (unsigned long )ml_upd_lastbuf) {
    goto _L;
  } else { //Added block
  if (line != ml_upd_lastline + 1L) {
    goto _L;
  } else { //Added block
  if (updtype != 1) {
    _L: 
    curline = (linenr_t )1;
    curix = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (curix < buf___3->b_ml.ml_usedchunks - 1) {
        if (! (line >= curline + (linenr_t )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      curline += (linenr_t )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines;
      curix ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if (line >= curline + (linenr_t )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines) {
    if (curix < buf___3->b_ml.ml_usedchunks - 1) {
      curline += (linenr_t )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines;
      curix ++;
    }
  }
  }
  }
  }
  curchnk = buf___3->b_ml.ml_chunksize + curix;
  if (updtype == 2) {
    len___0 *= -1;
  }
  curchnk->mlcs_totalsize += len___0;
  if (updtype == 1) {
    (curchnk->mlcs_numlines) ++;
    if (buf___3->b_ml.ml_usedchunks + 1 >= buf___3->b_ml.ml_numchunks) {
      {
      buf___3->b_ml.ml_numchunks = (buf___3->b_ml.ml_numchunks * 3) / 2;
      tmp___1 = realloc((void *)buf___3->b_ml.ml_chunksize, sizeof(ML_CHUNKSIZE ) * (unsigned long )buf___3->b_ml.ml_numchunks);
      buf___3->b_ml.ml_chunksize = (ML_CHUNKSIZE *)tmp___1;
      }
      if ((unsigned long )buf___3->b_ml.ml_chunksize == (unsigned long )((void *)0)) {
        buf___3->b_ml.ml_usedchunks = -1;
        return;
      }
    }
    if ((buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines >= 800) {
      {
      memmove((void *)((char *)((buf___3->b_ml.ml_chunksize + curix) + 1)), (void const   *)((char *)(buf___3->b_ml.ml_chunksize + curix)),
              (unsigned long )(buf___3->b_ml.ml_usedchunks - curix) * sizeof(ML_CHUNKSIZE ));
      size = 0L;
      linecnt = 0;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (curline < buf___3->b_ml.ml_line_count) {
          if (! (linecnt < 400)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        {
        hp = ml_find_line(buf___3, curline, 19);
        }
        if ((unsigned long )hp == (unsigned long )((void *)0)) {
          buf___3->b_ml.ml_usedchunks = -1;
          return;
        }
        dp = (DATA_BL *)hp->bh_data;
        count___2 = (int )((buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low) + 1L);
        idx = (int )(curline - buf___3->b_ml.ml_locked_low);
        curline = buf___3->b_ml.ml_locked_high + 1L;
        if (idx == 0) {
          text_end = (int )dp->db_txt_end;
        } else {
          text_end = (int )(dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
        }
        rest = count___2 - idx;
        if (linecnt + rest > 400) {
          idx += (400 - linecnt) - 1;
          linecnt = 400;
        } else {
          idx = count___2 - 1;
          linecnt += rest;
        }
        size += (long )((unsigned int )text_end - (dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))));
      }
      while_break___0: /* CIL Label */ ;
      }
      (buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines = linecnt;
      (buf___3->b_ml.ml_chunksize + (curix + 1))->mlcs_numlines -= linecnt;
      (buf___3->b_ml.ml_chunksize + curix)->mlcs_totalsize = (int )size;
      (buf___3->b_ml.ml_chunksize + (curix + 1))->mlcs_totalsize = (int )((long )(buf___3->b_ml.ml_chunksize + (curix + 1))->mlcs_totalsize - size);
      (buf___3->b_ml.ml_usedchunks) ++;
      ml_upd_lastbuf = (BUF *)((void *)0);
      return;
    } else { //Added block
    if ((buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines >= 400) {
      if (curix == buf___3->b_ml.ml_usedchunks - 1) {
        if (buf___3->b_ml.ml_line_count - line <= 1L) {
          curchnk = (buf___3->b_ml.ml_chunksize + curix) + 1;
          (buf___3->b_ml.ml_usedchunks) ++;
          if (line == buf___3->b_ml.ml_line_count) {
            curchnk->mlcs_numlines = 0;
            curchnk->mlcs_totalsize = 0;
          } else {
            {
            hp = ml_find_line(buf___3, buf___3->b_ml.ml_line_count, 19);
            }
            if ((unsigned long )hp == (unsigned long )((void *)0)) {
              buf___3->b_ml.ml_usedchunks = -1;
              return;
            }
            dp = (DATA_BL *)hp->bh_data;
            if (dp->db_line_count == 1L) {
              rest = (int )(dp->db_txt_end - dp->db_txt_start);
            } else {
              rest = (int )((dp->db_index[dp->db_line_count - 2L] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))) - dp->db_txt_start);
            }
            curchnk->mlcs_totalsize = rest;
            curchnk->mlcs_numlines = 1;
            (curchnk + -1)->mlcs_totalsize -= rest;
            ((curchnk + -1)->mlcs_numlines) --;
          }
        }
      }
    }
    }
  } else { //Added block
  if (updtype == 2) {
    (curchnk->mlcs_numlines) --;
    ml_upd_lastbuf = (BUF *)((void *)0);
    if (curix < buf___3->b_ml.ml_usedchunks - 1) {
      if (curchnk->mlcs_numlines + (curchnk + 1)->mlcs_numlines <= 400) {
        curix ++;
        curchnk = buf___3->b_ml.ml_chunksize + curix;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (curix == 0) {
      if (curchnk->mlcs_numlines <= 0) {
        {
        (buf___3->b_ml.ml_usedchunks) --;
        memmove((void *)((char *)buf___3->b_ml.ml_chunksize), (void const   *)((char *)(buf___3->b_ml.ml_chunksize + 1)),
                (unsigned long )buf___3->b_ml.ml_usedchunks * sizeof(ML_CHUNKSIZE ));
        }
        return;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (curix == 0) {
      return;
    } else { //Added block
    if (curchnk->mlcs_numlines > 10) {
      if (curchnk->mlcs_numlines + (curchnk + -1)->mlcs_numlines > 400) {
        return;
      }
    }
    }
    }
    }
    (curchnk + -1)->mlcs_numlines += curchnk->mlcs_numlines;
    (curchnk + -1)->mlcs_totalsize += curchnk->mlcs_totalsize;
    (buf___3->b_ml.ml_usedchunks) --;
    if (curix < buf___3->b_ml.ml_usedchunks) {
      {
      memmove((void *)((char *)(buf___3->b_ml.ml_chunksize + curix)), (void const   *)((char *)((buf___3->b_ml.ml_chunksize + curix) + 1)),
              (unsigned long )(buf___3->b_ml.ml_usedchunks - curix) * sizeof(ML_CHUNKSIZE ));
      }
    }
    return;
  }
  }
  ml_upd_lastbuf = buf___3;
  ml_upd_lastline = line;
  ml_upd_lastcurline = curline;
  ml_upd_lastcurix = curix;
  return;
}
}
long ml_find_line_or_offset(BUF *buf___3 , linenr_t line , long *offp ) 
{ 
  linenr_t curline ;
  int curix ;
  long size ;
  BHDR *hp ;
  DATA_BL *dp ;
  int count___2 ;
  int idx ;
  int start_idx ;
  int text_end ;
  long offset ;
  int len___0 ;
  int ffdos ;
  int tmp ;

  {
  {
  tmp = get_fileformat(buf___3);
  ffdos = tmp == 1;
  }
  if (buf___3->b_ml.ml_usedchunks == -1) {
    return (-1L);
  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_chunksize == (unsigned long )((void *)0)) {
    return (-1L);
  } else { //Added block
  if (line < 0L) {
    return (-1L);
  }
  }
  }
  if ((unsigned long )offp == (unsigned long )((void *)0)) {
    offset = 0L;
  } else {
    offset = *offp;
  }
  if (line == 0L) {
    if (offset <= 0L) {
      return (1L);
    }
  }
  curline = (linenr_t )1;
  size = 0L;
  curix = (int )size;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (curix < buf___3->b_ml.ml_usedchunks - 1) {
      if (line) {
        if (! (line >= curline + (linenr_t )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines)) {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (offset) {
        if (! (offset >= (size + (long )(buf___3->b_ml.ml_chunksize + curix)->mlcs_totalsize) + (long )(ffdos * (buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines))) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      }
    } else {
      goto while_break;
    }
    curline += (linenr_t )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines;
    size += (long )(buf___3->b_ml.ml_chunksize + curix)->mlcs_totalsize;
    if (offset) {
      if (ffdos) {
        size += (long )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines;
      }
    }
    curix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (line) {
      if (! (curline < line)) {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (offset) {
      if (! (size < offset)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    }
    if (curline > buf___3->b_ml.ml_line_count) {
      return (-1L);
    } else {
      {
      hp = ml_find_line(buf___3, curline, 19);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
        return (-1L);
      }
    }
    dp = (DATA_BL *)hp->bh_data;
    count___2 = (int )((buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low) + 1L);
    idx = (int )(curline - buf___3->b_ml.ml_locked_low);
    start_idx = idx;
    if (idx == 0) {
      text_end = (int )dp->db_txt_end;
    } else {
      text_end = (int )(dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
    }
    if (line) {
      if (curline + (linenr_t )(count___2 - idx) >= line) {
        idx = (int )((linenr_t )idx + ((line - curline) - 1L));
      } else {
        idx = count___2 - 1;
      }
    } else {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (offset >= ((size + (long )text_end) - (long )((int )(dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))))) + (long )ffdos)) {
          goto while_break___1;
        }
        if (ffdos) {
          size ++;
        }
        if (idx == count___2 - 1) {
          goto while_break___1;
        }
        idx ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    len___0 = (int )((unsigned int )text_end - (dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))));
    size += (long )len___0;
    if ((unsigned long )offp != (unsigned long )((void *)0)) {
      if (size >= offset) {
        if (size + (long )ffdos == offset) {
          *offp = 0L;
        } else { //Added block
        if (idx == start_idx) {
          *offp = (offset - size) + (long )len___0;
        } else {
          *offp = ((offset - size) + (long )len___0) - (long )((unsigned int )text_end - (dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))));
        }
        }
        return ((curline + (linenr_t )idx) - (linenr_t )start_idx);
      }
    }
    curline = buf___3->b_ml.ml_locked_high + 1L;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (ffdos) {
    size += line - 1L;
  }
  return (size);
}
}
void goto_byte(long cnt ) 
{ 
  long boff ;
  linenr_t lnum ;

  {
  {
  boff = cnt;
  ml_flush_line(curbuf);
  setpcmark();
  }
  if (boff) {
    boff --;
  }
  {
  lnum = ml_find_line_or_offset(curbuf, (linenr_t )0, & boff);
  }
  if (lnum < 1L) {
    {
    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
    curwin->w_curswant = (colnr_t )2147483647;
    coladvance((colnr_t )2147483647);
    }
  } else {
    curwin->w_cursor.lnum = lnum;
    curwin->w_cursor.col = (colnr_t )boff;
    curwin->w_set_curswant = 1;
  }
  {
  adjust_cursor();
  }
  return;
}
}
#pragma merger("0","/tmp/cil-VelGDUyk.i","-O0")
char_u *menu_name_skip(char_u *name___1 ) ;
int get_menu_index(VimMenu *menu___1 , int state ) ;
int menubar_menu(char_u *name___1 ) ;
int popup_menu(char_u *name___1 ) ;
int toolbar_menu(char_u *name___1 ) ;
int is_menu_separator(char_u *name___1 ) ;
static int add_menu_path(char_u *menu_path , int modes , int *pri_tab , char_u *call_data ,
                         int noremap ) ;
static int remove_menu(VimMenu **menup , char_u *name___1 , int modes , int silent ) ;
static void free_menu(VimMenu **menup ) ;
static void free_menu_string(VimMenu *menu___1 , int idx ) ;
static int show_menus(char_u *path_name , int modes ) ;
static void show_menus_recursive(VimMenu *menu___1 , int modes , int depth___1 ) ;
static int menu_name_equal(char_u *name___1 , VimMenu *menu___1 ) ;
static int menu_namecmp(char_u *name___1 , char_u *mname ) ;
static int get_menu_cmd_modes(char_u *cmd , int forceit , int *noremap , int *unmenu ) ;
static char_u *popup_mode_name(char_u *name___1 , int idx ) ;
static char_u *menu_text(char_u *str___1 , int *mnemonic , char_u **actext ) ;
static char_u menu_mode_chars[6]  = {      (char_u )'n',      (char_u )'v',      (char_u )'o',      (char_u )'i', 
        (char_u )'c',      (char_u )'t'};
void do_menu(EXARG *eap ) 
{ 
  char_u *menu_path ;
  int modes ;
  char_u *map_to ;
  int noremap ;
  int unmenu ;
  char_u *map_buf ;
  char_u *arg ;
  char_u *p___0 ;
  int i___0 ;
  int pri_tab[11] ;
  unsigned short const   **tmp ;
  long tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
  modes = get_menu_cmd_modes(eap->cmd, eap->forceit, & noremap, & unmenu);
  arg = eap->arg;
  p___0 = arg;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp + (int )*p___0) & 2048)) {
      if ((int )*p___0 != 46) {
        goto while_break;
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*p___0 == 32) {
    goto _L;
  } else { //Added block
  if ((int )*p___0 == 9) {
    _L: 
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (i___0 < 10) {
        if ((int )*arg == 32) {
          goto while_break___0;
        } else { //Added block
        if ((int )*arg == 9) {
          goto while_break___0;
        }
        }
      } else {
        goto while_break___0;
      }
      {
      tmp___0 = getdigits(& arg);
      pri_tab[i___0] = (int )tmp___0;
      }
      if (pri_tab[i___0] == 0) {
        pri_tab[i___0] = 500;
      }
      if ((int )*arg == 46) {
        arg ++;
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    arg = skipwhite(arg);
    }
  } else { //Added block
  if (eap->addr_count) {
    if (eap->line2 != 0L) {
      pri_tab[0] = (int )eap->line2;
      i___0 = 1;
    } else {
      i___0 = 0;
    }
  } else {
    i___0 = 0;
  }
  }
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (i___0 < 10)) {
      goto while_break___1;
    }
    tmp___1 = i___0;
    i___0 ++;
    pri_tab[tmp___1] = 500;
  }
  while_break___1: /* CIL Label */ ;
  }
  pri_tab[10] = -1;
  menu_path = arg;
  if ((int )*menu_path == 0) {
    {
    show_menus(menu_path, modes);
    }
    return;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (*arg) {
      if ((int )*arg == 32) {
        goto while_break___2;
      } else { //Added block
      if ((int )*arg == 9) {
        goto while_break___2;
      }
      }
    } else {
      goto while_break___2;
    }
    if ((int )*arg == 92) {
      goto _L___1;
    } else { //Added block
    if ((int )*arg == 22) {
      _L___1: 
      if ((int )*(arg + 1) != 0) {
        arg ++;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      {
      tmp___3 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"<TAB>"),
                            (size_t )5);
      }
      if (tmp___3 == 0) {
        {
        *arg = (char_u )'\t';
        tmp___2 = strlen((char const   *)((char *)(arg + 4)));
        memmove((void *)((char *)(arg + 1)), (void const   *)((char *)(arg + 5)),
                tmp___2);
        }
      }
    }
    }
    arg ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  if ((int )*arg != 0) {
    tmp___4 = arg;
    arg ++;
    *tmp___4 = (char_u )'\000';
  }
  {
  arg = skipwhite(arg);
  map_to = arg;
  }
  if ((int )*map_to == 0) {
    if (! unmenu) {
      {
      show_menus(menu_path, modes);
      }
      return;
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if ((int )*map_to != 0) {
    if (unmenu) {
      {
      emsg((char_u *)"Trailing characters");
      }
      return;
    }
  }
  }
  if (unmenu) {
    {
    tmp___5 = strcmp((char const   *)((char *)menu_path), (char const   *)((char *)"*"));
    }
    if (tmp___5 == 0) {
      menu_path = (char_u *)"";
    }
    {
    tmp___6 = popup_menu(menu_path);
    }
    if (tmp___6) {
      i___0 = 0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! (i___0 < 5)) {
          goto while_break___3;
        }
        if (modes & (1 << i___0)) {
          {
          p___0 = popup_mode_name(menu_path, i___0);
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            remove_menu(& root_menu, p___0, (1 << 5) - 1, 1);
            vim_free((void *)p___0);
            }
          }
        }
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    remove_menu(& root_menu, menu_path, modes, 0);
    }
  } else {
    {
    map_to = replace_termcodes(map_to, & map_buf, 0, 1);
    add_menu_path(menu_path, modes, pri_tab, map_to, noremap);
    tmp___7 = popup_menu(menu_path);
    }
    if (tmp___7) {
      i___0 = 0;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! (i___0 < 5)) {
          goto while_break___4;
        }
        if (modes & (1 << i___0)) {
          {
          p___0 = popup_mode_name(menu_path, i___0);
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            add_menu_path(p___0, modes, pri_tab, map_to, noremap);
            vim_free((void *)p___0);
            }
          }
        }
        i___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
    vim_free((void *)map_buf);
    }
  }
  return;
}
}
static int add_menu_path(char_u *menu_path , int modes , int *pri_tab , char_u *call_data ,
                         int noremap ) 
{ 
  char_u *path_name ;
  VimMenu **menup ;
  VimMenu *menu___1 ;
  VimMenu *parent ;
  VimMenu **lower_pri ;
  char_u *p___0 ;
  char_u *name___1 ;
  char_u *dname ;
  char_u *next_name ;
  int i___0 ;
  int c ;
  int pri_idx ;
  int old_modes ;
  int amenu ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  size_t tmp___5 ;

  {
  {
  menu___1 = (VimMenu *)((void *)0);
  pri_idx = 0;
  old_modes = 0;
  path_name = vim_strsave(menu_path);
  }
  if ((unsigned long )path_name == (unsigned long )((void *)0)) {
    return (0);
  }
  menup = & root_menu;
  parent = (VimMenu *)((void *)0);
  name___1 = path_name;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *name___1) {
      goto while_break;
    }
    {
    next_name = menu_name_skip(name___1);
    dname = menu_text(name___1, (int *)((void *)0), (char_u **)((void *)0));
    lower_pri = menup;
    menu___1 = *menup;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )menu___1 != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      tmp = menu_name_equal(name___1, menu___1);
      }
      if (tmp) {
        goto _L;
      } else {
        {
        tmp___0 = menu_name_equal(dname, menu___1);
        }
        if (tmp___0) {
          _L: 
          if ((int )*next_name == 0) {
            if ((unsigned long )menu___1->children != (unsigned long )((void *)0)) {
              if (! sys_menu) {
                {
                emsg((char_u *)"Menu path must not lead to a sub-menu");
                }
              }
              goto erret;
            }
          }
          if ((int )*next_name != 0) {
            if ((unsigned long )menu___1->children == (unsigned long )((void *)0)) {
              if (! sys_menu) {
                {
                emsg((char_u *)"Part of menu-item path is not sub-menu");
                }
              }
              goto erret;
            }
          }
          goto while_break___0;
        }
      }
      menup = & menu___1->next;
      if ((unsigned long )parent != (unsigned long )((void *)0)) {
        goto _L___0;
      } else {
        {
        tmp___1 = menubar_menu(menu___1->name);
        }
        if (tmp___1) {
          _L___0: 
          if (menu___1->priority <= *(pri_tab + pri_idx)) {
            lower_pri = menup;
          }
        }
      }
      menu___1 = menu___1->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
      if ((int )*next_name == 0) {
        if ((unsigned long )parent == (unsigned long )((void *)0)) {
          {
          emsg((char_u *)"Must not add menu items directly to menu bar");
          }
          goto erret;
        }
      }
      {
      tmp___2 = is_menu_separator(dname);
      }
      if (tmp___2) {
        if ((int )*next_name != 0) {
          {
          emsg((char_u *)"Separator cannot be part of a menu path");
          }
          goto erret;
        }
      }
      {
      tmp___3 = alloc_clear((unsigned int )sizeof(VimMenu ));
      menu___1 = (VimMenu *)tmp___3;
      }
      if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
        goto erret;
      }
      {
      menu___1->modes = modes;
      menu___1->name = vim_strsave(name___1);
      menu___1->dname = menu_text(name___1, & menu___1->mnemonic, & menu___1->actext);
      menu___1->priority = *(pri_tab + pri_idx);
      menu___1->next = *lower_pri;
      *lower_pri = menu___1;
      old_modes = 0;
      }
    } else {
      old_modes = menu___1->modes;
      menu___1->modes |= modes;
    }
    {
    menup = & menu___1->children;
    parent = menu___1;
    name___1 = next_name;
    vim_free((void *)dname);
    }
    if (*(pri_tab + (pri_idx + 1)) != -1) {
      pri_idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)path_name);
  amenu = (modes & (1 | (1 << 3))) == (1 | (1 << 3));
  }
  if (sys_menu) {
    modes &= ~ old_modes;
  }
  if ((unsigned long )menu___1 != (unsigned long )((void *)0)) {
    if (modes) {
      if ((unsigned long )call_data == (unsigned long )((void *)0)) {
        p___0 = (char_u *)((void *)0);
      } else {
        {
        tmp___4 = vim_strsave(call_data);
        p___0 = tmp___4;
        }
      }
      i___0 = 0;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (i___0 < 6)) {
          goto while_break___1;
        }
        if (modes & (1 << i___0)) {
          {
          free_menu_string(menu___1, i___0);
          c = 0;
          }
          if (amenu) {
            {
            if (1 << i___0 == 1 << 1) {
              goto case_exp;
            }
            if (1 << i___0 == 1 << 2) {
              goto case_exp;
            }
            if (1 << i___0 == 1 << 4) {
              goto case_exp;
            }
            if (1 << i___0 == 1 << 3) {
              goto case_exp___2;
            }
            goto switch_break;
            case_exp: /* CIL Label */ 
            case_exp___0: /* CIL Label */ 
            case_exp___1: /* CIL Label */ 
            c = 3;
            goto switch_break;
            case_exp___2: /* CIL Label */ 
            c = 15;
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
          if (c) {
            {
            tmp___5 = strlen((char const   *)((char *)call_data));
            menu___1->strings[i___0] = alloc((unsigned int )(tmp___5 + 2UL));
            }
            if ((unsigned long )menu___1->strings[i___0] != (unsigned long )((void *)0)) {
              {
              *(menu___1->strings[i___0] + 0) = (char_u )c;
              strcpy((char * __restrict  )((char *)(menu___1->strings[i___0] + 1)),
                     (char const   * __restrict  )((char *)call_data));
              }
            }
          } else {
            menu___1->strings[i___0] = p___0;
          }
          menu___1->noremap[i___0] = noremap;
        }
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return (1);
  erret: 
  {
  vim_free((void *)path_name);
  vim_free((void *)dname);
  }
  return (0);
}
}
static int remove_menu(VimMenu **menup , char_u *name___1 , int modes , int silent ) 
{ 
  VimMenu *menu___1 ;
  VimMenu *child ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )*menup == (unsigned long )((void *)0)) {
    return (1);
  }
  {
  p___0 = menu_name_skip(name___1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    menu___1 = *menup;
    if (! ((unsigned long )menu___1 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((int )*name___1 == 0) {
      goto _L;
    } else {
      {
      tmp___0 = menu_name_equal(name___1, menu___1);
      }
      if (tmp___0) {
        _L: 
        if ((int )*p___0 != 0) {
          if ((unsigned long )menu___1->children == (unsigned long )((void *)0)) {
            if (! silent) {
              {
              emsg((char_u *)"Part of menu-item path is not sub-menu");
              }
            }
            return (0);
          }
        }
        if ((menu___1->modes & modes) != 0) {
          {
          tmp = remove_menu(& menu___1->children, p___0, modes, silent);
          }
          if (tmp == 0) {
            return (0);
          }
        } else { //Added block
        if ((int )*name___1 != 0) {
          if (! silent) {
            {
            emsg((char_u *)"Menu only exists in another mode");
            }
          }
          return (0);
        }
        }
        if ((int )*name___1 != 0) {
          goto while_break;
        }
        menu___1->modes &= ~ modes;
        if (modes & (1 << 5)) {
          {
          free_menu_string(menu___1, 5);
          }
        }
        if ((menu___1->modes & ((1 << 5) - 1)) == 0) {
          {
          free_menu(menup);
          }
        } else {
          menup = & menu___1->next;
        }
      } else {
        menup = & menu___1->next;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*name___1 != 0) {
    if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
      if (! silent) {
        {
        emsg((char_u *)"No menu of that name");
        }
      }
      return (0);
    }
    menu___1->modes &= ~ modes;
    child = menu___1->children;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )child != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      menu___1->modes |= child->modes;
      child = child->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (modes & (1 << 5)) {
      {
      free_menu_string(menu___1, 5);
      }
    }
    if ((menu___1->modes & ((1 << 5) - 1)) == 0) {
      {
      *menup = menu___1;
      free_menu(menup);
      }
    }
  }
  return (1);
}
}
static void free_menu(VimMenu **menup ) 
{ 
  int i___0 ;
  VimMenu *menu___1 ;

  {
  {
  menu___1 = *menup;
  *menup = menu___1->next;
  vim_free((void *)menu___1->name);
  vim_free((void *)menu___1->dname);
  vim_free((void *)menu___1->actext);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 6)) {
      goto while_break;
    }
    {
    free_menu_string(menu___1, i___0);
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)menu___1);
  }
  return;
}
}
static void free_menu_string(VimMenu *menu___1 , int idx ) 
{ 
  int count___2 ;
  int i___0 ;

  {
  count___2 = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 6)) {
      goto while_break;
    }
    if ((unsigned long )menu___1->strings[i___0] == (unsigned long )menu___1->strings[idx]) {
      count___2 ++;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (count___2 == 1) {
    {
    vim_free((void *)menu___1->strings[idx]);
    }
  }
  menu___1->strings[idx] = (char_u *)((void *)0);
  return;
}
}
static int show_menus(char_u *path_name , int modes ) 
{ 
  char_u *p___0 ;
  char_u *name___1 ;
  VimMenu *menu___1 ;
  VimMenu *parent ;
  int tmp ;

  {
  {
  parent = (VimMenu *)((void *)0);
  menu___1 = root_menu;
  path_name = vim_strsave(path_name);
  name___1 = path_name;
  }
  if ((unsigned long )path_name == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *name___1) {
      goto while_break;
    }
    {
    p___0 = menu_name_skip(name___1);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )menu___1 != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      tmp = menu_name_equal(name___1, menu___1);
      }
      if (tmp) {
        if ((int )*p___0 != 0) {
          if ((unsigned long )menu___1->children == (unsigned long )((void *)0)) {
            {
            emsg((char_u *)"Part of menu-item path is not sub-menu");
            vim_free((void *)path_name);
            }
            return (0);
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if ((menu___1->modes & modes) == 0) {
          {
          emsg((char_u *)"Menu only exists in another mode");
          vim_free((void *)path_name);
          }
          return (0);
        }
        }
        goto while_break___0;
      }
      menu___1 = menu___1->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
      {
      emsg((char_u *)"No menu of that name");
      vim_free((void *)path_name);
      }
      return (0);
    }
    name___1 = p___0;
    parent = menu___1;
    menu___1 = menu___1->children;
  }
  while_break: /* CIL Label */ ;
  }
  {
  msg_puts_title((char_u *)"\n--- Menus ---");
  show_menus_recursive(parent, modes, 0);
  }
  return (1);
}
}
static void show_menus_recursive(VimMenu *menu___1 , int modes , int depth___1 ) 
{ 
  int i___0 ;
  int bit ;
  int tmp ;

  {
  if ((unsigned long )menu___1 != (unsigned long )((void *)0)) {
    if ((menu___1->modes & modes) == 0) {
      return;
    }
  }
  if ((unsigned long )menu___1 != (unsigned long )((void *)0)) {
    {
    msg_putchar('\n');
    }
    if (got_int) {
      return;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < depth___1)) {
        goto while_break;
      }
      {
      msg_puts((char_u *)"  ");
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (menu___1->priority) {
      {
      msg_outnum((long )menu___1->priority);
      msg_puts((char_u *)" ");
      }
    }
    {
    msg_outtrans_attr(menu___1->name, highlight_attr[2]);
    }
  }
  if ((unsigned long )menu___1 != (unsigned long )((void *)0)) {
    if ((unsigned long )menu___1->children == (unsigned long )((void *)0)) {
      bit = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (bit < 6)) {
          goto while_break___0;
        }
        if (((menu___1->modes & modes) & (1 << bit)) != 0) {
          {
          msg_putchar('\n');
          }
          if (got_int) {
            return;
          }
          i___0 = 0;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (i___0 < depth___1 + 2)) {
              goto while_break___1;
            }
            {
            msg_puts((char_u *)"  ");
            i___0 ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
          msg_putchar((int )menu_mode_chars[bit]);
          }
          if (menu___1->noremap[bit]) {
            {
            msg_putchar('*');
            }
          } else {
            {
            msg_putchar(' ');
            }
          }
          {
          msg_puts((char_u *)"  ");
          msg_outtrans_special(menu___1->strings[bit], 0);
          }
        }
        bit ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
      menu___1 = root_menu;
      depth___1 --;
    } else {
      menu___1 = menu___1->children;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if ((unsigned long )menu___1 != (unsigned long )((void *)0)) {
        if (! (! got_int)) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
      {
      tmp = popup_menu(menu___1->dname);
      }
      if (tmp) {
        if ((int )*(menu___1->dname + 5) == 0) {
          {
          show_menus_recursive(menu___1, modes, depth___1 + 1);
          }
        }
      } else {
        {
        show_menus_recursive(menu___1, modes, depth___1 + 1);
        }
      }
      menu___1 = menu___1->next;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
static VimMenu *expand_menu  =    (VimMenu *)((void *)0);
static int expand_modes  =    0;
char_u *set_context_in_menu_cmd(char_u *cmd , char_u *arg , int forceit ) 
{ 
  char_u *after_dot ;
  char_u *p___0 ;
  char_u *path_name ;
  char_u *name___1 ;
  int unmenu ;
  VimMenu *menu___1 ;
  int tmp ;

  {
  path_name = (char_u *)((void *)0);
  expand_context = -1;
  after_dot = arg;
  p___0 = arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if ((int )*p___0 == 32) {
        goto while_break;
      } else { //Added block
      if ((int )*p___0 == 9) {
        goto while_break;
      }
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 92) {
      goto _L___0;
    } else { //Added block
    if ((int )*p___0 == 22) {
      _L___0: 
      if ((int )*(p___0 + 1) != 0) {
        p___0 ++;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*p___0 == 46) {
      after_dot = p___0 + 1;
    }
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*cmd == 101) {
    if ((int )*p___0 == 32) {
      return ((char_u *)((void *)0));
    } else { //Added block
    if ((int )*p___0 == 9) {
      return ((char_u *)((void *)0));
    }
    }
  }
  if ((int )*p___0 == 0) {
    {
    expand_modes = get_menu_cmd_modes(cmd, forceit, (int *)((void *)0), & unmenu);
    }
    if (! unmenu) {
      expand_modes = (1 << 5) - 1;
    }
    menu___1 = root_menu;
    if ((unsigned long )after_dot != (unsigned long )arg) {
      {
      path_name = alloc((unsigned int )(after_dot - arg));
      }
      if ((unsigned long )path_name == (unsigned long )((void *)0)) {
        return ((char_u *)((void *)0));
      }
      {
      strncpy((char * __restrict  )((char *)path_name), (char const   * __restrict  )((char *)arg),
              (size_t )((after_dot - arg) - 1L));
      *(path_name + ((after_dot - arg) - 1L)) = (char_u )'\000';
      }
    }
    name___1 = path_name;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
        if (! *name___1) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      {
      p___0 = menu_name_skip(name___1);
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((unsigned long )menu___1 != (unsigned long )((void *)0))) {
          goto while_break___1;
        }
        {
        tmp = menu_name_equal(name___1, menu___1);
        }
        if (tmp) {
          if ((int )*p___0 != 0) {
            if ((unsigned long )menu___1->children == (unsigned long )((void *)0)) {
              {
              vim_free((void *)path_name);
              }
              return ((char_u *)((void *)0));
            } else {
              goto _L___1;
            }
          } else { //Added block
          _L___1: 
          if ((menu___1->modes & expand_modes) == 0) {
            {
            vim_free((void *)path_name);
            }
            return ((char_u *)((void *)0));
          }
          }
          goto while_break___1;
        }
        menu___1 = menu___1->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
        {
        vim_free((void *)path_name);
        }
        return ((char_u *)((void *)0));
      }
      name___1 = p___0;
      menu___1 = menu___1->children;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((int )*cmd == 101) {
      expand_context = 21;
    } else {
      expand_context = 11;
    }
    expand_pattern = after_dot;
    expand_menu = menu___1;
  } else {
    expand_context = 0;
  }
  return ((char_u *)((void *)0));
}
}
static VimMenu *menu  =    (VimMenu *)((void *)0);
static int get_dname  =    0;
char_u *get_menu_name(int idx ) 
{ 
  char_u *str___1 ;
  int tmp ;
  int tmp___0 ;

  {
  if (idx == 0) {
    menu = expand_menu;
    get_dname = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )menu != (unsigned long )((void *)0)) {
      {
      tmp = popup_menu(menu->dname);
      }
      if (tmp) {
        if (! *(menu->dname + 5)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    menu = menu->next;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )menu == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  if (menu->modes & expand_modes) {
    if (get_dname) {
      str___1 = menu->dname;
      get_dname = 0;
    } else {
      {
      str___1 = menu->name;
      tmp___0 = strcmp((char const   *)((char *)menu->name), (char const   *)((char *)menu->dname));
      }
      if (tmp___0) {
        get_dname = 1;
      }
    }
  } else {
    str___1 = (char_u *)"";
    get_dname = 0;
  }
  if (! get_dname) {
    menu = menu->next;
  }
  return (str___1);
}
}
static VimMenu *menu___0  =    (VimMenu *)((void *)0);
static char_u tbuffer[256]  ;
char_u *get_menu_names(int idx ) 
{ 
  char_u *str___1 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  if (idx == 0) {
    menu___0 = expand_menu;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )menu___0 != (unsigned long )((void *)0)) {
      {
      tmp = popup_menu(menu___0->dname);
      }
      if (! tmp) {
        {
        tmp___0 = is_menu_separator(menu___0->dname);
        }
        if (! tmp___0) {
          {
          tmp___1 = strlen((char const   *)((char *)menu___0->dname));
          }
          if (! ((int )*(menu___0->dname + (tmp___1 - 1UL)) == 46)) {
            goto while_break;
          }
        }
      }
    } else {
      goto while_break;
    }
    menu___0 = menu___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )menu___0 == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  if (menu___0->modes & expand_modes) {
    if ((unsigned long )menu___0->children != (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )((char *)(tbuffer)), (char const   * __restrict  )((char *)menu___0->dname));
      strcat((char * __restrict  )((char *)(tbuffer)), (char const   * __restrict  )((char *)"\001"));
      str___1 = tbuffer;
      }
    } else {
      str___1 = menu___0->dname;
    }
  } else {
    str___1 = (char_u *)"";
  }
  menu___0 = menu___0->next;
  return (str___1);
}
}
char_u *menu_name_skip(char_u *name___1 ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  char_u *tmp___0 ;

  {
  p___0 = name___1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if (! ((int )*p___0 != 46)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 92) {
      goto _L;
    } else { //Added block
    if ((int )*p___0 == 22) {
      _L: 
      {
      tmp = strlen((char const   *)((char *)p___0));
      memmove((void *)((char *)p___0), (void const   *)((char *)(p___0 + 1)), tmp);
      }
      if ((int )*p___0 == 0) {
        goto while_break;
      }
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (*p___0) {
    tmp___0 = p___0;
    p___0 ++;
    *tmp___0 = (char_u )'\000';
  }
  return (p___0);
}
}
static int menu_name_equal(char_u *name___1 , VimMenu *menu___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = menu_namecmp(name___1, menu___1->name);
  }
  if (tmp) {
    tmp___1 = 1;
  } else {
    {
    tmp___0 = menu_namecmp(name___1, menu___1->dname);
    }
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
static int menu_namecmp(char_u *name___1 , char_u *mname ) 
{ 
  int i___0 ;
  int tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*(name___1 + i___0) != 0) {
      if (! ((int )*(name___1 + i___0) != 9)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*(name___1 + i___0) != (int )*(mname + i___0)) {
      goto while_break;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*(name___1 + i___0) == 0) {
    goto _L;
  } else { //Added block
  if ((int )*(name___1 + i___0) == 9) {
    _L: 
    if ((int )*(mname + i___0) == 0) {
      tmp = 1;
    } else { //Added block
    if ((int )*(mname + i___0) == 9) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
static int get_menu_cmd_modes(char_u *cmd , int forceit , int *noremap , int *unmenu ) 
{ 
  int modes ;
  char_u *tmp ;

  {
  tmp = cmd;
  cmd ++;
  {
  if ((int )*tmp == 118) {
    goto case_118;
  }
  if ((int )*tmp == 111) {
    goto case_111;
  }
  if ((int )*tmp == 105) {
    goto case_105;
  }
  if ((int )*tmp == 116) {
    goto case_116;
  }
  if ((int )*tmp == 99) {
    goto case_99;
  }
  if ((int )*tmp == 97) {
    goto case_97;
  }
  if ((int )*tmp == 110) {
    goto case_110;
  }
  goto switch_default;
  case_118: /* CIL Label */ 
  modes = 1 << 1;
  goto switch_break;
  case_111: /* CIL Label */ 
  modes = 1 << 2;
  goto switch_break;
  case_105: /* CIL Label */ 
  modes = 1 << 3;
  goto switch_break;
  case_116: /* CIL Label */ 
  modes = 1 << 5;
  goto switch_break;
  case_99: /* CIL Label */ 
  modes = 1 << 4;
  goto switch_break;
  case_97: /* CIL Label */ 
  modes = ((((1 << 3) | (1 << 4)) | 1) | (1 << 1)) | (1 << 2);
  goto switch_break;
  case_110: /* CIL Label */ 
  if ((int )*(cmd + 1) != 111) {
    modes = 1;
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  cmd --;
  if (forceit) {
    modes = (1 << 3) | (1 << 4);
  } else {
    modes = (1 | (1 << 1)) | (1 << 2);
  }
  switch_break: /* CIL Label */ ;
  }
  if ((unsigned long )noremap != (unsigned long )((void *)0)) {
    *noremap = (int )*cmd == 110;
  }
  if ((unsigned long )unmenu != (unsigned long )((void *)0)) {
    *unmenu = (int )*cmd == 117;
  }
  return (modes);
}
}
static char_u *popup_mode_name(char_u *name___1 , int idx ) 
{ 
  char_u *p___0 ;
  int len___0 ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)name___1));
  len___0 = (int )tmp;
  p___0 = vim_strnsave(name___1, len___0 + 1);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    memmove((void *)((char *)(p___0 + 6)), (void const   *)((char *)(p___0 + 5)),
            (size_t )(len___0 - 4));
    *(p___0 + 5) = menu_mode_chars[idx];
    }
  }
  return (p___0);
}
}
int get_menu_index(VimMenu *menu___1 , int state ) 
{ 
  int idx ;

  {
  if (VIsual_active) {
    idx = 1;
  } else { //Added block
  if (state & 16) {
    idx = 3;
  } else { //Added block
  if (state & 8) {
    idx = 4;
  } else { //Added block
  if (finish_op) {
    idx = 2;
  } else { //Added block
  if (state & 1) {
    idx = 0;
  } else {
    idx = -1;
  }
  }
  }
  }
  }
  if (idx != -1) {
    if ((unsigned long )menu___1->strings[idx] == (unsigned long )((void *)0)) {
      idx = -1;
    }
  }
  return (idx);
}
}
static char_u *menu_text(char_u *str___1 , int *mnemonic , char_u **actext ) 
{ 
  char_u *p___0 ;
  char_u *text ;
  size_t tmp ;

  {
  {
  p___0 = vim_strchr(str___1, '\t');
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if ((unsigned long )actext != (unsigned long )((void *)0)) {
      {
      *actext = vim_strsave(p___0 + 1);
      }
    }
    {
    text = vim_strnsave(str___1, (int )(p___0 - str___1));
    }
  } else {
    {
    text = vim_strsave(str___1);
    }
  }
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
    p___0 = vim_strchr(text, '&');
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      if ((unsigned long )mnemonic != (unsigned long )((void *)0)) {
        *mnemonic = (int )*(p___0 + 1);
      }
      {
      tmp = strlen((char const   *)((char *)p___0));
      memmove((void *)((char *)p___0), (void const   *)((char *)(p___0 + 1)), tmp);
      }
    }
  }
  return (text);
}
}
int menubar_menu(char_u *name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = popup_menu(name___1);
  }
  if (tmp) {
    tmp___1 = 0;
  } else {
    {
    tmp___0 = toolbar_menu(name___1);
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else { //Added block
    if ((int )*name___1 != 93) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    }
  }
  return (tmp___1);
}
}
int popup_menu(char_u *name___1 ) 
{ 
  int tmp ;

  {
  {
  tmp = strncmp((char const   *)((char *)name___1), (char const   *)((char *)"PopUp"),
                (size_t )5);
  }
  return (tmp == 0);
}
}
int toolbar_menu(char_u *name___1 ) 
{ 
  int tmp ;

  {
  {
  tmp = strncmp((char const   *)((char *)name___1), (char const   *)((char *)"ToolBar"),
                (size_t )7);
  }
  return (tmp == 0);
}
}
void execute_menu(char_u *path_name ) 
{ 
  VimMenu *menu___1 ;
  char_u *name___1 ;
  char_u *saved_name ;
  char_u *p___0 ;
  int idx ;
  int tmp ;
  int tmp___0 ;

  {
  {
  saved_name = vim_strsave(path_name);
  }
  if ((unsigned long )saved_name == (unsigned long )((void *)0)) {
    return;
  }
  menu___1 = root_menu;
  name___1 = saved_name;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *name___1) {
      goto while_break;
    }
    {
    p___0 = menu_name_skip(name___1);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )menu___1 != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      tmp = menu_name_equal(name___1, menu___1);
      }
      if (tmp) {
        if ((int )*p___0 == 0) {
          if ((unsigned long )menu___1->children != (unsigned long )((void *)0)) {
            {
            emsg((char_u *)"Menu path must lead to a menu item");
            menu___1 = (VimMenu *)((void *)0);
            }
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if ((int )*p___0 != 0) {
          if ((unsigned long )menu___1->children == (unsigned long )((void *)0)) {
            {
            emsg((char_u *)"Part of menu-item path is not sub-menu");
            menu___1 = (VimMenu *)((void *)0);
            }
          }
        }
        }
        goto while_break___0;
      }
      menu___1 = menu___1->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
      goto while_break;
    } else { //Added block
    if ((int )*p___0 == 0) {
      goto while_break;
    }
    }
    menu___1 = menu___1->children;
    name___1 = p___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)saved_name);
  }
  if ((unsigned long )menu___1 == (unsigned long )((void *)0)) {
    {
    emsg((char_u *)"Menu not found - check menu names");
    }
    return;
  }
  {
  idx = get_menu_index(menu___1, 1);
  }
  if (idx != -1) {
    if (menu___1->noremap[idx]) {
      tmp___0 = -1;
    } else {
      tmp___0 = 0;
    }
    {
    ins_typebuf(menu___1->strings[idx], tmp___0, 0, 1);
    }
  } else {
    {
    emsg((char_u *)"Menu not defined for Normal mode");
    }
  }
  return;
}
}
int is_menu_separator(char_u *name___1 ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  if ((int )*(name___1 + 0) == 45) {
    {
    tmp = strlen((char const   *)((char *)name___1));
    }
    if ((int )*(name___1 + (tmp - 1UL)) == 45) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
#pragma merger("0","/tmp/cil-UVU21_qu.i","-O0")
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
char_u *msg_strtrunc(char_u *s ) ;
void msg_home_replace_hl(char_u *fname ) ;
void str2specialbuf(char_u *sp , char_u *buf___3 , int len___0 ) ;
void msg_puts_long_len_attr(char_u *longstr , int len___0 , int attr ) ;
void msg_moremsg(int full ) ;
void repeat_message(void) ;
void msg_clr_cmdline(void) ;
void give_warning(char_u *message , int hl ) ;
void display_confirm_msg(void) ;
void screen_puts(char_u *text , int row , int col , int attr ) ;
void screen_fill(int start_row , int end_row , int start_col , int end_col , int c1 ,
                 int c2 , int attr ) ;
int screen_del_lines(int off___0 , int row , int line_count , int end , int force ) ;
int screen_valid(int clear ) ;
int jump_to_mouse(int flags___0 , int *inclusive ) ;
void out_str(char_u *s ) ;
static void reset_last_sourcing(void) ;
static void add_msg_hist(char_u *s , int len___0 , int attr ) ;
static void hit_return_msg(void) ;
static void msg_home_replace_attr(char_u *fname , int attr ) ;
static int msg_use_printf(void) ;
static void msg_screen_putchar(int c , int attr ) ;
static int msg_check_screen(void) ;
static void redir_write(char_u *s ) ;
static char_u *msg_show_console_dialog(char_u *message , char_u *buttons , int dfltbutton ) ;
static int msg_noquit_more  =    0;
static struct msg_hist *first_msg_hist  =    (struct msg_hist *)((void *)0);
static struct msg_hist *last_msg_hist  =    (struct msg_hist *)((void *)0);
static int msg_hist_len  =    0;
static int msg_hist_off  =    0;
int msg(char_u *s ) 
{ 
  int tmp ;

  {
  {
  set_vim_var_string(4, s);
  tmp = msg_attr(s, 0);
  }
  return (tmp);
}
}
static int entered___0  =    0;
int msg_attr(char_u *s , int attr ) 
{ 
  int retval ;
  char_u *buf___3 ;
  int tmp ;

  {
  buf___3 = (char_u *)((void *)0);
  if (entered___0 >= 3) {
    return (1);
  }
  entered___0 ++;
  if ((unsigned long )s != (unsigned long )keep_msg) {
    {
    add_msg_hist(s, -1, attr);
    }
  } else { //Added block
  if ((int )*s != 60) {
    if ((unsigned long )last_msg_hist != (unsigned long )((void *)0)) {
      if ((unsigned long )last_msg_hist->msg != (unsigned long )((void *)0)) {
        {
        tmp = strcmp((char const   *)((char *)s), (char const   *)((char *)last_msg_hist->msg));
        }
        if (tmp) {
          {
          add_msg_hist(s, -1, attr);
          }
        }
      }
    }
  }
  }
  {
  buf___3 = msg_strtrunc(s);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    s = buf___3;
  }
  {
  msg_start();
  msg_outtrans_attr(s, attr);
  msg_clr_eos();
  retval = msg_end();
  vim_free((void *)buf___3);
  entered___0 --;
  }
  return (retval);
}
}
char_u *msg_strtrunc(char_u *s ) 
{ 
  char_u *buf___3 ;
  int len___0 ;
  int room ;
  int half ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  buf___3 = (char_u *)((void *)0);
  if (! msg_scroll) {
    if (! need_wait_return) {
      {
      tmp___3 = shortmess('T');
      }
      if (tmp___3) {
        if (! exmode_active) {
          {
          len___0 = vim_strsize(s);
          room = (int )(((long )((int )((Rows - (long )cmdline_row) - 1L)) * Columns + (long )sc_col) - 1L);
          }
          if (len___0 > room) {
            {
            buf___3 = alloc((unsigned int )(room + 1));
            }
            if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
              room -= 3;
              half = room / 2;
              len___0 = 0;
              i___0 = 0;
              {
              while (1) {
                while_continue: /* CIL Label */ ;
                if (! (len___0 < half)) {
                  goto while_break;
                }
                {
                tmp = charsize((int )*(s + i___0));
                len___0 += tmp;
                *(buf___3 + i___0) = *(s + i___0);
                i___0 ++;
                }
              }
              while_break: /* CIL Label */ ;
              }
              {
              i___0 --;
              tmp___0 = charsize((int )*(s + i___0));
              len___0 -= tmp___0;
              strcpy((char * __restrict  )((char *)(buf___3 + i___0)), (char const   * __restrict  )((char *)"..."));
              tmp___1 = strlen((char const   *)((char *)s));
              i___0 = (int )(tmp___1 - 1UL);
              }
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (! (len___0 < room)) {
                  goto while_break___0;
                }
                {
                tmp___2 = charsize((int )*(s + i___0));
                len___0 += tmp___2;
                i___0 --;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              if (len___0 > room) {
                i___0 ++;
              }
              {
              strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)((s + i___0) + 1)));
              }
            }
          }
        }
      }
    }
  }
  return (buf___3);
}
}
int smsg(char_u *s  , ...) 
{ 
  va_list arglist ;
  int tmp ;

  {
  {
  __builtin_va_start(arglist, s);
  vsprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s),
           arglist);
  __builtin_va_end(arglist);
  tmp = msg(IObuff);
  }
  return (tmp);
}
}
int smsg_attr(int attr , char_u *s  , ...) 
{ 
  va_list arglist ;
  int tmp ;

  {
  {
  __builtin_va_start(arglist, s);
  vsprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s),
           arglist);
  __builtin_va_end(arglist);
  tmp = msg_attr(IObuff, attr);
  }
  return (tmp);
}
}
static int last_sourcing_lnum  =    0;
static char_u *last_sourcing_name  =    (char_u *)((void *)0);
static void reset_last_sourcing(void) 
{ 


  {
  {
  vim_free((void *)last_sourcing_name);
  last_sourcing_name = (char_u *)((void *)0);
  last_sourcing_lnum = 0;
  }
  return;
}
}
int emsg(char_u *s ) 
{ 
  char_u *Buf ;
  int attr ;
  int other_sourcing_name ;
  size_t tmp ;
  int tmp___0 ;

  {
  if (emsg_off) {
    return (1);
  }
  if (global_busy) {
    global_busy ++;
  }
  if (p_eb) {
    {
    beep_flush();
    }
  } else {
    {
    flush_buffers(0);
    }
  }
  {
  did_emsg = 1;
  set_vim_var_string(2, s);
  emsg_on_display = 1;
  msg_scroll ++;
  attr = highlight_attr[3];
  }
  if (msg_scrolled) {
    need_wait_return = 1;
  }
  if ((unsigned long )sourcing_name != (unsigned long )((void *)0)) {
    if ((unsigned long )last_sourcing_name != (unsigned long )((void *)0)) {
      {
      other_sourcing_name = strcmp((char const   *)((char *)sourcing_name), (char const   *)((char *)last_sourcing_name));
      }
    } else {
      other_sourcing_name = 1;
    }
  } else {
    other_sourcing_name = 0;
  }
  if ((unsigned long )sourcing_name != (unsigned long )((void *)0)) {
    if (other_sourcing_name) {
      goto _L;
    } else { //Added block
    if (sourcing_lnum != (linenr_t )last_sourcing_lnum) {
      _L: 
      {
      tmp = strlen((char const   *)((char *)sourcing_name));
      Buf = alloc((unsigned int )tmp + 35U);
      }
      if ((unsigned long )Buf != (unsigned long )((void *)0)) {
        no_wait_return ++;
        if (other_sourcing_name) {
          {
          sprintf((char * __restrict  )((char *)Buf), (char const   * __restrict  )"Error detected while processing %s:",
                  sourcing_name);
          msg_attr(Buf, attr);
          }
        }
        if (sourcing_lnum != 0L) {
          {
          sprintf((char * __restrict  )((char *)Buf), (char const   * __restrict  )"line %4ld:",
                  sourcing_lnum);
          msg_attr(Buf, highlight_attr[9]);
          }
        }
        {
        no_wait_return --;
        last_sourcing_lnum = (int )sourcing_lnum;
        vim_free((void *)Buf);
        }
      }
    }
    }
  }
  if ((unsigned long )sourcing_name == (unsigned long )((void *)0)) {
    goto _L___0;
  } else { //Added block
  if (other_sourcing_name) {
    _L___0: 
    {
    vim_free((void *)last_sourcing_name);
    }
    if ((unsigned long )sourcing_name == (unsigned long )((void *)0)) {
      last_sourcing_name = (char_u *)((void *)0);
    } else {
      {
      last_sourcing_name = vim_strsave(sourcing_name);
      }
    }
  }
  }
  {
  msg_nowait = 0;
  tmp___0 = msg_attr(s, attr);
  }
  return (tmp___0);
}
}
int emsg2(char_u *s , char_u *a1 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (emsg_off) {
    return (1);
  }
  if ((unsigned long )a1 == (unsigned long )((void *)0)) {
    a1 = (char_u *)"[NULL]";
  }
  {
  tmp = strlen((char const   *)((char *)s));
  tmp___0 = strlen((char const   *)((char *)a1));
  }
  if (tmp + tmp___0 >= 1025UL) {
    a1 = (char_u *)"[string too long]";
  }
  {
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s),
          (char *)a1);
  tmp___1 = emsg(IObuff);
  }
  return (tmp___1);
}
}
int emsgn(char_u *s , long n ) 
{ 
  int tmp ;

  {
  if (emsg_off) {
    return (1);
  }
  {
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s),
          n);
  tmp = emsg(IObuff);
  }
  return (tmp);
}
}
char_u *msg_trunc_attr(char_u *s , int force , int attr ) 
{ 
  int n ;

  {
  {
  add_msg_hist(s, -1, attr);
  s = msg_may_trunc(force, s);
  msg_hist_off = 1;
  n = msg_attr(s, attr);
  msg_hist_off = 0;
  }
  if (n) {
    return (s);
  }
  return ((char_u *)((void *)0));
}
}
char_u *msg_may_trunc(int force , char_u *s ) 
{ 
  int n ;
  int tmp ;
  size_t tmp___0 ;

  {
  if (force) {
    goto _L;
  } else {
    {
    tmp = shortmess('t');
    }
    if (tmp) {
      if (! exmode_active) {
        _L: 
        {
        tmp___0 = strlen((char const   *)((char *)s));
        n = (int )((((long )((int )tmp___0) - (long )((int )((Rows - (long )cmdline_row) - 1L)) * Columns) - (long )sc_col) + 1L);
        }
        if (n > 0) {
          s += n;
          *s = (char_u )'<';
        }
      }
    }
  }
  return (s);
}
}
static void add_msg_hist(char_u *s , int len___0 , int attr ) 
{ 
  struct msg_hist *p___0 ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  if (msg_hist_off) {
    return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (msg_hist_len > 20)) {
      goto while_break;
    }
    {
    p___0 = first_msg_hist;
    first_msg_hist = p___0->next;
    vim_free((void *)p___0->msg);
    vim_free((void *)p___0);
    msg_hist_len --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp = alloc((unsigned int )((int )sizeof(struct msg_hist )));
  p___0 = (struct msg_hist *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if (len___0 < 0) {
      {
      tmp___0 = strlen((char const   *)((char *)s));
      len___0 = (int )tmp___0;
      }
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (len___0 > 0) {
        if (! ((int )*s == 10)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      s ++;
      len___0 --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (len___0 > 0) {
        if (! ((int )*(s + (len___0 - 1)) == 10)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      len___0 --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    p___0->msg = vim_strnsave(s, len___0);
    p___0->next = (struct msg_hist *)((void *)0);
    p___0->attr = attr;
    }
    if ((unsigned long )last_msg_hist != (unsigned long )((void *)0)) {
      last_msg_hist->next = p___0;
    }
    last_msg_hist = p___0;
    if ((unsigned long )first_msg_hist == (unsigned long )((void *)0)) {
      first_msg_hist = last_msg_hist;
    }
    msg_hist_len ++;
  }
  return;
}
}
void ex_messages(void) 
{ 
  struct msg_hist *p___0 ;

  {
  msg_hist_off = 1;
  p___0 = first_msg_hist;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )p___0->msg != (unsigned long )((void *)0)) {
      {
      msg_attr(p___0->msg, p___0->attr);
      }
    }
    p___0 = p___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  msg_hist_off = 0;
  return;
}
}
static void msg_end_prompt(void) ;
static void msg_end_prompt(void) 
{ 


  {
  {
  need_wait_return = 0;
  emsg_on_display = 0;
  cmdline_row = msg_row;
  msg_col = 0;
  msg_clr_eos();
  }
  return;
}
}
void wait_return(int redraw ) 
{ 
  int c ;
  int oldState ;
  int tmpState ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (redraw == 1) {
    must_redraw = 50;
  }
  if (vgetc_busy) {
    return;
  }
  if (no_wait_return) {
    need_wait_return = 1;
    if (! exmode_active) {
      cmdline_row = msg_row;
    }
    return;
  }
  redir_off = 1;
  oldState = State;
  if (quit_more) {
    c = '\r';
    quit_more = 0;
    got_int = 0;
  } else { //Added block
  if (exmode_active) {
    {
    msg_puts((char_u *)" ");
    c = '\r';
    got_int = 0;
    }
  } else {
    {
    State = 1537;
    setmouse();
    hit_return_msg();
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      c = safe_vgetc();
      }
      if (! global_busy) {
        got_int = 0;
      }
      if (! (c == 3)) {
        if (! (c == 253 + (43 << 8))) {
          if (! (c == 253 + (44 << 8))) {
            if (! (c == 253 + (46 << 8))) {
              if (! (c == 253 + (47 << 8))) {
                if (! (c == 253 + (49 << 8))) {
                  if (! (c == 253 + (50 << 8))) {
                    if (! (c == 253 + (67 << 8))) {
                      if (! (c == 253 + (68 << 8))) {
                        if (! (c == 253 + (51 << 8))) {
                          {
                          tmp = mouse_has('r');
                          }
                          if (tmp) {
                            goto while_break;
                          } else { //Added block
                          if (! (c == 253 + (42 << 8))) {
                            if (! (c == 253 + (45 << 8))) {
                              if (! (c == 253 + (48 << 8))) {
                                goto while_break;
                              }
                            }
                          }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    ui_breakcheck();
    }
    if (c == 253 + (42 << 8)) {
      {
      jump_to_mouse(8, (int *)((void *)0));
      }
    } else { //Added block
    if (c == 253 + (45 << 8)) {
      {
      jump_to_mouse(8, (int *)((void *)0));
      }
    } else { //Added block
    if (c == 253 + (48 << 8)) {
      {
      jump_to_mouse(8, (int *)((void *)0));
      }
    } else {
      {
      tmp___0 = vim_strchr((char_u *)"\r\n ", c);
      }
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
        stuffcharReadbuff(c);
        do_redraw = 1;
        }
      }
    }
    }
    }
  }
  }
  redir_off = 0;
  if (c == 58) {
    goto _L;
  } else { //Added block
  if (c == 63) {
    goto _L;
  } else { //Added block
  if (c == 47) {
    _L: 
    if (! exmode_active) {
      cmdline_row = msg_row;
    }
    skip_redraw = 1;
    do_redraw = 0;
  }
  }
  }
  {
  tmpState = State;
  State = oldState;
  setmouse();
  msg_check();
  tmp___1 = swapping_screen();
  }
  if (tmp___1) {
    if (! termcap_active) {
      newline_on_exit = 1;
    }
  }
  {
  need_wait_return = 0;
  emsg_on_display = 0;
  msg_didany = 0;
  lines_left = -1;
  reset_last_sourcing();
  }
  if ((unsigned long )keep_msg != (unsigned long )((void *)0)) {
    {
    tmp___2 = linetabsize(keep_msg);
    }
    if ((long )tmp___2 >= ((Rows - (long )cmdline_row) - 1L) * Columns + (long )sc_col) {
      keep_msg = (char_u *)((void *)0);
    }
  }
  if (tmpState == 2048) {
    {
    starttermcap();
    set_winsize(0, 0, 0);
    }
  } else { //Added block
  if (! skip_redraw) {
    if (redraw == 1) {
      {
      starttermcap();
      update_screen(10);
      }
    } else { //Added block
    if (msg_scrolled) {
      if (redraw != -1) {
        {
        starttermcap();
        update_screen(10);
        }
      }
    }
    }
  }
  }
  return;
}
}
static void hit_return_msg(void) 
{ 
  int tmp ;

  {
  if (msg_didout) {
    {
    msg_putchar('\n');
    }
  }
  if (got_int) {
    {
    msg_puts((char_u *)"Interrupt: ");
    }
  }
  {
  msg_puts_attr((char_u *)"Press RETURN or enter command to continue", highlight_attr[10]);
  tmp = msg_use_printf();
  }
  if (! tmp) {
    {
    msg_clr_eos();
    }
  }
  return;
}
}
void msg_start(void) 
{ 
  int did_return ;

  {
  did_return = 0;
  keep_msg = (char_u *)((void *)0);
  if (! msg_scroll) {
    if (full_screen) {
      msg_row = cmdline_row;
      msg_col = 0;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (msg_didout) {
    {
    msg_putchar('\n');
    did_return = 1;
    }
    if (! exmode_active) {
      cmdline_row = msg_row;
    }
  }
  }
  if (! msg_didany) {
    {
    msg_starthere();
    }
  }
  {
  msg_didout = 0;
  cursor_off();
  }
  if (! did_return) {
    {
    redir_write((char_u *)"\n");
    }
  }
  return;
}
}
void msg_starthere(void) 
{ 


  {
  lines_left = cmdline_row;
  msg_didany = 0;
  return;
}
}
void msg_putchar(int c ) 
{ 


  {
  {
  msg_putchar_attr(c, 0);
  }
  return;
}
}
void msg_putchar_attr(int c , int attr ) 
{ 
  char_u buf___3[4] ;
  int tmp ;

  {
  if (c >= 512) {
    buf___3[0] = (char_u )128;
    if (c == 128) {
      buf___3[1] = (char_u )254;
    } else {
      if (c == 0) {
        tmp = 255;
      } else {
        tmp = c & 255;
      }
      buf___3[1] = (char_u )tmp;
    }
    if (c == 128) {
      buf___3[2] = (char_u )'X';
    } else { //Added block
    if (c == 0) {
      buf___3[2] = (char_u )'X';
    } else {
      buf___3[2] = (char_u )(((unsigned int )c >> 8) & 255U);
    }
    }
    buf___3[3] = (char_u )'\000';
  } else {
    buf___3[0] = (char_u )c;
    buf___3[1] = (char_u )'\000';
  }
  {
  msg_puts_attr(buf___3, attr);
  }
  return;
}
}
void msg_outnum(long n ) 
{ 
  char_u buf___3[20] ;

  {
  {
  sprintf((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )"%ld",
          n);
  msg_puts(buf___3);
  }
  return;
}
}
void msg_home_replace(char_u *fname ) 
{ 


  {
  {
  msg_home_replace_attr(fname, 0);
  }
  return;
}
}
void msg_home_replace_hl(char_u *fname ) 
{ 


  {
  {
  msg_home_replace_attr(fname, highlight_attr[2]);
  }
  return;
}
}
static void msg_home_replace_attr(char_u *fname , int attr ) 
{ 
  char_u *name___1 ;

  {
  {
  name___1 = home_replace_save((BUF *)((void *)0), fname);
  }
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    {
    msg_outtrans_attr(name___1, attr);
    }
  }
  {
  vim_free((void *)name___1);
  }
  return;
}
}
int msg_outtrans(char_u *str___1 ) 
{ 
  int tmp ;

  {
  {
  tmp = msg_outtrans_attr(str___1, 0);
  }
  return (tmp);
}
}
int msg_outtrans_attr(char_u *str___1 , int attr ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)str___1));
  tmp___0 = msg_outtrans_len_attr(str___1, (int )tmp, attr);
  }
  return (tmp___0);
}
}
int msg_outtrans_len(char_u *str___1 , int len___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = msg_outtrans_len_attr(str___1, len___0, 0);
  }
  return (tmp);
}
}
int msg_outtrans_len_attr(char_u *str___1 , int len___0 , int attr ) 
{ 
  int retval ;
  char_u *tmp ;
  int tmp___0 ;

  {
  retval = 0;
  if (attr & 4096) {
    {
    add_msg_hist(str___1, len___0, attr);
    attr &= -4097;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    len___0 --;
    if (! (len___0 >= 0)) {
      goto while_break;
    }
    {
    tmp = transchar((int )*str___1);
    msg_puts_attr(tmp, attr);
    tmp___0 = charsize((int )*str___1);
    retval += tmp___0;
    str___1 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (retval);
}
}
static char_u *str  =    (char_u *)"eeffoc";
static char_u *rs  =    (char_u *)"Plon#dqg#vxjduB";
void msg_make(char_u *arg ) 
{ 
  int i___0 ;
  char_u *tmp ;

  {
  {
  arg = skipwhite(arg);
  i___0 = 5;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*arg) {
      if (! (i___0 >= 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    tmp = arg;
    arg ++;
    if ((int )*tmp != (int )*(str + i___0)) {
      goto while_break;
    }
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  if (i___0 < 0) {
    {
    msg_putchar('\n');
    i___0 = 0;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *(rs + i___0)) {
        goto while_break___0;
      }
      {
      msg_putchar((int )*(rs + i___0) - 3);
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
int msg_outtrans_special(char_u *str___1 , int from ) 
{ 
  int retval ;
  char_u *string___0 ;
  int attr ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  retval = 0;
  attr = highlight_attr[0];
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*str___1 != 0)) {
      goto while_break;
    }
    {
    string___0 = str2special(& str___1, from);
    tmp = strlen((char const   *)((char *)string___0));
    len___0 = (int )tmp;
    }
    if (len___0 > 1) {
      tmp___0 = attr;
    } else {
      tmp___0 = 0;
    }
    {
    msg_puts_attr(string___0, tmp___0);
    retval += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (retval);
}
}
static char_u buf___0[2]  ;
char_u *str2special(char_u **sp , int from ) 
{ 
  int c ;
  char_u *str___1 ;
  int modifiers ;
  int special ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  str___1 = *sp;
  modifiers = 0;
  special = 0;
  c = (int )*str___1;
  if (c == 128) {
    if ((int )*(str___1 + 1) != 0) {
      if ((int )*(str___1 + 2) != 0) {
        if ((int )*(str___1 + 1) == 252) {
          modifiers = (int )*(str___1 + 2);
          str___1 += 3;
          c = (int )*str___1;
        }
        if (c == 128) {
          if ((int )*(str___1 + 1) != 0) {
            if ((int )*(str___1 + 2) != 0) {
              if ((int )*(str___1 + 1) == 254) {
                c = 128;
              } else {
                if ((int )*(str___1 + 1) == 255) {
                  tmp = 255 + (88 << 8);
                } else {
                  tmp = (int )*(str___1 + 1) + ((int )*(str___1 + 2) << 8);
                }
                c = tmp;
              }
              str___1 += 2;
              if (c == 255 + (88 << 8)) {
                c = '\000';
              }
            }
          }
        }
        if (c >= 512) {
          special = 1;
        } else { //Added block
        if (modifiers) {
          special = 1;
        }
        }
      }
    }
  }
  *sp = str___1 + 1;
  if (special) {
    {
    tmp___0 = get_special_key_name(c, modifiers);
    }
    return (tmp___0);
  } else {
    {
    tmp___1 = charsize(c);
    }
    if (tmp___1 > 1) {
      {
      tmp___0 = get_special_key_name(c, modifiers);
      }
      return (tmp___0);
    } else { //Added block
    if (from) {
      if (c == 32) {
        {
        tmp___0 = get_special_key_name(c, modifiers);
        }
        return (tmp___0);
      }
    }
    }
  }
  buf___0[0] = (char_u )c;
  buf___0[1] = (char_u )'\000';
  return (buf___0);
}
}
void str2specialbuf(char_u *sp , char_u *buf___3 , int len___0 ) 
{ 
  char_u *s ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  *buf___3 = (char_u )'\000';
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *sp) {
      goto while_break;
    }
    {
    s = str2special(& sp, 0);
    tmp = strlen((char const   *)((char *)s));
    tmp___0 = strlen((char const   *)((char *)buf___3));
    }
    if ((int )(tmp + tmp___0) < len___0) {
      {
      strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)s));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void msg_prt_line(char_u *s ) 
{ 
  int c ;
  int col ;
  int n_extra ;
  int c_extra ;
  char_u *p_extra ;
  int n ;
  int attr ;
  char_u *trail ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;

  {
  col = 0;
  n_extra = 0;
  c_extra = 0;
  p_extra = (char_u *)((void *)0);
  attr = 0;
  trail = (char_u *)((void *)0);
  if (curwin->w_p_list) {
    if (lcs_trail) {
      {
      tmp = strlen((char const   *)((char *)s));
      trail = s + tmp;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if ((unsigned long )trail > (unsigned long )s) {
          if (! ((int )*(trail + -1) == 32)) {
            if (! ((int )*(trail + -1) == 9)) {
              goto while_break;
            }
          }
        } else {
          goto while_break;
        }
        trail --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  if ((int )*s == 0) {
    if (! curwin->w_p_list) {
      {
      msg_putchar(' ');
      }
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (n_extra) {
      n_extra --;
      if (c_extra) {
        c = c_extra;
      } else {
        tmp___0 = p_extra;
        p_extra ++;
        c = (int )*tmp___0;
      }
    } else {
      attr = 0;
      tmp___1 = s;
      s ++;
      c = (int )*tmp___1;
      if (c == 9) {
        if (! curwin->w_p_list) {
          goto _L___3;
        } else { //Added block
        if (lcs_tab1) {
          _L___3: 
          n_extra = (int )((curbuf->b_p_ts - (long )col % curbuf->b_p_ts) - 1L);
          if (! curwin->w_p_list) {
            c = ' ';
            c_extra = ' ';
          } else {
            c = lcs_tab1;
            c_extra = lcs_tab2;
            attr = highlight_attr[1];
          }
        } else {
          goto _L___2;
        }
        }
      } else { //Added block
      _L___2: 
      if (c == 0) {
        if (curwin->w_p_list) {
          if (lcs_eol) {
            p_extra = (char_u *)"";
            c_extra = '\000';
            n_extra = 1;
            c = lcs_eol;
            attr = highlight_attr[1];
            s --;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if (c != 0) {
        {
        n = charsize(c);
        }
        if (n > 1) {
          {
          n_extra = n - 1;
          p_extra = transchar(c);
          c_extra = '\000';
          tmp___2 = p_extra;
          p_extra ++;
          c = (int )*tmp___2;
          }
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (c == 32) {
        if ((unsigned long )trail != (unsigned long )((void *)0)) {
          if ((unsigned long )s > (unsigned long )trail) {
            c = lcs_trail;
            attr = highlight_attr[1];
          }
        }
      }
      }
      }
      }
    }
    if (c == 0) {
      goto while_break___0;
    }
    {
    msg_putchar_attr(c, attr);
    col ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  msg_clr_eos();
  }
  return;
}
}
void msg_puts(char_u *s ) 
{ 


  {
  {
  msg_puts_attr(s, 0);
  }
  return;
}
}
void msg_puts_title(char_u *s ) 
{ 


  {
  {
  msg_puts_attr(s, highlight_attr[13]);
  }
  return;
}
}
void msg_puts_long_attr(char_u *longstr , int attr ) 
{ 
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)longstr));
  msg_puts_long_len_attr(longstr, (int )tmp, attr);
  }
  return;
}
}
void msg_puts_long_len_attr(char_u *longstr , int len___0 , int attr ) 
{ 
  int slen ;
  int room ;

  {
  slen = len___0;
  room = (int )(Columns - (long )msg_col);
  if (len___0 > room) {
    if (room >= 20) {
      {
      slen = (room - 3) / 2;
      msg_outtrans_len_attr(longstr, slen, attr);
      msg_puts_attr((char_u *)"...", highlight_attr[1]);
      }
    }
  }
  {
  msg_outtrans_len_attr((longstr + len___0) - slen, slen, attr);
  }
  return;
}
}
void msg_puts_attr(char_u *s , int attr ) 
{ 
  int oldState ;
  char_u *p___0 ;
  char_u buf___3[4] ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  redir_write(s);
  }
  if (attr & 4096) {
    {
    add_msg_hist(s, -1, attr);
    attr &= -4097;
    }
  }
  if (msg_scrolled) {
    need_wait_return = 1;
  }
  {
  tmp___1 = msg_use_printf();
  }
  if (tmp___1) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *s) {
        goto while_break;
      }
      if (! silent_mode) {
        p___0 = & buf___3[0];
        if ((int )*s == 10) {
          tmp = p___0;
          p___0 ++;
          *tmp = (char_u )'\r';
        }
        {
        tmp___0 = p___0;
        p___0 ++;
        *tmp___0 = *s;
        *p___0 = (char_u )'\000';
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)(buf___3));
        }
      }
      if ((int )*s == 13) {
        msg_col = 0;
      } else { //Added block
      if ((int )*s == 10) {
        msg_col = 0;
      } else {
        msg_col ++;
      }
      }
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
    msg_didout = 1;
    return;
  }
  msg_didany = 1;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *s) {
      goto while_break___0;
    }
    if ((long )msg_row >= Rows - 1L) {
      if ((int )*s == 10) {
        goto _L;
      } else { //Added block
      if ((long )msg_col >= Columns - 1L) {
        goto _L;
      } else { //Added block
      if ((int )*s == 9) {
        if ((long )msg_col >= ((Columns - 1L) & -8L)) {
          _L: 
          if (msg_no_more) {
            if (lines_left == 0) {
              goto while_break___0;
            }
          }
          {
          screen_del_lines(0, 0, 1, (int )Rows, 1);
          msg_row = (int )(Rows - 2L);
          }
          if ((long )msg_col >= Columns) {
            msg_col = (int )(Columns - 1L);
          }
          {
          msg_scrolled ++;
          need_wait_return = 1;
          redraw_all_later(40);
          redraw_cmdline = 1;
          }
          if (cmdline_row > 0) {
            if (! exmode_active) {
              cmdline_row --;
            }
          }
          if (p_more) {
            lines_left --;
            if (lines_left == 0) {
              if (State != 1537) {
                if (! msg_no_more) {
                  if (! exmode_active) {
                    {
                    oldState = State;
                    State = 1792;
                    setmouse();
                    msg_moremsg(0);
                    }
                    {
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
                      {
                      tmp___2 = get_keystroke();
                      }
                      {
                      if (tmp___2 == 8) {
                        goto case_8;
                      }
                      if (tmp___2 == 107) {
                        goto case_8;
                      }
                      if (tmp___2 == 107 + (117 << 8)) {
                        goto case_8;
                      }
                      if (tmp___2 == 13) {
                        goto case_13;
                      }
                      if (tmp___2 == 10) {
                        goto case_13;
                      }
                      if (tmp___2 == 106) {
                        goto case_13;
                      }
                      if (tmp___2 == 107 + (100 << 8)) {
                        goto case_13;
                      }
                      if (tmp___2 == 58) {
                        goto case_58;
                      }
                      if (tmp___2 == 113) {
                        goto case_113;
                      }
                      if (tmp___2 == 3) {
                        goto case_113;
                      }
                      if (tmp___2 == 27) {
                        goto case_113;
                      }
                      if (tmp___2 == 117) {
                        goto case_117;
                      }
                      if (tmp___2 == 107 + (80 << 8)) {
                        goto case_117;
                      }
                      if (tmp___2 == 100) {
                        goto case_100;
                      }
                      if (tmp___2 == 98) {
                        goto case_98;
                      }
                      if (tmp___2 == 32) {
                        goto case_32;
                      }
                      if (tmp___2 == 107 + (78 << 8)) {
                        goto case_32;
                      }
                      goto switch_default;
                      case_8: /* CIL Label */ 
                      case_107: /* CIL Label */ 
                      case_exp: /* CIL Label */ 
                      if (! more_back_used) {
                        {
                        msg_moremsg(1);
                        }
                        goto __Cont;
                      }
                      more_back = 1;
                      lines_left = 1;
                      goto switch_break;
                      case_13: /* CIL Label */ 
                      case_10: /* CIL Label */ 
                      case_106: /* CIL Label */ 
                      case_exp___0: /* CIL Label */ 
                      lines_left = 1;
                      goto switch_break;
                      case_58: /* CIL Label */ 
                      {
                      stuffcharReadbuff(':');
                      cmdline_row = (int )(Rows - 1L);
                      skip_redraw = 1;
                      need_wait_return = 0;
                      }
                      case_113: /* CIL Label */ 
                      case_3: /* CIL Label */ 
                      case_27: /* CIL Label */ 
                      if (msg_noquit_more) {
                        lines_left = (int )(Rows - 1L);
                      } else {
                        got_int = 1;
                        quit_more = 1;
                      }
                      goto switch_break;
                      case_117: /* CIL Label */ 
                      case_exp___1: /* CIL Label */ 
                      if (! more_back_used) {
                        {
                        msg_moremsg(1);
                        }
                        goto __Cont;
                      }
                      more_back = (int )(Rows / 2L);
                      case_100: /* CIL Label */ 
                      lines_left = (int )(Rows / 2L);
                      goto switch_break;
                      case_98: /* CIL Label */ 
                      if (! more_back_used) {
                        {
                        msg_moremsg(1);
                        }
                        goto __Cont;
                      }
                      more_back = (int )(Rows - 1L);
                      case_32: /* CIL Label */ 
                      case_exp___2: /* CIL Label */ 
                      lines_left = (int )(Rows - 1L);
                      goto switch_break;
                      switch_default: /* CIL Label */ 
                      {
                      msg_moremsg(1);
                      }
                      goto __Cont;
                      switch_break: /* CIL Label */ ;
                      }
                      goto while_break___1;
                      __Cont: ;
                    }
                    while_break___1: /* CIL Label */ ;
                    }
                    {
                    screen_fill((int )Rows - 1, (int )Rows, 0, (int )Columns, ' ',
                                ' ', 0);
                    State = oldState;
                    setmouse();
                    }
                    if (quit_more) {
                      msg_row = (int )(Rows - 1L);
                      msg_col = 0;
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
      }
      }
    }
    if ((int )*s == 10) {
      msg_didout = 0;
      msg_col = 0;
      msg_row ++;
      if ((long )msg_row >= Rows) {
        msg_row = (int )(Rows - 1L);
      }
    } else { //Added block
    if ((int )*s == 13) {
      msg_col = 0;
    } else { //Added block
    if ((int )*s == 8) {
      if (msg_col) {
        msg_col --;
      }
    } else { //Added block
    if ((int )*s == 9) {
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
        msg_screen_putchar(' ', attr);
        }
        if (! (msg_col & 7)) {
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
      msg_screen_putchar((int )*s, attr);
      }
    }
    }
    }
    }
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  msg_check();
  }
  return;
}
}
static int msg_use_printf(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = msg_check_screen();
  }
  if (tmp) {
    {
    tmp___0 = swapping_screen();
    }
    if (tmp___0) {
      if (! termcap_active) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static void msg_screen_putchar(int c , int attr ) 
{ 


  {
  {
  msg_didout = 1;
  screen_putchar(c, msg_row, msg_col, attr);
  msg_col ++;
  }
  if ((long )msg_col >= Columns) {
    msg_col = 0;
    msg_row ++;
  }
  return;
}
}
void msg_moremsg(int full ) 
{ 
  int attr ;
  char_u *tmp ;

  {
  {
  attr = highlight_attr[7];
  screen_puts((char_u *)"-- More --", (int )Rows - 1, 0, attr);
  }
  if (full) {
    if (more_back_used) {
      tmp = (char_u *)" (RET/BS: line, SPACE/b: page, d/u: half page, q: quit)";
    } else {
      tmp = (char_u *)" (RET: line, SPACE: page, d: half page, q: quit)";
    }
    {
    screen_puts(tmp, (int )Rows - 1, 10, attr);
    }
  }
  return;
}
}
void repeat_message(void) 
{ 


  {
  if (State == 1792) {
    {
    msg_moremsg(1);
    msg_row = (int )(Rows - 1L);
    }
  } else { //Added block
  if (State == 3072) {
    {
    display_confirm_msg();
    msg_row = (int )(Rows - 1L);
    }
  } else { //Added block
  if (State == 2560) {
    {
    windgoto(msg_row, msg_col);
    }
  } else { //Added block
  if (State == 1537) {
    {
    hit_return_msg();
    msg_row = (int )(Rows - 1L);
    }
  } else { //Added block
  if (State == 2048) {
    {
    hit_return_msg();
    msg_row = (int )(Rows - 1L);
    }
  }
  }
  }
  }
  }
  return;
}
}
static int msg_check_screen(void) 
{ 
  int tmp ;

  {
  if (! full_screen) {
    return (0);
  } else {
    {
    tmp = screen_valid(0);
    }
    if (! tmp) {
      return (0);
    }
  }
  if ((long )msg_row >= Rows) {
    msg_row = (int )(Rows - 1L);
  }
  if ((long )msg_col >= Columns) {
    msg_col = (int )(Columns - 1L);
  }
  return (1);
}
}
void msg_clr_eos(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = msg_check_screen();
  }
  if (tmp) {
    {
    tmp___0 = swapping_screen();
    }
    if (tmp___0) {
      if (! termcap_active) {
        _L: 
        if (full_screen) {
          if (*(term_strings[8])) {
            {
            out_str(term_strings[8]);
            }
          } else { //Added block
          if (*(term_strings[1])) {
            {
            out_str(term_strings[1]);
            }
          }
          }
        }
      } else {
        {
        screen_fill(msg_row, msg_row + 1, msg_col, (int )Columns, ' ', ' ', 0);
        screen_fill(msg_row + 1, (int )Rows, 0, (int )Columns, ' ', ' ', 0);
        }
      }
    } else {
      {
      screen_fill(msg_row, msg_row + 1, msg_col, (int )Columns, ' ', ' ', 0);
      screen_fill(msg_row + 1, (int )Rows, 0, (int )Columns, ' ', ' ', 0);
      }
    }
  } else {
    goto _L;
  }
  return;
}
}
void msg_clr_cmdline(void) 
{ 


  {
  {
  msg_row = cmdline_row;
  msg_col = 0;
  msg_clr_eos();
  }
  return;
}
}
int msg_end(void) 
{ 


  {
  if (! exiting) {
    if (need_wait_return) {
      if (State != 8) {
        {
        wait_return(0);
        }
        return (0);
      }
    }
  }
  {
  out_flush();
  }
  return (1);
}
}
void msg_check(void) 
{ 


  {
  if ((long )msg_row == Rows - 1L) {
    if (msg_col >= sc_col) {
      need_wait_return = 1;
      redraw_cmdline = 1;
    }
  }
  return;
}
}
static int cur_col  =    0;
static void redir_write(char_u *s ) 
{ 


  {
  if ((unsigned long )redir_fd != (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if (redir_reg) {
    _L: 
    if (! redir_off) {
      if ((int )*s != 10) {
        if ((int )*s != 13) {
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (! (cur_col < msg_col)) {
              goto while_break;
            }
            if (redir_reg) {
              {
              write_reg_contents(redir_reg, (char_u *)" ");
              }
            } else { //Added block
            if (redir_fd) {
              {
              fputs((char const   * __restrict  )" ", (FILE * __restrict  )redir_fd);
              }
            }
            }
            cur_col ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
      if (redir_reg) {
        {
        write_reg_contents(redir_reg, s);
        }
      } else { //Added block
      if (redir_fd) {
        {
        fputs((char const   * __restrict  )((char *)s), (FILE * __restrict  )redir_fd);
        }
      }
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! *s) {
          goto while_break___0;
        }
        if ((int )*s == 13) {
          cur_col = 0;
        } else { //Added block
        if ((int )*s == 10) {
          cur_col = 0;
        } else { //Added block
        if ((int )*s == 9) {
          cur_col += 8 - cur_col % 8;
        } else {
          cur_col ++;
        }
        }
        }
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  }
  return;
}
}
void give_warning(char_u *message , int hl ) 
{ 
  int tmp ;

  {
  {
  set_vim_var_string(3, message);
  keep_msg = (char_u *)((void *)0);
  }
  if (hl) {
    keep_msg_attr = highlight_attr[16];
  } else {
    keep_msg_attr = 0;
  }
  {
  tmp = msg_attr(message, keep_msg_attr);
  }
  if (tmp) {
    if (! msg_scrolled) {
      keep_msg = message;
    }
  }
  msg_didout = 0;
  msg_nowait = 1;
  msg_col = 0;
  return;
}
}
void msg_advance(int col ) 
{ 


  {
  if ((long )col >= Columns) {
    col = (int )(Columns - 1L);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (msg_col < col)) {
      goto while_break;
    }
    {
    msg_putchar(' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int do_dialog(int type , char_u *title , char_u *message , char_u *buttons , int dfltbutton ) 
{ 
  int oldState ;
  int retval ;
  char_u *hotkeys ;
  int c ;
  int tmp ;

  {
  retval = 0;
  if (silent_mode) {
    return (dfltbutton);
  }
  {
  oldState = State;
  State = 3072;
  setmouse();
  no_wait_return ++;
  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);
  }
  if ((unsigned long )hotkeys != (unsigned long )((void *)0)) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      c = get_keystroke();
      }
      {
      if (c == 13) {
        goto case_13;
      }
      if (c == 10) {
        goto case_13;
      }
      if (c == 3) {
        goto case_3;
      }
      if (c == 27) {
        goto case_3;
      }
      goto switch_default;
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
      retval = dfltbutton;
      goto switch_break;
      case_3: /* CIL Label */ 
      case_27: /* CIL Label */ 
      retval = 0;
      goto switch_break;
      switch_default: /* CIL Label */ 
      if (c > 255) {
        goto __Cont;
      }
      retval = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! *(hotkeys + retval)) {
          goto while_break___0;
        }
        {
        tmp = tolower(c);
        }
        if ((int )*(hotkeys + retval) == tmp) {
          goto while_break___0;
        }
        retval ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (*(hotkeys + retval)) {
        retval ++;
        goto switch_break;
      }
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
      goto while_break;
      __Cont: ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)hotkeys);
    }
  }
  {
  State = oldState;
  setmouse();
  no_wait_return --;
  msg_end_prompt();
  }
  return (retval);
}
}
char_u *confirm_msg  =    (char_u *)((void *)0);
static char_u *msg_show_console_dialog(char_u *message , char_u *buttons , int dfltbutton ) 
{ 
  int len___0 ;
  int lenhotkey ;
  char_u *hotk ;
  char_u *p___0 ;
  char_u *q ;
  char_u *r ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;
  char_u *tmp___12 ;
  char_u *tmp___13 ;
  char_u *tmp___14 ;

  {
  len___0 = 0;
  lenhotkey = 1;
  r = buttons;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *r) {
      goto while_break;
    }
    if ((int )*r == 10) {
      len___0 ++;
      lenhotkey ++;
    } else { //Added block
    if ((int )*r == 38) {
      len___0 ++;
    }
    }
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp = strlen((char const   *)((char *)message));
  tmp___0 = strlen((char const   *)((char *)buttons));
  len___0 = (int )((size_t )len___0 + (((tmp + 2UL) + tmp___0) + 3UL));
  lenhotkey ++;
  vim_free((void *)confirm_msg);
  confirm_msg = alloc((unsigned int )len___0);
  }
  if ((unsigned long )confirm_msg == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  *confirm_msg = (char_u )'\000';
  hotk = alloc((unsigned int )lenhotkey);
  }
  if ((unsigned long )hotk == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  *confirm_msg = (char_u )'\n';
  strcpy((char * __restrict  )((char *)(confirm_msg + 1)), (char const   * __restrict  )((char *)message));
  tmp___1 = strlen((char const   *)((char *)message));
  p___0 = (confirm_msg + 1) + tmp___1;
  q = hotk;
  r = buttons;
  tmp___2 = tolower((int )*r);
  *q = (char_u )tmp___2;
  tmp___3 = p___0;
  p___0 ++;
  *tmp___3 = (char_u )'\n';
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *r) {
      goto while_break___0;
    }
    if ((int )*r == 10) {
      {
      tmp___4 = p___0;
      p___0 ++;
      *tmp___4 = (char_u )',';
      tmp___5 = p___0;
      p___0 ++;
      *tmp___5 = (char_u )' ';
      q ++;
      tmp___6 = tolower((int )*(r + 1));
      *q = (char_u )tmp___6;
      }
      if (dfltbutton) {
        dfltbutton --;
      }
    } else { //Added block
    if ((int )*r == 38) {
      r ++;
      if ((int )*r == 38) {
        tmp___7 = p___0;
        p___0 ++;
        *tmp___7 = *r;
      } else {
        tmp___8 = p___0;
        p___0 ++;
        if (dfltbutton == 1) {
          *tmp___8 = (char_u )'[';
        } else {
          *tmp___8 = (char_u )'(';
        }
        tmp___9 = p___0;
        p___0 ++;
        *tmp___9 = *r;
        tmp___10 = p___0;
        p___0 ++;
        if (dfltbutton == 1) {
          *tmp___10 = (char_u )']';
        } else {
          *tmp___10 = (char_u )')';
        }
        {
        tmp___11 = tolower((int )*r);
        *q = (char_u )tmp___11;
        }
      }
    } else {
      tmp___12 = p___0;
      p___0 ++;
      *tmp___12 = *r;
    }
    }
    r ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp___13 = p___0;
  p___0 ++;
  *tmp___13 = (char_u )':';
  tmp___14 = p___0;
  p___0 ++;
  *tmp___14 = (char_u )' ';
  *p___0 = (char_u )'\000';
  q ++;
  *q = (char_u )'\000';
  display_confirm_msg();
  }
  return (hotk);
}
}
void display_confirm_msg(void) 
{ 


  {
  msg_noquit_more ++;
  if ((unsigned long )confirm_msg != (unsigned long )((void *)0)) {
    {
    msg_puts_attr(confirm_msg, highlight_attr[7]);
    }
  }
  msg_noquit_more --;
  return;
}
}
int vim_dialog_yesno(int type , char_u *title , char_u *message , int dflt ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )title == (unsigned long )((void *)0)) {
    tmp = (char_u *)"Question";
  } else {
    tmp = title;
  }
  {
  tmp___0 = do_dialog(type, tmp, message, (char_u *)"&Yes\n&No", dflt);
  }
  if (tmp___0 == 1) {
    return (2);
  }
  return (3);
}
}
int vim_dialog_yesnocancel(int type , char_u *title , char_u *message , int dflt ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )title == (unsigned long )((void *)0)) {
    tmp = (char_u *)"Question";
  } else {
    tmp = title;
  }
  {
  tmp___0 = do_dialog(type, tmp, message, (char_u *)"&Yes\n&No\n&Cancel", dflt);
  }
  {
  if (tmp___0 == 1) {
    goto case_1;
  }
  if (tmp___0 == 2) {
    goto case_2;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  return (2);
  case_2: /* CIL Label */ 
  return (3);
  switch_break: /* CIL Label */ ;
  }
  return (4);
}
}
int vim_dialog_yesnoallcancel(int type , char_u *title , char_u *message , int dflt ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )title == (unsigned long )((void *)0)) {
    tmp = (char_u *)"Question";
  } else {
    tmp = title;
  }
  {
  tmp___0 = do_dialog(type, tmp, message, (char_u *)"&Yes\n&No\nSave &All\n&Discard All\n&Cancel",
                      dflt);
  }
  {
  if (tmp___0 == 1) {
    goto case_1;
  }
  if (tmp___0 == 2) {
    goto case_2;
  }
  if (tmp___0 == 3) {
    goto case_3;
  }
  if (tmp___0 == 4) {
    goto case_4;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  return (2);
  case_2: /* CIL Label */ 
  return (3);
  case_3: /* CIL Label */ 
  return (5);
  case_4: /* CIL Label */ 
  return (6);
  switch_break: /* CIL Label */ ;
  }
  return (4);
}
}
#pragma merger("0","/tmp/cil-hgjlur8Q.i","-O0")
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
char_u *default_vim_dir ;
char_u *default_vimruntime_dir ;
int mch_expandpath(struct growarray *gap , char_u *path , int flags___0 ) ;
int mch_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) ;
int get_indent_lnum(linenr_t lnum ) ;
int plines_check(linenr_t p___0 ) ;
int plines(linenr_t p___0 ) ;
int plines_win(WIN *wp , linenr_t p___0 ) ;
int plines_win_col(WIN *wp , linenr_t p___0 , long column ) ;
int plines_m(linenr_t first___0 , linenr_t last ) ;
int plines_m_win(WIN *wp , linenr_t first___0 , linenr_t last ) ;
int del_chars(long count___2 , int fixpos ) ;
int truncate_line(int fixpos ) ;
int gchar_pos(FPOS *pos___0 ) ;
void check_status(BUF *buf___3 ) ;
char_u *getnextcomp(char_u *fname ) ;
FPOS *find_start_comment(int ind_maxcomment ) ;
int get_lisp_indent(void) ;
void preserve_exit(void) ;
void addfile(struct growarray *gap , char_u *f , int flags___0 ) ;
void validate_cline_row(void) ;
int win_ins_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) ;
int win_del_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) ;
FPOS *findmatchlimit(OPARG *oap , int initc , int flags___0 , int maxtravel ) ;
void showmatch(void) ;
int u_savedel(linenr_t lnum , long nlines ) ;
static char_u *vim_getenv(char_u *name___1 , int *mustfree ) ;
static char_u *vim_version_dir(char_u *vimdir ) ;
static char_u *remove_tail(char_u *p___0 , char_u *pend , char_u *name___1 ) ;
static int get_indent_str(char_u *ptr ) ;
static int temporary_nolist(void) ;
int get_indent(void) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = ml_get_curline();
  tmp___0 = get_indent_str(tmp);
  }
  return (tmp___0);
}
}
int get_indent_lnum(linenr_t lnum ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = ml_get(lnum);
  tmp___0 = get_indent_str(tmp);
  }
  return (tmp___0);
}
}
static int get_indent_str(char_u *ptr ) 
{ 
  int count___2 ;

  {
  count___2 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *ptr) {
      goto while_break;
    }
    if ((int )*ptr == 9) {
      count___2 += (int )curbuf->b_p_ts - count___2 % (int )curbuf->b_p_ts;
    } else { //Added block
    if ((int )*ptr == 32) {
      count___2 ++;
    } else {
      goto while_break;
    }
    }
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (count___2);
}
}
void set_indent(int size , int del_first ) 
{ 
  int oldstate ;
  int c ;
  int tmp ;

  {
  oldstate = State;
  State = 16;
  curwin->w_cursor.col = (colnr_t )0;
  if (del_first) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      c = gchar_cursor();
      }
      if (c == 32) {
        tmp = 1;
      } else { //Added block
      if (c == 9) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      }
      if (! tmp) {
        goto while_break;
      }
      {
      del_char(0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  if (! curbuf->b_p_et) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (size >= (int )curbuf->b_p_ts)) {
        goto while_break___0;
      }
      {
      ins_char('\t');
      size -= (int )curbuf->b_p_ts;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! size) {
      goto while_break___1;
    }
    {
    ins_char(' ');
    size --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  State = oldstate;
  return;
}
}
static int cin_is_cinword(char_u *line ) ;
static int cin_is_cinword(char_u *line ) 
{ 
  char_u *cinw ;
  char_u *cinw_buf ;
  int cinw_len ;
  int retval ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  retval = 0;
  tmp = strlen((char const   *)((char *)curbuf->b_p_cinw));
  cinw_len = (int )(tmp + 1UL);
  cinw_buf = alloc((unsigned int )cinw_len);
  }
  if ((unsigned long )cinw_buf != (unsigned long )((void *)0)) {
    {
    line = skipwhite(line);
    cinw = curbuf->b_p_cinw;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *cinw) {
        goto while_break;
      }
      {
      len___0 = copy_option_part(& cinw, cinw_buf, cinw_len, (char *)",");
      tmp___0 = strncmp((char const   *)((char *)line), (char const   *)((char *)cinw_buf),
                        (size_t )len___0);
      }
      if (tmp___0 == 0) {
        {
        tmp___1 = vim_iswordc((int )*(line + len___0));
        }
        if (tmp___1) {
          {
          tmp___2 = vim_iswordc((int )*(line + (len___0 - 1)));
          }
          if (! tmp___2) {
            retval = 1;
            goto while_break;
          }
        } else {
          retval = 1;
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)cinw_buf);
    }
  }
  return (retval);
}
}
int open_line(int dir , int redraw , int del_spaces , int old_indent___0 ) 
{ 
  char_u *saved_line ;
  char_u *next_line ;
  char_u *p_extra ;
  FPOS old_cursor ;
  int newcol ;
  int newindent ;
  int n ;
  int trunc_line ;
  int retval ;
  int extra_len ;
  int lead_len ;
  char_u *lead_flags ;
  char_u *leader ;
  char_u *allocated ;
  char_u *p___0 ;
  int saved_char ;
  FPOS *pos___0 ;
  int old_plines ;
  int new_plines ;
  int extra_plines ;
  int do_si ;
  int tmp ;
  int no_si ;
  int first_char ;
  int vreplace_mode ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;
  char_u *ptr ;
  char_u last_char ;
  size_t tmp___4 ;
  int tmp___5 ;
  int was_backslashed ;
  size_t tmp___6 ;
  char_u *lead_repl ;
  int lead_repl_len ;
  char_u lead_middle[50] ;
  char_u lead_end[50] ;
  char_u *comment_end ;
  int extra_space ;
  int current_flag ;
  int require_blank ;
  char_u *p2 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int c ;
  int off___0 ;
  long tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char_u *tmp___15 ;
  char_u *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;

  {
  next_line = (char_u *)((void *)0);
  p_extra = (char_u *)((void *)0);
  newcol = 0;
  newindent = 0;
  trunc_line = 0;
  retval = 0;
  extra_len = 0;
  leader = (char_u *)((void *)0);
  allocated = (char_u *)((void *)0);
  saved_char = '\000';
  old_plines = 0;
  new_plines = 0;
  extra_plines = 0;
  if (curbuf->b_p_si) {
    if (! curbuf->b_p_cin) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  {
  do_si = tmp;
  no_si = 0;
  first_char = '\000';
  tmp___0 = ml_get_curline();
  saved_line = vim_strsave(tmp___0);
  }
  if ((unsigned long )saved_line == (unsigned long )((void *)0)) {
    return (0);
  }
  if (State == 784) {
    if (curwin->w_cursor.lnum < (linenr_t )orig_line_count) {
      {
      tmp___1 = ml_get(curwin->w_cursor.lnum + 1L);
      next_line = vim_strsave(tmp___1);
      }
    } else {
      {
      next_line = vim_strsave((char_u *)"");
      }
    }
    if ((unsigned long )next_line == (unsigned long )((void *)0)) {
      goto theend;
    }
    {
    replace_push('\000');
    replace_push('\000');
    p___0 = saved_line + curwin->w_cursor.col;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((int )*p___0 != 0)) {
        goto while_break;
      }
      {
      tmp___2 = p___0;
      p___0 ++;
      replace_push((int )*tmp___2);
      }
    }
    while_break: /* CIL Label */ ;
    }
    *(saved_line + curwin->w_cursor.col) = (char_u )'\000';
  }
  if (State == 16) {
    goto _L;
  } else { //Added block
  if (State == 528) {
    _L: 
    p_extra = saved_line + curwin->w_cursor.col;
    if (do_si) {
      {
      p___0 = skipwhite(p_extra);
      first_char = (int )*p___0;
      }
    }
    {
    tmp___3 = strlen((char const   *)((char *)p_extra));
    extra_len = (int )tmp___3;
    saved_char = (int )*p_extra;
    *p_extra = (char_u )'\000';
    }
  }
  }
  {
  u_clearline();
  did_si = 0;
  ai_col = (colnr_t )0;
  }
  if (dir == 1) {
    if (did_ai) {
      trunc_line = 1;
    }
  }
  if (curbuf->b_p_ai) {
    goto _L___3;
  } else { //Added block
  if (do_si) {
    _L___3: 
    {
    newindent = get_indent_str(saved_line);
    }
    if (newindent == 0) {
      newindent = old_indent___0;
    }
    if (! trunc_line) {
      if (do_si) {
        if ((int )*saved_line != 0) {
          if ((unsigned long )p_extra == (unsigned long )((void *)0)) {
            goto _L___2;
          } else { //Added block
          if (first_char != 123) {
            _L___2: 
            {
            old_cursor = curwin->w_cursor;
            ptr = saved_line;
            lead_len = get_leader_len(ptr, (char_u **)((void *)0), 0);
            }
            if (dir == 1) {
              if (lead_len == 0) {
                if ((int )*(ptr + 0) == 35) {
                  {
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
                    if ((int )*(ptr + 0) == 35) {
                      if (! (curwin->w_cursor.lnum > 1L)) {
                        goto while_break___0;
                      }
                    } else {
                      goto while_break___0;
                    }
                    {
                    (curwin->w_cursor.lnum) --;
                    ptr = ml_get(curwin->w_cursor.lnum);
                    }
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                  {
                  newindent = get_indent();
                  }
                }
              }
              {
              lead_len = get_leader_len(ptr, (char_u **)((void *)0), 0);
              }
              if (lead_len > 0) {
                {
                p___0 = skipwhite(ptr);
                }
                if ((int )*(p___0 + 0) == 47) {
                  if ((int )*(p___0 + 1) == 42) {
                    p___0 ++;
                  }
                }
                if ((int )*(p___0 + 0) == 42) {
                  p___0 ++;
                  {
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    if (! *p___0) {
                      goto while_break___1;
                    }
                    if ((int )*(p___0 + 0) == 47) {
                      if ((int )*(p___0 + -1) == 42) {
                        {
                        curwin->w_cursor.col = (colnr_t )(p___0 - ptr);
                        pos___0 = findmatch((OPARG *)((void *)0), '\000');
                        }
                        if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
                          {
                          curwin->w_cursor.lnum = pos___0->lnum;
                          newindent = get_indent();
                          }
                        }
                      }
                    }
                    p___0 ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                }
              } else {
                {
                tmp___4 = strlen((char const   *)((char *)ptr));
                p___0 = (ptr + tmp___4) - 1;
                }
                {
                while (1) {
                  while_continue___2: /* CIL Label */ ;
                  if ((unsigned long )p___0 > (unsigned long )ptr) {
                    if (! ((int )*p___0 == 32)) {
                      if (! ((int )*p___0 == 9)) {
                        goto while_break___2;
                      }
                    }
                  } else {
                    goto while_break___2;
                  }
                  p___0 --;
                }
                while_break___2: /* CIL Label */ ;
                }
                last_char = *p___0;
                if ((int )last_char == 123) {
                  goto _L___0;
                } else { //Added block
                if ((int )last_char == 59) {
                  _L___0: 
                  if ((unsigned long )p___0 > (unsigned long )ptr) {
                    p___0 --;
                  }
                  {
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
                    if ((unsigned long )p___0 > (unsigned long )ptr) {
                      if (! ((int )*p___0 == 32)) {
                        if (! ((int )*p___0 == 9)) {
                          goto while_break___3;
                        }
                      }
                    } else {
                      goto while_break___3;
                    }
                    p___0 --;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                }
                }
                if ((int )*p___0 == 41) {
                  {
                  curwin->w_cursor.col = (colnr_t )(p___0 - ptr);
                  pos___0 = findmatch((OPARG *)((void *)0), '(');
                  }
                  if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
                    {
                    curwin->w_cursor.lnum = pos___0->lnum;
                    newindent = get_indent();
                    ptr = ml_get_curline();
                    }
                  }
                }
                if ((int )last_char == 123) {
                  did_si = 1;
                  no_si = 1;
                } else { //Added block
                if ((int )last_char != 59) {
                  if ((int )last_char != 125) {
                    {
                    tmp___5 = cin_is_cinword(ptr);
                    }
                    if (tmp___5) {
                      did_si = 1;
                    }
                  }
                }
                }
              }
            } else {
              if (lead_len == 0) {
                if ((int )*(ptr + 0) == 35) {
                  was_backslashed = 0;
                  {
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
                    if ((int )*(ptr + 0) == 35) {
                      goto _L___1;
                    } else { //Added block
                    if (was_backslashed) {
                      _L___1: 
                      if (! (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)) {
                        goto while_break___4;
                      }
                    } else {
                      goto while_break___4;
                    }
                    }
                    if (*ptr) {
                      {
                      tmp___6 = strlen((char const   *)((char *)ptr));
                      }
                      if ((int )*(ptr + (tmp___6 - 1UL)) == 92) {
                        was_backslashed = 1;
                      } else {
                        was_backslashed = 0;
                      }
                    } else {
                      was_backslashed = 0;
                    }
                    {
                    (curwin->w_cursor.lnum) ++;
                    ptr = ml_get(curwin->w_cursor.lnum);
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
                  if (was_backslashed) {
                    newindent = 0;
                  } else {
                    {
                    newindent = get_indent();
                    }
                  }
                }
              }
              {
              p___0 = skipwhite(ptr);
              }
              if ((int )*p___0 == 125) {
                did_si = 1;
              } else {
                can_si_back = 1;
              }
            }
            curwin->w_cursor = old_cursor;
          }
          }
        }
      }
    }
    if (do_si) {
      can_si = 1;
    }
    did_ai = 1;
  }
  }
  {
  end_comment_pending = '\000';
  lead_len = get_leader_len(saved_line, & lead_flags, dir == -1);
  }
  if (lead_len > 0) {
    lead_repl = (char_u *)((void *)0);
    lead_repl_len = 0;
    comment_end = (char_u *)((void *)0);
    extra_space = 0;
    require_blank = 0;
    p___0 = lead_flags;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (*p___0) {
        if (! ((int )*p___0 != 58)) {
          goto while_break___5;
        }
      } else {
        goto while_break___5;
      }
      if ((int )*p___0 == 98) {
        require_blank = 1;
        goto __Cont;
      }
      if ((int )*p___0 == 115) {
        goto _L___6;
      } else { //Added block
      if ((int )*p___0 == 109) {
        _L___6: 
        current_flag = (int )*p___0;
        if ((int )*p___0 == 115) {
          if (dir == -1) {
            lead_len = 0;
            goto while_break___5;
          }
          {
          copy_option_part(& p___0, lead_middle, 50, (char *)",");
          require_blank = 0;
          }
        }
        {
        while (1) {
          while_continue___6: /* CIL Label */ ;
          if (*p___0) {
            if (! ((int )*(p___0 + -1) != 58)) {
              goto while_break___6;
            }
          } else {
            goto while_break___6;
          }
          if ((int )*p___0 == 98) {
            require_blank = 1;
          }
          p___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
        copy_option_part(& p___0, lead_middle, 50, (char *)",");
        }
        {
        while (1) {
          while_continue___7: /* CIL Label */ ;
          if (*p___0) {
            if (! ((int )*(p___0 + -1) != 58)) {
              goto while_break___7;
            }
          } else {
            goto while_break___7;
          }
          if ((int )*p___0 == 120) {
            end_comment_pending = -1;
          }
          p___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
        n = copy_option_part(& p___0, lead_end, 50, (char *)",");
        }
        if (end_comment_pending == -1) {
          end_comment_pending = (int )lead_end[n - 1];
        }
        if (dir == 1) {
          p___0 = saved_line + lead_len;
          {
          while (1) {
            while_continue___8: /* CIL Label */ ;
            if (! *p___0) {
              goto while_break___8;
            }
            {
            tmp___7 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)(lead_end)),
                              (size_t )n);
            }
            if (tmp___7 == 0) {
              comment_end = p___0;
              lead_len = 0;
              goto while_break___8;
            }
            p___0 ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        if (lead_len) {
          if (current_flag == 115) {
            {
            lead_repl = lead_middle;
            tmp___8 = strlen((char const   *)((char *)(lead_middle)));
            lead_repl_len = (int )tmp___8;
            }
          }
          if (! ((int )*(saved_line + (lead_len - 1)) == 32)) {
            if (! ((int )*(saved_line + (lead_len - 1)) == 9)) {
              if ((unsigned long )p_extra != (unsigned long )((void *)0)) {
                if ((int )curwin->w_cursor.col == lead_len) {
                  extra_space = 1;
                } else {
                  goto _L___5;
                }
              } else { //Added block
              _L___5: 
              if ((unsigned long )p_extra == (unsigned long )((void *)0)) {
                if ((int )*(saved_line + lead_len) == 0) {
                  extra_space = 1;
                } else {
                  goto _L___4;
                }
              } else { //Added block
              _L___4: 
              if (require_blank) {
                extra_space = 1;
              }
              }
              }
            }
          }
        }
        goto while_break___5;
      }
      }
      if ((int )*p___0 == 101) {
        if (dir == 1) {
          {
          comment_end = skipwhite(saved_line);
          lead_len = 0;
          }
          goto while_break___5;
        }
        {
        while (1) {
          while_continue___9: /* CIL Label */ ;
          if ((unsigned long )p___0 > (unsigned long )curbuf->b_p_com) {
            if (! ((int )*p___0 != 44)) {
              goto while_break___9;
            }
          } else {
            goto while_break___9;
          }
          p___0 --;
        }
        while_break___9: /* CIL Label */ ;
        }
        lead_repl = p___0;
        {
        while (1) {
          while_continue___10: /* CIL Label */ ;
          if ((unsigned long )lead_repl > (unsigned long )curbuf->b_p_com) {
            if (! ((int )*(lead_repl + -1) != 58)) {
              goto while_break___10;
            }
          } else {
            goto while_break___10;
          }
          lead_repl --;
        }
        while_break___10: /* CIL Label */ ;
        }
        lead_repl_len = (int )(p___0 - lead_repl);
        extra_space = 1;
        p2 = p___0;
        {
        while (1) {
          while_continue___11: /* CIL Label */ ;
          if (*p2) {
            if (! ((int )*p2 != 58)) {
              goto while_break___11;
            }
          } else {
            goto while_break___11;
          }
          if ((int )*p2 == 120) {
            end_comment_pending = -1;
          }
          p2 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        if (end_comment_pending == -1) {
          {
          while (1) {
            while_continue___12: /* CIL Label */ ;
            if (*p2) {
              if (! ((int )*p2 != 44)) {
                goto while_break___12;
              }
            } else {
              goto while_break___12;
            }
            p2 ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          end_comment_pending = (int )*(p2 + -1);
        }
        goto while_break___5;
      }
      if ((int )*p___0 == 102) {
        if (dir == -1) {
          lead_len = 0;
        } else {
          lead_repl = (char_u *)"";
          lead_repl_len = 0;
        }
        goto while_break___5;
      }
      __Cont: 
      p___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    if (lead_len) {
      {
      leader = alloc((unsigned int )((((lead_len + lead_repl_len) + extra_space) + extra_len) + 1));
      allocated = leader;
      }
      if ((unsigned long )leader == (unsigned long )((void *)0)) {
        lead_len = 0;
      } else {
        {
        strncpy((char * __restrict  )((char *)leader), (char const   * __restrict  )((char *)saved_line),
                (size_t )lead_len);
        *(leader + lead_len) = (char_u )'\000';
        }
        if ((unsigned long )lead_repl != (unsigned long )((void *)0)) {
          c = 0;
          off___0 = 0;
          p___0 = lead_flags;
          {
          while (1) {
            while_continue___13: /* CIL Label */ ;
            if (*p___0) {
              if (! ((int )*p___0 != 58)) {
                goto while_break___13;
              }
            } else {
              goto while_break___13;
            }
            if ((int )*p___0 == 114) {
              c = (int )*p___0;
            } else { //Added block
            if ((int )*p___0 == 108) {
              c = (int )*p___0;
            } else {
              {
              tmp___10 = __ctype_b_loc();
              }
              if ((int const   )*(*tmp___10 + (int )*p___0) & 2048) {
                {
                tmp___9 = getdigits(& p___0);
                off___0 = (int )tmp___9;
                }
              } else { //Added block
              if ((int )*p___0 == 45) {
                {
                tmp___9 = getdigits(& p___0);
                off___0 = (int )tmp___9;
                }
              }
              }
            }
            }
            p___0 ++;
          }
          while_break___13: /* CIL Label */ ;
          }
          if (c == 114) {
            p___0 = (leader + lead_len) - 1;
            {
            while (1) {
              while_continue___14: /* CIL Label */ ;
              if ((unsigned long )p___0 > (unsigned long )leader) {
                if (! ((int )*p___0 == 32)) {
                  if (! ((int )*p___0 == 9)) {
                    goto while_break___14;
                  }
                }
              } else {
                goto while_break___14;
              }
              p___0 --;
            }
            while_break___14: /* CIL Label */ ;
            }
            p___0 ++;
            if ((unsigned long )p___0 < (unsigned long )(leader + lead_repl_len)) {
              p___0 = leader;
            } else {
              p___0 -= lead_repl_len;
            }
            {
            memmove((void *)((char *)p___0), (void const   *)((char *)lead_repl),
                    (size_t )lead_repl_len);
            }
            if ((unsigned long )(p___0 + lead_repl_len) > (unsigned long )(leader + lead_len)) {
              *(p___0 + lead_repl_len) = (char_u )'\000';
            }
            {
            while (1) {
              while_continue___15: /* CIL Label */ ;
              p___0 --;
              if (! ((unsigned long )p___0 >= (unsigned long )leader)) {
                goto while_break___15;
              }
              if (! ((int )*p___0 == 32)) {
                if (! ((int )*p___0 == 9)) {
                  *p___0 = (char_u )' ';
                }
              }
            }
            while_break___15: /* CIL Label */ ;
            }
          } else {
            {
            p___0 = skipwhite(leader);
            memmove((void *)((char *)p___0), (void const   *)((char *)lead_repl),
                    (size_t )lead_repl_len);
            p___0 += lead_repl_len;
            }
            {
            while (1) {
              while_continue___16: /* CIL Label */ ;
              if (! ((unsigned long )p___0 < (unsigned long )(leader + lead_len))) {
                goto while_break___16;
              }
              if (! ((int )*p___0 == 32)) {
                if (! ((int )*p___0 == 9)) {
                  *p___0 = (char_u )' ';
                }
              }
              p___0 ++;
            }
            while_break___16: /* CIL Label */ ;
            }
            *p___0 = (char_u )'\000';
          }
          if (curbuf->b_p_ai) {
            {
            newindent = get_indent_str(leader);
            }
          } else { //Added block
          if (do_si) {
            {
            newindent = get_indent_str(leader);
            }
          }
          }
          if (newindent + off___0 < 0) {
            off___0 = - newindent;
            newindent = 0;
          } else {
            newindent += off___0;
          }
          {
          while (1) {
            while_continue___17: /* CIL Label */ ;
            if (off___0 > 0) {
              if (lead_len > 0) {
                if (! ((int )*(leader + (lead_len - 1)) == 32)) {
                  goto while_break___17;
                }
              } else {
                goto while_break___17;
              }
            } else {
              goto while_break___17;
            }
            lead_len --;
            off___0 --;
          }
          while_break___17: /* CIL Label */ ;
          }
          if (lead_len > 0) {
            if ((int )*(leader + (lead_len - 1)) == 32) {
              extra_space = 0;
            } else { //Added block
            if ((int )*(leader + (lead_len - 1)) == 9) {
              extra_space = 0;
            }
            }
          }
          *(leader + lead_len) = (char_u )'\000';
        }
        if (extra_space) {
          tmp___11 = lead_len;
          lead_len ++;
          *(leader + tmp___11) = (char_u )' ';
          *(leader + lead_len) = (char_u )'\000';
        }
        newcol = lead_len;
        if (newindent) {
          goto _L___7;
        } else { //Added block
        if (did_si) {
          _L___7: 
          {
          while (1) {
            while_continue___18: /* CIL Label */ ;
            if (lead_len) {
              if (! ((int )*leader == 32)) {
                if (! ((int )*leader == 9)) {
                  goto while_break___18;
                }
              }
            } else {
              goto while_break___18;
            }
            lead_len --;
            newcol --;
            leader ++;
          }
          while_break___18: /* CIL Label */ ;
          }
        }
        }
      }
      can_si = 0;
      did_si = can_si;
    } else { //Added block
    if ((unsigned long )comment_end != (unsigned long )((void *)0)) {
      if ((int )*(comment_end + 0) == 42) {
        if ((int )*(comment_end + 1) == 47) {
          if (curbuf->b_p_ai) {
            goto _L___8;
          } else { //Added block
          if (do_si) {
            _L___8: 
            {
            old_cursor = curwin->w_cursor;
            curwin->w_cursor.col = (colnr_t )(comment_end - saved_line);
            pos___0 = findmatch((OPARG *)((void *)0), '\000');
            }
            if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
              {
              curwin->w_cursor.lnum = pos___0->lnum;
              newindent = get_indent();
              }
            }
            curwin->w_cursor = old_cursor;
          }
          }
        }
      }
    }
    }
  }
  if ((unsigned long )p_extra != (unsigned long )((void *)0)) {
    *p_extra = (char_u )saved_char;
    if (State == 528) {
      {
      replace_push('\000');
      }
    }
    if (curbuf->b_p_ai) {
      goto _L___9;
    } else { //Added block
    if (del_spaces) {
      _L___9: 
      {
      while (1) {
        while_continue___19: /* CIL Label */ ;
        if (! ((int )*p_extra == 32)) {
          if (! ((int )*p_extra == 9)) {
            goto while_break___19;
          }
        }
        if (State == 528) {
          {
          replace_push((int )*p_extra);
          }
        }
        p_extra ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    }
    }
    if ((int )*p_extra != 0) {
      did_ai = 0;
    }
  }
  if ((unsigned long )p_extra == (unsigned long )((void *)0)) {
    p_extra = (char_u *)"";
  }
  if (lead_len) {
    {
    strcat((char * __restrict  )((char *)leader), (char const   * __restrict  )((char *)p_extra));
    p_extra = leader;
    did_ai = 1;
    }
  } else {
    end_comment_pending = '\000';
  }
  old_cursor = curwin->w_cursor;
  if (dir == -1) {
    (curwin->w_cursor.lnum) --;
  }
  if (State != 784) {
    goto _L___10;
  } else { //Added block
  if (old_cursor.lnum >= (linenr_t )orig_line_count) {
    _L___10: 
    {
    tmp___12 = ml_append(curwin->w_cursor.lnum, p_extra, (colnr_t )0, 0);
    }
    if (! tmp___12) {
      goto theend;
    }
    {
    mark_adjust(curwin->w_cursor.lnum + 1L, (linenr_t )2147483647, 1L, 0L);
    }
  } else {
    (curwin->w_cursor.lnum) ++;
    if (curwin->w_cursor.lnum >= Insstart.lnum + (linenr_t )vr_lines_changed) {
      {
      u_save_cursor();
      vr_lines_changed ++;
      }
    }
    {
    ml_replace(curwin->w_cursor.lnum, p_extra, 1);
    (curwin->w_cursor.lnum) --;
    }
  }
  }
  {
  changed_line_abv_curs();
  }
  if (newindent) {
    goto _L___11;
  } else { //Added block
  if (did_si) {
    _L___11: 
    (curwin->w_cursor.lnum) ++;
    if (did_si) {
      if (p_sr) {
        newindent -= newindent % (int )curbuf->b_p_sw;
      }
      newindent += (int )curbuf->b_p_sw;
    }
    {
    set_indent(newindent, 0);
    ai_col = curwin->w_cursor.col;
    }
    if (State == 528) {
      n = 0;
      {
      while (1) {
        while_continue___20: /* CIL Label */ ;
        if (! (n < (int )curwin->w_cursor.col)) {
          goto while_break___20;
        }
        {
        replace_push('\000');
        n ++;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
    }
    newcol = (int )((colnr_t )newcol + curwin->w_cursor.col);
    if (no_si) {
      did_si = 0;
    }
  }
  }
  if (State == 528) {
    {
    while (1) {
      while_continue___21: /* CIL Label */ ;
      tmp___13 = lead_len;
      lead_len --;
      if (! (tmp___13 > 0)) {
        goto while_break___21;
      }
      {
      replace_push('\000');
      }
    }
    while_break___21: /* CIL Label */ ;
    }
  }
  curwin->w_cursor = old_cursor;
  if (dir == 1) {
    if (redraw) {
      {
      old_plines = plines(curwin->w_cursor.lnum);
      new_plines = old_plines;
      }
    }
    if (trunc_line) {
      goto _L___12;
    } else { //Added block
    if (State == 16) {
      goto _L___12;
    } else { //Added block
    if (State == 528) {
      goto _L___12;
    } else { //Added block
    if (State == 784) {
      _L___12: 
      *(saved_line + curwin->w_cursor.col) = (char_u )'\000';
      if (trunc_line) {
        {
        truncate_spaces(saved_line);
        }
      }
      {
      ml_replace(curwin->w_cursor.lnum, saved_line, 0);
      saved_line = (char_u *)((void *)0);
      syn_changed(curwin->w_cursor.lnum);
      }
      if (redraw) {
        {
        new_plines = plines(curwin->w_cursor.lnum);
        }
      }
    }
    }
    }
    }
    curwin->w_cursor.col = (colnr_t )0;
    if (redraw) {
      if (State != 784) {
        {
        extra_plines = plines(curwin->w_cursor.lnum + 1L);
        }
      } else { //Added block
      if (old_cursor.lnum >= (linenr_t )orig_line_count) {
        {
        extra_plines = plines(curwin->w_cursor.lnum + 1L);
        }
      }
      }
      n = curwin->w_cline_row + new_plines;
      if ((long )((n + extra_plines) - 1) >= (long )curwin->w_height - p_so) {
        if (redraw < 0) {
          {
          tmp___14 = plines(curwin->w_topline);
          win_del_lines(curwin, 0, tmp___14, 1, 1);
          }
        }
        {
        scrollup(1L);
        }
      } else {
        {
        win_ins_lines(curwin, n, (new_plines - old_plines) + extra_plines, 1, 1);
        }
      }
    }
    curwin->w_cursor.lnum = old_cursor.lnum + 1L;
  } else { //Added block
  if (redraw) {
    {
    win_ins_lines(curwin, curwin->w_cline_row, 1, 1, 1);
    }
  }
  }
  curwin->w_cursor.col = (colnr_t )newcol;
  if (State == 784) {
    State = 16;
    vreplace_mode = 1;
  } else {
    vreplace_mode = 0;
  }
  if ((unsigned long )leader == (unsigned long )((void *)0)) {
    if (curbuf->b_p_lisp) {
      if (curbuf->b_p_ai) {
        {
        fixthisline(& get_lisp_indent);
        p___0 = ml_get_curline();
        tmp___15 = skipwhite(p___0);
        ai_col = (colnr_t )(tmp___15 - p___0);
        }
      }
    }
  }
  if ((unsigned long )leader == (unsigned long )((void *)0)) {
    goto _L___13;
  } else { //Added block
  if (! curbuf->b_p_ai) {
    _L___13: 
    if (curbuf->b_p_cin) {
      {
      tmp___17 = linewhite(curwin->w_cursor.lnum);
      }
      if (dir == 1) {
        tmp___18 = 257;
      } else {
        tmp___18 = 258;
      }
      {
      tmp___19 = in_cinkeys(tmp___18, ' ', tmp___17);
      }
      if (tmp___19) {
        {
        fixthisline(& get_c_indent);
        p___0 = ml_get_curline();
        tmp___16 = skipwhite(p___0);
        ai_col = (colnr_t )(tmp___16 - p___0);
        }
      }
    }
  }
  }
  if (vreplace_mode) {
    State = 784;
  }
  if (State == 784) {
    {
    tmp___20 = ml_get_curline();
    p_extra = vim_strsave(tmp___20);
    }
    if ((unsigned long )p_extra == (unsigned long )((void *)0)) {
      goto theend;
    }
    {
    ml_replace(curwin->w_cursor.lnum, next_line, 0);
    curwin->w_cursor.col = (colnr_t )0;
    vr_virtcol = (colnr_t )2147483647;
    }
    {
    while (1) {
      while_continue___22: /* CIL Label */ ;
      if (! ((int )*p_extra != 0)) {
        goto while_break___22;
      }
      {
      tmp___21 = p_extra;
      p_extra ++;
      ins_char((int )*tmp___21);
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    next_line = (char_u *)((void *)0);
  }
  {
  approximate_botline();
  }
  if (redraw > 0) {
    {
    update_topline();
    update_screen(35);
    }
  }
  {
  changed();
  retval = 1;
  }
  theend: 
  {
  vim_free((void *)saved_line);
  vim_free((void *)next_line);
  vim_free((void *)allocated);
  }
  return (retval);
}
}
int get_leader_len(char_u *line , char_u **flags___0 , int backward ) 
{ 
  int i___0 ;
  int j ;
  int got_com ;
  int found_one ;
  char_u part_buf[50] ;
  char_u *string___0 ;
  char_u *list ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  got_com = 0;
  if (! fo_do_comments) {
    return (0);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*(line + i___0) == 32)) {
      if (! ((int )*(line + i___0) == 9)) {
        goto while_break;
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *(line + i___0)) {
      goto while_break___0;
    }
    found_one = 0;
    list = curbuf->b_p_com;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! *list) {
        goto while_break___1;
      }
      if (! got_com) {
        if ((unsigned long )flags___0 != (unsigned long )((void *)0)) {
          *flags___0 = list;
        }
      }
      {
      copy_option_part(& list, part_buf, 50, (char *)",");
      string___0 = vim_strchr(part_buf, ':');
      }
      if ((unsigned long )string___0 == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      tmp = string___0;
      string___0 ++;
      *tmp = (char_u )'\000';
      if (got_com) {
        {
        tmp___0 = vim_strchr(part_buf, 'n');
        }
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
          goto __Cont;
        }
      }
      if (backward) {
        {
        tmp___1 = vim_strchr(part_buf, 'O');
        }
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
          goto __Cont;
        }
      }
      if ((int )*(string___0 + 0) == 32) {
        goto _L;
      } else { //Added block
      if ((int )*(string___0 + 0) == 9) {
        _L: 
        if (i___0 == 0) {
          goto __Cont;
        } else { //Added block
        if (! ((int )*(line + (i___0 - 1)) == 32)) {
          if (! ((int )*(line + (i___0 - 1)) == 9)) {
            goto __Cont;
          }
        }
        }
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! ((int )*(string___0 + 0) == 32)) {
            if (! ((int )*(string___0 + 0) == 9)) {
              goto while_break___2;
            }
          }
          string___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      }
      j = 0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if ((int )*(string___0 + j) != 0) {
          if (! ((int )*(string___0 + j) == (int )*(line + (i___0 + j)))) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      if ((int )*(string___0 + j) != 0) {
        goto __Cont;
      }
      {
      tmp___2 = vim_strchr(part_buf, 'b');
      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        if (! ((int )*(line + (i___0 + j)) == 32)) {
          if (! ((int )*(line + (i___0 + j)) == 9)) {
            if ((int )*(line + (i___0 + j)) != 0) {
              goto __Cont;
            }
          }
        }
      }
      i___0 += j;
      got_com = 1;
      found_one = 1;
      goto while_break___1;
      __Cont: ;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (! found_one) {
      goto while_break___0;
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ((int )*(line + i___0) == 32)) {
        if (! ((int )*(line + i___0) == 9)) {
          goto while_break___4;
        }
      }
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    tmp___3 = vim_strchr(part_buf, 'n');
    }
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (got_com) {
    tmp___4 = i___0;
  } else {
    tmp___4 = 0;
  }
  return (tmp___4);
}
}
int plines_check(linenr_t p___0 ) 
{ 
  int tmp ;

  {
  if (p___0 < 1L) {
    return (2147483647);
  } else { //Added block
  if (p___0 > curbuf->b_ml.ml_line_count) {
    return (2147483647);
  }
  }
  {
  tmp = plines_win(curwin, p___0);
  }
  return (tmp);
}
}
int plines(linenr_t p___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = plines_win(curwin, p___0);
  }
  return (tmp);
}
}
int plines_win(WIN *wp , linenr_t p___0 ) 
{ 
  long col ;
  char_u *s ;
  int lines___0 ;
  int tmp ;

  {
  if (! wp->w_p_wrap) {
    return (1);
  }
  {
  s = ml_get_buf(wp->w_buffer, p___0, 0);
  }
  if ((int )*s == 0) {
    return (1);
  }
  {
  tmp = win_linetabsize(wp, s);
  col = (long )tmp;
  }
  if (wp->w_p_list) {
    if (lcs_eol != 0) {
      col ++;
    }
  }
  if (wp->w_p_nu) {
    col += 8L;
  }
  lines___0 = (int )((col + (Columns - 1L)) / Columns);
  if (lines___0 <= wp->w_height) {
    return (lines___0);
  }
  return (wp->w_height);
}
}
int plines_win_col(WIN *wp , linenr_t p___0 , long column ) 
{ 
  register long col ;
  register char_u *s ;
  register int lines___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! wp->w_p_wrap) {
    return (1);
  }
  {
  s = ml_get_buf(wp->w_buffer, p___0, 0);
  col = 0L;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*s != 0) {
      column --;
      if (! (column >= 0L)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    tmp___0 = win_lbr_chartabsize(wp, tmp, (colnr_t )col, (int *)((void *)0));
    col += (long )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*s == 9) {
    if (State & 1) {
      if (! wp->w_p_list) {
        {
        tmp___1 = win_lbr_chartabsize(wp, s, (colnr_t )col, (int *)((void *)0));
        col += (long )(tmp___1 - 1);
        }
      } else { //Added block
      if (lcs_tab1) {
        {
        tmp___1 = win_lbr_chartabsize(wp, s, (colnr_t )col, (int *)((void *)0));
        col += (long )(tmp___1 - 1);
        }
      }
      }
    }
  }
  if (wp->w_p_nu) {
    col += 8L;
  }
  lines___0 = (int )(1L + col / Columns);
  if (lines___0 <= wp->w_height) {
    return (lines___0);
  }
  return (wp->w_height);
}
}
int plines_m(linenr_t first___0 , linenr_t last ) 
{ 
  int tmp ;

  {
  {
  tmp = plines_m_win(curwin, first___0, last);
  }
  return (tmp);
}
}
int plines_m_win(WIN *wp , linenr_t first___0 , linenr_t last ) 
{ 
  int count___2 ;
  linenr_t tmp ;
  int tmp___0 ;

  {
  count___2 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (first___0 <= last)) {
      goto while_break;
    }
    {
    tmp = first___0;
    first___0 ++;
    tmp___0 = plines_win(wp, tmp);
    count___2 += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (count___2);
}
}
static int temporary_nolist(void) 
{ 
  int old_list ;
  char_u *tmp ;

  {
  old_list = curwin->w_p_list;
  if (old_list) {
    {
    tmp = vim_strchr(p_cpo, 'L');
    }
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      curwin->w_p_list = 0;
    }
  }
  return (old_list);
}
}
void ins_char(int c ) 
{ 
  char_u *p___0 ;
  char_u *newp ;
  char_u *oldp ;
  int oldlen ;
  int extra ;
  colnr_t col ;
  linenr_t lnum ;
  int vcol ;
  int new_vcol ;
  int i___0 ;
  int size ;
  int old_list ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  col = curwin->w_cursor.col;
  lnum = curwin->w_cursor.lnum;
  new_vcol = 0;
  oldp = ml_get(lnum);
  tmp = strlen((char const   *)((char *)oldp));
  oldlen = (int )(tmp + 1UL);
  }
  if (State != 528) {
    extra = 1;
  } else { //Added block
  if ((int )*(oldp + col) == 0) {
    extra = 1;
  } else {
    extra = 0;
  }
  }
  if (State == 528) {
    {
    replace_push('\000');
    }
    if (! extra) {
      {
      replace_push((int )*(oldp + col));
      }
    }
  }
  if (State == 784) {
    {
    old_list = temporary_nolist();
    }
    if (vr_virtcol == 2147483647U) {
      {
      getvcol(curwin, & curwin->w_cursor, (colnr_t *)((void *)0), & vr_virtcol, (colnr_t *)((void *)0));
      tmp___0 = get_replace_stack_virtcol();
      vr_virtoffset = (int )(vr_virtcol - (colnr_t )tmp___0);
      }
    }
    {
    vcol = (int )vr_virtcol;
    replace_push('\000');
    tmp___1 = chartabsize(c, (colnr_t )vcol);
    new_vcol = vcol + tmp___1;
    vcol -= vr_virtoffset;
    vr_virtoffset = 0;
    i___0 = (int )col;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((int )*(oldp + i___0) != 0)) {
        goto while_break;
      }
      {
      size = chartabsize((int )*(oldp + i___0), (colnr_t )vcol);
      vcol += size;
      }
      if (vcol > new_vcol) {
        if (size == 2) {
          if ((int )*(oldp + i___0) != 9) {
            goto _L;
          } else { //Added block
          if (curwin->w_p_list) {
            _L: 
            if (vcol == new_vcol + 1) {
              vr_virtoffset = 1;
            }
          }
          }
        }
        goto while_break;
      }
      {
      tmp___2 = i___0;
      i___0 ++;
      replace_push((int )*(oldp + tmp___2));
      extra --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    curwin->w_p_list = old_list;
  }
  {
  newp = alloc_check((unsigned int )(oldlen + extra));
  }
  if ((unsigned long )newp == (unsigned long )((void *)0)) {
    return;
  }
  if (col > 0U) {
    {
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
    }
  }
  p___0 = newp + col;
  if (State == 784) {
    if (extra <= 0) {
      {
      i___0 = (int )((col - (colnr_t )extra) + 1U);
      memmove((void *)((char *)(p___0 + 1)), (void const   *)((char *)(oldp + i___0)),
              (size_t )(oldlen - i___0));
      }
    } else {
      {
      memmove((void *)((char *)(p___0 + extra)), (void const   *)((char *)(oldp + col)),
              (size_t )((colnr_t )oldlen - col));
      }
    }
  } else {
    {
    memmove((void *)((char *)(p___0 + extra)), (void const   *)((char *)(oldp + col)),
            (size_t )((colnr_t )oldlen - col));
    }
  }
  {
  *p___0 = (char_u )c;
  ml_replace(lnum, newp, 0);
  }
  if (p_sm) {
    if (State & 16) {
      if (c == 41) {
        {
        showmatch();
        }
      } else { //Added block
      if (c == 125) {
        {
        showmatch();
        }
      } else { //Added block
      if (c == 93) {
        {
        showmatch();
        }
      }
      }
      }
    }
  }
  {
  (curwin->w_cursor.col) ++;
  vr_virtcol = (colnr_t )new_vcol;
  changed();
  changed_cline_bef_curs();
  approximate_botline();
  }
  return;
}
}
void ins_str(char_u *s ) 
{ 
  char_u *oldp ;
  char_u *newp ;
  int newlen ;
  size_t tmp ;
  int oldlen ;
  colnr_t col ;
  linenr_t lnum ;
  size_t tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)s));
  newlen = (int )tmp;
  col = curwin->w_cursor.col;
  lnum = curwin->w_cursor.lnum;
  oldp = ml_get(lnum);
  tmp___0 = strlen((char const   *)((char *)oldp));
  oldlen = (int )tmp___0;
  newp = alloc_check((unsigned int )((oldlen + newlen) + 1));
  }
  if ((unsigned long )newp == (unsigned long )((void *)0)) {
    return;
  }
  if (col > 0U) {
    {
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
    }
  }
  {
  memmove((void *)((char *)(newp + col)), (void const   *)((char *)s), (size_t )newlen);
  memmove((void *)((char *)((newp + col) + newlen)), (void const   *)((char *)(oldp + col)),
          (size_t )(((colnr_t )oldlen - col) + 1U));
  ml_replace(lnum, newp, 0);
  curwin->w_cursor.col += (colnr_t )newlen;
  changed();
  changed_cline_bef_curs();
  approximate_botline();
  }
  return;
}
}
int del_char(int fixpos ) 
{ 
  int tmp ;

  {
  {
  tmp = del_chars(1L, fixpos);
  }
  return (tmp);
}
}
int del_chars(long count___2 , int fixpos ) 
{ 
  char_u *oldp ;
  char_u *newp ;
  colnr_t oldlen ;
  linenr_t lnum ;
  colnr_t col ;
  int was_alloced ;
  long movelen ;
  size_t tmp ;

  {
  {
  lnum = curwin->w_cursor.lnum;
  col = curwin->w_cursor.col;
  oldp = ml_get(lnum);
  tmp = strlen((char const   *)((char *)oldp));
  oldlen = (colnr_t )tmp;
  }
  if (col >= oldlen) {
    return (0);
  }
  movelen = (((long )oldlen - (long )col) - count___2) + 1L;
  if (movelen <= 1L) {
    if (col > 0U) {
      if (fixpos) {
        (curwin->w_cursor.col) --;
      }
    }
    count___2 = (long )(oldlen - col);
    movelen = 1L;
  }
  {
  was_alloced = ml_line_alloced();
  }
  if (was_alloced) {
    newp = oldp;
  } else {
    {
    newp = alloc((unsigned int )((long )(oldlen + 1U) - count___2));
    }
    if ((unsigned long )newp == (unsigned long )((void *)0)) {
      return (0);
    }
    {
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
    }
  }
  {
  memmove((void *)((char *)(newp + col)), (void const   *)((char *)((oldp + col) + count___2)),
          (size_t )movelen);
  }
  if (! was_alloced) {
    {
    ml_replace(lnum, newp, 0);
    }
  }
  {
  changed();
  changed_cline_bef_curs();
  approximate_botline();
  }
  return (1);
}
}
int truncate_line(int fixpos ) 
{ 
  char_u *newp ;
  linenr_t lnum ;
  colnr_t col ;
  char_u *tmp ;

  {
  lnum = curwin->w_cursor.lnum;
  col = curwin->w_cursor.col;
  if (col == 0U) {
    {
    newp = vim_strsave((char_u *)"");
    }
  } else {
    {
    tmp = ml_get(lnum);
    newp = vim_strnsave(tmp, (int )col);
    }
  }
  if ((unsigned long )newp == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  ml_replace(lnum, newp, 0);
  }
  if (fixpos) {
    if (curwin->w_cursor.col > 0U) {
      (curwin->w_cursor.col) --;
    }
  }
  {
  changed();
  changed_cline_bef_curs();
  approximate_botline();
  }
  return (1);
}
}
void del_lines(long nlines , int dowindow , int undo ) 
{ 
  int num_plines ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  num_plines = 0;
  offset = 0;
  if (nlines <= 0L) {
    return;
  }
  {
  tmp = redrawing();
  }
  if (tmp) {
    {
    tmp___0 = botline_approximated();
    }
    if (tmp___0) {
      {
      validate_cursor();
      }
      if (nlines > (long )(curwin->w_height - curwin->w_wrow)) {
        if (dowindow) {
          {
          dowindow = 0;
          win_del_lines(curwin, curwin->w_wrow, curwin->w_height, 1, 1);
          }
        }
      }
    } else {
      dowindow = 0;
    }
  } else {
    dowindow = 0;
  }
  {
  approximate_botline();
  }
  if (undo) {
    {
    tmp___1 = u_savedel(curwin->w_cursor.lnum, nlines);
    }
    if (tmp___1 == 0) {
      return;
    }
  }
  {
  mark_adjust(curwin->w_cursor.lnum, (curwin->w_cursor.lnum + nlines) - 1L, (linenr_t )2147483647,
              - nlines);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___3 = nlines;
    nlines --;
    if (! (tmp___3 > 0L)) {
      goto while_break;
    }
    if (curbuf->b_ml.ml_flags & 1) {
      goto while_break;
    }
    if (dowindow) {
      {
      tmp___2 = plines(curwin->w_cursor.lnum);
      num_plines += tmp___2;
      }
    }
    {
    ml_delete(curwin->w_cursor.lnum, 1);
    changed();
    }
    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
      offset = 1;
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  curwin->w_cursor.col = (colnr_t )0;
  changed_cline_bef_curs();
  }
  if (dowindow) {
    if (num_plines > 0) {
      {
      validate_cline_row();
      win_del_lines(curwin, curwin->w_cline_row + offset, num_plines, 1, 1);
      }
    }
  }
  return;
}
}
int gchar_pos(FPOS *pos___0 ) 
{ 
  char_u *ptr ;
  char_u *tmp ;

  {
  {
  tmp = ml_get_pos(pos___0);
  ptr = tmp;
  }
  return ((int )*ptr);
}
}
int gchar_cursor(void) 
{ 
  char_u *ptr ;
  char_u *tmp ;

  {
  {
  tmp = ml_get_cursor();
  ptr = tmp;
  }
  return ((int )*ptr);
}
}
void pchar_cursor(int c ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, curwin->w_cursor.lnum, 1);
  *(tmp + curwin->w_cursor.col) = (char_u )c;
  }
  return;
}
}
int inindent(int extra ) 
{ 
  char_u *ptr ;
  colnr_t col ;

  {
  {
  col = (colnr_t )0;
  ptr = ml_get_curline();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*ptr == 32)) {
      if (! ((int )*ptr == 9)) {
        goto while_break;
      }
    }
    ptr ++;
    col ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (col >= curwin->w_cursor.col + (colnr_t )extra) {
    return (1);
  } else {
    return (0);
  }
}
}
char_u *skip_to_option_part(char_u *p___0 ) 
{ 


  {
  if ((int )*p___0 == 44) {
    p___0 ++;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*p___0 == 32)) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
static char buf___1[2]  = {      (char )'s',      (char )'\000'};
char *plural(long n ) 
{ 


  {
  if (n == 1L) {
    return (& buf___1[1]);
  }
  return (& buf___1[0]);
}
}
void changed(void) 
{ 
  int save_msg_scroll ;

  {
  save_msg_scroll = msg_scroll;
  if (! curbuf->b_changed) {
    {
    change_warning(0);
    }
    if (curbuf->b_may_swap) {
      {
      ml_open_file(curbuf);
      }
      if (need_wait_return) {
        {
        out_flush();
        ui_delay(2000L, 1);
        wait_return(1);
        msg_scroll = save_msg_scroll;
        }
      }
    }
    {
    curbuf->b_changed = 1;
    ml_setdirty(curbuf, 1);
    check_status(curbuf);
    }
  }
  modified = 1;
  tag_modified = 1;
  return;
}
}
void unchanged(BUF *buf___3 , int ff ) 
{ 


  {
  if (buf___3->b_changed) {
    goto _L;
  } else { //Added block
  if (ff) {
    if (buf___3->b_start_ffc != (int )*(buf___3->b_p_ff)) {
      _L: 
      {
      buf___3->b_changed = 0;
      ml_setdirty(buf___3, 0);
      }
      if (ff) {
        buf___3->b_start_ffc = (int )*(buf___3->b_p_ff);
      }
      {
      check_status(buf___3);
      }
    }
  }
  }
  return;
}
}
void check_status(BUF *buf___3 ) 
{ 
  WIN *wp ;
  int i___0 ;

  {
  i___0 = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )wp->w_buffer == (unsigned long )buf___3) {
      if (wp->w_status_height) {
        wp->w_redr_status = 1;
        i___0 ++;
      }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  if (i___0) {
    {
    redraw_later(40);
    }
  }
  return;
}
}
void change_warning(int col ) 
{ 
  int tmp ;

  {
  if (curbuf->b_did_warn == 0) {
    {
    tmp = curbuf_changed();
    }
    if (tmp == 0) {
      if (! p_im) {
        if (! autocmd_busy) {
          if (curbuf->b_p_ro) {
            {
            msg_start();
            }
            if ((long )msg_row == Rows - 1L) {
              msg_col = col;
            }
            {
            msg_puts_attr((char_u *)"Warning: Changing a readonly file", highlight_attr[16] | 4096);
            msg_clr_eos();
            msg_end();
            out_flush();
            ui_delay(1000L, 1);
            curbuf->b_did_warn = 1;
            redraw_cmdline = 0;
            }
            if ((long )msg_row < Rows - 1L) {
              {
              showmode();
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
int ask_yesno(char_u *str___1 , int direct ) 
{ 
  int r ;
  int save_State ;

  {
  r = ' ';
  save_State = State;
  if (exiting) {
    {
    settmode(2);
    }
  }
  {
  no_wait_return ++;
  State = 3072;
  setmouse();
  no_mapping ++;
  allow_keys ++;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (r != 121) {
      if (! (r != 110)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    smsg_attr(highlight_attr[10], (char_u *)"%s (y/n)?", str___1);
    }
    if (direct) {
      {
      r = get_keystroke();
      }
    } else {
      {
      r = safe_vgetc();
      }
    }
    if (r == 3) {
      r = 'n';
    } else { //Added block
    if (r == 27) {
      r = 'n';
    }
    }
    {
    msg_putchar(r);
    out_flush();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  no_wait_return --;
  State = save_State;
  setmouse();
  no_mapping --;
  allow_keys --;
  }
  return (r);
}
}
int get_keystroke(void) 
{ 
  char_u buf___3[51] ;
  int len___0 ;
  int n ;
  long tmp ;
  int tmp___0 ;

  {
  len___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    cursor_on();
    out_flush();
    }
    if (len___0 == 0) {
      tmp = -1L;
    } else {
      tmp = 100L;
    }
    {
    n = ui_inchar(buf___3 + len___0, 45 - len___0, tmp);
    }
    if (n > 0) {
      {
      len___0 += n;
      n = check_termcode(1, buf___3, len___0);
      }
      if (n < 0) {
        goto __Cont;
      }
      if (n) {
        len___0 = n;
      }
    }
    if (len___0 == 0) {
      goto __Cont;
    }
    if ((int )buf___3[0] == 128) {
      if ((int )buf___3[1] == 252) {
        mod_mask = (int )buf___3[2];
        len___0 -= 3;
        if (len___0 == 0) {
          goto __Cont;
        }
        {
        memmove((void *)((char *)(buf___3)), (void const   *)((char *)(buf___3 + 3)),
                (size_t )len___0);
        }
      }
    }
    n = (int )buf___3[0];
    if (n == 128) {
      if ((int )buf___3[1] == 254) {
        n = 128;
      } else {
        if ((int )buf___3[1] == 255) {
          tmp___0 = 255 + (88 << 8);
        } else {
          tmp___0 = (int )buf___3[1] + ((int )buf___3[2] << 8);
        }
        n = tmp___0;
      }
      if (n == 253 + (42 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (61 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (43 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (44 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (62 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (45 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (46 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (47 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (48 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (49 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (50 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (67 << 8)) {
        len___0 = 0;
        goto __Cont;
      } else { //Added block
      if (n == 253 + (68 << 8)) {
        len___0 = 0;
        goto __Cont;
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
    }
    if (n == intr_char) {
      n = '\033';
    }
    goto while_break;
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  return (n);
}
}
int get_number(int colon ) 
{ 
  int n ;
  int c ;
  int tmp ;

  {
  n = 0;
  no_mapping ++;
  allow_keys ++;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    windgoto(msg_row, msg_col);
    c = safe_vgetc();
    tmp = vim_isdigit(c);
    }
    if (tmp) {
      {
      n = (n * 10 + c) - 48;
      msg_putchar(c);
      }
    } else { //Added block
    if (c == 107 + (68 << 8)) {
      {
      n /= 10;
      msg_puts((char_u *)"\b \b");
      }
    } else { //Added block
    if (c == 253 + (70 << 8)) {
      {
      n /= 10;
      msg_puts((char_u *)"\b \b");
      }
    } else { //Added block
    if (c == 107 + (98 << 8)) {
      {
      n /= 10;
      msg_puts((char_u *)"\b \b");
      }
    } else { //Added block
    if (c == 8) {
      {
      n /= 10;
      msg_puts((char_u *)"\b \b");
      }
    } else { //Added block
    if (n == 0) {
      if (c == 58) {
        if (colon) {
          {
          stuffcharReadbuff(':');
          }
          if (! exmode_active) {
            cmdline_row = msg_row;
          }
          skip_redraw = 1;
          do_redraw = 0;
          goto while_break;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (c == 13) {
      goto while_break;
    } else { //Added block
    if (c == 10) {
      goto while_break;
    } else { //Added block
    if (c == 3) {
      goto while_break;
    } else { //Added block
    if (c == 27) {
      goto while_break;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  no_mapping --;
  allow_keys --;
  return (n);
}
}
void msgmore(long n ) 
{ 
  long pn ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  if (global_busy) {
    return;
  } else { //Added block
  if (keep_msg) {
    return;
  } else {
    {
    tmp = messaging();
    }
    if (! tmp) {
      return;
    }
  }
  }
  if (n > 0L) {
    pn = n;
  } else {
    pn = - n;
  }
  if (pn > p_report) {
    if (got_int) {
      tmp___0 = "(Interrupted)";
    } else {
      tmp___0 = "";
    }
    {
    tmp___1 = plural(pn);
    }
    if (n > 0L) {
      tmp___2 = "more";
    } else {
      tmp___2 = "fewer";
    }
    {
    sprintf((char * __restrict  )((char *)(msg_buf)), (char const   * __restrict  )"%ld %s line%s %s",
            pn, tmp___2, tmp___1, tmp___0);
    tmp___3 = msg(msg_buf);
    }
    if (tmp___3) {
      keep_msg = msg_buf;
      keep_msg_attr = 0;
    }
  }
  return;
}
}
void beep_flush(void) 
{ 


  {
  {
  flush_buffers(0);
  vim_beep();
  }
  return;
}
}
void vim_beep(void) 
{ 


  {
  if (p_vb) {
    {
    out_str(term_strings[27]);
    }
  } else {
    {
    out_char((unsigned int )'\a');
    }
  }
  return;
}
}
static char_u *homedir  =    (char_u *)((void *)0);
void init_homedir(void) 
{ 
  char_u *var___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = getenv((char const   *)((char *)((char_u *)"HOME")));
  var___0 = (char_u *)tmp;
  }
  if ((unsigned long )var___0 != (unsigned long )((void *)0)) {
    if ((int )*var___0 == 0) {
      var___0 = (char_u *)((void *)0);
    }
  }
  if ((unsigned long )var___0 != (unsigned long )((void *)0)) {
    {
    tmp___2 = mch_dirname(NameBuff, 1024);
    }
    if (tmp___2 == 1) {
      {
      tmp___0 = chdir((char const   *)((char *)var___0));
      }
      if (! tmp___0) {
        {
        tmp___1 = mch_dirname(IObuff, 1025);
        }
        if (tmp___1 == 1) {
          var___0 = IObuff;
        }
      }
      {
      chdir((char const   *)((char *)NameBuff));
      }
    }
    {
    homedir = vim_strsave(var___0);
    }
  }
  return;
}
}
void expand_env(char_u *src , char_u *dst , int dstlen ) 
{ 
  char_u *tail ;
  int c ;
  char_u *var___0 ;
  int copy_char ;
  int mustfree ;
  int at_start___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct passwd *pw ;
  int tmp___12 ;
  char_u *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;
  char_u *tmp___22 ;
  char_u *tmp___23 ;

  {
  {
  at_start___0 = 1;
  src = skipwhite(src);
  dstlen --;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*src) {
      if (! (dstlen > 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    copy_char = 1;
    if ((int )*src == 36) {
      goto _L___0;
    } else { //Added block
    if ((int )*src == 126) {
      if (at_start___0) {
        _L___0: 
        mustfree = 0;
        if ((int )*src == 36) {
          tail = src + 1;
          var___0 = dst;
          c = dstlen - 1;
          if ((int )*tail == 123) {
            {
            tmp___6 = vim_isIDc('{');
            }
            if (tmp___6) {
              goto _L;
            } else {
              tail ++;
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                tmp___1 = c;
                c --;
                if (tmp___1 > 0) {
                  if (*tail) {
                    if (! ((int )*tail != 125)) {
                      goto while_break___0;
                    }
                  } else {
                    goto while_break___0;
                  }
                } else {
                  goto while_break___0;
                }
                tmp = var___0;
                var___0 ++;
                tmp___0 = tail;
                tail ++;
                *tmp = *tmp___0;
              }
              while_break___0: /* CIL Label */ ;
              }
              tail ++;
            }
          } else {
            _L: 
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              tmp___4 = c;
              c --;
              if (tmp___4 > 0) {
                if (*tail) {
                  {
                  tmp___5 = vim_isIDc((int )*tail);
                  }
                  if (! tmp___5) {
                    goto while_break___1;
                  }
                } else {
                  goto while_break___1;
                }
              } else {
                goto while_break___1;
              }
              tmp___2 = var___0;
              var___0 ++;
              tmp___3 = tail;
              tail ++;
              *tmp___2 = *tmp___3;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
          {
          *var___0 = (char_u )'\000';
          var___0 = vim_getenv(dst, & mustfree);
          }
        } else { //Added block
        if ((int )*(src + 1) == 0) {
          var___0 = homedir;
          tail = src + 1;
        } else {
          {
          tmp___12 = vim_ispathsep((int )*(src + 1));
          }
          if (tmp___12) {
            var___0 = homedir;
            tail = src + 1;
          } else {
            {
            tmp___13 = vim_strchr((char_u *)" ,\t\n", (int )*(src + 1));
            }
            if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
              var___0 = homedir;
              tail = src + 1;
            } else {
              tail = src;
              var___0 = dst;
              c = dstlen - 1;
              {
              while (1) {
                while_continue___2: /* CIL Label */ ;
                tmp___9 = c;
                c --;
                if (tmp___9 > 0) {
                  if (*tail) {
                    {
                    tmp___10 = vim_isfilec((int )*tail);
                    }
                    if (tmp___10) {
                      {
                      tmp___11 = vim_ispathsep((int )*tail);
                      }
                      if (tmp___11) {
                        goto while_break___2;
                      }
                    } else {
                      goto while_break___2;
                    }
                  } else {
                    goto while_break___2;
                  }
                } else {
                  goto while_break___2;
                }
                tmp___7 = var___0;
                var___0 ++;
                tmp___8 = tail;
                tail ++;
                *tmp___7 = *tmp___8;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
              *var___0 = (char_u )'\000';
              pw = getpwnam((char const   *)((char *)dst + 1));
              }
              if ((unsigned long )pw != (unsigned long )((void *)0)) {
                var___0 = (char_u *)pw->pw_dir;
              } else {
                var___0 = (char_u *)((void *)0);
              }
              if ((unsigned long )var___0 == (unsigned long )((void *)0)) {
                {
                expand_context = 2;
                var___0 = ExpandOne(dst, (char_u *)((void *)0), 80, 2);
                mustfree = 1;
                }
              }
            }
          }
        }
        }
        if ((unsigned long )var___0 != (unsigned long )((void *)0)) {
          if ((int )*var___0 != 0) {
            {
            tmp___18 = strlen((char const   *)((char *)var___0));
            tmp___19 = strlen((char const   *)((char *)tail));
            }
            if ((tmp___18 + tmp___19) + 1UL < (size_t )((unsigned int )dstlen)) {
              {
              strcpy((char * __restrict  )((char *)dst), (char const   * __restrict  )((char *)var___0));
              tmp___14 = strlen((char const   *)((char *)var___0));
              dstlen = (int )((size_t )dstlen - tmp___14);
              tmp___15 = strlen((char const   *)((char *)var___0));
              dst += tmp___15;
              }
              if (*var___0) {
                {
                tmp___16 = vim_ispathsep((int )*(dst - 1));
                }
                if (tmp___16) {
                  {
                  tmp___17 = vim_ispathsep((int )*tail);
                  }
                  if (tmp___17) {
                    tail ++;
                  }
                }
              }
              src = tail;
              copy_char = 0;
            }
          }
        }
        if (mustfree) {
          {
          vim_free((void *)var___0);
          }
        }
      }
    }
    }
    if (copy_char) {
      at_start___0 = 0;
      if ((int )*(src + 0) == 92) {
        tmp___20 = dst;
        dst ++;
        tmp___21 = src;
        src ++;
        *tmp___20 = *tmp___21;
        dstlen --;
      } else { //Added block
      if ((int )*(src + 0) == 32) {
        at_start___0 = 1;
      } else { //Added block
      if ((int )*(src + 0) == 44) {
        at_start___0 = 1;
      }
      }
      }
      tmp___22 = dst;
      dst ++;
      tmp___23 = src;
      src ++;
      *tmp___22 = *tmp___23;
      dstlen --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  *dst = (char_u )'\000';
  return;
}
}
static char_u *vim_getenv(char_u *name___1 , int *mustfree ) 
{ 
  char_u *p___0 ;
  char_u *pend ;
  int vimruntime ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  tmp = getenv((char const   *)((char *)name___1));
  p___0 = (char_u *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if ((int )*p___0 == 0) {
      p___0 = (char_u *)((void *)0);
    }
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    return (p___0);
  }
  {
  tmp___0 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"VIMRUNTIME"));
  vimruntime = tmp___0 == 0;
  }
  if (! vimruntime) {
    {
    tmp___1 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"VIM"));
    }
    if (tmp___1 != 0) {
      return ((char_u *)((void *)0));
    }
  }
  if (vimruntime) {
    if ((int )*default_vimruntime_dir == 0) {
      {
      tmp___2 = getenv((char const   *)((char *)((char_u *)"VIM")));
      p___0 = (char_u *)tmp___2;
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        if ((int )*p___0 == 0) {
          p___0 = (char_u *)((void *)0);
        }
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        {
        p___0 = vim_version_dir(p___0);
        }
        if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
          *mustfree = 1;
        } else {
          {
          tmp___3 = getenv((char const   *)((char *)((char_u *)"VIM")));
          p___0 = (char_u *)tmp___3;
          }
        }
      }
    }
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
    tmp___4 = vim_strchr(p_hf, '$');
    }
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      p___0 = p_hf;
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      {
      pend = gettail(p___0);
      }
      if ((unsigned long )p___0 == (unsigned long )p_hf) {
        {
        pend = remove_tail(p___0, pend, (char_u *)"doc");
        }
      }
      if (! vimruntime) {
        {
        pend = remove_tail(p___0, pend, (char_u *)"runtime");
        pend = remove_tail(p___0, pend, (char_u *)"vim58");
        }
      }
      if ((unsigned long )pend > (unsigned long )p___0) {
        {
        tmp___5 = vim_ispathsep((int )*(pend - 1));
        }
        if (tmp___5) {
          pend --;
        }
      }
      {
      p___0 = vim_strnsave(p___0, (int )(pend - p___0));
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        {
        tmp___6 = mch_isdir(p___0);
        }
        if (tmp___6) {
          *mustfree = 1;
        } else {
          {
          vim_free((void *)p___0);
          p___0 = (char_u *)((void *)0);
          }
        }
      } else {
        *mustfree = 1;
      }
    }
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    if (vimruntime) {
      if ((int )*default_vimruntime_dir != 0) {
        p___0 = default_vimruntime_dir;
        *mustfree = 0;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (vimruntime) {
      {
      p___0 = vim_version_dir(default_vim_dir);
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        *mustfree = 1;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*default_vim_dir != 0) {
      p___0 = default_vim_dir;
      *mustfree = 0;
    }
    }
    }
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if (vimruntime) {
      {
      vim_setenv((char_u *)"VIMRUNTIME", p___0);
      didset_vimruntime = 1;
      }
    } else {
      {
      vim_setenv((char_u *)"VIM", p___0);
      didset_vim = 1;
      }
    }
  }
  return (p___0);
}
}
static char_u *vim_version_dir(char_u *vimdir ) 
{ 
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )vimdir == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((int )*vimdir == 0) {
    return ((char_u *)((void *)0));
  }
  }
  {
  p___0 = concat_fnames(vimdir, (char_u *)"vim58", 1);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp = mch_isdir(p___0);
    }
    if (tmp) {
      return (p___0);
    }
  }
  {
  vim_free((void *)p___0);
  p___0 = concat_fnames(vimdir, (char_u *)"runtime", 1);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp___0 = mch_isdir(p___0);
    }
    if (tmp___0) {
      return (p___0);
    }
  }
  {
  vim_free((void *)p___0);
  }
  return ((char_u *)((void *)0));
}
}
static char_u *remove_tail(char_u *p___0 , char_u *pend , char_u *name___1 ) 
{ 
  int len___0 ;
  size_t tmp ;
  char_u *newend ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = strlen((char const   *)((char *)name___1));
  len___0 = (int )(tmp + 1UL);
  newend = pend - len___0;
  }
  if ((unsigned long )newend >= (unsigned long )p___0) {
    {
    tmp___0 = strncmp((char const   *)((char *)newend), (char const   *)((char *)name___1),
                      (size_t )(len___0 - 1));
    }
    if (tmp___0 == 0) {
      if ((unsigned long )newend == (unsigned long )p___0) {
        return (newend);
      } else {
        {
        tmp___1 = vim_ispathsep((int )*(newend - 1));
        }
        if (tmp___1) {
          return (newend);
        }
      }
    }
  }
  return (pend);
}
}
char_u *expand_env_save(char_u *src ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = alloc(1024U);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    expand_env(src, p___0, 1024);
    }
  }
  return (p___0);
}
}
void vim_setenv(char_u *name___1 , char_u *val ) 
{ 


  {
  {
  setenv((char const   *)((char *)name___1), (char const   *)((char *)val), 1);
  }
  return;
}
}
void home_replace(BUF *buf___3 , char_u *src , char_u *dst , int dstlen , int one ) 
{ 
  size_t dirlen ;
  size_t envlen ;
  size_t len___0 ;
  char_u *homedir_env ;
  char_u *p___0 ;
  char_u *tmp ;
  char *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;

  {
  dirlen = (size_t )0;
  envlen = (size_t )0;
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    *dst = (char_u )'\000';
    return;
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    if (buf___3->b_help) {
      {
      tmp = gettail(src);
      strcpy((char * __restrict  )((char *)dst), (char const   * __restrict  )((char *)tmp));
      }
      return;
    }
  }
  if ((unsigned long )homedir != (unsigned long )((void *)0)) {
    {
    dirlen = strlen((char const   *)((char *)homedir));
    }
  }
  {
  tmp___0 = getenv((char const   *)((char *)((char_u *)"HOME")));
  homedir_env = (char_u *)tmp___0;
  }
  if ((unsigned long )homedir_env != (unsigned long )((void *)0)) {
    if ((int )*homedir_env == 0) {
      homedir_env = (char_u *)((void *)0);
    }
  }
  if ((unsigned long )homedir_env != (unsigned long )((void *)0)) {
    {
    envlen = strlen((char const   *)((char *)homedir_env));
    }
  }
  if (! one) {
    {
    src = skipwhite(src);
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*src) {
      if (! (dstlen > 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    p___0 = homedir;
    len___0 = dirlen;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (len___0) {
        {
        tmp___4 = strncmp((char const   *)((char *)src), (char const   *)((char *)p___0),
                          len___0);
        }
        if (tmp___4 == 0) {
          {
          tmp___5 = vim_ispathsep((int )*(src + len___0));
          }
          if (tmp___5) {
            goto _L;
          } else { //Added block
          if (! one) {
            if ((int )*(src + len___0) == 44) {
              goto _L;
            } else { //Added block
            if ((int )*(src + len___0) == 32) {
              goto _L;
            } else {
              goto _L___0;
            }
            }
          } else { //Added block
          _L___0: 
          if ((int )*(src + len___0) == 0) {
            _L: 
            src += len___0;
            dstlen --;
            if (dstlen > 0) {
              tmp___1 = dst;
              dst ++;
              *tmp___1 = (char_u )'~';
            }
            {
            tmp___3 = vim_ispathsep((int )*(src + 0));
            }
            if (! tmp___3) {
              dstlen --;
              if (dstlen > 0) {
                tmp___2 = dst;
                dst ++;
                *tmp___2 = (char_u )'/';
              }
            }
            goto while_break___0;
          }
          }
          }
        }
      }
      if ((unsigned long )p___0 == (unsigned long )homedir_env) {
        goto while_break___0;
      }
      p___0 = homedir_env;
      len___0 = envlen;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (*src) {
        if (one) {
          goto _L___1;
        } else { //Added block
        if ((int )*src != 44) {
          if ((int )*src != 32) {
            _L___1: 
            dstlen --;
            if (! (dstlen > 0)) {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        }
      } else {
        goto while_break___1;
      }
      tmp___6 = dst;
      dst ++;
      tmp___7 = src;
      src ++;
      *tmp___6 = *tmp___7;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if ((int )*src == 32) {
        goto _L___2;
      } else { //Added block
      if ((int )*src == 44) {
        _L___2: 
        dstlen --;
        if (! (dstlen > 0)) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
      }
      tmp___8 = dst;
      dst ++;
      tmp___9 = src;
      src ++;
      *tmp___8 = *tmp___9;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  *dst = (char_u )'\000';
  return;
}
}
char_u *home_replace_save(BUF *buf___3 , char_u *src ) 
{ 
  char_u *dst ;
  unsigned int len___0 ;
  size_t tmp ;

  {
  len___0 = 3U;
  if ((unsigned long )src != (unsigned long )((void *)0)) {
    {
    tmp = strlen((char const   *)((char *)src));
    len___0 = (unsigned int )((size_t )len___0 + tmp);
    }
  }
  {
  dst = alloc(len___0);
  }
  if ((unsigned long )dst != (unsigned long )((void *)0)) {
    {
    home_replace(buf___3, src, dst, (int )len___0, 1);
    }
  }
  return (dst);
}
}
int fullpathcmp(char_u *s1 , char_u *s2 , int checkname ) 
{ 
  char_u exp1[1024] ;
  char_u full1[1024] ;
  char_u full2[1024] ;
  struct stat st1 ;
  struct stat st2 ;
  int r1 ;
  int r2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  expand_env(s1, exp1, 1024);
  r1 = stat((char const   * __restrict  )((char *)(exp1)), (struct stat * __restrict  )(& st1));
  r2 = stat((char const   * __restrict  )((char *)s2), (struct stat * __restrict  )(& st2));
  }
  if (r1 != 0) {
    if (r2 != 0) {
      if (checkname) {
        {
        tmp = strcmp((char const   *)((char *)(exp1)), (char const   *)((char *)s2));
        }
        if (tmp == 0) {
          return (7);
        }
        {
        r1 = mch_FullName(exp1, full1, 1024, 0);
        r2 = mch_FullName(s2, full2, 1024, 0);
        }
        if (r1 == 1) {
          if (r2 == 1) {
            {
            tmp___0 = strcmp((char const   *)((char *)(full1)), (char const   *)((char *)(full2)));
            }
            if (tmp___0 == 0) {
              return (7);
            }
          }
        }
      }
      return (4);
    }
  }
  if (r1 != 0) {
    return (6);
  } else { //Added block
  if (r2 != 0) {
    return (6);
  }
  }
  if (st1.st_dev == st2.st_dev) {
    if (st1.st_ino == st2.st_ino) {
      return (1);
    }
  }
  return (2);
}
}
char_u *gettail(char_u *fname ) 
{ 
  char_u *p1 ;
  char_u *p2 ;
  int tmp ;

  {
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    return ((char_u *)"");
  }
  p2 = fname;
  p1 = p2;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p2) {
      goto while_break;
    }
    {
    tmp = vim_ispathsep((int )*p2);
    }
    if (tmp) {
      p1 = p2 + 1;
    }
    p2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p1);
}
}
char_u *getnextcomp(char_u *fname ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*fname) {
      {
      tmp = vim_ispathsep((int )*fname);
      }
      if (tmp) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    fname ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (*fname) {
    fname ++;
  }
  return (fname);
}
}
char_u *get_past_head(char_u *path ) 
{ 
  char_u *retval ;
  int tmp ;

  {
  retval = path;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = vim_ispathsep((int )*retval);
    }
    if (! tmp) {
      goto while_break;
    }
    retval ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (retval);
}
}
int vim_ispathsep(int c ) 
{ 


  {
  return (c == 47);
}
}
char_u *concat_fnames(char_u *fname1 , char_u *fname2 , int sep ) 
{ 
  char_u *dest ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)fname1));
  tmp___0 = strlen((char const   *)((char *)fname2));
  dest = alloc((unsigned int )((tmp + tmp___0) + 3UL));
  }
  if ((unsigned long )dest != (unsigned long )((void *)0)) {
    {
    strcpy((char * __restrict  )((char *)dest), (char const   * __restrict  )((char *)fname1));
    }
    if (sep) {
      {
      add_pathsep(dest);
      }
    }
    {
    strcat((char * __restrict  )((char *)dest), (char const   * __restrict  )((char *)fname2));
    }
  }
  return (dest);
}
}
void add_pathsep(char_u *p___0 ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  if (*p___0) {
    {
    tmp = strlen((char const   *)((char *)p___0));
    tmp___0 = vim_ispathsep((int )*((p___0 + tmp) - 1));
    }
    if (! tmp___0) {
      {
      strcat((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)"/"));
      }
    }
  }
  return;
}
}
char_u *FullName_save(char_u *fname , int force ) 
{ 
  char_u *buf___3 ;
  char_u *new_fname ;
  int tmp ;

  {
  new_fname = (char_u *)((void *)0);
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  buf___3 = alloc(1024U);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    {
    tmp = mch_FullName(fname, buf___3, 1024, force);
    }
    if (tmp != 0) {
      {
      new_fname = vim_strsave(buf___3);
      }
    } else {
      {
      new_fname = vim_strsave(fname);
      }
    }
    {
    vim_free((void *)buf___3);
    }
  }
  return (new_fname);
}
}
static char_u *skip_string(char_u *p___0 ) ;
FPOS *find_start_comment(int ind_maxcomment ) 
{ 
  FPOS *pos___0 ;
  char_u *line ;
  char_u *p___0 ;

  {
  {
  pos___0 = findmatchlimit((OPARG *)((void *)0), '*', 1, ind_maxcomment);
  }
  if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
    return ((FPOS *)((void *)0));
  }
  {
  line = ml_get(pos___0->lnum);
  p___0 = line;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if (! ((unsigned int )(p___0 - line) < pos___0->col)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    p___0 = skip_string(p___0);
    p___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned int )(p___0 - line) > pos___0->col) {
    return ((FPOS *)((void *)0));
  }
  return (pos___0);
}
}
static char_u *skip_string(char_u *p___0 ) 
{ 
  int i___0 ;
  unsigned short const   **tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*(p___0 + 0) == 39) {
      if (! *(p___0 + 1)) {
        goto while_break;
      }
      i___0 = 2;
      if ((int )*(p___0 + 1) == 92) {
        i___0 ++;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
          tmp = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp + (int )*(p___0 + (i___0 - 1))) & 2048)) {
            goto while_break___0;
          }
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      if ((int )*(p___0 + i___0) == 39) {
        p___0 += i___0;
        goto __Cont;
      }
    } else { //Added block
    if ((int )*(p___0 + 0) == 34) {
      p___0 ++;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! *(p___0 + 0)) {
          goto while_break___1;
        }
        if ((int )*(p___0 + 0) == 92) {
          if (*(p___0 + 1)) {
            p___0 ++;
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if ((int )*(p___0 + 0) == 34) {
          goto while_break___1;
        }
        }
        p___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      goto __Cont;
    }
    }
    goto while_break;
    __Cont: 
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (! *p___0) {
    p___0 --;
  }
  return (p___0);
}
}
static char_u *cin_skipcomment(char_u *s ) ;
static int cin_nocode(char_u *s ) ;
static int cin_islabel_skip(char_u **s ) ;
static int cin_isdefault(char_u *s ) ;
static char_u *after_label(char_u *l ) ;
static int get_indent_nolabel(linenr_t lnum ) ;
static int skip_label(linenr_t lnum , char_u **pp , int ind_maxcomment ) ;
static int cin_ispreproc(char_u *s ) ;
static int cin_iscomment(char_u *p___0 ) ;
static int cin_isterminated(char_u *s , int incl_open ) ;
static int cin_isfuncdecl(char_u *s ) ;
static int cin_isif(char_u *p___0 ) ;
static int cin_iselse(char_u *p___0 ) ;
static int cin_isdo(char_u *p___0 ) ;
static int cin_iswhileofdo(char_u *p___0 , linenr_t lnum , int ind_maxparen ) ;
static int cin_skip2pos(FPOS *trypos ) ;
static FPOS *find_start_brace(int ind_maxcomment ) ;
static FPOS *find_match_paren(int ind_maxparen , int ind_maxcomment ) ;
static int find_last_paren(char_u *l ) ;
static int find_match(int lookfor , linenr_t ourscope , int ind_maxparen , int ind_maxcomment ) ;
static char_u *cin_skipcomment(char_u *s ) 
{ 
  size_t tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    s = skipwhite(s);
    }
    if ((int )*s != 47) {
      goto while_break;
    }
    s ++;
    if ((int )*s == 47) {
      {
      tmp = strlen((char const   *)((char *)s));
      s += tmp;
      }
      goto while_break;
    }
    if ((int )*s != 42) {
      goto while_break;
    }
    s ++;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *s) {
        goto while_break___0;
      }
      if ((int )*(s + 0) == 42) {
        if ((int )*(s + 1) == 47) {
          s += 2;
          goto while_break___0;
        }
      }
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (s);
}
}
static int cin_nocode(char_u *s ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = cin_skipcomment(s);
  }
  return ((int )*tmp == 0);
}
}
static int cin_islabel_skip(char_u **s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = vim_isIDc((int )*(*s));
  }
  if (! tmp) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = vim_isIDc((int )*(*s));
    }
    if (! tmp___0) {
      goto while_break;
    }
    (*s) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *s = cin_skipcomment(*s);
  }
  if ((int )*(*s) == 58) {
    (*s) ++;
    if ((int )*(*s) != 58) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
int cin_islabel(int ind_maxcomment ) 
{ 
  char_u *s ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FPOS cursor_save ;
  FPOS *trypos ;
  char_u *line ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
  tmp = ml_get_curline();
  s = cin_skipcomment(tmp);
  tmp___0 = cin_isdefault(s);
  }
  if (tmp___0) {
    return (0);
  }
  {
  tmp___1 = cin_isscopedecl(s);
  }
  if (tmp___1) {
    return (0);
  }
  {
  tmp___8 = cin_islabel_skip(& s);
  }
  if (tmp___8) {
    cursor_save = curwin->w_cursor;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (curwin->w_cursor.lnum > 1L)) {
        goto while_break;
      }
      {
      (curwin->w_cursor.lnum) --;
      curwin->w_cursor.col = (colnr_t )0;
      trypos = find_start_comment(ind_maxcomment);
      }
      if ((unsigned long )trypos != (unsigned long )((void *)0)) {
        curwin->w_cursor = *trypos;
      }
      {
      line = ml_get_curline();
      tmp___2 = cin_ispreproc(line);
      }
      if (tmp___2) {
        goto while_continue;
      }
      {
      line = cin_skipcomment(line);
      }
      if ((int )*line == 0) {
        goto while_continue;
      }
      {
      curwin->w_cursor = cursor_save;
      tmp___3 = cin_isterminated(line, 1);
      }
      if (tmp___3) {
        return (1);
      } else {
        {
        tmp___4 = cin_isscopedecl(line);
        }
        if (tmp___4) {
          return (1);
        } else {
          {
          tmp___5 = cin_iscase(line);
          }
          if (tmp___5) {
            return (1);
          } else {
            {
            tmp___6 = cin_islabel_skip(& line);
            }
            if (tmp___6) {
              {
              tmp___7 = cin_nocode(line);
              }
              if (tmp___7) {
                return (1);
              }
            }
          }
        }
      }
      return (0);
    }
    while_break: /* CIL Label */ ;
    }
    curwin->w_cursor = cursor_save;
    return (1);
  }
  return (0);
}
}
int cin_iscase(char_u *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  s = cin_skipcomment(s);
  tmp = strncmp((char const   *)((char *)s), (char const   *)((char *)"case"), (size_t )4);
  }
  if (tmp == 0) {
    {
    tmp___0 = vim_isIDc((int )*(s + 4));
    }
    if (! tmp___0) {
      s += 4;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! *s) {
          goto while_break;
        }
        {
        s = cin_skipcomment(s);
        }
        if ((int )*s == 58) {
          if ((int )*(s + 1) == 58) {
            s ++;
          } else {
            return (1);
          }
        }
        if ((int )*s == 39) {
          if (*(s + 1)) {
            if ((int )*(s + 2) == 39) {
              s += 2;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if ((int )*s == 47) {
          if ((int )*(s + 1) == 42) {
            return (0);
          } else { //Added block
          if ((int )*(s + 1) == 47) {
            return (0);
          } else {
            goto _L;
          }
          }
        } else { //Added block
        _L: 
        if ((int )*s == 34) {
          return (0);
        }
        }
        }
        s ++;
      }
      while_break: /* CIL Label */ ;
      }
      return (0);
    }
  }
  {
  tmp___1 = cin_isdefault(s);
  }
  if (tmp___1) {
    return (1);
  }
  return (0);
}
}
static int cin_isdefault(char_u *s ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = strncmp((char const   *)((char *)s), (char const   *)((char *)"default"),
                (size_t )7);
  }
  if (tmp == 0) {
    {
    s = cin_skipcomment(s + 7);
    }
    if ((int )*s == 58) {
      if ((int )*(s + 1) != 58) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int cin_isscopedecl(char_u *s ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  s = cin_skipcomment(s);
  tmp___1 = strncmp((char const   *)((char *)s), (char const   *)((char *)"public"),
                    (size_t )6);
  }
  if (tmp___1 == 0) {
    i___0 = 6;
  } else {
    {
    tmp___0 = strncmp((char const   *)((char *)s), (char const   *)((char *)"protected"),
                      (size_t )9);
    }
    if (tmp___0 == 0) {
      i___0 = 9;
    } else {
      {
      tmp = strncmp((char const   *)((char *)s), (char const   *)((char *)"private"),
                    (size_t )7);
      }
      if (tmp == 0) {
        i___0 = 7;
      } else {
        return (0);
      }
    }
  }
  {
  s = cin_skipcomment(s + i___0);
  }
  if ((int )*s == 58) {
    if ((int )*(s + 1) != 58) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
static char_u *after_label(char_u *l ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *l) {
      goto while_break;
    }
    if ((int )*l == 58) {
      if ((int )*(l + 1) == 58) {
        l ++;
      } else {
        {
        tmp = cin_iscase(l + 1);
        }
        if (! tmp) {
          goto while_break;
        }
      }
    } else { //Added block
    if ((int )*l == 39) {
      if (*(l + 1)) {
        if ((int )*(l + 2) == 39) {
          l += 2;
        }
      }
    }
    }
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*l == 0) {
    return ((char_u *)((void *)0));
  }
  {
  l = cin_skipcomment(l + 1);
  }
  if ((int )*l == 0) {
    return ((char_u *)((void *)0));
  }
  return (l);
}
}
static int get_indent_nolabel(linenr_t lnum ) 
{ 
  char_u *l ;
  FPOS fp___0 ;
  colnr_t col ;
  char_u *p___0 ;

  {
  {
  l = ml_get(lnum);
  p___0 = after_label(l);
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  fp___0.col = (colnr_t )(p___0 - l);
  fp___0.lnum = lnum;
  getvcol(curwin, & fp___0, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
  }
  return ((int )col);
}
}
static int skip_label(linenr_t lnum , char_u **pp , int ind_maxcomment ) 
{ 
  char_u *l ;
  int amount ;
  FPOS cursor_save ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  cursor_save = curwin->w_cursor;
  curwin->w_cursor.lnum = lnum;
  l = ml_get_curline();
  tmp___0 = cin_iscase(l);
  }
  if (tmp___0) {
    goto _L;
  } else {
    {
    tmp___1 = cin_isscopedecl(l);
    }
    if (tmp___1) {
      goto _L;
    } else {
      {
      tmp___2 = cin_islabel(ind_maxcomment);
      }
      if (tmp___2) {
        _L: 
        {
        amount = get_indent_nolabel(lnum);
        tmp = ml_get_curline();
        l = after_label(tmp);
        }
        if ((unsigned long )l == (unsigned long )((void *)0)) {
          {
          l = ml_get_curline();
          }
        }
      } else {
        {
        amount = get_indent();
        l = ml_get_curline();
        }
      }
    }
  }
  *pp = l;
  curwin->w_cursor = cursor_save;
  return (amount);
}
}
static int cin_ispreproc(char_u *s ) 
{ 


  {
  {
  s = skipwhite(s);
  }
  if ((int )*s == 35) {
    return (1);
  }
  return (0);
}
}
static int cin_iscomment(char_u *p___0 ) 
{ 
  int tmp ;

  {
  if ((int )*(p___0 + 0) == 47) {
    if ((int )*(p___0 + 1) == 42) {
      tmp = 1;
    } else { //Added block
    if ((int )*(p___0 + 1) == 47) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int cin_isterminated(char_u *s , int incl_open ) 
{ 
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  {
  s = cin_skipcomment(s);
  }
  if ((int )*s == 123) {
    return (1);
  } else { //Added block
  if ((int )*s == 125) {
    {
    tmp = cin_iselse(s);
    }
    if (! tmp) {
      return (1);
    }
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp___0 = cin_skipcomment(s);
    s = skip_string(tmp___0);
    }
    if ((int )*s == 59) {
      goto _L;
    } else { //Added block
    if (incl_open) {
      if ((int )*s == 123) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((int )*s == 125) {
      goto _L;
    } else { //Added block
    if ((int )*s == 44) {
      _L: 
      {
      tmp___1 = cin_nocode(s + 1);
      }
      if (tmp___1) {
        return (1);
      }
    }
    }
    }
    }
    if (*s) {
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int cin_isfuncdecl(char_u *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*s) {
      if ((int )*s != 40) {
        if ((int )*s != 59) {
          if ((int )*s != 39) {
            if (! ((int )*s != 34)) {
              goto while_break;
            }
          } else {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = cin_iscomment(s);
    }
    if (tmp) {
      {
      s = cin_skipcomment(s);
      }
    } else {
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*s != 40) {
    return (0);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (*s) {
      if ((int )*s != 59) {
        if ((int )*s != 39) {
          if (! ((int )*s != 34)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    if ((int )*s == 41) {
      {
      tmp___0 = cin_nocode(s + 1);
      }
      if (tmp___0) {
        return (1);
      }
    }
    {
    tmp___1 = cin_iscomment(s);
    }
    if (tmp___1) {
      {
      s = cin_skipcomment(s);
      }
    } else {
      s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return (0);
}
}
static int cin_isif(char_u *p___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"if"), (size_t )2);
  }
  if (tmp == 0) {
    {
    tmp___0 = vim_isIDc((int )*(p___0 + 2));
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
static int cin_iselse(char_u *p___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )*p___0 == 125) {
    {
    p___0 = cin_skipcomment(p___0 + 1);
    }
  }
  {
  tmp = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"else"),
                (size_t )4);
  }
  if (tmp == 0) {
    {
    tmp___0 = vim_isIDc((int )*(p___0 + 4));
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
static int cin_isdo(char_u *p___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"do"), (size_t )2);
  }
  if (tmp == 0) {
    {
    tmp___0 = vim_isIDc((int )*(p___0 + 2));
    }
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
static int cin_iswhileofdo(char_u *p___0 , linenr_t lnum , int ind_maxparen ) 
{ 
  FPOS cursor_save ;
  FPOS *trypos ;
  int retval ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  retval = 0;
  p___0 = cin_skipcomment(p___0);
  }
  if ((int )*p___0 == 125) {
    {
    p___0 = cin_skipcomment(p___0 + 1);
    }
  }
  {
  tmp___1 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"while"),
                    (size_t )5);
  }
  if (tmp___1 == 0) {
    {
    tmp___2 = vim_isIDc((int )*(p___0 + 5));
    }
    if (! tmp___2) {
      {
      cursor_save = curwin->w_cursor;
      curwin->w_cursor.lnum = lnum;
      curwin->w_cursor.col = (colnr_t )0;
      p___0 = ml_get_curline();
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (*p___0) {
          if (! ((int )*p___0 != 119)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        p___0 ++;
        (curwin->w_cursor.col) ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
      trypos = findmatchlimit((OPARG *)((void *)0), 0, 0, ind_maxparen);
      }
      if ((unsigned long )trypos != (unsigned long )((void *)0)) {
        {
        tmp = ml_get_pos(trypos);
        tmp___0 = cin_skipcomment(tmp + 1);
        }
        if ((int )*tmp___0 == 59) {
          retval = 1;
        }
      }
      curwin->w_cursor = cursor_save;
    }
  }
  return (retval);
}
}
static int cin_skip2pos(FPOS *trypos ) 
{ 
  char_u *line ;
  char_u *p___0 ;
  int tmp ;

  {
  {
  line = ml_get(trypos->lnum);
  p___0 = line;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if (! ((colnr_t )(p___0 - line) < trypos->col)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp = cin_iscomment(p___0);
    }
    if (tmp) {
      {
      p___0 = cin_skipcomment(p___0);
      }
    } else {
      {
      p___0 = skip_string(p___0);
      p___0 ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return ((int )(p___0 - line));
}
}
static FPOS pos_copy___0  ;
static FPOS *find_start_brace(int ind_maxcomment ) 
{ 
  FPOS cursor_save ;
  FPOS *trypos ;
  FPOS *pos___0 ;
  int tmp ;

  {
  cursor_save = curwin->w_cursor;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    trypos = findmatchlimit((OPARG *)((void *)0), '{', 4, 0);
    }
    if (! ((unsigned long )trypos != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    pos_copy___0 = *trypos;
    trypos = & pos_copy___0;
    curwin->w_cursor = *trypos;
    pos___0 = (FPOS *)((void *)0);
    tmp = cin_skip2pos(trypos);
    }
    if ((colnr_t )tmp == trypos->col) {
      {
      pos___0 = find_start_comment(ind_maxcomment);
      }
      if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
        goto while_break;
      }
    }
    if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
      curwin->w_cursor.lnum = pos___0->lnum;
    }
  }
  while_break: /* CIL Label */ ;
  }
  curwin->w_cursor = cursor_save;
  return (trypos);
}
}
static FPOS pos_copy___1  ;
static FPOS *find_match_paren(int ind_maxparen , int ind_maxcomment ) 
{ 
  FPOS cursor_save ;
  FPOS *trypos ;
  FPOS *tmp ;
  int tmp___0 ;

  {
  {
  cursor_save = curwin->w_cursor;
  trypos = findmatchlimit((OPARG *)((void *)0), '(', 0, ind_maxparen);
  }
  if ((unsigned long )trypos != (unsigned long )((void *)0)) {
    {
    tmp___0 = cin_skip2pos(trypos);
    }
    if ((colnr_t )tmp___0 > trypos->col) {
      trypos = (FPOS *)((void *)0);
    } else {
      {
      pos_copy___1 = *trypos;
      trypos = & pos_copy___1;
      curwin->w_cursor = *trypos;
      tmp = find_start_comment(ind_maxcomment);
      }
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        trypos = (FPOS *)((void *)0);
      }
    }
  }
  curwin->w_cursor = cursor_save;
  return (trypos);
}
}
static int find_last_paren(char_u *l ) 
{ 
  int i___0 ;
  int retval ;
  char_u *tmp ;

  {
  retval = 0;
  curwin->w_cursor.col = (colnr_t )0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(l + i___0)) {
      goto while_break;
    }
    {
    tmp = skip_string(l + i___0);
    i___0 = (int )(tmp - l);
    }
    if ((int )*(l + i___0) == 41) {
      curwin->w_cursor.col = (colnr_t )i___0;
      retval = 1;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (retval);
}
}
int get_c_indent(void) 
{ 
  int ind_level ;
  int ind_open_imag ;
  int ind_no_brace ;
  int ind_first_open ;
  int ind_open_extra ;
  int ind_close_extra ;
  int ind_open_left_imag ;
  int ind_case ;
  int ind_case_code ;
  int ind_scopedecl ;
  int ind_scopedecl_code ;
  int ind_param ;
  int ind_func_type ;
  int ind_continuation ;
  int ind_unclosed ;
  int ind_unclosed2 ;
  int ind_in_comment ;
  int ind_maxparen ;
  int ind_maxcomment ;
  FPOS cur_curpos ;
  int amount ;
  int scope_amount ;
  int cur_amount ;
  colnr_t col ;
  char_u *theline ;
  char_u *linecopy ;
  FPOS *trypos ;
  FPOS our_paren_pos ;
  char_u *start___0 ;
  int start_brace ;
  linenr_t ourscope ;
  char_u *l ;
  char_u *look ;
  int lookfor ;
  int whilelevel ;
  linenr_t lnum ;
  char_u *options___0 ;
  int fraction ;
  int divider ;
  int n ;
  int iscase ;
  char_u *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned short const   **tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char_u *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char_u *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char_u *tmp___29 ;
  char_u *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char_u *tmp___35 ;
  int tmp___36 ;
  char_u *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char_u *tmp___42 ;
  char_u *tmp___43 ;
  int tmp___44 ;
  char_u *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  char_u *tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char_u *tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;

  {
  ind_level = (int )curbuf->b_p_sw;
  ind_open_imag = 0;
  ind_no_brace = 0;
  ind_first_open = 0;
  ind_open_extra = 0;
  ind_close_extra = 0;
  ind_open_left_imag = 0;
  ind_case = (int )curbuf->b_p_sw;
  ind_case_code = (int )curbuf->b_p_sw;
  ind_scopedecl = (int )curbuf->b_p_sw;
  ind_scopedecl_code = (int )curbuf->b_p_sw;
  ind_param = (int )curbuf->b_p_sw;
  ind_func_type = (int )curbuf->b_p_sw;
  ind_continuation = (int )curbuf->b_p_sw;
  ind_unclosed = (int )(curbuf->b_p_sw * 2L);
  ind_unclosed2 = (int )curbuf->b_p_sw;
  ind_in_comment = 3;
  ind_maxparen = 20;
  ind_maxcomment = 30;
  fraction = 0;
  options___0 = curbuf->b_p_cino;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *options___0) {
      goto while_break;
    }
    tmp = options___0;
    options___0 ++;
    l = tmp;
    if ((int )*options___0 == 45) {
      options___0 ++;
    }
    {
    tmp___0 = getdigits(& options___0);
    n = (int )tmp___0;
    divider = 0;
    }
    if ((int )*options___0 == 46) {
      {
      options___0 ++;
      tmp___1 = atol((char const   *)((char *)options___0));
      fraction = (int )tmp___1;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp___2 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___2 + (int )*options___0) & 2048)) {
          goto while_break___0;
        }
        options___0 ++;
        if (divider) {
          divider *= 10;
        } else {
          divider = 10;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    if ((int )*options___0 == 115) {
      if (n == 0) {
        if (fraction == 0) {
          n = (int )curbuf->b_p_sw;
        } else {
          goto _L;
        }
      } else {
        _L: 
        n = (int )((long )n * curbuf->b_p_sw);
        if (divider) {
          n = (int )((long )n + (curbuf->b_p_sw * (long )fraction + (long )(divider / 2)) / (long )divider);
        }
      }
      options___0 ++;
    }
    if ((int )*(l + 1) == 45) {
      n = - n;
    }
    {
    if ((int )*l == 62) {
      goto case_62;
    }
    if ((int )*l == 101) {
      goto case_101;
    }
    if ((int )*l == 110) {
      goto case_110;
    }
    if ((int )*l == 102) {
      goto case_102;
    }
    if ((int )*l == 123) {
      goto case_123;
    }
    if ((int )*l == 125) {
      goto case_125;
    }
    if ((int )*l == 94) {
      goto case_94;
    }
    if ((int )*l == 58) {
      goto case_58;
    }
    if ((int )*l == 61) {
      goto case_61;
    }
    if ((int )*l == 112) {
      goto case_112;
    }
    if ((int )*l == 116) {
      goto case_116;
    }
    if ((int )*l == 99) {
      goto case_99;
    }
    if ((int )*l == 43) {
      goto case_43;
    }
    if ((int )*l == 40) {
      goto case_40;
    }
    if ((int )*l == 117) {
      goto case_117;
    }
    if ((int )*l == 41) {
      goto case_41;
    }
    if ((int )*l == 42) {
      goto case_42;
    }
    if ((int )*l == 103) {
      goto case_103;
    }
    if ((int )*l == 104) {
      goto case_104;
    }
    goto switch_break;
    case_62: /* CIL Label */ 
    ind_level = n;
    goto switch_break;
    case_101: /* CIL Label */ 
    ind_open_imag = n;
    goto switch_break;
    case_110: /* CIL Label */ 
    ind_no_brace = n;
    goto switch_break;
    case_102: /* CIL Label */ 
    ind_first_open = n;
    goto switch_break;
    case_123: /* CIL Label */ 
    ind_open_extra = n;
    goto switch_break;
    case_125: /* CIL Label */ 
    ind_close_extra = n;
    goto switch_break;
    case_94: /* CIL Label */ 
    ind_open_left_imag = n;
    goto switch_break;
    case_58: /* CIL Label */ 
    ind_case = n;
    goto switch_break;
    case_61: /* CIL Label */ 
    ind_case_code = n;
    goto switch_break;
    case_112: /* CIL Label */ 
    ind_param = n;
    goto switch_break;
    case_116: /* CIL Label */ 
    ind_func_type = n;
    goto switch_break;
    case_99: /* CIL Label */ 
    ind_in_comment = n;
    goto switch_break;
    case_43: /* CIL Label */ 
    ind_continuation = n;
    goto switch_break;
    case_40: /* CIL Label */ 
    ind_unclosed = n;
    goto switch_break;
    case_117: /* CIL Label */ 
    ind_unclosed2 = n;
    goto switch_break;
    case_41: /* CIL Label */ 
    ind_maxparen = n;
    goto switch_break;
    case_42: /* CIL Label */ 
    ind_maxcomment = n;
    goto switch_break;
    case_103: /* CIL Label */ 
    ind_scopedecl = n;
    goto switch_break;
    case_104: /* CIL Label */ 
    ind_scopedecl_code = n;
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  cur_curpos = curwin->w_cursor;
  tmp___3 = ml_get(cur_curpos.lnum);
  linecopy = vim_strsave(tmp___3);
  }
  if ((unsigned long )linecopy == (unsigned long )((void *)0)) {
    return (0);
  }
  if (State & 16) {
    if ((int )*(linecopy + curwin->w_cursor.col) == 41) {
      *(linecopy + curwin->w_cursor.col) = (char_u )'\000';
    }
  }
  {
  theline = skipwhite(linecopy);
  curwin->w_cursor.col = (colnr_t )0;
  }
  if ((int )*theline == 35) {
    if ((int )*linecopy == 35) {
      amount = 0;
    } else {
      {
      tmp___58 = in_cinkeys('#', ' ', 1);
      }
      if (tmp___58) {
        amount = 0;
      } else {
        goto _L___8;
      }
    }
  } else {
    _L___8: 
    {
    tmp___57 = cin_islabel(ind_maxcomment);
    }
    if (tmp___57) {
      amount = 0;
    } else {
      {
      tmp___56 = cin_iscomment(theline);
      }
      if (tmp___56) {
        _L___7: 
        {
        trypos = find_match_paren(ind_maxparen, ind_maxcomment);
        }
        if ((unsigned long )trypos != (unsigned long )((void *)0)) {
          amount = -1;
          our_paren_pos = *trypos;
          if ((int )*(theline + 0) != 41) {
            lnum = cur_curpos.lnum - 1L;
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (! (lnum > our_paren_pos.lnum)) {
                goto while_break___1;
              }
              {
              tmp___6 = ml_get(lnum);
              l = skipwhite(tmp___6);
              tmp___7 = cin_nocode(l);
              }
              if (tmp___7) {
                goto __Cont___0;
              }
              {
              tmp___8 = cin_ispreproc(l);
              }
              if (tmp___8) {
                goto __Cont___0;
              }
              {
              curwin->w_cursor.lnum = lnum;
              trypos = find_start_comment(ind_maxcomment);
              }
              if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                lnum = trypos->lnum + 1L;
                goto __Cont___0;
              }
              {
              trypos = find_match_paren(ind_maxparen, ind_maxcomment);
              }
              if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                if (trypos->lnum == our_paren_pos.lnum) {
                  if (trypos->col == our_paren_pos.col) {
                    {
                    amount = get_indent_lnum(lnum);
                    }
                    goto while_break___1;
                  }
                }
              }
              __Cont___0: 
              lnum --;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
          if (amount == -1) {
            {
            amount = skip_label(our_paren_pos.lnum, & look, ind_maxcomment);
            }
            if ((int )*(theline + 0) == 41) {
              goto _L___0;
            } else { //Added block
            if (ind_unclosed == 0) {
              goto _L___0;
            } else {
              {
              tmp___10 = skipwhite(look);
              }
              if ((int )*tmp___10 == 40) {
                _L___0: 
                if ((int )*(theline + 0) != 41) {
                  {
                  col = our_paren_pos.col + 1U;
                  look = ml_get(our_paren_pos.lnum);
                  }
                  {
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
                    if (! ((int )*(look + col) == 32)) {
                      if (! ((int )*(look + col) == 9)) {
                        goto while_break___2;
                      }
                    }
                    col ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
                  if ((int )*(look + col) != 0) {
                    our_paren_pos.col = col;
                  } else {
                    (our_paren_pos.col) ++;
                  }
                }
                {
                getvcol(curwin, & our_paren_pos, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
                amount = (int )col;
                }
              } else {
                col = our_paren_pos.col;
                {
                while (1) {
                  while_continue___3: /* CIL Label */ ;
                  if (! (our_paren_pos.col > 0U)) {
                    goto while_break___3;
                  }
                  {
                  (our_paren_pos.col) --;
                  tmp___9 = ml_get_pos(& our_paren_pos);
                  }
                  {
                  if ((int )*tmp___9 == 40) {
                    goto case_40___0;
                  }
                  if ((int )*tmp___9 == 41) {
                    goto case_41___0;
                  }
                  goto switch_break___0;
                  case_40___0: /* CIL Label */ 
                  amount += ind_unclosed2;
                  col = our_paren_pos.col;
                  goto switch_break___0;
                  case_41___0: /* CIL Label */ 
                  amount -= ind_unclosed2;
                  col = (colnr_t )2147483647;
                  goto switch_break___0;
                  switch_break___0: /* CIL Label */ ;
                  }
                }
                while_break___3: /* CIL Label */ ;
                }
                if (col == 2147483647U) {
                  amount += ind_unclosed;
                } else {
                  {
                  curwin->w_cursor.lnum = our_paren_pos.lnum;
                  curwin->w_cursor.col = col;
                  trypos = find_match_paren(ind_maxparen, ind_maxcomment);
                  }
                  if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                    amount += ind_unclosed2;
                  } else {
                    amount += ind_unclosed;
                  }
                }
              }
            }
            }
          }
        } else {
          {
          trypos = find_start_brace(ind_maxcomment);
          }
          if ((unsigned long )trypos != (unsigned long )((void *)0)) {
            {
            ourscope = trypos->lnum;
            start___0 = ml_get(ourscope);
            look = skipwhite(start___0);
            }
            if ((int )*look == 123) {
              {
              getvcol(curwin, trypos, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
              amount = (int )col;
              }
              if ((int )*start___0 == 123) {
                start_brace = 1;
              } else {
                start_brace = 2;
              }
            } else {
              {
              curwin->w_cursor.lnum = ourscope;
              lnum = ourscope;
              tmp___11 = find_last_paren(start___0);
              }
              if (tmp___11) {
                {
                trypos = find_match_paren(ind_maxparen, ind_maxcomment);
                }
                if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                  lnum = trypos->lnum;
                }
              }
              {
              amount = skip_label(lnum, & l, ind_maxcomment);
              start_brace = 3;
              }
            }
            if ((int )*(theline + 0) == 125) {
              amount += ind_close_extra;
            } else {
              {
              lookfor = 0;
              tmp___13 = cin_iselse(theline);
              }
              if (tmp___13) {
                lookfor = 1;
              } else {
                {
                tmp___12 = cin_iswhileofdo(theline, cur_curpos.lnum, ind_maxparen);
                }
                if (tmp___12) {
                  lookfor = 2;
                }
              }
              if (lookfor) {
                {
                curwin->w_cursor.lnum = cur_curpos.lnum;
                tmp___14 = find_match(lookfor, ourscope, ind_maxparen, ind_maxcomment);
                }
                if (tmp___14 == 1) {
                  {
                  amount = get_indent();
                  }
                  goto theend;
                }
              }
              if (start_brace == 1) {
                amount = ind_open_left_imag;
              } else { //Added block
              if (start_brace == 3) {
                amount += ind_open_imag;
              } else {
                amount -= ind_open_extra;
                if (amount < 0) {
                  amount = 0;
                }
              }
              }
              {
              tmp___16 = cin_iscase(theline);
              }
              if (tmp___16) {
                lookfor = 3;
                amount += ind_case;
              } else {
                {
                tmp___15 = cin_isscopedecl(theline);
                }
                if (tmp___15) {
                  lookfor = 7;
                  amount += ind_scopedecl;
                } else {
                  lookfor = 4;
                  amount += ind_level;
                }
              }
              scope_amount = amount;
              whilelevel = 0;
              curwin->w_cursor = cur_curpos;
              {
              while (1) {
                while_continue___4: /* CIL Label */ ;
                (curwin->w_cursor.lnum) --;
                curwin->w_cursor.col = (colnr_t )0;
                if (curwin->w_cursor.lnum <= ourscope) {
                  if (lookfor == 6) {
                    amount += ind_continuation;
                  } else { //Added block
                  if (lookfor != 5) {
                    amount = scope_amount;
                    if ((int )*(theline + 0) == 123) {
                      amount += ind_open_extra;
                    }
                  }
                  }
                  goto while_break___4;
                }
                {
                trypos = find_start_comment(ind_maxcomment);
                }
                if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                  curwin->w_cursor.lnum = trypos->lnum + 1L;
                  goto __Cont___1;
                }
                {
                l = ml_get_curline();
                iscase = cin_iscase(l);
                }
                if (iscase) {
                  goto _L___3;
                } else {
                  {
                  tmp___21 = cin_isscopedecl(l);
                  }
                  if (tmp___21) {
                    _L___3: 
                    if (lookfor == 6) {
                      amount += ind_continuation;
                      goto while_break___4;
                    }
                    if (iscase) {
                      if (lookfor == 3) {
                        goto _L___1;
                      } else {
                        goto _L___2;
                      }
                    } else { //Added block
                    _L___2: 
                    if (! iscase) {
                      if (lookfor == 7) {
                        _L___1: 
                        {
                        trypos = find_start_brace(ind_maxcomment);
                        }
                        if ((unsigned long )trypos == (unsigned long )((void *)0)) {
                          {
                          amount = get_indent();
                          }
                          goto while_break___4;
                        } else { //Added block
                        if (trypos->lnum == ourscope) {
                          {
                          amount = get_indent();
                          }
                          goto while_break___4;
                        }
                        }
                        goto __Cont___1;
                      }
                    }
                    }
                    {
                    n = get_indent_nolabel(curwin->w_cursor.lnum);
                    }
                    if (lookfor == 5) {
                      if (n) {
                        amount = n;
                      }
                      goto while_break___4;
                    }
                    if (n) {
                      {
                      amount = n;
                      tmp___17 = ml_get_curline();
                      l = after_label(tmp___17);
                      }
                      if ((unsigned long )l != (unsigned long )((void *)0)) {
                        {
                        tmp___18 = cin_is_cinword(l);
                        }
                        if (tmp___18) {
                          amount += ind_level + ind_no_brace;
                        }
                      }
                      goto while_break___4;
                    }
                    {
                    tmp___19 = get_indent();
                    }
                    if (iscase) {
                      tmp___20 = ind_case_code;
                    } else {
                      tmp___20 = ind_scopedecl_code;
                    }
                    scope_amount = tmp___19 + tmp___20;
                    lookfor = 4;
                    goto __Cont___1;
                  }
                }
                if (lookfor == 3) {
                  goto __Cont___1;
                } else { //Added block
                if (lookfor == 7) {
                  goto __Cont___1;
                }
                }
                {
                tmp___24 = cin_islabel(ind_maxcomment);
                }
                if (tmp___24) {
                  {
                  tmp___22 = ml_get_curline();
                  l = after_label(tmp___22);
                  }
                  if ((unsigned long )l == (unsigned long )((void *)0)) {
                    goto __Cont___1;
                  } else {
                    {
                    tmp___23 = cin_nocode(l);
                    }
                    if (tmp___23) {
                      goto __Cont___1;
                    }
                  }
                }
                {
                l = ml_get_curline();
                tmp___25 = cin_ispreproc(l);
                }
                if (tmp___25) {
                  goto __Cont___1;
                } else {
                  {
                  tmp___26 = cin_nocode(l);
                  }
                  if (tmp___26) {
                    goto __Cont___1;
                  }
                }
                {
                tmp___47 = cin_isterminated(l, 0);
                }
                if (tmp___47) {
                  {
                  tmp___46 = cin_iswhileofdo(l, curwin->w_cursor.lnum, ind_maxparen);
                  }
                  if (tmp___46) {
                    if (lookfor == 6) {
                      amount += ind_continuation;
                      goto while_break___4;
                    }
                    if (whilelevel == 0) {
                      {
                      lookfor = 5;
                      amount = get_indent();
                      }
                      if ((int )*(theline + 0) == 123) {
                        amount += ind_open_extra;
                      }
                    }
                    whilelevel ++;
                  } else {
                    if (whilelevel > 0) {
                      {
                      tmp___37 = ml_get_curline();
                      l = cin_skipcomment(tmp___37);
                      tmp___38 = cin_isdo(l);
                      }
                      if (tmp___38) {
                        {
                        amount = get_indent();
                        whilelevel --;
                        }
                        goto __Cont___1;
                      }
                    }
                    if (lookfor == 6) {
                      amount += ind_continuation;
                      goto while_break___4;
                    }
                    if (lookfor == 5) {
                      if (whilelevel == 0) {
                        goto while_break___4;
                      }
                    } else {
                      term_again: 
                      {
                      l = ml_get_curline();
                      tmp___41 = find_last_paren(l);
                      }
                      if (tmp___41) {
                        {
                        trypos = find_match_paren(ind_maxparen, ind_maxcomment);
                        }
                        if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                          {
                          curwin->w_cursor.lnum = trypos->lnum;
                          l = ml_get_curline();
                          tmp___39 = cin_iscase(l);
                          }
                          if (tmp___39) {
                            (curwin->w_cursor.lnum) ++;
                            goto __Cont___1;
                          } else {
                            {
                            tmp___40 = cin_isscopedecl(l);
                            }
                            if (tmp___40) {
                              (curwin->w_cursor.lnum) ++;
                              goto __Cont___1;
                            }
                          }
                        }
                      }
                      {
                      amount = skip_label(curwin->w_cursor.lnum, & l, ind_maxcomment);
                      }
                      if ((int )*(theline + 0) == 123) {
                        amount += ind_open_extra;
                      }
                      {
                      tmp___42 = skipwhite(l);
                      }
                      if ((int )*tmp___42 == 123) {
                        amount -= ind_open_extra;
                      }
                      {
                      lookfor = 5;
                      curwin->w_cursor.col = (colnr_t )0;
                      tmp___45 = cin_skipcomment(l);
                      }
                      if ((int )*tmp___45 == 125) {
                        {
                        trypos = find_start_brace(ind_maxcomment);
                        }
                        if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                          {
                          curwin->w_cursor.lnum = trypos->lnum;
                          tmp___43 = ml_get_curline();
                          l = cin_skipcomment(tmp___43);
                          }
                          if ((int )*l == 125) {
                            goto term_again;
                          } else {
                            {
                            tmp___44 = cin_iselse(l);
                            }
                            if (! tmp___44) {
                              goto term_again;
                            }
                          }
                          (curwin->w_cursor.lnum) ++;
                        }
                      }
                    }
                  }
                } else {
                  {
                  find_last_paren(l);
                  trypos = find_match_paren(ind_maxparen, ind_maxcomment);
                  }
                  if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                    {
                    curwin->w_cursor.lnum = trypos->lnum;
                    l = ml_get_curline();
                    tmp___27 = cin_iscase(l);
                    }
                    if (tmp___27) {
                      (curwin->w_cursor.lnum) ++;
                      goto __Cont___1;
                    } else {
                      {
                      tmp___28 = cin_isscopedecl(l);
                      }
                      if (tmp___28) {
                        (curwin->w_cursor.lnum) ++;
                        goto __Cont___1;
                      }
                    }
                  }
                  {
                  cur_amount = skip_label(curwin->w_cursor.lnum, & l, ind_maxcomment);
                  }
                  if (lookfor != 5) {
                    if ((int )*(theline + 0) == 123) {
                      {
                      amount = cur_amount;
                      tmp___29 = skipwhite(l);
                      }
                      if ((int )*tmp___29 != 123) {
                        amount += ind_open_extra;
                      }
                      goto while_break___4;
                    }
                  }
                  {
                  tmp___34 = cin_is_cinword(l);
                  }
                  if (tmp___34) {
                    goto _L___4;
                  } else {
                    {
                    tmp___35 = skipwhite(l);
                    tmp___36 = cin_iselse(tmp___35);
                    }
                    if (tmp___36) {
                      _L___4: 
                      if (lookfor == 6) {
                        amount += ind_continuation;
                        goto while_break___4;
                      }
                      amount = cur_amount;
                      if ((int )*(theline + 0) == 123) {
                        amount += ind_open_extra;
                      }
                      if (lookfor != 5) {
                        amount += ind_level + ind_no_brace;
                        goto while_break___4;
                      }
                      {
                      tmp___30 = ml_get_curline();
                      l = skipwhite(tmp___30);
                      tmp___31 = cin_isdo(l);
                      }
                      if (tmp___31) {
                        if (whilelevel == 0) {
                          goto while_break___4;
                        }
                        whilelevel --;
                      }
                      {
                      tmp___32 = cin_iselse(l);
                      }
                      if (tmp___32) {
                        {
                        trypos = find_start_brace(ind_maxcomment);
                        }
                        if ((unsigned long )trypos == (unsigned long )((void *)0)) {
                          goto while_break___4;
                        } else {
                          {
                          tmp___33 = find_match(1, trypos->lnum, ind_maxparen, ind_maxcomment);
                          }
                          if (tmp___33 == 0) {
                            goto while_break___4;
                          }
                        }
                      }
                    } else {
                      if (lookfor == 6) {
                        goto while_break___4;
                      }
                      amount = cur_amount;
                      if (lookfor != 5) {
                        lookfor = 6;
                      }
                    }
                  }
                }
                __Cont___1: ;
              }
              while_break___4: /* CIL Label */ ;
              }
            }
          } else { //Added block
          if ((int )*(theline + 0) == 123) {
            amount = ind_first_open;
          } else { //Added block
          if (cur_curpos.lnum < curbuf->b_ml.ml_line_count) {
            {
            tmp___53 = cin_nocode(theline);
            }
            if (tmp___53) {
              goto _L___6;
            } else {
              {
              tmp___54 = ml_get(cur_curpos.lnum + 1L);
              tmp___55 = cin_isfuncdecl(tmp___54);
              }
              if (tmp___55) {
                amount = ind_func_type;
              } else {
                goto _L___6;
              }
            }
          } else {
            _L___6: 
            amount = 0;
            curwin->w_cursor = cur_curpos;
            {
            while (1) {
              while_continue___5: /* CIL Label */ ;
              if (! (curwin->w_cursor.lnum > 1L)) {
                goto while_break___5;
              }
              {
              (curwin->w_cursor.lnum) --;
              curwin->w_cursor.col = (colnr_t )0;
              l = ml_get_curline();
              trypos = find_start_comment(ind_maxcomment);
              }
              if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                curwin->w_cursor.lnum = trypos->lnum + 1L;
                goto while_continue___5;
              }
              {
              tmp___48 = cin_isfuncdecl(theline);
              }
              if (tmp___48) {
                goto while_break___5;
              }
              {
              tmp___49 = skipwhite(l);
              }
              if ((int )*tmp___49 == 125) {
                goto while_break___5;
              }
              {
              tmp___50 = cin_ispreproc(l);
              }
              if (tmp___50) {
                goto while_continue___5;
              }
              {
              tmp___51 = cin_nocode(l);
              }
              if (tmp___51) {
                goto while_continue___5;
              }
              {
              tmp___52 = cin_isfuncdecl(l);
              }
              if (tmp___52) {
                amount = ind_param;
                goto while_break___5;
              }
              {
              find_last_paren(l);
              trypos = find_match_paren(ind_maxparen, ind_maxcomment);
              }
              if ((unsigned long )trypos != (unsigned long )((void *)0)) {
                curwin->w_cursor.lnum = trypos->lnum;
              }
              {
              amount = get_indent();
              }
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
          }
          }
        }
      } else {
        {
        trypos = find_start_comment(ind_maxcomment);
        }
        if ((unsigned long )trypos != (unsigned long )((void *)0)) {
          {
          getvcol(curwin, trypos, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
          amount = (int )col;
          }
          if ((int )*(theline + 0) == 42) {
            amount ++;
          } else {
            amount = -1;
            lnum = cur_curpos.lnum - 1L;
            {
            while (1) {
              while_continue___6: /* CIL Label */ ;
              if (! (lnum > trypos->lnum)) {
                goto while_break___6;
              }
              {
              tmp___4 = linewhite(lnum);
              }
              if (tmp___4) {
                goto __Cont;
              }
              {
              amount = get_indent_lnum(lnum);
              }
              goto while_break___6;
              __Cont: 
              lnum --;
            }
            while_break___6: /* CIL Label */ ;
            }
            if (amount == -1) {
              {
              start___0 = ml_get(trypos->lnum);
              look = (start___0 + trypos->col) + 2;
              }
              if (*look) {
                {
                tmp___5 = skipwhite(look);
                trypos->col = (colnr_t )(tmp___5 - start___0);
                }
              }
              {
              getvcol(curwin, trypos, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
              amount = (int )col;
              }
              if (! *look) {
                amount += ind_in_comment;
              }
            }
          }
        } else {
          goto _L___7;
        }
      }
    }
  }
  theend: 
  {
  curwin->w_cursor = cur_curpos;
  vim_free((void *)linecopy);
  }
  if (amount < 0) {
    return (0);
  }
  return (amount);
}
}
static int find_match(int lookfor , linenr_t ourscope , int ind_maxparen , int ind_maxcomment ) 
{ 
  char_u *look ;
  FPOS *theirscope ;
  char_u *mightbeif ;
  int elselevel ;
  int whilelevel ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  if (lookfor == 1) {
    elselevel = 1;
    whilelevel = 0;
  } else {
    elselevel = 0;
    whilelevel = 1;
  }
  curwin->w_cursor.col = (colnr_t )0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (curwin->w_cursor.lnum > ourscope + 1L)) {
      goto while_break;
    }
    {
    (curwin->w_cursor.lnum) --;
    curwin->w_cursor.col = (colnr_t )0;
    tmp = ml_get_curline();
    look = cin_skipcomment(tmp);
    tmp___7 = cin_iselse(look);
    }
    if (tmp___7) {
      goto _L;
    } else {
      {
      tmp___8 = cin_isif(look);
      }
      if (tmp___8) {
        goto _L;
      } else {
        {
        tmp___9 = cin_isdo(look);
        }
        if (tmp___9) {
          goto _L;
        } else {
          {
          tmp___10 = cin_iswhileofdo(look, curwin->w_cursor.lnum, ind_maxparen);
          }
          if (tmp___10) {
            _L: 
            {
            theirscope = find_start_brace(ind_maxcomment);
            }
            if ((unsigned long )theirscope == (unsigned long )((void *)0)) {
              goto while_break;
            }
            if (theirscope->lnum < ourscope) {
              goto while_break;
            }
            if (theirscope->lnum > ourscope) {
              goto while_continue;
            }
            {
            tmp___0 = ml_get_curline();
            look = cin_skipcomment(tmp___0);
            tmp___2 = cin_iselse(look);
            }
            if (tmp___2) {
              {
              mightbeif = cin_skipcomment(look + 4);
              tmp___1 = cin_isif(mightbeif);
              }
              if (! tmp___1) {
                elselevel ++;
              }
              goto while_continue;
            }
            {
            tmp___3 = cin_iswhileofdo(look, curwin->w_cursor.lnum, ind_maxparen);
            }
            if (tmp___3) {
              whilelevel ++;
              goto while_continue;
            }
            {
            tmp___4 = ml_get_curline();
            look = cin_skipcomment(tmp___4);
            tmp___5 = cin_isif(look);
            }
            if (tmp___5) {
              elselevel --;
              if (elselevel == 0) {
                if (lookfor == 1) {
                  whilelevel = 0;
                }
              }
            }
            {
            tmp___6 = cin_isdo(look);
            }
            if (tmp___6) {
              whilelevel --;
            }
            if (elselevel <= 0) {
              if (whilelevel <= 0) {
                return (1);
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int get_lisp_indent(void) 
{ 
  FPOS *pos___0 ;
  FPOS realpos ;
  int amount ;
  char_u *that ;
  colnr_t col ;
  colnr_t firsttry ;
  int parencount ;
  int quotecount ;
  int vi_lisp ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  {
  tmp = vim_strchr(p_cpo, 'p');
  vi_lisp = (unsigned long )tmp != (unsigned long )((void *)0);
  realpos = curwin->w_cursor;
  curwin->w_cursor.col = (colnr_t )0;
  pos___0 = findmatch((OPARG *)((void *)0), '(');
  }
  if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
    amount = -1;
    parencount = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      (curwin->w_cursor.lnum) --;
      if (! (curwin->w_cursor.lnum >= pos___0->lnum)) {
        goto while_break;
      }
      {
      tmp___0 = linewhite(curwin->w_cursor.lnum);
      }
      if (tmp___0) {
        goto while_continue;
      }
      {
      that = ml_get_curline();
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((int )*that != 0)) {
          goto while_break___0;
        }
        if ((int )*that == 59) {
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! ((int )*(that + 1) != 0)) {
              goto while_break___1;
            }
            that ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          goto __Cont;
        }
        if ((int )*that == 92) {
          if ((int )*(that + 1) != 0) {
            that ++;
          }
          goto __Cont;
        }
        if ((int )*that == 34) {
          if ((int )*(that + 1) != 0) {
            that ++;
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              if (*that) {
                if (! ((int )*that != 34)) {
                  if (! ((int )*(that - 1) == 92)) {
                    goto while_break___2;
                  }
                }
              } else {
                goto while_break___2;
              }
              that ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        if ((int )*that == 40) {
          parencount ++;
        } else { //Added block
        if ((int )*that == 41) {
          parencount --;
        }
        }
        __Cont: 
        that ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (parencount == 0) {
        {
        amount = get_indent();
        }
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (amount == -1) {
      {
      curwin->w_cursor.lnum = pos___0->lnum;
      curwin->w_cursor.col = pos___0->col;
      col = pos___0->col;
      that = ml_get_curline();
      }
      if (vi_lisp) {
        {
        tmp___22 = get_indent();
        }
        if (tmp___22 == 0) {
          amount = 2;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: 
        amount = 0;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (*that) {
            if (! col) {
              goto while_break___3;
            }
          } else {
            goto while_break___3;
          }
          {
          tmp___1 = lbr_chartabsize(that, (colnr_t )amount);
          amount += tmp___1;
          col --;
          that ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        if (! vi_lisp) {
          if ((int )*that == 40) {
            {
            tmp___6 = strncmp((char const   *)((char *)(that + 1)), (char const   *)((char *)"defun "),
                              (size_t )6);
            }
            if (tmp___6) {
              {
              tmp___7 = strncmp((char const   *)((char *)(that + 1)), (char const   *)((char *)"define "),
                                (size_t )7);
              }
              if (tmp___7) {
                {
                tmp___8 = strncmp((char const   *)((char *)(that + 1)), (char const   *)((char *)"defmacro "),
                                  (size_t )9);
                }
                if (tmp___8) {
                  {
                  tmp___9 = strncmp((char const   *)((char *)(that + 1)), (char const   *)((char *)"set! "),
                                    (size_t )5);
                  }
                  if (tmp___9) {
                    {
                    tmp___10 = strncmp((char const   *)((char *)(that + 1)), (char const   *)((char *)"lambda "),
                                       (size_t )7);
                    }
                    if (tmp___10) {
                      {
                      tmp___11 = strncmp((char const   *)((char *)(that + 1)), (char const   *)((char *)"if "),
                                         (size_t )3);
                      }
                      if (tmp___11) {
                        {
                        tmp___12 = strncmp((char const   *)((char *)(that + 1)), (char const   *)((char *)"case "),
                                           (size_t )5);
                        }
                        if (tmp___12) {
                          {
                          tmp___13 = strncmp((char const   *)((char *)(that + 1)),
                                             (char const   *)((char *)"let "), (size_t )4);
                          }
                          if (tmp___13) {
                            {
                            tmp___14 = strncmp((char const   *)((char *)(that + 1)),
                                               (char const   *)((char *)"flet "),
                                               (size_t )5);
                            }
                            if (tmp___14) {
                              {
                              tmp___15 = strncmp((char const   *)((char *)(that + 1)),
                                                 (char const   *)((char *)"let* "),
                                                 (size_t )5);
                              }
                              if (tmp___15) {
                                {
                                tmp___16 = strncmp((char const   *)((char *)(that + 1)),
                                                   (char const   *)((char *)"letrec "),
                                                   (size_t )7);
                                }
                                if (tmp___16) {
                                  {
                                  tmp___17 = strncmp((char const   *)((char *)(that + 1)),
                                                     (char const   *)((char *)"do "),
                                                     (size_t )3);
                                  }
                                  if (tmp___17) {
                                    {
                                    tmp___18 = strncmp((char const   *)((char *)(that + 1)),
                                                       (char const   *)((char *)"do* "),
                                                       (size_t )4);
                                    }
                                    if (tmp___18) {
                                      {
                                      tmp___19 = strncmp((char const   *)((char *)(that + 1)),
                                                         (char const   *)((char *)"define-syntax "),
                                                         (size_t )14);
                                      }
                                      if (tmp___19) {
                                        {
                                        tmp___20 = strncmp((char const   *)((char *)(that + 1)),
                                                           (char const   *)((char *)"let-syntax "),
                                                           (size_t )11);
                                        }
                                        if (tmp___20) {
                                          {
                                          tmp___21 = strncmp((char const   *)((char *)(that + 1)),
                                                             (char const   *)((char *)"letrec-syntax "),
                                                             (size_t )14);
                                          }
                                          if (tmp___21) {
                                            goto _L___4;
                                          } else {
                                            amount += 2;
                                          }
                                        } else {
                                          amount += 2;
                                        }
                                      } else {
                                        amount += 2;
                                      }
                                    } else {
                                      amount += 2;
                                    }
                                  } else {
                                    amount += 2;
                                  }
                                } else {
                                  amount += 2;
                                }
                              } else {
                                amount += 2;
                              }
                            } else {
                              amount += 2;
                            }
                          } else {
                            amount += 2;
                          }
                        } else {
                          amount += 2;
                        }
                      } else {
                        amount += 2;
                      }
                    } else {
                      amount += 2;
                    }
                  } else {
                    amount += 2;
                  }
                } else {
                  amount += 2;
                }
              } else {
                amount += 2;
              }
            } else {
              amount += 2;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          that ++;
          amount ++;
          firsttry = (colnr_t )amount;
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (! ((int )*that == 32)) {
              if (! ((int )*that == 9)) {
                goto while_break___4;
              }
            }
            {
            tmp___2 = lbr_chartabsize(that, (colnr_t )amount);
            amount += tmp___2;
            that ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          if (*that) {
            if ((int )*that != 59) {
              if (! vi_lisp) {
                if ((int )*that != 40) {
                  firsttry ++;
                }
              }
              parencount = 0;
              quotecount = 0;
              if (vi_lisp) {
                goto _L___2;
              } else { //Added block
              if ((int )*that != 34) {
                if ((int )*that != 39) {
                  if ((int )*that != 35) {
                    if ((int )*that < 48) {
                      goto _L___2;
                    } else { //Added block
                    if ((int )*that > 57) {
                      _L___2: 
                      {
                      while (1) {
                        while_continue___5: /* CIL Label */ ;
                        if (*that) {
                          if ((int )*that == 32) {
                            goto _L___0;
                          } else { //Added block
                          if ((int )*that == 9) {
                            _L___0: 
                            if (quotecount) {
                              goto _L;
                            } else { //Added block
                            if (parencount) {
                              _L: 
                              if ((int )*that == 40) {
                                if (! quotecount) {
                                  if (! parencount) {
                                    if (vi_lisp) {
                                      goto while_break___5;
                                    }
                                  }
                                }
                              }
                            } else {
                              goto while_break___5;
                            }
                            }
                          } else {
                            goto _L;
                          }
                          }
                        } else {
                          goto while_break___5;
                        }
                        if ((int )*that == 34) {
                          quotecount = ! quotecount;
                        }
                        if ((int )*that == 40) {
                          if (! quotecount) {
                            parencount ++;
                          }
                        }
                        if ((int )*that == 41) {
                          if (! quotecount) {
                            parencount --;
                          }
                        }
                        if ((int )*that == 92) {
                          if ((int )*(that + 1) != 0) {
                            {
                            tmp___3 = lbr_chartabsize(that, (colnr_t )amount);
                            amount += tmp___3;
                            that ++;
                            }
                          }
                        }
                        {
                        tmp___4 = lbr_chartabsize(that, (colnr_t )amount);
                        amount += tmp___4;
                        that ++;
                        }
                      }
                      while_break___5: /* CIL Label */ ;
                      }
                    }
                    }
                  }
                }
              }
              }
              {
              while (1) {
                while_continue___6: /* CIL Label */ ;
                if (! ((int )*that == 32)) {
                  if (! ((int )*that == 9)) {
                    goto while_break___6;
                  }
                }
                {
                tmp___5 = lbr_chartabsize(that, (colnr_t )amount);
                amount += tmp___5;
                that ++;
                }
              }
              while_break___6: /* CIL Label */ ;
              }
              if (! *that) {
                amount = (int )firsttry;
              } else { //Added block
              if ((int )*that == 59) {
                amount = (int )firsttry;
              }
              }
            }
          }
        }
      }
    }
  } else {
    amount = 0;
  }
  curwin->w_cursor = realpos;
  return (amount);
}
}
void preserve_exit(void) 
{ 
  BUF *buf___3 ;

  {
  {
  windgoto((int )Rows - 1, 0);
  settmode(0);
  stoptermcap();
  out_flush();
  out_str(IObuff);
  screen_start();
  out_flush();
  ml_close_notmod();
  buf___3 = firstbuf;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )buf___3->b_ml.ml_mfp != (unsigned long )((void *)0)) {
      if ((unsigned long )(buf___3->b_ml.ml_mfp)->mf_fname != (unsigned long )((void *)0)) {
        {
        out_str((char_u *)"Vim: preserving files...\n");
        screen_start();
        out_flush();
        ml_sync_all(0, 0);
        }
        goto while_break;
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  ml_close_all(0);
  out_str((char_u *)"Vim: Finished.\n");
  getout(1);
  }
  return;
}
}
int vim_fexists(char_u *fname ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
  tmp = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
  }
  if (tmp) {
    return (0);
  }
  return (1);
}
}
static int count___1  =    0;
void line_breakcheck(void) 
{ 


  {
  count___1 ++;
  if (count___1 == 32) {
    {
    count___1 = 0;
    ui_breakcheck();
    }
  }
  return;
}
}
int expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                     int flags___0 ) 
{ 
  int retval ;
  int i___0 ;
  int j ;
  char_u *p___0 ;
  int non_suf_match ;
  char_u buf___3[100] ;
  char_u *ffname ;
  char_u *tail ;
  char_u *regpat ;
  char allow_dirs ;
  int match ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  retval = gen_expand_wildcards(num_pat, pat, num_file, file, flags___0);
  }
  if (flags___0 & 16) {
    return (retval);
  }
  if (*p_wig) {
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < *num_file)) {
        goto while_break;
      }
      {
      ffname = FullName_save(*(*file + i___0), 0);
      }
      if ((unsigned long )ffname == (unsigned long )((void *)0)) {
        goto while_break;
      }
      {
      tail = gettail(*(*file + i___0));
      p___0 = p_wig;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! *p___0) {
          goto while_break___0;
        }
        {
        copy_option_part(& p___0, buf___3, 100, (char *)",");
        tmp = strlen((char const   *)((char *)(buf___3)));
        regpat = file_pat_to_reg_pat(buf___3, buf___3 + tmp, & allow_dirs, 0);
        }
        if ((unsigned long )regpat == (unsigned long )((void *)0)) {
          goto while_break___0;
        }
        {
        match = match_file_pat(regpat, ffname, *(*file + i___0), tail, (int )allow_dirs);
        vim_free((void *)regpat);
        }
        if (match) {
          {
          vim_free((void *)*(*file + i___0));
          j = i___0;
          }
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (j + 1 < *num_file)) {
              goto while_break___1;
            }
            *(*file + j) = *(*file + (j + 1));
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          (*num_file) --;
          i___0 --;
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      vim_free((void *)ffname);
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  if (*num_file > 1) {
    non_suf_match = 0;
    i___0 = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (i___0 < *num_file)) {
        goto while_break___2;
      }
      {
      tmp___1 = match_suffix(*(*file + i___0));
      }
      if (! tmp___1) {
        p___0 = *(*file + i___0);
        j = i___0;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (! (j > non_suf_match)) {
            goto while_break___3;
          }
          *(*file + j) = *(*file + (j - 1));
          j --;
        }
        while_break___3: /* CIL Label */ ;
        }
        tmp___0 = non_suf_match;
        non_suf_match ++;
        *(*file + tmp___0) = p___0;
      }
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return (retval);
}
}
int match_suffix(char_u *fname ) 
{ 
  int fnamelen ;
  int setsuflen ;
  char_u *setsuf ;
  char_u suf_buf[30] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)fname));
  fnamelen = (int )tmp;
  setsuflen = 0;
  setsuf = p_su;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *setsuf) {
      goto while_break;
    }
    {
    setsuflen = copy_option_part(& setsuf, suf_buf, 30, (char *)".,");
    }
    if (fnamelen >= setsuflen) {
      {
      tmp___0 = strncmp((char const   *)((char *)(suf_buf)), (char const   *)((char *)((fname + fnamelen) - setsuflen)),
                        (size_t )setsuflen);
      }
      if (tmp___0 == 0) {
        goto while_break;
      }
    }
    setsuflen = 0;
  }
  while_break: /* CIL Label */ ;
  }
  return (setsuflen != 0);
}
}
static int recursive___0  =    0;
int gen_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) 
{ 
  int i___0 ;
  struct growarray ga ;
  char_u *p___0 ;
  int add_pat ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char_u *t ;
  char_u *tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  if (recursive___0) {
    {
    tmp = mch_expand_wildcards(num_pat, pat, num_file, file, flags___0);
    }
    return (tmp);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < num_pat)) {
      goto while_break;
    }
    {
    tmp___1 = strpbrk((char const   *)((char *)*(pat + i___0)), (char const   *)((char *)((char_u *)"`\'{")));
    }
    if ((unsigned long )((char_u *)tmp___1) != (unsigned long )((void *)0)) {
      {
      tmp___0 = mch_expand_wildcards(num_pat, pat, num_file, file, flags___0);
      }
      return (tmp___0);
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  recursive___0 = 1;
  ga_init2(& ga, (int )sizeof(char_u *), 30);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < num_pat)) {
      goto while_break___0;
    }
    {
    add_pat = -1;
    p___0 = *(pat + i___0);
    tmp___3 = strpbrk((char const   *)((char *)p___0), (char const   *)((char *)((char_u *)"$~")));
    }
    if ((unsigned long )((char_u *)tmp___3) != (unsigned long )((void *)0)) {
      {
      p___0 = expand_env_save(p___0);
      }
      if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
        p___0 = *(pat + i___0);
      } else {
        {
        tmp___2 = strpbrk((char const   *)((char *)p___0), (char const   *)((char *)((char_u *)"$~")));
        }
        if ((unsigned long )((char_u *)tmp___2) != (unsigned long )((void *)0)) {
          {
          vim_free((void *)p___0);
          ga_clear(& ga);
          i___0 = mch_expand_wildcards(num_pat, pat, num_file, file, flags___0);
          recursive___0 = 0;
          }
          return (i___0);
        }
      }
    }
    {
    tmp___4 = mch_has_wildcard(p___0);
    }
    if (tmp___4) {
      {
      add_pat = mch_expandpath(& ga, p___0, flags___0);
      }
    }
    if (add_pat <= 0) {
      if (flags___0 & 4) {
        {
        tmp___5 = backslash_halve_save(p___0);
        t = tmp___5;
        addfile(& ga, t, flags___0);
        vim_free((void *)t);
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (add_pat == -1) {
      {
      tmp___6 = mch_getperm(p___0);
      }
      if (tmp___6 >= 0L) {
        {
        tmp___5 = backslash_halve_save(p___0);
        t = tmp___5;
        addfile(& ga, t, flags___0);
        vim_free((void *)t);
        }
      }
    }
    }
    if ((unsigned long )p___0 != (unsigned long )*(pat + i___0)) {
      {
      vim_free((void *)p___0);
      }
    }
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *num_file = ga.ga_len;
  if ((unsigned long )ga.ga_data != (unsigned long )((void *)0)) {
    *file = (char_u **)ga.ga_data;
  } else {
    *file = (char_u **)"";
  }
  recursive___0 = 0;
  if ((unsigned long )ga.ga_data != (unsigned long )((void *)0)) {
    tmp___7 = 1;
  } else {
    tmp___7 = 0;
  }
  return (tmp___7);
}
}
void addfile(struct growarray *gap , char_u *f , int flags___0 ) 
{ 
  char_u *p___0 ;
  int isdir ;
  long tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if (! (flags___0 & 4)) {
    {
    tmp = mch_getperm(f);
    }
    if (tmp < 0L) {
      return;
    }
  }
  {
  isdir = mch_isdir(f);
  }
  if (isdir) {
    if (! (flags___0 & 1)) {
      return;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (! isdir) {
    if (! (flags___0 & 2)) {
      return;
    }
  }
  }
  {
  tmp___0 = ga_grow(gap, 1);
  }
  if (tmp___0 == 0) {
    return;
  }
  {
  tmp___1 = strlen((char const   *)((char *)f));
  p___0 = alloc((unsigned int )((tmp___1 + 1UL) + (size_t )isdir));
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    return;
  }
  {
  strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)f));
  }
  if (isdir) {
    if (flags___0 & 8) {
      {
      strcat((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)"/"));
      }
    }
  }
  tmp___2 = gap->ga_len;
  (gap->ga_len) ++;
  *((char_u **)gap->ga_data + tmp___2) = p___0;
  (gap->ga_room) --;
  return;
}
}
char_u *get_cmd_output(char_u *cmd , int flags___0 ) 
{ 
  char_u *tempname ;
  char_u *command ;
  char_u *buffer ;
  int len___0 ;
  int i___0 ;
  FILE *fd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;

  {
  {
  buffer = (char_u *)((void *)0);
  i___0 = 0;
  tmp = check_restricted();
  }
  if (tmp) {
    return ((char_u *)((void *)0));
  } else {
    {
    tmp___0 = check_secure();
    }
    if (tmp___0) {
      return ((char_u *)((void *)0));
    }
  }
  {
  tempname = vim_tempname('o');
  }
  if ((unsigned long )tempname == (unsigned long )((void *)0)) {
    {
    emsg(e_notmp);
    }
    return ((char_u *)((void *)0));
  }
  {
  command = make_filter_cmd(cmd, (char_u *)((void *)0), tempname);
  }
  if ((unsigned long )command == (unsigned long )((void *)0)) {
    goto done;
  }
  {
  call_shell(command, 10 | flags___0);
  vim_free((void *)command);
  fd = fopen((char const   * __restrict  )((char *)tempname), (char const   * __restrict  )"r");
  }
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
    emsg2(e_notopen, tempname);
    }
    goto done;
  }
  {
  fseek(fd, 0L, 2);
  tmp___1 = ftell(fd);
  len___0 = (int )tmp___1;
  fseek(fd, 0L, 0);
  buffer = alloc((unsigned int )(len___0 + 1));
  }
  if ((unsigned long )buffer != (unsigned long )((void *)0)) {
    {
    tmp___2 = fread((void * __restrict  )((char *)buffer), (size_t )1, (size_t )len___0,
                    (FILE * __restrict  )fd);
    i___0 = (int )tmp___2;
    }
  }
  {
  fclose(fd);
  unlink((char const   *)((char *)tempname));
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    goto done;
  }
  if (i___0 != len___0) {
    {
    emsg2(e_notread, tempname);
    vim_free((void *)buffer);
    buffer = (char_u *)((void *)0);
    }
  } else {
    *(buffer + len___0) = (char_u )'\000';
  }
  done: 
  {
  vim_free((void *)tempname);
  }
  return (buffer);
}
}
void FreeWild(int num , char_u **file ) 
{ 
  int tmp ;

  {
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    return;
  } else { //Added block
  if (num <= 0) {
    return;
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = num;
    num --;
    if (! tmp) {
      goto while_break;
    }
    {
    vim_free((void *)*(file + num));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)file);
  }
  return;
}
}
int goto_im(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (p_im) {
    {
    tmp = stuff_empty();
    }
    if (tmp) {
      {
      tmp___0 = typebuf_typed();
      }
      if (tmp___0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
#pragma merger("0","/tmp/cil-yqxOv2S_.i","-O0")
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
int mch_get_user_name(char_u *s , int len___0 ) ;
int mch_call_shell(char_u *cmd , int options___0 ) ;
int inc(FPOS *lp ) ;
int incl(FPOS *lp ) ;
int decl(FPOS *lp ) ;
void adjust_cursor_col(void) ;
int leftcol_changed(void) ;
char_u *lalloc_clear(long_u size , int message ) ;
char_u *vim_strsave_up(char_u *string___0 ) ;
char_u *vim_strnsave_up(char_u *string___0 , int len___0 ) ;
void copy_spaces(char_u *ptr , size_t count___2 ) ;
void copy_chars(char_u *ptr , size_t count___2 , int c ) ;
int name_to_mod_mask(int c ) ;
int simplify_key(int key , int *modifiers ) ;
int find_special_key(char_u **srcp , int *modp , int keycode ) ;
int find_special_key_in_table(int c ) ;
char_u *get_key_name(int i___0 ) ;
int get_mouse_button(int code , int *is_click , int *is_drag ) ;
int get_pseudo_mouse_code(int button , int is_click , int is_drag ) ;
void tag_freematch(void) ;
int coladvance(colnr_t wcol ) 
{ 
  int idx ;
  char_u *ptr ;
  colnr_t col ;
  int tmp ;

  {
  {
  ptr = ml_get_curline();
  idx = -1;
  col = (colnr_t )0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (col <= wcol) {
      if (! *ptr) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    idx ++;
    tmp = lbr_chartabsize(ptr, col);
    col += (colnr_t )tmp;
    ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (State & 16) {
    goto _L;
  } else { //Added block
  if (VIsual_active) {
    if ((int )*p_sel != 111) {
      _L: 
      if (col <= wcol) {
        idx ++;
      }
    }
  }
  }
  if (idx < 0) {
    curwin->w_cursor.col = (colnr_t )0;
  } else {
    curwin->w_cursor.col = (colnr_t )idx;
  }
  if (col <= wcol) {
    return (0);
  } else {
    return (1);
  }
}
}
int inc_cursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = inc(& curwin->w_cursor);
  }
  return (tmp);
}
}
int inc(FPOS *lp ) 
{ 
  char_u *p___0 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = ml_get_pos(lp);
  p___0 = tmp;
  }
  if ((int )*p___0 != 0) {
    (lp->col) ++;
    if ((int )*(p___0 + 1) != 0) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return (tmp___0);
  }
  if (lp->lnum != curbuf->b_ml.ml_line_count) {
    lp->col = (colnr_t )0;
    (lp->lnum) ++;
    return (1);
  }
  return (-1);
}
}
int incl(FPOS *lp ) 
{ 
  int r ;

  {
  {
  r = inc(lp);
  }
  if (r == 1) {
    if (lp->col) {
      {
      r = inc(lp);
      }
    }
  }
  return (r);
}
}
int dec_cursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = dec(& curwin->w_cursor);
  }
  return (tmp);
}
}
int dec(FPOS *lp ) 
{ 
  char_u *tmp ;
  size_t tmp___0 ;

  {
  if (lp->col > 0U) {
    (lp->col) --;
    return (0);
  }
  if (lp->lnum > 1L) {
    {
    (lp->lnum) --;
    tmp = ml_get(lp->lnum);
    tmp___0 = strlen((char const   *)((char *)tmp));
    lp->col = (colnr_t )tmp___0;
    }
    return (1);
  }
  return (-1);
}
}
int decl(FPOS *lp ) 
{ 
  int r ;

  {
  {
  r = dec(lp);
  }
  if (r == 1) {
    if (lp->col) {
      {
      r = dec(lp);
      }
    }
  }
  return (r);
}
}
void check_cursor_lnum(void) 
{ 


  {
  if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
  }
  if (curwin->w_cursor.lnum <= 0L) {
    curwin->w_cursor.lnum = (linenr_t )1;
  }
  return;
}
}
void check_cursor_col(void) 
{ 
  colnr_t len___0 ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = ml_get_curline();
  tmp___0 = strlen((char const   *)((char *)tmp));
  len___0 = (colnr_t )tmp___0;
  }
  if (len___0 == 0U) {
    curwin->w_cursor.col = (colnr_t )0;
  } else { //Added block
  if (curwin->w_cursor.col >= len___0) {
    if (State & 16) {
      curwin->w_cursor.col = len___0;
    } else { //Added block
    if (restart_edit) {
      curwin->w_cursor.col = len___0;
    } else { //Added block
    if (VIsual_active) {
      if ((int )*p_sel != 111) {
        curwin->w_cursor.col = len___0;
      } else {
        curwin->w_cursor.col = len___0 - 1U;
      }
    } else {
      curwin->w_cursor.col = len___0 - 1U;
    }
    }
    }
  }
  }
  return;
}
}
void adjust_cursor(void) 
{ 


  {
  {
  check_cursor_lnum();
  check_cursor_col();
  }
  return;
}
}
void adjust_cursor_col(void) 
{ 
  int tmp ;

  {
  if (! VIsual_active) {
    goto _L;
  } else { //Added block
  if ((int )*p_sel == 111) {
    _L: 
    if (curwin->w_cursor.col) {
      {
      tmp = gchar_cursor();
      }
      if (tmp == 0) {
        (curwin->w_cursor.col) --;
      }
    }
  }
  }
  return;
}
}
int leftcol_changed(void) 
{ 
  long lastcol ;
  colnr_t s ;
  colnr_t e ;
  int retval ;
  int tmp ;
  int tmp___0 ;

  {
  {
  retval = 0;
  changed_cline_bef_curs();
  }
  if (curwin->w_p_nu) {
    tmp = 8;
  } else {
    tmp = 0;
  }
  {
  lastcol = (((long )curwin->w_leftcol + Columns) - (long )tmp) - 1L;
  validate_virtcol();
  }
  if (curwin->w_virtcol > (colnr_t )lastcol) {
    {
    retval = 1;
    coladvance((colnr_t )lastcol);
    }
  } else { //Added block
  if (curwin->w_virtcol < curwin->w_leftcol) {
    {
    retval = 1;
    coladvance(curwin->w_leftcol);
    }
  }
  }
  {
  getvcol(curwin, & curwin->w_cursor, & s, (colnr_t *)((void *)0), & e);
  }
  if (e > (colnr_t )lastcol) {
    {
    retval = 1;
    coladvance(s - 1U);
    }
  } else { //Added block
  if (s < curwin->w_leftcol) {
    {
    retval = 1;
    tmp___0 = coladvance(e + 1U);
    }
    if (tmp___0 == 0) {
      {
      curwin->w_leftcol = s;
      changed_cline_bef_curs();
      }
    }
  }
  }
  if (retval) {
    curwin->w_set_curswant = 1;
  }
  {
  redraw_later(40);
  }
  return (retval);
}
}
static void vim_strup(char_u *p___0 ) ;
char_u *alloc(unsigned int size ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = lalloc((long_u )size, 1);
  }
  return (tmp);
}
}
char_u *alloc_clear(unsigned int size ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = lalloc((long_u )size, 1);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    memset((void *)p___0, 0, (size_t )size);
    }
  }
  return (p___0);
}
}
char_u *alloc_check(unsigned int size ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = lalloc((long_u )size, 1);
  }
  return (tmp);
}
}
char_u *lalloc_clear(long_u size , int message ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = lalloc(size, message);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    memset((void *)p___0, 0, size);
    }
  }
  return (p___0);
}
}
static int releasing  =    0;
char_u *lalloc(long_u size , int message ) 
{ 
  char_u *p___0 ;
  int try_again ;
  void *tmp ;

  {
  if (size <= 0UL) {
    {
    emsgn((char_u *)"Internal error: lalloc(%ld, )", (long )size);
    }
    return ((char_u *)((void *)0));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = malloc(size);
    p___0 = (char_u *)tmp;
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      goto theend;
    }
    if (releasing) {
      goto while_break;
    }
    {
    releasing = 1;
    try_again = mf_release_all();
    releasing = 0;
    }
    if (! try_again) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (message) {
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      {
      do_outofmem_msg();
      }
    }
  }
  theend: 
  return (p___0);
}
}
void do_outofmem_msg(void) 
{ 


  {
  if (! did_outofmem_msg) {
    {
    emsg(e_outofmem);
    did_outofmem_msg = 1;
    }
  }
  return;
}
}
char_u *vim_strsave(char_u *string___0 ) 
{ 
  char_u *p___0 ;
  unsigned int len___0 ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)string___0));
  len___0 = (unsigned int )(tmp + 1UL);
  p___0 = alloc(len___0);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    memmove((void *)((char *)p___0), (void const   *)((char *)string___0), (size_t )len___0);
    }
  }
  return (p___0);
}
}
char_u *vim_strnsave(char_u *string___0 , int len___0 ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = alloc((unsigned int )(len___0 + 1));
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    strncpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)string___0),
            (size_t )len___0);
    *(p___0 + len___0) = (char_u )'\000';
    }
  }
  return (p___0);
}
}
char_u *vim_strsave_escaped(char_u *string___0 , char_u *esc_chars ) 
{ 
  char_u *p___0 ;
  char_u *p2 ;
  char_u *escaped_string ;
  unsigned int length ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;

  {
  length = 1U;
  p___0 = string___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp = vim_strchr(esc_chars, (int )*p___0);
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      length ++;
    }
    length ++;
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  escaped_string = alloc(length);
  }
  if ((unsigned long )escaped_string != (unsigned long )((void *)0)) {
    p2 = escaped_string;
    p___0 = string___0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break___0;
      }
      {
      tmp___1 = vim_strchr(esc_chars, (int )*p___0);
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        tmp___0 = p2;
        p2 ++;
        *tmp___0 = (char_u )'\\';
      }
      tmp___2 = p2;
      p2 ++;
      *tmp___2 = *p___0;
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    *p2 = (char_u )'\000';
  }
  return (escaped_string);
}
}
char_u *vim_strsave_up(char_u *string___0 ) 
{ 
  char_u *p1 ;

  {
  {
  p1 = vim_strsave(string___0);
  vim_strup(p1);
  }
  return (p1);
}
}
char_u *vim_strnsave_up(char_u *string___0 , int len___0 ) 
{ 
  char_u *p1 ;

  {
  {
  p1 = vim_strnsave(string___0, len___0);
  vim_strup(p1);
  }
  return (p1);
}
}
static void vim_strup(char_u *p___0 ) 
{ 
  char_u *p2 ;
  int c ;
  char_u *tmp ;

  {
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    p2 = p___0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      c = (int )*p2;
      if (! (c != 0)) {
        goto while_break;
      }
      tmp = p2;
      p2 ++;
      if (c < 97) {
        *tmp = (char_u )c;
      } else { //Added block
      if (c > 122) {
        *tmp = (char_u )c;
      } else {
        *tmp = (char_u )(c - 32);
      }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
void copy_spaces(char_u *ptr , size_t count___2 ) 
{ 
  size_t i___0 ;
  char_u *p___0 ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  i___0 = count___2;
  p___0 = ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___0 = i___0;
    i___0 --;
    if (! tmp___0) {
      goto while_break;
    }
    tmp = p___0;
    p___0 ++;
    *tmp = (char_u )' ';
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void copy_chars(char_u *ptr , size_t count___2 , int c ) 
{ 
  size_t i___0 ;
  char_u *p___0 ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  i___0 = count___2;
  p___0 = ptr;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___0 = i___0;
    i___0 --;
    if (! tmp___0) {
      goto while_break;
    }
    tmp = p___0;
    p___0 ++;
    *tmp = (char_u )c;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void del_trailing_spaces(char_u *ptr ) 
{ 
  char_u *q ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)ptr));
  q = ptr + tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    q --;
    if ((unsigned long )q > (unsigned long )ptr) {
      if ((int )*(q + 0) == 32) {
        goto _L;
      } else { //Added block
      if ((int )*(q + 0) == 9) {
        _L: 
        if ((int )*(q + -1) != 92) {
          if (! ((int )*(q + -1) != 22)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      }
    } else {
      goto while_break;
    }
    *q = (char_u )'\000';
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void vim_strncpy(char_u *to , char_u *from , int len___0 ) 
{ 
  int i___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  if ((unsigned long )to <= (unsigned long )from) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp___1 = len___0;
      len___0 --;
      if (tmp___1) {
        if (! *from) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      tmp = to;
      to ++;
      tmp___0 = from;
      from ++;
      *tmp = *tmp___0;
    }
    while_break: /* CIL Label */ ;
    }
    if (len___0 >= 0) {
      *to = *from;
    }
  } else {
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < len___0)) {
        goto while_break___0;
      }
      to ++;
      tmp___2 = from;
      from ++;
      if ((int )*tmp___2 == 0) {
        i___0 ++;
        goto while_break___0;
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i___0 > 0)) {
        goto while_break___1;
      }
      to --;
      from --;
      *to = *from;
      i___0 --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return;
}
}
int copy_option_part(char_u **option , char_u *buf___3 , int maxlen , char *sep_chars ) 
{ 
  int len___0 ;
  char_u *p___0 ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;

  {
  len___0 = 0;
  p___0 = *option;
  if ((int )*p___0 == 46) {
    tmp = len___0;
    len___0 ++;
    tmp___0 = p___0;
    p___0 ++;
    *(buf___3 + tmp) = *tmp___0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      {
      tmp___3 = vim_strchr((char_u *)sep_chars, (int )*p___0);
      }
      if (! ((unsigned long )tmp___3 == (unsigned long )((void *)0))) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == 92) {
      {
      tmp___1 = vim_strchr((char_u *)sep_chars, (int )*(p___0 + 1));
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        p___0 ++;
      }
    }
    if (len___0 < maxlen - 1) {
      tmp___2 = len___0;
      len___0 ++;
      *(buf___3 + tmp___2) = *p___0;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *(buf___3 + len___0) = (char_u )'\000';
  p___0 = skip_to_option_part(p___0);
  *option = p___0;
  }
  return (len___0);
}
}
void vim_free(void *x___0 ) 
{ 


  {
  if ((unsigned long )x___0 != (unsigned long )((void *)0)) {
    {
    free(x___0);
    }
  }
  return;
}
}
char_u *vim_strchr(char_u *string___0 , int n ) 
{ 
  char_u *p___0 ;
  int c ;

  {
  p___0 = string___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    c = (int )*p___0;
    if (! (c != 0)) {
      goto while_break;
    }
    if (c == n) {
      return (p___0);
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
char_u *vim_strrchr(char_u *string___0 , int n ) 
{ 
  char_u *retval ;

  {
  retval = (char_u *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *string___0) {
      goto while_break;
    }
    if ((int )*string___0 == n) {
      retval = string___0;
    }
    string___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (retval);
}
}
int vim_isspace(int x___0 ) 
{ 
  int tmp ;

  {
  if (x___0 >= 9) {
    if (x___0 <= 13) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (x___0 == 32) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
void ga_clear(struct growarray *gap ) 
{ 


  {
  {
  vim_free(gap->ga_data);
  ga_init(gap);
  }
  return;
}
}
void ga_clear_strings(struct growarray *gap ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < gap->ga_len)) {
      goto while_break;
    }
    {
    vim_free((void *)*((char_u **)gap->ga_data + i___0));
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  ga_clear(gap);
  }
  return;
}
}
void ga_init(struct growarray *gap ) 
{ 


  {
  gap->ga_data = (void *)0;
  gap->ga_room = 0;
  gap->ga_len = 0;
  return;
}
}
void ga_init2(struct growarray *gap , int itemsize , int growsize ) 
{ 


  {
  {
  ga_init(gap);
  gap->ga_itemsize = itemsize;
  gap->ga_growsize = growsize;
  }
  return;
}
}
int ga_grow(struct growarray *gap , int n ) 
{ 
  size_t len___0 ;
  char_u *pp ;

  {
  if (gap->ga_room < n) {
    if (n < gap->ga_growsize) {
      n = gap->ga_growsize;
    }
    {
    len___0 = (size_t )(gap->ga_itemsize * (gap->ga_len + n));
    pp = alloc_clear((unsigned int )len___0);
    }
    if ((unsigned long )pp == (unsigned long )((void *)0)) {
      return (0);
    }
    gap->ga_room = n;
    if ((unsigned long )gap->ga_data != (unsigned long )((void *)0)) {
      {
      memmove((void *)((char *)pp), (void const   *)((char *)gap->ga_data), (size_t )(gap->ga_itemsize * gap->ga_len));
      vim_free(gap->ga_data);
      }
    }
    gap->ga_data = (void *)pp;
  }
  return (1);
}
}
void ga_concat(struct growarray *gap , char_u *s ) 
{ 
  size_t len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)s));
  len___0 = tmp;
  tmp___0 = ga_grow(gap, (int )len___0);
  }
  if (tmp___0 == 1) {
    {
    memmove((void *)((char *)gap->ga_data + gap->ga_len), (void const   *)((char *)s),
            len___0);
    gap->ga_len = (int )((size_t )gap->ga_len + len___0);
    gap->ga_room = (int )((size_t )gap->ga_room - len___0);
    }
  }
  return;
}
}
void ga_append(struct growarray *gap , int c ) 
{ 
  int tmp ;

  {
  {
  tmp = ga_grow(gap, 1);
  }
  if (tmp == 1) {
    *((char *)gap->ga_data + gap->ga_len) = (char )c;
    (gap->ga_len) ++;
    (gap->ga_room) --;
  }
  return;
}
}
static struct modmasktable mod_mask_table[7]  = {      {8, (char_u )'M'}, 
        {4, (char_u )'C'}, 
        {2, (char_u )'S'}, 
        {16, (char_u )'2'}, 
        {32, (char_u )'3'}, 
        {64, (char_u )'4'}, 
        {0, (char_u )'\000'}};
static char_u shifted_keys_table[277]  = 
  {      (char_u )'&',      (char_u )'9',      (char_u )'@',      (char_u )'1', 
        (char_u )'&',      (char_u )'0',      (char_u )'@',      (char_u )'2', 
        (char_u )'*',      (char_u )'1',      (char_u )'@',      (char_u )'4', 
        (char_u )'*',      (char_u )'2',      (char_u )'@',      (char_u )'5', 
        (char_u )'*',      (char_u )'3',      (char_u )'@',      (char_u )'6', 
        (char_u )'*',      (char_u )'4',      (char_u )'k',      (char_u )'D', 
        (char_u )'*',      (char_u )'5',      (char_u )'k',      (char_u )'L', 
        (char_u )'*',      (char_u )'7',      (char_u )'@',      (char_u )'7', 
        (char_u )'*',      (char_u )'9',      (char_u )'@',      (char_u )'9', 
        (char_u )'*',      (char_u )'0',      (char_u )'@',      (char_u )'0', 
        (char_u )'#',      (char_u )'1',      (char_u )'%',      (char_u )'1', 
        (char_u )'#',      (char_u )'2',      (char_u )'k',      (char_u )'h', 
        (char_u )'#',      (char_u )'3',      (char_u )'k',      (char_u )'I', 
        (char_u )'#',      (char_u )'4',      (char_u )'k',      (char_u )'l', 
        (char_u )'%',      (char_u )'a',      (char_u )'%',      (char_u )'3', 
        (char_u )'%',      (char_u )'b',      (char_u )'%',      (char_u )'4', 
        (char_u )'%',      (char_u )'c',      (char_u )'%',      (char_u )'5', 
        (char_u )'%',      (char_u )'d',      (char_u )'%',      (char_u )'7', 
        (char_u )'%',      (char_u )'e',      (char_u )'%',      (char_u )'8', 
        (char_u )'%',      (char_u )'f',      (char_u )'%',      (char_u )'9', 
        (char_u )'%',      (char_u )'g',      (char_u )'%',      (char_u )'0', 
        (char_u )'%',      (char_u )'h',      (char_u )'&',      (char_u )'3', 
        (char_u )'%',      (char_u )'i',      (char_u )'k',      (char_u )'r', 
        (char_u )'%',      (char_u )'j',      (char_u )'&',      (char_u )'5', 
        (char_u )'!',      (char_u )'1',      (char_u )'&',      (char_u )'6', 
        (char_u )'!',      (char_u )'2',      (char_u )'&',      (char_u )'7', 
        (char_u )'!',      (char_u )'3',      (char_u )'&',      (char_u )'8', 
        (char_u )253,      (char_u )4,      (char_u )'k',      (char_u )'u', 
        (char_u )253,      (char_u )5,      (char_u )'k',      (char_u )'d', 
        (char_u )253,      (char_u )63,      (char_u )253,      (char_u )55, 
        (char_u )253,      (char_u )64,      (char_u )253,      (char_u )56, 
        (char_u )253,      (char_u )65,      (char_u )253,      (char_u )57, 
        (char_u )253,      (char_u )66,      (char_u )253,      (char_u )58, 
        (char_u )253,      (char_u )6,      (char_u )'k',      (char_u )'1', 
        (char_u )253,      (char_u )7,      (char_u )'k',      (char_u )'2', 
        (char_u )253,      (char_u )8,      (char_u )'k',      (char_u )'3', 
        (char_u )253,      (char_u )9,      (char_u )'k',      (char_u )'4', 
        (char_u )253,      (char_u )10,      (char_u )'k',      (char_u )'5', 
        (char_u )253,      (char_u )11,      (char_u )'k',      (char_u )'6', 
        (char_u )253,      (char_u )12,      (char_u )'k',      (char_u )'7', 
        (char_u )253,      (char_u )13,      (char_u )'k',      (char_u )'8', 
        (char_u )253,      (char_u )14,      (char_u )'k',      (char_u )'9', 
        (char_u )253,      (char_u )15,      (char_u )'k',      (char_u )';', 
        (char_u )253,      (char_u )16,      (char_u )'F',      (char_u )'1', 
        (char_u )253,      (char_u )17,      (char_u )'F',      (char_u )'2', 
        (char_u )253,      (char_u )18,      (char_u )'F',      (char_u )'3', 
        (char_u )253,      (char_u )19,      (char_u )'F',      (char_u )'4', 
        (char_u )253,      (char_u )20,      (char_u )'F',      (char_u )'5', 
        (char_u )253,      (char_u )21,      (char_u )'F',      (char_u )'6', 
        (char_u )253,      (char_u )22,      (char_u )'F',      (char_u )'7', 
        (char_u )253,      (char_u )23,      (char_u )'F',      (char_u )'8', 
        (char_u )253,      (char_u )24,      (char_u )'F',      (char_u )'9', 
        (char_u )253,      (char_u )25,      (char_u )'F',      (char_u )'A', 
        (char_u )253,      (char_u )26,      (char_u )'F',      (char_u )'B', 
        (char_u )253,      (char_u )27,      (char_u )'F',      (char_u )'C', 
        (char_u )253,      (char_u )28,      (char_u )'F',      (char_u )'D', 
        (char_u )253,      (char_u )29,      (char_u )'F',      (char_u )'E', 
        (char_u )253,      (char_u )30,      (char_u )'F',      (char_u )'F', 
        (char_u )253,      (char_u )31,      (char_u )'F',      (char_u )'G', 
        (char_u )253,      (char_u )32,      (char_u )'F',      (char_u )'H', 
        (char_u )253,      (char_u )33,      (char_u )'F',      (char_u )'I', 
        (char_u )253,      (char_u )34,      (char_u )'F',      (char_u )'J', 
        (char_u )253,      (char_u )35,      (char_u )'F',      (char_u )'K', 
        (char_u )253,      (char_u )36,      (char_u )'F',      (char_u )'L', 
        (char_u )253,      (char_u )37,      (char_u )'F',      (char_u )'M', 
        (char_u )253,      (char_u )38,      (char_u )'F',      (char_u )'N', 
        (char_u )253,      (char_u )39,      (char_u )'F',      (char_u )'O', 
        (char_u )253,      (char_u )40,      (char_u )'F',      (char_u )'P', 
        (char_u )253,      (char_u )53,      (char_u )253,      (char_u )52, 
        (char_u )'\000'};
static struct key_name_entry key_names_table[99]  = 
  {      {' ', (char_u *)"Space"}, 
        {'\t', (char_u *)"Tab"}, 
        {253 + (52 << 8), (char_u *)"Tab"}, 
        {'\n', (char_u *)"NL"}, 
        {'\n', (char_u *)"NewLine"}, 
        {'\n', (char_u *)"LineFeed"}, 
        {'\n', (char_u *)"LF"}, 
        {'\r', (char_u *)"CR"}, 
        {'\r', (char_u *)"Return"}, 
        {107 + (98 << 8), (char_u *)"BS"}, 
        {107 + (98 << 8), (char_u *)"BackSpace"}, 
        {'\033', (char_u *)"Esc"}, 
        {155, (char_u *)"CSI"}, 
        {253 + (71 << 8), (char_u *)"xCSI"}, 
        {'|', (char_u *)"Bar"}, 
        {'\\', (char_u *)"Bslash"}, 
        {107 + (68 << 8), (char_u *)"Del"}, 
        {107 + (68 << 8), (char_u *)"Delete"}, 
        {253 + (70 << 8), (char_u *)"kDel"}, 
        {107 + (117 << 8), (char_u *)"Up"}, 
        {107 + (100 << 8), (char_u *)"Down"}, 
        {107 + (108 << 8), (char_u *)"Left"}, 
        {107 + (114 << 8), (char_u *)"Right"}, 
        {107 + (49 << 8), (char_u *)"F1"}, 
        {107 + (50 << 8), (char_u *)"F2"}, 
        {107 + (51 << 8), (char_u *)"F3"}, 
        {107 + (52 << 8), (char_u *)"F4"}, 
        {107 + (53 << 8), (char_u *)"F5"}, 
        {107 + (54 << 8), (char_u *)"F6"}, 
        {107 + (55 << 8), (char_u *)"F7"}, 
        {107 + (56 << 8), (char_u *)"F8"}, 
        {107 + (57 << 8), (char_u *)"F9"}, 
        {107 + (59 << 8), (char_u *)"F10"}, 
        {70 + (49 << 8), (char_u *)"F11"}, 
        {70 + (50 << 8), (char_u *)"F12"}, 
        {70 + (51 << 8), (char_u *)"F13"}, 
        {70 + (52 << 8), (char_u *)"F14"}, 
        {70 + (53 << 8), (char_u *)"F15"}, 
        {70 + (54 << 8), (char_u *)"F16"}, 
        {70 + (55 << 8), (char_u *)"F17"}, 
        {70 + (56 << 8), (char_u *)"F18"}, 
        {70 + (57 << 8), (char_u *)"F19"}, 
        {70 + (65 << 8), (char_u *)"F20"}, 
        {70 + (66 << 8), (char_u *)"F21"}, 
        {70 + (67 << 8), (char_u *)"F22"}, 
        {70 + (68 << 8), (char_u *)"F23"}, 
        {70 + (69 << 8), (char_u *)"F24"}, 
        {70 + (70 << 8), (char_u *)"F25"}, 
        {70 + (71 << 8), (char_u *)"F26"}, 
        {70 + (72 << 8), (char_u *)"F27"}, 
        {70 + (73 << 8), (char_u *)"F28"}, 
        {70 + (74 << 8), (char_u *)"F29"}, 
        {70 + (75 << 8), (char_u *)"F30"}, 
        {70 + (76 << 8), (char_u *)"F31"}, 
        {70 + (77 << 8), (char_u *)"F32"}, 
        {70 + (78 << 8), (char_u *)"F33"}, 
        {70 + (79 << 8), (char_u *)"F34"}, 
        {70 + (80 << 8), (char_u *)"F35"}, 
        {253 + (55 << 8), (char_u *)"xF1"}, 
        {253 + (56 << 8), (char_u *)"xF2"}, 
        {253 + (57 << 8), (char_u *)"xF3"}, 
        {253 + (58 << 8), (char_u *)"xF4"}, 
        {37 + (49 << 8), (char_u *)"Help"}, 
        {38 + (56 << 8), (char_u *)"Undo"}, 
        {107 + (73 << 8), (char_u *)"Insert"}, 
        {107 + (73 << 8), (char_u *)"Ins"}, 
        {253 + (69 << 8), (char_u *)"kInsert"}, 
        {107 + (104 << 8), (char_u *)"Home"}, 
        {75 + (49 << 8), (char_u *)"kHome"}, 
        {253 + (60 << 8), (char_u *)"xHome"}, 
        {64 + (55 << 8), (char_u *)"End"}, 
        {75 + (52 << 8), (char_u *)"kEnd"}, 
        {253 + (59 << 8), (char_u *)"xEnd"}, 
        {107 + (80 << 8), (char_u *)"PageUp"}, 
        {107 + (78 << 8), (char_u *)"PageDown"}, 
        {75 + (51 << 8), (char_u *)"kPageUp"}, 
        {75 + (53 << 8), (char_u *)"kPageDown"}, 
        {75 + (54 << 8), (char_u *)"kPlus"}, 
        {75 + (55 << 8), (char_u *)"kMinus"}, 
        {75 + (56 << 8), (char_u *)"kDivide"}, 
        {75 + (57 << 8), (char_u *)"kMultiply"}, 
        {75 + (65 << 8), (char_u *)"kEnter"}, 
        {'<', (char_u *)"lt"}, 
        {251 + (88 << 8), (char_u *)"Mouse"}, 
        {253 + (42 << 8), (char_u *)"LeftMouse"}, 
        {253 + (61 << 8), (char_u *)"LeftMouseNM"}, 
        {253 + (43 << 8), (char_u *)"LeftDrag"}, 
        {253 + (44 << 8), (char_u *)"LeftRelease"}, 
        {253 + (62 << 8), (char_u *)"LeftReleaseNM"}, 
        {253 + (45 << 8), (char_u *)"MiddleMouse"}, 
        {253 + (46 << 8), (char_u *)"MiddleDrag"}, 
        {253 + (47 << 8), (char_u *)"MiddleRelease"}, 
        {253 + (48 << 8), (char_u *)"RightMouse"}, 
        {253 + (49 << 8), (char_u *)"RightDrag"}, 
        {253 + (50 << 8), (char_u *)"RightRelease"}, 
        {253 + (67 << 8), (char_u *)"MouseDown"}, 
        {253 + (68 << 8), (char_u *)"MouseUp"}, 
        {255 + (88 << 8), (char_u *)"Nul"}, 
        {0, (char_u *)((void *)0)}};
static struct mousetable mouse_table[12]  = 
  {      {42, 0, 1, 0}, 
        {43, 0, 0, 1}, 
        {44, 0, 0, 0}, 
        {45, 1, 1, 0}, 
        {46, 1, 0, 1}, 
        {47, 1, 0, 0}, 
        {48, 2, 1, 0}, 
        {49, 2, 0, 1}, 
        {50, 2, 0, 0}, 
        {51, 3, 0, 1}, 
        {51, 3, 0, 0}, 
        {0, 0, 0, 0}};
int name_to_mod_mask(int c ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if (c <= 255) {
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! mod_mask_table[i___0].mod_mask) {
        goto while_break;
      }
      {
      tmp = tolower(c);
      tmp___0 = tolower((int )mod_mask_table[i___0].name);
      }
      if (tmp == tmp___0) {
        return (mod_mask_table[i___0].mod_mask);
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (0);
}
}
int simplify_key(int key , int *modifiers ) 
{ 
  int i___0 ;
  int key0 ;
  int key1 ;

  {
  if (*modifiers & 2) {
    if (key == 9) {
      *modifiers &= -3;
      return (253 + (53 << 8));
    }
    key0 = key & 255;
    key1 = (int )(((unsigned int )key >> 8) & 255U);
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((int )shifted_keys_table[i___0] != 0)) {
        goto while_break;
      }
      if (key0 == (int )shifted_keys_table[i___0 + 2]) {
        if (key1 == (int )shifted_keys_table[i___0 + 3]) {
          *modifiers &= -3;
          return ((int )shifted_keys_table[i___0] + ((int )shifted_keys_table[i___0 + 1] << 8));
        }
      }
      i___0 += 4;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (key);
}
}
static char_u string[24]  ;
char_u *get_special_key_name(int c , int modifiers ) 
{ 
  int i___0 ;
  int idx ;
  int table_idx ;
  char_u *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  string[0] = (char_u )'<';
  idx = 1;
  if (c >= 512) {
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! shifted_keys_table[i___0]) {
        goto while_break;
      }
      if ((c & 255) == (int )shifted_keys_table[i___0]) {
        if ((((unsigned int )c >> 8) & 255U) == (unsigned int )shifted_keys_table[i___0 + 1]) {
          modifiers |= 2;
          c = (int )shifted_keys_table[i___0 + 2] + ((int )shifted_keys_table[i___0 + 3] << 8);
          goto while_break;
        }
      }
      i___0 += 4;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  table_idx = find_special_key_in_table(c);
  }
  if (table_idx < 0) {
    {
    tmp = vim_isprintc(c);
    }
    if (tmp) {
      if ((c & 127) == 32) {
        _L: 
        if (c & 128) {
          {
          c &= 127;
          modifiers |= 8;
          table_idx = find_special_key_in_table(c);
          }
        }
      }
    } else {
      goto _L;
    }
  }
  if (table_idx < 0) {
    {
    tmp___0 = vim_isprintc(c);
    }
    if (! tmp___0) {
      if (c < 32) {
        c += 64;
        modifiers |= 4;
      }
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! mod_mask_table[i___0].mod_mask) {
      goto while_break___0;
    }
    if (modifiers & mod_mask_table[i___0].mod_mask) {
      tmp___1 = idx;
      idx ++;
      string[tmp___1] = mod_mask_table[i___0].name;
      tmp___2 = idx;
      idx ++;
      string[tmp___2] = (char_u )'-';
    }
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (table_idx < 0) {
    if (c >= 512) {
      tmp___3 = idx;
      idx ++;
      string[tmp___3] = (char_u )'t';
      tmp___4 = idx;
      idx ++;
      string[tmp___4] = (char_u )'_';
      tmp___5 = idx;
      idx ++;
      string[tmp___5] = (char_u )(c & 255);
      tmp___6 = idx;
      idx ++;
      string[tmp___6] = (char_u )(((unsigned int )c >> 8) & 255U);
    } else {
      {
      tmp___10 = vim_isprintc(c);
      }
      if (tmp___10) {
        tmp___7 = idx;
        idx ++;
        string[tmp___7] = (char_u )c;
      } else {
        {
        s = transchar(c);
        }
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! *s) {
            goto while_break___1;
          }
          tmp___8 = idx;
          idx ++;
          tmp___9 = s;
          s ++;
          string[tmp___8] = *tmp___9;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  } else {
    {
    strcpy((char * __restrict  )((char *)(string + idx)), (char const   * __restrict  )((char *)key_names_table[table_idx].name));
    tmp___11 = strlen((char const   *)((char *)(string)));
    idx = (int )tmp___11;
    }
  }
  tmp___12 = idx;
  idx ++;
  string[tmp___12] = (char_u )'>';
  string[idx] = (char_u )'\000';
  return (string);
}
}
int trans_special(char_u **srcp , char_u *dst , int keycode ) 
{ 
  int modifiers ;
  int key ;
  int dlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  dlen = 0;
  key = find_special_key(srcp, & modifiers, keycode);
  }
  if (key == 0) {
    return (0);
  }
  if (modifiers != 0) {
    tmp = dlen;
    dlen ++;
    *(dst + tmp) = (char_u )128;
    tmp___0 = dlen;
    dlen ++;
    *(dst + tmp___0) = (char_u )252;
    tmp___1 = dlen;
    dlen ++;
    *(dst + tmp___1) = (char_u )modifiers;
  }
  if (key >= 512) {
    tmp___2 = dlen;
    dlen ++;
    *(dst + tmp___2) = (char_u )128;
    tmp___3 = dlen;
    dlen ++;
    *(dst + tmp___3) = (char_u )(key & 255);
    tmp___4 = dlen;
    dlen ++;
    *(dst + tmp___4) = (char_u )(((unsigned int )key >> 8) & 255U);
  } else {
    tmp___5 = dlen;
    dlen ++;
    *(dst + tmp___5) = (char_u )key;
  }
  return (dlen);
}
}
int find_special_key(char_u **srcp , int *modp , int keycode ) 
{ 
  char_u *last_dash ;
  char_u *end_of_name ;
  char_u *src ;
  char_u *bp___0 ;
  int modifiers ;
  int bit ;
  int key ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  src = *srcp;
  if ((int )*(src + 0) != 60) {
    return (0);
  }
  last_dash = src;
  bp___0 = src + 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*bp___0 == 45)) {
      {
      tmp = vim_isIDc((int )*bp___0);
      }
      if (! tmp) {
        goto while_break;
      }
    }
    if ((int )*bp___0 == 45) {
      last_dash = bp___0;
      if ((int )*(bp___0 + 1) != 0) {
        if ((int )*(bp___0 + 2) == 62) {
          bp___0 ++;
        }
      }
    }
    if ((int )*(bp___0 + 0) == 116) {
      if ((int )*(bp___0 + 1) == 95) {
        if (*(bp___0 + 2)) {
          if (*(bp___0 + 3)) {
            bp___0 += 3;
          }
        }
      }
    }
    bp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*bp___0 == 62) {
    end_of_name = bp___0 + 1;
    modifiers = 0;
    bp___0 = src + 1;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )bp___0 < (unsigned long )last_dash)) {
        goto while_break___0;
      }
      if ((int )*bp___0 != 45) {
        {
        bit = name_to_mod_mask((int )*bp___0);
        }
        if (bit == 0) {
          goto while_break___0;
        }
        modifiers |= bit;
      }
      bp___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )bp___0 >= (unsigned long )last_dash) {
      if (modifiers != 0) {
        if ((int )*(last_dash + 2) == 62) {
          key = (int )*(last_dash + 1);
        } else {
          {
          key = get_special_key_code(last_dash + 1);
          }
        }
      } else {
        {
        key = get_special_key_code(last_dash + 1);
        }
      }
      if (key != 0) {
        {
        key = simplify_key(key, & modifiers);
        }
        if (! keycode) {
          if (key == 107 + (98 << 8)) {
            key = '\b';
          } else { //Added block
          if (key == 107 + (68 << 8)) {
            key = 127;
          } else { //Added block
          if (key == 253 + (70 << 8)) {
            key = 127;
          }
          }
          }
        }
        if (! (key >= 512)) {
          if (modifiers & 2) {
            {
            tmp___0 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___0 + key) & 1024) {
              {
              key = toupper(key);
              modifiers &= -3;
              }
            }
          }
          if (modifiers & 4) {
            if (key >= 63) {
              if (key <= 95) {
                goto _L;
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              {
              tmp___1 = __ctype_b_loc();
              }
              if ((int const   )*(*tmp___1 + key) & 1024) {
                _L: 
                if (key == 63) {
                  key = 127;
                } else {
                  key &= 31;
                }
                modifiers &= -5;
              }
            }
          }
          if (modifiers & 8) {
            if (key < 128) {
              key |= 128;
              modifiers &= -9;
            }
          }
        }
        *modp = modifiers;
        *srcp = end_of_name;
        return (key);
      }
    }
  }
  return (0);
}
}
int find_special_key_in_table(int c ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )key_names_table[i___0].name != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (c == key_names_table[i___0].key) {
      goto while_break;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )key_names_table[i___0].name == (unsigned long )((void *)0)) {
    i___0 = -1;
  }
  return (i___0);
}
}
int get_special_key_code(char_u *name___1 ) 
{ 
  char_u *table_name ;
  char_u string___0[3] ;
  int i___0 ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((int )*(name___1 + 0) == 116) {
    if ((int )*(name___1 + 1) == 95) {
      if ((int )*(name___1 + 2) != 0) {
        if ((int )*(name___1 + 3) != 0) {
          {
          string___0[0] = *(name___1 + 2);
          string___0[1] = *(name___1 + 3);
          string___0[2] = (char_u )'\000';
          tmp = add_termcap_entry(string___0, 0);
          }
          if (tmp == 1) {
            return ((int )*(name___1 + 2) + ((int )*(name___1 + 3) << 8));
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )key_names_table[i___0].name != (unsigned long )((void *)0))) {
        goto while_break;
      }
      table_name = key_names_table[i___0].name;
      j = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp___2 = vim_isIDc((int )*(name___1 + j));
        }
        if (tmp___2) {
          if (! ((int )*(table_name + j) != 0)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        {
        tmp___0 = tolower((int )*(table_name + j));
        tmp___1 = tolower((int )*(name___1 + j));
        }
        if (tmp___0 != tmp___1) {
          goto while_break___0;
        }
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      tmp___3 = vim_isIDc((int )*(name___1 + j));
      }
      if (! tmp___3) {
        if ((int )*(table_name + j) == 0) {
          return (key_names_table[i___0].key);
        }
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (0);
}
}
char_u *get_key_name(int i___0 ) 
{ 


  {
  if ((unsigned long )i___0 >= sizeof(key_names_table) / sizeof(struct key_name_entry )) {
    return ((char_u *)((void *)0));
  }
  return (key_names_table[i___0].name);
}
}
int get_mouse_button(int code , int *is_click , int *is_drag ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! mouse_table[i___0].pseudo_code) {
      goto while_break;
    }
    if (code == mouse_table[i___0].pseudo_code) {
      *is_click = mouse_table[i___0].is_click;
      *is_drag = mouse_table[i___0].is_drag;
      return (mouse_table[i___0].button);
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int get_pseudo_mouse_code(int button , int is_click , int is_drag ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! mouse_table[i___0].pseudo_code) {
      goto while_break;
    }
    if (button == mouse_table[i___0].button) {
      if (is_click == mouse_table[i___0].is_click) {
        if (is_drag == mouse_table[i___0].is_drag) {
          return (mouse_table[i___0].pseudo_code);
        }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (51);
}
}
int get_fileformat(BUF *buf___3 ) 
{ 
  int c ;

  {
  c = (int )*(buf___3->b_p_ff);
  if (buf___3->b_p_bin) {
    return (0);
  } else { //Added block
  if (c == 117) {
    return (0);
  }
  }
  if (c == 109) {
    return (2);
  }
  return (1);
}
}
void set_fileformat(int t ) 
{ 


  {
  {
  if (t == 1) {
    goto case_1;
  }
  if (t == 0) {
    goto case_0;
  }
  if (t == 2) {
    goto case_2;
  }
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  set_string_option_direct((char_u *)"ff", -1, (char_u *)"dos", 1);
  curbuf->b_p_tx = 1;
  }
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  set_string_option_direct((char_u *)"ff", -1, (char_u *)"unix", 1);
  curbuf->b_p_tx = 0;
  }
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  set_string_option_direct((char_u *)"ff", -1, (char_u *)"mac", 1);
  curbuf->b_p_tx = 0;
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  check_status(curbuf);
  }
  return;
}
}
int default_fileformat(void) 
{ 


  {
  {
  if ((int )*p_ffs == 109) {
    goto case_109;
  }
  if ((int )*p_ffs == 100) {
    goto case_100;
  }
  goto switch_break;
  case_109: /* CIL Label */ 
  return (2);
  case_100: /* CIL Label */ 
  return (1);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
int call_shell(char_u *cmd , int opt ) 
{ 
  char_u *ncmd ;
  int retval ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  tag_freematch();
  }
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
    {
    retval = mch_call_shell(cmd, opt);
    }
  } else { //Added block
  if ((int )*p_sxq == 0) {
    {
    retval = mch_call_shell(cmd, opt);
    }
  } else {
    {
    tmp = strlen((char const   *)((char *)cmd));
    tmp___0 = strlen((char const   *)((char *)p_sxq));
    ncmd = alloc((unsigned int )((tmp + tmp___0 * 2UL) + 1UL));
    }
    if ((unsigned long )ncmd != (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )((char *)ncmd), (char const   * __restrict  )((char *)p_sxq));
      strcat((char * __restrict  )((char *)ncmd), (char const   * __restrict  )((char *)cmd));
      strcat((char * __restrict  )((char *)ncmd), (char const   * __restrict  )((char *)p_sxq));
      retval = mch_call_shell(ncmd, opt);
      vim_free((void *)ncmd);
      }
    } else {
      retval = -1;
    }
  }
  }
  {
  set_vim_var_nr(5, (long )retval);
  }
  return (retval);
}
}
int get_real_state(void) 
{ 


  {
  if (State & 1) {
    if (VIsual_active) {
      return (2);
    } else { //Added block
    if (finish_op) {
      return (4);
    }
    }
  }
  return (State);
}
}
int vim_chdirfile(char_u *fname ) 
{ 
  char_u temp_string[1024] ;
  char_u *p___0 ;
  char_u *t ;
  int tmp ;
  int tmp___0 ;

  {
  {
  strcpy((char * __restrict  )((char *)(temp_string)), (char const   * __restrict  )((char *)fname));
  p___0 = get_past_head(temp_string);
  t = gettail(temp_string);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )t > (unsigned long )p___0) {
      {
      tmp = vim_ispathsep((int )*(t + -1));
      }
      if (! tmp) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    t --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *t = (char_u )'\000';
  tmp___0 = chdir((char const   *)((char *)(temp_string)));
  }
  return (tmp___0);
}
}
ulg crc_32_tab[256]  = 
  {      (ulg )0L,      (ulg )1996959894L,      (ulg )3993919788L,      (ulg )2567524794L, 
        (ulg )124634137L,      (ulg )1886057615L,      (ulg )3915621685L,      (ulg )2657392035L, 
        (ulg )249268274L,      (ulg )2044508324L,      (ulg )3772115230L,      (ulg )2547177864L, 
        (ulg )162941995L,      (ulg )2125561021L,      (ulg )3887607047L,      (ulg )2428444049L, 
        (ulg )498536548L,      (ulg )1789927666L,      (ulg )4089016648L,      (ulg )2227061214L, 
        (ulg )450548861L,      (ulg )1843258603L,      (ulg )4107580753L,      (ulg )2211677639L, 
        (ulg )325883990L,      (ulg )1684777152L,      (ulg )4251122042L,      (ulg )2321926636L, 
        (ulg )335633487L,      (ulg )1661365465L,      (ulg )4195302755L,      (ulg )2366115317L, 
        (ulg )997073096L,      (ulg )1281953886L,      (ulg )3579855332L,      (ulg )2724688242L, 
        (ulg )1006888145L,      (ulg )1258607687L,      (ulg )3524101629L,      (ulg )2768942443L, 
        (ulg )901097722L,      (ulg )1119000684L,      (ulg )3686517206L,      (ulg )2898065728L, 
        (ulg )853044451L,      (ulg )1172266101L,      (ulg )3705015759L,      (ulg )2882616665L, 
        (ulg )651767980L,      (ulg )1373503546L,      (ulg )3369554304L,      (ulg )3218104598L, 
        (ulg )565507253L,      (ulg )1454621731L,      (ulg )3485111705L,      (ulg )3099436303L, 
        (ulg )671266974L,      (ulg )1594198024L,      (ulg )3322730930L,      (ulg )2970347812L, 
        (ulg )795835527L,      (ulg )1483230225L,      (ulg )3244367275L,      (ulg )3060149565L, 
        (ulg )1994146192L,      (ulg )31158534L,      (ulg )2563907772L,      (ulg )4023717930L, 
        (ulg )1907459465L,      (ulg )112637215L,      (ulg )2680153253L,      (ulg )3904427059L, 
        (ulg )2013776290L,      (ulg )251722036L,      (ulg )2517215374L,      (ulg )3775830040L, 
        (ulg )2137656763L,      (ulg )141376813L,      (ulg )2439277719L,      (ulg )3865271297L, 
        (ulg )1802195444L,      (ulg )476864866L,      (ulg )2238001368L,      (ulg )4066508878L, 
        (ulg )1812370925L,      (ulg )453092731L,      (ulg )2181625025L,      (ulg )4111451223L, 
        (ulg )1706088902L,      (ulg )314042704L,      (ulg )2344532202L,      (ulg )4240017532L, 
        (ulg )1658658271L,      (ulg )366619977L,      (ulg )2362670323L,      (ulg )4224994405L, 
        (ulg )1303535960L,      (ulg )984961486L,      (ulg )2747007092L,      (ulg )3569037538L, 
        (ulg )1256170817L,      (ulg )1037604311L,      (ulg )2765210733L,      (ulg )3554079995L, 
        (ulg )1131014506L,      (ulg )879679996L,      (ulg )2909243462L,      (ulg )3663771856L, 
        (ulg )1141124467L,      (ulg )855842277L,      (ulg )2852801631L,      (ulg )3708648649L, 
        (ulg )1342533948L,      (ulg )654459306L,      (ulg )3188396048L,      (ulg )3373015174L, 
        (ulg )1466479909L,      (ulg )544179635L,      (ulg )3110523913L,      (ulg )3462522015L, 
        (ulg )1591671054L,      (ulg )702138776L,      (ulg )2966460450L,      (ulg )3352799412L, 
        (ulg )1504918807L,      (ulg )783551873L,      (ulg )3082640443L,      (ulg )3233442989L, 
        (ulg )3988292384L,      (ulg )2596254646L,      (ulg )62317068L,      (ulg )1957810842L, 
        (ulg )3939845945L,      (ulg )2647816111L,      (ulg )81470997L,      (ulg )1943803523L, 
        (ulg )3814918930L,      (ulg )2489596804L,      (ulg )225274430L,      (ulg )2053790376L, 
        (ulg )3826175755L,      (ulg )2466906013L,      (ulg )167816743L,      (ulg )2097651377L, 
        (ulg )4027552580L,      (ulg )2265490386L,      (ulg )503444072L,      (ulg )1762050814L, 
        (ulg )4150417245L,      (ulg )2154129355L,      (ulg )426522225L,      (ulg )1852507879L, 
        (ulg )4275313526L,      (ulg )2312317920L,      (ulg )282753626L,      (ulg )1742555852L, 
        (ulg )4189708143L,      (ulg )2394877945L,      (ulg )397917763L,      (ulg )1622183637L, 
        (ulg )3604390888L,      (ulg )2714866558L,      (ulg )953729732L,      (ulg )1340076626L, 
        (ulg )3518719985L,      (ulg )2797360999L,      (ulg )1068828381L,      (ulg )1219638859L, 
        (ulg )3624741850L,      (ulg )2936675148L,      (ulg )906185462L,      (ulg )1090812512L, 
        (ulg )3747672003L,      (ulg )2825379669L,      (ulg )829329135L,      (ulg )1181335161L, 
        (ulg )3412177804L,      (ulg )3160834842L,      (ulg )628085408L,      (ulg )1382605366L, 
        (ulg )3423369109L,      (ulg )3138078467L,      (ulg )570562233L,      (ulg )1426400815L, 
        (ulg )3317316542L,      (ulg )2998733608L,      (ulg )733239954L,      (ulg )1555261956L, 
        (ulg )3268935591L,      (ulg )3050360625L,      (ulg )752459403L,      (ulg )1541320221L, 
        (ulg )2607071920L,      (ulg )3965973030L,      (ulg )1969922972L,      (ulg )40735498L, 
        (ulg )2617837225L,      (ulg )3943577151L,      (ulg )1913087877L,      (ulg )83908371L, 
        (ulg )2512341634L,      (ulg )3803740692L,      (ulg )2075208622L,      (ulg )213261112L, 
        (ulg )2463272603L,      (ulg )3855990285L,      (ulg )2094854071L,      (ulg )198958881L, 
        (ulg )2262029012L,      (ulg )4057260610L,      (ulg )1759359992L,      (ulg )534414190L, 
        (ulg )2176718541L,      (ulg )4139329115L,      (ulg )1873836001L,      (ulg )414664567L, 
        (ulg )2282248934L,      (ulg )4279200368L,      (ulg )1711684554L,      (ulg )285281116L, 
        (ulg )2405801727L,      (ulg )4167216745L,      (ulg )1634467795L,      (ulg )376229701L, 
        (ulg )2685067896L,      (ulg )3608007406L,      (ulg )1308918612L,      (ulg )956543938L, 
        (ulg )2808555105L,      (ulg )3495958263L,      (ulg )1231636301L,      (ulg )1047427035L, 
        (ulg )2932959818L,      (ulg )3654703836L,      (ulg )1088359270L,      (ulg )936918000L, 
        (ulg )2847714899L,      (ulg )3736837829L,      (ulg )1202900863L,      (ulg )817233897L, 
        (ulg )3183342108L,      (ulg )3401237130L,      (ulg )1404277552L,      (ulg )615818150L, 
        (ulg )3134207493L,      (ulg )3453421203L,      (ulg )1423857449L,      (ulg )601450431L, 
        (ulg )3009837614L,      (ulg )3294710456L,      (ulg )1567103746L,      (ulg )711928724L, 
        (ulg )3020668471L,      (ulg )3272380065L,      (ulg )1510334235L,      (ulg )755167117L};
static ulg keys[3]  ;
int decrypt_byte(void) 
{ 
  ush temp ;

  {
  temp = (ush )((int )((ush )keys[2]) | 2);
  return ((int )(((unsigned int )((int )temp * ((int )temp ^ 1)) >> 8) & 255U));
}
}
int update_keys(int c ) 
{ 


  {
  keys[0] = crc_32_tab[((int )keys[0] ^ c) & 255] ^ (keys[0] >> 8);
  keys[1] += keys[0] & 255UL;
  keys[1] = keys[1] * 134775813UL + 1UL;
  keys[2] = crc_32_tab[((int )keys[2] ^ (int )(keys[1] >> 24)) & 255] ^ (keys[2] >> 8);
  return (c);
}
}
void crypt_init_keys(char_u *passwd ) 
{ 
  char_u *tmp ;

  {
  if (passwd) {
    if (*passwd) {
      keys[0] = (ulg )305419896L;
      keys[1] = (ulg )591751049L;
      keys[2] = (ulg )878082192L;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((int )*passwd != 0)) {
          goto while_break;
        }
        {
        tmp = passwd;
        passwd ++;
        update_keys((int )*tmp);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
char_u *get_crypt_key(int store ) 
{ 
  char_u *p___0 ;

  {
  {
  cmdline_crypt = 1;
  cmdline_row = msg_row;
  p___0 = getcmdline_prompt('\000', (char_u *)"Enter encryption key: ", 0);
  cmdline_crypt = 0;
  need_wait_return = 0;
  msg_didout = 0;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if (store) {
      {
      set_option_value((char_u *)"key", 0L, p___0);
      }
      return (curbuf->b_p_key);
    }
  }
  return (p___0);
}
}
static char_u *name  =    (char_u *)((void *)0);
int get_user_name(char_u *buf___3 , int len___0 ) 
{ 
  int tmp ;

  {
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
    tmp = mch_get_user_name(buf___3, len___0);
    }
    if (tmp == 0) {
      return (0);
    }
    {
    name = vim_strsave(buf___3);
    }
  } else {
    {
    strncpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)name),
            (size_t )len___0);
    }
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-kll2qSdF.i","-O0")
#pragma merger("0","/tmp/cil-NdJb9vp2.i","-O0")
void do_pending_operator(CMDARG *cap , char_u *searchbuff , int *command_busy , int old_col ,
                         int gui_yank , int dont_adjust_op_end ) ;
void check_visual_highlight(void) ;
void check_scrollbind(linenr_t topline_diff , long leftcol_diff ) ;
void may_start_select(int c ) ;
int get_op_type(int char1 , int char2 ) ;
int op_on_lines(int op ) ;
int get_op_char(int optype ) ;
int get_extra_op_char(int optype ) ;
void op_reindent(OPARG *oap , int (*how)(void) ) ;
int yank_register_mline(int regname___0 ) ;
int do_record(int c ) ;
int op_replace(OPARG *oap , int c ) ;
void op_tilde(OPARG *oap ) ;
void swapchar(int op_type , FPOS *pos___0 ) ;
void op_insert(OPARG *oap , long count1 ) ;
int op_change(OPARG *oap ) ;
void op_format(OPARG *oap ) ;
int do_addsub(int command , linenr_t Prenum1 ) ;
void update_other_win(void) ;
void scroll_cursor_top(int min_scroll , int always ) ;
void scroll_cursor_bot(int min_scroll , int set_topbot ) ;
void validate_botline(void) ;
void halfpage(int flag , linenr_t Prenum ) ;
int searchc(int c , int dir , int type , long count___2 ) ;
int findsent(int dir , long count___2 ) ;
int findpar(OPARG *oap , int dir , long count___2 , int what , int both ) ;
int end_word(long count___2 , int type , int stop , int empty ) ;
int bckend_word(long count___2 , int type , int eol ) ;
int current_word(OPARG *oap , long count___2 , int include , int type ) ;
int current_sent(OPARG *oap , long count___2 , int include ) ;
int current_block(OPARG *oap , long count___2 , int include , int what , int other ) ;
int current_par(OPARG *oap , long count___2 , int include , int type ) ;
int mouse_model_popup(void) ;
void clip_auto_select(void) ;
void u_undoline(void) ;
void do_window(int nchar , long Prenum ) ;
static int resel_VIsual_mode  =    '\000';
static linenr_t resel_VIsual_line_count  ;
static colnr_t resel_VIsual_col  ;
static void op_colon(OPARG *oap ) ;
static void find_start_of_word(FPOS *pos___0 ) ;
static void find_end_of_word(FPOS *pos___0 ) ;
static int get_mouse_class(int c ) ;
static void prep_redo_cmd(CMDARG *cap ) ;
static void prep_redo(int regname___0 , long num , int cmd1 , int cmd2 , int cmd3 ,
                      int cmd4 ) ;
static int checkclearop(OPARG *oap ) ;
static int checkclearopq(OPARG *oap ) ;
static void clearop(OPARG *oap ) ;
static void clearopbeep(OPARG *oap ) ;
static void del_from_showcmd(int len___0 ) ;
static void nv_gd(OPARG *oap , int nchar ) ;
static int nv_screengo(OPARG *oap , int dir , long dist ) ;
static void nv_scroll_line(CMDARG *cap , int is_ctrl_e ) ;
static void nv_zet(CMDARG *cap ) ;
static void nv_colon(CMDARG *cap ) ;
static void nv_ctrlg(CMDARG *cap ) ;
static void nv_zzet(CMDARG *cap ) ;
static void nv_ident(CMDARG *cap , char_u **searchp ) ;
static void nv_scroll(CMDARG *cap ) ;
static void nv_right(CMDARG *cap ) ;
static int nv_left(CMDARG *cap ) ;
static void nv_gotofile(CMDARG *cap ) ;
static void nv_dollar(CMDARG *cap ) ;
static void nv_search(CMDARG *cap , char_u **searchp , int dont_set_mark ) ;
static void nv_next(CMDARG *cap , int flag ) ;
static void nv_csearch(CMDARG *cap , int dir , int type ) ;
static void nv_brackets(CMDARG *cap , int dir ) ;
static void nv_percent(CMDARG *cap ) ;
static void nv_brace(CMDARG *cap , int dir ) ;
static void nv_findpar(CMDARG *cap , int dir ) ;
static int nv_Replace(CMDARG *cap ) ;
static int nv_VReplace(CMDARG *cap ) ;
static int nv_vreplace(CMDARG *cap ) ;
static void v_swap_corners(CMDARG *cap ) ;
static int nv_replace(CMDARG *cap ) ;
static void n_swapchar(CMDARG *cap ) ;
static void nv_cursormark(CMDARG *cap , int flag , FPOS *pos___0 ) ;
static void v_visop(CMDARG *cap ) ;
static void nv_optrans(CMDARG *cap ) ;
static void nv_gomark(CMDARG *cap , int flag ) ;
static void nv_pcmark(CMDARG *cap ) ;
static void nv_regname(CMDARG *cap , linenr_t *opnump ) ;
static void nv_visual(CMDARG *cap , int selectmode ) ;
static void n_start_visual_mode(int c ) ;
static int nv_g_cmd(CMDARG *cap , char_u **searchp ) ;
static int n_opencmd(CMDARG *cap ) ;
static void nv_Undo(CMDARG *cap ) ;
static void nv_operator(CMDARG *cap ) ;
static void nv_lineop(CMDARG *cap ) ;
static void nv_pipe(CMDARG *cap ) ;
static void nv_bck_word(CMDARG *cap , int type ) ;
static void nv_wordcmd(CMDARG *cap , int type ) ;
static void adjust_for_sel(CMDARG *cap ) ;
static void unadjust_for_sel(void) ;
static void nv_goto(CMDARG *cap , linenr_t lnum ) ;
static void nv_select(CMDARG *cap ) ;
static void nv_normal(CMDARG *cap ) ;
static void nv_esc(CMDARG *cap , linenr_t opnum___0 ) ;
static int nv_edit(CMDARG *cap ) ;
static void nv_object(CMDARG *cap ) ;
static void nv_q(CMDARG *cap ) ;
static void nv_at(CMDARG *cap ) ;
static void nv_halfpage(CMDARG *cap ) ;
static void nv_join(CMDARG *cap ) ;
static void nv_put(CMDARG *cap ) ;
static linenr_t opnum  =    (linenr_t )0;
static int restart_VIsual_select  =    0;
static int old_mapped_len  =    0;
static int seltab[42]  = 
  {      37 + (105 << 8),      107 + (114 << 8),      1,      35 + (52 << 8), 
        107 + (108 << 8),      1,      253 + (4 << 8),      107 + (117 << 8), 
        1,      253 + (5 << 8),      107 + (100 << 8),      1, 
        35 + (50 << 8),      107 + (104 << 8),      1,      42 + (55 << 8), 
        64 + (55 << 8),      1,      75 + (49 << 8),      75 + (49 << 8), 
        0,      253 + (60 << 8),      253 + (60 << 8),      0, 
        75 + (52 << 8),      75 + (52 << 8),      0,      253 + (59 << 8), 
        75 + (52 << 8),      0,      107 + (80 << 8),      107 + (80 << 8), 
        0,      75 + (51 << 8),      75 + (51 << 8),      0, 
        107 + (78 << 8),      107 + (78 << 8),      0,      75 + (53 << 8), 
        75 + (53 << 8),      0};
void normal_cmd(OPARG *oap , int toplevel ) 
{ 
  CMDARG ca ;
  int c ;
  int flag ;
  int type ;
  int dir ;
  char_u *searchbuff ;
  int command_busy ;
  int ctrl_w ;
  int old_col ;
  int dont_adjust_op_end ;
  FPOS old_pos ;
  int need_flushbuf ;
  int mapped_len ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int i___0 ;
  char_u *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char_u *tmp___31 ;
  int save_State ;
  char_u *kmsg ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
  {
  flag = 0;
  type = 0;
  dir = 1;
  searchbuff = (char_u *)((void *)0);
  command_busy = 0;
  ctrl_w = 0;
  old_col = (int )curwin->w_curswant;
  dont_adjust_op_end = 0;
  do_check_scrollbind(0);
  memset((void *)(& ca), 0, sizeof(ca));
  ca.oap = oap;
  finish_op = oap->op_type != 0;
  }
  if (! finish_op) {
    if (! oap->regname) {
      opnum = (linenr_t )0;
    }
  }
  {
  mapped_len = typebuf_maplen();
  State = 257;
  c = safe_vgetc();
  }
  if (! restart_edit) {
    old_mapped_len = 0;
  } else { //Added block
  if (old_mapped_len) {
    {
    old_mapped_len = typebuf_maplen();
    }
  } else { //Added block
  if (VIsual_active) {
    if (mapped_len == 0) {
      {
      tmp = typebuf_maplen();
      }
      if (tmp > 0) {
        {
        old_mapped_len = typebuf_maplen();
        }
      }
    }
  }
  }
  }
  if (c == 0) {
    c = 255 + (88 << 8);
  } else { //Added block
  if (c == 75 + (57 << 8)) {
    c = '*';
  } else { //Added block
  if (c == 75 + (55 << 8)) {
    c = '-';
  } else { //Added block
  if (c == 75 + (54 << 8)) {
    c = '+';
  } else { //Added block
  if (c == 75 + (56 << 8)) {
    c = '/';
  }
  }
  }
  }
  }
  if (VIsual_active) {
    if (VIsual_select) {
      {
      tmp___0 = vim_isprintc(c);
      }
      if (tmp___0) {
        {
        stuffcharReadbuff(c);
        c = 'c';
        }
      } else { //Added block
      if (c == 10) {
        {
        stuffcharReadbuff(c);
        c = 'c';
        }
      } else { //Added block
      if (c == 13) {
        {
        stuffcharReadbuff(c);
        c = 'c';
        }
      } else { //Added block
      if (c == 75 + (65 << 8)) {
        {
        stuffcharReadbuff(c);
        c = 'c';
        }
      }
      }
      }
      }
    }
    {
    tmp___1 = vim_strchr(p_km, 'o');
    }
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
      if (c == 107 + (117 << 8)) {
        goto case_exp;
      }
      if (c == 16) {
        goto case_exp;
      }
      if (c == 107 + (100 << 8)) {
        goto case_exp;
      }
      if (c == 14) {
        goto case_exp;
      }
      if (c == 107 + (108 << 8)) {
        goto case_exp;
      }
      if (c == 107 + (114 << 8)) {
        goto case_exp;
      }
      if (c == 2) {
        goto case_exp;
      }
      if (c == 107 + (80 << 8)) {
        goto case_exp;
      }
      if (c == 75 + (51 << 8)) {
        goto case_exp;
      }
      if (c == 6) {
        goto case_exp;
      }
      if (c == 107 + (78 << 8)) {
        goto case_exp;
      }
      if (c == 75 + (53 << 8)) {
        goto case_exp;
      }
      if (c == 107 + (104 << 8)) {
        goto case_exp;
      }
      if (c == 75 + (49 << 8)) {
        goto case_exp;
      }
      if (c == 253 + (60 << 8)) {
        goto case_exp;
      }
      if (c == 64 + (55 << 8)) {
        goto case_exp;
      }
      if (c == 75 + (52 << 8)) {
        goto case_exp;
      }
      if (c == 253 + (59 << 8)) {
        goto case_exp;
      }
      goto switch_break;
      case_exp: /* CIL Label */ 
      case_16: /* CIL Label */ 
      case_exp___0: /* CIL Label */ 
      case_14: /* CIL Label */ 
      case_exp___1: /* CIL Label */ 
      case_exp___2: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_exp___3: /* CIL Label */ 
      case_exp___4: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_exp___5: /* CIL Label */ 
      case_exp___6: /* CIL Label */ 
      case_exp___7: /* CIL Label */ 
      case_exp___8: /* CIL Label */ 
      case_exp___9: /* CIL Label */ 
      case_exp___10: /* CIL Label */ 
      case_exp___11: /* CIL Label */ 
      case_exp___12: /* CIL Label */ 
      if (! (mod_mask & 2)) {
        {
        end_visual_mode();
        redraw_curbuf_later(40);
        }
      }
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
    tmp___2 = vim_strchr(p_km, 'a');
    }
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
      if (c == 253 + (4 << 8)) {
        goto case_exp___13;
      }
      if (c == 253 + (5 << 8)) {
        goto case_exp___14;
      }
      if (c == 35 + (52 << 8)) {
        goto case_exp___15;
      }
      if (c == 37 + (105 << 8)) {
        goto case_exp___16;
      }
      if (c == 35 + (50 << 8)) {
        goto case_exp___17;
      }
      if (c == 42 + (55 << 8)) {
        goto case_exp___18;
      }
      if (c == 107 + (80 << 8)) {
        goto case_exp___19;
      }
      if (c == 75 + (51 << 8)) {
        goto case_exp___19;
      }
      if (c == 107 + (78 << 8)) {
        goto case_exp___19;
      }
      if (c == 75 + (53 << 8)) {
        goto case_exp___19;
      }
      if (c == 75 + (49 << 8)) {
        goto case_exp___19;
      }
      if (c == 253 + (60 << 8)) {
        goto case_exp___19;
      }
      if (c == 75 + (52 << 8)) {
        goto case_exp___19;
      }
      if (c == 253 + (59 << 8)) {
        goto case_exp___19;
      }
      goto switch_break___0;
      case_exp___13: /* CIL Label */ 
      c = 107 + (117 << 8);
      goto switch_break___0;
      case_exp___14: /* CIL Label */ 
      c = 107 + (100 << 8);
      goto switch_break___0;
      case_exp___15: /* CIL Label */ 
      c = 107 + (108 << 8);
      goto switch_break___0;
      case_exp___16: /* CIL Label */ 
      c = 107 + (114 << 8);
      goto switch_break___0;
      case_exp___17: /* CIL Label */ 
      c = 107 + (104 << 8);
      goto switch_break___0;
      case_exp___18: /* CIL Label */ 
      c = 64 + (55 << 8);
      goto switch_break___0;
      case_exp___19: /* CIL Label */ 
      case_exp___20: /* CIL Label */ 
      case_exp___21: /* CIL Label */ 
      case_exp___22: /* CIL Label */ 
      case_exp___23: /* CIL Label */ 
      case_exp___24: /* CIL Label */ 
      case_exp___25: /* CIL Label */ 
      case_exp___26: /* CIL Label */ 
      mod_mask = 0;
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  {
  need_flushbuf = add_to_showcmd(c);
  }
  getcount: 
  if (VIsual_active) {
    if (! VIsual_select) {
      goto _L___0;
    }
  } else {
    _L___0: 
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (c >= 49) {
        if (! (c <= 57)) {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (ca.count0 != 0L) {
        if (! (c == 107 + (68 << 8))) {
          if (! (c == 253 + (70 << 8))) {
            if (! (c == 48)) {
              goto while_break;
            }
          }
        }
      } else {
        goto while_break;
      }
      }
      if (c == 107 + (68 << 8)) {
        {
        ca.count0 /= 10L;
        del_from_showcmd(4);
        }
      } else { //Added block
      if (c == 253 + (70 << 8)) {
        {
        ca.count0 /= 10L;
        del_from_showcmd(4);
        }
      } else {
        ca.count0 = ca.count0 * 10L + (long )(c - 48);
      }
      }
      if (ca.count0 < 0L) {
        ca.count0 = 999999999L;
      }
      if (ctrl_w) {
        no_mapping ++;
        allow_keys ++;
      }
      {
      c = safe_vgetc();
      }
      if (ctrl_w) {
        no_mapping --;
        allow_keys --;
      }
      {
      tmp___3 = add_to_showcmd(c);
      need_flushbuf |= tmp___3;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (c == 23) {
      if (! ctrl_w) {
        if (oap->op_type == 0) {
          {
          ctrl_w = 1;
          opnum = ca.count0;
          ca.count0 = 0L;
          no_mapping ++;
          allow_keys ++;
          c = safe_vgetc();
          no_mapping --;
          allow_keys --;
          tmp___4 = add_to_showcmd(c);
          need_flushbuf |= tmp___4;
          }
          goto getcount;
        }
      }
    }
  }
  ca.cmdchar = c;
  if (opnum != 0L) {
    if (ca.count0) {
      ca.count0 *= opnum;
    } else {
      ca.count0 = opnum;
    }
  }
  opnum = ca.count0;
  if (ca.count0 == 0L) {
    ca.count1 = 1L;
  } else {
    ca.count1 = ca.count0;
  }
  if (toplevel) {
    {
    set_vim_var_nr(0, ca.count0);
    set_vim_var_nr(1, ca.count1);
    }
  }
  if (ctrl_w) {
    ca.nchar = ca.cmdchar;
    ca.cmdchar = 23;
  } else { //Added block
  if (oap->op_type == 0) {
    {
    tmp___7 = vim_strchr((char_u *)"@zm\"", ca.cmdchar);
    }
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      goto _L___2;
    } else {
      goto _L___8;
    }
  } else { //Added block
  _L___8: 
  if (oap->op_type == 0) {
    if (ca.cmdchar == 114) {
      goto _L___2;
    } else { //Added block
    if (! VIsual_active) {
      if (ca.cmdchar == 90) {
        goto _L___2;
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
    }
  } else {
    _L___7: 
    {
    tmp___8 = vim_strchr((char_u *)"tTfF[]g\'`", ca.cmdchar);
    }
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
      goto _L___2;
    } else { //Added block
    if (ca.cmdchar == 113) {
      if (oap->op_type == 0) {
        if (! Recording) {
          if (! Exec_reg) {
            goto _L___2;
          } else {
            goto _L___6;
          }
        } else {
          goto _L___6;
        }
      } else {
        goto _L___6;
      }
    } else { //Added block
    _L___6: 
    if (ca.cmdchar == 97) {
      goto _L___3;
    } else { //Added block
    if (ca.cmdchar == 105) {
      _L___3: 
      if (oap->op_type != 0) {
        goto _L___2;
      } else { //Added block
      if (VIsual_active) {
        _L___2: 
        no_mapping ++;
        allow_keys ++;
        if (ca.cmdchar == 103) {
          {
          ca.nchar = safe_vgetc();
          }
        }
        if (ca.cmdchar != 103) {
          {
          ca.nchar = safe_vgetc();
          }
        } else { //Added block
        if (ca.nchar == 114) {
          {
          ca.extra_char = safe_vgetc();
          }
        }
        }
        {
        no_mapping --;
        allow_keys --;
        tmp___5 = add_to_showcmd(ca.nchar);
        need_flushbuf |= tmp___5;
        }
        if (ca.cmdchar == 103) {
          if (ca.nchar == 114) {
            {
            tmp___6 = add_to_showcmd(ca.extra_char);
            need_flushbuf |= tmp___6;
            }
          }
        }
      }
      }
    }
    }
    }
    }
  }
  }
  }
  if (need_flushbuf) {
    {
    out_flush();
    }
  }
  State = 1;
  if (ca.nchar == 27) {
    {
    clearop(oap);
    }
    if (p_im) {
      if (! restart_edit) {
        restart_edit = 'a';
      }
    }
    goto normal_end;
  }
  if (! VIsual_active) {
    {
    tmp___9 = vim_strchr(p_km, 'a');
    }
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
      i___0 = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )i___0 < sizeof(seltab) / sizeof(int ))) {
          goto while_break___0;
        }
        if (seltab[i___0] == ca.cmdchar) {
          if (seltab[i___0 + 2]) {
            {
            ca.cmdchar = seltab[i___0 + 1];
            start_selection();
            }
            goto while_break___0;
          } else { //Added block
          if (mod_mask & 2) {
            {
            ca.cmdchar = seltab[i___0 + 1];
            start_selection();
            }
            goto while_break___0;
          }
          }
        }
        i___0 += 3;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  msg_didout = 0;
  msg_col = 0;
  old_pos = curwin->w_cursor;
  {
  if (ca.cmdchar == 113) {
    goto case_113;
  }
  if (ca.cmdchar == 64) {
    goto case_64;
  }
  if (ca.cmdchar == 4) {
    goto case_4;
  }
  if (ca.cmdchar == 21) {
    goto case_4;
  }
  if (ca.cmdchar == 2) {
    goto case_2___0;
  }
  if (ca.cmdchar == 253 + (4 << 8)) {
    goto case_2___0;
  }
  if (ca.cmdchar == 107 + (80 << 8)) {
    goto case_2___0;
  }
  if (ca.cmdchar == 75 + (51 << 8)) {
    goto case_2___0;
  }
  if (ca.cmdchar == 6) {
    goto case_6___0;
  }
  if (ca.cmdchar == 253 + (5 << 8)) {
    goto case_6___0;
  }
  if (ca.cmdchar == 107 + (78 << 8)) {
    goto case_6___0;
  }
  if (ca.cmdchar == 75 + (53 << 8)) {
    goto case_6___0;
  }
  if (ca.cmdchar == 5) {
    goto case_5;
  }
  if (ca.cmdchar == 25) {
    goto case_25;
  }
  if (ca.cmdchar == 253 + (68 << 8)) {
    goto case_exp___33;
  }
  if (ca.cmdchar == 253 + (67 << 8)) {
    goto case_exp___34;
  }
  if (ca.cmdchar == 122) {
    goto case_122;
  }
  if (ca.cmdchar == 58) {
    goto case_58;
  }
  if (ca.cmdchar == 81) {
    goto case_81;
  }
  if (ca.cmdchar == 37 + (49 << 8)) {
    goto case_exp___35;
  }
  if (ca.cmdchar == 107 + (49 << 8)) {
    goto case_exp___35;
  }
  if (ca.cmdchar == 253 + (55 << 8)) {
    goto case_exp___35;
  }
  if (ca.cmdchar == 12) {
    goto case_12;
  }
  if (ca.cmdchar == 7) {
    goto case_7;
  }
  if (ca.cmdchar == 30) {
    goto case_30;
  }
  if (ca.cmdchar == 90) {
    goto case_90;
  }
  if (ca.cmdchar == 163) {
    goto case_163;
  }
  if (ca.cmdchar == 29) {
    goto case_29;
  }
  if (ca.cmdchar == 75) {
    goto case_29;
  }
  if (ca.cmdchar == 42) {
    goto case_29;
  }
  if (ca.cmdchar == 75 + (57 << 8)) {
    goto case_29;
  }
  if (ca.cmdchar == 35) {
    goto case_29;
  }
  if (ca.cmdchar == 20) {
    goto case_20;
  }
  if (ca.cmdchar == 71) {
    goto case_71;
  }
  if (ca.cmdchar == 72) {
    goto case_72;
  }
  if (ca.cmdchar == 77) {
    goto case_72;
  }
  if (ca.cmdchar == 76) {
    goto case_72;
  }
  if (ca.cmdchar == 107 + (114 << 8)) {
    goto case_exp___39;
  }
  if (ca.cmdchar == 108) {
    goto case_108;
  }
  if (ca.cmdchar == 32) {
    goto case_108;
  }
  if (ca.cmdchar == 107 + (108 << 8)) {
    goto case_exp___40;
  }
  if (ca.cmdchar == 104) {
    goto case_104;
  }
  if (ca.cmdchar == 107 + (98 << 8)) {
    goto case_exp___41;
  }
  if (ca.cmdchar == 8) {
    goto case_exp___41;
  }
  if (ca.cmdchar == 45) {
    goto case_45;
  }
  if (ca.cmdchar == 75 + (55 << 8)) {
    goto case_45;
  }
  if (ca.cmdchar == 107) {
    goto case_107;
  }
  if (ca.cmdchar == 107 + (117 << 8)) {
    goto case_107;
  }
  if (ca.cmdchar == 16) {
    goto case_107;
  }
  if (ca.cmdchar == 43) {
    goto case_43;
  }
  if (ca.cmdchar == 75 + (54 << 8)) {
    goto case_43;
  }
  if (ca.cmdchar == 13) {
    goto case_43;
  }
  if (ca.cmdchar == 75 + (65 << 8)) {
    goto case_43;
  }
  if (ca.cmdchar == 106) {
    goto case_106;
  }
  if (ca.cmdchar == 107 + (100 << 8)) {
    goto case_106;
  }
  if (ca.cmdchar == 14) {
    goto case_106;
  }
  if (ca.cmdchar == 10) {
    goto case_106;
  }
  if (ca.cmdchar == 95) {
    goto case_95;
  }
  if (ca.cmdchar == 107 + (104 << 8)) {
    goto case_exp___47;
  }
  if (ca.cmdchar == 75 + (49 << 8)) {
    goto case_exp___47;
  }
  if (ca.cmdchar == 253 + (60 << 8)) {
    goto case_exp___47;
  }
  if (ca.cmdchar == 35 + (50 << 8)) {
    goto case_exp___47;
  }
  if (ca.cmdchar == 124) {
    goto case_124;
  }
  if (ca.cmdchar == 66) {
    goto case_66;
  }
  if (ca.cmdchar == 98) {
    goto case_98;
  }
  if (ca.cmdchar == 35 + (52 << 8)) {
    goto case_98;
  }
  if (ca.cmdchar == 69) {
    goto case_69;
  }
  if (ca.cmdchar == 101) {
    goto case_101;
  }
  if (ca.cmdchar == 87) {
    goto case_87;
  }
  if (ca.cmdchar == 119) {
    goto case_119;
  }
  if (ca.cmdchar == 37 + (105 << 8)) {
    goto case_119;
  }
  if (ca.cmdchar == 64 + (55 << 8)) {
    goto case_exp___53;
  }
  if (ca.cmdchar == 75 + (52 << 8)) {
    goto case_exp___53;
  }
  if (ca.cmdchar == 253 + (59 << 8)) {
    goto case_exp___53;
  }
  if (ca.cmdchar == 42 + (55 << 8)) {
    goto case_exp___53;
  }
  if (ca.cmdchar == 36) {
    goto case_36;
  }
  if (ca.cmdchar == 94) {
    goto case_94;
  }
  if (ca.cmdchar == 48) {
    goto case_48;
  }
  if (ca.cmdchar == 75 + (56 << 8)) {
    goto case_exp___57;
  }
  if (ca.cmdchar == 63) {
    goto case_63;
  }
  if (ca.cmdchar == 47) {
    goto case_63;
  }
  if (ca.cmdchar == 78) {
    goto case_78;
  }
  if (ca.cmdchar == 110) {
    goto case_110;
  }
  if (ca.cmdchar == 84) {
    goto case_84;
  }
  if (ca.cmdchar == 116) {
    goto case_116;
  }
  if (ca.cmdchar == 70) {
    goto case_70;
  }
  if (ca.cmdchar == 102) {
    goto case_102;
  }
  if (ca.cmdchar == 44) {
    goto case_44;
  }
  if (ca.cmdchar == 59) {
    goto case_59;
  }
  if (ca.cmdchar == 91) {
    goto case_91;
  }
  if (ca.cmdchar == 93) {
    goto case_93;
  }
  if (ca.cmdchar == 37) {
    goto case_37;
  }
  if (ca.cmdchar == 40) {
    goto case_40;
  }
  if (ca.cmdchar == 41) {
    goto case_41;
  }
  if (ca.cmdchar == 123) {
    goto case_123;
  }
  if (ca.cmdchar == 125) {
    goto case_125;
  }
  if (ca.cmdchar == 46) {
    goto case_46;
  }
  if (ca.cmdchar == 117) {
    goto case_117;
  }
  if (ca.cmdchar == 38 + (56 << 8)) {
    goto case_exp___58;
  }
  if (ca.cmdchar == 18) {
    goto case_18;
  }
  if (ca.cmdchar == 85) {
    goto case_85;
  }
  if (ca.cmdchar == 114) {
    goto case_114;
  }
  if (ca.cmdchar == 74) {
    goto case_74;
  }
  if (ca.cmdchar == 80) {
    goto case_80;
  }
  if (ca.cmdchar == 112) {
    goto case_80;
  }
  if (ca.cmdchar == 1) {
    goto case_1;
  }
  if (ca.cmdchar == 24) {
    goto case_1;
  }
  if (ca.cmdchar == 65) {
    goto case_65;
  }
  if (ca.cmdchar == 97) {
    goto case_65;
  }
  if (ca.cmdchar == 73) {
    goto case_65;
  }
  if (ca.cmdchar == 105) {
    goto case_65;
  }
  if (ca.cmdchar == 107 + (73 << 8)) {
    goto case_65;
  }
  if (ca.cmdchar == 253 + (69 << 8)) {
    goto case_65;
  }
  if (ca.cmdchar == 111) {
    goto case_111;
  }
  if (ca.cmdchar == 79) {
    goto case_111;
  }
  if (ca.cmdchar == 82) {
    goto case_82;
  }
  if (ca.cmdchar == 126) {
    goto case_126;
  }
  if (ca.cmdchar == 100) {
    goto case_100;
  }
  if (ca.cmdchar == 99) {
    goto case_100;
  }
  if (ca.cmdchar == 121) {
    goto case_100;
  }
  if (ca.cmdchar == 62) {
    goto case_100;
  }
  if (ca.cmdchar == 60) {
    goto case_100;
  }
  if (ca.cmdchar == 33) {
    goto case_100;
  }
  if (ca.cmdchar == 61) {
    goto case_100;
  }
  if (ca.cmdchar == 83) {
    goto case_83;
  }
  if (ca.cmdchar == 115) {
    goto case_83;
  }
  if (ca.cmdchar == 107 + (68 << 8)) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 253 + (70 << 8)) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 89) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 68) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 67) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 120) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 88) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 38) {
    goto case_38;
  }
  if (ca.cmdchar == 109) {
    goto case_109;
  }
  if (ca.cmdchar == 39) {
    goto case_39;
  }
  if (ca.cmdchar == 96) {
    goto case_96;
  }
  if (ca.cmdchar == 15) {
    goto case_15;
  }
  if (ca.cmdchar == 9) {
    goto case_9;
  }
  if (ca.cmdchar == 34) {
    goto case_34;
  }
  if (ca.cmdchar == 118) {
    goto case_118;
  }
  if (ca.cmdchar == 86) {
    goto case_118;
  }
  if (ca.cmdchar == 22) {
    goto case_118;
  }
  if (ca.cmdchar == 26) {
    goto case_26;
  }
  if (ca.cmdchar == 23) {
    goto case_23;
  }
  if (ca.cmdchar == 103) {
    goto case_103;
  }
  if (ca.cmdchar == 253 + (42 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (61 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (43 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (44 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (62 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (45 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (46 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (47 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (48 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (49 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (50 << 8)) {
    goto case_exp___63;
  }
  if (ca.cmdchar == 253 + (51 << 8)) {
    goto case_exp___74;
  }
  if (ca.cmdchar == 245 + (88 << 8)) {
    goto case_exp___75;
  }
  if (ca.cmdchar == 28) {
    goto case_28;
  }
  if (ca.cmdchar == 3) {
    goto case_3;
  }
  if (ca.cmdchar == 27) {
    goto case_27;
  }
  goto switch_default;
  case_113: /* CIL Label */ 
  {
  nv_q(& ca);
  }
  goto switch_break___1;
  case_64: /* CIL Label */ 
  {
  nv_at(& ca);
  }
  goto switch_break___1;
  case_4: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
  nv_halfpage(& ca);
  }
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  case_exp___27: /* CIL Label */ 
  case_exp___28: /* CIL Label */ 
  case_exp___29: /* CIL Label */ 
  dir = -1;
  case_6___0: /* CIL Label */ 
  case_exp___30: /* CIL Label */ 
  case_exp___31: /* CIL Label */ 
  case_exp___32: /* CIL Label */ 
  {
  tmp___10 = checkclearop(oap);
  }
  if (tmp___10) {
    goto switch_break___1;
  }
  {
  onepage(dir, ca.count1);
  }
  goto switch_break___1;
  case_5: /* CIL Label */ 
  flag = 1;
  case_25: /* CIL Label */ 
  {
  nv_scroll_line(& ca, flag);
  }
  goto switch_break___1;
  case_exp___33: /* CIL Label */ 
  flag = 1;
  case_exp___34: /* CIL Label */ 
  if (mod_mask & 2) {
    if (flag) {
      tmp___11 = 1;
    } else {
      tmp___11 = -1;
    }
    {
    onepage(tmp___11, 1L);
    }
  } else {
    {
    ca.count1 = 3L;
    ca.count0 = 3L;
    nv_scroll_line(& ca, flag);
    }
  }
  goto switch_break___1;
  case_122: /* CIL Label */ 
  {
  tmp___12 = checkclearop(oap);
  }
  if (! tmp___12) {
    {
    nv_zet(& ca);
    }
  }
  goto switch_break___1;
  case_58: /* CIL Label */ 
  {
  nv_colon(& ca);
  }
  goto switch_break___1;
  case_81: /* CIL Label */ 
  if (VIsual_active) {
    {
    vim_beep();
    }
  } else {
    {
    tmp___13 = checkclearop(oap);
    }
    if (! tmp___13) {
      {
      do_exmode();
      }
    }
  }
  goto switch_break___1;
  case_exp___35: /* CIL Label */ 
  case_exp___36: /* CIL Label */ 
  case_exp___37: /* CIL Label */ 
  {
  tmp___14 = checkclearopq(oap);
  }
  if (! tmp___14) {
    {
    do_help((EXARG *)((void *)0));
    }
  }
  goto switch_break___1;
  case_12: /* CIL Label */ 
  {
  tmp___15 = checkclearop(oap);
  }
  if (! tmp___15) {
    {
    update_screen(50);
    }
  }
  goto switch_break___1;
  case_7: /* CIL Label */ 
  {
  nv_ctrlg(& ca);
  }
  goto switch_break___1;
  case_30: /* CIL Label */ 
  {
  tmp___16 = checkclearopq(oap);
  }
  if (! tmp___16) {
    {
    buflist_getfile((int )ca.count0, (linenr_t )0, 3, 0);
    }
  }
  goto switch_break___1;
  case_90: /* CIL Label */ 
  {
  nv_zzet(& ca);
  }
  goto switch_break___1;
  case_163: /* CIL Label */ 
  ca.cmdchar = '#';
  case_29: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_exp___38: /* CIL Label */ 
  case_35: /* CIL Label */ 
  if (ca.cmdchar == 75 + (57 << 8)) {
    ca.cmdchar = '*';
  }
  {
  nv_ident(& ca, & searchbuff);
  }
  goto switch_break___1;
  case_20: /* CIL Label */ 
  {
  tmp___17 = checkclearopq(oap);
  }
  if (! tmp___17) {
    {
    do_tag((char_u *)"", 2, (int )ca.count1, 0, 1);
    }
  }
  goto switch_break___1;
  case_71: /* CIL Label */ 
  {
  nv_goto(& ca, curbuf->b_ml.ml_line_count);
  }
  goto switch_break___1;
  case_72: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  {
  nv_scroll(& ca);
  }
  goto switch_break___1;
  case_exp___39: /* CIL Label */ 
  if (mod_mask & 4) {
    {
    oap->inclusive = 0;
    nv_wordcmd(& ca, 1);
    }
    goto switch_break___1;
  }
  case_108: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
  nv_right(& ca);
  }
  goto switch_break___1;
  case_exp___40: /* CIL Label */ 
  if (mod_mask & 4) {
    {
    nv_bck_word(& ca, 1);
    }
    goto switch_break___1;
  }
  case_104: /* CIL Label */ 
  {
  dont_adjust_op_end = nv_left(& ca);
  }
  goto switch_break___1;
  case_exp___41: /* CIL Label */ 
  case_8: /* CIL Label */ 
  if (VIsual_active) {
    if (VIsual_select) {
      {
      ca.cmdchar = 'x';
      v_visop(& ca);
      }
    } else {
      {
      dont_adjust_op_end = nv_left(& ca);
      }
    }
  } else {
    {
    dont_adjust_op_end = nv_left(& ca);
    }
  }
  goto switch_break___1;
  case_45: /* CIL Label */ 
  case_exp___42: /* CIL Label */ 
  flag = 1;
  case_107: /* CIL Label */ 
  case_exp___43: /* CIL Label */ 
  case_16___0: /* CIL Label */ 
  {
  oap->motion_type = 1;
  tmp___18 = cursor_up(ca.count1, oap->op_type == 0);
  }
  if (tmp___18 == 0) {
    {
    clearopbeep(oap);
    }
  } else { //Added block
  if (flag) {
    {
    beginline(5);
    }
  }
  }
  goto switch_break___1;
  case_43: /* CIL Label */ 
  case_exp___44: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_exp___45: /* CIL Label */ 
  flag = 1;
  case_106: /* CIL Label */ 
  case_exp___46: /* CIL Label */ 
  case_14___0: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
  oap->motion_type = 1;
  tmp___19 = cursor_down(ca.count1, oap->op_type == 0);
  }
  if (tmp___19 == 0) {
    {
    clearopbeep(oap);
    }
  } else { //Added block
  if (flag) {
    {
    beginline(5);
    }
  }
  }
  goto switch_break___1;
  case_95: /* CIL Label */ 
  {
  nv_lineop(& ca);
  }
  goto switch_break___1;
  case_exp___47: /* CIL Label */ 
  case_exp___48: /* CIL Label */ 
  case_exp___49: /* CIL Label */ 
  case_exp___50: /* CIL Label */ 
  if (mod_mask & 4) {
    {
    nv_goto(& ca, (linenr_t )1);
    }
    goto switch_break___1;
  }
  ca.count0 = 1L;
  case_124: /* CIL Label */ 
  {
  nv_pipe(& ca);
  }
  goto switch_break___1;
  case_66: /* CIL Label */ 
  type = 1;
  case_98: /* CIL Label */ 
  case_exp___51: /* CIL Label */ 
  {
  nv_bck_word(& ca, type);
  }
  goto switch_break___1;
  case_69: /* CIL Label */ 
  type = 1;
  case_101: /* CIL Label */ 
  {
  oap->inclusive = 1;
  nv_wordcmd(& ca, type);
  }
  goto switch_break___1;
  case_87: /* CIL Label */ 
  type = 1;
  case_119: /* CIL Label */ 
  case_exp___52: /* CIL Label */ 
  {
  oap->inclusive = 0;
  nv_wordcmd(& ca, type);
  }
  goto switch_break___1;
  case_exp___53: /* CIL Label */ 
  case_exp___54: /* CIL Label */ 
  case_exp___55: /* CIL Label */ 
  case_exp___56: /* CIL Label */ 
  if (mod_mask & 4) {
    {
    nv_goto(& ca, curbuf->b_ml.ml_line_count);
    ca.count1 = 1L;
    }
  }
  case_36: /* CIL Label */ 
  {
  nv_dollar(& ca);
  }
  goto switch_break___1;
  case_94: /* CIL Label */ 
  flag = 5;
  case_48: /* CIL Label */ 
  {
  oap->motion_type = 0;
  oap->inclusive = 0;
  beginline(flag);
  }
  goto switch_break___1;
  case_exp___57: /* CIL Label */ 
  ca.cmdchar = '/';
  case_63: /* CIL Label */ 
  case_47: /* CIL Label */ 
  {
  nv_search(& ca, & searchbuff, 0);
  }
  goto switch_break___1;
  case_78: /* CIL Label */ 
  flag = 1;
  case_110: /* CIL Label */ 
  {
  nv_next(& ca, flag);
  }
  goto switch_break___1;
  case_84: /* CIL Label */ 
  dir = -1;
  case_116: /* CIL Label */ 
  {
  nv_csearch(& ca, dir, 1);
  }
  goto switch_break___1;
  case_70: /* CIL Label */ 
  dir = -1;
  case_102: /* CIL Label */ 
  {
  nv_csearch(& ca, dir, 0);
  }
  goto switch_break___1;
  case_44: /* CIL Label */ 
  flag = 1;
  case_59: /* CIL Label */ 
  {
  nv_csearch(& ca, flag, 0);
  }
  goto switch_break___1;
  case_91: /* CIL Label */ 
  dir = -1;
  case_93: /* CIL Label */ 
  {
  nv_brackets(& ca, dir);
  }
  goto switch_break___1;
  case_37: /* CIL Label */ 
  {
  nv_percent(& ca);
  }
  goto switch_break___1;
  case_40: /* CIL Label */ 
  dir = -1;
  case_41: /* CIL Label */ 
  {
  nv_brace(& ca, dir);
  }
  goto switch_break___1;
  case_123: /* CIL Label */ 
  dir = -1;
  case_125: /* CIL Label */ 
  {
  nv_findpar(& ca, dir);
  }
  goto switch_break___1;
  case_46: /* CIL Label */ 
  {
  tmp___22 = checkclearopq(oap);
  }
  if (! tmp___22) {
    if (restart_edit) {
      if (! arrow_used) {
        tmp___20 = 1;
      } else {
        tmp___20 = 0;
      }
    } else {
      tmp___20 = 0;
    }
    {
    tmp___21 = start_redo(ca.count0, tmp___20);
    }
    if (tmp___21 == 0) {
      {
      clearopbeep(oap);
      }
    }
  }
  goto switch_break___1;
  case_117: /* CIL Label */ 
  if (VIsual_active) {
    {
    ca.cmdchar = 'g';
    ca.nchar = 'u';
    nv_operator(& ca);
    }
    goto switch_break___1;
  } else { //Added block
  if (oap->op_type == 12) {
    {
    ca.cmdchar = 'g';
    ca.nchar = 'u';
    nv_operator(& ca);
    }
    goto switch_break___1;
  }
  }
  case_exp___58: /* CIL Label */ 
  {
  tmp___23 = checkclearopq(oap);
  }
  if (! tmp___23) {
    {
    u_undo((int )ca.count1);
    curwin->w_set_curswant = 1;
    }
  }
  goto switch_break___1;
  case_18: /* CIL Label */ 
  {
  tmp___24 = checkclearopq(oap);
  }
  if (! tmp___24) {
    {
    u_redo((int )ca.count1);
    curwin->w_set_curswant = 1;
    }
  }
  goto switch_break___1;
  case_85: /* CIL Label */ 
  {
  nv_Undo(& ca);
  }
  goto switch_break___1;
  case_114: /* CIL Label */ 
  {
  command_busy = nv_replace(& ca);
  }
  goto switch_break___1;
  case_74: /* CIL Label */ 
  {
  nv_join(& ca);
  }
  goto switch_break___1;
  case_80: /* CIL Label */ 
  case_112: /* CIL Label */ 
  {
  nv_put(& ca);
  }
  goto switch_break___1;
  case_1: /* CIL Label */ 
  case_24: /* CIL Label */ 
  {
  tmp___25 = checkclearopq(oap);
  }
  if (! tmp___25) {
    {
    tmp___26 = do_addsub(ca.cmdchar, ca.count1);
    }
    if (tmp___26 == 1) {
      {
      prep_redo_cmd(& ca);
      }
    }
  }
  goto switch_break___1;
  case_65: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_exp___59: /* CIL Label */ 
  case_exp___60: /* CIL Label */ 
  {
  command_busy = nv_edit(& ca);
  }
  goto switch_break___1;
  case_111: /* CIL Label */ 
  case_79: /* CIL Label */ 
  if (VIsual_active) {
    {
    v_swap_corners(& ca);
    }
  } else {
    {
    command_busy = n_opencmd(& ca);
    }
  }
  goto switch_break___1;
  case_82: /* CIL Label */ 
  {
  command_busy = nv_Replace(& ca);
  }
  goto switch_break___1;
  case_126: /* CIL Label */ 
  if (! p_to) {
    if (! VIsual_active) {
      if (oap->op_type != 7) {
        {
        n_swapchar(& ca);
        }
        goto switch_break___1;
      }
    }
  }
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_61: /* CIL Label */ 
  {
  nv_operator(& ca);
  }
  goto switch_break___1;
  case_83: /* CIL Label */ 
  case_115: /* CIL Label */ 
  if (VIsual_active) {
    if (ca.cmdchar == 83) {
      VIsual_mode = 'V';
    }
    {
    ca.cmdchar = 'c';
    nv_operator(& ca);
    }
    goto switch_break___1;
  }
  case_exp___61: /* CIL Label */ 
  case_exp___62: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_88: /* CIL Label */ 
  if (ca.cmdchar == 107 + (68 << 8)) {
    ca.cmdchar = 'x';
  } else { //Added block
  if (ca.cmdchar == 253 + (70 << 8)) {
    ca.cmdchar = 'x';
  }
  }
  if (VIsual_active) {
    {
    v_visop(& ca);
    }
    goto switch_break___1;
  }
  case_38: /* CIL Label */ 
  {
  nv_optrans(& ca);
  opnum = (linenr_t )0;
  }
  goto switch_break___1;
  case_109: /* CIL Label */ 
  {
  tmp___28 = checkclearop(oap);
  }
  if (! tmp___28) {
    {
    tmp___27 = setmark(ca.nchar);
    }
    if (tmp___27 == 0) {
      {
      clearopbeep(oap);
      }
    }
  }
  goto switch_break___1;
  case_39: /* CIL Label */ 
  flag = 1;
  case_96: /* CIL Label */ 
  {
  nv_gomark(& ca, flag);
  }
  goto switch_break___1;
  case_15: /* CIL Label */ 
  if (VIsual_active) {
    if (VIsual_select) {
      {
      VIsual_select = 0;
      showmode();
      restart_VIsual_select = 2;
      }
      goto switch_break___1;
    }
  }
  ca.count1 = - ca.count1;
  case_9: /* CIL Label */ 
  {
  nv_pcmark(& ca);
  }
  goto switch_break___1;
  case_34: /* CIL Label */ 
  {
  nv_regname(& ca, & opnum);
  }
  goto switch_break___1;
  case_118: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_22: /* CIL Label */ 
  {
  tmp___29 = checkclearop(oap);
  }
  if (! tmp___29) {
    {
    nv_visual(& ca, 0);
    }
  }
  goto switch_break___1;
  case_26: /* CIL Label */ 
  {
  clearop(oap);
  }
  if (VIsual_active) {
    {
    end_visual_mode();
    }
  }
  {
  stuffReadbuff((char_u *)":st\r");
  }
  goto switch_break___1;
  case_23: /* CIL Label */ 
  {
  tmp___30 = checkclearop(oap);
  }
  if (! tmp___30) {
    {
    do_window(ca.nchar, ca.count0);
    }
  }
  goto switch_break___1;
  case_103: /* CIL Label */ 
  {
  command_busy = nv_g_cmd(& ca, & searchbuff);
  }
  goto switch_break___1;
  case_exp___63: /* CIL Label */ 
  case_exp___64: /* CIL Label */ 
  case_exp___65: /* CIL Label */ 
  case_exp___66: /* CIL Label */ 
  case_exp___67: /* CIL Label */ 
  case_exp___68: /* CIL Label */ 
  case_exp___69: /* CIL Label */ 
  case_exp___70: /* CIL Label */ 
  case_exp___71: /* CIL Label */ 
  case_exp___72: /* CIL Label */ 
  case_exp___73: /* CIL Label */ 
  {
  do_mouse(oap, ca.cmdchar, -1, ca.count1, 0);
  }
  goto switch_break___1;
  case_exp___74: /* CIL Label */ 
  goto switch_break___1;
  case_exp___75: /* CIL Label */ 
  {
  nv_select(& ca);
  }
  goto switch_break___1;
  case_28: /* CIL Label */ 
  {
  nv_normal(& ca);
  }
  goto switch_break___1;
  case_3: /* CIL Label */ 
  restart_edit = 0;
  case_27: /* CIL Label */ 
  {
  nv_esc(& ca, opnum);
  }
  goto switch_break___1;
  switch_default: /* CIL Label */ 
  {
  clearopbeep(oap);
  }
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  if (! finish_op) {
    if (! oap->op_type) {
      {
      tmp___31 = vim_strchr((char_u *)"\"DCYSsXx.", ca.cmdchar);
      }
      if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
        oap->regname = 0;
      }
    }
  }
  {
  do_pending_operator(& ca, searchbuff, & command_busy, old_col, 0, dont_adjust_op_end);
  }
  if (p_smd) {
    if (VIsual_active) {
      if (old_pos.lnum == curwin->w_cursor.lnum) {
        if (old_pos.col == curwin->w_cursor.col) {
          goto _L___17;
        } else {
          goto _L___19;
        }
      } else {
        goto _L___19;
      }
    } else { //Added block
    _L___19: 
    if (restart_edit) {
      _L___17: 
      if (clear_cmdline) {
        goto _L___15;
      } else { //Added block
      if (redraw_cmdline) {
        _L___15: 
        if (msg_didany) {
          if (! msg_nowait) {
            if (KeyTyped) {
              goto _L___10;
            } else {
              goto _L___16;
            }
          } else {
            goto _L___16;
          }
        } else {
          goto _L___16;
        }
      } else {
        goto _L___16;
      }
      }
    } else {
      goto _L___16;
    }
    }
  } else { //Added block
  _L___16: 
  if (restart_edit) {
    if (! VIsual_active) {
      if (msg_scroll) {
        goto _L___10;
      } else { //Added block
      if (emsg_on_display) {
        _L___10: 
        if (oap->regname == 0) {
          if (! command_busy) {
            {
            tmp___32 = stuff_empty();
            }
            if (tmp___32) {
              {
              tmp___33 = typebuf_typed();
              }
              if (tmp___33) {
                if (oap->op_type == 0) {
                  save_State = State;
                  if (restart_edit) {
                    State = 16;
                  }
                  if (must_redraw) {
                    if ((unsigned long )keep_msg != (unsigned long )((void *)0)) {
                      if (! emsg_on_display) {
                        {
                        kmsg = keep_msg;
                        update_screen(must_redraw);
                        msg_attr(kmsg, keep_msg_attr);
                        }
                      }
                    }
                  }
                  {
                  setcursor();
                  cursor_on();
                  out_flush();
                  }
                  if (msg_scroll) {
                    {
                    ui_delay(1000L, 1);
                    }
                  } else { //Added block
                  if (emsg_on_display) {
                    {
                    ui_delay(1000L, 1);
                    }
                  }
                  }
                  {
                  ui_delay(3000L, 0);
                  State = save_State;
                  msg_scroll = 0;
                  emsg_on_display = 0;
                  }
                }
              }
            }
          }
        }
      }
      }
    }
  }
  }
  normal_end: 
  msg_nowait = 0;
  finish_op = 0;
  if (oap->op_type == 0) {
    if (oap->regname == 0) {
      {
      clear_showcmd();
      }
    }
  }
  if (modified) {
    {
    update_other_win();
    modified = 0;
    }
  }
  {
  checkpcmark();
  vim_free((void *)searchbuff);
  }
  if (curwin->w_p_scb) {
    {
    validate_cursor();
    do_check_scrollbind(1);
    }
  }
  if (restart_edit) {
    if (! VIsual_active) {
      if (old_mapped_len == 0) {
        goto _L___20;
      } else {
        goto _L___22;
      }
    } else {
      goto _L___22;
    }
  } else { //Added block
  _L___22: 
  if (restart_VIsual_select == 1) {
    _L___20: 
    if (oap->op_type == 0) {
      if (! command_busy) {
        {
        tmp___34 = stuff_empty();
        }
        if (tmp___34) {
          if (oap->regname == 0) {
            if (restart_VIsual_select == 1) {
              {
              VIsual_select = 1;
              showmode();
              restart_VIsual_select = 0;
              }
            }
            if (restart_edit) {
              if (! VIsual_active) {
                if (old_mapped_len == 0) {
                  if (must_redraw) {
                    {
                    update_screen(must_redraw);
                    }
                  }
                  {
                  edit(restart_edit, 0, 1L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  }
  if (restart_VIsual_select == 2) {
    restart_VIsual_select = 1;
  }
  return;
}
}
static int redo_VIsual_mode  =    '\000';
static linenr_t redo_VIsual_line_count  ;
static colnr_t redo_VIsual_col  ;
static long redo_VIsual_count  ;
void do_pending_operator(CMDARG *cap , char_u *searchbuff , int *command_busy , int old_col ,
                         int gui_yank , int dont_adjust_op_end ) 
{ 
  OPARG *oap ;
  FPOS old_cursor ;
  int empty_region_error ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  size_t tmp___4 ;
  char_u *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  colnr_t start___0 ;
  colnr_t end ;
  int tmp___9 ;
  int tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char_u *tmp___16 ;
  int tmp___17 ;
  char_u *tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char_u *tmp___22 ;
  colnr_t tmp___23 ;

  {
  oap = cap->oap;
  if (clipboard.available) {
    if (oap->op_type != 0) {
      if (! gui_yank) {
        if (VIsual_active) {
          if (oap->regname == 0) {
            if (! redo_VIsual_busy) {
              {
              clip_auto_select();
              }
            }
          }
        }
      }
    }
  }
  old_cursor = curwin->w_cursor;
  if (VIsual_active) {
    goto _L___6;
  } else { //Added block
  if (finish_op) {
    _L___6: 
    if (oap->op_type != 0) {
      {
      oap->is_VIsual = VIsual_active;
      tmp___2 = vim_strchr(p_cpo, 'y');
      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        goto _L___0;
      } else { //Added block
      if (oap->op_type != 2) {
        _L___0: 
        if (! VIsual_active) {
          {
          tmp = get_extra_op_char(oap->op_type);
          tmp___0 = get_op_char(oap->op_type);
          prep_redo(oap->regname, cap->count0, tmp___0, tmp, cap->cmdchar, cap->nchar);
          }
          if (cap->cmdchar == 47) {
            goto _L;
          } else { //Added block
          if (cap->cmdchar == 63) {
            _L: 
            {
            tmp___1 = vim_strchr(p_cpo, 'r');
            }
            if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
              {
              AppendToRedobuff(searchbuff);
              }
            }
            {
            AppendToRedobuff((char_u *)"\n");
            }
          }
          }
        }
      }
      }
      if (redo_VIsual_busy) {
        oap->start = curwin->w_cursor;
        curwin->w_cursor.lnum += redo_VIsual_line_count - 1L;
        if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
        }
        VIsual_mode = redo_VIsual_mode;
        if (VIsual_mode == 118) {
          if (redo_VIsual_line_count <= 1L) {
            curwin->w_cursor.col += redo_VIsual_col - 1U;
          } else {
            curwin->w_cursor.col = redo_VIsual_col;
          }
        }
        if (redo_VIsual_col == 2147483647U) {
          {
          curwin->w_curswant = (colnr_t )2147483647;
          coladvance((colnr_t )2147483647);
          }
        }
        cap->count0 = redo_VIsual_count;
        if (redo_VIsual_count != 0L) {
          cap->count1 = redo_VIsual_count;
        } else {
          cap->count1 = 1L;
        }
      } else { //Added block
      if (VIsual_active) {
        if (VIsual_select) {
          if (VIsual_mode == 86) {
            if (VIsual.lnum != curwin->w_cursor.lnum) {
              tmp___7 = VIsual.lnum < curwin->w_cursor.lnum;
            } else {
              tmp___7 = VIsual.col < curwin->w_cursor.col;
            }
            if (tmp___7) {
              {
              VIsual.col = (colnr_t )0;
              tmp___3 = ml_get(curwin->w_cursor.lnum);
              tmp___4 = strlen((char const   *)((char *)tmp___3));
              curwin->w_cursor.col = (colnr_t )tmp___4;
              }
            } else {
              {
              curwin->w_cursor.col = (colnr_t )0;
              tmp___5 = ml_get(VIsual.lnum);
              tmp___6 = strlen((char const   *)((char *)tmp___5));
              VIsual.col = (colnr_t )tmp___6;
              }
            }
            VIsual_mode = 'v';
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if (VIsual_mode == 118) {
          {
          unadjust_for_sel();
          }
        }
        }
        curbuf->b_visual_start = VIsual;
        curbuf->b_visual_end = curwin->w_cursor;
        curbuf->b_visual_mode = VIsual_mode;
        oap->start = VIsual;
        if (VIsual_mode == 86) {
          oap->start.col = (colnr_t )0;
        }
      }
      }
      if (oap->start.lnum != curwin->w_cursor.lnum) {
        tmp___8 = oap->start.lnum < curwin->w_cursor.lnum;
      } else {
        tmp___8 = oap->start.col < curwin->w_cursor.col;
      }
      if (tmp___8) {
        oap->end = curwin->w_cursor;
        curwin->w_cursor = oap->start;
      } else {
        oap->end = oap->start;
        oap->start = curwin->w_cursor;
      }
      oap->line_count = (oap->end.lnum - oap->start.lnum) + 1L;
      if (VIsual_active) {
        goto _L___3;
      } else { //Added block
      if (redo_VIsual_busy) {
        _L___3: 
        if (VIsual_mode == 22) {
          {
          oap->block_mode = 1;
          getvcol(curwin, & oap->start, & oap->start_vcol, (colnr_t *)((void *)0),
                  & oap->end_vcol);
          }
          if (! redo_VIsual_busy) {
            {
            getvcol(curwin, & oap->end, & start___0, (colnr_t *)((void *)0), & end);
            }
            if (start___0 < oap->start_vcol) {
              oap->start_vcol = start___0;
            }
            if (end > oap->end_vcol) {
              if ((int )*p_sel == 101) {
                if (start___0 - 1U >= oap->end_vcol) {
                  oap->end_vcol = start___0 - 1U;
                } else {
                  oap->end_vcol = end;
                }
              } else {
                oap->end_vcol = end;
              }
            }
          }
          if (curwin->w_curswant == 2147483647U) {
            curwin->w_cursor.col = (colnr_t )2147483647;
            oap->end_vcol = (colnr_t )0;
            curwin->w_cursor.lnum = oap->start.lnum;
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              if (! (curwin->w_cursor.lnum <= oap->end.lnum)) {
                goto while_break;
              }
              {
              getvcol(curwin, & curwin->w_cursor, (colnr_t *)((void *)0), (colnr_t *)((void *)0),
                      & end);
              }
              if (end > oap->end_vcol) {
                oap->end_vcol = end;
              }
              (curwin->w_cursor.lnum) ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else { //Added block
          if (redo_VIsual_busy) {
            oap->end_vcol = (oap->start_vcol + redo_VIsual_col) - 1U;
          }
          }
          {
          curwin->w_cursor.lnum = oap->end.lnum;
          coladvance(oap->end_vcol);
          oap->end = curwin->w_cursor;
          curwin->w_cursor = oap->start;
          coladvance(oap->start_vcol);
          oap->start = curwin->w_cursor;
          }
        }
        if (! redo_VIsual_busy) {
          if (! gui_yank) {
            resel_VIsual_mode = VIsual_mode;
            if (curwin->w_curswant == 2147483647U) {
              resel_VIsual_col = (colnr_t )2147483647;
            } else { //Added block
            if (VIsual_mode == 22) {
              resel_VIsual_col = (oap->end_vcol - oap->start_vcol) + 1U;
            } else { //Added block
            if (oap->line_count > 1L) {
              resel_VIsual_col = oap->end.col;
            } else {
              resel_VIsual_col = (oap->end.col - oap->start.col) + 1U;
            }
            }
            }
            resel_VIsual_line_count = oap->line_count;
          }
        }
        {
        tmp___11 = vim_strchr(p_cpo, 'y');
        }
        if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
          goto _L___2;
        } else { //Added block
        if (oap->op_type != 2) {
          _L___2: 
          if (oap->op_type != 10) {
            {
            tmp___9 = get_extra_op_char(oap->op_type);
            tmp___10 = get_op_char(oap->op_type);
            prep_redo(oap->regname, 0L, '\000', 'v', tmp___10, tmp___9);
            redo_VIsual_mode = resel_VIsual_mode;
            redo_VIsual_col = resel_VIsual_col;
            redo_VIsual_line_count = resel_VIsual_line_count;
            redo_VIsual_count = cap->count0;
            }
          }
        }
        }
        oap->inclusive = 1;
        if (VIsual_mode == 86) {
          oap->motion_type = 1;
        } else {
          oap->motion_type = 0;
          if (VIsual_mode != 22) {
            {
            tmp___13 = ml_get_pos(& oap->end);
            }
            if ((int )*tmp___13 == 0) {
              oap->inclusive = 0;
              if ((int )*p_sel != 111) {
                {
                tmp___12 = op_on_lines(oap->op_type);
                }
                if (! tmp___12) {
                  if (oap->end.lnum < curbuf->b_ml.ml_line_count) {
                    (oap->end.lnum) ++;
                    oap->end.col = (colnr_t )0;
                    (oap->line_count) ++;
                  }
                }
              }
            }
          }
        }
        redo_VIsual_busy = 0;
        if (! gui_yank) {
          {
          VIsual_active = 0;
          setmouse();
          mouse_dragging = 0;
          }
          if (p_smd) {
            clear_cmdline = 1;
          }
          if (oap->op_type == 2) {
            {
            update_curbuf(40);
            }
          } else { //Added block
          if (oap->op_type == 10) {
            {
            update_curbuf(40);
            }
          } else { //Added block
          if (oap->op_type == 6) {
            {
            update_curbuf(40);
            }
          }
          }
          }
        }
      }
      }
      curwin->w_set_curswant = 1;
      if (oap->motion_type == 0) {
        if (! oap->inclusive) {
          goto _L___4;
        } else { //Added block
        if (oap->op_type == 2) {
          {
          tmp___14 = gchar_pos(& oap->end);
          }
          if (tmp___14 == 0) {
            _L___4: 
            if (oap->start.lnum == oap->end.lnum) {
              if (oap->start.col == oap->end.col) {
                tmp___15 = 1;
              } else {
                tmp___15 = 0;
              }
            } else {
              tmp___15 = 0;
            }
          } else {
            tmp___15 = 0;
          }
        } else {
          tmp___15 = 0;
        }
        }
      } else {
        tmp___15 = 0;
      }
      oap->empty = tmp___15;
      if (oap->empty) {
        {
        tmp___16 = vim_strchr(p_cpo, 'E');
        }
        if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
          tmp___17 = 1;
        } else {
          tmp___17 = 0;
        }
      } else {
        tmp___17 = 0;
      }
      empty_region_error = tmp___17;
      if (oap->is_VIsual) {
        if (oap->empty) {
          {
          redraw_curbuf_later(40);
          }
        }
      }
      if (oap->motion_type == 0) {
        if (oap->inclusive == 0) {
          if (! dont_adjust_op_end) {
            if (oap->end.col == 0U) {
              if (! oap->is_VIsual) {
                goto _L___5;
              } else { //Added block
              if ((int )*p_sel == 111) {
                _L___5: 
                if (oap->line_count > 1L) {
                  {
                  oap->end_adjusted = 1;
                  (oap->line_count) --;
                  (oap->end.lnum) --;
                  tmp___20 = inindent(0);
                  }
                  if (tmp___20) {
                    oap->motion_type = 1;
                  } else {
                    {
                    tmp___18 = ml_get(oap->end.lnum);
                    tmp___19 = strlen((char const   *)((char *)tmp___18));
                    oap->end.col = (colnr_t )tmp___19;
                    }
                    if (oap->end.col) {
                      (oap->end.col) --;
                      oap->inclusive = 1;
                    }
                  }
                } else {
                  oap->end_adjusted = 0;
                }
              } else {
                oap->end_adjusted = 0;
              }
              }
            } else {
              oap->end_adjusted = 0;
            }
          } else {
            oap->end_adjusted = 0;
          }
        } else {
          oap->end_adjusted = 0;
        }
      } else {
        oap->end_adjusted = 0;
      }
      {
      if (oap->op_type == 4) {
        goto case_4;
      }
      if (oap->op_type == 5) {
        goto case_4;
      }
      if (oap->op_type == 14) {
        goto case_14;
      }
      if (oap->op_type == 13) {
        goto case_14;
      }
      if (oap->op_type == 1) {
        goto case_1;
      }
      if (oap->op_type == 2) {
        goto case_2;
      }
      if (oap->op_type == 3) {
        goto case_3;
      }
      if (oap->op_type == 6) {
        goto case_6;
      }
      if (oap->op_type == 8) {
        goto case_8;
      }
      if (oap->op_type == 10) {
        goto case_8;
      }
      if (oap->op_type == 7) {
        goto case_7;
      }
      if (oap->op_type == 11) {
        goto case_7;
      }
      if (oap->op_type == 12) {
        goto case_7;
      }
      if (oap->op_type == 15) {
        goto case_7;
      }
      if (oap->op_type == 9) {
        goto case_9;
      }
      if (oap->op_type == 17) {
        goto case_17;
      }
      if (oap->op_type == 18) {
        goto case_17;
      }
      if (oap->op_type == 16) {
        goto case_16;
      }
      goto switch_default;
      case_4: /* CIL Label */ 
      case_5: /* CIL Label */ 
      if (oap->is_VIsual) {
        tmp___21 = (int )cap->count1;
      } else {
        tmp___21 = 1;
      }
      {
      op_shift(oap, 1, tmp___21);
      }
      goto switch_break;
      case_14: /* CIL Label */ 
      case_13: /* CIL Label */ 
      if (oap->line_count < 2L) {
        oap->line_count = 2L;
      }
      if ((curwin->w_cursor.lnum + oap->line_count) - 1L > curbuf->b_ml.ml_line_count) {
        {
        beep_flush();
        }
      } else {
        {
        do_do_join(oap->line_count, oap->op_type == 13, 1);
        }
      }
      goto switch_break;
      case_1: /* CIL Label */ 
      VIsual_reselect = 0;
      if (empty_region_error) {
        {
        vim_beep();
        }
      } else {
        {
        op_delete(oap);
        }
      }
      goto switch_break;
      case_2: /* CIL Label */ 
      if (empty_region_error) {
        if (! gui_yank) {
          {
          vim_beep();
          }
        }
      } else {
        {
        op_yank(oap, 0, ! gui_yank);
        }
      }
      {
      check_cursor_col();
      }
      goto switch_break;
      case_3: /* CIL Label */ 
      VIsual_reselect = 0;
      if (empty_region_error) {
        {
        vim_beep();
        }
      } else {
        {
        restart_edit = 0;
        *command_busy = op_change(oap);
        }
      }
      goto switch_break;
      case_6: /* CIL Label */ 
      {
      tmp___22 = vim_strchr(p_cpo, '!');
      }
      if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
        {
        AppendToRedobuff((char_u *)"!\r");
        }
      } else {
        bangredo = 1;
      }
      case_8: /* CIL Label */ 
      case_10: /* CIL Label */ 
      if (oap->op_type == 8) {
        if ((int )*p_ep == 0) {
          if (curbuf->b_p_lisp) {
            {
            op_reindent(oap, & get_lisp_indent);
            }
            goto switch_break;
          }
          {
          op_reindent(oap, & get_c_indent);
          }
          goto switch_break;
        }
      }
      {
      op_colon(oap);
      }
      goto switch_break;
      case_7: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_12: /* CIL Label */ 
      case_15: /* CIL Label */ 
      if (empty_region_error) {
        {
        vim_beep();
        }
      } else {
        {
        op_tilde(oap);
        }
      }
      {
      check_cursor_col();
      }
      goto switch_break;
      case_9: /* CIL Label */ 
      if ((int )*p_fp != 0) {
        {
        op_colon(oap);
        }
      } else {
        {
        op_format(oap);
        }
      }
      goto switch_break;
      case_17: /* CIL Label */ 
      case_18: /* CIL Label */ 
      VIsual_reselect = 0;
      if (empty_region_error) {
        {
        vim_beep();
        }
      } else {
        {
        restart_edit = 0;
        op_insert(oap, cap->count1);
        }
      }
      goto switch_break;
      case_16: /* CIL Label */ 
      VIsual_reselect = 0;
      if (empty_region_error) {
        {
        vim_beep();
        }
      } else {
        {
        op_replace(oap, cap->nchar);
        }
      }
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      clearopbeep(oap);
      }
      switch_break: /* CIL Label */ ;
      }
      if (! gui_yank) {
        if (! p_sol) {
          if (oap->motion_type == 1) {
            if (! oap->end_adjusted) {
              if (oap->op_type == 4) {
                {
                tmp___23 = (colnr_t )old_col;
                curwin->w_curswant = tmp___23;
                coladvance(tmp___23);
                }
              } else { //Added block
              if (oap->op_type == 5) {
                {
                tmp___23 = (colnr_t )old_col;
                curwin->w_curswant = tmp___23;
                coladvance(tmp___23);
                }
              } else { //Added block
              if (oap->op_type == 1) {
                {
                tmp___23 = (colnr_t )old_col;
                curwin->w_curswant = tmp___23;
                coladvance(tmp___23);
                }
              }
              }
              }
            }
          }
        }
        oap->op_type = 0;
      } else {
        curwin->w_cursor = old_cursor;
      }
      oap->block_mode = 0;
      oap->regname = 0;
    }
  }
  }
  return;
}
}
static void op_colon(OPARG *oap ) 
{ 


  {
  {
  stuffcharReadbuff(':');
  }
  if (oap->is_VIsual) {
    {
    stuffReadbuff((char_u *)"\'<,\'>");
    }
  } else {
    if (oap->start.lnum == curwin->w_cursor.lnum) {
      {
      stuffcharReadbuff('.');
      }
    } else {
      {
      stuffnumReadbuff(oap->start.lnum);
      }
    }
    if (oap->end.lnum != oap->start.lnum) {
      {
      stuffcharReadbuff(',');
      }
      if (oap->end.lnum == curwin->w_cursor.lnum) {
        {
        stuffcharReadbuff('.');
        }
      } else { //Added block
      if (oap->end.lnum == curbuf->b_ml.ml_line_count) {
        {
        stuffcharReadbuff('$');
        }
      } else { //Added block
      if (oap->start.lnum == curwin->w_cursor.lnum) {
        {
        stuffReadbuff((char_u *)".+");
        stuffnumReadbuff(oap->line_count - 1L);
        }
      } else {
        {
        stuffnumReadbuff(oap->end.lnum);
        }
      }
      }
      }
    }
  }
  if (oap->op_type != 10) {
    {
    stuffReadbuff((char_u *)"!");
    }
  }
  if (oap->op_type == 8) {
    {
    stuffReadbuff(p_ep);
    stuffReadbuff((char_u *)"\n");
    }
  } else { //Added block
  if (oap->op_type == 9) {
    if ((int )*p_fp == 0) {
      {
      stuffReadbuff((char_u *)"fmt");
      }
    } else {
      {
      stuffReadbuff(p_fp);
      }
    }
    {
    stuffReadbuff((char_u *)"\n");
    }
  }
  }
  return;
}
}
static FPOS orig_cursor  ;
static int do_always  =    0;
static int got_click  =    0;
int do_mouse(OPARG *oap , int c , int dir , long count___2 , int fix_indent ) 
{ 
  int which_button ;
  int is_click ;
  int is_drag ;
  int jump_flags ;
  FPOS start_visual ;
  FPOS end_visual ;
  colnr_t leftcol ;
  colnr_t rightcol ;
  int diff ;
  int moved ;
  int in_status_line ;
  int c1 ;
  int c2 ;
  int VIsual_was_active ;
  int regname___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  jump_flags = 0;
  VIsual_was_active = VIsual_active;
  if (do_always) {
    do_always = 0;
  } else { //Added block
  if (VIsual_active) {
    {
    tmp = mouse_has('v');
    }
    if (! tmp) {
      return (0);
    }
  } else { //Added block
  if (State == 1) {
    {
    tmp___0 = mouse_has('n');
    }
    if (! tmp___0) {
      return (0);
    }
  }
  }
  }
  {
  which_button = get_mouse_button((int )(((unsigned int )c >> 8) & 255U), & is_click,
                                  & is_drag);
  }
  if (is_click) {
    got_click = 1;
  } else {
    if (! got_click) {
      return (0);
    }
    if (! is_drag) {
      got_click = 0;
    }
  }
  if (mod_mask & 8) {
    return (0);
  }
  if (is_click) {
    if (mod_mask & 4) {
      if (which_button == 2) {
        if (State & 16) {
          {
          stuffcharReadbuff(15);
          }
        }
        {
        stuffcharReadbuff(20);
        got_click = 0;
        }
        return (0);
      }
    }
  }
  if (mod_mask & 4) {
    if (which_button != 0) {
      return (0);
    }
  }
  if (mod_mask & 14) {
    if (! is_click) {
      goto _L;
    } else { //Added block
    if (mod_mask & 112) {
      goto _L;
    } else { //Added block
    if (which_button == 1) {
      _L: 
      if (mod_mask & 2) {
        {
        tmp___1 = mouse_model_popup();
        }
        if (tmp___1) {
          if (! (which_button == 0)) {
            return (0);
          }
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    }
    }
    }
  }
  if (! is_click) {
    if (which_button == 1) {
      return (0);
    }
  }
  if ((unsigned long )oap != (unsigned long )((void *)0)) {
    regname___0 = oap->regname;
  } else {
    regname___0 = 0;
  }
  if (which_button == 1) {
    if (State == 1) {
      if ((unsigned long )oap != (unsigned long )((void *)0)) {
        if (oap->op_type != 0) {
          {
          clearopbeep(oap);
          }
          return (0);
        }
      }
      if (VIsual_active) {
        {
        stuffcharReadbuff('y');
        stuffcharReadbuff(253 + (45 << 8));
        do_always = 1;
        }
        return (0);
      }
    } else { //Added block
    if (State & 16) {
      if (regname___0 == 46) {
        {
        insert_reg(regname___0, 1);
        }
      } else {
        if (clipboard.available) {
          if (regname___0 == 0) {
            regname___0 = '*';
          }
        }
        if (State == 528) {
          goto _L___1;
        } else { //Added block
        if (State == 784) {
          _L___1: 
          {
          tmp___4 = yank_register_mline(regname___0);
          }
          if (tmp___4) {
            goto _L___0;
          } else {
            {
            insert_reg(regname___0, 1);
            }
          }
        } else {
          _L___0: 
          {
          do_put(regname___0, -1, 1L, fix_indent | 2);
          AppendCharToRedobuff(18);
          }
          if (fix_indent) {
            tmp___2 = 16;
          } else {
            tmp___2 = 15;
          }
          {
          AppendCharToRedobuff(tmp___2);
          }
          if (regname___0 == 0) {
            tmp___3 = '\"';
          } else {
            tmp___3 = regname___0;
          }
          {
          AppendCharToRedobuff(tmp___3);
          }
        }
        }
      }
      return (0);
    } else {
      return (0);
    }
    }
  }
  if (! is_click) {
    jump_flags |= 5;
  }
  {
  start_visual.lnum = (linenr_t )0;
  tmp___5 = mouse_model_popup();
  }
  if (tmp___5) {
    if (which_button == 2) {
      if (! (mod_mask & 6)) {
        return (0);
      }
    }
    if (which_button == 0) {
      if (mod_mask & 2) {
        which_button = 2;
        mod_mask &= -3;
      }
    }
  }
  if (State & 17) {
    if (! (mod_mask & 6)) {
      if (which_button == 0) {
        if (is_click) {
          if (VIsual_active) {
            jump_flags |= 16;
          }
        } else {
          jump_flags |= 2;
        }
      } else { //Added block
      if (which_button == 2) {
        if (is_click) {
          if (VIsual_active) {
            if (curwin->w_cursor.lnum != VIsual.lnum) {
              tmp___6 = curwin->w_cursor.lnum < VIsual.lnum;
            } else {
              tmp___6 = curwin->w_cursor.col < VIsual.col;
            }
            if (tmp___6) {
              start_visual = curwin->w_cursor;
              end_visual = VIsual;
            } else {
              start_visual = VIsual;
              end_visual = curwin->w_cursor;
            }
          }
        }
        jump_flags |= 2;
      }
      }
    }
  }
  if (! is_drag) {
    if ((unsigned long )oap != (unsigned long )((void *)0)) {
      if (oap->op_type != 0) {
        got_click = 0;
        oap->motion_type = 0;
      }
    }
  }
  if ((unsigned long )oap == (unsigned long )((void *)0)) {
    tmp___7 = (int *)((void *)0);
  } else {
    tmp___7 = & oap->inclusive;
  }
  {
  jump_flags = jump_to_mouse(jump_flags, tmp___7);
  moved = jump_flags & 256;
  in_status_line = (jump_flags & 3) == 3;
  }
  if (moved) {
    if (VIsual_active) {
      if (is_drag) {
        if (p_so) {
          if (mouse_row == 0) {
            mouse_dragging = 2;
          } else {
            mouse_dragging = 1;
          }
        }
      }
    }
  }
  if (start_visual.lnum) {
    if (VIsual_mode == 22) {
      {
      getvcols(& start_visual, & end_visual, & leftcol, & rightcol);
      }
      if (curwin->w_curswant > (leftcol + rightcol) / 2U) {
        end_visual.col = leftcol;
      } else {
        end_visual.col = rightcol;
      }
      if (curwin->w_cursor.lnum < (start_visual.lnum + end_visual.lnum) / 2L) {
        end_visual.lnum = end_visual.lnum;
      } else {
        end_visual.lnum = start_visual.lnum;
      }
      {
      start_visual = curwin->w_cursor;
      curwin->w_cursor = end_visual;
      coladvance(end_visual.col);
      VIsual = curwin->w_cursor;
      curwin->w_cursor = start_visual;
      }
    } else {
      if (curwin->w_cursor.lnum != start_visual.lnum) {
        tmp___9 = curwin->w_cursor.lnum < start_visual.lnum;
      } else {
        tmp___9 = curwin->w_cursor.col < start_visual.col;
      }
      if (tmp___9) {
        VIsual = end_visual;
      } else {
        if (end_visual.lnum != curwin->w_cursor.lnum) {
          tmp___8 = end_visual.lnum < curwin->w_cursor.lnum;
        } else {
          tmp___8 = end_visual.col < curwin->w_cursor.col;
        }
        if (tmp___8) {
          VIsual = start_visual;
        } else { //Added block
        if (end_visual.lnum == start_visual.lnum) {
          if (curwin->w_cursor.col - start_visual.col > end_visual.col - curwin->w_cursor.col) {
            VIsual = start_visual;
          } else {
            VIsual = end_visual;
          }
        } else {
          diff = (int )((curwin->w_cursor.lnum - start_visual.lnum) - (end_visual.lnum - curwin->w_cursor.lnum));
          if (diff > 0) {
            VIsual = start_visual;
          } else { //Added block
          if (diff < 0) {
            VIsual = end_visual;
          } else { //Added block
          if (curwin->w_cursor.col < (start_visual.col + end_visual.col) / 2U) {
            VIsual = end_visual;
          } else {
            VIsual = start_visual;
          }
          }
          }
        }
        }
      }
    }
  } else { //Added block
  if (State & 16) {
    if (VIsual_active) {
      {
      stuffcharReadbuff(15);
      }
    }
  }
  }
  if (moved) {
    if (State & 16) {
      if (modified) {
        if ((unsigned long )firstwin->w_next != (unsigned long )((void *)0)) {
          {
          update_curbuf(40);
          modified = 0;
          }
        }
      }
    }
  }
  if (which_button == 1) {
    if (clipboard.available) {
      if (regname___0 == 0) {
        regname___0 = '*';
      }
    }
    {
    tmp___10 = yank_register_mline(regname___0);
    }
    if (tmp___10) {
      if (mouse_past_bottom) {
        dir = 1;
      }
    } else { //Added block
    if (mouse_past_eol) {
      dir = 1;
    }
    }
    if (fix_indent) {
      if (dir == -1) {
        c1 = '[';
      } else {
        c1 = ']';
      }
      c2 = 'p';
    } else {
      if (dir == 1) {
        c1 = 'p';
      } else {
        c1 = 'P';
      }
      c2 = '\000';
    }
    {
    prep_redo(regname___0, count___2, '\000', c1, c2, '\000');
    }
    if (restart_edit) {
      where_paste_started = curwin->w_cursor;
    }
    {
    do_put(regname___0, dir, count___2, fix_indent | 2);
    }
  } else { //Added block
  if (mod_mask & 4) {
    goto _L___4;
  } else { //Added block
  if (curbuf->b_help) {
    if (mod_mask & 16) {
      _L___4: 
      if (State & 16) {
        {
        stuffcharReadbuff(15);
        }
      }
      {
      stuffcharReadbuff(29);
      got_click = 0;
      }
    } else {
      goto _L___5;
    }
  } else { //Added block
  _L___5: 
  if (mod_mask & 2) {
    if (State & 16) {
      {
      stuffcharReadbuff(15);
      }
    } else { //Added block
    if (VIsual_active) {
      if (VIsual_select) {
        {
        stuffcharReadbuff(15);
        }
      }
    }
    }
    if (which_button == 0) {
      {
      stuffcharReadbuff('*');
      }
    } else {
      {
      stuffcharReadbuff('#');
      }
    }
  } else { //Added block
  if (! in_status_line) {
    if (mod_mask & 112) {
      if (State & 17) {
        if (is_click) {
          goto _L___2;
        } else { //Added block
        if (! VIsual_active) {
          _L___2: 
          if (VIsual_active) {
            orig_cursor = VIsual;
          } else {
            {
            check_visual_highlight();
            VIsual = curwin->w_cursor;
            orig_cursor = VIsual;
            VIsual_active = 1;
            VIsual_reselect = 1;
            may_start_select('o');
            setmouse();
            }
            if (p_smd) {
              redraw_cmdline = 1;
            }
          }
          if (mod_mask & 16) {
            VIsual_mode = 'v';
          } else { //Added block
          if (mod_mask & 32) {
            VIsual_mode = 'V';
          } else { //Added block
          if (mod_mask & 64) {
            VIsual_mode = 22;
          }
          }
          }
          clipboard.vmode = '\000';
        }
        }
        if (mod_mask & 16) {
          if (curwin->w_cursor.lnum != orig_cursor.lnum) {
            tmp___11 = curwin->w_cursor.lnum < orig_cursor.lnum;
          } else {
            tmp___11 = curwin->w_cursor.col < orig_cursor.col;
          }
          if (tmp___11) {
            {
            find_start_of_word(& curwin->w_cursor);
            find_end_of_word(& VIsual);
            }
          } else {
            {
            find_start_of_word(& VIsual);
            find_end_of_word(& curwin->w_cursor);
            }
          }
          curwin->w_set_curswant = 1;
        }
        if (is_click) {
          {
          update_curbuf(40);
          }
        }
      } else {
        goto _L___3;
      }
    } else { //Added block
    _L___3: 
    if (VIsual_active) {
      if (VIsual_was_active != VIsual_active) {
        VIsual_mode = 'v';
      }
    }
    }
  }
  }
  }
  }
  }
  return (moved);
}
}
static void find_start_of_word(FPOS *pos___0 ) 
{ 
  char_u *ptr ;
  int cclass ;
  int tmp ;
  int tmp___0 ;

  {
  {
  ptr = ml_get(pos___0->lnum);
  cclass = get_mouse_class((int )*(ptr + pos___0->col));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (pos___0->col > 0U) {
      {
      tmp = get_mouse_class((int )*(ptr + pos___0->col));
      }
      if (! (tmp == cclass)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    (pos___0->col) --;
  }
  while_break: /* CIL Label */ ;
  }
  if (pos___0->col != 0U) {
    (pos___0->col) ++;
  } else {
    {
    tmp___0 = get_mouse_class((int )*(ptr + 0));
    }
    if (tmp___0 != cclass) {
      (pos___0->col) ++;
    }
  }
  return;
}
}
static void find_end_of_word(FPOS *pos___0 ) 
{ 
  char_u *ptr ;
  int cclass ;
  int tmp ;

  {
  {
  ptr = ml_get(pos___0->lnum);
  }
  if ((int )*p_sel == 101) {
    if (pos___0->col) {
      (pos___0->col) --;
    }
  }
  {
  cclass = get_mouse_class((int )*(ptr + pos___0->col));
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*(ptr + pos___0->col)) {
      {
      tmp = get_mouse_class((int )*(ptr + pos___0->col));
      }
      if (! (tmp == cclass)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    (pos___0->col) ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*p_sel != 101) {
    if (pos___0->col) {
      (pos___0->col) --;
    }
  }
  return;
}
}
static int get_mouse_class(int c ) 
{ 
  int tmp ;
  char_u *tmp___0 ;

  {
  if (c == 32) {
    return (' ');
  } else { //Added block
  if (c == 9) {
    return (' ');
  }
  }
  {
  tmp = vim_isIDc(c);
  }
  if (tmp) {
    return ('a');
  }
  if (c != 0) {
    {
    tmp___0 = vim_strchr((char_u *)"-+*/%<>&|^!=", c);
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      return ('=');
    }
  }
  return (c);
}
}
static int did_check  =    0;
void check_visual_highlight(void) 
{ 


  {
  if (! did_check) {
    if (highlight_attr[14] == 0) {
      {
      msg((char_u *)"Warning: terminal cannot highlight");
      }
    }
  }
  did_check = 1;
  return;
}
}
void end_visual_mode(void) 
{ 
  char_u *tmp ;

  {
  if (clipboard.available) {
    if (clipboard.owned) {
      {
      clip_auto_select();
      }
    }
  }
  {
  VIsual_active = 0;
  setmouse();
  mouse_dragging = 0;
  curbuf->b_visual_start = VIsual;
  curbuf->b_visual_end = curwin->w_cursor;
  curbuf->b_visual_mode = VIsual_mode;
  }
  if (p_smd) {
    clear_cmdline = 1;
  }
  if (curwin->w_cursor.col > 0U) {
    {
    tmp = ml_get_cursor();
    }
    if ((int )*tmp == 0) {
      (curwin->w_cursor.col) --;
    }
  }
  return;
}
}
int find_ident_under_cursor(char_u **string___0 , int find_type ) 
{ 
  char_u *ptr ;
  int col ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  col = 0;
  ptr = ml_get_curline();
  }
  if (find_type & 1) {
    i___0 = 0;
  } else {
    i___0 = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break;
    }
    col = (int )curwin->w_cursor.col;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((int )*(ptr + col) != 0) {
        if (i___0 == 0) {
          {
          tmp = vim_iswordc((int )*(ptr + col));
          }
          if (tmp) {
            tmp___0 = 0;
          } else {
            tmp___0 = 1;
          }
          tmp___2 = tmp___0;
        } else {
          if ((int )*(ptr + col) == 32) {
            tmp___1 = 1;
          } else { //Added block
          if ((int )*(ptr + col) == 9) {
            tmp___1 = 1;
          } else {
            tmp___1 = 0;
          }
          }
          tmp___2 = tmp___1;
        }
        if (! tmp___2) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (col > 0) {
        if (i___0 == 0) {
          {
          tmp___3 = vim_iswordc((int )*(ptr + (col - 1)));
          tmp___6 = tmp___3;
          }
        } else {
          if ((int )*(ptr + (col - 1)) == 32) {
            tmp___5 = 0;
          } else { //Added block
          if ((int )*(ptr + (col - 1)) == 9) {
            tmp___5 = 0;
          } else { //Added block
          if (! (find_type & 1)) {
            tmp___5 = 1;
          } else {
            {
            tmp___4 = vim_iswordc((int )*(ptr + (col - 1)));
            }
            if (tmp___4) {
              tmp___5 = 0;
            } else {
              tmp___5 = 1;
            }
          }
          }
          }
          tmp___6 = tmp___5;
        }
        if (! tmp___6) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      col --;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (! (find_type & 2)) {
      goto while_break;
    } else {
      {
      tmp___7 = vim_iswordc((int )*(ptr + col));
      }
      if (tmp___7) {
        goto while_break;
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*(ptr + col) == 0) {
    goto _L;
  } else {
    {
    tmp___8 = vim_iswordc((int )*(ptr + col));
    }
    if (! tmp___8) {
      if (i___0 == 0) {
        _L: 
        if (find_type & 2) {
          {
          emsg((char_u *)"No string under cursor");
          }
        } else {
          {
          emsg((char_u *)"No identifier under cursor");
          }
        }
        return (0);
      }
    }
  }
  ptr += col;
  *string___0 = ptr;
  col = 0;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (i___0 == 0) {
      {
      tmp___9 = vim_iswordc((int )*ptr);
      tmp___11 = tmp___9;
      }
    } else {
      if ((int )*ptr != 0) {
        if ((int )*ptr == 32) {
          tmp___10 = 0;
        } else { //Added block
        if ((int )*ptr == 9) {
          tmp___10 = 0;
        } else {
          tmp___10 = 1;
        }
        }
      } else {
        tmp___10 = 0;
      }
      tmp___11 = tmp___10;
    }
    if (! tmp___11) {
      goto while_break___2;
    }
    ptr ++;
    col ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return (col);
}
}
static void prep_redo_cmd(CMDARG *cap ) 
{ 


  {
  {
  prep_redo((cap->oap)->regname, cap->count0, '\000', cap->cmdchar, '\000', cap->nchar);
  }
  return;
}
}
static void prep_redo(int regname___0 , long num , int cmd1 , int cmd2 , int cmd3 ,
                      int cmd4 ) 
{ 


  {
  {
  ResetRedobuff();
  }
  if (regname___0 != 0) {
    {
    AppendCharToRedobuff('\"');
    AppendCharToRedobuff(regname___0);
    }
  }
  if (num) {
    {
    AppendNumberToRedobuff(num);
    }
  }
  if (cmd1 != 0) {
    {
    AppendCharToRedobuff(cmd1);
    }
  }
  if (cmd2 != 0) {
    {
    AppendCharToRedobuff(cmd2);
    }
  }
  if (cmd3 != 0) {
    {
    AppendCharToRedobuff(cmd3);
    }
  }
  if (cmd4 != 0) {
    {
    AppendCharToRedobuff(cmd4);
    }
  }
  return;
}
}
static int checkclearop(OPARG *oap ) 
{ 


  {
  if (oap->op_type == 0) {
    return (0);
  }
  {
  clearopbeep(oap);
  }
  return (1);
}
}
static int checkclearopq(OPARG *oap ) 
{ 


  {
  if (oap->op_type == 0) {
    if (! VIsual_active) {
      return (0);
    }
  }
  {
  clearopbeep(oap);
  }
  return (1);
}
}
static void clearop(OPARG *oap ) 
{ 


  {
  oap->op_type = 0;
  oap->regname = 0;
  return;
}
}
static void clearopbeep(OPARG *oap ) 
{ 


  {
  {
  clearop(oap);
  beep_flush();
  }
  return;
}
}
static char_u showcmd_buf[11]  ;
static char_u old_showcmd_buf[11]  ;
static int showcmd_is_clear  =    1;
static void display_showcmd(void) ;
void clear_showcmd(void) 
{ 


  {
  if (! p_sc) {
    return;
  }
  showcmd_buf[0] = (char_u )'\000';
  if (showcmd_is_clear) {
    return;
  }
  {
  display_showcmd();
  }
  return;
}
}
static int ignore[13]  = 
  {      253 + (51 << 8),      253 + (42 << 8),      253 + (43 << 8),      253 + (44 << 8), 
        253 + (45 << 8),      253 + (46 << 8),      253 + (47 << 8),      253 + (48 << 8), 
        253 + (49 << 8),      253 + (50 << 8),      253 + (67 << 8),      253 + (68 << 8), 
        0};
int add_to_showcmd(int c ) 
{ 
  char_u *p___0 ;
  int old_len ;
  int extra_len ;
  int overflow ;
  int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (! p_sc) {
    return (0);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ignore[i___0]) {
      goto while_break;
    }
    if (ignore[i___0] == c) {
      return (0);
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  p___0 = transchar(c);
  tmp = strlen((char const   *)((char *)(showcmd_buf)));
  old_len = (int )tmp;
  tmp___0 = strlen((char const   *)((char *)p___0));
  extra_len = (int )tmp___0;
  overflow = (old_len + extra_len) - 10;
  }
  if (overflow > 0) {
    {
    strcpy((char * __restrict  )((char *)(showcmd_buf)), (char const   * __restrict  )((char *)(showcmd_buf + overflow)));
    }
  }
  {
  strcat((char * __restrict  )((char *)(showcmd_buf)), (char const   * __restrict  )((char *)p___0));
  tmp___1 = char_avail();
  }
  if (tmp___1) {
    return (0);
  }
  {
  display_showcmd();
  }
  return (1);
}
}
void add_to_showcmd_c(int c ) 
{ 
  int tmp ;

  {
  {
  tmp = add_to_showcmd(c);
  }
  if (! tmp) {
    {
    setcursor();
    }
  }
  return;
}
}
static void del_from_showcmd(int len___0 ) 
{ 
  int old_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  if (! p_sc) {
    return;
  }
  {
  tmp = strlen((char const   *)((char *)(showcmd_buf)));
  old_len = (int )tmp;
  }
  if (len___0 > old_len) {
    len___0 = old_len;
  }
  {
  showcmd_buf[old_len - len___0] = (char_u )'\000';
  tmp___0 = char_avail();
  }
  if (! tmp___0) {
    {
    display_showcmd();
    }
  }
  return;
}
}
void push_showcmd(void) 
{ 


  {
  if (p_sc) {
    {
    strcpy((char * __restrict  )((char *)(old_showcmd_buf)), (char const   * __restrict  )((char *)(showcmd_buf)));
    }
  }
  return;
}
}
void pop_showcmd(void) 
{ 


  {
  if (! p_sc) {
    return;
  }
  {
  strcpy((char * __restrict  )((char *)(showcmd_buf)), (char const   * __restrict  )((char *)(old_showcmd_buf)));
  display_showcmd();
  }
  return;
}
}
static void display_showcmd(void) 
{ 
  int len___0 ;
  size_t tmp ;

  {
  {
  cursor_off();
  tmp = strlen((char const   *)((char *)(showcmd_buf)));
  len___0 = (int )tmp;
  }
  if (len___0 == 0) {
    showcmd_is_clear = 1;
  } else {
    {
    screen_puts(showcmd_buf, (int )Rows - 1, sc_col, 0);
    showcmd_is_clear = 0;
    }
  }
  {
  screen_puts((char_u *)"          " + len___0, (int )Rows - 1, sc_col + len___0,
              0);
  setcursor();
  }
  return;
}
}
static WIN *old_curwin  =    (WIN *)((void *)0);
static linenr_t old_topline  =    (linenr_t )0;
static BUF *old_buf  =    (BUF *)((void *)0);
static colnr_t old_leftcol  =    (colnr_t )0;
void do_check_scrollbind(int check ) 
{ 
  char_u *tmp ;

  {
  if (check) {
    if (curwin->w_p_scb) {
      if (did_syncbind) {
        did_syncbind = 0;
      } else { //Added block
      if ((unsigned long )curwin == (unsigned long )old_curwin) {
        if ((unsigned long )curwin->w_buffer == (unsigned long )old_buf) {
          if (curwin->w_topline != old_topline) {
            {
            check_scrollbind(curwin->w_topline - old_topline, (long )(curwin->w_leftcol - old_leftcol));
            }
          } else { //Added block
          if (curwin->w_leftcol != old_leftcol) {
            {
            check_scrollbind(curwin->w_topline - old_topline, (long )(curwin->w_leftcol - old_leftcol));
            }
          }
          }
        }
      } else {
        {
        tmp = vim_strchr(p_sbo, 'j');
        }
        if (tmp) {
          {
          check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);
          }
        }
      }
      }
      curwin->w_scbind_pos = curwin->w_topline;
    }
  }
  old_curwin = curwin;
  old_topline = curwin->w_topline;
  old_buf = curwin->w_buffer;
  old_leftcol = curwin->w_leftcol;
  return;
}
}
void check_scrollbind(linenr_t topline_diff , long leftcol_diff ) 
{ 
  int want_ver ;
  int want_hor ;
  WIN *old_curwin___0 ;
  BUF *old_curbuf ;
  int update ;
  int old_VIsual_select ;
  int old_VIsual_active ;
  colnr_t tgt_leftcol ;
  long topline ;
  long y ;
  char_u *tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  {
  old_curwin___0 = curwin;
  old_curbuf = curbuf;
  update = 0;
  old_VIsual_select = VIsual_select;
  old_VIsual_active = VIsual_active;
  tgt_leftcol = curwin->w_leftcol;
  tmp = vim_strchr(p_sbo, 'v');
  }
  if (tmp) {
    if (topline_diff) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  {
  want_ver = tmp___0;
  tmp___1 = vim_strchr(p_sbo, 'h');
  }
  if (tmp___1) {
    if (leftcol_diff) {
      tmp___2 = 1;
    } else { //Added block
    if (topline_diff) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    }
  } else {
    tmp___2 = 0;
  }
  want_hor = tmp___2;
  VIsual_active = 0;
  VIsual_select = VIsual_active;
  curwin = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! curwin) {
      goto while_break;
    }
    curbuf = curwin->w_buffer;
    if ((unsigned long )curwin != (unsigned long )old_curwin___0) {
      if (curwin->w_p_scb) {
        if (want_ver) {
          curwin->w_scbind_pos += topline_diff;
          topline = curwin->w_scbind_pos;
          if (topline > curbuf->b_ml.ml_line_count - p_so) {
            topline = curbuf->b_ml.ml_line_count - p_so;
          }
          if (topline < 1L) {
            topline = 1L;
          }
          y = topline - curwin->w_topline;
          if (y > 0L) {
            {
            scrollup(y);
            }
          } else {
            {
            scrolldown(- y);
            }
          }
          {
          redraw_later(10);
          cursor_correct();
          curwin->w_redr_status = 1;
          }
        }
        if (want_hor) {
          if (curwin->w_leftcol != tgt_leftcol) {
            {
            curwin->w_leftcol = tgt_leftcol;
            leftcol_changed();
            }
          }
        }
        update = 1;
      }
    }
    curwin = curwin->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  VIsual_select = old_VIsual_select;
  VIsual_active = old_VIsual_active;
  curwin = old_curwin___0;
  curbuf = old_curbuf;
  out_flush();
  }
  if (update) {
    {
    update_screen(40);
    }
  }
  return;
}
}
static void nv_gd(OPARG *oap , int nchar ) 
{ 
  int len___0 ;
  char_u *pat ;
  FPOS old_pos ;
  int t ;
  int save_p_ws ;
  int save_p_scs ;
  char_u *ptr ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  int tmp___6 ;

  {
  {
  len___0 = find_ident_under_cursor(& ptr, 1);
  }
  if (len___0 == 0) {
    {
    clearopbeep(oap);
    }
    return;
  } else {
    {
    pat = alloc((unsigned int )(len___0 + 5));
    }
    if ((unsigned long )pat == (unsigned long )((void *)0)) {
      {
      clearopbeep(oap);
      }
      return;
    }
  }
  {
  tmp___1 = vim_iswordc((int )*ptr);
  }
  if (tmp___1) {
    tmp___0 = "\\<%.*s\\>";
  } else {
    tmp___0 = "%.*s";
  }
  {
  sprintf((char * __restrict  )((char *)pat), (char const   * __restrict  )tmp___0,
          len___0, ptr);
  old_pos = curwin->w_cursor;
  save_p_ws = p_ws;
  save_p_scs = p_scs;
  p_ws = 0;
  p_scs = 0;
  fo_do_comments = 1;
  }
  if (nchar == 68) {
    {
    setpcmark();
    curwin->w_cursor.lnum = (linenr_t )1;
    }
  } else {
    {
    tmp___4 = findpar(oap, -1, 1L, '{', 0);
    }
    if (tmp___4) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (curwin->w_cursor.lnum > 1L) {
          {
          tmp___2 = ml_get_curline();
          tmp___3 = skipwhite(tmp___2);
          }
          if (! ((int )*tmp___3 != 0)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        (curwin->w_cursor.lnum) --;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
      setpcmark();
      curwin->w_cursor.lnum = (linenr_t )1;
      }
    }
  }
  curwin->w_cursor.col = (colnr_t )0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    t = searchit(curbuf, & curwin->w_cursor, 1, pat, 1L, 0, 2);
    }
    if (t == 1) {
      {
      tmp___5 = ml_get_curline();
      tmp___6 = get_leader_len(tmp___5, (char_u **)((void *)0), 0);
      }
      if (tmp___6) {
        if (! (old_pos.lnum > curwin->w_cursor.lnum)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    (curwin->w_cursor.lnum) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (t == 0) {
    {
    clearopbeep(oap);
    curwin->w_cursor = old_pos;
    }
  } else { //Added block
  if (old_pos.lnum <= curwin->w_cursor.lnum) {
    {
    clearopbeep(oap);
    curwin->w_cursor = old_pos;
    }
  } else {
    curwin->w_set_curswant = 1;
  }
  }
  {
  vim_free((void *)pat);
  p_ws = save_p_ws;
  p_scs = save_p_scs;
  fo_do_comments = 0;
  }
  return;
}
}
static int nv_screengo(OPARG *oap , int dir , long dist ) 
{ 
  int linelen___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int retval ;
  int atend ;
  int n ;
  int tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  long tmp___6 ;

  {
  {
  tmp = ml_get_curline();
  tmp___0 = linetabsize(tmp);
  linelen___0 = tmp___0;
  retval = 1;
  atend = 0;
  oap->motion_type = 0;
  oap->inclusive = 0;
  }
  if (curwin->w_curswant == 2147483647U) {
    {
    atend = 1;
    validate_virtcol();
    }
    if (curwin->w_p_nu) {
      tmp___1 = 8;
    } else {
      tmp___1 = 0;
    }
    curwin->w_curswant = (colnr_t )(((long )(curwin->w_virtcol + (colnr_t )tmp___1) / Columns + 1L) * Columns - 1L);
    if (curwin->w_p_nu) {
      if (curwin->w_curswant > 8U) {
        curwin->w_curswant -= 8U;
      }
    }
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (curwin->w_curswant >= (colnr_t )((long )linelen___0 + Columns))) {
        goto while_break;
      }
      curwin->w_curswant = (colnr_t )((long )curwin->w_curswant - Columns);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    tmp___6 = dist;
    dist --;
    if (! tmp___6) {
      goto while_break___0;
    }
    if (dir == -1) {
      if ((long )curwin->w_curswant >= Columns) {
        curwin->w_curswant = (colnr_t )((long )curwin->w_curswant - Columns);
      } else {
        if (curwin->w_cursor.lnum == 1L) {
          retval = 0;
          goto while_break___0;
        }
        {
        (curwin->w_cursor.lnum) --;
        tmp___2 = ml_get_curline();
        linelen___0 = linetabsize(tmp___2);
        }
        if (curwin->w_p_nu) {
          tmp___3 = 8;
        } else {
          tmp___3 = 0;
        }
        n = (int )(((long )((linelen___0 + tmp___3) - 1) / Columns) * Columns);
        if (curwin->w_p_nu) {
          if ((long )curwin->w_curswant >= Columns - 8L) {
            if (n) {
              n = (int )((long )n - Columns);
            }
          }
        }
        curwin->w_curswant += (colnr_t )n;
      }
    } else {
      if (curwin->w_p_nu) {
        tmp___4 = 8;
      } else {
        tmp___4 = 0;
      }
      n = (int )(((long )((linelen___0 + tmp___4) - 1) / Columns) * Columns);
      if (curwin->w_p_nu) {
        if (n > 8) {
          n -= 8;
        }
      }
      if (curwin->w_curswant < (colnr_t )n) {
        curwin->w_curswant = (colnr_t )((long )curwin->w_curswant + Columns);
      } else {
        if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {
          retval = 0;
          goto while_break___0;
        }
        {
        (curwin->w_cursor.lnum) ++;
        tmp___5 = ml_get_curline();
        linelen___0 = linetabsize(tmp___5);
        curwin->w_curswant = (colnr_t )((long )curwin->w_curswant % Columns);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  coladvance(curwin->w_curswant);
  }
  if (atend) {
    curwin->w_curswant = (colnr_t )2147483647;
  }
  return (retval);
}
}
static void nv_scroll_line(CMDARG *cap , int is_ctrl_e ) 
{ 
  int tmp ;

  {
  {
  tmp = checkclearop(cap->oap);
  }
  if (tmp) {
    return;
  }
  {
  scroll_redraw(is_ctrl_e, cap->count1);
  }
  return;
}
}
void scroll_redraw(int up , long count___2 ) 
{ 
  linenr_t prev_topline ;
  linenr_t prev_lnum ;

  {
  prev_topline = curwin->w_topline;
  prev_lnum = curwin->w_cursor.lnum;
  if (up) {
    {
    scrollup(count___2);
    }
  } else {
    {
    scrolldown(count___2);
    }
  }
  if (p_so) {
    {
    cursor_correct();
    update_topline();
    }
    if (curwin->w_topline == prev_topline) {
      if (up) {
        {
        cursor_down(1L, 0);
        }
      } else { //Added block
      if (prev_topline != 1L) {
        {
        cursor_up(1L, 0);
        }
      }
      }
    }
  }
  if (curwin->w_cursor.lnum != prev_lnum) {
    {
    coladvance(curwin->w_curswant);
    }
  }
  {
  update_screen(10);
  }
  return;
}
}
static void nv_zet(CMDARG *cap ) 
{ 
  long n ;
  colnr_t col ;
  int nchar ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  nchar = cap->nchar;
  tmp___0 = vim_isdigit(nchar);
  }
  if (tmp___0) {
    n = (long )(nchar - 48);
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      no_mapping ++;
      allow_keys ++;
      nchar = safe_vgetc();
      no_mapping --;
      allow_keys --;
      add_to_showcmd(nchar);
      }
      if (nchar == 107 + (68 << 8)) {
        n /= 10L;
      } else { //Added block
      if (nchar == 253 + (70 << 8)) {
        n /= 10L;
      } else {
        {
        tmp = vim_isdigit(nchar);
        }
        if (tmp) {
          n = n * 10L + (long )(nchar - 48);
        } else { //Added block
        if (nchar == 13) {
          {
          win_setheight((int )n);
          }
          goto while_break;
        } else { //Added block
        if (nchar == 108) {
          goto _L;
        } else { //Added block
        if (nchar == 104) {
          goto _L;
        } else { //Added block
        if (nchar == 107 + (108 << 8)) {
          goto _L;
        } else { //Added block
        if (nchar == 107 + (114 << 8)) {
          _L: 
          if (n) {
            cap->count1 = n * cap->count1;
          } else {
            cap->count1 = cap->count1;
          }
          goto dozet;
        } else {
          {
          clearopbeep(cap->oap);
          }
          goto while_break;
        }
        }
        }
        }
        }
        }
      }
      }
    }
    while_break: /* CIL Label */ ;
    }
    (cap->oap)->op_type = 0;
    return;
  }
  dozet: 
  {
  tmp___1 = vim_strchr((char_u *)"hles", nchar);
  }
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    if (nchar != 107 + (108 << 8)) {
      if (nchar != 107 + (114 << 8)) {
        if (cap->count0) {
          if (cap->count0 != curwin->w_cursor.lnum) {
            {
            setpcmark();
            }
            if (cap->count0 > curbuf->b_ml.ml_line_count) {
              curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
            } else {
              curwin->w_cursor.lnum = cap->count0;
            }
          }
        }
      }
    }
  }
  {
  if (nchar == 43) {
    goto case_43;
  }
  if (nchar == 75 + (54 << 8)) {
    goto case_43;
  }
  if (nchar == 10) {
    goto case_10;
  }
  if (nchar == 13) {
    goto case_10;
  }
  if (nchar == 75 + (65 << 8)) {
    goto case_10;
  }
  if (nchar == 116) {
    goto case_116;
  }
  if (nchar == 46) {
    goto case_46;
  }
  if (nchar == 122) {
    goto case_122;
  }
  if (nchar == 94) {
    goto case_94;
  }
  if (nchar == 45) {
    goto case_45;
  }
  if (nchar == 75 + (55 << 8)) {
    goto case_45;
  }
  if (nchar == 98) {
    goto case_98;
  }
  if (nchar == 72) {
    goto case_72;
  }
  if (nchar == 104) {
    goto case_104;
  }
  if (nchar == 107 + (108 << 8)) {
    goto case_104;
  }
  if (nchar == 76) {
    goto case_76;
  }
  if (nchar == 108) {
    goto case_108;
  }
  if (nchar == 107 + (114 << 8)) {
    goto case_108;
  }
  if (nchar == 115) {
    goto case_115;
  }
  if (nchar == 101) {
    goto case_101;
  }
  if (nchar == 19) {
    goto case_19;
  }
  if (nchar == 17) {
    goto case_19;
  }
  goto switch_default;
  case_43: /* CIL Label */ 
  case_exp: /* CIL Label */ 
  if (cap->count0 == 0L) {
    {
    validate_botline();
    }
    if (curwin->w_botline > curbuf->b_ml.ml_line_count) {
      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
    } else {
      curwin->w_cursor.lnum = curwin->w_botline;
    }
  }
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_exp___0: /* CIL Label */ 
  {
  beginline(5);
  }
  case_116: /* CIL Label */ 
  {
  scroll_cursor_top(0, 1);
  }
  goto switch_break;
  case_46: /* CIL Label */ 
  {
  beginline(5);
  }
  case_122: /* CIL Label */ 
  {
  scroll_cursor_halfway(1);
  }
  goto switch_break;
  case_94: /* CIL Label */ 
  if (cap->count0 != 0L) {
    {
    scroll_cursor_bot(0, 1);
    curwin->w_cursor.lnum = curwin->w_topline;
    }
  } else { //Added block
  if (curwin->w_topline == 1L) {
    curwin->w_cursor.lnum = (linenr_t )1;
  } else {
    curwin->w_cursor.lnum = curwin->w_topline - 1L;
  }
  }
  case_45: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
  {
  beginline(5);
  }
  case_98: /* CIL Label */ 
  {
  scroll_cursor_bot(0, 1);
  }
  goto switch_break;
  case_72: /* CIL Label */ 
  cap->count1 *= Columns / 2L;
  case_104: /* CIL Label */ 
  case_exp___2: /* CIL Label */ 
  if (! curwin->w_p_wrap) {
    if ((colnr_t )cap->count1 > curwin->w_leftcol) {
      curwin->w_leftcol = (colnr_t )0;
    } else {
      curwin->w_leftcol -= (colnr_t )cap->count1;
    }
    {
    leftcol_changed();
    }
  }
  goto switch_break;
  case_76: /* CIL Label */ 
  cap->count1 *= Columns / 2L;
  case_108: /* CIL Label */ 
  case_exp___3: /* CIL Label */ 
  if (! curwin->w_p_wrap) {
    {
    curwin->w_leftcol += (colnr_t )cap->count1;
    leftcol_changed();
    }
  }
  goto switch_break;
  case_115: /* CIL Label */ 
  if (! curwin->w_p_wrap) {
    {
    getvcol(curwin, & curwin->w_cursor, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
    curwin->w_leftcol = col;
    redraw_later(40);
    }
  }
  goto switch_break;
  case_101: /* CIL Label */ 
  if (! curwin->w_p_wrap) {
    {
    getvcol(curwin, & curwin->w_cursor, (colnr_t *)((void *)0), (colnr_t *)((void *)0),
            & col);
    n = Columns;
    }
    if (curwin->w_p_nu) {
      n -= 8L;
    }
    if ((long )col < n) {
      curwin->w_leftcol = (colnr_t )0;
    } else {
      curwin->w_leftcol = (colnr_t )(((long )col - n) + 1L);
    }
    {
    redraw_later(40);
    }
  }
  goto switch_break;
  case_19: /* CIL Label */ 
  case_17: /* CIL Label */ 
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  clearopbeep(cap->oap);
  }
  switch_break: /* CIL Label */ ;
  }
  {
  update_screen(10);
  }
  return;
}
}
static void nv_colon(CMDARG *cap ) 
{ 
  int old_p_im ;
  int tmp ;

  {
  if (VIsual_active) {
    {
    nv_operator(cap);
    }
  } else {
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      if (cap->count0) {
        {
        stuffcharReadbuff('.');
        }
        if (cap->count0 > 1L) {
          {
          stuffReadbuff((char_u *)",.+");
          stuffnumReadbuff(cap->count0 - 1L);
          }
        }
      }
      if (KeyTyped) {
        {
        compute_cmdrow();
        }
      }
      {
      old_p_im = p_im;
      do_cmdline((char_u *)((void *)0), & getexline, (void *)0, 0);
      }
      if (p_im != old_p_im) {
        if (p_im) {
          restart_edit = 'i';
        } else {
          restart_edit = 0;
        }
      }
    }
  }
  return;
}
}
static void nv_ctrlg(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (VIsual_active) {
    {
    VIsual_select = ! VIsual_select;
    showmode();
    }
  } else {
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      {
      fileinfo((int )cap->count0, 0, 1);
      }
    }
  }
  return;
}
}
static void nv_zzet(CMDARG *cap ) 
{ 
  int tmp ;

  {
  {
  tmp = checkclearopq(cap->oap);
  }
  if (! tmp) {
    if (cap->nchar == 90) {
      {
      do_cmdline((char_u *)"x", (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
                 3);
      }
    } else { //Added block
    if (cap->nchar == 81) {
      {
      do_cmdline((char_u *)"q!", (char_u *(*)(int  , void * , int  ))((void *)0),
                 (void *)0, 3);
      }
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
    }
  }
  return;
}
}
static void nv_ident(CMDARG *cap , char_u **searchp ) 
{ 
  char_u *ptr ;
  int n ;
  int cmdchar ;
  int g_cmd ;
  char_u *aux_ptr ;
  int isman ;
  int isman_s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  ptr = (char_u *)((void *)0);
  n = 0;
  if (cap->cmdchar == 103) {
    cmdchar = cap->nchar;
    g_cmd = 1;
  } else {
    cmdchar = cap->cmdchar;
    g_cmd = 0;
  }
  if (cmdchar == 93) {
    goto _L;
  } else { //Added block
  if (cmdchar == 29) {
    goto _L;
  } else { //Added block
  if (cmdchar == 75) {
    _L: 
    if (VIsual_active) {
      if (VIsual_mode != 86) {
        {
        unadjust_for_sel();
        }
      }
      if (VIsual.lnum != curwin->w_cursor.lnum) {
        {
        clearopbeep(cap->oap);
        }
        return;
      }
      if (curwin->w_cursor.lnum != VIsual.lnum) {
        tmp = curwin->w_cursor.lnum < VIsual.lnum;
      } else {
        tmp = curwin->w_cursor.col < VIsual.col;
      }
      if (tmp) {
        {
        ptr = ml_get_pos(& curwin->w_cursor);
        n = (int )((VIsual.col - curwin->w_cursor.col) + 1U);
        }
      } else {
        {
        ptr = ml_get_pos(& VIsual);
        n = (int )((curwin->w_cursor.col - VIsual.col) + 1U);
        }
      }
      {
      end_visual_mode();
      VIsual_reselect = 0;
      redraw_curbuf_later(40);
      }
    }
    {
    tmp___0 = checkclearopq(cap->oap);
    }
    if (tmp___0) {
      return;
    }
  }
  }
  }
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    if (cmdchar == 42) {
      tmp___1 = 3;
    } else { //Added block
    if (cmdchar == 35) {
      tmp___1 = 3;
    } else {
      tmp___1 = 1;
    }
    }
    {
    n = find_ident_under_cursor(& ptr, tmp___1);
    }
    if (n == 0) {
      {
      clearop(cap->oap);
      }
      return;
    }
  }
  {
  tmp___2 = strcmp((char const   *)((char *)p_kp), (char const   *)((char *)"man"));
  isman = tmp___2 == 0;
  tmp___3 = strcmp((char const   *)((char *)p_kp), (char const   *)((char *)"man -s"));
  isman_s = tmp___3 == 0;
  }
  if (cap->count0) {
    if (cmdchar == 75) {
      if (! isman) {
        if (! isman_s) {
          goto _L___0;
        }
      }
    } else { //Added block
    _L___0: 
    if (! (cmdchar == 42)) {
      if (! (cmdchar == 35)) {
        {
        stuffnumReadbuff(cap->count0);
        }
      }
    }
    }
  }
  {
  if (cmdchar == 42) {
    goto case_42;
  }
  if (cmdchar == 35) {
    goto case_42;
  }
  if (cmdchar == 75) {
    goto case_75;
  }
  if (cmdchar == 93) {
    goto case_93;
  }
  goto switch_default;
  case_42: /* CIL Label */ 
  case_35: /* CIL Label */ 
  {
  setpcmark();
  tmp___4 = ml_get_curline();
  curwin->w_cursor.col = (colnr_t )(ptr - tmp___4);
  }
  if (! g_cmd) {
    {
    tmp___5 = vim_iswordc((int )*ptr);
    }
    if (tmp___5) {
      {
      stuffReadbuff((char_u *)"\\<");
      }
    }
  }
  no_smartcase = 1;
  goto switch_break;
  case_75: /* CIL Label */ 
  if ((int )*p_kp == 0) {
    {
    stuffReadbuff((char_u *)":he ");
    }
  } else {
    {
    stuffReadbuff((char_u *)":! ");
    }
    if (! cap->count0) {
      if (isman_s) {
        {
        stuffReadbuff((char_u *)"man");
        }
      } else {
        {
        stuffReadbuff(p_kp);
        }
      }
    } else {
      {
      stuffReadbuff(p_kp);
      }
    }
    {
    stuffReadbuff((char_u *)" ");
    }
    if (cap->count0) {
      if (isman) {
        {
        stuffnumReadbuff(cap->count0);
        stuffReadbuff((char_u *)" ");
        }
      } else { //Added block
      if (isman_s) {
        {
        stuffnumReadbuff(cap->count0);
        stuffReadbuff((char_u *)" ");
        }
      }
      }
    }
  }
  goto switch_break;
  case_93: /* CIL Label */ 
  {
  stuffReadbuff((char_u *)":ts ");
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  if (curbuf->b_help) {
    {
    stuffReadbuff((char_u *)":he ");
    }
  } else { //Added block
  if (g_cmd) {
    {
    stuffReadbuff((char_u *)":tj ");
    }
  } else {
    {
    stuffReadbuff((char_u *)":ta ");
    }
  }
  }
  switch_break: /* CIL Label */ ;
  }
  if (cmdchar == 42) {
    goto _L___1;
  } else { //Added block
  if (cmdchar == 35) {
    _L___1: 
    if (p_magic) {
      tmp___6 = "/?.*~[^$\\";
    } else {
      tmp___6 = "/?^$\\";
    }
    aux_ptr = (char_u *)tmp___6;
  } else { //Added block
  if (cmdchar == 75) {
    if ((int )*p_kp != 0) {
      aux_ptr = escape_chars;
    } else {
      aux_ptr = (char_u *)"\\|\"";
    }
  } else {
    aux_ptr = (char_u *)"\\|\"";
  }
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___9 = n;
    n --;
    if (! tmp___9) {
      goto while_break;
    }
    {
    tmp___7 = vim_strchr(aux_ptr, (int )*ptr);
    }
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      {
      stuffcharReadbuff('\\');
      }
    } else { //Added block
    if ((int )*ptr < 32) {
      {
      stuffcharReadbuff(22);
      }
    } else { //Added block
    if ((int )*ptr > 126) {
      {
      stuffcharReadbuff(22);
      }
    }
    }
    }
    {
    tmp___8 = ptr;
    ptr ++;
    stuffcharReadbuff((int )*tmp___8);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (! g_cmd) {
    if (cmdchar == 42) {
      goto _L___2;
    } else { //Added block
    if (cmdchar == 35) {
      _L___2: 
      {
      tmp___10 = vim_iswordc((int )*(ptr + -1));
      }
      if (tmp___10) {
        {
        stuffReadbuff((char_u *)"\\>");
        }
      }
    }
    }
  }
  {
  stuffReadbuff((char_u *)"\n");
  }
  if (cmdchar == 42) {
    goto _L___3;
  } else { //Added block
  if (cmdchar == 35) {
    _L___3: 
    if (cmdchar == 42) {
      cap->cmdchar = '/';
    } else {
      cap->cmdchar = '?';
    }
    {
    nv_search(cap, searchp, 1);
    }
  }
  }
  return;
}
}
static void nv_scroll(CMDARG *cap ) 
{ 
  int used ;
  long n ;
  int tmp ;

  {
  {
  used = 0;
  (cap->oap)->motion_type = 1;
  setpcmark();
  }
  if (cap->cmdchar == 76) {
    {
    validate_botline();
    curwin->w_cursor.lnum = curwin->w_botline - 1L;
    }
    if (cap->count1 - 1L >= curwin->w_cursor.lnum) {
      curwin->w_cursor.lnum = (linenr_t )1;
    } else {
      curwin->w_cursor.lnum -= cap->count1 - 1L;
    }
  } else {
    if (cap->cmdchar == 77) {
      {
      validate_botline();
      n = 0L;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (curwin->w_topline + n < curbuf->b_ml.ml_line_count)) {
          goto while_break;
        }
        {
        tmp = plines(curwin->w_topline + n);
        used += tmp;
        }
        if (used >= ((curwin->w_height - curwin->w_empty_rows) + 1) / 2) {
          goto while_break;
        }
        n ++;
      }
      while_break: /* CIL Label */ ;
      }
      if (n) {
        if (used > curwin->w_height) {
          n --;
        }
      }
    } else {
      n = cap->count1 - 1L;
    }
    curwin->w_cursor.lnum = curwin->w_topline + n;
    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
    }
  }
  {
  cursor_correct();
  beginline(6);
  }
  return;
}
}
static void nv_right(CMDARG *cap ) 
{ 
  long n ;
  int past_line ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;

  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  if (VIsual_active) {
    if ((int )*p_sel != 111) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  past_line = tmp;
  n = cap->count1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (n > 0L)) {
      goto while_break;
    }
    if (! past_line) {
      {
      tmp___5 = oneright();
      }
      if (tmp___5 == 0) {
        goto _L___3;
      } else {
        goto _L___5;
      }
    } else { //Added block
    _L___5: 
    if (past_line) {
      {
      tmp___6 = ml_get_cursor();
      }
      if ((int )*tmp___6 == 0) {
        _L___3: 
        if (cap->cmdchar == 32) {
          {
          tmp___1 = vim_strchr(p_ww, 's');
          }
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
            goto _L___0;
          } else {
            goto _L___2;
          }
        } else { //Added block
        _L___2: 
        if (cap->cmdchar == 108) {
          {
          tmp___2 = vim_strchr(p_ww, 'l');
          }
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if (cap->cmdchar == 107 + (114 << 8)) {
          {
          tmp___3 = vim_strchr(p_ww, '>');
          }
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            _L___0: 
            if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
              if ((cap->oap)->op_type == 1) {
                goto _L;
              } else { //Added block
              if ((cap->oap)->op_type == 3) {
                _L: 
                if (! (cap->oap)->inclusive) {
                  {
                  tmp___0 = ml_get(curwin->w_cursor.lnum);
                  }
                  if ((int )*tmp___0 == 0) {
                    (curwin->w_cursor.lnum) ++;
                    curwin->w_cursor.col = (colnr_t )0;
                    curwin->w_set_curswant = 1;
                    (cap->oap)->inclusive = 0;
                  } else {
                    (cap->oap)->inclusive = 1;
                  }
                } else {
                  (curwin->w_cursor.lnum) ++;
                  curwin->w_cursor.col = (colnr_t )0;
                  curwin->w_set_curswant = 1;
                  (cap->oap)->inclusive = 0;
                }
              } else {
                (curwin->w_cursor.lnum) ++;
                curwin->w_cursor.col = (colnr_t )0;
                curwin->w_set_curswant = 1;
                (cap->oap)->inclusive = 0;
              }
              }
              goto __Cont;
            }
          }
        }
        }
        }
        if ((cap->oap)->op_type == 0) {
          if (n == cap->count1) {
            {
            beep_flush();
            }
          }
        } else {
          {
          tmp___4 = ml_get(curwin->w_cursor.lnum);
          }
          if (! ((int )*tmp___4 == 0)) {
            (cap->oap)->inclusive = 1;
          }
        }
        goto while_break;
      } else {
        goto _L___4;
      }
    } else { //Added block
    _L___4: 
    if (past_line) {
      curwin->w_set_curswant = 1;
      (curwin->w_cursor.col) ++;
    }
    }
    }
    __Cont: 
    n --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int nv_left(CMDARG *cap ) 
{ 
  long n ;
  int retval ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  retval = 0;
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  n = cap->count1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (n > 0L)) {
      goto while_break;
    }
    {
    tmp___3 = oneleft();
    }
    if (tmp___3 == 0) {
      if (cap->cmdchar == 107 + (98 << 8)) {
        goto _L___5;
      } else { //Added block
      if (cap->cmdchar == 8) {
        _L___5: 
        {
        tmp___0 = vim_strchr(p_ww, 'b');
        }
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
          goto _L___1;
        } else {
          goto _L___4;
        }
      } else { //Added block
      _L___4: 
      if (cap->cmdchar == 104) {
        {
        tmp___1 = vim_strchr(p_ww, 'h');
        }
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
          goto _L___1;
        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: 
      if (cap->cmdchar == 107 + (108 << 8)) {
        {
        tmp___2 = vim_strchr(p_ww, '<');
        }
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
          _L___1: 
          if (curwin->w_cursor.lnum > 1L) {
            {
            (curwin->w_cursor.lnum) --;
            coladvance((colnr_t )2147483647);
            curwin->w_set_curswant = 1;
            }
            if ((cap->oap)->op_type == 1) {
              goto _L;
            } else { //Added block
            if ((cap->oap)->op_type == 3) {
              _L: 
              {
              tmp = ml_get(curwin->w_cursor.lnum);
              }
              if (! ((int )*tmp == 0)) {
                (curwin->w_cursor.col) ++;
                retval = 1;
              }
            }
            }
            goto __Cont;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else { //Added block
      _L___2: 
      if ((cap->oap)->op_type == 0) {
        if (n == cap->count1) {
          {
          beep_flush();
          }
        }
      }
      }
      }
      }
      }
      goto while_break;
    }
    __Cont: 
    n --;
  }
  while_break: /* CIL Label */ ;
  }
  return (retval);
}
}
static void nv_gotofile(CMDARG *cap ) 
{ 
  char_u *ptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
  ptr = file_name_at_cursor(7, cap->count1);
  }
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
    tmp = curbuf_changed();
    }
    if (tmp) {
      if (curbuf->b_nwindows <= 1) {
        if (! p_hid) {
          {
          autowrite(curbuf, 0);
          }
        }
      }
    }
    {
    setpcmark();
    }
    if (p_hid) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    {
    do_ecmd(0, ptr, (char_u *)((void *)0), (char_u *)((void *)0), (linenr_t )-1, tmp___0);
    vim_free((void *)ptr);
    }
  } else {
    {
    clearop(cap->oap);
    }
  }
  return;
}
}
static void nv_dollar(CMDARG *cap ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 1;
  curwin->w_curswant = (colnr_t )2147483647;
  tmp = cursor_down(cap->count1 - 1L, (cap->oap)->op_type == 0);
  }
  if (tmp == 0) {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static void nv_search(CMDARG *cap , char_u **searchp , int dont_set_mark ) 
{ 
  OPARG *oap ;
  int i___0 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  oap = cap->oap;
  if (cap->cmdchar == 63) {
    if ((cap->oap)->op_type == 15) {
      {
      cap->cmdchar = 'g';
      cap->nchar = '?';
      nv_operator(cap);
      }
      return;
    }
  }
  {
  tmp = getcmdline(cap->cmdchar, cap->count1, 0);
  *searchp = tmp;
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    clearop(oap);
    }
    return;
  }
  oap->motion_type = 0;
  oap->inclusive = 0;
  curwin->w_set_curswant = 1;
  if (dont_set_mark) {
    tmp___0 = 0;
  } else {
    tmp___0 = 512;
  }
  {
  i___0 = do_search(oap, cap->cmdchar, *searchp, cap->count1, ((tmp___0 | 16) | 2) | 12);
  }
  if (i___0 == 0) {
    {
    clearop(oap);
    }
  } else { //Added block
  if (i___0 == 2) {
    oap->motion_type = 1;
  }
  }
  {
  adjust_cursor();
  }
  return;
}
}
static void nv_next(CMDARG *cap , int flag ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  tmp = do_search(cap->oap, 0, (char_u *)((void *)0), cap->count1, 542 | flag);
  }
  if (! tmp) {
    {
    clearop(cap->oap);
    }
  }
  {
  adjust_cursor();
  }
  return;
}
}
static void nv_csearch(CMDARG *cap , int dir , int type ) 
{ 
  int tmp ;

  {
  (cap->oap)->motion_type = 0;
  if (dir == -1) {
    (cap->oap)->inclusive = 0;
  } else {
    (cap->oap)->inclusive = 1;
  }
  if (cap->nchar >= 256) {
    {
    clearopbeep(cap->oap);
    }
  } else {
    {
    tmp = searchc(cap->nchar, dir, type, cap->count1);
    }
    if (tmp) {
      {
      curwin->w_set_curswant = 1;
      adjust_for_sel(cap);
      }
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
  }
  return;
}
}
static void nv_brackets(CMDARG *cap , int dir ) 
{ 
  FPOS new_pos ;
  FPOS prev_pos ;
  FPOS *pos___0 ;
  FPOS old_pos ;
  int flag ;
  long n ;
  int findc ;
  int c ;
  char_u *ptr ;
  int len___0 ;
  linenr_t tmp ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int norm ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;
  char_u *tmp___22 ;

  {
  pos___0 = (FPOS *)((void *)0);
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  old_pos = curwin->w_cursor;
  if (cap->nchar == 102) {
    {
    nv_gotofile(cap);
    }
  } else {
    {
    tmp___22 = vim_strchr((char_u *)"iI\tdD\004", cap->nchar);
    }
    if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
      {
      len___0 = find_ident_under_cursor(& ptr, 1);
      }
      if (len___0 == 0) {
        {
        clearop(cap->oap);
        }
      } else {
        if (cap->cmdchar == 93) {
          tmp = curwin->w_cursor.lnum;
        } else {
          tmp = (linenr_t )1;
        }
        {
        tmp___5 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___5 + cap->nchar) & 256) {
          tmp___4 = 4;
        } else {
          {
          tmp___3 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___3 + cap->nchar) & 512) {
            tmp___2 = 1;
          } else {
            tmp___2 = 2;
          }
          tmp___4 = tmp___2;
        }
        if ((cap->nchar & 15) == 4) {
          tmp___6 = 2;
        } else {
          tmp___6 = 1;
        }
        if (cap->count0 == 0L) {
          {
          tmp___7 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___7 + cap->nchar) & 256) {
            tmp___8 = 0;
          } else {
            tmp___8 = 1;
          }
          tmp___9 = tmp___8;
        } else {
          tmp___9 = 0;
        }
        {
        find_pattern_in_path(ptr, 0, len___0, 1, tmp___9, tmp___6, cap->count1, tmp___4,
                             tmp, (linenr_t )2147483647);
        curwin->w_set_curswant = 1;
        }
      }
    } else { //Added block
    if (cap->cmdchar == 91) {
      {
      tmp___20 = vim_strchr((char_u *)"{(*/#mM", cap->nchar);
      }
      if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
        goto _L___6;
      } else {
        goto _L___8;
      }
    } else { //Added block
    _L___8: 
    if (cap->cmdchar == 93) {
      {
      tmp___21 = vim_strchr((char_u *)"})*/#mM", cap->nchar);
      }
      if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
        _L___6: 
        if (cap->nchar == 42) {
          cap->nchar = '/';
        }
        new_pos.lnum = (linenr_t )0;
        prev_pos.lnum = (linenr_t )0;
        if (cap->nchar == 109) {
          goto _L;
        } else { //Added block
        if (cap->nchar == 77) {
          _L: 
          if (cap->cmdchar == 91) {
            findc = '{';
          } else {
            findc = '}';
          }
          n = 9999L;
        } else {
          findc = cap->nchar;
          n = cap->count1;
        }
        }
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (n > 0L)) {
            goto while_break;
          }
          if (cap->cmdchar == 91) {
            tmp___10 = 1;
          } else {
            tmp___10 = 2;
          }
          {
          pos___0 = findmatchlimit(cap->oap, findc, tmp___10, 0);
          }
          if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
            if (new_pos.lnum == 0L) {
              if (cap->nchar != 109) {
                if (cap->nchar != 77) {
                  {
                  clearopbeep(cap->oap);
                  }
                }
              }
            } else {
              pos___0 = & new_pos;
            }
            goto while_break;
          }
          prev_pos = new_pos;
          curwin->w_cursor = *pos___0;
          new_pos = *pos___0;
          n --;
        }
        while_break: /* CIL Label */ ;
        }
        curwin->w_cursor = old_pos;
        if (cap->nchar == 109) {
          goto _L___3;
        } else { //Added block
        if (cap->nchar == 77) {
          _L___3: 
          norm = (findc == 123) == (cap->nchar == 109);
          n = cap->count1;
          if (prev_pos.lnum != 0L) {
            pos___0 = & prev_pos;
            curwin->w_cursor = prev_pos;
            if (norm) {
              n --;
            }
          } else {
            pos___0 = (FPOS *)((void *)0);
          }
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (n > 0L)) {
              goto while_break___0;
            }
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (findc == 123) {
                {
                tmp___11 = dec_cursor();
                tmp___13 = tmp___11;
                }
              } else {
                {
                tmp___12 = inc_cursor();
                tmp___13 = tmp___12;
                }
              }
              if (tmp___13 < 0) {
                if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
                  {
                  clearopbeep(cap->oap);
                  }
                }
                n = 0L;
                goto while_break___1;
              }
              {
              c = gchar_cursor();
              }
              if (c == 123) {
                goto _L___2;
              } else { //Added block
              if (c == 125) {
                _L___2: 
                if (c == findc) {
                  if (norm) {
                    new_pos = curwin->w_cursor;
                    pos___0 = & new_pos;
                    n = 0L;
                  } else {
                    goto _L___1;
                  }
                } else { //Added block
                _L___1: 
                if (n == 1L) {
                  if (! norm) {
                    new_pos = curwin->w_cursor;
                    pos___0 = & new_pos;
                    n = 0L;
                  } else {
                    goto _L___0;
                  }
                } else { //Added block
                _L___0: 
                if (new_pos.lnum == 0L) {
                  new_pos = curwin->w_cursor;
                  pos___0 = & new_pos;
                } else {
                  if (cap->cmdchar == 91) {
                    tmp___14 = 1;
                  } else {
                    tmp___14 = 2;
                  }
                  {
                  pos___0 = findmatchlimit(cap->oap, findc, tmp___14, 0);
                  }
                  if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
                    n = 0L;
                  } else {
                    curwin->w_cursor = *pos___0;
                  }
                }
                }
                }
                goto while_break___1;
              }
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            n --;
          }
          while_break___0: /* CIL Label */ ;
          }
          curwin->w_cursor = old_pos;
          if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
            if (new_pos.lnum != 0L) {
              {
              clearopbeep(cap->oap);
              }
            }
          }
        }
        }
        if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
          {
          setpcmark();
          curwin->w_cursor = *pos___0;
          curwin->w_set_curswant = 1;
          }
        }
      } else {
        goto _L___7;
      }
    } else { //Added block
    _L___7: 
    if (cap->nchar == 91) {
      goto _L___5;
    } else { //Added block
    if (cap->nchar == 93) {
      _L___5: 
      if (cap->nchar == cap->cmdchar) {
        flag = '{';
      } else {
        flag = '}';
      }
      curwin->w_set_curswant = 1;
      if ((cap->oap)->op_type != 0) {
        if (dir == 1) {
          if (flag == 123) {
            tmp___15 = 1;
          } else {
            tmp___15 = 0;
          }
        } else {
          tmp___15 = 0;
        }
      } else {
        tmp___15 = 0;
      }
      {
      tmp___16 = findpar(cap->oap, dir, cap->count1, flag, tmp___15);
      }
      if (tmp___16) {
        if ((cap->oap)->op_type == 0) {
          {
          beginline(5);
          }
        }
      } else {
        {
        clearopbeep(cap->oap);
        }
      }
    } else { //Added block
    if (cap->nchar == 112) {
      goto _L___4;
    } else { //Added block
    if (cap->nchar == 80) {
      _L___4: 
      {
      tmp___18 = checkclearopq(cap->oap);
      }
      if (! tmp___18) {
        {
        prep_redo_cmd(cap);
        }
        if (cap->cmdchar == 93) {
          if (cap->nchar == 112) {
            tmp___17 = 1;
          } else {
            tmp___17 = -1;
          }
        } else {
          tmp___17 = -1;
        }
        {
        do_put((cap->oap)->regname, tmp___17, cap->count1, 1);
        }
      }
    } else { //Added block
    if (cap->nchar >= 253 + (42 << 8)) {
      if (cap->nchar <= 253 + (50 << 8)) {
        if (cap->cmdchar == 93) {
          tmp___19 = 1;
        } else {
          tmp___19 = -1;
        }
        {
        do_mouse(cap->oap, cap->nchar, tmp___19, cap->count1, 1);
        }
      } else {
        {
        clearopbeep(cap->oap);
        }
      }
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
    }
    }
    }
    }
    }
    }
    }
  }
  return;
}
}
static void nv_percent(CMDARG *cap ) 
{ 
  FPOS *pos___0 ;

  {
  (cap->oap)->inclusive = 1;
  if (cap->count0) {
    if (cap->count0 > 100L) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      {
      (cap->oap)->motion_type = 1;
      setpcmark();
      curwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count * cap->count0 + 99L) / 100L;
      beginline(6);
      }
    }
  } else {
    {
    (cap->oap)->motion_type = 0;
    pos___0 = findmatch(cap->oap, '\000');
    }
    if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      {
      setpcmark();
      curwin->w_cursor = *pos___0;
      curwin->w_set_curswant = 1;
      adjust_for_sel(cap);
      }
    }
  }
  return;
}
}
static void nv_brace(CMDARG *cap , int dir ) 
{ 
  int tmp ;

  {
  (cap->oap)->motion_type = 0;
  if (cap->cmdchar == 41) {
    (cap->oap)->inclusive = 0;
  } else {
    (cap->oap)->inclusive = 1;
  }
  {
  curwin->w_set_curswant = 1;
  tmp = findsent(dir, cap->count1);
  }
  if (tmp == 0) {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static void nv_findpar(CMDARG *cap , int dir ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  tmp = findpar(cap->oap, dir, cap->count1, '\000', 0);
  }
  if (! tmp) {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static int nv_replace(CMDARG *cap ) 
{ 
  char_u *ptr ;
  int had_ctrl_v ;
  int command_busy ;
  long n ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  command_busy = 0;
  if (VIsual_active) {
    {
    nv_operator(cap);
    }
    return (command_busy);
  }
  {
  tmp = checkclearop(cap->oap);
  }
  if (tmp) {
    return (command_busy);
  }
  {
  ptr = ml_get_cursor();
  }
  if (cap->nchar >= 256) {
    {
    clearopbeep(cap->oap);
    }
    return (0);
  } else {
    {
    tmp___0 = strlen((char const   *)((char *)ptr));
    }
    if (tmp___0 < (size_t )((unsigned int )cap->count1)) {
      {
      clearopbeep(cap->oap);
      }
      return (0);
    }
  }
  if (cap->nchar == 9) {
    if (curbuf->b_p_et) {
      {
      stuffnumReadbuff(cap->count1);
      stuffcharReadbuff('R');
      stuffcharReadbuff('\t');
      stuffcharReadbuff('\033');
      }
      return (0);
    } else { //Added block
    if (p_sta) {
      {
      stuffnumReadbuff(cap->count1);
      stuffcharReadbuff('R');
      stuffcharReadbuff('\t');
      stuffcharReadbuff('\033');
      }
      return (0);
    }
    }
  }
  if (cap->nchar == 22) {
    {
    had_ctrl_v = 22;
    cap->nchar = get_literal();
    }
  } else {
    had_ctrl_v = '\000';
  }
  {
  tmp___1 = u_save_cursor();
  }
  if (tmp___1 == 0) {
    return (0);
  }
  if (had_ctrl_v != 22) {
    if (cap->nchar == 13) {
      {
      del_chars(cap->count1, 0);
      stuffcharReadbuff('\r');
      stuffcharReadbuff('\033');
      command_busy = edit('r', 0, cap->count1);
      }
    } else { //Added block
    if (cap->nchar == 10) {
      {
      del_chars(cap->count1, 0);
      stuffcharReadbuff('\r');
      stuffcharReadbuff('\033');
      command_busy = edit('r', 0, cap->count1);
      }
    } else {
      goto _L;
    }
    }
  } else {
    _L: 
    {
    prep_redo((cap->oap)->regname, cap->count1, '\000', 'r', had_ctrl_v, cap->nchar);
    n = cap->count1;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (n > 0L)) {
        goto while_break;
      }
      {
      ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, 1);
      *(ptr + curwin->w_cursor.col) = (char_u )cap->nchar;
      }
      if (p_sm) {
        if (cap->nchar == 41) {
          {
          showmatch();
          }
        } else { //Added block
        if (cap->nchar == 125) {
          {
          showmatch();
          }
        } else { //Added block
        if (cap->nchar == 93) {
          {
          showmatch();
          }
        }
        }
        }
      }
      (curwin->w_cursor.col) ++;
      n --;
    }
    while_break: /* CIL Label */ ;
    }
    {
    (curwin->w_cursor.col) --;
    curwin->w_set_curswant = 1;
    set_last_insert(cap->nchar);
    changed_cline_bef_curs();
    approximate_botline();
    update_screenline();
    }
  }
  {
  changed();
  }
  return (command_busy);
}
}
static void v_swap_corners(CMDARG *cap ) 
{ 
  FPOS old_cursor ;
  colnr_t left ;
  colnr_t right ;

  {
  if (cap->cmdchar == 79) {
    if (VIsual_mode == 22) {
      {
      old_cursor = curwin->w_cursor;
      getvcols(& old_cursor, & VIsual, & left, & right);
      curwin->w_cursor.lnum = VIsual.lnum;
      coladvance(left);
      VIsual = curwin->w_cursor;
      curwin->w_cursor.lnum = old_cursor.lnum;
      coladvance(right);
      curwin->w_curswant = right;
      }
      if (curwin->w_cursor.col == old_cursor.col) {
        {
        curwin->w_cursor.lnum = VIsual.lnum;
        coladvance(right);
        VIsual = curwin->w_cursor;
        curwin->w_cursor.lnum = old_cursor.lnum;
        coladvance(left);
        curwin->w_curswant = left;
        }
      }
    }
  }
  if (cap->cmdchar != 79) {
    old_cursor = curwin->w_cursor;
    curwin->w_cursor = VIsual;
    VIsual = old_cursor;
    curwin->w_set_curswant = 1;
  } else { //Added block
  if (VIsual_mode != 22) {
    old_cursor = curwin->w_cursor;
    curwin->w_cursor = VIsual;
    VIsual = old_cursor;
    curwin->w_set_curswant = 1;
  }
  }
  return;
}
}
static int nv_Replace(CMDARG *cap ) 
{ 
  int command_busy ;
  int tmp ;
  int tmp___0 ;

  {
  command_busy = 0;
  if (VIsual_active) {
    {
    cap->cmdchar = 'c';
    VIsual_mode = 'V';
    nv_operator(cap);
    }
  } else {
    {
    tmp___0 = checkclearopq(cap->oap);
    }
    if (! tmp___0) {
      {
      tmp = u_save_cursor();
      }
      if (tmp == 1) {
        {
        restart_edit = 0;
        command_busy = edit('R', 0, cap->count1);
        }
      }
    }
  }
  return (command_busy);
}
}
static int nv_VReplace(CMDARG *cap ) 
{ 
  int command_busy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  command_busy = 0;
  if (VIsual_active) {
    {
    cap->cmdchar = 'R';
    cap->nchar = '\000';
    tmp = nv_Replace(cap);
    }
    return (tmp);
  } else {
    {
    tmp___1 = checkclearopq(cap->oap);
    }
    if (! tmp___1) {
      {
      tmp___0 = u_save_cursor();
      }
      if (tmp___0 == 1) {
        {
        restart_edit = 0;
        command_busy = edit('V', 0, cap->count1);
        }
      }
    }
  }
  return (command_busy);
}
}
static int nv_vreplace(CMDARG *cap ) 
{ 
  int command_busy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  command_busy = 0;
  if (VIsual_active) {
    {
    cap->cmdchar = 'r';
    cap->nchar = cap->extra_char;
    tmp = nv_replace(cap);
    }
    return (tmp);
  } else {
    {
    tmp___1 = checkclearopq(cap->oap);
    }
    if (! tmp___1) {
      {
      tmp___0 = u_save_cursor();
      }
      if (tmp___0 == 1) {
        if (cap->extra_char == 22) {
          {
          cap->extra_char = get_literal();
          }
        }
        {
        stuffcharReadbuff(cap->extra_char);
        stuffcharReadbuff('\033');
        restart_edit = 0;
        command_busy = edit('v', 0, cap->count1);
        }
      }
    }
  }
  return (command_busy);
}
}
static void n_swapchar(CMDARG *cap ) 
{ 
  long n ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;

  {
  {
  tmp = checkclearopq(cap->oap);
  }
  if (tmp) {
    return;
  }
  {
  tmp___0 = ml_get(curwin->w_cursor.lnum);
  }
  if ((int )*tmp___0 == 0) {
    {
    tmp___1 = vim_strchr(p_ww, '~');
    }
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      clearopbeep(cap->oap);
      }
      return;
    }
  }
  {
  prep_redo_cmd(cap);
  tmp___2 = u_save_cursor();
  }
  if (tmp___2 == 0) {
    return;
  }
  n = cap->count1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (n > 0L)) {
      goto while_break;
    }
    {
    swapchar((cap->oap)->op_type, & curwin->w_cursor);
    inc_cursor();
    tmp___5 = gchar_cursor();
    }
    if (tmp___5 == 0) {
      {
      tmp___4 = vim_strchr(p_ww, '~');
      }
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
        if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
          {
          (curwin->w_cursor.lnum) ++;
          curwin->w_cursor.col = (colnr_t )0;
          redraw_curbuf_later(40);
          }
          if (n > 1L) {
            {
            tmp___3 = u_savesub(curwin->w_cursor.lnum);
            }
            if (tmp___3 == 0) {
              goto while_break;
            }
            {
            u_clearline();
            }
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
    n --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  adjust_cursor();
  curwin->w_set_curswant = 1;
  changed();
  update_screenline();
  }
  return;
}
}
static void nv_cursormark(CMDARG *cap , int flag , FPOS *pos___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = check_mark(pos___0);
  }
  if (tmp == 0) {
    {
    clearop(cap->oap);
    }
  } else {
    if (cap->cmdchar == 39) {
      {
      setpcmark();
      }
    } else { //Added block
    if (cap->cmdchar == 96) {
      {
      setpcmark();
      }
    }
    }
    curwin->w_cursor = *pos___0;
    if (flag) {
      {
      beginline(5);
      }
    } else {
      {
      adjust_cursor();
      }
    }
  }
  if (flag) {
    (cap->oap)->motion_type = 1;
  } else {
    (cap->oap)->motion_type = 0;
  }
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  return;
}
}
static char_u trans[17]  = 
  {      (char_u )'Y',      (char_u )'y',      (char_u )'D',      (char_u )'d', 
        (char_u )'C',      (char_u )'c',      (char_u )'x',      (char_u )'d', 
        (char_u )'X',      (char_u )'d',      (char_u )'A',      (char_u )'A', 
        (char_u )'I',      (char_u )'I',      (char_u )'r',      (char_u )'r', 
        (char_u )'\000'};
static void v_visop(CMDARG *cap ) 
{ 
  unsigned short const   **tmp ;
  char_u *tmp___0 ;

  {
  {
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + cap->cmdchar) & 256) {
    if (VIsual_mode != 22) {
      VIsual_mode = 'V';
    } else { //Added block
    if (cap->cmdchar == 67) {
      curwin->w_curswant = (colnr_t )2147483647;
    } else { //Added block
    if (cap->cmdchar == 68) {
      curwin->w_curswant = (colnr_t )2147483647;
    }
    }
    }
  }
  {
  tmp___0 = vim_strchr(trans, cap->cmdchar);
  cap->cmdchar = (int )*(tmp___0 + 1);
  nv_operator(cap);
  }
  return;
}
}
static char_u *ar[8]  = 
  {      (char_u *)"dl",      (char_u *)"dh",      (char_u *)"d$",      (char_u *)"c$", 
        (char_u *)"cl",      (char_u *)"cc",      (char_u *)"yy",      (char_u *)":s\r"};
static char_u *str___0  =    (char_u *)"xXDCsSY&";
static void nv_optrans(CMDARG *cap ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = checkclearopq(cap->oap);
  }
  if (! tmp___0) {
    if (cap->count0) {
      {
      stuffnumReadbuff(cap->count0);
      }
    }
    {
    tmp = vim_strchr(str___0, cap->cmdchar);
    stuffReadbuff(ar[(int )(tmp - str___0)]);
    }
  }
  return;
}
}
static void nv_gomark(CMDARG *cap , int flag ) 
{ 
  FPOS *pos___0 ;

  {
  {
  pos___0 = getmark(cap->nchar, (cap->oap)->op_type == 0);
  }
  if ((unsigned long )pos___0 == (unsigned long )((FPOS *)-1)) {
    if (flag) {
      {
      check_cursor_lnum();
      beginline(5);
      }
    } else {
      {
      adjust_cursor();
      }
    }
  } else {
    {
    nv_cursormark(cap, flag, pos___0);
    }
  }
  return;
}
}
static void nv_pcmark(CMDARG *cap ) 
{ 
  FPOS *pos___0 ;
  int tmp ;

  {
  {
  tmp = checkclearopq(cap->oap);
  }
  if (! tmp) {
    {
    pos___0 = movemark((int )cap->count1);
    }
    if ((unsigned long )pos___0 == (unsigned long )((FPOS *)-1)) {
      {
      curwin->w_set_curswant = 1;
      adjust_cursor();
      }
    } else { //Added block
    if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
      {
      nv_cursormark(cap, 0, pos___0);
      }
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
    }
  }
  return;
}
}
static void nv_regname(CMDARG *cap , linenr_t *opnump ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = checkclearop(cap->oap);
  }
  if (tmp) {
    return;
  }
  if (cap->nchar == 61) {
    {
    cap->nchar = get_expr_register();
    }
  }
  if (cap->nchar != 0) {
    {
    tmp___0 = valid_yank_reg(cap->nchar, 0);
    }
    if (tmp___0) {
      (cap->oap)->regname = cap->nchar;
      *opnump = cap->count0;
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
  } else {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static void nv_visual(CMDARG *cap , int selectmode ) 
{ 


  {
  VIsual_select = selectmode;
  if (VIsual_active) {
    if (VIsual_mode == cap->cmdchar) {
      {
      end_visual_mode();
      }
    } else {
      {
      VIsual_mode = cap->cmdchar;
      showmode();
      }
    }
    {
    update_curbuf(40);
    }
  } else {
    {
    check_visual_highlight();
    }
    if (cap->count0) {
      if (resel_VIsual_mode == 0) {
        {
        beep_flush();
        }
        return;
      }
      VIsual = curwin->w_cursor;
      VIsual_active = 1;
      VIsual_reselect = 1;
      if (! selectmode) {
        {
        may_start_select('c');
        }
      }
      {
      setmouse();
      }
      if (p_smd) {
        redraw_cmdline = 1;
      }
      if (resel_VIsual_mode != 118) {
        goto _L;
      } else { //Added block
      if (resel_VIsual_line_count > 1L) {
        _L: 
        curwin->w_cursor.lnum += resel_VIsual_line_count * cap->count0 - 1L;
        if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
        }
      }
      }
      VIsual_mode = resel_VIsual_mode;
      if (VIsual_mode == 118) {
        if (resel_VIsual_line_count <= 1L) {
          curwin->w_cursor.col = (colnr_t )((long )curwin->w_cursor.col + ((long )resel_VIsual_col * cap->count0 - 1L));
        } else {
          curwin->w_cursor.col = resel_VIsual_col;
        }
      }
      if (resel_VIsual_col == 2147483647U) {
        {
        curwin->w_curswant = (colnr_t )2147483647;
        coladvance((colnr_t )2147483647);
        }
      } else { //Added block
      if (VIsual_mode == 22) {
        {
        validate_virtcol();
        curwin->w_curswant = (colnr_t )(((long )curwin->w_virtcol + (long )resel_VIsual_col * cap->count0) - 1L);
        coladvance(curwin->w_curswant);
        }
      } else {
        curwin->w_set_curswant = 1;
      }
      }
      {
      update_curbuf(40);
      }
    } else {
      if (! selectmode) {
        {
        may_start_select('c');
        }
      }
      {
      n_start_visual_mode(cap->cmdchar);
      }
    }
  }
  return;
}
}
void start_selection(void) 
{ 


  {
  {
  may_start_select('k');
  n_start_visual_mode('v');
  }
  return;
}
}
void may_start_select(int c ) 
{ 
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = stuff_empty();
  }
  if (tmp) {
    {
    tmp___0 = typebuf_typed();
    }
    if (tmp___0) {
      {
      tmp___1 = vim_strchr(p_slm, c);
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  VIsual_select = tmp___2;
  return;
}
}
static void n_start_visual_mode(int c ) 
{ 


  {
  {
  VIsual = curwin->w_cursor;
  VIsual_mode = c;
  VIsual_active = 1;
  VIsual_reselect = 1;
  setmouse();
  }
  if (p_smd) {
    redraw_cmdline = 1;
  }
  {
  clipboard.vmode = '\000';
  update_screenline();
  }
  return;
}
}
static int nv_g_cmd(CMDARG *cap , char_u **searchp ) 
{ 
  OPARG *oap ;
  FPOS tpos ;
  int i___0 ;
  int flag ;
  int command_busy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
  oap = cap->oap;
  flag = 0;
  command_busy = 0;
  {
  if (cap->nchar == 82) {
    goto case_82;
  }
  if (cap->nchar == 114) {
    goto case_114;
  }
  if (cap->nchar == 118) {
    goto case_118;
  }
  if (cap->nchar == 86) {
    goto case_86;
  }
  if (cap->nchar == 107 + (98 << 8)) {
    goto case_exp;
  }
  if (cap->nchar == 104) {
    goto case_104;
  }
  if (cap->nchar == 72) {
    goto case_104;
  }
  if (cap->nchar == 8) {
    goto case_104;
  }
  if (cap->nchar == 106) {
    goto case_106;
  }
  if (cap->nchar == 107 + (100 << 8)) {
    goto case_106;
  }
  if (cap->nchar == 107) {
    goto case_107;
  }
  if (cap->nchar == 107 + (117 << 8)) {
    goto case_107;
  }
  if (cap->nchar == 74) {
    goto case_74;
  }
  if (cap->nchar == 94) {
    goto case_94;
  }
  if (cap->nchar == 48) {
    goto case_48;
  }
  if (cap->nchar == 109) {
    goto case_48;
  }
  if (cap->nchar == 107 + (104 << 8)) {
    goto case_48;
  }
  if (cap->nchar == 75 + (49 << 8)) {
    goto case_48;
  }
  if (cap->nchar == 253 + (60 << 8)) {
    goto case_48;
  }
  if (cap->nchar == 36) {
    goto case_36;
  }
  if (cap->nchar == 64 + (55 << 8)) {
    goto case_36;
  }
  if (cap->nchar == 75 + (52 << 8)) {
    goto case_36;
  }
  if (cap->nchar == 253 + (59 << 8)) {
    goto case_36;
  }
  if (cap->nchar == 42) {
    goto case_42;
  }
  if (cap->nchar == 35) {
    goto case_42;
  }
  if (cap->nchar == 101) {
    goto case_101;
  }
  if (cap->nchar == 69) {
    goto case_101;
  }
  if (cap->nchar == 7) {
    goto case_7;
  }
  if (cap->nchar == 73) {
    goto case_73;
  }
  if (cap->nchar == 102) {
    goto case_102;
  }
  if (cap->nchar == 115) {
    goto case_115;
  }
  if (cap->nchar == 97) {
    goto case_97;
  }
  if (cap->nchar == 103) {
    goto case_103;
  }
  if (cap->nchar == 113) {
    goto case_113;
  }
  if (cap->nchar == 126) {
    goto case_113;
  }
  if (cap->nchar == 117) {
    goto case_113;
  }
  if (cap->nchar == 85) {
    goto case_113;
  }
  if (cap->nchar == 63) {
    goto case_113;
  }
  if (cap->nchar == 100) {
    goto case_100;
  }
  if (cap->nchar == 68) {
    goto case_100;
  }
  if (cap->nchar == 253 + (45 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (46 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (47 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (42 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (43 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (44 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (48 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (49 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (50 << 8)) {
    goto case_exp___8;
  }
  if (cap->nchar == 253 + (51 << 8)) {
    goto case_exp___17;
  }
  if (cap->nchar == 29) {
    goto case_29;
  }
  if (cap->nchar == 93) {
    goto case_29;
  }
  if (cap->nchar == 112) {
    goto case_112;
  }
  if (cap->nchar == 80) {
    goto case_112;
  }
  if (cap->nchar == 111) {
    goto case_111;
  }
  goto switch_default;
  case_82: /* CIL Label */ 
  {
  command_busy = nv_VReplace(cap);
  }
  goto switch_break;
  case_114: /* CIL Label */ 
  {
  command_busy = nv_vreplace(cap);
  }
  goto switch_break;
  case_118: /* CIL Label */ 
  {
  tmp = checkclearop(oap);
  }
  if (tmp) {
    goto switch_break;
  }
  if (curbuf->b_visual_start.lnum == 0L) {
    {
    beep_flush();
    }
  } else { //Added block
  if (curbuf->b_visual_start.lnum > curbuf->b_ml.ml_line_count) {
    {
    beep_flush();
    }
  } else { //Added block
  if (curbuf->b_visual_end.lnum == 0L) {
    {
    beep_flush();
    }
  } else {
    if (VIsual_active) {
      i___0 = VIsual_mode;
      VIsual_mode = curbuf->b_visual_mode;
      curbuf->b_visual_mode = i___0;
      tpos = curbuf->b_visual_end;
      curbuf->b_visual_end = curwin->w_cursor;
      curwin->w_cursor = curbuf->b_visual_start;
      curbuf->b_visual_start = VIsual;
    } else {
      VIsual_mode = curbuf->b_visual_mode;
      tpos = curbuf->b_visual_end;
      curwin->w_cursor = curbuf->b_visual_start;
    }
    {
    VIsual_active = 1;
    VIsual_reselect = 1;
    adjust_cursor();
    VIsual = curwin->w_cursor;
    curwin->w_cursor = tpos;
    adjust_cursor();
    update_topline();
    }
    if ((unsigned long )searchp == (unsigned long )((void *)0)) {
      VIsual_select = 1;
    } else {
      {
      may_start_select('c');
      }
    }
    {
    setmouse();
    clipboard.vmode = '\000';
    update_curbuf(40);
    showmode();
    }
  }
  }
  }
  goto switch_break;
  case_86: /* CIL Label */ 
  VIsual_reselect = 0;
  goto switch_break;
  case_exp: /* CIL Label */ 
  cap->nchar = 8;
  case_104: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
  tmp___0 = checkclearop(oap);
  }
  if (! tmp___0) {
    {
    cap->cmdchar = cap->nchar + 14;
    nv_visual(cap, 1);
    }
  }
  goto switch_break;
  case_106: /* CIL Label */ 
  case_exp___0: /* CIL Label */ 
  if (! curwin->w_p_wrap) {
    {
    oap->motion_type = 1;
    i___0 = cursor_down(cap->count1, oap->op_type == 0);
    }
  } else {
    {
    i___0 = nv_screengo(oap, 1, cap->count1);
    }
  }
  if (i___0 == 0) {
    {
    clearopbeep(oap);
    }
  }
  goto switch_break;
  case_107: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
  if (! curwin->w_p_wrap) {
    {
    oap->motion_type = 1;
    i___0 = cursor_up(cap->count1, oap->op_type == 0);
    }
  } else {
    {
    i___0 = nv_screengo(oap, -1, cap->count1);
    }
  }
  if (i___0 == 0) {
    {
    clearopbeep(oap);
    }
  }
  goto switch_break;
  case_74: /* CIL Label */ 
  {
  nv_join(cap);
  }
  goto switch_break;
  case_94: /* CIL Label */ 
  flag = 1;
  case_48: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_exp___2: /* CIL Label */ 
  case_exp___3: /* CIL Label */ 
  case_exp___4: /* CIL Label */ 
  oap->motion_type = 0;
  oap->inclusive = 0;
  if (curwin->w_p_wrap) {
    {
    validate_virtcol();
    }
    if (curwin->w_p_nu) {
      tmp___1 = 8;
    } else {
      tmp___1 = 0;
    }
    i___0 = (int )(((long )(curwin->w_virtcol + (colnr_t )tmp___1) / Columns) * Columns);
    if (curwin->w_p_nu) {
      if (i___0 > 8) {
        i___0 -= 8;
      }
    }
  } else {
    i___0 = (int )curwin->w_leftcol;
  }
  if (cap->nchar == 109) {
    i___0 = (int )((long )i___0 + Columns / 2L);
  }
  {
  coladvance((colnr_t )i___0);
  }
  if (flag) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      i___0 = gchar_cursor();
      }
      if (i___0 == 32) {
        goto _L;
      } else { //Added block
      if (i___0 == 9) {
        _L: 
        {
        tmp___2 = oneright();
        }
        if (! (tmp___2 == 1)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  curwin->w_set_curswant = 1;
  goto switch_break;
  case_36: /* CIL Label */ 
  case_exp___5: /* CIL Label */ 
  case_exp___6: /* CIL Label */ 
  case_exp___7: /* CIL Label */ 
  oap->motion_type = 0;
  oap->inclusive = 1;
  if (curwin->w_p_wrap) {
    curwin->w_curswant = (colnr_t )2147483647;
    if (cap->count1 == 1L) {
      {
      validate_virtcol();
      }
      if (curwin->w_p_nu) {
        tmp___3 = 8;
      } else {
        tmp___3 = 0;
      }
      i___0 = (int )(((long )(curwin->w_virtcol + (colnr_t )tmp___3) / Columns + 1L) * Columns - 1L);
      if (curwin->w_p_nu) {
        if (i___0 > 8) {
          i___0 -= 8;
        }
      }
      {
      coladvance((colnr_t )i___0);
      }
    } else {
      {
      tmp___4 = nv_screengo(oap, 1, cap->count1 - 1L);
      }
      if (tmp___4 == 0) {
        {
        clearopbeep(oap);
        }
      }
    }
  } else {
    i___0 = (int )(((long )curwin->w_leftcol + Columns) - 1L);
    if (curwin->w_p_nu) {
      i___0 -= 8;
    }
    {
    coladvance((colnr_t )i___0);
    curwin->w_set_curswant = 1;
    }
  }
  goto switch_break;
  case_42: /* CIL Label */ 
  case_35: /* CIL Label */ 
  {
  nv_ident(cap, searchp);
  }
  goto switch_break;
  case_101: /* CIL Label */ 
  case_69: /* CIL Label */ 
  {
  oap->motion_type = 0;
  curwin->w_set_curswant = 1;
  oap->inclusive = 1;
  tmp___5 = bckend_word(cap->count1, cap->nchar == 69, 0);
  }
  if (tmp___5 == 0) {
    {
    clearopbeep(oap);
    }
  }
  goto switch_break;
  case_7: /* CIL Label */ 
  {
  cursor_pos_info();
  }
  goto switch_break;
  case_73: /* CIL Label */ 
  {
  beginline(0);
  tmp___7 = checkclearopq(oap);
  }
  if (! tmp___7) {
    {
    tmp___6 = u_save_cursor();
    }
    if (tmp___6 == 1) {
      {
      restart_edit = 0;
      command_busy = edit('g', 0, cap->count1);
      }
    }
  }
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  nv_gotofile(cap);
  }
  goto switch_break;
  case_115: /* CIL Label */ 
  {
  out_flush();
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    tmp___8 = cap->count1;
    (cap->count1) --;
    if (tmp___8) {
      if (! (! got_int)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    ui_delay(1000L, 1);
    ui_breakcheck();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  goto switch_break;
  case_97: /* CIL Label */ 
  {
  do_ascii();
  }
  goto switch_break;
  case_103: /* CIL Label */ 
  {
  nv_goto(cap, (linenr_t )1);
  }
  goto switch_break;
  case_113: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_63: /* CIL Label */ 
  {
  nv_operator(cap);
  }
  goto switch_break;
  case_100: /* CIL Label */ 
  case_68: /* CIL Label */ 
  {
  nv_gd(oap, cap->nchar);
  }
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  case_exp___9: /* CIL Label */ 
  case_exp___10: /* CIL Label */ 
  case_exp___11: /* CIL Label */ 
  case_exp___12: /* CIL Label */ 
  case_exp___13: /* CIL Label */ 
  case_exp___14: /* CIL Label */ 
  case_exp___15: /* CIL Label */ 
  case_exp___16: /* CIL Label */ 
  {
  mod_mask = 4;
  do_mouse(oap, cap->nchar, -1, cap->count1, 0);
  }
  goto switch_break;
  case_exp___17: /* CIL Label */ 
  goto switch_break;
  case_29: /* CIL Label */ 
  case_93: /* CIL Label */ 
  {
  nv_ident(cap, searchp);
  }
  goto switch_break;
  case_112: /* CIL Label */ 
  case_80: /* CIL Label */ 
  {
  nv_put(cap);
  }
  goto switch_break;
  case_111: /* CIL Label */ 
  {
  goto_byte(cap->count0);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  clearopbeep(oap);
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (command_busy);
}
}
static int n_opencmd(CMDARG *cap ) 
{ 
  int command_busy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  command_busy = 0;
  tmp___5 = checkclearopq(cap->oap);
  }
  if (! tmp___5) {
    {
    tmp = has_format_option('o');
    }
    if (tmp) {
      fo_do_comments = 1;
    }
    if (cap->cmdchar == 111) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    if (cap->cmdchar == 79) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    {
    tmp___2 = u_save(curwin->w_cursor.lnum - (linenr_t )tmp___1, curwin->w_cursor.lnum + (linenr_t )tmp___0);
    }
    if (tmp___2 == 1) {
      if (cap->cmdchar == 79) {
        tmp___3 = -1;
      } else {
        tmp___3 = 1;
      }
      {
      tmp___4 = open_line(tmp___3, 1, 0, 0);
      }
      if (tmp___4) {
        {
        restart_edit = 0;
        command_busy = edit(cap->cmdchar, 1, cap->count1);
        }
      }
    }
    fo_do_comments = 0;
  }
  return (command_busy);
}
}
static void nv_Undo(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (VIsual_active) {
    {
    cap->cmdchar = 'g';
    cap->nchar = 'U';
    nv_operator(cap);
    }
  } else { //Added block
  if ((cap->oap)->op_type == 11) {
    {
    cap->cmdchar = 'g';
    cap->nchar = 'U';
    nv_operator(cap);
    }
  } else {
    {
    tmp = checkclearopq(cap->oap);
    }
    if (! tmp) {
      {
      u_undoline();
      curwin->w_set_curswant = 1;
      }
    }
  }
  }
  return;
}
}
static void nv_operator(CMDARG *cap ) 
{ 
  int op_type ;
  int tmp ;

  {
  {
  op_type = get_op_type(cap->cmdchar, cap->nchar);
  }
  if (op_type == (cap->oap)->op_type) {
    {
    nv_lineop(cap);
    }
  } else {
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      (cap->oap)->start = curwin->w_cursor;
      (cap->oap)->op_type = op_type;
    }
  }
  return;
}
}
static void nv_lineop(CMDARG *cap ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 1;
  tmp = cursor_down(cap->count1 - 1L, (cap->oap)->op_type == 0);
  }
  if (tmp == 0) {
    {
    clearopbeep(cap->oap);
    }
  } else { //Added block
  if ((cap->oap)->op_type == 1) {
    {
    beginline(6);
    }
  } else { //Added block
  if ((cap->oap)->op_type == 4) {
    {
    beginline(6);
    }
  } else { //Added block
  if ((cap->oap)->op_type == 5) {
    {
    beginline(6);
    }
  } else { //Added block
  if ((cap->oap)->op_type != 2) {
    {
    beginline(5);
    }
  }
  }
  }
  }
  }
  return;
}
}
static void nv_pipe(CMDARG *cap ) 
{ 


  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  beginline(0);
  }
  if (cap->count0 > 0L) {
    {
    coladvance((colnr_t )(cap->count0 - 1L));
    curwin->w_curswant = (colnr_t )(cap->count0 - 1L);
    }
  } else {
    curwin->w_curswant = (colnr_t )0;
  }
  curwin->w_set_curswant = 0;
  return;
}
}
static void nv_bck_word(CMDARG *cap , int type ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  tmp = bck_word(cap->count1, type, 0);
  }
  if (tmp == 0) {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static void nv_wordcmd(CMDARG *cap , int type ) 
{ 
  int n ;
  int word_end ;
  int flag ;
  char_u *tmp ;
  int tmp___0 ;

  {
  flag = 0;
  word_end = (cap->oap)->inclusive;
  if (! word_end) {
    if ((cap->oap)->op_type == 3) {
      {
      n = gchar_cursor();
      }
      if (n != 0) {
        if (n == 32) {
          goto _L;
        } else { //Added block
        if (n == 9) {
          _L: 
          if (cap->count1 == 1L) {
            {
            tmp = vim_strchr(p_cpo, 'w');
            }
            if ((unsigned long )tmp != (unsigned long )((void *)0)) {
              (cap->oap)->inclusive = 1;
              (cap->oap)->motion_type = 0;
              return;
            }
          }
        } else {
          (cap->oap)->inclusive = 1;
          word_end = 1;
          flag = 1;
        }
        }
      }
    }
  }
  (cap->oap)->motion_type = 0;
  curwin->w_set_curswant = 1;
  if (word_end) {
    {
    n = end_word(cap->count1, type, flag, 0);
    }
  } else {
    {
    n = fwd_word(cap->count1, type, (cap->oap)->op_type != 0);
    }
  }
  if (curwin->w_cursor.col) {
    {
    tmp___0 = gchar_cursor();
    }
    if (tmp___0 == 0) {
      (curwin->w_cursor.col) --;
      (cap->oap)->inclusive = 1;
    }
  }
  if (n == 0) {
    if ((cap->oap)->op_type == 0) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      {
      adjust_for_sel(cap);
      }
    }
  } else {
    {
    adjust_for_sel(cap);
    }
  }
  return;
}
}
static void adjust_for_sel(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (VIsual_active) {
    if ((cap->oap)->inclusive) {
      if ((int )*p_sel == 101) {
        {
        tmp = gchar_cursor();
        }
        if (tmp != 0) {
          (curwin->w_cursor.col) ++;
          (cap->oap)->inclusive = 0;
        }
      }
    }
  }
  return;
}
}
static void unadjust_for_sel(void) 
{ 
  FPOS *pp ;
  int tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;

  {
  if ((int )*p_sel == 101) {
    if (VIsual.lnum == curwin->w_cursor.lnum) {
      if (! (VIsual.col == curwin->w_cursor.col)) {
        goto _L;
      }
    } else {
      _L: 
      if (VIsual.lnum != curwin->w_cursor.lnum) {
        tmp = VIsual.lnum < curwin->w_cursor.lnum;
      } else {
        tmp = VIsual.col < curwin->w_cursor.col;
      }
      if (tmp) {
        pp = & curwin->w_cursor;
      } else {
        pp = & VIsual;
      }
      if (pp->col > 0U) {
        (pp->col) --;
      } else { //Added block
      if (pp->lnum > 1L) {
        {
        (pp->lnum) --;
        tmp___0 = ml_get(pp->lnum);
        tmp___1 = strlen((char const   *)((char *)tmp___0));
        pp->col = (colnr_t )tmp___1;
        }
      }
      }
    }
  }
  return;
}
}
static void nv_goto(CMDARG *cap , linenr_t lnum ) 
{ 


  {
  {
  (cap->oap)->motion_type = 1;
  setpcmark();
  }
  if (cap->count0 != 0L) {
    lnum = cap->count0;
  }
  if (lnum < 1L) {
    lnum = 1L;
  } else { //Added block
  if (lnum > curbuf->b_ml.ml_line_count) {
    lnum = curbuf->b_ml.ml_line_count;
  }
  }
  {
  curwin->w_cursor.lnum = lnum;
  beginline(6);
  }
  return;
}
}
static void nv_select(CMDARG *cap ) 
{ 
  FPOS *pp ;
  int tmp ;
  char_u *tmp___0 ;

  {
  if (VIsual_active) {
    VIsual_select = 1;
  } else { //Added block
  if (VIsual_reselect) {
    {
    cap->nchar = 'v';
    nv_g_cmd(cap, (char_u **)((void *)0));
    }
    if ((int )*p_sel == 101) {
      if (VIsual_mode == 118) {
        if (VIsual.lnum != curwin->w_cursor.lnum) {
          tmp = VIsual.lnum < curwin->w_cursor.lnum;
        } else {
          tmp = VIsual.col < curwin->w_cursor.col;
        }
        if (tmp) {
          pp = & curwin->w_cursor;
        } else {
          pp = & VIsual;
        }
        {
        tmp___0 = ml_get_pos(pp);
        }
        if ((int )*tmp___0 != 0) {
          (pp->col) ++;
        } else { //Added block
        if (pp->lnum < curbuf->b_ml.ml_line_count) {
          (pp->lnum) ++;
          pp->col = (colnr_t )0;
        }
        }
        {
        curwin->w_set_curswant = 1;
        update_curbuf(40);
        }
      }
    }
  }
  }
  return;
}
}
static void nv_normal(CMDARG *cap ) 
{ 
  int tmp ;

  {
  {
  tmp = safe_vgetc();
  }
  if (tmp == 14) {
    {
    clearop(cap->oap);
    }
    if (VIsual_active) {
      {
      end_visual_mode();
      redraw_curbuf_later(40);
      }
    }
  } else {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static void nv_esc(CMDARG *cap , linenr_t opnum___0 ) 
{ 


  {
  if (VIsual_active) {
    {
    end_visual_mode();
    check_cursor_col();
    curwin->w_set_curswant = 1;
    update_curbuf(40);
    }
  } else { //Added block
  if ((cap->oap)->op_type == 0) {
    if (opnum___0 == 0L) {
      if (cap->count0 == 0L) {
        if ((cap->oap)->regname == 0) {
          if (! p_im) {
            {
            vim_beep();
            }
          }
        }
      }
    }
  }
  }
  {
  clearop(cap->oap);
  }
  if (p_im) {
    if (! restart_edit) {
      restart_edit = 'a';
    }
  }
  return;
}
}
static int nv_edit(CMDARG *cap ) 
{ 
  char_u *tmp ;
  size_t tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (cap->cmdchar == 107 + (73 << 8)) {
    cap->cmdchar = 'i';
  } else { //Added block
  if (cap->cmdchar == 253 + (69 << 8)) {
    cap->cmdchar = 'i';
  }
  }
  if (cap->cmdchar == 65) {
    goto _L___2;
  } else { //Added block
  if (cap->cmdchar == 73) {
    _L___2: 
    if (VIsual_active) {
      {
      v_visop(cap);
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (cap->cmdchar == 97) {
    goto _L___0;
  } else { //Added block
  if (cap->cmdchar == 105) {
    _L___0: 
    if ((cap->oap)->op_type != 0) {
      {
      nv_object(cap);
      }
    } else { //Added block
    if (VIsual_active) {
      {
      nv_object(cap);
      }
    } else {
      goto _L;
    }
    }
  } else {
    _L: 
    {
    tmp___3 = checkclearopq(cap->oap);
    }
    if (! tmp___3) {
      {
      tmp___4 = u_save_cursor();
      }
      if (tmp___4 == 1) {
        {
        if (cap->cmdchar == 65) {
          goto case_65;
        }
        if (cap->cmdchar == 73) {
          goto case_73;
        }
        if (cap->cmdchar == 97) {
          goto case_97;
        }
        goto switch_break;
        case_65: /* CIL Label */ 
        {
        curwin->w_set_curswant = 1;
        tmp = ml_get_cursor();
        tmp___0 = strlen((char const   *)((char *)tmp));
        curwin->w_cursor.col = (colnr_t )((size_t )curwin->w_cursor.col + tmp___0);
        }
        goto switch_break;
        case_73: /* CIL Label */ 
        {
        beginline(1);
        }
        goto switch_break;
        case_97: /* CIL Label */ 
        {
        tmp___1 = ml_get_cursor();
        }
        if ((int )*tmp___1 != 0) {
          {
          inc_cursor();
          }
        }
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
        restart_edit = 0;
        tmp___2 = edit(cap->cmdchar, 0, cap->count1);
        }
        return (tmp___2);
      }
    }
  }
  }
  }
  }
  return (0);
}
}
static void nv_object(CMDARG *cap ) 
{ 
  int flag ;
  int include ;
  char_u *mps_save ;

  {
  if (cap->cmdchar == 105) {
    include = 0;
  } else {
    include = 1;
  }
  mps_save = curbuf->b_p_mps;
  curbuf->b_p_mps = (char_u *)"(:),{:},[:],<:>";
  {
  if (cap->nchar == 119) {
    goto case_119;
  }
  if (cap->nchar == 87) {
    goto case_87;
  }
  if (cap->nchar == 98) {
    goto case_98;
  }
  if (cap->nchar == 40) {
    goto case_98;
  }
  if (cap->nchar == 41) {
    goto case_98;
  }
  if (cap->nchar == 66) {
    goto case_66;
  }
  if (cap->nchar == 123) {
    goto case_66;
  }
  if (cap->nchar == 125) {
    goto case_66;
  }
  if (cap->nchar == 91) {
    goto case_91;
  }
  if (cap->nchar == 93) {
    goto case_91;
  }
  if (cap->nchar == 60) {
    goto case_60;
  }
  if (cap->nchar == 62) {
    goto case_60;
  }
  if (cap->nchar == 112) {
    goto case_112;
  }
  if (cap->nchar == 115) {
    goto case_115;
  }
  goto switch_default;
  case_119: /* CIL Label */ 
  {
  flag = current_word(cap->oap, cap->count1, include, 0);
  }
  goto switch_break;
  case_87: /* CIL Label */ 
  {
  flag = current_word(cap->oap, cap->count1, include, 1);
  }
  goto switch_break;
  case_98: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_41: /* CIL Label */ 
  {
  flag = current_block(cap->oap, cap->count1, include, '(', ')');
  }
  goto switch_break;
  case_66: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_125: /* CIL Label */ 
  {
  flag = current_block(cap->oap, cap->count1, include, '{', '}');
  }
  goto switch_break;
  case_91: /* CIL Label */ 
  case_93: /* CIL Label */ 
  {
  flag = current_block(cap->oap, cap->count1, include, '[', ']');
  }
  goto switch_break;
  case_60: /* CIL Label */ 
  case_62: /* CIL Label */ 
  {
  flag = current_block(cap->oap, cap->count1, include, '<', '>');
  }
  goto switch_break;
  case_112: /* CIL Label */ 
  {
  flag = current_par(cap->oap, cap->count1, include, 'p');
  }
  goto switch_break;
  case_115: /* CIL Label */ 
  {
  flag = current_sent(cap->oap, cap->count1, include);
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  flag = 0;
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  curbuf->b_p_mps = mps_save;
  if (flag == 0) {
    {
    clearopbeep(cap->oap);
    }
  }
  {
  adjust_cursor_col();
  curwin->w_set_curswant = 1;
  }
  return;
}
}
static void nv_q(CMDARG *cap ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((cap->oap)->op_type == 9) {
    {
    cap->cmdchar = 'g';
    cap->nchar = 'q';
    nv_operator(cap);
    }
  } else {
    {
    tmp___0 = checkclearop(cap->oap);
    }
    if (! tmp___0) {
      if (! Exec_reg) {
        {
        tmp = do_record(cap->nchar);
        }
        if (tmp == 0) {
          {
          clearopbeep(cap->oap);
          }
        }
      }
    }
  }
  return;
}
}
static void nv_at(CMDARG *cap ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = checkclearop(cap->oap);
  }
  if (tmp) {
    return;
  }
  if (cap->nchar == 61) {
    {
    tmp___0 = get_expr_register();
    }
    if (tmp___0 == 0) {
      return;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___2 = cap->count1;
    (cap->count1) --;
    if (tmp___2) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    tmp___1 = do_execreg(cap->nchar, 0, 0);
    }
    if (tmp___1 == 0) {
      {
      clearopbeep(cap->oap);
      }
      goto while_break;
    }
    {
    line_breakcheck();
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void nv_halfpage(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (cap->cmdchar == 21) {
    if (curwin->w_cursor.lnum == 1L) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (cap->cmdchar == 4) {
    if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      {
      halfpage(cap->cmdchar == 4, cap->count0);
      }
    }
  }
  }
  return;
}
}
static void nv_join(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (VIsual_active) {
    {
    nv_operator(cap);
    }
  } else {
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      if (cap->count0 <= 1L) {
        cap->count0 = 2L;
      }
      if ((curwin->w_cursor.lnum + cap->count0) - 1L > curbuf->b_ml.ml_line_count) {
        {
        clearopbeep(cap->oap);
        }
      } else {
        {
        prep_redo((cap->oap)->regname, cap->count0, '\000', cap->cmdchar, '\000',
                  cap->nchar);
        do_do_join(cap->count0, cap->nchar == 0, 1);
        }
      }
    }
  }
  return;
}
}
static void nv_put(CMDARG *cap ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((cap->oap)->op_type != 0) {
    {
    clearopbeep(cap->oap);
    }
  } else { //Added block
  if (VIsual_active) {
    {
    clearopbeep(cap->oap);
    }
  } else {
    {
    prep_redo_cmd(cap);
    }
    if (cap->cmdchar == 103) {
      tmp = 2;
    } else {
      tmp = 0;
    }
    if (cap->cmdchar == 80) {
      tmp___0 = -1;
    } else { //Added block
    if (cap->cmdchar == 103) {
      if (cap->nchar == 80) {
        tmp___0 = -1;
      } else {
        tmp___0 = 1;
      }
    } else {
      tmp___0 = 1;
    }
    }
    {
    do_put((cap->oap)->regname, tmp___0, cap->count1, tmp);
    }
  }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-PCiYej8m.i","-O0")
int get_register_name(int num ) ;
void dis_msg(char_u *p___0 , int skip_esc ) ;
void clip_free_selection(void) ;
void clip_get_selection(void) ;
void clip_yank_selection(int type , char_u *str___1 , long len___0 ) ;
int clip_convert_selection(char_u **str___1 , long_u *len___0 ) ;
void update_topline_redraw(void) ;
int may_validate_crow(void) ;
char_u *last_search_pat(void) ;
void set_last_search_pat(char_u *s , int idx , int magic , int setlast ) ;
int startPS(linenr_t lnum , int para , int both ) ;
void clip_own_selection(void) ;
void clip_gen_set_selection(void) ;
void clip_gen_request_selection(void) ;
static struct yankreg y_regs[38]  ;
static struct yankreg *y_current  ;
static int y_append  ;
static struct yankreg *y_previous  =    (struct yankreg *)((void *)0);
static void shift_block(OPARG *oap , int amount ) ;
static void block_insert(OPARG *oap , char_u *s , int b_insert , struct block_def *bdp ) ;
static char_u *get_expr_line(void) ;
static void get_yank_register(int regname___0 , int writing ) ;
static int stuff_yank(int regname___0 , char_u *p___0 ) ;
static int put_in_typebuf(char_u *s , int colon ) ;
static void stuffescaped(char_u *arg ) ;
static int get_spec_reg(int regname___0 , char_u **argp , int *allocated , int errmsg ) ;
static void cmdline_paste_str(char_u *s , int literally ) ;
static void free_yank(long n ) ;
static void free_yank_all(void) ;
static void block_prep(OPARG *oap , struct block_def *bdp , linenr_t lnum , int is_del ) ;
static void str_to_reg(struct yankreg *y_ptr , int type , char_u *str___1 , long len___0 ) ;
static int same_leader(int leader1_len , char_u *leader1_flags , int leader2_len ,
                       char_u *leader2_flags ) ;
static int fmt_check_par(linenr_t lnum , int *leader_len , char_u **leader_flags ) ;
static char opchars[19][3]  = 
  { {        (char )'\000',        (char )'\000',        (char)0}, 
   {        (char )'d',        (char )'\000',        (char)0}, 
   {        (char )'y',        (char )'\000',        (char)0}, 
   {        (char )'c',        (char )'\000',        (char)0}, 
   {        (char )'<',        (char )'\000',        (char)1}, 
   {        (char )'>',        (char )'\000',        (char)1}, 
   {        (char )'!',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'~',        (char)0}, 
   {        (char )'=',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'q',        (char)1}, 
   {        (char )':',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'U',        (char)0}, 
   {        (char )'g',        (char )'u',        (char)0}, 
   {        (char )'J',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'J',        (char)1}, 
   {        (char )'g',        (char )'?',        (char)0}, 
   {        (char )'r',        (char )'\000',        (char)0}, 
   {        (char )'I',        (char )'\000',        (char)0}, 
   {        (char )'A',        (char )'\000',        (char)0}};
int get_op_type(int char1 , int char2 ) 
{ 
  int i___0 ;

  {
  if (char1 == 114) {
    return (16);
  }
  if (char1 == 126) {
    return (7);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )opchars[i___0][0] == char1) {
      if ((int )opchars[i___0][1] == char2) {
        goto while_break;
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (i___0);
}
}
int op_on_lines(int op ) 
{ 


  {
  return ((int )opchars[op][2]);
}
}
int get_op_char(int optype ) 
{ 


  {
  return ((int )opchars[optype][0]);
}
}
int get_extra_op_char(int optype ) 
{ 


  {
  return ((int )opchars[optype][1]);
}
}
void op_shift(OPARG *oap , int curs_top , int amount ) 
{ 
  long i___0 ;
  int first_char ;
  int block_col ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
  block_col = 0;
  tmp = u_save(curwin->w_cursor.lnum - 1L, curwin->w_cursor.lnum + oap->line_count);
  }
  if (tmp == 0) {
    return;
  }
  {
  syn_changed(curwin->w_cursor.lnum);
  }
  if (oap->block_mode) {
    block_col = (int )curwin->w_cursor.col;
  }
  i___0 = oap->line_count;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0L)) {
      goto while_break;
    }
    {
    tmp___0 = ml_get_curline();
    first_char = (int )*tmp___0;
    }
    if (first_char == 0) {
      curwin->w_cursor.col = (colnr_t )0;
    } else { //Added block
    if (oap->block_mode) {
      {
      shift_block(oap, amount);
      }
    } else { //Added block
    if (first_char != 35) {
      {
      shift_line(oap->op_type == 4, p_sr, amount);
      }
    } else { //Added block
    if (! curbuf->b_p_si) {
      goto _L;
    } else { //Added block
    if (curbuf->b_p_cin) {
      _L: 
      if (! curbuf->b_p_cin) {
        {
        shift_line(oap->op_type == 4, p_sr, amount);
        }
      } else {
        {
        tmp___1 = in_cinkeys('#', ' ', 1);
        }
        if (! tmp___1) {
          {
          shift_line(oap->op_type == 4, p_sr, amount);
          }
        }
      }
    }
    }
    }
    }
    }
    (curwin->w_cursor.lnum) ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (oap->block_mode) {
    curwin->w_cursor.lnum -= oap->line_count;
    curwin->w_cursor.col = (colnr_t )block_col;
  } else { //Added block
  if (curs_top) {
    {
    curwin->w_cursor.lnum -= oap->line_count;
    beginline(6);
    }
  } else {
    (curwin->w_cursor.lnum) --;
  }
  }
  {
  update_topline();
  update_screen(40);
  }
  if (oap->line_count > p_report) {
    {
    tmp___2 = plural((long )amount);
    }
    if (oap->op_type == 5) {
      tmp___3 = '>';
    } else {
      tmp___3 = '<';
    }
    {
    tmp___4 = plural(oap->line_count);
    smsg((char_u *)"%ld line%s %ced %d time%s", oap->line_count, tmp___4, tmp___3,
         amount, tmp___2);
    }
  }
  curbuf->b_op_start = oap->start;
  curbuf->b_op_end = oap->end;
  return;
}
}
void shift_line(int left , int round , int amount ) 
{ 
  int count___2 ;
  int i___0 ;
  int j ;
  int p_sw ;

  {
  {
  p_sw = (int )curbuf->b_p_sw;
  count___2 = get_indent();
  }
  if (round) {
    i___0 = count___2 / p_sw;
    j = count___2 % p_sw;
    if (j) {
      if (left) {
        amount --;
      }
    }
    if (left) {
      i___0 -= amount;
      if (i___0 < 0) {
        i___0 = 0;
      }
    } else {
      i___0 += amount;
    }
    count___2 = i___0 * p_sw;
  } else { //Added block
  if (left) {
    count___2 -= p_sw * amount;
    if (count___2 < 0) {
      count___2 = 0;
    }
  } else {
    count___2 += p_sw * amount;
  }
  }
  if (State == 784) {
    {
    change_indent(1, count___2, 0, '\000');
    }
  } else {
    {
    set_indent(count___2, 1);
    }
  }
  return;
}
}
static void shift_block(OPARG *oap , int amount ) 
{ 
  int left ;
  int oldstate ;
  int total ;
  int split ;
  char_u *newp ;
  char_u *oldp ;
  char_u *midp ;
  char_u *ptr ;
  int oldcol ;
  int p_sw ;
  int p_ts ;
  struct block_def bd ;
  int internal ;
  int incr ;
  colnr_t vcol ;
  colnr_t col ;
  colnr_t ws_vcol ;
  int i___0 ;
  int j ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
  left = oap->op_type == 4;
  oldstate = State;
  oldcol = (int )curwin->w_cursor.col;
  p_sw = (int )curbuf->b_p_sw;
  p_ts = (int )curbuf->b_p_ts;
  internal = 0;
  col = (colnr_t )0;
  i___0 = 0;
  j = 0;
  State = 16;
  block_prep(oap, & bd, curwin->w_cursor.lnum, 1);
  }
  if (bd.is_short) {
    return;
  }
  {
  total = amount * p_sw;
  oldp = ml_get_curline();
  }
  if (! left) {
    total += bd.pre_whitesp;
    ws_vcol = bd.start_vcol - (colnr_t )bd.pre_whitesp;
    if (bd.startspaces) {
      (bd.textstart) ++;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((int )*(bd.textstart) == 32)) {
        if (! ((int )*(bd.textstart) == 9)) {
          goto while_break;
        }
      }
      {
      incr = lbr_chartabsize(bd.textstart, bd.start_vcol);
      total += incr;
      bd.start_vcol += (colnr_t )incr;
      (bd.textstart) ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (! curbuf->b_p_et) {
      i___0 = (int )((ws_vcol % (unsigned int )p_ts + (unsigned int )total) / (unsigned int )p_ts);
    }
    if (i___0) {
      j = (int )((ws_vcol % (unsigned int )p_ts + (unsigned int )total) % (unsigned int )p_ts);
    } else {
      j = total;
    }
    {
    bd.textcol -= (colnr_t )(bd.pre_whitesp_c - (bd.startspaces != 0));
    tmp = strlen((char const   *)((char *)bd.textstart));
    newp = alloc_check((((bd.textcol + (colnr_t )i___0) + (colnr_t )j) + (unsigned int )tmp) + 1U);
    }
    if ((unsigned long )newp == (unsigned long )((void *)0)) {
      return;
    }
    {
    tmp___0 = strlen((char const   *)((char *)bd.textstart));
    memset((void *)newp, '\000', ((size_t )((bd.textcol + (colnr_t )i___0) + (colnr_t )j) + tmp___0) + 1UL);
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )bd.textcol);
    copy_chars(newp + bd.textcol, (size_t )i___0, '\t');
    copy_spaces((newp + bd.textcol) + i___0, (size_t )j);
    tmp___1 = strlen((char const   *)((char *)bd.textstart));
    memmove((void *)((char *)(((newp + bd.textcol) + i___0) + j)), (void const   *)((char *)bd.textstart),
            tmp___1 + 1UL);
    }
  } else {
    vcol = oap->start_vcol;
    midp = oldp + bd.textcol;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (vcol < oap->start_vcol + (colnr_t )total) {
        if (! ((int )*midp == 32)) {
          if (! ((int )*midp == 9)) {
            goto while_break___0;
          }
        }
      } else {
        goto while_break___0;
      }
      {
      incr = lbr_chartabsize(midp, vcol);
      vcol += (colnr_t )incr;
      midp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (vcol > oap->start_vcol + (colnr_t )total) {
      internal = (int )(vcol - (oap->start_vcol + (colnr_t )total));
    }
    split = bd.startspaces + internal;
    if (split > 0) {
      if (! curbuf->b_p_et) {
        ptr = oldp;
        col = (colnr_t )0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((unsigned long )ptr < (unsigned long )(oldp + bd.textcol))) {
            goto while_break___1;
          }
          {
          tmp___2 = lbr_chartabsize(ptr, col);
          col += (colnr_t )tmp___2;
          ptr ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        i___0 = (int )((col % (unsigned int )p_ts + (unsigned int )split) / (unsigned int )p_ts);
      }
      if (i___0) {
        j = (int )((col % (unsigned int )p_ts + (unsigned int )split) % (unsigned int )p_ts);
      } else {
        j = split;
      }
    }
    {
    tmp___3 = strlen((char const   *)((char *)midp));
    newp = alloc_check((((bd.textcol + (colnr_t )i___0) + (colnr_t )j) + (unsigned int )tmp___3) + 1U);
    }
    if ((unsigned long )newp == (unsigned long )((void *)0)) {
      return;
    }
    {
    tmp___4 = strlen((char const   *)((char *)midp));
    memset((void *)newp, '\000', ((size_t )((bd.textcol + (colnr_t )i___0) + (colnr_t )j) + tmp___4) + 1UL);
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )bd.textcol);
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! ((int )*midp == 32)) {
        if (! ((int )*midp == 9)) {
          goto while_break___2;
        }
      }
      if ((int )*midp == 9) {
        i___0 ++;
      } else {
        j ++;
      }
      midp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    if (j / p_ts) {
      if (! curbuf->b_p_et) {
        i___0 ++;
        j -= p_ts;
      }
    }
    {
    copy_chars(newp + bd.textcol, (size_t )i___0, '\t');
    copy_spaces((newp + bd.textcol) + i___0, (size_t )j);
    tmp___5 = strlen((char const   *)((char *)midp));
    tmp___6 = strlen((char const   *)((char *)newp));
    memmove((void *)((char *)(newp + tmp___6)), (void const   *)((char *)midp), tmp___5 + 1UL);
    }
  }
  {
  ml_replace(curwin->w_cursor.lnum, newp, 0);
  changed();
  State = oldstate;
  curwin->w_cursor.col = (colnr_t )oldcol;
  }
  return;
}
}
static void block_insert(OPARG *oap , char_u *s , int b_insert , struct block_def *bdp ) 
{ 
  int p_ts ;
  int count___2 ;
  int spaces ;
  colnr_t offset ;
  unsigned int s_len ;
  char_u *newp ;
  char_u *oldp ;
  linenr_t lnum ;
  int oldstate ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
  count___2 = 0;
  spaces = 0;
  oldstate = State;
  State = 16;
  tmp = strlen((char const   *)((char *)s));
  s_len = (unsigned int )tmp;
  lnum = oap->start.lnum + 1L;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lnum <= oap->end.lnum)) {
      goto while_break;
    }
    {
    block_prep(oap, bdp, lnum, 1);
    }
    if (bdp->is_short) {
      if (b_insert) {
        goto __Cont;
      }
    }
    {
    oldp = ml_get(lnum);
    }
    if (b_insert) {
      p_ts = (int )bdp->start_char_vcols;
      spaces = bdp->startspaces;
      if (spaces != 0) {
        count___2 = p_ts - 1;
      }
      offset = bdp->textcol;
    } else {
      p_ts = (int )bdp->end_char_vcols;
      if (! bdp->is_short) {
        if (bdp->endspaces) {
          spaces = p_ts - bdp->endspaces;
        } else {
          spaces = 0;
        }
        if (spaces != 0) {
          count___2 = p_ts - 1;
        }
        offset = (bdp->textcol + (colnr_t )bdp->textlen) - (colnr_t )(spaces != 0);
      } else {
        if (! bdp->is_MAX) {
          spaces = bdp->endspaces + ! bdp->is_EOL;
        }
        count___2 = spaces;
        offset = bdp->textcol + (colnr_t )bdp->textlen;
      }
    }
    {
    tmp___0 = strlen((char const   *)((char *)oldp));
    newp = alloc_check((((unsigned int )tmp___0 + s_len) + (unsigned int )count___2) + 1U);
    }
    if ((unsigned long )newp == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    {
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )offset);
    copy_spaces(newp + offset, (size_t )spaces);
    memmove((void *)((char *)((newp + offset) + spaces)), (void const   *)((char *)s),
            (size_t )s_len);
    oldp += offset;
    }
    if (spaces) {
      if (! bdp->is_short) {
        {
        copy_spaces(((newp + offset) + spaces) + s_len, (size_t )(p_ts - spaces));
        oldp ++;
        count___2 ++;
        }
      }
    }
    {
    tmp___1 = strlen((char const   *)((char *)oldp));
    }
    if (spaces) {
      tmp___2 = count___2;
    } else {
      tmp___2 = 0;
    }
    {
    memmove((void *)((char *)(((newp + offset) + s_len) + tmp___2)), (void const   *)((char *)oldp),
            tmp___1 + 1UL);
    ml_replace(lnum, newp, 0);
    }
    __Cont: 
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  State = oldstate;
  return;
}
}
void op_reindent(OPARG *oap , int (*how)(void) ) 
{ 
  long i___0 ;
  char_u *l ;
  int count___2 ;
  int tmp ;
  char *tmp___0 ;
  char_u *tmp___1 ;
  char *tmp___2 ;

  {
  {
  tmp = u_save(curwin->w_cursor.lnum - 1L, curwin->w_cursor.lnum + oap->line_count);
  }
  if (tmp == 0) {
    return;
  }
  {
  syn_changed(curwin->w_cursor.lnum);
  i___0 = oap->line_count;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (i___0 >= 0L) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (i___0 % 50L == 0L) {
      goto _L;
    } else { //Added block
    if (i___0 == oap->line_count - 1L) {
      _L: 
      if (oap->line_count > p_report) {
        {
        tmp___0 = plural(i___0);
        smsg((char_u *)"%ld line%s to indent... ", i___0, tmp___0);
        }
      }
    }
    }
    if (i___0 != oap->line_count - 1L) {
      goto _L___0;
    } else { //Added block
    if (oap->line_count == 1L) {
      goto _L___0;
    } else { //Added block
    if ((unsigned long )how != (unsigned long )(& get_lisp_indent)) {
      _L___0: 
      {
      tmp___1 = ml_get_curline();
      l = skipwhite(tmp___1);
      }
      if ((int )*l == 0) {
        count___2 = 0;
      } else {
        {
        count___2 = (*how)();
        }
      }
      {
      set_indent(count___2, 1);
      }
    }
    }
    }
    (curwin->w_cursor.lnum) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  curwin->w_cursor.lnum -= oap->line_count;
  beginline(6);
  update_topline();
  update_screen(40);
  }
  if (oap->line_count > p_report) {
    {
    i___0 = oap->line_count - (i___0 + 1L);
    tmp___2 = plural(i___0);
    smsg((char_u *)"%ld line%s indented ", i___0, tmp___2);
    }
  }
  curbuf->b_op_start = oap->start;
  curbuf->b_op_end = oap->end;
  return;
}
}
static char_u *expr_line  =    (char_u *)((void *)0);
int get_expr_register(void) 
{ 
  char_u *new_line ;

  {
  {
  new_line = getcmdline('=', 0L, 0);
  }
  if ((unsigned long )new_line == (unsigned long )((void *)0)) {
    return ('\000');
  }
  if ((int )*new_line == 0) {
    {
    vim_free((void *)new_line);
    }
  } else {
    {
    set_expr_line(new_line);
    }
  }
  return ('=');
}
}
void set_expr_line(char_u *new_line ) 
{ 


  {
  {
  vim_free((void *)expr_line);
  expr_line = new_line;
  }
  return;
}
}
static char_u *get_expr_line(void) 
{ 
  char_u *tmp ;

  {
  if ((unsigned long )expr_line == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  tmp = eval_to_string(expr_line, (char_u **)((void *)0));
  }
  return (tmp);
}
}
int valid_yank_reg(int regname___0 , int writing ) 
{ 
  unsigned short const   **tmp ;
  char_u *tmp___0 ;

  {
  if (regname___0 > 126) {
    return (0);
  }
  {
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + regname___0) & 8) {
    return (1);
  } else { //Added block
  if (! writing) {
    {
    tmp___0 = vim_strchr((char_u *)"/.%#:=", regname___0);
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      return (1);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (regname___0 == 34) {
    return (1);
  } else { //Added block
  if (regname___0 == 45) {
    return (1);
  } else { //Added block
  if (regname___0 == 95) {
    return (1);
  } else { //Added block
  if (regname___0 == 42) {
    return (1);
  }
  }
  }
  }
  }
  }
  return (0);
}
}
static void get_yank_register(int regname___0 , int writing ) 
{ 
  int i___0 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  y_append = 0;
  if (regname___0 == 0) {
    if (! writing) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (regname___0 == 34) {
    _L: 
    if ((unsigned long )y_previous != (unsigned long )((void *)0)) {
      y_current = y_previous;
      return;
    }
  }
  }
  {
  i___0 = regname___0;
  tmp___1 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___1 + i___0) & 2048) {
    i___0 -= 48;
  } else {
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + i___0) & 512) {
      i___0 -= 87;
    } else {
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + i___0) & 256) {
        i___0 -= 55;
        y_append = 1;
      } else { //Added block
      if (regname___0 == 45) {
        i___0 = 36;
      } else { //Added block
      if (clipboard.available) {
        if (regname___0 == 42) {
          i___0 = 37;
        } else {
          i___0 = 0;
        }
      } else {
        i___0 = 0;
      }
      }
      }
    }
  }
  y_current = & y_regs[i___0];
  if (writing) {
    y_previous = y_current;
  }
  return;
}
}
int yank_register_mline(int regname___0 ) 
{ 
  int tmp ;

  {
  if (regname___0 != 0) {
    {
    tmp = valid_yank_reg(regname___0, 0);
    }
    if (! tmp) {
      return (0);
    }
  }
  if (regname___0 == 95) {
    return (0);
  }
  {
  get_yank_register(regname___0, 0);
  }
  return ((int )y_current->y_type == 1);
}
}
static int regname  ;
int do_record(int c ) 
{ 
  char_u *p___0 ;
  struct yankreg *old_y_previous ;
  struct yankreg *old_y_current ;
  int retval ;
  unsigned short const   **tmp ;

  {
  if (Recording == 0) {
    if (c > 126) {
      retval = 0;
    } else {
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + c) & 8) {
        {
        Recording = 1;
        showmode();
        regname = c;
        retval = 1;
        }
      } else { //Added block
      if (c != 34) {
        retval = 0;
      } else {
        {
        Recording = 1;
        showmode();
        regname = c;
        retval = 1;
        }
      }
      }
    }
  } else {
    {
    Recording = 0;
    msg((char_u *)"");
    p___0 = get_recorded();
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      retval = 0;
    } else {
      {
      old_y_previous = y_previous;
      old_y_current = y_current;
      retval = stuff_yank(regname, p___0);
      y_previous = old_y_previous;
      y_current = old_y_current;
      }
    }
  }
  return (retval);
}
}
static int stuff_yank(int regname___0 , char_u *p___0 ) 
{ 
  char_u *lp ;
  char_u **pp ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char_u **tmp___2 ;
  char_u *tmp___3 ;

  {
  if (regname___0 != 0) {
    {
    tmp = valid_yank_reg(regname___0, 1);
    }
    if (! tmp) {
      {
      vim_free((void *)p___0);
      }
      return (0);
    }
  }
  if (regname___0 == 95) {
    {
    vim_free((void *)p___0);
    }
    return (1);
  }
  {
  get_yank_register(regname___0, 1);
  }
  if (y_append) {
    if ((unsigned long )y_current->y_array != (unsigned long )((void *)0)) {
      {
      pp = y_current->y_array + (y_current->y_size - 1L);
      tmp___0 = strlen((char const   *)((char *)*pp));
      tmp___1 = strlen((char const   *)((char *)p___0));
      lp = lalloc((tmp___0 + tmp___1) + 1UL, 1);
      }
      if ((unsigned long )lp == (unsigned long )((void *)0)) {
        {
        vim_free((void *)p___0);
        }
        return (0);
      }
      {
      strcpy((char * __restrict  )((char *)lp), (char const   * __restrict  )((char *)*pp));
      strcat((char * __restrict  )((char *)lp), (char const   * __restrict  )((char *)p___0));
      vim_free((void *)p___0);
      vim_free((void *)*pp);
      *pp = lp;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    free_yank_all();
    tmp___3 = alloc((unsigned int )sizeof(char_u *));
    tmp___2 = (char_u **)tmp___3;
    y_current->y_array = tmp___2;
    }
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
      vim_free((void *)p___0);
      }
      return (0);
    }
    *(y_current->y_array + 0) = p___0;
    y_current->y_size = (linenr_t )1;
    y_current->y_type = (char_u )0;
  }
  return (1);
}
}
static int lastc  =    '\000';
int do_execreg(int regname___0 , int colon , int addcr ) 
{ 
  long i___0 ;
  char_u *p___0 ;
  int retval ;
  int remap ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  retval = 1;
  if (regname___0 == 64) {
    regname___0 = lastc;
  }
  if (regname___0 == 37) {
    return (0);
  } else { //Added block
  if (regname___0 == 35) {
    return (0);
  } else {
    {
    tmp = valid_yank_reg(regname___0, 0);
    }
    if (! tmp) {
      return (0);
    }
  }
  }
  lastc = regname___0;
  if (regname___0 == 95) {
    return (1);
  }
  if (regname___0 == 58) {
    if ((unsigned long )last_cmdline == (unsigned long )((void *)0)) {
      {
      emsg(e_nolastcmd);
      }
      return (0);
    }
    {
    vim_free((void *)new_last_cmdline);
    new_last_cmdline = (char_u *)((void *)0);
    retval = put_in_typebuf(last_cmdline, 1);
    }
  } else { //Added block
  if (regname___0 == 61) {
    {
    p___0 = get_expr_line();
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      return (0);
    }
    {
    retval = put_in_typebuf(p___0, colon);
    vim_free((void *)p___0);
    }
  } else { //Added block
  if (regname___0 == 46) {
    {
    p___0 = get_last_insert_save();
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      {
      emsg(e_noinstext);
      }
      return (0);
    }
    {
    retval = put_in_typebuf(p___0, colon);
    vim_free((void *)p___0);
    }
  } else {
    {
    get_yank_register(regname___0, 0);
    }
    if ((unsigned long )y_current->y_array == (unsigned long )((void *)0)) {
      return (0);
    }
    if (colon) {
      remap = -1;
    } else {
      remap = 0;
    }
    i___0 = y_current->y_size;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      i___0 --;
      if (! (i___0 >= 0L)) {
        goto while_break;
      }
      if ((int )y_current->y_type == 1) {
        goto _L;
      } else { //Added block
      if (i___0 < y_current->y_size - 1L) {
        goto _L;
      } else { //Added block
      if (addcr) {
        _L: 
        {
        tmp___0 = ins_typebuf((char_u *)"\n", remap, 0, 1);
        }
        if (tmp___0 == 0) {
          return (0);
        }
      }
      }
      }
      {
      tmp___1 = ins_typebuf(*(y_current->y_array + i___0), remap, 0, 1);
      }
      if (tmp___1 == 0) {
        return (0);
      }
      if (colon) {
        {
        tmp___2 = ins_typebuf((char_u *)":", remap, 0, 1);
        }
        if (tmp___2 == 0) {
          return (0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    Exec_reg = 1;
  }
  }
  }
  return (retval);
}
}
static int put_in_typebuf(char_u *s , int colon ) 
{ 
  int retval ;

  {
  retval = 1;
  if (colon) {
    {
    retval = ins_typebuf((char_u *)"\n", 0, 0, 1);
    }
  }
  if (retval == 1) {
    {
    retval = ins_typebuf(s, 0, 0, 1);
    }
  }
  if (colon) {
    if (retval == 1) {
      {
      retval = ins_typebuf((char_u *)":", 0, 0, 1);
      }
    }
  }
  return (retval);
}
}
int insert_reg(int regname___0 , int literally ) 
{ 
  long i___0 ;
  int retval ;
  char_u *arg ;
  int allocated ;
  int tmp ;
  int tmp___0 ;

  {
  {
  retval = 1;
  ui_breakcheck();
  }
  if (got_int) {
    return (0);
  }
  if (regname___0 != 0) {
    {
    tmp = valid_yank_reg(regname___0, 0);
    }
    if (! tmp) {
      return (0);
    }
  }
  if (regname___0 == 42) {
    if (! clipboard.available) {
      regname___0 = 0;
    } else {
      {
      clip_get_selection();
      }
    }
  }
  if (regname___0 == 46) {
    {
    retval = stuff_inserted('\000', 1L, 1);
    }
  } else {
    {
    tmp___0 = get_spec_reg(regname___0, & arg, & allocated, 1);
    }
    if (tmp___0) {
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
        return (0);
      }
      if (literally) {
        {
        stuffescaped(arg);
        }
      } else {
        {
        stuffReadbuff(arg);
        }
      }
      if (allocated) {
        {
        vim_free((void *)arg);
        }
      }
    } else {
      {
      get_yank_register(regname___0, 0);
      }
      if ((unsigned long )y_current->y_array == (unsigned long )((void *)0)) {
        retval = 0;
      } else {
        i___0 = 0L;
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (i___0 < y_current->y_size)) {
            goto while_break;
          }
          if (literally) {
            {
            stuffescaped(*(y_current->y_array + i___0));
            }
          } else {
            {
            stuffReadbuff(*(y_current->y_array + i___0));
            }
          }
          if ((int )y_current->y_type == 1) {
            {
            stuffcharReadbuff('\n');
            }
          } else { //Added block
          if (i___0 < y_current->y_size - 1L) {
            {
            stuffcharReadbuff('\n');
            }
          }
          }
          i___0 ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (retval);
}
}
static void stuffescaped(char_u *arg ) 
{ 
  char_u *tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *arg) {
      goto while_break;
    }
    if ((int )*arg < 32) {
      if ((int )*arg != 9) {
        {
        stuffcharReadbuff(22);
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*arg > 126) {
      {
      stuffcharReadbuff(22);
      }
    }
    }
    {
    tmp = arg;
    arg ++;
    stuffcharReadbuff((int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int get_spec_reg(int regname___0 , char_u **argp , int *allocated , int errmsg ) 
{ 
  int cnt ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  *argp = (char_u *)((void *)0);
  *allocated = 0;
  {
  if (regname___0 == 37) {
    goto case_37;
  }
  if (regname___0 == 35) {
    goto case_35;
  }
  if (regname___0 == 61) {
    goto case_61;
  }
  if (regname___0 == 58) {
    goto case_58;
  }
  if (regname___0 == 47) {
    goto case_47;
  }
  if (regname___0 == 46) {
    goto case_46;
  }
  if (regname___0 == 6) {
    goto case_6;
  }
  if (regname___0 == 16) {
    goto case_6;
  }
  if (regname___0 == 23) {
    goto case_23;
  }
  if (regname___0 == 1) {
    goto case_23;
  }
  if (regname___0 == 95) {
    goto case_95;
  }
  goto switch_break;
  case_37: /* CIL Label */ 
  if (errmsg) {
    {
    check_fname();
    }
  }
  *argp = curbuf->b_fname;
  return (1);
  case_35: /* CIL Label */ 
  {
  *argp = getaltfname(errmsg);
  }
  return (1);
  case_61: /* CIL Label */ 
  {
  *argp = get_expr_line();
  *allocated = 1;
  }
  return (1);
  case_58: /* CIL Label */ 
  if ((unsigned long )last_cmdline == (unsigned long )((void *)0)) {
    if (errmsg) {
      {
      emsg(e_nolastcmd);
      }
    }
  }
  *argp = last_cmdline;
  return (1);
  case_47: /* CIL Label */ 
  {
  tmp = last_search_pat();
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    if (errmsg) {
      {
      emsg(e_noprevre);
      }
    }
  }
  {
  *argp = last_search_pat();
  }
  return (1);
  case_46: /* CIL Label */ 
  {
  *argp = get_last_insert_save();
  *allocated = 1;
  }
  if ((unsigned long )*argp == (unsigned long )((void *)0)) {
    if (errmsg) {
      {
      emsg(e_noinstext);
      }
    }
  }
  return (1);
  case_6: /* CIL Label */ 
  case_16: /* CIL Label */ 
  if (! errmsg) {
    return (0);
  }
  if (regname___0 == 16) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  {
  *argp = file_name_at_cursor(5 | tmp___0, 1L);
  *allocated = 1;
  }
  return (1);
  case_23: /* CIL Label */ 
  case_1: /* CIL Label */ 
  if (! errmsg) {
    return (0);
  }
  if (regname___0 == 23) {
    tmp___1 = 3;
  } else {
    tmp___1 = 2;
  }
  {
  cnt = find_ident_under_cursor(argp, tmp___1);
  }
  if (cnt) {
    {
    tmp___2 = vim_strnsave(*argp, cnt);
    *argp = tmp___2;
    }
  } else {
    *argp = (char_u *)((void *)0);
  }
  *allocated = 1;
  return (1);
  case_95: /* CIL Label */ 
  *argp = (char_u *)"";
  return (1);
  switch_break: /* CIL Label */ ;
  }
  return (0);
}
}
int cmdline_paste(int regname___0 , int literally ) 
{ 
  long i___0 ;
  char_u *arg ;
  int allocated ;
  int tmp ;
  int tmp___0 ;

  {
  if (regname___0 != 6) {
    if (regname___0 != 16) {
      if (regname___0 != 23) {
        if (regname___0 != 1) {
          {
          tmp = valid_yank_reg(regname___0, 0);
          }
          if (! tmp) {
            return (0);
          }
        }
      }
    }
  }
  if (regname___0 == 42) {
    if (! clipboard.available) {
      regname___0 = 0;
    } else {
      {
      clip_get_selection();
      }
    }
  }
  {
  tmp___0 = get_spec_reg(regname___0, & arg, & allocated, 1);
  }
  if (tmp___0) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      return (0);
    }
    {
    cmdline_paste_str(arg, literally);
    }
    if (allocated) {
      {
      vim_free((void *)arg);
      }
    }
    return (1);
  }
  {
  get_yank_register(regname___0, 0);
  }
  if ((unsigned long )y_current->y_array == (unsigned long )((void *)0)) {
    return (0);
  }
  i___0 = 0L;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < y_current->y_size)) {
      goto while_break;
    }
    {
    cmdline_paste_str(*(y_current->y_array + i___0), literally);
    }
    if ((int )y_current->y_type == 1) {
      {
      cmdline_paste_str((char_u *)"\r", literally);
      }
    } else { //Added block
    if (i___0 < y_current->y_size - 1L) {
      {
      cmdline_paste_str((char_u *)"\r", literally);
      }
    }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static void cmdline_paste_str(char_u *s , int literally ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  if (literally) {
    {
    put_on_cmdline(s, -1, 1);
    }
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *s) {
        goto while_break;
      }
      if ((int )*s == 22) {
        if (*(s + 1)) {
          {
          tmp = s;
          s ++;
          stuffcharReadbuff((int )*tmp);
          }
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if ((int )*s == 27) {
        {
        stuffcharReadbuff(22);
        }
      } else { //Added block
      if ((int )*s == 3) {
        {
        stuffcharReadbuff(22);
        }
      } else { //Added block
      if ((int )*s == 13) {
        {
        stuffcharReadbuff(22);
        }
      } else { //Added block
      if ((int )*s == 10) {
        {
        stuffcharReadbuff(22);
        }
      } else { //Added block
      if ((int )*s == intr_char) {
        {
        stuffcharReadbuff(22);
        }
      } else { //Added block
      if ((int )*s == 28) {
        if ((int )*(s + 1) == 14) {
          {
          stuffcharReadbuff(22);
          }
        }
      }
      }
      }
      }
      }
      }
      }
      {
      tmp___0 = s;
      s ++;
      stuffcharReadbuff((int )*tmp___0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
int op_delete(OPARG *oap ) 
{ 
  int n ;
  linenr_t lnum ;
  char_u *ptr ;
  char_u *newp ;
  char_u *oldp ;
  linenr_t old_lcount ;
  int did_yank ;
  struct block_def bd ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  old_lcount = curbuf->b_ml.ml_line_count;
  did_yank = 0;
  if (curbuf->b_ml.ml_flags & 1) {
    return (1);
  }
  if (oap->empty) {
    {
    tmp = u_save_cursor();
    }
    return (tmp);
  }
  if (oap->regname == 0) {
    {
    tmp___0 = vim_strchr(p_cb, 'd');
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      oap->regname = '*';
    }
  }
  if (! clipboard.available) {
    if (oap->regname == 42) {
      oap->regname = 0;
    }
  }
  if (oap->motion_type == 0) {
    if (! oap->is_VIsual) {
      if (oap->line_count > 1L) {
        if (oap->op_type == 1) {
          {
          tmp___1 = ml_get(oap->end.lnum);
          ptr = (tmp___1 + oap->end.col) + oap->inclusive;
          ptr = skipwhite(ptr);
          }
          if ((int )*ptr == 0) {
            {
            tmp___2 = inindent(0);
            }
            if (tmp___2) {
              oap->motion_type = 1;
            }
          }
        }
      }
    }
  }
  if (oap->motion_type == 0) {
    if (oap->line_count == 1L) {
      if (oap->op_type == 1) {
        {
        tmp___4 = ml_get(oap->start.lnum);
        }
        if ((int )*tmp___4 == 0) {
          {
          tmp___3 = vim_strchr(p_cpo, 'E');
          }
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            {
            beep_flush();
            }
          }
          return (1);
        }
      }
    }
  }
  if (oap->regname != 95) {
    if (oap->regname != 0) {
      {
      tmp___5 = valid_yank_reg(oap->regname, 1);
      }
      if (! tmp___5) {
        {
        beep_flush();
        }
        return (1);
      }
      {
      get_yank_register(oap->regname, 1);
      tmp___6 = op_yank(oap, 1, 0);
      }
      if (tmp___6 == 1) {
        did_yank = 1;
      }
    }
    if (oap->regname != 0) {
      goto _L;
    } else { //Added block
    if (oap->motion_type == 1) {
      goto _L;
    } else { //Added block
    if (oap->line_count > 1L) {
      _L: 
      {
      y_current = & y_regs[9];
      free_yank_all();
      n = 9;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (n > 1)) {
          goto while_break;
        }
        y_regs[n] = y_regs[n - 1];
        n --;
      }
      while_break: /* CIL Label */ ;
      }
      y_current = & y_regs[1];
      y_previous = y_current;
      y_regs[1].y_array = (char_u **)((void *)0);
      oap->regname = 0;
    } else { //Added block
    if (oap->regname == 0) {
      {
      oap->regname = '-';
      get_yank_register(oap->regname, 1);
      oap->regname = 0;
      }
    }
    }
    }
    }
    if (oap->regname == 0) {
      {
      tmp___7 = op_yank(oap, 1, 0);
      }
      if (tmp___7 == 1) {
        did_yank = 1;
      }
    }
    if (! did_yank) {
      {
      tmp___8 = ask_yesno((char_u *)"cannot yank; delete anyway", 1);
      }
      if (tmp___8 != 121) {
        {
        emsg(e_abort);
        }
        return (0);
      }
    }
  }
  if (oap->block_mode) {
    {
    tmp___9 = u_save(oap->start.lnum - 1L, oap->end.lnum + 1L);
    }
    if (tmp___9 == 0) {
      return (0);
    }
    {
    syn_changed(curwin->w_cursor.lnum);
    lnum = curwin->w_cursor.lnum;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (curwin->w_cursor.lnum <= oap->end.lnum)) {
        goto while_break___0;
      }
      {
      block_prep(oap, & bd, curwin->w_cursor.lnum, 1);
      }
      if (bd.textlen == 0) {
        goto __Cont;
      }
      {
      n = (bd.textlen - bd.startspaces) - bd.endspaces;
      oldp = ml_get_curline();
      tmp___10 = strlen((char const   *)((char *)oldp));
      newp = alloc_check(((unsigned int )tmp___10 + 1U) - (unsigned int )n);
      }
      if ((unsigned long )newp == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      {
      memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )bd.textcol);
      copy_spaces(newp + bd.textcol, (size_t )(bd.startspaces + bd.endspaces));
      oldp += bd.textcol + (colnr_t )bd.textlen;
      tmp___11 = strlen((char const   *)((char *)oldp));
      memmove((void *)((char *)(((newp + bd.textcol) + bd.startspaces) + bd.endspaces)),
              (void const   *)((char *)oldp), tmp___11 + 1UL);
      ml_replace(curwin->w_cursor.lnum, newp, 0);
      }
      __Cont: 
      (curwin->w_cursor.lnum) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    curwin->w_cursor.lnum = lnum;
    changed_cline_bef_curs();
    approximate_botline();
    adjust_cursor();
    changed();
    update_screen(30);
    oap->line_count = 0L;
    }
  } else { //Added block
  if (oap->motion_type == 1) {
    if (oap->op_type == 3) {
      if (oap->line_count > 1L) {
        {
        lnum = curwin->w_cursor.lnum;
        (curwin->w_cursor.lnum) ++;
        del_lines(oap->line_count - 1L, 1, 1);
        curwin->w_cursor.lnum = lnum;
        }
      }
      {
      tmp___12 = u_save_cursor();
      }
      if (tmp___12 == 0) {
        return (0);
      }
      if (curbuf->b_p_ai) {
        {
        beginline(1);
        did_ai = 1;
        ai_col = curwin->w_cursor.col;
        }
      } else {
        {
        beginline(0);
        }
      }
      {
      syn_changed(curwin->w_cursor.lnum);
      truncate_line(0);
      }
      if (oap->line_count > 1L) {
        {
        u_clearline();
        }
      }
    } else {
      {
      del_lines(oap->line_count, 1, 1);
      beginline(5);
      u_clearline();
      }
    }
  } else { //Added block
  if (oap->line_count == 1L) {
    {
    tmp___13 = u_save_cursor();
    }
    if (tmp___13 == 0) {
      return (0);
    }
    {
    tmp___14 = vim_strchr(p_cpo, '$');
    }
    if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
      if (oap->op_type == 3) {
        if (oap->end.lnum == curwin->w_cursor.lnum) {
          if (! oap->is_VIsual) {
            {
            display_dollar(oap->end.col - (colnr_t )(! oap->inclusive));
            }
          }
        }
      }
    }
    {
    n = (int )(((oap->end.col - oap->start.col) + 1U) - (colnr_t )(! oap->inclusive));
    del_chars((long )n, restart_edit == 0);
    }
  } else {
    {
    tmp___15 = u_save_cursor();
    }
    if (tmp___15 == 0) {
      return (0);
    }
    {
    syn_changed(curwin->w_cursor.lnum);
    truncate_line(1);
    oap->start = curwin->w_cursor;
    (curwin->w_cursor.lnum) ++;
    del_lines(oap->line_count - 2L, 1, 1);
    tmp___16 = u_save_cursor();
    }
    if (tmp___16 == 0) {
      return (0);
    }
    {
    u_clearline();
    curwin->w_cursor.col = (colnr_t )0;
    del_chars((long )((oap->end.col + 1U) - (colnr_t )(! oap->inclusive)), restart_edit == 0);
    curwin->w_cursor = oap->start;
    do_join(0, 1);
    }
  }
  }
  }
  if (oap->motion_type == 0) {
    if (oap->line_count == 1L) {
      if (dollar_vcol) {
        must_redraw = 0;
      } else {
        {
        update_screenline();
        }
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (! global_busy) {
    {
    update_topline();
    update_screen(40);
    }
  }
  }
  {
  msgmore(curbuf->b_ml.ml_line_count - old_lcount);
  curbuf->b_op_start = oap->start;
  }
  if (oap->block_mode) {
    curbuf->b_op_end.lnum = oap->end.lnum;
    curbuf->b_op_end.col = oap->start.col;
  } else {
    curbuf->b_op_end = oap->start;
  }
  return (1);
}
}
int op_replace(OPARG *oap , int c ) 
{ 
  int n ;
  linenr_t lnum ;
  char_u *newp ;
  char_u *oldp ;
  linenr_t old_lcount ;
  struct block_def bd ;
  int tmp ;
  colnr_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  old_lcount = curbuf->b_ml.ml_line_count;
  if (curbuf->b_ml.ml_flags & 1) {
    return (1);
  } else { //Added block
  if (oap->empty) {
    return (1);
  }
  }
  if (oap->block_mode) {
    {
    tmp = u_save(oap->start.lnum - 1L, oap->end.lnum + 1L);
    }
    if (tmp == 0) {
      return (0);
    }
    {
    syn_changed(curwin->w_cursor.lnum);
    lnum = curwin->w_cursor.lnum;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (curwin->w_cursor.lnum <= oap->end.lnum)) {
        goto while_break;
      }
      {
      block_prep(oap, & bd, curwin->w_cursor.lnum, 1);
      }
      if (bd.textlen == 0) {
        goto __Cont;
      }
      if (bd.startspaces) {
        n = (int )(bd.start_char_vcols - 1U);
      } else {
        n = 0;
      }
      if (bd.endspaces) {
        if (! bd.is_oneChar) {
          tmp___0 = bd.end_char_vcols - 1U;
        } else {
          tmp___0 = (colnr_t )0;
        }
      } else {
        tmp___0 = (colnr_t )0;
      }
      {
      n = (int )((colnr_t )n + tmp___0);
      n = (int )((colnr_t )n + (((oap->end_vcol - oap->start_vcol) - (colnr_t )bd.textlen) + 1U));
      oldp = ml_get_curline();
      tmp___1 = strlen((char const   *)((char *)oldp));
      newp = alloc_check(((unsigned int )tmp___1 + 1U) + (unsigned int )n);
      }
      if ((unsigned long )newp == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      {
      tmp___2 = strlen((char const   *)((char *)oldp));
      memset((void *)newp, '\000', (tmp___2 + 1UL) + (size_t )n);
      memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )bd.textcol);
      oldp += bd.textcol + (colnr_t )bd.textlen;
      copy_spaces(newp + bd.textcol, (size_t )bd.startspaces);
      tmp___3 = strlen((char const   *)((char *)newp));
      copy_chars(newp + tmp___3, (size_t )bd.textlen, c);
      }
      if (! bd.is_short) {
        {
        tmp___4 = strlen((char const   *)((char *)newp));
        copy_spaces(newp + tmp___4, (size_t )bd.endspaces);
        tmp___5 = strlen((char const   *)((char *)oldp));
        tmp___6 = strlen((char const   *)((char *)newp));
        memmove((void *)((char *)(newp + tmp___6)), (void const   *)((char *)oldp),
                tmp___5 + 1UL);
        }
      }
      {
      ml_replace(curwin->w_cursor.lnum, newp, 0);
      }
      __Cont: 
      (curwin->w_cursor.lnum) ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    curwin->w_cursor.lnum = lnum;
    changed_cline_bef_curs();
    approximate_botline();
    adjust_cursor();
    changed();
    update_screen(30);
    oap->line_count = 0L;
    }
  }
  if (oap->motion_type == 0) {
    if (oap->line_count == 1L) {
      if (dollar_vcol) {
        must_redraw = 0;
      } else {
        {
        update_screenline();
        }
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (! global_busy) {
    {
    update_topline();
    update_screen(40);
    }
  }
  }
  {
  msgmore(curbuf->b_ml.ml_line_count - old_lcount);
  curbuf->b_op_start = oap->start;
  }
  if (oap->block_mode) {
    curbuf->b_op_end.lnum = oap->end.lnum;
    curbuf->b_op_end.col = oap->start.col;
  } else {
    curbuf->b_op_end = oap->start;
  }
  return (1);
}
}
void op_tilde(OPARG *oap ) 
{ 
  FPOS pos___0 ;
  struct block_def bd ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
  tmp = u_save(oap->start.lnum - 1L, oap->end.lnum + 1L);
  }
  if (tmp == 0) {
    return;
  }
  curbuf->b_op_start = oap->start;
  curbuf->b_op_end = oap->end;
  pos___0 = oap->start;
  if (oap->block_mode) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (pos___0.lnum <= oap->end.lnum)) {
        goto while_break;
      }
      {
      block_prep(oap, & bd, pos___0.lnum, 0);
      pos___0.col = bd.textcol;
      }
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        (bd.textlen) --;
        if (! (bd.textlen >= 0)) {
          goto while_break___0;
        }
        {
        swapchar(oap->op_type, & pos___0);
        tmp___0 = inc(& pos___0);
        }
        if (tmp___0 == -1) {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      (pos___0.lnum) ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    if (oap->motion_type == 1) {
      {
      pos___0.col = (colnr_t )0;
      tmp___1 = ml_get(oap->end.lnum);
      tmp___2 = strlen((char const   *)((char *)tmp___1));
      oap->end.col = (colnr_t )tmp___2;
      }
      if (oap->end.col) {
        (oap->end.col) --;
      }
    } else { //Added block
    if (! oap->inclusive) {
      {
      dec(& oap->end);
      }
    }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (pos___0.lnum != oap->end.lnum) {
        tmp___4 = pos___0.lnum < oap->end.lnum;
      } else {
        tmp___4 = pos___0.col <= oap->end.col;
      }
      if (! tmp___4) {
        goto while_break___1;
      }
      {
      swapchar(oap->op_type, & pos___0);
      tmp___3 = inc(& pos___0);
      }
      if (tmp___3 == -1) {
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  if (oap->motion_type == 0) {
    if (oap->line_count == 1L) {
      if (! oap->block_mode) {
        {
        update_screenline();
        }
      } else {
        {
        syn_changed(oap->start.lnum);
        update_topline();
        update_screen(40);
        }
      }
    } else {
      {
      syn_changed(oap->start.lnum);
      update_topline();
      update_screen(40);
      }
    }
  } else {
    {
    syn_changed(oap->start.lnum);
    update_topline();
    update_screen(40);
    }
  }
  if (oap->line_count > p_report) {
    {
    tmp___5 = plural(oap->line_count);
    smsg((char_u *)"%ld line%s ~ed", oap->line_count, tmp___5);
    }
  }
  return;
}
}
void swapchar(int op_type , FPOS *pos___0 ) 
{ 
  int c ;
  int nc ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  c = gchar_pos(pos___0);
  }
  if (c >= 128) {
    if (op_type == 15) {
      return;
    }
  }
  {
  nc = c;
  tmp___0 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___0 + c) & 512) {
    if (op_type == 15) {
      nc = ((c - 97) + 13) % 26 + 97;
    } else { //Added block
    if (op_type != 12) {
      {
      nc = toupper(c);
      }
    }
    }
  } else {
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + c) & 256) {
      if (op_type == 15) {
        nc = ((c - 65) + 13) % 26 + 65;
      } else { //Added block
      if (op_type != 11) {
        {
        nc = tolower(c);
        }
      }
      }
    }
  }
  if (nc != c) {
    {
    tmp___1 = ml_get_buf(curbuf, pos___0->lnum, 1);
    *(tmp___1 + pos___0->col) = (char_u )nc;
    changed();
    }
  }
  return;
}
}
void op_insert(OPARG *oap , long count1 ) 
{ 
  long ins_len ;
  long pre_textlen ;
  char_u *firstline ;
  char_u *ins_text ;
  struct block_def bd ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  struct block_def bd2 ;
  char_u *tmp___6 ;
  size_t tmp___7 ;

  {
  {
  pre_textlen = 0L;
  tmp = u_save(oap->start.lnum - 1L, oap->end.lnum + 1L);
  }
  if (tmp == 0) {
    return;
  }
  {
  bd.is_MAX = curwin->w_curswant == 2147483647U;
  tmp___0 = ml_get_curline();
  tmp___1 = linetabsize(tmp___0);
  bd.is_EOL = tmp___1 == (int )oap->end_vcol;
  curwin->w_cursor.lnum = oap->start.lnum;
  update_screen(30);
  }
  if (oap->block_mode) {
    {
    block_prep(oap, & bd, oap->start.lnum, 1);
    tmp___2 = ml_get(oap->start.lnum);
    firstline = tmp___2 + bd.textcol;
    }
    if (oap->op_type == 18) {
      firstline += bd.textlen;
    }
    {
    tmp___3 = strlen((char const   *)((char *)firstline));
    pre_textlen = (long )tmp___3;
    }
  }
  if (oap->op_type == 18) {
    if (oap->block_mode) {
      curwin->w_set_curswant = 1;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        tmp___4 = inc_cursor();
        }
        if (tmp___4 == 0) {
          if (! (curwin->w_cursor.col < bd.textcol + (colnr_t )bd.textlen)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      if (bd.is_short) {
        if (! bd.is_MAX) {
          i___0 = 0;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (i___0 < bd.endspaces)) {
              goto while_break___0;
            }
            {
            ins_char(' ');
            i___0 ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          bd.textlen += bd.endspaces;
        }
      }
    } else {
      {
      curwin->w_cursor = oap->end;
      tmp___5 = ml_get(curwin->w_cursor.lnum);
      }
      if (! ((int )*tmp___5 == 0)) {
        if (oap->start_vcol != oap->end_vcol) {
          {
          inc_cursor();
          }
        }
      }
    }
  }
  {
  edit('\000', 0, count1);
  }
  if (curwin->w_cursor.lnum != oap->start.lnum) {
    return;
  }
  if (oap->block_mode) {
    {
    block_prep(oap, & bd2, oap->start.lnum, 1);
    }
    if (! bd.is_MAX) {
      goto _L;
    } else { //Added block
    if (bd2.textlen < bd.textlen) {
      _L: 
      if (oap->op_type == 18) {
        pre_textlen += (long )(bd2.textlen - bd.textlen);
        if (bd2.endspaces) {
          (bd2.textlen) --;
        }
      }
      bd.textcol = bd2.textcol;
      bd.textlen = bd2.textlen;
    }
    }
    {
    tmp___6 = ml_get(oap->start.lnum);
    firstline = tmp___6 + bd.textcol;
    }
    if (oap->op_type == 18) {
      firstline += bd.textlen;
    }
    {
    tmp___7 = strlen((char const   *)((char *)firstline));
    ins_len = (long )(tmp___7 - (size_t )pre_textlen);
    }
    if (ins_len > 0L) {
      {
      ins_text = alloc_check((unsigned int )(ins_len + 1L));
      }
      if ((unsigned long )ins_text != (unsigned long )((char_u *)0)) {
        {
        strncpy((char * __restrict  )((char *)ins_text), (char const   * __restrict  )((char *)firstline),
                (size_t )ins_len);
        *(ins_text + ins_len) = (char_u )'\000';
        block_insert(oap, ins_text, oap->op_type == 17, & bd);
        curwin->w_cursor.col = oap->start.col;
        changed_cline_bef_curs();
        approximate_botline();
        adjust_cursor();
        changed();
        update_screen(30);
        }
      }
      {
      vim_free((void *)ins_text);
      }
    }
  }
  {
  syn_changed(oap->start.lnum);
  }
  if (oap->motion_type == 1) {
    if (curbuf->b_p_lisp) {
      if (curbuf->b_p_ai) {
        {
        fixthisline(& get_lisp_indent);
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (curbuf->b_p_cin) {
      {
      fixthisline(& get_c_indent);
      }
    }
    }
  }
  return;
}
}
int op_change(OPARG *oap ) 
{ 
  colnr_t l ;
  int retval ;
  long offset ;
  linenr_t linenr ;
  long ins_len ;
  long pre_textlen ;
  char_u *firstline ;
  char_u *ins_text ;
  char_u *newp ;
  char_u *oldp ;
  struct block_def bd ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  pre_textlen = 0L;
  l = oap->start.col;
  if (oap->motion_type == 1) {
    l = (colnr_t )0;
    if (curbuf->b_p_si) {
      if (! curbuf->b_p_cin) {
        can_si = 1;
      }
    }
  }
  if (curbuf->b_ml.ml_flags & 1) {
    {
    tmp = u_save_cursor();
    }
    if (tmp == 0) {
      return (0);
    }
  } else {
    {
    tmp___0 = op_delete(oap);
    }
    if (tmp___0 == 0) {
      return (0);
    }
  }
  if (l > curwin->w_cursor.col) {
    {
    tmp___1 = ml_get(curwin->w_cursor.lnum);
    }
    if (! ((int )*tmp___1 == 0)) {
      {
      inc_cursor();
      }
    }
  }
  if (oap->block_mode) {
    {
    firstline = ml_get(oap->start.lnum);
    tmp___2 = strlen((char const   *)((char *)firstline));
    pre_textlen = (long )tmp___2;
    block_prep(oap, & bd, oap->start.lnum, 1);
    }
  }
  if (oap->motion_type == 1) {
    if (curbuf->b_p_lisp) {
      if (curbuf->b_p_ai) {
        {
        fixthisline(& get_lisp_indent);
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (curbuf->b_p_cin) {
      {
      fixthisline(& get_c_indent);
      }
    }
    }
  }
  {
  retval = edit('\000', 0, (linenr_t )1);
  }
  if (oap->block_mode) {
    if (oap->start.lnum != oap->end.lnum) {
      {
      firstline = ml_get(oap->start.lnum);
      tmp___5 = strlen((char const   *)((char *)firstline));
      ins_len = (long )(tmp___5 - (size_t )pre_textlen);
      }
      if (ins_len > 0L) {
        {
        ins_text = alloc_check((unsigned int )(ins_len + 1L));
        }
        if ((unsigned long )ins_text != (unsigned long )((char_u *)0)) {
          {
          curwin->w_cursor = oap->end;
          strncpy((char * __restrict  )((char *)ins_text), (char const   * __restrict  )((char *)(firstline + bd.textcol)),
                  (size_t )ins_len);
          *(ins_text + ins_len) = (char_u )'\000';
          linenr = oap->start.lnum + 1L;
          }
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (! (linenr <= oap->end.lnum)) {
              goto while_break;
            }
            {
            block_prep(oap, & bd, linenr, 1);
            }
            if (! bd.is_short) {
              {
              oldp = ml_get(linenr);
              tmp___3 = strlen((char const   *)((char *)oldp));
              newp = alloc_check((unsigned int )((tmp___3 + (size_t )ins_len) + 1UL));
              }
              if ((unsigned long )newp == (unsigned long )((void *)0)) {
                goto __Cont;
              }
              {
              memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )bd.textcol);
              offset = 0L;
              }
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (! (offset < ins_len)) {
                  goto while_break___0;
                }
                *((newp + bd.textcol) + offset) = *(ins_text + offset);
                offset ++;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              oldp += bd.textcol;
              tmp___4 = strlen((char const   *)((char *)oldp));
              memmove((void *)((char *)((newp + bd.textcol) + offset)), (void const   *)((char *)oldp),
                      tmp___4 + 1UL);
              ml_replace(linenr, newp, 0);
              }
              if (linenr == oap->end.lnum) {
                curwin->w_cursor.col = (colnr_t )(((long )bd.textcol + ins_len) - 1L);
              }
            }
            __Cont: 
            linenr ++;
          }
          while_break: /* CIL Label */ ;
          }
          {
          changed_line_abv_curs();
          approximate_botline();
          adjust_cursor();
          changed();
          update_screen(40);
          }
        }
        {
        vim_free((void *)ins_text);
        }
      }
      {
      syn_changed(oap->start.lnum);
      }
    }
  }
  return (retval);
}
}
void init_yank(void) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 38)) {
      goto while_break;
    }
    y_regs[i___0].y_array = (char_u **)((void *)0);
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void free_yank(long n ) 
{ 
  long i___0 ;

  {
  if ((unsigned long )y_current->y_array != (unsigned long )((void *)0)) {
    i___0 = n;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      i___0 --;
      if (! (i___0 >= 0L)) {
        goto while_break;
      }
      {
      vim_free((void *)*(y_current->y_array + i___0));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)y_current->y_array);
    y_current->y_array = (char_u **)((void *)0);
    }
  }
  return;
}
}
static void free_yank_all(void) 
{ 


  {
  {
  free_yank(y_current->y_size);
  }
  return;
}
}
int op_yank(OPARG *oap , int deleting , int mess ) 
{ 
  long y_idx ;
  struct yankreg *curr ;
  struct yankreg newreg ;
  char_u **new_ptr ;
  linenr_t lnum ;
  long j ;
  long len___0 ;
  int yanktype ;
  long yanklines ;
  linenr_t yankendlnum ;
  char_u *p___0 ;
  char_u *pnew ;
  struct block_def bd ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  long tmp___2 ;
  char_u *tmp___3 ;
  size_t tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  linenr_t tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  linenr_t tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  char_u *tmp___14 ;
  char_u *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  char *tmp___21 ;

  {
  yanktype = oap->motion_type;
  yanklines = oap->line_count;
  yankendlnum = oap->end.lnum;
  if (oap->regname != 0) {
    {
    tmp = valid_yank_reg(oap->regname, 1);
    }
    if (! tmp) {
      {
      beep_flush();
      }
      return (0);
    }
  }
  if (oap->regname == 95) {
    return (1);
  }
  if (! deleting) {
    if (oap->regname == 0) {
      {
      tmp___0 = vim_strchr(p_cb, 'd');
      }
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        oap->regname = '*';
      }
    }
  }
  if (! clipboard.available) {
    if (oap->regname == 42) {
      oap->regname = 0;
    }
  }
  if (! deleting) {
    {
    get_yank_register(oap->regname, 1);
    }
  }
  curr = y_current;
  if (y_append) {
    if ((unsigned long )y_current->y_array != (unsigned long )((void *)0)) {
      y_current = & newreg;
    } else {
      {
      free_yank_all();
      }
    }
  } else {
    {
    free_yank_all();
    }
  }
  if (oap->motion_type == 0) {
    if (oap->start.col == 0U) {
      if (! oap->inclusive) {
        if (! oap->is_VIsual) {
          goto _L;
        } else { //Added block
        if ((int )*p_sel == 111) {
          _L: 
          if (oap->end.col == 0U) {
            if (yanklines > 1L) {
              yanktype = 1;
              yankendlnum --;
              yanklines --;
            }
          }
        }
        }
      }
    }
  }
  {
  y_current->y_size = yanklines;
  y_current->y_type = (char_u )yanktype;
  tmp___1 = lalloc_clear(sizeof(char_u *) * (unsigned long )yanklines, 1);
  y_current->y_array = (char_u **)tmp___1;
  }
  if ((unsigned long )y_current->y_array == (unsigned long )((void *)0)) {
    y_current = curr;
    return (0);
  }
  y_idx = 0L;
  lnum = oap->start.lnum;
  if (oap->block_mode) {
    y_current->y_type = (char_u )2;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (lnum <= yankendlnum)) {
        goto while_break;
      }
      {
      block_prep(oap, & bd, lnum, 0);
      pnew = alloc((unsigned int )(((bd.startspaces + bd.endspaces) + bd.textlen) + 1));
      }
      if ((unsigned long )pnew == (unsigned long )((void *)0)) {
        goto fail;
      }
      {
      tmp___2 = y_idx;
      y_idx ++;
      *(y_current->y_array + tmp___2) = pnew;
      copy_spaces(pnew, (size_t )bd.startspaces);
      pnew += bd.startspaces;
      memmove((void *)((char *)pnew), (void const   *)((char *)bd.textstart), (size_t )bd.textlen);
      pnew += bd.textlen;
      copy_spaces(pnew, (size_t )bd.endspaces);
      pnew += bd.endspaces;
      *pnew = (char_u )'\000';
      lnum ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    if (yanktype != 1) {
      if (yanklines == 1L) {
        {
        j = (long )(((oap->end.col - oap->start.col) + 1U) - (colnr_t )(! oap->inclusive));
        tmp___3 = ml_get(lnum);
        p___0 = tmp___3 + oap->start.col;
        tmp___4 = strlen((char const   *)((char *)p___0));
        len___0 = (long )tmp___4;
        }
        if (j > len___0) {
          j = len___0;
        } else { //Added block
        if (j < 0L) {
          j = len___0;
        }
        }
        {
        tmp___5 = vim_strnsave(p___0, (int )j);
        *(y_current->y_array + 0) = tmp___5;
        }
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
          fail: 
          {
          free_yank(y_idx);
          y_current = curr;
          }
          return (0);
        }
        goto success;
      }
      {
      tmp___7 = lnum;
      lnum ++;
      tmp___8 = ml_get(tmp___7);
      tmp___6 = vim_strsave(tmp___8 + oap->start.col);
      *(y_current->y_array + 0) = tmp___6;
      }
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
        goto fail;
      }
      y_idx ++;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (yanktype == 1) {
        tmp___12 = lnum <= yankendlnum;
      } else {
        tmp___12 = lnum < yankendlnum;
      }
      if (! tmp___12) {
        goto while_break___0;
      }
      {
      tmp___10 = lnum;
      lnum ++;
      tmp___11 = ml_get(tmp___10);
      tmp___9 = vim_strsave(tmp___11);
      *(y_current->y_array + y_idx) = tmp___9;
      }
      if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
        goto fail;
      }
      y_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (yanktype != 1) {
      {
      tmp___14 = ml_get(yankendlnum);
      tmp___13 = vim_strnsave(tmp___14, (int )((oap->end.col + 1U) - (colnr_t )(! oap->inclusive)));
      *(y_current->y_array + y_idx) = tmp___13;
      }
      if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
        goto fail;
      }
    }
  }
  success: 
  if ((unsigned long )curr != (unsigned long )y_current) {
    {
    tmp___15 = lalloc(sizeof(char_u *) * (unsigned long )(curr->y_size + y_current->y_size),
                      1);
    new_ptr = (char_u **)tmp___15;
    }
    if ((unsigned long )new_ptr == (unsigned long )((void *)0)) {
      goto fail;
    }
    j = 0L;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (j < curr->y_size)) {
        goto while_break___1;
      }
      *(new_ptr + j) = *(curr->y_array + j);
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    vim_free((void *)curr->y_array);
    curr->y_array = new_ptr;
    }
    if (yanktype == 1) {
      curr->y_type = (char_u )1;
    }
    if ((int )curr->y_type == 0) {
      {
      tmp___16 = strlen((char const   *)((char *)*(curr->y_array + (curr->y_size - 1L))));
      tmp___17 = strlen((char const   *)((char *)*(y_current->y_array + 0)));
      pnew = lalloc((tmp___16 + tmp___17) + 1UL, 1);
      }
      if ((unsigned long )pnew == (unsigned long )((void *)0)) {
        y_idx = y_current->y_size - 1L;
        goto fail;
      }
      {
      j --;
      strcpy((char * __restrict  )((char *)pnew), (char const   * __restrict  )((char *)*(curr->y_array + j)));
      strcat((char * __restrict  )((char *)pnew), (char const   * __restrict  )((char *)*(y_current->y_array + 0)));
      vim_free((void *)*(curr->y_array + j));
      vim_free((void *)*(y_current->y_array + 0));
      tmp___18 = j;
      j ++;
      *(curr->y_array + tmp___18) = pnew;
      y_idx = 1L;
      }
    } else {
      y_idx = 0L;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (y_idx < y_current->y_size)) {
        goto while_break___2;
      }
      tmp___19 = j;
      j ++;
      tmp___20 = y_idx;
      y_idx ++;
      *(curr->y_array + tmp___19) = *(y_current->y_array + tmp___20);
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    curr->y_size = j;
    vim_free((void *)y_current->y_array);
    y_current = curr;
    }
  }
  if (mess) {
    if (yanktype == 0) {
      if (! oap->block_mode) {
        if (yanklines == 1L) {
          yanklines = 0L;
        }
      }
    }
    if (yanklines > p_report) {
      {
      update_topline_redraw();
      tmp___21 = plural(yanklines);
      smsg((char_u *)"%ld line%s yanked", yanklines, tmp___21);
      }
    }
  }
  curbuf->b_op_start = oap->start;
  curbuf->b_op_end = oap->end;
  if ((unsigned long )curr == (unsigned long )(& y_regs[37])) {
    if (clipboard.available) {
      {
      clip_own_selection();
      clip_gen_set_selection();
      }
    }
  }
  return (1);
}
}
void do_put(int regname___0 , int dir , long count___2 , int flags___0 ) 
{ 
  char_u *ptr ;
  char_u *newp ;
  char_u *oldp ;
  int yanklen ;
  int oldlen ;
  int totlen ;
  linenr_t lnum ;
  colnr_t col ;
  long i___0 ;
  int y_type ;
  long y_size ;
  char_u **y_array ;
  long nr_lines ;
  colnr_t vcol ;
  int delcount ;
  int incr ;
  long j ;
  FPOS new_cursor ;
  int indent ;
  int orig_indent ;
  int indent_diff ;
  int first_indent ;
  int lendiff ;
  FPOS old_pos ;
  struct block_def bd ;
  char_u *insert_string ;
  int allocated ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char_u *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char_u *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;

  {
  totlen = 0;
  y_array = (char_u **)((void *)0);
  nr_lines = 0L;
  incr = 0;
  orig_indent = 0;
  indent_diff = 0;
  first_indent = 1;
  lendiff = 0;
  insert_string = (char_u *)((void *)0);
  allocated = 0;
  if (regname___0 == 0) {
    {
    tmp = vim_strchr(p_cb, 'd');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      regname___0 = '*';
    }
  }
  if (regname___0 == 42) {
    if (! clipboard.available) {
      regname___0 = 0;
    } else {
      {
      clip_get_selection();
      }
    }
  }
  if (flags___0 & 1) {
    {
    orig_indent = get_indent();
    }
  }
  curbuf->b_op_start = curwin->w_cursor;
  if (dir == 1) {
    (curbuf->b_op_start.col) ++;
  }
  curbuf->b_op_end = curwin->w_cursor;
  if (regname___0 == 46) {
    if (dir == 1) {
      if (count___2 == -1L) {
        tmp___0 = 'o';
      } else {
        tmp___0 = 'a';
      }
      tmp___2 = tmp___0;
    } else {
      if (count___2 == -1L) {
        tmp___1 = 'O';
      } else {
        tmp___1 = 'i';
      }
      tmp___2 = tmp___1;
    }
    {
    stuff_inserted(tmp___2, count___2, 0);
    }
    if (flags___0 & 2) {
      {
      tmp___3 = gchar_cursor();
      }
      if (tmp___3 != 0) {
        {
        stuffcharReadbuff('l');
        }
      }
    }
    return;
  }
  {
  tmp___4 = get_spec_reg(regname___0, & insert_string, & allocated, 1);
  }
  if (tmp___4) {
    if ((unsigned long )insert_string == (unsigned long )((void *)0)) {
      return;
    }
  }
  if ((unsigned long )insert_string != (unsigned long )((void *)0)) {
    y_type = 0;
    if (regname___0 == 61) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        y_size = 0L;
        ptr = insert_string;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
            goto while_break___0;
          }
          if ((unsigned long )y_array != (unsigned long )((void *)0)) {
            *(y_array + y_size) = ptr;
          }
          {
          y_size ++;
          ptr = vim_strchr(ptr, '\n');
          }
          if ((unsigned long )ptr != (unsigned long )((void *)0)) {
            if ((unsigned long )y_array != (unsigned long )((void *)0)) {
              *ptr = (char_u )'\000';
            }
            ptr ++;
            if ((int )*ptr == 0) {
              y_type = 1;
              goto while_break___0;
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        if ((unsigned long )y_array != (unsigned long )((void *)0)) {
          goto while_break;
        }
        {
        tmp___5 = alloc((unsigned int )((unsigned long )y_size * sizeof(char_u *)));
        y_array = (char_u **)tmp___5;
        }
        if ((unsigned long )y_array == (unsigned long )((void *)0)) {
          goto end;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      y_size = 1L;
      y_array = & insert_string;
    }
  } else {
    {
    get_yank_register(regname___0, 0);
    y_type = (int )y_current->y_type;
    y_size = y_current->y_size;
    y_array = y_current->y_array;
    }
  }
  if (count___2 == -1L) {
    y_type = 1;
    count___2 = 1L;
  }
  if (y_size == 0L) {
    goto _L;
  } else { //Added block
  if ((unsigned long )y_array == (unsigned long )((void *)0)) {
    _L: 
    if (regname___0 == 0) {
      tmp___7 = (char_u *)"\"";
    } else {
      {
      tmp___6 = transchar(regname___0);
      tmp___7 = tmp___6;
      }
    }
    {
    emsg2((char_u *)"Nothing in register %s", tmp___7);
    }
    goto end;
  }
  }
  if (y_type == 2) {
    lnum = (curwin->w_cursor.lnum + y_size) + 1L;
    if (lnum > curbuf->b_ml.ml_line_count) {
      lnum = curbuf->b_ml.ml_line_count + 1L;
    }
    {
    tmp___8 = u_save(curwin->w_cursor.lnum - 1L, lnum);
    }
    if (tmp___8 == 0) {
      goto end;
    }
  } else {
    {
    tmp___9 = u_save_cursor();
    }
    if (tmp___9 == 0) {
      goto end;
    }
  }
  {
  tmp___10 = strlen((char const   *)((char *)*(y_array + 0)));
  yanklen = (int )tmp___10;
  changed();
  lnum = curwin->w_cursor.lnum;
  col = curwin->w_cursor.col;
  approximate_botline();
  changed_cline_bef_curs();
  }
  if (y_type == 2) {
    if (dir == 1) {
      {
      tmp___11 = gchar_cursor();
      }
      if (tmp___11 != 0) {
        {
        getvcol(curwin, & curwin->w_cursor, (colnr_t *)((void *)0), (colnr_t *)((void *)0),
                & col);
        col ++;
        (curwin->w_cursor.col) ++;
        }
      } else {
        {
        getvcol(curwin, & curwin->w_cursor, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
        }
      }
    } else {
      {
      getvcol(curwin, & curwin->w_cursor, & col, (colnr_t *)((void *)0), (colnr_t *)((void *)0));
      }
    }
    {
    syn_changed(curwin->w_cursor.lnum);
    i___0 = 0L;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i___0 < y_size)) {
        goto while_break___1;
      }
      bd.startspaces = 0;
      bd.endspaces = 0;
      bd.textcol = (colnr_t )0;
      vcol = (colnr_t )0;
      delcount = 0;
      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
        {
        ml_append(curbuf->b_ml.ml_line_count, (char_u *)"", (colnr_t )1, 0);
        nr_lines ++;
        }
      }
      {
      oldp = ml_get_curline();
      tmp___12 = strlen((char const   *)((char *)oldp));
      oldlen = (int )tmp___12;
      ptr = oldp;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (vcol < col) {
          if (! *ptr) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        {
        incr = lbr_chartabsize(ptr, vcol);
        vcol += (colnr_t )incr;
        (bd.textcol) ++;
        ptr ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      if (vcol < col) {
        bd.startspaces = (int )(col - vcol);
      } else { //Added block
      if (vcol > col) {
        bd.endspaces = (int )(vcol - col);
        bd.startspaces = incr - bd.endspaces;
        (bd.textcol) --;
        delcount = 1;
      }
      }
      {
      tmp___13 = strlen((char const   *)((char *)*(y_array + i___0)));
      yanklen = (int )tmp___13;
      totlen = (int )((count___2 * (long )yanklen + (long )bd.startspaces) + (long )bd.endspaces);
      newp = alloc_check(((unsigned int )totlen + (unsigned int )oldlen) + 1U);
      }
      if ((unsigned long )newp == (unsigned long )((void *)0)) {
        goto while_break___1;
      }
      {
      ptr = newp;
      memmove((void *)((char *)ptr), (void const   *)((char *)oldp), (size_t )bd.textcol);
      ptr += bd.textcol;
      copy_spaces(ptr, (size_t )bd.startspaces);
      ptr += bd.startspaces;
      j = 0L;
      }
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! (j < count___2)) {
          goto while_break___3;
        }
        {
        memmove((void *)((char *)ptr), (void const   *)((char *)*(y_array + i___0)),
                (size_t )yanklen);
        ptr += yanklen;
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      copy_spaces(ptr, (size_t )bd.endspaces);
      ptr += bd.endspaces;
      memmove((void *)((char *)ptr), (void const   *)((char *)((oldp + bd.textcol) + delcount)),
              (size_t )((((colnr_t )oldlen - bd.textcol) - (colnr_t )delcount) + 1U));
      ml_replace(curwin->w_cursor.lnum, newp, 0);
      (curwin->w_cursor.lnum) ++;
      }
      if (i___0 == 0L) {
        curwin->w_cursor.col += (colnr_t )bd.startspaces;
      }
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    curbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1L;
    curbuf->b_op_end.col = (bd.textcol + (colnr_t )totlen) - 1U;
    if (flags___0 & 2) {
      curwin->w_cursor = curbuf->b_op_end;
      (curwin->w_cursor.col) ++;
    } else {
      curwin->w_cursor.lnum = lnum;
    }
    {
    update_topline();
    }
    if (flags___0 & 2) {
      {
      update_screen(40);
      }
    } else {
      {
      update_screen(30);
      }
    }
  } else {
    if (y_type == 0) {
      if (dir == 1) {
        {
        tmp___14 = gchar_cursor();
        }
        if (tmp___14 != 0) {
          col ++;
          if (yanklen) {
            (curwin->w_cursor.col) ++;
            (curbuf->b_op_end.col) ++;
          }
        }
      }
      new_cursor = curwin->w_cursor;
    } else { //Added block
    if (dir == -1) {
      lnum --;
    }
    }
    if (y_type == 0) {
      if (y_size == 1L) {
        totlen = (int )(count___2 * (long )yanklen);
        if (totlen) {
          {
          oldp = ml_get(lnum);
          tmp___15 = strlen((char const   *)((char *)oldp));
          newp = alloc_check((unsigned int )((tmp___15 + (size_t )totlen) + 1UL));
          }
          if ((unsigned long )newp == (unsigned long )((void *)0)) {
            goto end;
          }
          {
          memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
          ptr = newp + col;
          i___0 = 0L;
          }
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (! (i___0 < count___2)) {
              goto while_break___4;
            }
            {
            memmove((void *)((char *)ptr), (void const   *)((char *)*(y_array + 0)),
                    (size_t )yanklen);
            ptr += yanklen;
            i___0 ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
          tmp___16 = strlen((char const   *)((char *)(oldp + col)));
          memmove((void *)((char *)ptr), (void const   *)((char *)(oldp + col)), tmp___16 + 1UL);
          ml_replace(lnum, newp, 0);
          curwin->w_cursor.col += (colnr_t )(totlen - 1);
          }
        }
        curbuf->b_op_end = curwin->w_cursor;
        if (totlen) {
          if (restart_edit) {
            (curwin->w_cursor.col) ++;
          } else { //Added block
          if (flags___0 & 2) {
            (curwin->w_cursor.col) ++;
          }
          }
        }
        {
        update_screenline();
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      {
      syn_changed(lnum);
      }
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        count___2 --;
        if (! (count___2 >= 0L)) {
          goto while_break___5;
        }
        i___0 = 0L;
        if (y_type == 0) {
          {
          tmp___17 = ml_get(lnum);
          ptr = tmp___17 + col;
          tmp___18 = strlen((char const   *)((char *)*(y_array + (y_size - 1L))));
          totlen = (int )tmp___18;
          tmp___19 = strlen((char const   *)((char *)ptr));
          newp = alloc_check((unsigned int )((tmp___19 + (size_t )totlen) + 1UL));
          }
          if ((unsigned long )newp == (unsigned long )((void *)0)) {
            goto error;
          }
          {
          strcpy((char * __restrict  )((char *)newp), (char const   * __restrict  )((char *)*(y_array + (y_size - 1L))));
          strcat((char * __restrict  )((char *)newp), (char const   * __restrict  )((char *)ptr));
          ml_append(lnum, newp, (colnr_t )0, 0);
          vim_free((void *)newp);
          oldp = ml_get(lnum);
          newp = alloc_check((col + (colnr_t )yanklen) + 1U);
          }
          if ((unsigned long )newp == (unsigned long )((void *)0)) {
            goto error;
          }
          {
          memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
          memmove((void *)((char *)(newp + col)), (void const   *)((char *)*(y_array + 0)),
                  (size_t )(yanklen + 1));
          ml_replace(lnum, newp, 0);
          curwin->w_cursor.lnum = lnum;
          i___0 = 1L;
          }
        }
        {
        while (1) {
          while_continue___6: /* CIL Label */ ;
          if (! (i___0 < y_size)) {
            goto while_break___6;
          }
          if (y_type != 0) {
            goto _L___0;
          } else { //Added block
          if (i___0 < y_size - 1L) {
            _L___0: 
            {
            tmp___20 = ml_append(lnum, *(y_array + i___0), (colnr_t )0, 0);
            }
            if (tmp___20 == 0) {
              goto error;
            }
          }
          }
          lnum ++;
          i___0 ++;
          if (flags___0 & 1) {
            {
            old_pos = curwin->w_cursor;
            curwin->w_cursor.lnum = lnum;
            ptr = ml_get(lnum);
            }
            if (count___2 == 0L) {
              if (i___0 == y_size - 1L) {
                {
                tmp___21 = strlen((char const   *)((char *)ptr));
                lendiff = (int )tmp___21;
                }
              }
            }
            if ((int )*ptr == 35) {
              if (curbuf->b_p_si) {
                if (! curbuf->b_p_cin) {
                  indent = 0;
                } else {
                  goto _L___2;
                }
              } else { //Added block
              _L___2: 
              if (curbuf->b_p_cin) {
                {
                tmp___24 = in_cinkeys('#', ' ', 1);
                }
                if (tmp___24) {
                  indent = 0;
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
              }
            } else { //Added block
            _L___1: 
            if ((int )*ptr == 0) {
              indent = 0;
            } else { //Added block
            if (first_indent) {
              {
              tmp___22 = get_indent();
              indent_diff = orig_indent - tmp___22;
              indent = orig_indent;
              first_indent = 0;
              }
            } else {
              {
              tmp___23 = get_indent();
              indent = tmp___23 + indent_diff;
              }
              if (indent < 0) {
                indent = 0;
              }
            }
            }
            }
            {
            set_indent(indent, 1);
            curwin->w_cursor = old_pos;
            }
            if (count___2 == 0L) {
              if (i___0 == y_size - 1L) {
                {
                tmp___25 = ml_get(lnum);
                tmp___26 = strlen((char const   *)((char *)tmp___25));
                lendiff = (int )((size_t )lendiff - tmp___26);
                }
              }
            }
          }
          nr_lines ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
      curbuf->b_op_end.lnum = lnum;
      tmp___27 = strlen((char const   *)((char *)*(y_array + (y_size - 1L))));
      col = (colnr_t )(tmp___27 - (size_t )lendiff);
      }
      if (col > 1U) {
        curbuf->b_op_end.col = col - 1U;
      } else {
        curbuf->b_op_end.col = (colnr_t )0;
      }
      if (flags___0 & 2) {
        if (y_type == 1) {
          if (lnum >= curbuf->b_ml.ml_line_count) {
            curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
          } else {
            curwin->w_cursor.lnum = lnum + 1L;
          }
          curwin->w_cursor.col = (colnr_t )0;
        } else {
          curwin->w_cursor.lnum = lnum;
          curwin->w_cursor.col = col;
        }
        {
        redraw_curbuf_later(40);
        }
      } else { //Added block
      if (y_type == 1) {
        curwin->w_cursor.col = (colnr_t )0;
        if (dir == 1) {
          (curwin->w_cursor.lnum) ++;
        }
        {
        beginline(5);
        }
      } else {
        curwin->w_cursor = new_cursor;
      }
      }
      error: 
      if (y_type == 1) {
        curbuf->b_op_start.col = (colnr_t )0;
        if (dir == 1) {
          (curbuf->b_op_start.lnum) ++;
        }
      }
      {
      mark_adjust(curbuf->b_op_start.lnum + (linenr_t )(y_type == 0), (linenr_t )2147483647,
                  nr_lines, 0L);
      update_topline();
      update_screen(30);
      }
    }
  }
  {
  msgmore(nr_lines);
  curwin->w_set_curswant = 1;
  }
  end: 
  if (allocated) {
    {
    vim_free((void *)insert_string);
    }
    if (regname___0 == 61) {
      {
      vim_free((void *)y_array);
      }
    }
  }
  if (flags___0 & 2) {
    {
    tmp___28 = gchar_cursor();
    }
    if (tmp___28 == 0) {
      if (curwin->w_cursor.col) {
        if (! restart_edit) {
          if (! (State & 16)) {
            (curwin->w_cursor.col) --;
          }
        }
      }
    }
  }
  return;
}
}
int get_register_name(int num ) 
{ 


  {
  if (num == -1) {
    return ('\"');
  } else { //Added block
  if (num < 10) {
    return (num + 48);
  } else { //Added block
  if (num == 36) {
    return ('-');
  } else { //Added block
  if (num == 37) {
    return ('*');
  } else {
    return ((num + 97) - 10);
  }
  }
  }
  }
}
}
void do_dis(char_u *arg ) 
{ 
  int i___0 ;
  int n ;
  long j ;
  char_u *p___0 ;
  struct yankreg *yb ;
  char_u name___1 ;
  int attr ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *fname ;
  linenr_t dummy ;
  int tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;

  {
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    if ((int )*arg == 0) {
      arg = (char_u *)((void *)0);
    }
  }
  {
  attr = highlight_attr[0];
  msg_puts_title((char_u *)"\n--- Registers ---");
  i___0 = -1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 38)) {
      goto while_break;
    }
    if (i___0 == -1) {
      if ((unsigned long )y_previous != (unsigned long )((void *)0)) {
        yb = y_previous;
      } else {
        yb = & y_regs[0];
      }
    } else {
      yb = & y_regs[i___0];
    }
    {
    tmp = get_register_name(i___0);
    name___1 = (char_u )tmp;
    }
    if ((unsigned long )yb->y_array != (unsigned long )((void *)0)) {
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
        goto _L;
      } else {
        {
        tmp___1 = vim_strchr(arg, (int )name___1);
        }
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
          _L: 
          {
          msg_putchar('\n');
          msg_putchar('\"');
          msg_putchar((int )name___1);
          msg_puts((char_u *)"   ");
          n = (int )Columns - 6;
          j = 0L;
          }
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (j < yb->y_size) {
              if (! (n > 1)) {
                goto while_break___0;
              }
            } else {
              goto while_break___0;
            }
            if (j) {
              {
              msg_puts_attr((char_u *)"^J", attr);
              n -= 2;
              }
            }
            p___0 = *(yb->y_array + j);
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (*p___0) {
                {
                tmp___0 = charsize((int )*p___0);
                n -= tmp___0;
                }
                if (! (n >= 0)) {
                  goto while_break___1;
                }
              } else {
                goto while_break___1;
              }
              {
              msg_outtrans_len(p___0, 1);
              p___0 ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          if (n > 1) {
            if ((int )yb->y_type == 1) {
              {
              msg_puts_attr((char_u *)"^J", attr);
              }
            }
          }
          {
          out_flush();
          }
        }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  p___0 = get_last_insert();
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      msg_puts((char_u *)"\n\".   ");
      dis_msg(p___0, 1);
      }
    } else {
      {
      tmp___2 = vim_strchr(arg, '.');
      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        {
        msg_puts((char_u *)"\n\".   ");
        dis_msg(p___0, 1);
        }
      }
    }
  }
  if ((unsigned long )last_cmdline != (unsigned long )((void *)0)) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      msg_puts((char_u *)"\n\":   ");
      dis_msg(last_cmdline, 0);
      }
    } else {
      {
      tmp___3 = vim_strchr(arg, ':');
      }
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {
        msg_puts((char_u *)"\n\":   ");
        dis_msg(last_cmdline, 0);
        }
      }
    }
  }
  if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      msg_puts((char_u *)"\n\"%   ");
      dis_msg(curbuf->b_fname, 0);
      }
    } else {
      {
      tmp___4 = vim_strchr(arg, '%');
      }
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
        {
        msg_puts((char_u *)"\n\"%   ");
        dis_msg(curbuf->b_fname, 0);
        }
      }
    }
  }
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    goto _L___0;
  } else {
    {
    tmp___6 = vim_strchr(arg, '%');
    }
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      _L___0: 
      {
      tmp___5 = buflist_name_nr(0, & fname, & dummy);
      }
      if (tmp___5 != 0) {
        {
        msg_puts((char_u *)"\n\"#   ");
        dis_msg(fname, 0);
        }
      }
    }
  }
  {
  tmp___8 = last_search_pat();
  }
  if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      msg_puts((char_u *)"\n\"/   ");
      tmp___7 = last_search_pat();
      dis_msg(tmp___7, 0);
      }
    } else {
      {
      tmp___9 = vim_strchr(arg, '/');
      }
      if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
        {
        msg_puts((char_u *)"\n\"/   ");
        tmp___7 = last_search_pat();
        dis_msg(tmp___7, 0);
        }
      }
    }
  }
  if ((unsigned long )expr_line != (unsigned long )((void *)0)) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      msg_puts((char_u *)"\n\"=   ");
      dis_msg(expr_line, 0);
      }
    } else {
      {
      tmp___10 = vim_strchr(arg, '=');
      }
      if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
        {
        msg_puts((char_u *)"\n\"=   ");
        dis_msg(expr_line, 0);
        }
      }
    }
  }
  return;
}
}
void dis_msg(char_u *p___0 , int skip_esc ) 
{ 
  int n ;
  char_u *tmp ;
  int tmp___0 ;

  {
  n = (int )Columns - 6;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*p___0) {
      if ((int )*p___0 == 27) {
        if (skip_esc) {
          if ((int )*(p___0 + 1) == 0) {
            goto while_break;
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        {
        tmp___0 = charsize((int )*p___0);
        n -= tmp___0;
        }
        if (! (n >= 0)) {
          goto while_break;
        }
      }
    } else {
      goto while_break;
    }
    {
    tmp = p___0;
    p___0 ++;
    msg_outtrans_len(tmp, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void do_do_join(long count___2 , int insert_space , int redraw ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = u_save(curwin->w_cursor.lnum - 1L, curwin->w_cursor.lnum + count___2);
  }
  if (tmp == 0) {
    return;
  }
  if (count___2 > 10L) {
    redraw = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    count___2 --;
    if (! (count___2 > 0L)) {
      goto while_break;
    }
    {
    line_breakcheck();
    }
    if (got_int) {
      {
      beep_flush();
      }
      goto while_break;
    } else {
      {
      tmp___0 = do_join(insert_space, redraw);
      }
      if (tmp___0 == 0) {
        {
        beep_flush();
        }
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  redraw_later(30);
  update_topline_redraw();
  }
  return;
}
}
int do_join(int insert_space , int redraw ) 
{ 
  char_u *curr ;
  char_u *next ;
  char_u *newp ;
  int endcurr1 ;
  int endcurr2 ;
  int currsize ;
  int nextsize ;
  int spaces ;
  int rows_to_del ;
  linenr_t t ;
  int tmp ;
  size_t tmp___0 ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  rows_to_del = 0;
  if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {
    return (0);
  }
  if (redraw) {
    {
    tmp = may_validate_crow();
    }
    if (tmp == 1) {
      {
      rows_to_del = plines_m(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1L);
      }
    } else {
      redraw = 0;
    }
  }
  {
  curr = ml_get_curline();
  tmp___0 = strlen((char const   *)((char *)curr));
  currsize = (int )tmp___0;
  endcurr2 = '\000';
  endcurr1 = endcurr2;
  }
  if (currsize > 0) {
    endcurr1 = (int )*((curr + currsize) - 1);
    if (currsize > 1) {
      endcurr2 = (int )*((curr + currsize) - 2);
    }
  }
  {
  next = ml_get(curwin->w_cursor.lnum + 1L);
  spaces = 0;
  }
  if (insert_space) {
    {
    next = skipwhite(next);
    }
    if ((int )*next != 41) {
      if (currsize != 0) {
        if (endcurr1 != 9) {
          if (endcurr1 == 32) {
            endcurr1 = endcurr2;
          } else {
            spaces ++;
          }
          if (p_js) {
            if (endcurr1 == 46) {
              spaces ++;
            } else {
              {
              tmp___1 = vim_strchr(p_cpo, 'j');
              }
              if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
                if (endcurr1 == 63) {
                  spaces ++;
                } else { //Added block
                if (endcurr1 == 33) {
                  spaces ++;
                }
                }
              }
            }
          }
        }
      }
    }
  }
  {
  tmp___2 = strlen((char const   *)((char *)next));
  nextsize = (int )tmp___2;
  newp = alloc_check((unsigned int )(((currsize + nextsize) + spaces) + 1));
  }
  if ((unsigned long )newp == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  memmove((void *)((char *)((newp + currsize) + spaces)), (void const   *)((char *)next),
          (size_t )(nextsize + 1));
  curr = ml_get_curline();
  memmove((void *)((char *)newp), (void const   *)((char *)curr), (size_t )currsize);
  copy_spaces(newp + currsize, (size_t )spaces);
  ml_replace(curwin->w_cursor.lnum, newp, 0);
  syn_changed(curwin->w_cursor.lnum);
  t = curwin->w_cursor.lnum;
  (curwin->w_cursor.lnum) ++;
  del_lines(1L, 0, 0);
  curwin->w_cursor.lnum = t;
  }
  if (redraw) {
    {
    tmp___3 = plines(curwin->w_cursor.lnum);
    rows_to_del -= tmp___3;
    }
    if (rows_to_del > 0) {
      {
      win_del_lines(curwin, curwin->w_cline_row + curwin->w_cline_height, rows_to_del,
                    1, 1);
      }
    }
  }
  if (currsize == 0) {
    curwin->w_cursor.col = (colnr_t )0;
  } else {
    {
    curwin->w_cursor.col = (colnr_t )(currsize - 1);
    oneright();
    }
  }
  {
  changed();
  }
  return (1);
}
}
static int same_leader(int leader1_len , char_u *leader1_flags , int leader2_len ,
                       char_u *leader2_flags ) 
{ 
  int idx1 ;
  int idx2 ;
  char_u *p___0 ;
  char_u *line1 ;
  char_u *line2 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  idx1 = 0;
  idx2 = 0;
  if (leader1_len == 0) {
    return (leader2_len == 0);
  }
  if ((unsigned long )leader1_flags != (unsigned long )((void *)0)) {
    p___0 = leader1_flags;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (*p___0) {
        if (! ((int )*p___0 != 58)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      if ((int )*p___0 == 102) {
        return (leader2_len == 0);
      }
      if ((int )*p___0 == 101) {
        return (0);
      }
      if ((int )*p___0 == 115) {
        {
        tmp = ml_get_curline();
        }
        if ((int )*(tmp + leader1_len) == 0) {
          return (0);
        }
        if ((unsigned long )leader2_flags == (unsigned long )((void *)0)) {
          return (0);
        } else { //Added block
        if (leader2_len == 0) {
          return (0);
        }
        }
        p___0 = leader2_flags;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (*p___0) {
            if (! ((int )*p___0 != 58)) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
          if ((int )*p___0 == 109) {
            return (1);
          }
          p___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        return (0);
      }
      p___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  tmp___0 = ml_get_curline();
  line1 = vim_strsave(tmp___0);
  }
  if ((unsigned long )line1 != (unsigned long )((void *)0)) {
    idx1 = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((int )*(line1 + idx1) == 32)) {
        if (! ((int )*(line1 + idx1) == 9)) {
          goto while_break___1;
        }
      }
      idx1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    line2 = ml_get(curwin->w_cursor.lnum + 1L);
    idx2 = 0;
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (idx2 < leader2_len)) {
        goto while_break___2;
      }
      if ((int )*(line2 + idx2) == 32) {
        goto _L;
      } else { //Added block
      if ((int )*(line2 + idx2) == 9) {
        _L: 
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (! ((int )*(line1 + idx1) == 32)) {
            if (! ((int )*(line1 + idx1) == 9)) {
              goto while_break___3;
            }
          }
          idx1 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        tmp___1 = idx1;
        idx1 ++;
        if ((int )*(line1 + tmp___1) != (int )*(line2 + idx2)) {
          goto while_break___2;
        }
      }
      }
      idx2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    vim_free((void *)line1);
    }
  }
  if (idx2 == leader2_len) {
    if (idx1 == leader1_len) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
void op_format(OPARG *oap ) 
{ 
  long old_line_count ;
  int is_not_par ;
  int next_is_not_par ;
  int is_end_par ;
  int prev_is_end_par ;
  int leader_len ;
  int next_leader_len ;
  char_u *leader_flags ;
  char_u *next_leader_flags ;
  int advance ;
  int second_indent ;
  int do_second_indent ;
  int first_par_line ;
  int smd_save ;
  long count___2 ;
  int need_set_indent ;
  int force_format ;
  int max_len ;
  int screenlines ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;

  {
  {
  old_line_count = curbuf->b_ml.ml_line_count;
  prev_is_end_par = 0;
  leader_len = 0;
  leader_flags = (char_u *)((void *)0);
  advance = 1;
  second_indent = -1;
  first_par_line = 1;
  need_set_indent = 1;
  force_format = 0;
  screenlines = -1;
  tmp = u_save(oap->start.lnum - 1L, oap->end.lnum + 1L);
  }
  if (tmp == 0) {
    return;
  }
  if (oap->end.lnum - oap->start.lnum < Rows) {
    {
    screenlines = plines_m(oap->start.lnum, oap->end.lnum);
    }
  }
  {
  tmp___0 = comp_textwidth(1);
  max_len = tmp___0 * 3;
  curbuf->b_op_start = oap->start;
  fo_do_comments = has_format_option('q');
  do_second_indent = has_format_option('2');
  }
  if (curwin->w_cursor.lnum > 1L) {
    {
    is_not_par = fmt_check_par(curwin->w_cursor.lnum - 1L, & leader_len, & leader_flags);
    }
  } else {
    is_not_par = 1;
  }
  {
  next_is_not_par = fmt_check_par(curwin->w_cursor.lnum, & next_leader_len, & next_leader_flags);
  }
  if (is_not_par) {
    tmp___1 = 1;
  } else { //Added block
  if (next_is_not_par) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  }
  is_end_par = tmp___1;
  (curwin->w_cursor.lnum) --;
  count___2 = oap->line_count;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (count___2 > 0L) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (advance) {
      (curwin->w_cursor.lnum) ++;
      prev_is_end_par = is_end_par;
      is_not_par = next_is_not_par;
      leader_len = next_leader_len;
      leader_flags = next_leader_flags;
    }
    if (count___2 == 1L) {
      next_is_not_par = 1;
      next_leader_len = 0;
      next_leader_flags = (char_u *)((void *)0);
    } else {
      {
      next_is_not_par = fmt_check_par(curwin->w_cursor.lnum + 1L, & next_leader_len,
                                      & next_leader_flags);
      }
    }
    advance = 1;
    if (is_not_par) {
      tmp___2 = 1;
    } else { //Added block
    if (next_is_not_par) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    }
    is_end_par = tmp___2;
    if (! is_not_par) {
      if (first_par_line) {
        if (do_second_indent) {
          if (prev_is_end_par) {
            if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
              if (leader_len == 0) {
                if (next_leader_len == 0) {
                  {
                  tmp___3 = ml_get(curwin->w_cursor.lnum + 1L);
                  }
                  if (! ((int )*tmp___3 == 0)) {
                    {
                    second_indent = get_indent_lnum(curwin->w_cursor.lnum + 1L);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count) {
        is_end_par = 1;
      } else {
        {
        tmp___4 = same_leader(leader_len, leader_flags, next_leader_len, next_leader_flags);
        }
        if (! tmp___4) {
          is_end_par = 1;
        }
      }
      if (is_end_par) {
        goto _L;
      } else { //Added block
      if (force_format) {
        _L: 
        if (need_set_indent) {
          {
          tmp___5 = get_indent();
          set_indent(tmp___5, 1);
          }
        }
        {
        coladvance((colnr_t )2147483647);
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (curwin->w_cursor.col) {
            {
            tmp___6 = gchar_cursor();
            tmp___7 = vim_isspace(tmp___6);
            }
            if (! tmp___7) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
          {
          dec_cursor();
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        syn_changed(curwin->w_cursor.lnum);
        State = 16;
        smd_save = p_smd;
        p_smd = 0;
        insertchar((unsigned int )'\000', 1, second_indent, 0);
        State = 1;
        p_smd = smd_save;
        second_indent = -1;
        need_set_indent = is_end_par;
        }
        if (is_end_par) {
          first_par_line = 1;
        }
        force_format = 0;
      }
      }
      if (! is_end_par) {
        {
        advance = 0;
        (curwin->w_cursor.lnum) ++;
        curwin->w_cursor.col = (colnr_t )0;
        del_chars((long )next_leader_len, 0);
        (curwin->w_cursor.lnum) --;
        tmp___8 = do_join(1, 0);
        }
        if (tmp___8 == 0) {
          {
          beep_flush();
          }
          goto while_break;
        }
        {
        first_par_line = 0;
        tmp___9 = ml_get_curline();
        tmp___10 = strlen((char const   *)((char *)tmp___9));
        }
        if (tmp___10 > (size_t )max_len) {
          force_format = 1;
        } else {
          force_format = 0;
        }
      }
    }
    {
    line_breakcheck();
    count___2 --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  fo_do_comments = 0;
  if (screenlines > 0) {
    {
    tmp___11 = plines_m(oap->start.lnum, curwin->w_cursor.lnum);
    screenlines -= tmp___11;
    }
    if (screenlines > 0) {
      {
      win_del_lines(curwin, curwin->w_cline_row, screenlines, 0, 1);
      }
    } else { //Added block
    if (screenlines < 0) {
      {
      win_ins_lines(curwin, curwin->w_cline_row, screenlines, 0, 1);
      }
    }
    }
  }
  if (oap->end_adjusted) {
    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
      (curwin->w_cursor.lnum) ++;
    }
  }
  {
  beginline(5);
  update_screen(40);
  msgmore(curbuf->b_ml.ml_line_count - old_line_count);
  curbuf->b_op_end = curwin->w_cursor;
  }
  return;
}
}
static int fmt_check_par(linenr_t lnum , int *leader_len , char_u **leader_flags ) 
{ 
  char_u *flags___0 ;
  char_u *ptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
  flags___0 = (char_u *)((void *)0);
  ptr = ml_get(lnum);
  *leader_len = get_leader_len(ptr, leader_flags, 0);
  }
  if (*leader_len > 0) {
    flags___0 = *leader_flags;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (*flags___0) {
        if ((int )*flags___0 != 58) {
          if (! ((int )*flags___0 != 101)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      flags___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if ((int )*(ptr + *leader_len) == 0) {
    tmp___0 = 1;
  } else { //Added block
  if (*leader_len > 0) {
    if ((int )*flags___0 == 101) {
      tmp___0 = 1;
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    tmp = startPS(lnum, '\000', 0);
    }
    if (tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  }
  return (tmp___0);
}
}
static void block_prep(OPARG *oap , struct block_def *bdp , linenr_t lnum , int is_del ) 
{ 
  int incr ;
  char_u *pend ;
  char_u *pstart ;

  {
  {
  incr = 0;
  bdp->startspaces = 0;
  bdp->endspaces = 0;
  bdp->textlen = 0;
  bdp->textcol = (colnr_t )0;
  bdp->start_vcol = (colnr_t )0;
  bdp->end_vcol = (colnr_t )0;
  bdp->is_short = 0;
  bdp->is_oneChar = 0;
  bdp->pre_whitesp = 0;
  bdp->pre_whitesp_c = 0;
  pstart = ml_get(lnum);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (bdp->start_vcol < oap->start_vcol) {
      if (! *pstart) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    incr = lbr_chartabsize(pstart, bdp->start_vcol);
    bdp->start_vcol += (colnr_t )incr;
    (bdp->textcol) ++;
    }
    if ((int )*pstart == 32) {
      bdp->pre_whitesp += incr;
      (bdp->pre_whitesp_c) ++;
    } else { //Added block
    if ((int )*pstart == 9) {
      bdp->pre_whitesp += incr;
      (bdp->pre_whitesp_c) ++;
    } else {
      bdp->pre_whitesp = 0;
      bdp->pre_whitesp_c = 0;
    }
    }
    pstart ++;
  }
  while_break: /* CIL Label */ ;
  }
  bdp->start_char_vcols = (colnr_t )incr;
  if (bdp->start_vcol < oap->start_vcol) {
    bdp->is_short = 1;
    if (! is_del) {
      bdp->endspaces = (int )((oap->end_vcol - oap->start_vcol) + 1U);
    } else { //Added block
    if (oap->op_type == 18) {
      bdp->endspaces = (int )((oap->end_vcol - oap->start_vcol) + 1U);
    }
    }
  } else {
    bdp->startspaces = (int )(bdp->start_vcol - oap->start_vcol);
    if (is_del) {
      if (bdp->startspaces) {
        bdp->startspaces = (int )(bdp->start_char_vcols - (colnr_t )bdp->startspaces);
      }
    }
    pend = pstart;
    bdp->end_vcol = bdp->start_vcol;
    if (bdp->end_vcol > oap->end_vcol) {
      bdp->is_oneChar = 1;
      if (oap->op_type == 17) {
        bdp->endspaces = (int )(bdp->start_char_vcols - (colnr_t )bdp->startspaces);
      } else { //Added block
      if (oap->op_type == 18) {
        bdp->startspaces = (int )((colnr_t )bdp->startspaces + ((oap->end_vcol - oap->start_vcol) + 1U));
        bdp->endspaces = (int )(bdp->start_char_vcols - (colnr_t )bdp->startspaces);
      } else {
        bdp->startspaces = (int )((oap->end_vcol - oap->start_vcol) + 1U);
        if (is_del) {
          if (oap->op_type != 4) {
            bdp->startspaces = (int )(bdp->start_char_vcols - (colnr_t )bdp->startspaces);
          }
        }
      }
      }
    } else {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (bdp->end_vcol <= oap->end_vcol) {
          if (! *pend) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        {
        incr = lbr_chartabsize(pend, bdp->end_vcol);
        bdp->end_vcol += (colnr_t )incr;
        pend ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      if (bdp->end_vcol <= oap->end_vcol) {
        if (! is_del) {
          goto _L___0;
        } else { //Added block
        if (oap->op_type == 18) {
          goto _L___0;
        } else { //Added block
        if (oap->op_type == 16) {
          _L___0: 
          bdp->is_short = 1;
          if (oap->op_type == 18) {
            bdp->endspaces = (int )((oap->end_vcol - bdp->end_vcol) + 1U);
          } else {
            bdp->endspaces = 0;
          }
        } else {
          goto _L;
        }
        }
        }
      } else { //Added block
      _L: 
      if (bdp->end_vcol > oap->end_vcol) {
        bdp->endspaces = (int )((bdp->end_vcol - oap->end_vcol) - 1U);
        if (! is_del) {
          if ((unsigned long )pend != (unsigned long )pstart) {
            if (bdp->endspaces) {
              pend --;
            }
          }
        }
      }
      }
    }
    bdp->end_char_vcols = (colnr_t )incr;
    if (is_del) {
      if (bdp->startspaces) {
        pstart --;
        (bdp->textcol) --;
      }
    }
    bdp->textlen = (int )(pend - pstart);
  }
  bdp->textstart = pstart;
  return;
}
}
static int hexupper  =    0;
int do_addsub(int command , linenr_t Prenum1 ) 
{ 
  int col ;
  char_u buf1[30] ;
  char_u buf2[30] ;
  int hex ;
  unsigned long n ;
  unsigned long oldn ;
  char_u *ptr ;
  int c ;
  int length ;
  int todel ;
  int dohex ;
  int dooct ;
  int firstdigit ;
  int negative ;
  int subtract ;
  char_u *tmp ;
  char_u *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  char_u *tmp___12 ;
  size_t tmp___13 ;
  char_u *tmp___14 ;
  int tmp___15 ;

  {
  {
  length = 0;
  tmp = vim_strchr(curbuf->b_p_nf, 'x');
  dohex = (unsigned long )tmp != (unsigned long )((void *)0);
  tmp___0 = vim_strchr(curbuf->b_p_nf, 'o');
  dooct = (unsigned long )tmp___0 != (unsigned long )((void *)0);
  ptr = ml_get_curline();
  col = (int )curwin->w_cursor.col;
  }
  if (dohex) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (col > 0) {
        {
        tmp___1 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___1 + (int )*(ptr + col)) & 4096)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      col --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if (dohex) {
    if (col > 0) {
      if ((int )*(ptr + col) == 88) {
        goto _L___2;
      } else { //Added block
      if ((int )*(ptr + col) == 120) {
        _L___2: 
        if ((int )*(ptr + (col - 1)) == 48) {
          {
          tmp___4 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___4 + (int )*(ptr + (col + 1))) & 4096) {
            col --;
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    col = (int )curwin->w_cursor.col;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((int )*(ptr + col) != 0) {
        {
        tmp___2 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___2 + (int )*(ptr + col)) & 2048) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (col > 0) {
        {
        tmp___3 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___3 + (int )*(ptr + (col - 1))) & 2048)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      col --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  firstdigit = (int )*(ptr + col);
  tmp___5 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___5 + firstdigit) & 2048) {
    {
    tmp___6 = u_save_cursor();
    }
    if (tmp___6 != 1) {
      {
      beep_flush();
      }
      return (0);
    }
  } else {
    {
    beep_flush();
    }
    return (0);
  }
  {
  ptr = ml_get_curline();
  negative = 0;
  }
  if (col > 0) {
    if ((int )*(ptr + (col - 1)) == 45) {
      col --;
      negative = 1;
    }
  }
  {
  vim_str2nr(ptr + col, & hex, & length, dooct, dohex, (long *)((void *)0), & n);
  }
  if (hex) {
    if (negative) {
      col ++;
      length --;
      negative = 0;
    }
  }
  subtract = 0;
  if (command == 24) {
    subtract ^= 1;
  }
  if (negative) {
    subtract ^= 1;
  }
  oldn = n;
  if (subtract) {
    n -= (unsigned long )Prenum1;
  } else {
    n += (unsigned long )Prenum1;
  }
  if (! hex) {
    if (subtract) {
      if (n > oldn) {
        n = 1UL + (n ^ 0xffffffffffffffffUL);
        negative ^= 1;
      }
    } else { //Added block
    if (n < oldn) {
      n ^= 0xffffffffffffffffUL;
      negative ^= 1;
    }
    }
    if (n == 0UL) {
      negative = 0;
    }
  }
  {
  curwin->w_cursor.col = (colnr_t )col;
  todel = length;
  c = gchar_cursor();
  }
  if (c == 45) {
    length --;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    tmp___9 = todel;
    todel --;
    if (! (tmp___9 > 0)) {
      goto while_break___2;
    }
    {
    tmp___8 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___8 + c) & 1024) {
      {
      tmp___7 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___7 + c) & 256) {
        hexupper = 1;
      } else {
        hexupper = 0;
      }
    }
    {
    del_char(0);
    c = gchar_cursor();
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  ptr = buf1;
  if (negative) {
    tmp___10 = ptr;
    ptr ++;
    *tmp___10 = (char_u )'-';
  }
  if (hex) {
    tmp___11 = ptr;
    ptr ++;
    *tmp___11 = (char_u )'0';
    length --;
  }
  if (hex == 120) {
    tmp___12 = ptr;
    ptr ++;
    *tmp___12 = (char_u )hex;
    length --;
  } else { //Added block
  if (hex == 88) {
    tmp___12 = ptr;
    ptr ++;
    *tmp___12 = (char_u )hex;
    length --;
  }
  }
  if (length >= 29) {
    length = 28;
  }
  if (hex == 0) {
    {
    sprintf((char * __restrict  )((char *)(buf2)), (char const   * __restrict  )"%lu",
            n);
    }
  } else { //Added block
  if (hex == 48) {
    {
    sprintf((char * __restrict  )((char *)(buf2)), (char const   * __restrict  )"%lo",
            n);
    }
  } else { //Added block
  if (hex) {
    if (hexupper) {
      {
      sprintf((char * __restrict  )((char *)(buf2)), (char const   * __restrict  )"%lX",
              n);
      }
    } else {
      {
      sprintf((char * __restrict  )((char *)(buf2)), (char const   * __restrict  )"%lx",
              n);
      }
    }
  } else {
    {
    sprintf((char * __restrict  )((char *)(buf2)), (char const   * __restrict  )"%lx",
            n);
    }
  }
  }
  }
  {
  tmp___13 = strlen((char const   *)((char *)(buf2)));
  length = (int )((size_t )length - tmp___13);
  }
  if (firstdigit == 48) {
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      tmp___15 = length;
      length --;
      if (! (tmp___15 > 0)) {
        goto while_break___3;
      }
      tmp___14 = ptr;
      ptr ++;
      *tmp___14 = (char_u )'0';
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
  *ptr = (char_u )'\000';
  strcat((char * __restrict  )((char *)(buf1)), (char const   * __restrict  )((char *)(buf2)));
  ins_str(buf1);
  (curwin->w_cursor.col) --;
  curwin->w_set_curswant = 1;
  update_screenline();
  }
  return (1);
}
}
int read_viminfo_register(char_u *line , FILE *fp___0 , int force ) 
{ 
  int eof ;
  int do_it ;
  int size ;
  int limit ;
  int i___0 ;
  int set_prev ;
  char_u *str___1 ;
  char_u **array ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char_u *tmp___1 ;
  char_u **tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  char_u *tmp___8 ;

  {
  do_it = 1;
  set_prev = 0;
  array = (char_u **)((void *)0);
  str___1 = line + 1;
  if ((int )*str___1 == 34) {
    set_prev = 1;
    str___1 ++;
  }
  {
  tmp___0 = __ctype_b_loc();
  }
  if (! ((int const   )*(*tmp___0 + (int )*str___1) & 8)) {
    if ((int )*str___1 != 45) {
      {
      tmp = viminfo_error((char *)"Illegal register name", line);
      }
      if (tmp) {
        return (1);
      }
      do_it = 0;
    }
  }
  {
  tmp___1 = str___1;
  str___1 ++;
  get_yank_register((int )*tmp___1, 0);
  }
  if (! force) {
    if ((unsigned long )y_current->y_array != (unsigned long )((void *)0)) {
      do_it = 0;
    }
  }
  size = 0;
  limit = 100;
  if (do_it) {
    if (set_prev) {
      y_previous = y_current;
    }
    {
    vim_free((void *)y_current->y_array);
    tmp___3 = alloc((unsigned int )((unsigned long )limit * sizeof(char_u *)));
    tmp___2 = (char_u **)tmp___3;
    y_current->y_array = tmp___2;
    array = tmp___2;
    str___1 = skipwhite(str___1);
    tmp___5 = strncmp((char const   *)((char *)str___1), (char const   *)((char *)"CHAR"),
                      (size_t )4);
    }
    if (tmp___5 == 0) {
      y_current->y_type = (char_u )0;
    } else {
      {
      tmp___4 = strncmp((char const   *)((char *)str___1), (char const   *)((char *)"BLOCK"),
                        (size_t )5);
      }
      if (tmp___4 == 0) {
        y_current->y_type = (char_u )2;
      } else {
        y_current->y_type = (char_u )1;
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    eof = vim_fgets(line, 512, fp___0);
    }
    if (eof) {
      goto while_break;
    } else { //Added block
    if (! ((int )*(line + 0) == 9)) {
      if (! ((int )*(line + 0) == 60)) {
        goto while_break;
      }
    }
    }
    if (do_it) {
      if (size >= limit) {
        {
        tmp___6 = alloc((unsigned int )((unsigned long )(limit * 2) * sizeof(char_u *)));
        y_current->y_array = (char_u **)tmp___6;
        i___0 = 0;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (i___0 < limit)) {
            goto while_break___0;
          }
          *(y_current->y_array + i___0) = *(array + i___0);
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        vim_free((void *)array);
        limit *= 2;
        array = y_current->y_array;
        }
      }
      {
      str___1 = viminfo_readstring(line + 1, fp___0);
      }
      if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
        tmp___7 = size;
        size ++;
        *(array + tmp___7) = str___1;
      } else {
        do_it = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (do_it) {
    if (size == 0) {
      {
      vim_free((void *)array);
      y_current->y_array = (char_u **)((void *)0);
      }
    } else { //Added block
    if (size < limit) {
      {
      tmp___8 = alloc((unsigned int )((unsigned long )size * sizeof(char_u *)));
      y_current->y_array = (char_u **)tmp___8;
      i___0 = 0;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (i___0 < size)) {
          goto while_break___1;
        }
        *(y_current->y_array + i___0) = *(array + i___0);
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      vim_free((void *)array);
      }
    }
    }
    y_current->y_size = (linenr_t )size;
  }
  return (eof);
}
}
void write_viminfo_registers(FILE *fp___0 ) 
{ 
  int i___0 ;
  int j ;
  char_u *type ;
  char_u c ;
  int num_lines ;
  int max_num_lines ;

  {
  {
  fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# Registers:\n");
  max_num_lines = get_viminfo_parameter('\"');
  }
  if (max_num_lines == 0) {
    return;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 38)) {
      goto while_break;
    }
    if ((unsigned long )y_regs[i___0].y_array == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    if (i___0 == 37) {
      goto __Cont;
    }
    {
    if ((int )y_regs[i___0].y_type == 1) {
      goto case_1;
    }
    if ((int )y_regs[i___0].y_type == 0) {
      goto case_0;
    }
    if ((int )y_regs[i___0].y_type == 2) {
      goto case_2;
    }
    goto switch_default;
    case_1: /* CIL Label */ 
    type = (char_u *)"LINE";
    goto switch_break;
    case_0: /* CIL Label */ 
    type = (char_u *)"CHAR";
    goto switch_break;
    case_2: /* CIL Label */ 
    type = (char_u *)"BLOCK";
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Unknown register type %d",
            (int )y_regs[i___0].y_type);
    emsg(IObuff);
    type = (char_u *)"LINE";
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    if ((unsigned long )y_previous == (unsigned long )(& y_regs[i___0])) {
      {
      fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\"");
      }
    }
    if (i___0 == 36) {
      c = (char_u )'-';
    } else { //Added block
    if (i___0 < 10) {
      c = (char_u )(48 + i___0);
    } else {
      c = (char_u )((97 + i___0) - 10);
    }
    }
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\"%c\t%s\n",
            (int )c, type);
    num_lines = (int )y_regs[i___0].y_size;
    }
    if (max_num_lines > 0) {
      if (num_lines > max_num_lines) {
        num_lines = max_num_lines;
      }
    }
    j = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (j < num_lines)) {
        goto while_break___0;
      }
      {
      _IO_putc('\t', fp___0);
      viminfo_writestring(fp___0, *(y_regs[i___0].y_array + j));
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: 
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void clip_free_selection(void) 
{ 
  struct yankreg *y_ptr ;

  {
  {
  y_ptr = y_current;
  y_current = & y_regs[37];
  free_yank_all();
  y_current->y_size = (linenr_t )0;
  y_current = y_ptr;
  }
  return;
}
}
void clip_get_selection(void) 
{ 
  struct yankreg *old_y_previous ;
  struct yankreg *old_y_current ;
  FPOS old_cursor ;
  FPOS old_visual ;
  int old_visual_mode ;
  colnr_t old_curswant ;
  int old_set_curswant ;
  OPARG oa ;
  CMDARG ca ;

  {
  if (clipboard.owned) {
    if ((unsigned long )y_regs[37].y_array != (unsigned long )((void *)0)) {
      return;
    }
    {
    old_y_previous = y_previous;
    old_y_current = y_current;
    old_cursor = curwin->w_cursor;
    old_curswant = curwin->w_curswant;
    old_set_curswant = curwin->w_set_curswant;
    old_visual = VIsual;
    old_visual_mode = VIsual_mode;
    clear_oparg(& oa);
    oa.regname = '*';
    oa.op_type = 2;
    memset((void *)(& ca), 0, sizeof(ca));
    ca.oap = & oa;
    ca.cmdchar = 'y';
    ca.count1 = 1L;
    do_pending_operator(& ca, (char_u *)((void *)0), (int *)((void *)0), 0, 1, 1);
    y_previous = old_y_previous;
    y_current = old_y_current;
    curwin->w_cursor = old_cursor;
    curwin->w_curswant = old_curswant;
    curwin->w_set_curswant = old_set_curswant;
    VIsual = old_visual;
    VIsual_mode = old_visual_mode;
    }
  } else {
    {
    clip_free_selection();
    clip_gen_request_selection();
    }
  }
  return;
}
}
void clip_yank_selection(int type , char_u *str___1 , long len___0 ) 
{ 
  struct yankreg *y_ptr ;

  {
  {
  y_ptr = & y_regs[37];
  clip_free_selection();
  str_to_reg(y_ptr, type, str___1, len___0);
  }
  return;
}
}
int clip_convert_selection(char_u **str___1 , long_u *len___0 ) 
{ 
  struct yankreg *y_ptr ;
  char_u *p___0 ;
  int lnum ;
  int i___0 ;
  int j ;
  int_u eolsize ;
  size_t tmp ;
  char_u *tmp___0 ;

  {
  y_ptr = & y_regs[37];
  eolsize = (int_u )1;
  *str___1 = (char_u *)((void *)0);
  *len___0 = (long_u )0;
  if ((unsigned long )y_ptr->y_array == (unsigned long )((void *)0)) {
    return (-1);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((linenr_t )i___0 < y_ptr->y_size)) {
      goto while_break;
    }
    {
    tmp = strlen((char const   *)((char *)*(y_ptr->y_array + i___0)));
    *len___0 += tmp + (size_t )eolsize;
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )y_ptr->y_type == 0) {
    if (*len___0 > (long_u )eolsize) {
      *len___0 -= (long_u )eolsize;
    }
  }
  {
  tmp___0 = lalloc(*len___0, 1);
  *str___1 = tmp___0;
  p___0 = tmp___0;
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    return (-1);
  }
  lnum = 0;
  i___0 = 0;
  j = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < (int )*len___0)) {
      goto while_break___0;
    }
    if ((int )*(*(y_ptr->y_array + lnum) + j) == 10) {
      *(p___0 + i___0) = (char_u )'\000';
    } else { //Added block
    if ((int )*(*(y_ptr->y_array + lnum) + j) == 0) {
      *(p___0 + i___0) = (char_u )'\n';
      lnum ++;
      j = -1;
    } else {
      *(p___0 + i___0) = *(*(y_ptr->y_array + lnum) + j);
    }
    }
    i___0 ++;
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((int )y_ptr->y_type);
}
}
char_u *get_reg_contents(int regname___0 ) 
{ 
  long i___0 ;
  char_u *retval ;
  int allocated ;
  long len___0 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  long tmp___3 ;

  {
  if (regname___0 == 61) {
    return ((char_u *)((void *)0));
  }
  if (regname___0 == 64) {
    regname___0 = '\"';
  }
  if (regname___0 != 0) {
    {
    tmp = valid_yank_reg(regname___0, 0);
    }
    if (! tmp) {
      return ((char_u *)((void *)0));
    }
  }
  if (regname___0 == 42) {
    if (! clipboard.available) {
      regname___0 = 0;
    } else {
      {
      clip_get_selection();
      }
    }
  }
  {
  tmp___0 = get_spec_reg(regname___0, & retval, & allocated, 0);
  }
  if (tmp___0) {
    if ((unsigned long )retval == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    if (! allocated) {
      {
      retval = vim_strsave(retval);
      }
    }
    return (retval);
  }
  {
  get_yank_register(regname___0, 0);
  }
  if ((unsigned long )y_current->y_array == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  len___0 = 0L;
  i___0 = 0L;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < y_current->y_size)) {
      goto while_break;
    }
    {
    tmp___1 = strlen((char const   *)((char *)*(y_current->y_array + i___0)));
    len___0 = (long )((size_t )len___0 + tmp___1);
    }
    if ((int )y_current->y_type == 1) {
      len___0 ++;
    } else { //Added block
    if (i___0 < y_current->y_size - 1L) {
      len___0 ++;
    }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  retval = lalloc((long_u )(len___0 + 1L), 1);
  }
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
    len___0 = 0L;
    i___0 = 0L;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < y_current->y_size)) {
        goto while_break___0;
      }
      {
      strcpy((char * __restrict  )((char *)(retval + len___0)), (char const   * __restrict  )((char *)*(y_current->y_array + i___0)));
      tmp___2 = strlen((char const   *)((char *)(retval + len___0)));
      len___0 = (long )((size_t )len___0 + tmp___2);
      }
      if ((int )y_current->y_type == 1) {
        tmp___3 = len___0;
        len___0 ++;
        *(retval + tmp___3) = (char_u )'\n';
      } else { //Added block
      if (i___0 < y_current->y_size - 1L) {
        tmp___3 = len___0;
        len___0 ++;
        *(retval + tmp___3) = (char_u )'\n';
      }
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    *(retval + len___0) = (char_u )'\000';
  }
  return (retval);
}
}
void write_reg_contents(int name___1 , char_u *str___1 ) 
{ 
  struct yankreg *old_y_previous ;
  struct yankreg *old_y_current ;
  long len___0 ;
  char_u *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if (name___1 == 47) {
    {
    set_last_search_pat(str___1, 0, 1, 1);
    }
    return;
  }
  {
  tmp___0 = valid_yank_reg(name___1, 1);
  }
  if (! tmp___0) {
    {
    tmp = transchar(name___1);
    emsg2((char_u *)"Invalid register name: \'%s\'", tmp);
    }
    return;
  }
  if (name___1 == 95) {
    return;
  }
  {
  old_y_previous = y_previous;
  old_y_current = y_current;
  get_yank_register(name___1, 1);
  }
  if (! y_append) {
    {
    free_yank_all();
    }
  }
  {
  tmp___1 = strlen((char const   *)((char *)str___1));
  len___0 = (long )tmp___1;
  }
  if (len___0 > 0L) {
    if ((int )*(str___1 + (len___0 - 1L)) == 10) {
      tmp___2 = 1;
    } else { //Added block
    if ((int )*(str___1 + (len___0 - 1L)) == 13) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    }
  } else {
    tmp___2 = 0;
  }
  {
  str_to_reg(y_current, tmp___2, str___1, len___0);
  }
  if ((unsigned long )y_current == (unsigned long )(& y_regs[37])) {
    if (clipboard.available) {
      {
      clip_own_selection();
      clip_gen_set_selection();
      }
    }
  }
  y_previous = old_y_previous;
  y_current = old_y_current;
  return;
}
}
static void str_to_reg(struct yankreg *y_ptr , int type , char_u *str___1 , long len___0 ) 
{ 
  int lnum ;
  long start___0 ;
  long i___0 ;
  int extra ;
  int newlines ;
  int extraline ;
  int append ;
  char_u *s ;
  char_u **pp ;
  char_u *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  extraline = 0;
  append = 0;
  if ((unsigned long )y_ptr->y_array == (unsigned long )((void *)0)) {
    y_ptr->y_size = (linenr_t )0;
  }
  newlines = 0;
  i___0 = 0L;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < len___0)) {
      goto while_break;
    }
    if ((int )*(str___1 + i___0) == 10) {
      newlines ++;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (type == 0) {
    extraline = 1;
    newlines ++;
  } else { //Added block
  if (len___0 == 0L) {
    extraline = 1;
    newlines ++;
  } else { //Added block
  if ((int )*(str___1 + (len___0 - 1L)) != 10) {
    extraline = 1;
    newlines ++;
  }
  }
  }
  if (y_ptr->y_size > 0L) {
    if ((int )y_ptr->y_type == 0) {
      append = 1;
      newlines --;
    }
  }
  {
  tmp = lalloc_clear((unsigned long )(y_ptr->y_size + (linenr_t )newlines) * sizeof(char_u *),
                     1);
  pp = (char_u **)tmp;
  }
  if ((unsigned long )pp == (unsigned long )((void *)0)) {
    return;
  }
  lnum = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((linenr_t )lnum < y_ptr->y_size)) {
      goto while_break___0;
    }
    *(pp + lnum) = *(y_ptr->y_array + lnum);
    lnum ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  vim_free((void *)y_ptr->y_array);
  y_ptr->y_array = pp;
  start___0 = 0L;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (start___0 < len___0 + (long )extraline)) {
      goto while_break___1;
    }
    i___0 = start___0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (i___0 < len___0)) {
        goto while_break___2;
      }
      if ((int )*(str___1 + i___0) == 10) {
        goto while_break___2;
      }
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    i___0 -= start___0;
    if (append) {
      {
      lnum --;
      tmp___0 = strlen((char const   *)((char *)*(y_ptr->y_array + lnum)));
      extra = (int )tmp___0;
      }
    } else {
      extra = 0;
    }
    {
    s = alloc((unsigned int )((i___0 + (long )extra) + 1L));
    }
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      goto while_break___1;
    }
    if (extra) {
      {
      memmove((void *)((char *)s), (void const   *)((char *)*(y_ptr->y_array + lnum)),
              (size_t )extra);
      vim_free((void *)*(y_ptr->y_array + lnum));
      }
    }
    if (i___0) {
      {
      memmove((void *)((char *)(s + extra)), (void const   *)((char *)(str___1 + start___0)),
              (size_t )i___0);
      }
    }
    extra = (int )((long )extra + i___0);
    *(s + extra) = (char_u )'\000';
    tmp___1 = lnum;
    lnum ++;
    *(y_ptr->y_array + tmp___1) = s;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      extra --;
      if (! (extra >= 0)) {
        goto while_break___3;
      }
      if ((int )*s == 0) {
        *s = (char_u )'\n';
      }
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    append = 0;
    start___0 += i___0 + 1L;
  }
  while_break___1: /* CIL Label */ ;
  }
  y_ptr->y_type = (char_u )type;
  y_ptr->y_size = (linenr_t )lnum;
  return;
}
}
void clear_oparg(OPARG *oap ) 
{ 


  {
  {
  memset((void *)oap, 0, sizeof(OPARG ));
  }
  return;
}
}
#pragma merger("0","/tmp/cil-57zfFRmO.i","-O0")
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
int mch_can_restore_title(void) ;
int mch_can_restore_icon(void) ;
void mch_setmouse(int on ) ;
void check_mouse_termcode(void) ;
void clear_xterm_clip(void) ;
void set_string_default(char *name___1 , char_u *val ) ;
void set_number_default(char *name___1 , long val ) ;
void set_title_defaults(void) ;
void check_options(void) ;
void set_term_option_alloced(char_u **p___0 ) ;
char_u *check_stl_option(char_u *s ) ;
char_u *get_term_code(char_u *tname ) ;
char_u *get_highlight_default(void) ;
void clear_termoptions(void) ;
void set_term_defaults(void) ;
void comp_col(void) ;
void win_copy_options(WIN *wp_from , WIN *wp_to ) ;
int option_was_set(char_u *name___1 ) ;
int highlight_changed(void) ;
int set_termname(char_u *term ) ;
void ttest(int pairs ) ;
void check_winsize(void) ;
void clear_termcodes(void) ;
char_u *get_termcode(int i___0 ) ;
void show_termcodes(void) ;
int show_one_termcode(char_u *name___1 , char_u *code , int printit ) ;
void ui_set_winsize(void) ;
void win_setminheight(void) ;
void win_comp_scroll(WIN *wp ) ;
void command_height(long old_p_ch ) ;
int min_rows(void) ;
static struct vimoption options[286]  = 
  {      {(char *)"aleph", (char *)"al", (short_u )1026, (char_u *)((void *)0), {(char_u *)224L,
                                                                             (char_u *)0L}}, 
        {(char *)"allowrevins",
      (char *)"ari", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"altkeymap",
      (char *)"akm", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"autoindent",
      (char *)"ai", (short_u )1057, (char_u *)1, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"autoprint", (char *)"ap", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                                 (char_u *)0L}}, 
        {(char *)"autowrite",
      (char *)"aw", (short_u )1025, (char_u *)(& p_aw), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"background",
      (char *)"bg", (short_u )29700, (char_u *)(& p_bg), {(char_u *)"light", (char_u *)0L}}, 
        {(char *)"backspace",
      (char *)"bs", (short_u )35844, (char_u *)(& p_bs), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"backup",
      (char *)"bk", (short_u )3073, (char_u *)(& p_bk), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"backupdir",
      (char *)"bdir", (short_u )33812, (char_u *)(& p_bdir), {(char_u *)".,~/tmp,~/",
                                                              (char_u *)0L}}, 
        {(char *)"backupext", (char *)"bex", (short_u )1028, (char_u *)(& p_bex), {(char_u *)"~",
                                                                                (char_u *)0L}}, 
        {(char *)"beautify",
      (char *)"bf", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"binary",
      (char *)"bin", (short_u )5153, (char_u *)2, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"bioskey", (char *)"biosk", (short_u )1025, (char_u *)((void *)0), {(char_u *)1,
                                                                                  (char_u *)0L}}, 
        {(char *)"breakat",
      (char *)"brk", (short_u )17412, (char_u *)(& p_breakat), {(char_u *)" \t!@*-+_;:,./?",
                                                                (char_u *)0L}}, 
        {(char *)"browsedir", (char *)"bsdir", (short_u )1028, (char_u *)((void *)0),
      {(char_u *)"last", (char_u *)0L}}, 
        {(char *)"cindent", (char *)"cin", (short_u )3105, (char_u *)3, {(char_u *)0,
                                                                      (char_u *)0L}}, 
        {(char *)"cinkeys",
      (char *)"cink", (short_u )33836, (char_u *)4, {(char_u *)"0{,0},:,0#,!^F,o,O,e",
                                                     (char_u *)0L}}, 
        {(char *)"cinoptions", (char *)"cino", (short_u )33836, (char_u *)5, {(char_u *)"",
                                                                           (char_u *)0L}}, 
        {(char *)"cinwords",
      (char *)"cinw", (short_u )33836, (char_u *)6, {(char_u *)"if,else,while,do,for,switch",
                                                     (char_u *)0L}}, 
        {(char *)"clipboard", (char *)"cb", (short_u )33796, (char_u *)(& p_cb), {(char_u *)"",
                                                                               (char_u *)0L}}, 
        {(char *)"cmdheight",
      (char *)"ch", (short_u )17410, (char_u *)(& p_ch), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"columns",
      (char *)"co", (short_u )30274, (char_u *)(& Columns), {(char_u *)80L, (char_u *)0L}}, 
        {(char *)"comments",
      (char *)"com", (short_u )33836, (char_u *)7, {(char_u *)"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-",
                                                    (char_u *)0L}}, 
        {(char *)"compatible", (char *)"cp", (short_u )16385, (char_u *)(& p_cp), {(char_u *)1,
                                                                                (char_u *)0}}, 
        {(char *)"complete",
      (char *)"cpt", (short_u )33836, (char_u *)8, {(char_u *)".,w,b,u,t,i", (char_u *)0L}}, 
        {(char *)"confirm",
      (char *)"cf", (short_u )1025, (char_u *)(& p_confirm), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"conskey",
      (char *)"consk", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"cpoptions",
      (char *)"cpo", (short_u )18436, (char_u *)(& p_cpo), {(char_u *)"aAbBcCdeEfFjJkKlLmoOprsStuwWxy$!%*<",
                                                            (char_u *)"aABceFs"}}, 
        {(char *)"cscopeprg",
      (char *)"csprg", (short_u )1044, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopetag",
      (char *)"cst", (short_u )3073, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopetagorder",
      (char *)"csto", (short_u )3074, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopeverbose",
      (char *)"csverb", (short_u )3073, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"define",
      (char *)"def", (short_u )1028, (char_u *)(& p_def), {(char_u *)"^#\\s*define",
                                                           (char_u *)0L}}, 
        {(char *)"dictionary", (char *)"dict", (short_u )33812, (char_u *)(& p_dict),
      {(char_u *)"", (char_u *)0L}}, 
        {(char *)"digraph", (char *)"dg", (short_u )3073, (char_u *)(& p_dg), {(char_u *)0,
                                                                            (char_u *)0L}}, 
        {(char *)"directory",
      (char *)"dir", (short_u )33812, (char_u *)(& p_dir), {(char_u *)".,~/tmp,/var/tmp,/tmp",
                                                            (char_u *)0L}}, 
        {(char *)"display", (char *)"dy", (short_u )50180, (char_u *)(& p_dy), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"edcompatible",
      (char *)"ed", (short_u )1025, (char_u *)(& p_ed), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"endofline",
      (char *)"eol", (short_u )5665, (char_u *)9, {(char_u *)1, (char_u *)0L}}, 
        {(char *)"equalalways", (char *)"ea", (short_u )17409, (char_u *)(& p_ea), {(char_u *)1,
                                                                                 (char_u *)0L}}, 
        {(char *)"equalprg",
      (char *)"ep", (short_u )1044, (char_u *)(& p_ep), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"errorbells",
      (char *)"eb", (short_u )1025, (char_u *)(& p_eb), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"errorfile",
      (char *)"ef", (short_u )1044, (char_u *)(& p_ef), {(char_u *)"errors.err", (char_u *)0L}}, 
        {(char *)"errorformat",
      (char *)"efm", (short_u )33796, (char_u *)(& p_efm), {(char_u *)"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f\',%X%*\\a[%*\\d]: Leaving directory `%f\',%DMaking %*\\a in %f",
                                                            (char_u *)0L}}, 
        {(char *)"esckeys", (char *)"ek", (short_u )2049, (char_u *)(& p_ek), {(char_u *)0,
                                                                            (char_u *)1}}, 
        {(char *)"eventignore",
      (char *)"ei", (short_u )33796, (char_u *)(& p_ei), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"expandtab",
      (char *)"et", (short_u )3105, (char_u *)10, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"exrc", (char *)"ex", (short_u )1025, (char_u *)(& p_exrc), {(char_u *)0,
                                                                           (char_u *)0L}}, 
        {(char *)"fileencoding",
      (char *)"fe", (short_u )5164, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"fileformat",
      (char *)"ff", (short_u )5676, (char_u *)12, {(char_u *)"unix", (char_u *)0L}}, 
        {(char *)"fileformats",
      (char *)"ffs", (short_u )34820, (char_u *)(& p_ffs), {(char_u *)"", (char_u *)"unix,dos"}}, 
        {(char *)"filetype",
      (char *)"ft", (short_u )1068, (char_u *)14, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"fkmap", (char *)"fk", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                             (char_u *)0L}}, 
        {(char *)"flash",
      (char *)"fl", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"formatoptions",
      (char *)"fo", (short_u )2092, (char_u *)13, {(char_u *)"vt", (char_u *)"tcq"}}, 
        {(char *)"formatprg",
      (char *)"fp", (short_u )1044, (char_u *)(& p_fp), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"gdefault",
      (char *)"gd", (short_u )3073, (char_u *)(& p_gd), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"graphic",
      (char *)"gr", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"grepformat",
      (char *)"gfm", (short_u )33796, (char_u *)(& p_gefm), {(char_u *)"%f:%l%m,%f  %l%m",
                                                             (char_u *)0L}}, 
        {(char *)"grepprg", (char *)"gp", (short_u )1044, (char_u *)(& p_gp), {(char_u *)"grep -n",
                                                                            (char_u *)0L}}, 
        {(char *)"guicursor",
      (char *)"gcr", (short_u )33796, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                              (char_u *)0L}}, 
        {(char *)"guifont", (char *)"gfn", (short_u )62468, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                                                 (char_u *)0L}}, 
        {(char *)"guifontset",
      (char *)"gfs", (short_u )62468, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                              (char_u *)0L}}, 
        {(char *)"guiheadroom", (char *)"ghr", (short_u )1026, (char_u *)((void *)0),
      {(char_u *)50L, (char_u *)0L}}, 
        {(char *)"guioptions", (char *)"go", (short_u )17412, (char_u *)((void *)0),
      {(char_u *)((void *)0), (char_u *)0L}}, 
        {(char *)"guipty", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)1, (char_u *)0L}}, 
        {(char *)"hardtabs", (char *)"ht", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L,
                                                                                (char_u *)0L}}, 
        {(char *)"helpfile",
      (char *)"hf", (short_u )1044, (char_u *)(& p_hf), {(char_u *)"$VIMRUNTIME/doc/help.txt",
                                                         (char_u *)0L}}, 
        {(char *)"helpheight", (char *)"hh", (short_u )1026, (char_u *)(& p_hh), {(char_u *)20L,
                                                                               (char_u *)0L}}, 
        {(char *)"hidden",
      (char *)"hid", (short_u )1025, (char_u *)(& p_hid), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"highlight",
      (char *)"hl", (short_u )62468, (char_u *)(& p_hl), {(char_u *)"8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,r:Question,s:StatusLine,S:StatusLineNC,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu",
                                                          (char_u *)0L}}, 
        {(char *)"history", (char *)"hi", (short_u )2050, (char_u *)(& p_hi), {(char_u *)0L,
                                                                            (char_u *)20L}}, 
        {(char *)"hkmap",
      (char *)"hk", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"hkmapp",
      (char *)"hkp", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"hlsearch",
      (char *)"hls", (short_u )19457, (char_u *)(& p_hls), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"icon",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_icon), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"iconstring",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_iconstring), {(char_u *)"",
                                                                        (char_u *)0L}}, 
        {(char *)"ignorecase",
      (char *)"ic", (short_u )1025, (char_u *)(& p_ic), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"include",
      (char *)"inc", (short_u )1028, (char_u *)(& p_inc), {(char_u *)"^#\\s*include",
                                                           (char_u *)0L}}, 
        {(char *)"incsearch", (char *)"is", (short_u )3073, (char_u *)(& p_is), {(char_u *)0,
                                                                              (char_u *)0L}}, 
        {(char *)"infercase",
      (char *)"inf", (short_u )1057, (char_u *)15, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"insertmode", (char *)"im", (short_u )3073, (char_u *)(& p_im), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"isfname",
      (char *)"isf", (short_u )33796, (char_u *)(& p_isf), {(char_u *)"@,48-57,/,.,-,_,+,,,$,~",
                                                            (char_u *)0L}}, 
        {(char *)"isident", (char *)"isi", (short_u )33796, (char_u *)(& p_isi), {(char_u *)"@,48-57,_,192-255",
                                                                               (char_u *)0L}}, 
        {(char *)"iskeyword",
      (char *)"isk", (short_u )34860, (char_u *)16, {(char_u *)"@,48-57,_", (char_u *)"@,48-57,_,192-255"}}, 
        {(char *)"isprint",
      (char *)"isp", (short_u )50180, (char_u *)(& p_isp), {(char_u *)"@,161-255",
                                                            (char_u *)0L}}, 
        {(char *)"joinspaces", (char *)"js", (short_u )3073, (char_u *)(& p_js), {(char_u *)1,
                                                                               (char_u *)0L}}, 
        {(char *)"key",
      (char *)((void *)0), (short_u )1580, (char_u *)17, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"keymodel",
      (char *)"km", (short_u )33796, (char_u *)(& p_km), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"keywordprg",
      (char *)"kp", (short_u )1044, (char_u *)(& p_kp), {(char_u *)"man -s", (char_u *)0L}}, 
        {(char *)"langmap",
      (char *)"lmap", (short_u )33796, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                               (char_u *)0L}}, 
        {(char *)"laststatus", (char *)"ls", (short_u )17410, (char_u *)(& p_ls), {(char_u *)1L,
                                                                                (char_u *)0L}}, 
        {(char *)"lazyredraw",
      (char *)"lz", (short_u )1025, (char_u *)(& p_lz), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"linebreak",
      (char *)"lbr", (short_u )9249, (char_u *)18, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"lines", (char *)((void *)0), (short_u )30274, (char_u *)(& Rows), {(char_u *)24L,
                                                                                  (char_u *)0L}}, 
        {(char *)"lisp",
      (char *)((void *)0), (short_u )1057, (char_u *)19, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"list",
      (char *)((void *)0), (short_u )9249, (char_u *)20, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"listchars",
      (char *)"lcs", (short_u )50180, (char_u *)(& p_lcs), {(char_u *)"eol:$", (char_u *)0L}}, 
        {(char *)"magic",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_magic), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"makeef",
      (char *)"mef", (short_u )1044, (char_u *)(& p_mef), {(char_u *)"/tmp/vim##.err",
                                                           (char_u *)0L}}, 
        {(char *)"makeprg", (char *)"mp", (short_u )1044, (char_u *)(& p_mp), {(char_u *)"make",
                                                                            (char_u *)0L}}, 
        {(char *)"matchpairs",
      (char *)"mps", (short_u )33836, (char_u *)22, {(char_u *)"(:),{:},[:]", (char_u *)0L}}, 
        {(char *)"matchtime",
      (char *)"mat", (short_u )1026, (char_u *)(& p_mat), {(char_u *)5L, (char_u *)0L}}, 
        {(char *)"maxfuncdepth",
      (char *)"mfd", (short_u )1026, (char_u *)(& p_mfd), {(char_u *)100L, (char_u *)0L}}, 
        {(char *)"maxmapdepth",
      (char *)"mmd", (short_u )1026, (char_u *)(& p_mmd), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"maxmem",
      (char *)"mm", (short_u )1026, (char_u *)(& p_mm), {(char_u *)5120, (char_u *)0L}}, 
        {(char *)"maxmemtot",
      (char *)"mmt", (short_u )1026, (char_u *)(& p_mmt), {(char_u *)10240, (char_u *)0L}}, 
        {(char *)"mesg",
      (char *)((void *)0), (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"modeline",
      (char *)"ml", (short_u )2081, (char_u *)21, {(char_u *)0, (char_u *)1}}, 
        {(char *)"modelines", (char *)"mls", (short_u )1026, (char_u *)(& p_mls), {(char_u *)5L,
                                                                                (char_u *)0L}}, 
        {(char *)"modified",
      (char *)"mod", (short_u )5665, (char_u *)23, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"more", (char *)((void *)0), (short_u )2049, (char_u *)(& p_more), {(char_u *)0,
                                                                                  (char_u *)1}}, 
        {(char *)"mouse",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_mouse), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"mousefocus",
      (char *)"mousef", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"mousehide",
      (char *)"mh", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"mousemodel",
      (char *)"mousem", (short_u )1028, (char_u *)(& p_mousem), {(char_u *)"extend",
                                                                 (char_u *)0L}}, 
        {(char *)"mousetime", (char *)"mouset", (short_u )1026, (char_u *)(& p_mouset),
      {(char_u *)500L, (char_u *)0L}}, 
        {(char *)"novice", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"nrformats", (char *)"nf", (short_u )33836, (char_u *)24, {(char_u *)"octal,hex",
                                                                         (char_u *)0L}}, 
        {(char *)"number",
      (char *)"nu", (short_u )9249, (char_u *)25, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"open", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"optimize", (char *)"opt", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                                 (char_u *)0L}}, 
        {(char *)"osfiletype",
      (char *)"oft", (short_u )1068, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"paragraphs",
      (char *)"para", (short_u )1028, (char_u *)(& p_para), {(char_u *)"IPLPPPQPP LIpplpipbp",
                                                             (char_u *)0L}}, 
        {(char *)"paste", (char *)((void *)0), (short_u )1025, (char_u *)(& p_paste),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"pastetoggle", (char *)"pt", (short_u )1028, (char_u *)(& p_pt), {(char_u *)"",
                                                                                (char_u *)0L}}, 
        {(char *)"patchmode",
      (char *)"pm", (short_u )1028, (char_u *)(& p_pm), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"path",
      (char *)"pa", (short_u )33812, (char_u *)(& p_path), {(char_u *)".,/usr/include,,",
                                                            (char_u *)0L}}, 
        {(char *)"previewheight", (char *)"pvh", (short_u )1026, (char_u *)(& p_pvh),
      {(char_u *)12L, (char_u *)0L}}, 
        {(char *)"prompt", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"readonly", (char *)"ro", (short_u )5153, (char_u *)28, {(char_u *)0,
                                                                       (char_u *)0L}}, 
        {(char *)"redraw",
      (char *)((void *)0), (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"remap",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_remap), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"report",
      (char *)((void *)0), (short_u )1026, (char_u *)(& p_report), {(char_u *)2L,
                                                                    (char_u *)0L}}, 
        {(char *)"restorescreen",
      (char *)"rs", (short_u )1025, (char_u *)((void *)0), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"revins",
      (char *)"ri", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"rightleft",
      (char *)"rl", (short_u )9249, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"ruler",
      (char *)"ru", (short_u )7169, (char_u *)(& p_ru), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"rulerformat",
      (char *)"ruf", (short_u )5132, (char_u *)(& p_ruf), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"scroll",
      (char *)"scr", (short_u )1570, (char_u *)29, {(char_u *)12L, (char_u *)0L}}, 
        {(char *)"scrollbind",
      (char *)"scb", (short_u )1057, (char_u *)35, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"scrolljump", (char *)"sj", (short_u )3074, (char_u *)(& p_sj), {(char_u *)1L,
                                                                               (char_u *)0L}}, 
        {(char *)"scrolloff",
      (char *)"so", (short_u )19458, (char_u *)(& p_so), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"scrollopt",
      (char *)"sbo", (short_u )33796, (char_u *)(& p_sbo), {(char_u *)"ver,jump",
                                                            (char_u *)0L}}, 
        {(char *)"sections", (char *)"sect", (short_u )1028, (char_u *)(& p_sections),
      {(char_u *)"SHNHH HUnhsh", (char_u *)0L}}, 
        {(char *)"secure", (char *)((void *)0), (short_u )1025, (char_u *)(& p_secure),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"selection", (char *)"sel", (short_u )1028, (char_u *)(& p_sel), {(char_u *)"inclusive",
                                                                                (char_u *)0L}}, 
        {(char *)"selectmode",
      (char *)"slm", (short_u )33796, (char_u *)(& p_slm), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"sessionoptions",
      (char *)"ssop", (short_u )33796, (char_u *)(& p_sessopt), {(char_u *)"buffers,winsize,options,help,blank",
                                                                 (char_u *)0L}}, 
        {(char *)"shell", (char *)"sh", (short_u )1044, (char_u *)(& p_sh), {(char_u *)"sh",
                                                                          (char_u *)0L}}, 
        {(char *)"shellcmdflag",
      (char *)"shcf", (short_u )1028, (char_u *)(& p_shcf), {(char_u *)"-c", (char_u *)0L}}, 
        {(char *)"shellpipe",
      (char *)"sp", (short_u )1028, (char_u *)(& p_sp), {(char_u *)"| tee", (char_u *)0L}}, 
        {(char *)"shellquote",
      (char *)"shq", (short_u )1028, (char_u *)(& p_shq), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"shellredir",
      (char *)"srr", (short_u )1028, (char_u *)(& p_srr), {(char_u *)">", (char_u *)0L}}, 
        {(char *)"shellslash",
      (char *)"ssl", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"shelltype",
      (char *)"st", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"shellxquote",
      (char *)"sxq", (short_u )1028, (char_u *)(& p_sxq), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"shiftround",
      (char *)"sr", (short_u )3073, (char_u *)(& p_sr), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"shiftwidth",
      (char *)"sw", (short_u )1058, (char_u *)36, {(char_u *)8L, (char_u *)0L}}, 
        {(char *)"shortmess", (char *)"shm", (short_u )2052, (char_u *)(& p_shm), {(char_u *)"",
                                                                                (char_u *)"filnxtToO"}}, 
        {(char *)"shortname",
      (char *)"sn", (short_u )1057, (char_u *)31, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showbreak", (char *)"sbr", (short_u )17412, (char_u *)(& p_sbr), {(char_u *)"",
                                                                                 (char_u *)0L}}, 
        {(char *)"showcmd",
      (char *)"sc", (short_u )2049, (char_u *)(& p_sc), {(char_u *)0, (char_u *)0}}, 
        {(char *)"showfulltag",
      (char *)"sft", (short_u )1025, (char_u *)(& p_sft), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showmatch",
      (char *)"sm", (short_u )1025, (char_u *)(& p_sm), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showmode",
      (char *)"smd", (short_u )2049, (char_u *)(& p_smd), {(char_u *)0, (char_u *)1}}, 
        {(char *)"sidescroll",
      (char *)"ss", (short_u )1026, (char_u *)(& p_ss), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"slowopen",
      (char *)"slow", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smartcase",
      (char *)"scs", (short_u )3073, (char_u *)(& p_scs), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smartindent",
      (char *)"si", (short_u )3105, (char_u *)30, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smarttab", (char *)"sta", (short_u )3073, (char_u *)(& p_sta), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"softtabstop",
      (char *)"sts", (short_u )3106, (char_u *)32, {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"sourceany", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"splitbelow", (char *)"sb", (short_u )1025, (char_u *)(& p_sb), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"startofline",
      (char *)"sol", (short_u )3073, (char_u *)(& p_sol), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"statusline",
      (char *)"stl", (short_u )5132, (char_u *)(& p_stl), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"suffixes",
      (char *)"su", (short_u )33796, (char_u *)(& p_su), {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
                                                          (char_u *)0L}}, 
        {(char *)"swapfile", (char *)"swf", (short_u )5153, (char_u *)33, {(char_u *)1,
                                                                        (char_u *)0L}}, 
        {(char *)"swapsync",
      (char *)"sws", (short_u )1028, (char_u *)(& p_sws), {(char_u *)"fsync", (char_u *)0L}}, 
        {(char *)"switchbuf",
      (char *)"swb", (short_u )33796, (char_u *)(& p_swb), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"syntax",
      (char *)"syn", (short_u )1068, (char_u *)34, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"tabstop", (char *)"ts", (short_u )9250, (char_u *)37, {(char_u *)8L,
                                                                      (char_u *)0L}}, 
        {(char *)"tagbsearch",
      (char *)"tbs", (short_u )1025, (char_u *)(& p_tbs), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"taglength",
      (char *)"tl", (short_u )1026, (char_u *)(& p_tl), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"tagrelative",
      (char *)"tr", (short_u )2049, (char_u *)(& p_tr), {(char_u *)0, (char_u *)1}}, 
        {(char *)"tags",
      (char *)"tag", (short_u )33812, (char_u *)(& p_tags), {(char_u *)"./tags,tags",
                                                             (char_u *)0L}}, 
        {(char *)"tagstack", (char *)"tgst", (short_u )1025, (char_u *)(& p_tgst), {(char_u *)1,
                                                                                 (char_u *)0L}}, 
        {(char *)"term",
      (char *)((void *)0), (short_u )18004, (char_u *)(& term_strings[0]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"terse",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_terse), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"textauto",
      (char *)"ta", (short_u )2049, (char_u *)(& p_ta), {(char_u *)0, (char_u *)1}}, 
        {(char *)"textmode",
      (char *)"tx", (short_u )1569, (char_u *)39, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"textwidth", (char *)"tw", (short_u )3106, (char_u *)38, {(char_u *)0L,
                                                                        (char_u *)0L}}, 
        {(char *)"tildeop",
      (char *)"top", (short_u )3073, (char_u *)(& p_to), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"timeout",
      (char *)"to", (short_u )1025, (char_u *)(& p_timeout), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"timeoutlen",
      (char *)"tm", (short_u )1026, (char_u *)(& p_tm), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"title",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_title), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"titlelen",
      (char *)((void *)0), (short_u )1026, (char_u *)(& p_titlelen), {(char_u *)85L,
                                                                      (char_u *)0L}}, 
        {(char *)"titleold",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_titleold), {(char_u *)"Thanks for flying Vim",
                                                                      (char_u *)0L}}, 
        {(char *)"titlestring",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_titlestring), {(char_u *)"",
                                                                         (char_u *)0L}}, 
        {(char *)"ttimeout",
      (char *)((void *)0), (short_u )3073, (char_u *)(& p_ttimeout), {(char_u *)0,
                                                                      (char_u *)0L}}, 
        {(char *)"ttimeoutlen",
      (char *)"ttm", (short_u )1026, (char_u *)(& p_ttm), {(char_u *)-1L, (char_u *)0L}}, 
        {(char *)"ttybuiltin",
      (char *)"tbi", (short_u )1025, (char_u *)(& p_tbi), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"ttyfast",
      (char *)"tf", (short_u )1537, (char_u *)(& p_tf), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"ttymouse",
      (char *)"ttym", (short_u )1604, (char_u *)(& p_ttym), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"ttyscroll",
      (char *)"tsl", (short_u )1026, (char_u *)(& p_ttyscroll), {(char_u *)999L, (char_u *)0L}}, 
        {(char *)"ttytype",
      (char *)"tty", (short_u )18004, (char_u *)(& term_strings[0]), {(char_u *)"",
                                                                      (char_u *)0L}}, 
        {(char *)"undolevels",
      (char *)"ul", (short_u )1026, (char_u *)(& p_ul), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"updatecount",
      (char *)"uc", (short_u )1026, (char_u *)(& p_uc), {(char_u *)200L, (char_u *)0L}}, 
        {(char *)"updatetime",
      (char *)"ut", (short_u )1026, (char_u *)(& p_ut), {(char_u *)4000L, (char_u *)0L}}, 
        {(char *)"verbose",
      (char *)"vbs", (short_u )1026, (char_u *)(& p_verbose), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"viminfo",
      (char *)"vi", (short_u )33796, (char_u *)(& p_viminfo), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"visualbell",
      (char *)"vb", (short_u )1025, (char_u *)(& p_vb), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"w300",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"w1200",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"w9600",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"warn",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_warn), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"weirdinvert",
      (char *)"wiv", (short_u )29697, (char_u *)(& p_wiv), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"whichwrap",
      (char *)"ww", (short_u )34820, (char_u *)(& p_ww), {(char_u *)"", (char_u *)"b,s"}}, 
        {(char *)"wildchar",
      (char *)"wc", (short_u )2050, (char_u *)(& p_wc), {(char_u *)5L, (char_u *)((long )'\t')}}, 
        {(char *)"wildcharm",
      (char *)"wcm", (short_u )1026, (char_u *)(& p_wcm), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"wildignore",
      (char *)"wig", (short_u )33796, (char_u *)(& p_wig), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"wildmenu",
      (char *)"wmnu", (short_u )1025, (char_u *)(& p_wmnu), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"wildmode",
      (char *)"wim", (short_u )33796, (char_u *)(& p_wim), {(char_u *)"full", (char_u *)0L}}, 
        {(char *)"winaltkeys",
      (char *)"wak", (short_u )1028, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                             (char_u *)0L}}, 
        {(char *)"window", (char *)"wi", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L,
                                                                              (char_u *)0L}}, 
        {(char *)"winheight",
      (char *)"wh", (short_u )1026, (char_u *)(& p_wh), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"winminheight",
      (char *)"wmh", (short_u )1026, (char_u *)(& p_wmh), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"wrap",
      (char *)((void *)0), (short_u )9249, (char_u *)41, {(char_u *)1, (char_u *)0L}}, 
        {(char *)"wrapmargin",
      (char *)"wm", (short_u )1058, (char_u *)40, {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"wrapscan", (char *)"ws", (short_u )1025, (char_u *)(& p_ws), {(char_u *)1,
                                                                             (char_u *)0L}}, 
        {(char *)"write",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_write), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"writeany",
      (char *)"wa", (short_u )1025, (char_u *)(& p_wa), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"writebackup",
      (char *)"wb", (short_u )3073, (char_u *)(& p_wb), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"writedelay",
      (char *)"wd", (short_u )1026, (char_u *)(& p_wd), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"t_AB",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[40]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_AF",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[39]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_AL",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[3]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_al",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[2]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_bc",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[32]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_cd",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[8]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_ce",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[1]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_cl",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[7]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_cm",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[24]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Co",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[34]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_CS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[33]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_cs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[6]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_da",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[9]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_db",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[10]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_DL",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[5]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_dl",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[4]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_fs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[46]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_IE",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[44]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_IS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[43]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ke",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[29]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ks",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[28]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_le",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[41]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_mb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[38]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_md",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[16]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_me",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[14]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_mr",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[15]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ms",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[23]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_nd",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[42]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_op",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[50]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_RI",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[26]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_RV",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[49]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Sb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[36]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Sf",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[35]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_se",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[17]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_so",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[18]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_sr",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[25]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ts",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[45]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_te",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[31]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ti",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[30]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ue",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[21]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_us",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[22]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[27]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ve",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[12]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vi",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[11]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[13]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_WP",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[47]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_WS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[48]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_xs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[37]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ZH",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[19]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ZR",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[20]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)((void *)0),
      (char *)((void *)0), (short_u )0, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                                (char_u *)((void *)0)}}};
static char *p_bg_values[3]  = {      (char *)"light",      (char *)"dark",      (char *)((void *)0)};
static char *p_nf_values[3]  = {      (char *)"octal",      (char *)"hex",      (char *)((void *)0)};
static char *p_ff_values[4]  = {      (char *)"unix",      (char *)"dos",      (char *)"mac",      (char *)((void *)0)};
static char *p_sessopt_values[11]  = 
  {      (char *)"buffers",      (char *)"winpos",      (char *)"resize",      (char *)"winsize", 
        (char *)"options",      (char *)"help",      (char *)"blank",      (char *)"globals", 
        (char *)"slash",      (char *)"unix",      (char *)((void *)0)};
static char *p_mousem_values[5]  = {      (char *)"extend",      (char *)"popup",      (char *)"popup_setpos",      (char *)"mac", 
        (char *)((void *)0)};
static char *p_slm_values[4]  = {      (char *)"mouse",      (char *)"key",      (char *)"cmd",      (char *)((void *)0)};
static char *p_sel_values[4]  = {      (char *)"inclusive",      (char *)"exclusive",      (char *)"old",      (char *)((void *)0)};
static char *p_ttym_values[5]  = {      (char *)"xterm",      (char *)"xterm2",      (char *)"dec",      (char *)"netterm", 
        (char *)((void *)0)};
static char *p_km_values[3]  = {      (char *)"startsel",      (char *)"stopsel",      (char *)((void *)0)};
static char *p_bsdir_values[4]  = {      (char *)"current",      (char *)"last",      (char *)"buffer",      (char *)((void *)0)};
static char *p_scbopt_values[4]  = {      (char *)"ver",      (char *)"hor",      (char *)"jump",      (char *)((void *)0)};
static char *p_swb_values[3]  = {      (char *)"useopen",      (char *)"split",      (char *)((void *)0)};
static char *p_dy_values[2]  = {      (char *)"lastline",      (char *)((void *)0)};
static char *p_cb_values[3]  = {      (char *)"unnamed",      (char *)"autoselect",      (char *)((void *)0)};
static char *p_bs_values[4]  = {      (char *)"indent",      (char *)"eol",      (char *)"start",      (char *)((void *)0)};
static void set_option_default(int opt_idx , int dofree ) ;
static void set_options_default(int dofree ) ;
static char_u *illegal_char(char_u *errbuf___0 , int c ) ;
static void did_set_title(int icon ) ;
static char_u *option_expand(int opt_idx ) ;
static void set_string_option(int opt_idx , char_u *value ) ;
static char_u *did_set_string_option(int opt_idx , char_u **varp , int new_value_alloced ,
                                     char_u *oldval , char_u *errbuf___0 ) ;
static char_u *set_bool_option(int opt_idx , char_u *varp , int value ) ;
static char_u *set_num_option(int opt_idx , char_u *varp , long value , char_u *errbuf___0 ) ;
static void check_redraw(int flags___0 ) ;
static int findoption(char_u *arg ) ;
static int find_key_option(char_u *arg ) ;
static void showoptions(int all ) ;
static int option_not_default(struct vimoption *p___0 ) ;
static void showoneopt(struct vimoption *p___0 ) ;
static int istermoption(struct vimoption *p___0 ) ;
static char_u *get_varp(struct vimoption *p___0 ) ;
static void option_value2string(struct vimoption *opp ) ;
static void paste_option_changed(void) ;
static void compatible_set(void) ;
static void fill_breakat_flags(void) ;
static int check_opt_strings(char_u *val , char **values , int list ) ;
static int check_opt_wim(void) ;
void set_init_1(void) 
{ 
  char_u *p___0 ;
  int opt_idx ;
  long n ;
  char *tmp ;
  int tmp___0 ;

  {
  {
  p_cp = 1;
  tmp = getenv((char const   *)((char *)((char_u *)"SHELL")));
  p___0 = (char_u *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    set_string_default((char *)"sh", p___0);
    }
  }
  {
  opt_idx = findoption((char_u *)"maxmemtot");
  }
  if ((unsigned long )options[opt_idx].def_val[0] == (unsigned long )((char_u *)0L)) {
    {
    n = (long )(2147483647 >> 11);
    options[opt_idx].def_val[0] = (char_u *)n;
    opt_idx = findoption((char_u *)"maxmem");
    }
    if ((long )options[opt_idx].def_val[0] > n) {
      options[opt_idx].def_val[0] = (char_u *)n;
    } else { //Added block
    if ((long )options[opt_idx].def_val[0] == 0L) {
      options[opt_idx].def_val[0] = (char_u *)n;
    }
    }
  }
  {
  set_options_default(0);
  curbuf->b_p_initialized = 1;
  check_buf_options(curbuf);
  check_options();
  init_chartab();
  fill_breakat_flags();
  opt_idx = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = istermoption(& options[opt_idx]);
    }
    if (tmp___0) {
      goto while_break;
    }
    {
    p___0 = option_expand(opt_idx);
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      *((char_u **)options[opt_idx].var) = p___0;
      options[opt_idx].def_val[0] = p___0;
      options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 128);
    }
    opt_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  highlight_changed();
  curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
  check_opt_wim();
  }
  return;
}
}
static void set_option_default(int opt_idx , int dofree ) 
{ 
  char_u *varp ;
  int dvi ;
  int flags___0 ;

  {
  {
  varp = get_varp(& options[opt_idx]);
  flags___0 = (int )options[opt_idx].flags;
  }
  if ((unsigned long )varp != (unsigned long )((void *)0)) {
    if (flags___0 & 1024) {
      dvi = 0;
    } else { //Added block
    if (p_cp) {
      dvi = 0;
    } else {
      dvi = 1;
    }
    }
    if (flags___0 & 4) {
      if (flags___0 & 32) {
        {
        set_string_option_direct((char_u *)((void *)0), opt_idx, options[opt_idx].def_val[dvi],
                                 dofree);
        }
      } else {
        if (dofree) {
          if (flags___0 & 8) {
            {
            free_string_option(*((char_u **)varp));
            }
          }
        }
        *((char_u **)varp) = options[opt_idx].def_val[dvi];
        options[opt_idx].flags = (short_u )((int )options[opt_idx].flags & -9);
      }
    } else { //Added block
    if (flags___0 & 2) {
      if ((unsigned long )varp == (unsigned long )((char_u *)29)) {
        {
        win_comp_scroll(curwin);
        }
      } else {
        *((long *)varp) = (long )options[opt_idx].def_val[dvi];
      }
    } else {
      *((int *)varp) = (int )((long )options[opt_idx].def_val[dvi]);
    }
    }
  }
  return;
}
}
static void set_options_default(int dofree ) 
{ 
  int i___0 ;
  WIN *wp ;
  int tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = istermoption(& options[i___0]);
    }
    if (tmp) {
      goto while_break;
    }
    if (! ((int )options[i___0].flags & 64)) {
      {
      set_option_default(i___0, dofree);
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  wp = firstwin;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    win_comp_scroll(wp);
    wp = wp->w_next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
void set_string_default(char *name___1 , char_u *val ) 
{ 
  char_u *p___0 ;
  int opt_idx ;

  {
  {
  p___0 = vim_strsave(val);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    opt_idx = findoption((char_u *)name___1);
    }
    if ((int )options[opt_idx].flags & 128) {
      {
      vim_free((void *)options[opt_idx].def_val[0]);
      }
    }
    options[opt_idx].def_val[0] = p___0;
    options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 128);
  }
  return;
}
}
void set_number_default(char *name___1 , long val ) 
{ 
  int tmp ;

  {
  {
  tmp = findoption((char_u *)name___1);
  options[tmp].def_val[0] = (char_u *)val;
  }
  return;
}
}
void set_init_2(void) 
{ 
  int tmp ;
  int idx4 ;
  int tmp___0 ;

  {
  {
  tmp = findoption((char_u *)"scroll");
  options[tmp].def_val[0] = (char_u *)((long_u )Rows >> 1);
  comp_col();
  idx4 = findoption((char_u *)"bg");
  }
  if (! ((int )options[idx4].flags & 256)) {
    {
    tmp___0 = strcmp((char const   *)((char *)term_strings[0]), (char const   *)((char *)"linux"));
    }
    if (tmp___0 == 0) {
      {
      set_string_option_direct((char_u *)((void *)0), idx4, (char_u *)"dark", 1);
      }
    }
  }
  return;
}
}
void set_init_3(void) 
{ 
  char_u *p___0 ;
  int idx_srr ;
  int do_srr ;
  int idx_sp ;
  int do_sp ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  idx_srr = findoption((char_u *)"srr");
  do_srr = ! ((int )options[idx_srr].flags & 256);
  idx_sp = findoption((char_u *)"sp");
  do_sp = ! ((int )options[idx_sp].flags & 256);
  p___0 = gettail(p_sh);
  tmp = skiptowhite(p___0);
  p___0 = vim_strnsave(p___0, (int )(tmp - p___0));
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp___4 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"csh"));
    }
    if (tmp___4 == 0) {
      goto _L___0;
    } else {
      {
      tmp___5 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"tcsh"));
      }
      if (tmp___5 == 0) {
        _L___0: 
        if (do_sp) {
          p_sp = (char_u *)"|& tee";
          options[idx_sp].def_val[0] = p_sp;
        }
        if (do_srr) {
          p_srr = (char_u *)">&";
          options[idx_srr].def_val[0] = p_srr;
        }
      } else {
        {
        tmp___0 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"sh"));
        }
        if (tmp___0 == 0) {
          goto _L;
        } else {
          {
          tmp___1 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"ksh"));
          }
          if (tmp___1 == 0) {
            goto _L;
          } else {
            {
            tmp___2 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"zsh"));
            }
            if (tmp___2 == 0) {
              goto _L;
            } else {
              {
              tmp___3 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"bash"));
              }
              if (tmp___3 == 0) {
                _L: 
                if (do_sp) {
                  p_sp = (char_u *)"2>&1| tee";
                  options[idx_sp].def_val[0] = p_sp;
                }
                if (do_srr) {
                  p_srr = (char_u *)">%s 2>&1";
                  options[idx_srr].def_val[0] = p_srr;
                }
              }
            }
          }
        }
      }
    }
    {
    vim_free((void *)p___0);
    }
  }
  {
  set_title_defaults();
  }
  return;
}
}
void set_title_defaults(void) 
{ 
  int idx1 ;
  long val ;
  int tmp ;
  int tmp___0 ;

  {
  {
  idx1 = findoption((char_u *)"title");
  }
  if (! ((int )options[idx1].flags & 256)) {
    {
    tmp = mch_can_restore_title();
    val = (long )tmp;
    options[idx1].def_val[0] = (char_u *)val;
    p_title = (int )val;
    }
  }
  {
  idx1 = findoption((char_u *)"icon");
  }
  if (! ((int )options[idx1].flags & 256)) {
    {
    tmp___0 = mch_can_restore_icon();
    val = (long )tmp___0;
    options[idx1].def_val[0] = (char_u *)val;
    p_icon = (int )val;
    }
  }
  return;
}
}
int do_set(char_u *arg , int modeline ) 
{ 
  int opt_idx ;
  char_u *errmsg ;
  char_u errbuf___0[80] ;
  char_u *startarg ;
  int prefix ;
  int nextchar ;
  int afterchar ;
  int len___0 ;
  int i___0 ;
  long value ;
  int key ;
  int flags___0 ;
  char_u *varp ;
  int did_show ;
  int adding ;
  int prepending ;
  int removing ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u name___1[2] ;
  char_u *p___0 ;
  char_u *tmp___5 ;
  long temp ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char_u *save_arg ;
  char_u *s ;
  char_u *oldval ;
  char_u *newval ;
  unsigned int newlen ;
  int comma ;
  int bs ;
  int new_value_alloced ;
  long tmp___11 ;
  size_t tmp___12 ;
  unsigned short const   **tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char_u *tmp___16 ;
  char_u *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  char_u name___2[2] ;
  char_u *p___1 ;
  int tmp___26 ;
  char_u *tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  unsigned short const   **tmp___31 ;
  char_u *tmp___32 ;
  char_u *tmp___33 ;

  {
  varp = (char_u *)((void *)0);
  did_show = 0;
  if ((int )*arg == 0) {
    {
    showoptions(0);
    }
    return (1);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *arg) {
      goto while_break;
    }
    {
    errmsg = (char_u *)((void *)0);
    startarg = arg;
    tmp___30 = strncmp((char const   *)((char *)arg), (char const   *)((char *)"all"),
                       (size_t )3);
    }
    if (tmp___30 == 0) {
      {
      tmp___31 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___31 + (int )*(arg + 3)) & 1024) {
        goto _L___19;
      } else {
        arg += 3;
        if ((int )*arg == 38) {
          {
          arg ++;
          set_options_default(1);
          }
        } else {
          {
          showoptions(1);
          }
        }
      }
    } else {
      _L___19: 
      {
      tmp___29 = strncmp((char const   *)((char *)arg), (char const   *)((char *)"termcap"),
                         (size_t )7);
      }
      if (tmp___29 == 0) {
        {
        showoptions(2);
        show_termcodes();
        arg += 7;
        }
      } else {
        {
        prefix = 1;
        tmp___0 = strncmp((char const   *)((char *)arg), (char const   *)((char *)"no"),
                          (size_t )2);
        }
        if (tmp___0 == 0) {
          prefix = 0;
          arg += 2;
        } else {
          {
          tmp = strncmp((char const   *)((char *)arg), (char const   *)((char *)"inv"),
                        (size_t )3);
          }
          if (tmp == 0) {
            prefix = 2;
            arg += 3;
          }
        }
        key = 0;
        if ((int )*arg == 60) {
          opt_idx = -1;
          if ((int )*(arg + 1) == 116) {
            if ((int )*(arg + 2) == 95) {
              if (*(arg + 3)) {
                if (*(arg + 4)) {
                  len___0 = 5;
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            len___0 = 1;
            {
            while (1) {
              while_continue___0: /* CIL Label */ ;
              if ((int )*(arg + len___0) != 0) {
                if (! ((int )*(arg + len___0) != 62)) {
                  goto while_break___0;
                }
              } else {
                goto while_break___0;
              }
              len___0 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          if ((int )*(arg + len___0) != 62) {
            errmsg = e_invarg;
            goto skip;
          }
          *(arg + len___0) = (char_u )'\000';
          if ((int )*(arg + 1) == 116) {
            if ((int )*(arg + 2) == 95) {
              {
              opt_idx = findoption(arg + 1);
              }
            }
          }
          tmp___1 = len___0;
          len___0 ++;
          *(arg + tmp___1) = (char_u )'>';
          if (opt_idx == -1) {
            {
            key = find_key_option(arg + 1);
            }
          }
        } else {
          len___0 = 0;
          if ((int )*(arg + 0) == 116) {
            if ((int )*(arg + 1) == 95) {
              if (*(arg + 2)) {
                if (*(arg + 3)) {
                  len___0 = 4;
                } else {
                  goto _L___4;
                }
              } else {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            _L___4: 
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
              tmp___2 = __ctype_b_loc();
              }
              if (! ((int const   )*(*tmp___2 + (int )*(arg + len___0)) & 8)) {
                if (! ((int )*(arg + len___0) == 95)) {
                  goto while_break___1;
                }
              }
              len___0 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
          {
          nextchar = (int )*(arg + len___0);
          *(arg + len___0) = (char_u )'\000';
          opt_idx = findoption(arg);
          *(arg + len___0) = (char_u )nextchar;
          }
          if (opt_idx == -1) {
            {
            key = find_key_option(arg);
            }
          }
        }
        if (opt_idx == -1) {
          if (key == 0) {
            errmsg = (char_u *)"Unknown option";
            goto skip;
          }
        }
        if (opt_idx >= 0) {
          if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
            goto skip;
          }
          {
          flags___0 = (int )options[opt_idx].flags;
          varp = get_varp(& options[opt_idx]);
          }
        } else {
          flags___0 = 4;
        }
        if (modeline) {
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_exrc))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          } else { //Added block
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_secure))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          } else { //Added block
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_shcf))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          } else { //Added block
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_sp))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          } else { //Added block
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_shq))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          } else { //Added block
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_srr))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          } else { //Added block
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_sxq))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          } else { //Added block
          if ((unsigned long )varp == (unsigned long )((char_u *)(& p_sh))) {
            errmsg = (char_u *)"Not allowed in a modeline";
            goto skip;
          }
          }
          }
          }
          }
          }
          }
          }
          if (p_secure) {
            if ((unsigned long )varp == (unsigned long )((char_u *)(& p_ep))) {
              {
              smsg((char_u *)"Warning: %s option changed from modeline", options[opt_idx].fullname);
              }
            } else { //Added block
            if ((unsigned long )varp == (unsigned long )((char_u *)(& p_fp))) {
              {
              smsg((char_u *)"Warning: %s option changed from modeline", options[opt_idx].fullname);
              }
            } else { //Added block
            if ((unsigned long )varp == (unsigned long )((char_u *)(& p_mp))) {
              {
              smsg((char_u *)"Warning: %s option changed from modeline", options[opt_idx].fullname);
              }
            } else { //Added block
            if ((unsigned long )varp == (unsigned long )((char_u *)(& p_gp))) {
              {
              smsg((char_u *)"Warning: %s option changed from modeline", options[opt_idx].fullname);
              }
            } else { //Added block
            if ((unsigned long )varp == (unsigned long )((char_u *)(& p_kp))) {
              {
              smsg((char_u *)"Warning: %s option changed from modeline", options[opt_idx].fullname);
              }
            }
            }
            }
            }
            }
          }
        }
        afterchar = (int )*(arg + len___0);
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! ((int )*(arg + len___0) == 32)) {
            if (! ((int )*(arg + len___0) == 9)) {
              goto while_break___2;
            }
          }
          len___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        adding = 0;
        prepending = 0;
        removing = 0;
        if ((int )*(arg + len___0) == 43) {
          if ((int )*(arg + (len___0 + 1)) == 61) {
            adding = 1;
            len___0 ++;
          } else {
            goto _L___6;
          }
        } else { //Added block
        _L___6: 
        if ((int )*(arg + len___0) == 94) {
          if ((int )*(arg + (len___0 + 1)) == 61) {
            prepending = 1;
            len___0 ++;
          } else {
            goto _L___5;
          }
        } else { //Added block
        _L___5: 
        if ((int )*(arg + len___0) == 45) {
          if ((int )*(arg + (len___0 + 1)) == 61) {
            removing = 1;
            len___0 ++;
          }
        }
        }
        }
        {
        nextchar = (int )*(arg + len___0);
        tmp___4 = vim_strchr((char_u *)"?=:!&", nextchar);
        }
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
          {
          arg += len___0;
          len___0 = 0;
          tmp___3 = vim_strchr((char_u *)"?!&", nextchar);
          }
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            if ((int )*(arg + 1) != 0) {
              if (! ((int )*(arg + 1) == 32)) {
                if (! ((int )*(arg + 1) == 9)) {
                  errmsg = e_trailing;
                  goto skip;
                }
              }
            }
          }
        }
        if (nextchar == 63) {
          goto _L___16;
        } else { //Added block
        if (prefix == 1) {
          {
          tmp___27 = vim_strchr((char_u *)"=:&", nextchar);
          }
          if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
            if (! (flags___0 & 1)) {
              _L___16: 
              if (did_show) {
                {
                msg_putchar('\n');
                }
              } else {
                {
                gotocmdline(1);
                did_show = 1;
                }
              }
              if (opt_idx >= 0) {
                {
                showoneopt(& options[opt_idx]);
                }
              } else {
                {
                name___1[0] = (char_u )(key & 255);
                name___1[1] = (char_u )(((unsigned int )key >> 8) & 255U);
                p___0 = find_termcode(name___1);
                }
                if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
                  errmsg = (char_u *)"Unknown option";
                  goto skip;
                } else {
                  {
                  show_one_termcode(name___1, p___0, 1);
                  }
                }
              }
              if (nextchar != 63) {
                if (nextchar != 0) {
                  if (! (afterchar == 32)) {
                    if (! (afterchar == 9)) {
                      errmsg = e_trailing;
                    }
                  }
                }
              }
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
          if (flags___0 & 1) {
            if (nextchar == 61) {
              errmsg = e_invarg;
              goto skip;
            } else { //Added block
            if (nextchar == 58) {
              errmsg = e_invarg;
              goto skip;
            }
            }
            if (nextchar == 33) {
              value = (long )(*((int *)varp) ^ 1);
            } else { //Added block
            if (nextchar == 38) {
              {
              i___0 = *((int *)varp);
              set_option_default(opt_idx, 0);
              value = (long )*((int *)varp);
              *((int *)varp) = i___0;
              }
            } else {
              if (nextchar != 0) {
                if (! (afterchar == 32)) {
                  if (! (afterchar == 9)) {
                    errmsg = e_trailing;
                    goto skip;
                  }
                }
              }
              if (prefix == 2) {
                value = (long )(*((int *)varp) ^ 1);
              } else {
                value = (long )prefix;
              }
            }
            }
            {
            errmsg = set_bool_option(opt_idx, varp, (int )value);
            }
          } else {
            {
            tmp___5 = vim_strchr((char_u *)"=:&", nextchar);
            }
            if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
              errmsg = e_invarg;
              goto skip;
            } else { //Added block
            if (prefix != 1) {
              errmsg = e_invarg;
              goto skip;
            }
            }
            if (flags___0 & 2) {
              arg += len___0 + 1;
              if (nextchar == 38) {
                {
                temp = *((long *)varp);
                set_option_default(opt_idx, 0);
                value = *((long *)varp);
                *((long *)varp) = temp;
                }
              } else { //Added block
              if ((unsigned long )((long *)varp) == (unsigned long )(& p_wc)) {
                goto _L___12;
              } else { //Added block
              if ((unsigned long )((long *)varp) == (unsigned long )(& p_wcm)) {
                _L___12: 
                if ((int )*arg == 60) {
                  goto _L___9;
                } else { //Added block
                if ((int )*arg == 94) {
                  goto _L___9;
                } else { //Added block
                if (! *(arg + 1)) {
                  goto _L___11;
                } else { //Added block
                if ((int )*(arg + 1) == 32) {
                  goto _L___11;
                } else { //Added block
                if ((int )*(arg + 1) == 9) {
                  _L___11: 
                  {
                  tmp___10 = __ctype_b_loc();
                  }
                  if ((int const   )*(*tmp___10 + (int )*arg) & 2048) {
                    goto _L___8;
                  } else {
                    _L___9: 
                    if ((int )*arg == 60) {
                      {
                      tmp___6 = find_key_option(arg + 1);
                      value = (long )tmp___6;
                      }
                    } else { //Added block
                    if ((int )*arg == 94) {
                      value = (long )((int )*(arg + 1) ^ 64);
                    } else {
                      value = (long )*arg;
                    }
                    }
                    if (value == 0L) {
                      if ((unsigned long )((long *)varp) != (unsigned long )(& p_wcm)) {
                        errmsg = e_invarg;
                        goto skip;
                      }
                    }
                  }
                } else {
                  goto _L___8;
                }
                }
                }
                }
                }
              } else { //Added block
              _L___8: 
              if ((int )*arg == 45) {
                goto _L___7;
              } else {
                {
                tmp___9 = __ctype_b_loc();
                }
                if ((int const   )*(*tmp___9 + (int )*arg) & 2048) {
                  _L___7: 
                  i___0 = 0;
                  if ((int )*arg == 45) {
                    i___0 = 1;
                  }
                  {
                  value = strtol((char const   * __restrict  )((char *)arg), (char ** __restrict  )((void *)0),
                                 0);
                  }
                  if ((int )*(arg + i___0) == 48) {
                    {
                    tmp___7 = tolower((int )*(arg + (i___0 + 1)));
                    }
                    if (tmp___7 == 120) {
                      i___0 += 2;
                    }
                  }
                  {
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
                    {
                    tmp___8 = __ctype_b_loc();
                    }
                    if (! ((int const   )*(*tmp___8 + (int )*(arg + i___0)) & 2048)) {
                      goto while_break___3;
                    }
                    i___0 ++;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                  if ((int )*(arg + i___0) != 0) {
                    if (! ((int )*(arg + i___0) == 32)) {
                      if (! ((int )*(arg + i___0) == 9)) {
                        errmsg = e_invarg;
                        goto skip;
                      }
                    }
                  }
                } else {
                  errmsg = (char_u *)"Number required after =";
                  goto skip;
                }
              }
              }
              }
              }
              if (adding) {
                value = *((long *)varp) + value;
              }
              if (prepending) {
                value = *((long *)varp) * value;
              }
              if (removing) {
                value = *((long *)varp) - value;
              }
              {
              errmsg = set_num_option(opt_idx, varp, value, errbuf___0);
              }
            } else { //Added block
            if (opt_idx >= 0) {
              save_arg = (char_u *)((void *)0);
              oldval = *((char_u **)varp);
              if (nextchar == 38) {
                {
                set_option_default(opt_idx, 0);
                new_value_alloced = (int )options[opt_idx].flags & 8;
                options[opt_idx].flags = (short_u )flags___0;
                }
              } else {
                arg += len___0 + 1;
                if ((unsigned long )varp == (unsigned long )((char_u *)(& p_ww))) {
                  {
                  tmp___13 = __ctype_b_loc();
                  }
                  if ((int const   )*(*tmp___13 + (int )*arg) & 2048) {
                    {
                    errbuf___0[0] = (char_u )'\000';
                    tmp___11 = getdigits(& arg);
                    i___0 = (int )tmp___11;
                    }
                    if (i___0 & 1) {
                      {
                      strcat((char * __restrict  )((char *)(errbuf___0)), (char const   * __restrict  )((char *)"b,"));
                      }
                    }
                    if (i___0 & 2) {
                      {
                      strcat((char * __restrict  )((char *)(errbuf___0)), (char const   * __restrict  )((char *)"s,"));
                      }
                    }
                    if (i___0 & 4) {
                      {
                      strcat((char * __restrict  )((char *)(errbuf___0)), (char const   * __restrict  )((char *)"h,l,"));
                      }
                    }
                    if (i___0 & 8) {
                      {
                      strcat((char * __restrict  )((char *)(errbuf___0)), (char const   * __restrict  )((char *)"<,>,"));
                      }
                    }
                    if (i___0 & 16) {
                      {
                      strcat((char * __restrict  )((char *)(errbuf___0)), (char const   * __restrict  )((char *)"[,],"));
                      }
                    }
                    if ((int )errbuf___0[0] != 0) {
                      {
                      tmp___12 = strlen((char const   *)((char *)(errbuf___0)));
                      errbuf___0[tmp___12 - 1UL] = (char_u )'\000';
                      }
                    }
                    save_arg = arg;
                    arg = errbuf___0;
                  } else {
                    goto _L___13;
                  }
                } else { //Added block
                _L___13: 
                if ((int )*arg == 62) {
                  if ((unsigned long )varp == (unsigned long )((char_u *)(& p_dir))) {
                    arg ++;
                  } else { //Added block
                  if ((unsigned long )varp == (unsigned long )((char_u *)(& p_bdir))) {
                    arg ++;
                  }
                  }
                }
                }
                {
                tmp___14 = strlen((char const   *)((char *)arg));
                newlen = (unsigned int )(tmp___14 + 1UL);
                }
                if (adding) {
                  {
                  tmp___15 = strlen((char const   *)((char *)oldval));
                  newlen = (unsigned int )((size_t )newlen + (tmp___15 + 1UL));
                  }
                } else { //Added block
                if (prepending) {
                  {
                  tmp___15 = strlen((char const   *)((char *)oldval));
                  newlen = (unsigned int )((size_t )newlen + (tmp___15 + 1UL));
                  }
                } else { //Added block
                if (removing) {
                  {
                  tmp___15 = strlen((char const   *)((char *)oldval));
                  newlen = (unsigned int )((size_t )newlen + (tmp___15 + 1UL));
                  }
                }
                }
                }
                {
                newval = alloc(newlen);
                }
                if ((unsigned long )newval == (unsigned long )((void *)0)) {
                  goto while_break;
                }
                s = newval;
                {
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  if (*arg) {
                    if ((int )*arg == 32) {
                      goto while_break___4;
                    } else { //Added block
                    if ((int )*arg == 9) {
                      goto while_break___4;
                    }
                    }
                  } else {
                    goto while_break___4;
                  }
                  if ((int )*arg == 92) {
                    if ((int )*(arg + 1) != 0) {
                      arg ++;
                    }
                  }
                  tmp___16 = s;
                  s ++;
                  tmp___17 = arg;
                  arg ++;
                  *tmp___16 = *tmp___17;
                }
                while_break___4: /* CIL Label */ ;
                }
                *s = (char_u )'\000';
                if (adding) {
                  goto _L___14;
                } else { //Added block
                if (prepending) {
                  _L___14: 
                  if (flags___0 & 32768) {
                    if (*oldval) {
                      tmp___18 = 1;
                    } else {
                      tmp___18 = 0;
                    }
                  } else {
                    tmp___18 = 0;
                  }
                  comma = tmp___18;
                  if (adding) {
                    {
                    tmp___19 = strlen((char const   *)((char *)oldval));
                    i___0 = (int )tmp___19;
                    tmp___20 = strlen((char const   *)((char *)newval));
                    memmove((void *)((char *)((newval + i___0) + comma)), (void const   *)((char *)newval),
                            tmp___20 + 1UL);
                    memmove((void *)((char *)newval), (void const   *)((char *)oldval),
                            (size_t )i___0);
                    }
                  } else {
                    {
                    tmp___21 = strlen((char const   *)((char *)newval));
                    i___0 = (int )tmp___21;
                    tmp___22 = strlen((char const   *)((char *)oldval));
                    memmove((void *)((char *)((newval + i___0) + comma)), (void const   *)((char *)oldval),
                            tmp___22 + 1UL);
                    }
                  }
                  if (comma) {
                    *(newval + i___0) = (char_u )',';
                  }
                }
                }
                if (removing) {
                  {
                  tmp___23 = strlen((char const   *)((char *)newval));
                  i___0 = (int )tmp___23;
                  bs = 0;
                  s = oldval;
                  }
                  {
                  while (1) {
                    while_continue___5: /* CIL Label */ ;
                    if (! *s) {
                      goto while_break___5;
                    }
                    if (! (flags___0 & 32768)) {
                      goto _L___15;
                    } else { //Added block
                    if ((unsigned long )s == (unsigned long )oldval) {
                      goto _L___15;
                    } else { //Added block
                    if ((int )*(s + -1) == 44) {
                      if (! (bs & 1)) {
                        _L___15: 
                        {
                        tmp___24 = strncmp((char const   *)((char *)s), (char const   *)((char *)newval),
                                           (size_t )i___0);
                        }
                        if (tmp___24 == 0) {
                          if (! (flags___0 & 32768)) {
                            goto while_break___5;
                          } else { //Added block
                          if ((int )*(s + i___0) == 44) {
                            goto while_break___5;
                          } else { //Added block
                          if ((int )*(s + i___0) == 0) {
                            goto while_break___5;
                          }
                          }
                          }
                        }
                      }
                    }
                    }
                    }
                    if ((unsigned long )s > (unsigned long )oldval) {
                      if ((int )*(s + -1) == 92) {
                        bs ++;
                      } else {
                        bs = 0;
                      }
                    } else {
                      bs = 0;
                    }
                    s ++;
                  }
                  while_break___5: /* CIL Label */ ;
                  }
                  {
                  strcpy((char * __restrict  )((char *)newval), (char const   * __restrict  )((char *)oldval));
                  }
                  if (*s) {
                    if (flags___0 & 32768) {
                      if ((unsigned long )s == (unsigned long )oldval) {
                        if ((int )*(s + i___0) == 44) {
                          i___0 ++;
                        }
                      } else {
                        s --;
                        i___0 ++;
                      }
                    }
                    {
                    tmp___25 = strlen((char const   *)((char *)(s + i___0)));
                    memmove((void *)((char *)(newval + (s - oldval))), (void const   *)((char *)(s + i___0)),
                            tmp___25 + 1UL);
                    }
                  }
                }
                *((char_u **)varp) = newval;
                if ((unsigned long )save_arg != (unsigned long )((void *)0)) {
                  arg = save_arg;
                }
                new_value_alloced = 1;
              }
              {
              s = option_expand(opt_idx);
              }
              if ((unsigned long )s != (unsigned long )((void *)0)) {
                if (new_value_alloced) {
                  {
                  vim_free((void *)*((char_u **)varp));
                  }
                }
                *((char_u **)varp) = s;
                new_value_alloced = 1;
              }
              {
              errmsg = did_set_string_option(opt_idx, (char_u **)varp, new_value_alloced,
                                             oldval, errbuf___0);
              }
              if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
                goto skip;
              }
            } else {
              name___2[0] = (char_u )(key & 255);
              name___2[1] = (char_u )(((unsigned int )key >> 8) & 255U);
              if (nextchar == 38) {
                {
                tmp___26 = add_termcap_entry(name___2, 1);
                }
                if (tmp___26 == 0) {
                  errmsg = (char_u *)"Not found in termcap";
                }
              } else {
                arg += len___0 + 1;
                p___1 = arg;
                {
                while (1) {
                  while_continue___6: /* CIL Label */ ;
                  if (*p___1) {
                    if ((int )*p___1 == 32) {
                      goto while_break___6;
                    } else { //Added block
                    if ((int )*p___1 == 9) {
                      goto while_break___6;
                    }
                    }
                  } else {
                    goto while_break___6;
                  }
                  if ((int )*p___1 == 92) {
                    if (*(p___1 + 1)) {
                      p___1 ++;
                    }
                  }
                  p___1 ++;
                }
                while_break___6: /* CIL Label */ ;
                }
                {
                nextchar = (int )*p___1;
                *p___1 = (char_u )'\000';
                add_termcode(name___2, arg, 0);
                *p___1 = (char_u )nextchar;
                }
              }
              if (full_screen) {
                {
                ttest(0);
                }
              }
              {
              redraw_all_later(50);
              }
            }
            }
          }
          if (opt_idx >= 0) {
            options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
          }
        }
        }
        skip: 
        i___0 = 0;
        {
        while (1) {
          while_continue___7: /* CIL Label */ ;
          if (! (i___0 < 2)) {
            goto while_break___7;
          }
          {
          while (1) {
            while_continue___8: /* CIL Label */ ;
            if ((int )*arg != 0) {
              if ((int )*arg == 32) {
                goto while_break___8;
              } else { //Added block
              if ((int )*arg == 9) {
                goto while_break___8;
              }
              }
            } else {
              goto while_break___8;
            }
            tmp___28 = arg;
            arg ++;
            if ((int )*tmp___28 == 92) {
              if ((int )*arg != 0) {
                arg ++;
              }
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          {
          arg = skipwhite(arg);
          }
          if ((int )*arg != 61) {
            goto while_break___7;
          }
          i___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
    {
    arg = skipwhite(arg);
    }
    if (errmsg) {
      {
      no_wait_return ++;
      emsg(errmsg);
      msg_puts((char_u *)": ");
      }
      {
      while (1) {
        while_continue___9: /* CIL Label */ ;
        if (! ((unsigned long )startarg < (unsigned long )arg)) {
          goto while_break___9;
        }
        {
        tmp___32 = startarg;
        startarg ++;
        tmp___33 = transchar((int )*tmp___32);
        msg_puts(tmp___33);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
      msg_end();
      no_wait_return --;
      }
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static char_u *illegal_char(char_u *errbuf___0 , int c ) 
{ 
  char_u *tmp ;

  {
  if ((unsigned long )errbuf___0 == (unsigned long )((void *)0)) {
    return ((char_u *)"");
  }
  {
  tmp = transchar(c);
  sprintf((char * __restrict  )((char *)errbuf___0), (char const   * __restrict  )"Illegal character <%s>",
          (char *)tmp);
  }
  return (errbuf___0);
}
}
static void did_set_title(int icon ) 
{ 


  {
  if (starting != 2) {
    {
    maketitle();
    }
    if (icon) {
      if (! p_icon) {
        {
        mch_restore_title(2);
        }
      }
    } else { //Added block
    if (! p_title) {
      {
      mch_restore_title(1);
      }
    }
    }
  }
  return;
}
}
void set_options_bin(int oldval , int newval ) 
{ 


  {
  if (newval) {
    if (! oldval) {
      curbuf->b_p_tw_nobin = curbuf->b_p_tw;
      curbuf->b_p_wm_nobin = curbuf->b_p_wm;
      curbuf->b_p_ml_nobin = curbuf->b_p_ml;
      curbuf->b_p_et_nobin = curbuf->b_p_et;
    }
    curbuf->b_p_tw = 0L;
    curbuf->b_p_wm = 0L;
    curbuf->b_p_ml = 0;
    curbuf->b_p_et = 0;
  } else { //Added block
  if (oldval) {
    curbuf->b_p_tw = curbuf->b_p_tw_nobin;
    curbuf->b_p_wm = curbuf->b_p_wm_nobin;
    curbuf->b_p_ml = curbuf->b_p_ml_nobin;
    curbuf->b_p_et = curbuf->b_p_et_nobin;
  }
  }
  return;
}
}
int get_viminfo_parameter(int type ) 
{ 
  char_u *p___0 ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  p___0 = find_viminfo_parameter(type);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + (int )*p___0) & 2048) {
      {
      tmp = atoi((char const   *)((char *)p___0));
      }
      return (tmp);
    }
  }
  return (-1);
}
}
char_u *find_viminfo_parameter(int type ) 
{ 
  char_u *p___0 ;

  {
  p___0 = p_viminfo;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == type) {
      return (p___0 + 1);
    }
    if ((int )*p___0 == 110) {
      goto while_break;
    }
    {
    p___0 = vim_strchr(p___0, ',');
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
static char_u *option_expand(int opt_idx ) 
{ 
  char_u *p___0 ;
  int tmp ;
  char_u *tmp___0 ;

  {
  if (! ((int )options[opt_idx].flags & 16)) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  }
  {
  p___0 = *((char_u **)options[opt_idx].var);
  expand_env(p___0, NameBuff, 1024);
  tmp = strcmp((char const   *)((char *)NameBuff), (char const   *)((char *)p___0));
  }
  if (tmp == 0) {
    return ((char_u *)((void *)0));
  }
  {
  tmp___0 = vim_strsave(NameBuff);
  }
  return (tmp___0);
}
}
void check_options(void) 
{ 
  int opt_idx ;
  char_u **p___0 ;
  char_u *tmp ;

  {
  opt_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )options[opt_idx].fullname != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((int )options[opt_idx].flags & 4) {
      if ((unsigned long )options[opt_idx].var != (unsigned long )((void *)0)) {
        {
        tmp = get_varp(& options[opt_idx]);
        p___0 = (char_u **)tmp;
        }
        if ((unsigned long )*p___0 == (unsigned long )((void *)0)) {
          *p___0 = empty_option;
        }
      }
    }
    opt_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void check_buf_options(BUF *buf___3 ) 
{ 


  {
  if ((unsigned long )buf___3->b_p_ff == (unsigned long )((void *)0)) {
    buf___3->b_p_ff = empty_option;
  }
  if ((unsigned long )buf___3->b_p_key == (unsigned long )((void *)0)) {
    buf___3->b_p_key = empty_option;
  }
  if ((unsigned long )buf___3->b_p_mps == (unsigned long )((void *)0)) {
    buf___3->b_p_mps = empty_option;
  }
  if ((unsigned long )buf___3->b_p_fo == (unsigned long )((void *)0)) {
    buf___3->b_p_fo = empty_option;
  }
  if ((unsigned long )buf___3->b_p_isk == (unsigned long )((void *)0)) {
    buf___3->b_p_isk = empty_option;
  }
  if ((unsigned long )buf___3->b_p_com == (unsigned long )((void *)0)) {
    buf___3->b_p_com = empty_option;
  }
  if ((unsigned long )buf___3->b_p_nf == (unsigned long )((void *)0)) {
    buf___3->b_p_nf = empty_option;
  }
  if ((unsigned long )buf___3->b_p_syn == (unsigned long )((void *)0)) {
    buf___3->b_p_syn = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cink == (unsigned long )((void *)0)) {
    buf___3->b_p_cink = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cino == (unsigned long )((void *)0)) {
    buf___3->b_p_cino = empty_option;
  }
  if ((unsigned long )buf___3->b_p_ft == (unsigned long )((void *)0)) {
    buf___3->b_p_ft = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cinw == (unsigned long )((void *)0)) {
    buf___3->b_p_cinw = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cpt == (unsigned long )((void *)0)) {
    buf___3->b_p_cpt = empty_option;
  }
  return;
}
}
void free_string_option(char_u *p___0 ) 
{ 


  {
  if ((unsigned long )p___0 != (unsigned long )empty_option) {
    {
    vim_free((void *)p___0);
    }
  }
  return;
}
}
void set_term_option_alloced(char_u **p___0 ) 
{ 
  int opt_idx ;

  {
  opt_idx = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )options[opt_idx].fullname != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )options[opt_idx].var == (unsigned long )((char_u *)p___0)) {
      options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 8);
      return;
    }
    opt_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void set_string_option_direct(char_u *name___1 , int opt_idx , char_u *val , int dofree ) 
{ 
  char_u *s ;
  char_u **varp ;
  char_u *tmp ;

  {
  if (opt_idx == -1) {
    {
    opt_idx = findoption(name___1);
    }
    if (opt_idx == -1) {
      return;
    }
  }
  if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
    return;
  }
  {
  s = vim_strsave(val);
  }
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    tmp = get_varp(& options[opt_idx]);
    varp = (char_u **)tmp;
    }
    if (dofree) {
      if ((int )options[opt_idx].flags & 8) {
        {
        free_string_option(*varp);
        }
      }
    }
    *varp = s;
    options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 8);
  }
  return;
}
}
static void set_string_option(int opt_idx , char_u *value ) 
{ 
  char_u *s ;
  char_u **varp ;
  char_u *oldval ;
  char_u *tmp ;

  {
  if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
    return;
  }
  {
  s = vim_strsave(value);
  }
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    tmp = get_varp(& options[opt_idx]);
    varp = (char_u **)tmp;
    oldval = *varp;
    *varp = s;
    options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
    did_set_string_option(opt_idx, varp, 1, oldval, (char_u *)((void *)0));
    }
  }
  return;
}
}
static struct lcstab lcstab[4]  = {      {& lcs_eol, (char *)"eol"}, 
        {& lcs_ext, (char *)"extends"}, 
        {& lcs_tab2, (char *)"tab"}, 
        {& lcs_trail, (char *)"trail"}};
static char_u *did_set_string_option(int opt_idx , char_u **varp , int new_value_alloced ,
                                     char_u *oldval , char_u *errbuf___0 ) 
{ 
  char_u *errmsg ;
  char_u *s ;
  char_u *p___0 ;
  int did_chartab ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;
  unsigned short const   **tmp___15 ;
  char_u *tmp___16 ;
  int round ;
  int i___0 ;
  int len___0 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char_u *tmp___19 ;
  unsigned short const   **tmp___20 ;
  char_u *tmp___21 ;
  unsigned short const   **tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int flagval ;
  int tmp___26 ;
  char_u *tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int wid ;
  long tmp___38 ;
  char_u *tmp___39 ;
  int tmp___40 ;
  unsigned short const   **tmp___41 ;
  char_u *tmp___42 ;
  int tmp___43 ;

  {
  errmsg = (char_u *)((void *)0);
  did_chartab = 0;
  if ((unsigned long )varp == (unsigned long )(& term_strings[0])) {
    if ((int )*(term_strings[0] + 0) == 0) {
      errmsg = (char_u *)"Cannot set \'term\' to empty string";
    } else {
      {
      tmp = set_termname(term_strings[0]);
      }
      if (tmp == 0) {
        errmsg = (char_u *)"Not found in termcap";
      } else {
        {
        out_str(term_strings[14]);
        redraw_later(50);
        }
      }
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_bex)) {
    goto _L___4;
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_pm)) {
    _L___4: 
    if ((int )*p_pm == 46) {
      tmp___0 = p_pm + 1;
    } else {
      tmp___0 = p_pm;
    }
    if ((int )*p_bex == 46) {
      tmp___1 = p_bex + 1;
    } else {
      tmp___1 = p_bex;
    }
    {
    tmp___2 = strcmp((char const   *)((char *)tmp___1), (char const   *)((char *)tmp___0));
    }
    if (tmp___2 == 0) {
      errmsg = (char_u *)"\'backupext\' and \'patchmode\' are equal";
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_isi)) {
    goto _L___3;
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_isk)) {
    goto _L___3;
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_isp)) {
    goto _L___3;
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_isf)) {
    _L___3: 
    {
    tmp___3 = init_chartab();
    }
    if (tmp___3 == 0) {
      did_chartab = 1;
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_hf)) {
    if (didset_vim) {
      {
      vim_setenv((char_u *)"VIM", (char_u *)"");
      didset_vim = 0;
      }
    }
    if (didset_vimruntime) {
      {
      vim_setenv((char_u *)"VIMRUNTIME", (char_u *)"");
      didset_vimruntime = 0;
      }
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_hl)) {
    {
    tmp___4 = highlight_changed();
    }
    if (tmp___4 == 0) {
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_nf)) {
    {
    tmp___5 = check_opt_strings(curbuf->b_p_nf, p_nf_values, 1);
    }
    if (tmp___5 != 1) {
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_sessopt)) {
    {
    tmp___6 = check_opt_strings(p_sessopt, p_sessopt_values, 1);
    }
    if (tmp___6 != 1) {
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_sbo)) {
    {
    tmp___7 = check_opt_strings(p_sbo, p_scbopt_values, 1);
    }
    if (tmp___7 != 1) {
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_bg)) {
    {
    tmp___8 = check_opt_strings(p_bg, p_bg_values, 0);
    }
    if (tmp___8 == 1) {
      {
      init_highlight(0);
      }
    } else {
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_wim)) {
    {
    tmp___9 = check_opt_wim();
    }
    if (tmp___9 == 0) {
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_ei)) {
    {
    tmp___10 = check_ei();
    }
    if (tmp___10 == 0) {
      errmsg = e_invarg;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_ff)) {
    {
    tmp___12 = check_opt_strings(curbuf->b_p_ff, p_ff_values, 0);
    }
    if (tmp___12 != 1) {
      errmsg = e_invarg;
    } else {
      {
      tmp___11 = get_fileformat(curbuf);
      }
      if (tmp___11 == 1) {
        curbuf->b_p_tx = 1;
      } else {
        curbuf->b_p_tx = 0;
      }
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_ffs)) {
    {
    tmp___13 = check_opt_strings(p_ffs, p_ff_values, 1);
    }
    if (tmp___13 != 1) {
      errmsg = e_invarg;
    } else { //Added block
    if ((int )*p_ffs == 0) {
      p_ta = 0;
    } else {
      p_ta = 1;
    }
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_key)) {
    {
    remove_key_from_history();
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_mps)) {
    p___0 = curbuf->b_p_mps;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break;
      }
      if (! *(p___0 + 0)) {
        errmsg = e_invarg;
        goto while_break;
      } else { //Added block
      if ((int )*(p___0 + 1) != 58) {
        errmsg = e_invarg;
        goto while_break;
      } else { //Added block
      if (! *(p___0 + 2)) {
        errmsg = e_invarg;
        goto while_break;
      } else { //Added block
      if (*(p___0 + 3)) {
        if ((int )*(p___0 + 3) != 44) {
          errmsg = e_invarg;
          goto while_break;
        }
      }
      }
      }
      }
      if (! *(p___0 + 3)) {
        goto while_break;
      }
      p___0 += 4;
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_com)) {
    s = curbuf->b_p_com;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *s) {
        goto while_break___0;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (*s) {
          if (! ((int )*s != 58)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        {
        tmp___14 = vim_strchr((char_u *)"nbsmexflrO", (int )*s);
        }
        if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
          {
          tmp___15 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___15 + (int )*s) & 2048)) {
            if ((int )*s != 45) {
              {
              errmsg = illegal_char(errbuf___0, (int )*s);
              }
              goto while_break___1;
            }
          }
        }
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      tmp___16 = s;
      s ++;
      if ((int )*tmp___16 == 0) {
        errmsg = (char_u *)"Missing colon";
      } else { //Added block
      if ((int )*s == 44) {
        errmsg = (char_u *)"Zero length string";
      } else { //Added block
      if ((int )*s == 0) {
        errmsg = (char_u *)"Zero length string";
      }
      }
      }
      if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
        goto while_break___0;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (*s) {
          if (! ((int )*s != 44)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        if ((int )*s == 92) {
          if ((int )*(s + 1) != 0) {
            s ++;
          }
        }
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      s = skip_to_option_part(s);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_lcs)) {
    round = 0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (round <= 1) {
        if (! ((unsigned long )errmsg == (unsigned long )((void *)0))) {
          goto while_break___3;
        }
      } else {
        goto while_break___3;
      }
      if (round) {
        i___0 = 0;
        {
        while (1) {
          while_continue___4: /* CIL Label */ ;
          if (! ((unsigned long )i___0 < sizeof(lcstab) / sizeof(struct lcstab ))) {
            goto while_break___4;
          }
          *(lcstab[i___0].lcsp) = '\000';
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        lcs_tab1 = '\000';
      }
      p___0 = p_lcs;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (! *p___0) {
          goto while_break___5;
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___6: /* CIL Label */ ;
          if (! ((unsigned long )i___0 < sizeof(lcstab) / sizeof(struct lcstab ))) {
            goto while_break___6;
          }
          {
          tmp___17 = strlen((char const   *)lcstab[i___0].name);
          len___0 = (int )tmp___17;
          tmp___18 = strncmp((char const   *)((char *)p___0), (char const   *)lcstab[i___0].name,
                             (size_t )len___0);
          }
          if (tmp___18 == 0) {
            if ((int )*(p___0 + len___0) == 58) {
              if ((int )*(p___0 + (len___0 + 1)) != 0) {
                if ((unsigned long )lcstab[i___0].lcsp == (unsigned long )(& lcs_tab2)) {
                  len___0 ++;
                }
                if ((int )*(p___0 + (len___0 + 1)) != 0) {
                  if ((int )*(p___0 + (len___0 + 2)) == 44) {
                    goto _L;
                  } else { //Added block
                  if ((int )*(p___0 + (len___0 + 2)) == 0) {
                    _L: 
                    if (round) {
                      *(lcstab[i___0].lcsp) = (int )*(p___0 + (len___0 + 1));
                      if ((unsigned long )lcstab[i___0].lcsp == (unsigned long )(& lcs_tab2)) {
                        lcs_tab1 = (int )*(p___0 + len___0);
                      }
                    }
                    p___0 += len___0 + 2;
                    goto while_break___6;
                  }
                  }
                }
              }
            }
          }
          i___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        if ((unsigned long )i___0 == sizeof(lcstab) / sizeof(struct lcstab )) {
          errmsg = e_invarg;
          goto while_break___5;
        }
        if ((int )*p___0 == 44) {
          p___0 ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      round ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_viminfo)) {
    s = p_viminfo;
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      if (! *s) {
        goto while_break___7;
      }
      {
      tmp___19 = vim_strchr((char_u *)"\"\'%!fhrn:/", (int )*s);
      }
      if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
        {
        errmsg = illegal_char(errbuf___0, (int )*s);
        }
        goto while_break___7;
      }
      if ((int )*s == 110) {
        goto while_break___7;
      } else { //Added block
      if ((int )*s == 114) {
        {
        while (1) {
          while_continue___8: /* CIL Label */ ;
          s ++;
          if (*s) {
            if (! ((int )*s != 44)) {
              goto while_break___8;
            }
          } else {
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
      } else { //Added block
      if ((int )*s == 37) {
        s ++;
      } else { //Added block
      if ((int )*s == 33) {
        s ++;
      } else { //Added block
      if ((int )*s == 104) {
        s ++;
      } else {
        {
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
          tmp___20 = __ctype_b_loc();
          s ++;
          }
          if (! ((int const   )*(*tmp___20 + (int )*s) & 2048)) {
            goto while_break___9;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        {
        tmp___22 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___22 + (int )*(s - 1)) & 2048)) {
          if ((unsigned long )errbuf___0 != (unsigned long )((void *)0)) {
            {
            tmp___21 = transchar((int )*(s - 1));
            sprintf((char * __restrict  )((char *)errbuf___0), (char const   * __restrict  )"Missing number after <%s>",
                    tmp___21);
            errmsg = errbuf___0;
            }
          } else {
            errmsg = (char_u *)"";
          }
          goto while_break___7;
        }
      }
      }
      }
      }
      }
      if ((int )*s == 44) {
        s ++;
      } else { //Added block
      if (*s) {
        if ((unsigned long )errbuf___0 != (unsigned long )((void *)0)) {
          errmsg = (char_u *)"Missing comma";
        } else {
          errmsg = (char_u *)"";
        }
        goto while_break___7;
      }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    if (*p_viminfo) {
      if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
        {
        tmp___23 = get_viminfo_parameter('\'');
        }
        if (tmp___23 < 0) {
          errmsg = (char_u *)"Must specify a \' value";
        }
      }
    }
  } else {
    {
    tmp___43 = istermoption(& options[opt_idx]);
    }
    if (tmp___43) {
      if (full_screen) {
        if ((unsigned long )varp == (unsigned long )(& term_strings[34])) {
          {
          tmp___24 = atoi((char const   *)((char *)term_strings[34]));
          }
          if (tmp___24 == 0) {
            if (new_value_alloced) {
              {
              vim_free((void *)term_strings[34]);
              }
            }
            term_strings[34] = empty_option;
          }
        }
        {
        ttest(0);
        }
        if ((unsigned long )varp == (unsigned long )(& term_strings[14])) {
          {
          out_str(term_strings[14]);
          redraw_later(50);
          }
        }
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if ((unsigned long )varp == (unsigned long )(& p_sbr)) {
      s = p_sbr;
      {
      while (1) {
        while_continue___10: /* CIL Label */ ;
        if (! *s) {
          goto while_break___10;
        }
        {
        tmp___25 = charsize((int )*s);
        }
        if (tmp___25 != 1) {
          errmsg = (char_u *)"contains unprintable character";
        }
        s ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_breakat)) {
      {
      fill_breakat_flags();
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_titlestring)) {
      goto _L___1;
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_iconstring)) {
      _L___1: 
      if ((unsigned long )varp == (unsigned long )(& p_titlestring)) {
        tmp___26 = 2;
      } else {
        tmp___26 = 1;
      }
      {
      flagval = tmp___26;
      tmp___27 = vim_strchr(*varp, '%');
      }
      if (tmp___27) {
        {
        tmp___28 = check_stl_option(*varp);
        }
        if ((unsigned long )tmp___28 == (unsigned long )((void *)0)) {
          stl_syntax |= flagval;
        } else {
          stl_syntax &= ~ flagval;
        }
      } else {
        stl_syntax &= ~ flagval;
      }
      {
      did_set_title((unsigned long )varp == (unsigned long )(& p_iconstring));
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_ttym)) {
      {
      tmp___29 = check_opt_strings(p_ttym, p_ttym_values, 0);
      }
      if (tmp___29 != 1) {
        errmsg = e_invarg;
      } else {
        {
        check_mouse_termcode();
        }
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_sel)) {
      if ((int )*p_sel == 0) {
        errmsg = e_invarg;
      } else {
        {
        tmp___30 = check_opt_strings(p_sel, p_sel_values, 0);
        }
        if (tmp___30 != 1) {
          errmsg = e_invarg;
        }
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_slm)) {
      {
      tmp___31 = check_opt_strings(p_slm, p_slm_values, 1);
      }
      if (tmp___31 != 1) {
        errmsg = e_invarg;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_bsdir)) {
      {
      tmp___32 = check_opt_strings(p_bsdir, p_bsdir_values, 0);
      }
      if (tmp___32 != 1) {
        errmsg = e_invarg;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_km)) {
      {
      tmp___33 = check_opt_strings(p_km, p_km_values, 1);
      }
      if (tmp___33 != 1) {
        errmsg = e_invarg;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_mousem)) {
      {
      tmp___34 = check_opt_strings(p_mousem, p_mousem_values, 0);
      }
      if (tmp___34 != 1) {
        errmsg = e_invarg;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_swb)) {
      {
      tmp___35 = check_opt_strings(p_swb, p_swb_values, 1);
      }
      if (tmp___35 != 1) {
        errmsg = e_invarg;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_dy)) {
      {
      tmp___36 = check_opt_strings(p_dy, p_dy_values, 1);
      }
      if (tmp___36 != 1) {
        errmsg = e_invarg;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_cb)) {
      {
      tmp___37 = check_opt_strings(p_cb, p_cb_values, 1);
      }
      if (tmp___37 != 1) {
        errmsg = e_invarg;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_syn)) {
      {
      apply_autocmds((EVENT_T )30, curbuf->b_p_syn, curbuf->b_fname, 1, curbuf);
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_ft)) {
      {
      apply_autocmds((EVENT_T )18, curbuf->b_p_ft, curbuf->b_fname, 1, curbuf);
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_stl)) {
      goto _L___0;
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_ruf)) {
      _L___0: 
      if ((unsigned long )varp == (unsigned long )(& p_ruf)) {
        ru_wid = 0;
      }
      s = *varp;
      if ((unsigned long )varp == (unsigned long )(& p_ruf)) {
        if ((int )*s == 37) {
          s ++;
          if ((int )*s == 45) {
            s ++;
          }
          {
          tmp___38 = getdigits(& s);
          wid = (int )tmp___38;
          }
          if (wid) {
            if ((int )*s == 40) {
              {
              errmsg = check_stl_option(p_ruf);
              }
              if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
                ru_wid = wid;
              } else {
                {
                errmsg = check_stl_option(p_ruf);
                }
              }
            } else {
              {
              errmsg = check_stl_option(p_ruf);
              }
            }
          } else {
            {
            errmsg = check_stl_option(p_ruf);
            }
          }
        } else {
          {
          errmsg = check_stl_option(s);
          }
        }
      } else {
        {
        errmsg = check_stl_option(s);
        }
      }
      if ((unsigned long )varp == (unsigned long )(& p_ruf)) {
        if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
          {
          comp_col();
          }
        }
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_cpt)) {
      s = curbuf->b_p_cpt;
      {
      while (1) {
        while_continue___11: /* CIL Label */ ;
        if (! *s) {
          goto while_break___11;
        }
        {
        while (1) {
          while_continue___12: /* CIL Label */ ;
          if (! ((int )*s == 44)) {
            if (! ((int )*s == 32)) {
              goto while_break___12;
            }
          }
          s ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        if (! *s) {
          goto while_break___11;
        }
        {
        tmp___39 = vim_strchr((char_u *)".wbukid]t", (int )*s);
        }
        if ((unsigned long )tmp___39 == (unsigned long )((void *)0)) {
          {
          errmsg = illegal_char(errbuf___0, (int )*s);
          }
          goto while_break___11;
        }
        s ++;
        if ((int )*s != 0) {
          if ((int )*s != 44) {
            if ((int )*s != 32) {
              if ((int )*(s - 1) == 107) {
                {
                while (1) {
                  while_continue___13: /* CIL Label */ ;
                  if (*s) {
                    if ((int )*s != 44) {
                      if (! ((int )*s != 32)) {
                        goto while_break___13;
                      }
                    } else {
                      goto while_break___13;
                    }
                  } else {
                    goto while_break___13;
                  }
                  if ((int )*s == 92) {
                    s ++;
                  }
                  s ++;
                }
                while_break___13: /* CIL Label */ ;
                }
              } else {
                if ((unsigned long )errbuf___0 != (unsigned long )((void *)0)) {
                  {
                  s --;
                  sprintf((char * __restrict  )((char *)errbuf___0), (char const   * __restrict  )"Illegal character after <%c>",
                          (int )*s);
                  errmsg = errbuf___0;
                  }
                } else {
                  errmsg = (char_u *)"";
                }
                goto while_break___11;
              }
            }
          }
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_pt)) {
      if (*p_pt) {
        {
        replace_termcodes(p_pt, & p___0, 1, 1);
        }
        if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
          if (new_value_alloced) {
            {
            vim_free((void *)p_pt);
            }
          }
          p_pt = p___0;
          new_value_alloced = 1;
        }
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_bs)) {
      {
      tmp___41 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___41 + (int )*p_bs) & 2048) {
        if ((int )*p_bs > 50) {
          errmsg = e_invarg;
        } else { //Added block
        if ((int )*(p_bs + 1) != 0) {
          errmsg = e_invarg;
        }
        }
      } else {
        {
        tmp___40 = check_opt_strings(p_bs, p_bs_values, 1);
        }
        if (tmp___40 != 1) {
          errmsg = e_invarg;
        }
      }
    } else {
      p___0 = (char_u *)((void *)0);
      if ((unsigned long )varp == (unsigned long )(& p_ww)) {
        p___0 = (char_u *)"bshl<>[],~";
      }
      if ((unsigned long )varp == (unsigned long )(& p_shm)) {
        p___0 = (char_u *)"rmfixlnwaWtToOsAI";
      } else { //Added block
      if ((unsigned long )varp == (unsigned long )(& p_cpo)) {
        p___0 = (char_u *)"aAbBcCdeEfFjJkKlLmoOprsStuwWxy$!%*<";
      } else { //Added block
      if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_fo)) {
        p___0 = (char_u *)"tcroq2vlb,";
      } else { //Added block
      if ((unsigned long )varp == (unsigned long )(& p_mouse)) {
        p___0 = (char_u *)"anvichr";
      }
      }
      }
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        s = *varp;
        {
        while (1) {
          while_continue___14: /* CIL Label */ ;
          if (! *s) {
            goto while_break___14;
          }
          {
          tmp___42 = vim_strchr(p___0, (int )*s);
          }
          if ((unsigned long )tmp___42 == (unsigned long )((void *)0)) {
            {
            errmsg = illegal_char(errbuf___0, (int )*s);
            }
            goto while_break___14;
          }
          s ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
    if (new_value_alloced) {
      {
      vim_free((void *)*varp);
      }
    }
    *varp = oldval;
    if (did_chartab) {
      {
      init_chartab();
      }
    }
    if ((unsigned long )varp == (unsigned long )(& p_hl)) {
      {
      highlight_changed();
      }
    }
  } else {
    if ((int )options[opt_idx].flags & 8) {
      {
      free_string_option(oldval);
      }
    }
    if (new_value_alloced) {
      options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 8);
    } else {
      options[opt_idx].flags = (short_u )((int )options[opt_idx].flags & -9);
    }
  }
  if ((unsigned long )varp == (unsigned long )(& p_mouse)) {
    if ((int )*p_mouse == 0) {
      {
      mch_setmouse(0);
      }
    } else {
      {
      setmouse();
      }
    }
  }
  {
  curwin->w_set_curswant = 1;
  check_redraw((int )options[opt_idx].flags);
  }
  return (errmsg);
}
}
static char_u errbuf[80]  ;
char_u *check_stl_option(char_u *s ) 
{ 
  int itemcnt ;
  int groupdepth ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;

  {
  itemcnt = 0;
  groupdepth = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*s) {
      if (! (itemcnt < 50)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (*s) {
        if (! ((int )*s != 37)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (! *s) {
      goto while_break;
    }
    s ++;
    if ((int )*s == 37) {
      s ++;
      goto while_continue;
    } else { //Added block
    if ((int )*s == 60) {
      s ++;
      goto while_continue;
    } else { //Added block
    if ((int )*s == 61) {
      s ++;
      goto while_continue;
    }
    }
    }
    if ((int )*s == 41) {
      s ++;
      groupdepth --;
      goto while_continue;
    }
    if ((int )*s == 45) {
      s ++;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
        goto while_break___1;
      }
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((int )*s == 42) {
      goto while_continue;
    }
    if ((int )*s == 46) {
      s ++;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (*s) {
          {
          tmp___0 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___0 + (int )*s) & 2048)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    if ((int )*s == 40) {
      groupdepth ++;
      goto while_continue;
    }
    {
    tmp___2 = vim_strchr((char_u *)"fFtcvVlLnoObBrRhHmYyWwMpPa{", (int )*s);
    }
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
      tmp___1 = illegal_char(errbuf, (int )*s);
      }
      return (tmp___1);
    }
    if ((int )*s == 123) {
      s ++;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if ((int )*s != 125) {
          if (! *s) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      if ((int )*s != 125) {
        return ((char_u *)"Unclosed expression sequence");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (itemcnt >= 50) {
    return ((char_u *)"too many items");
  }
  if (groupdepth != 0) {
    return ((char_u *)"unbalanced groups");
  }
  return ((char_u *)((void *)0));
}
}
static char_u *set_bool_option(int opt_idx , char_u *varp , int value ) 
{ 
  int old_p_bin ;
  int old_p_ea ;
  int old_p_wiv ;
  char_u *p___0 ;
  size_t tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  old_p_bin = curbuf->b_p_bin;
  old_p_ea = p_ea;
  old_p_wiv = p_wiv;
  if (secure) {
    goto _L;
  } else { //Added block
  if (sandbox != 0) {
    _L: 
    if ((unsigned long )((int *)varp) == (unsigned long )(& p_secure)) {
      return ((char_u *)"not allowed here");
    }
  }
  }
  *((int *)varp) = value;
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_cp)) {
    {
    compatible_set();
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_ro)) {
    if (! curbuf->b_p_ro) {
      readonlymode = 0;
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_bin)) {
    {
    set_options_bin(old_p_bin, curbuf->b_p_bin);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_swf)) {
    if (curbuf->b_p_swf) {
      if (p_uc) {
        {
        ml_open_file(curbuf);
        }
      } else {
        {
        mf_close_file(curbuf, 1);
        }
      }
    } else {
      {
      mf_close_file(curbuf, 1);
      }
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_terse)) {
    {
    p___0 = vim_strchr(p_shm, 's');
    }
    if (p_terse) {
      if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
        {
        strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)p_shm));
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"s"));
        set_string_option_direct((char_u *)"shm", -1, IObuff, 1);
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (! p_terse) {
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        {
        tmp = strlen((char const   *)((char *)p___0));
        memmove((void *)((char *)p___0), (void const   *)((char *)(p___0 + 1)), tmp);
        }
      }
    }
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_paste)) {
    {
    paste_option_changed();
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_ic)) {
    if (p_hls) {
      {
      redraw_all_later(40);
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_hls)) {
    no_hlsearch = 0;
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_tx)) {
    if (curbuf->b_p_tx) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    {
    set_fileformat(tmp___0);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_ta)) {
    if (p_ta) {
      tmp___1 = (char_u *)"unix,dos";
    } else {
      tmp___1 = (char_u *)"";
    }
    {
    set_string_option_direct((char_u *)"ffs", -1, tmp___1, 1);
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )((char_u *)(& curbuf->b_p_lisp))) {
    {
    init_chartab();
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_title)) {
    {
    did_set_title(0);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_icon)) {
    {
    did_set_title(1);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_changed)) {
    if (! value) {
      curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
    }
    modified_was_set = value;
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  if (p_ea) {
    if (! old_p_ea) {
      {
      win_equal(curwin, 0);
      }
    }
  }
  if (p_wiv) {
    if (! old_p_wiv) {
      term_strings[37] = (char_u *)"y";
    } else {
      goto _L___3;
    }
  } else { //Added block
  _L___3: 
  if (! p_wiv) {
    if (old_p_wiv) {
      term_strings[37] = empty_option;
    }
  }
  }
  {
  p_wiv = (int )*(term_strings[37]) != 0;
  options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
  comp_col();
  curwin->w_set_curswant = 1;
  check_redraw((int )options[opt_idx].flags);
  }
  return ((char_u *)((void *)0));
}
}
static char_u *set_num_option(int opt_idx , char_u *varp , long value , char_u *errbuf___0 ) 
{ 
  char_u *errmsg ;
  long old_Rows___0 ;
  long old_Columns ;
  long old_p_ch ;
  long old_p_uc ;
  long old_titlelen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  errmsg = (char_u *)((void *)0);
  old_Rows___0 = Rows;
  old_Columns = Columns;
  old_p_ch = p_ch;
  old_p_uc = p_uc;
  old_titlelen = p_titlelen;
  *((long *)varp) = value;
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_wh)) {
    goto _L;
  } else { //Added block
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_hh)) {
    _L: 
    if (p_wh < 1L) {
      errmsg = e_positive;
      p_wh = 1L;
    }
    if (p_wmh > p_wh) {
      errmsg = (char_u *)"\'winheight\' cannot be smaller than \'winminheight\'";
      p_wh = p_wmh;
    }
    if (p_hh < 0L) {
      errmsg = e_positive;
      p_hh = 0L;
    }
    if ((unsigned long )lastwin != (unsigned long )firstwin) {
      if ((unsigned long )((long *)varp) == (unsigned long )(& p_wh)) {
        if ((long )curwin->w_height < p_wh) {
          {
          win_setheight((int )p_wh);
          }
        }
      }
      if ((unsigned long )((long *)varp) == (unsigned long )(& p_hh)) {
        if (curbuf->b_help) {
          if ((long )curwin->w_height < p_hh) {
            {
            win_setheight((int )p_hh);
            }
          }
        }
      }
    }
  } else { //Added block
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_wmh)) {
    if (p_wmh < 0L) {
      errmsg = e_positive;
      p_wh = 0L;
    }
    if (p_wmh > p_wh) {
      errmsg = (char_u *)"\'winheight\' cannot be smaller than \'winminheight\'";
      p_wmh = p_wh;
    }
    {
    win_setminheight();
    }
  } else { //Added block
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_ls)) {
    {
    last_status();
    }
  }
  }
  }
  }
  {
  tmp___1 = min_rows();
  }
  if (Rows < (long )tmp___1) {
    if (full_screen) {
      if ((unsigned long )errbuf___0 != (unsigned long )((void *)0)) {
        {
        tmp = min_rows();
        sprintf((char * __restrict  )((char *)errbuf___0), (char const   * __restrict  )"Need at least %d lines",
                tmp);
        errmsg = errbuf___0;
        }
      }
      {
      tmp___0 = min_rows();
      Rows = (long )tmp___0;
      }
    }
  }
  if (Columns < 12L) {
    if (full_screen) {
      if ((unsigned long )errbuf___0 != (unsigned long )((void *)0)) {
        {
        sprintf((char * __restrict  )((char *)errbuf___0), (char const   * __restrict  )"Need at least %d columns",
                12);
        errmsg = errbuf___0;
        }
      }
      Columns = 12L;
    }
  }
  if (old_Rows___0 != Rows) {
    goto _L___0;
  } else { //Added block
  if (old_Columns != Columns) {
    _L___0: 
    if (full_screen) {
      {
      ui_set_winsize();
      check_winsize();
      }
    }
  }
  }
  if (curbuf->b_p_sts < 0L) {
    errmsg = e_positive;
    curbuf->b_p_sts = 0L;
  }
  if (curbuf->b_p_ts <= 0L) {
    errmsg = e_positive;
    curbuf->b_p_ts = 8L;
  }
  if (curbuf->b_p_sw <= 0L) {
    errmsg = e_positive;
    curbuf->b_p_sw = curbuf->b_p_ts;
  }
  if (curbuf->b_p_tw < 0L) {
    errmsg = e_positive;
    curbuf->b_p_tw = 0L;
  }
  if (p_tm < 0L) {
    errmsg = e_positive;
    p_tm = 0L;
  }
  if (p_titlelen < 0L) {
    errmsg = e_positive;
    p_titlelen = 85L;
  }
  if (curwin->w_p_scroll <= 0L) {
    goto _L___1;
  } else { //Added block
  if (curwin->w_p_scroll > (long )curwin->w_height) {
    if (curwin->w_height > 0) {
      _L___1: 
      if (full_screen) {
        if ((unsigned long )((long *)varp) == (unsigned long )(& curwin->w_p_scroll)) {
          if (curwin->w_p_scroll != 0L) {
            errmsg = e_scroll;
          }
          {
          win_comp_scroll(curwin);
          }
        } else { //Added block
        if (curwin->w_p_scroll <= 0L) {
          curwin->w_p_scroll = 1L;
        } else {
          curwin->w_p_scroll = (long )curwin->w_height;
        }
        }
      }
    }
  }
  }
  if (p_report < 0L) {
    errmsg = e_positive;
    p_report = 1L;
  }
  if (p_sj < 0L) {
    goto _L___2;
  } else { //Added block
  if (p_sj >= Rows) {
    _L___2: 
    if (full_screen) {
      if (Rows != old_Rows___0) {
        p_sj = Rows / 2L;
      } else {
        errmsg = e_scroll;
        p_sj = 1L;
      }
    }
  }
  }
  if (p_so < 0L) {
    if (full_screen) {
      errmsg = e_scroll;
      p_so = 0L;
    }
  }
  if (p_uc < 0L) {
    errmsg = e_positive;
    p_uc = 100L;
  }
  if (p_ch < 1L) {
    errmsg = e_positive;
    p_ch = 1L;
  }
  if (p_ut < 0L) {
    errmsg = e_positive;
    p_ut = 2000L;
  }
  if (p_ss < 0L) {
    errmsg = e_positive;
    p_ss = 0L;
  }
  if (p_uc) {
    if (! old_p_uc) {
      {
      ml_open_files();
      }
    }
  }
  if (p_ch != old_p_ch) {
    {
    command_height(old_p_ch);
    }
  }
  if (old_titlelen != p_titlelen) {
    if (starting != 2) {
      {
      maketitle();
      }
    }
  }
  {
  options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
  comp_col();
  curwin->w_set_curswant = 1;
  check_redraw((int )options[opt_idx].flags);
  }
  return (errmsg);
}
}
static void check_redraw(int flags___0 ) 
{ 


  {
  if (flags___0 & 20480) {
    {
    status_redraw_all();
    }
  }
  if (flags___0 & 24576) {
    {
    changed_line_abv_curs();
    invalidate_botline();
    update_topline();
    }
  }
  if (flags___0 & 8192) {
    {
    redraw_curbuf_later(40);
    }
  }
  if (flags___0 & 16384) {
    {
    redraw_all_later(40);
    }
  }
  if ((flags___0 & 28672) == 28672) {
    {
    redraw_all_later(50);
    }
  }
  return;
}
}
static short quick_tab[27]  = {      (short)0,      (short)0};
static int findoption(char_u *arg ) 
{ 
  int opt_idx ;
  char *s ;
  char *p___0 ;
  int is_term_opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )quick_tab[1] == 0) {
    p___0 = options[0].fullname;
    opt_idx = 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      s = options[opt_idx].fullname;
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if ((int )*(s + 0) != (int )*(p___0 + 0)) {
        if ((int )*(s + 0) == 116) {
          if ((int )*(s + 1) == 95) {
            quick_tab[26] = (short )opt_idx;
          } else {
            quick_tab[(int )*(s + 0) - 97] = (short )opt_idx;
          }
        } else {
          quick_tab[(int )*(s + 0) - 97] = (short )opt_idx;
        }
      }
      p___0 = s;
      opt_idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if ((int )*(arg + 0) < 97) {
    return (-1);
  } else { //Added block
  if ((int )*(arg + 0) > 122) {
    return (-1);
  }
  }
  if ((int )*(arg + 0) == 116) {
    if ((int )*(arg + 1) == 95) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  is_term_opt = tmp;
  if (is_term_opt) {
    opt_idx = (int )quick_tab[26];
  } else {
    opt_idx = (int )quick_tab[(int )*(arg + 0) - 97];
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    s = options[opt_idx].fullname;
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    tmp___0 = strcmp((char const   *)((char *)arg), (char const   *)s);
    }
    if (tmp___0 == 0) {
      goto while_break___0;
    }
    opt_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    if (! is_term_opt) {
      opt_idx = (int )quick_tab[(int )*(arg + 0) - 97];
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! ((unsigned long )options[opt_idx].fullname != (unsigned long )((void *)0))) {
          goto while_break___1;
        }
        s = options[opt_idx].shortname;
        if ((unsigned long )s != (unsigned long )((void *)0)) {
          {
          tmp___1 = strcmp((char const   *)((char *)arg), (char const   *)s);
          }
          if (tmp___1 == 0) {
            goto while_break___1;
          }
        }
        s = (char *)((void *)0);
        opt_idx ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    opt_idx = -1;
  }
  return (opt_idx);
}
}
int get_option_value(char_u *name___1 , long *numval , char_u **stringval ) 
{ 
  int opt_idx ;
  char_u *varp ;

  {
  {
  opt_idx = findoption(name___1);
  }
  if (opt_idx < 0) {
    return (-2);
  }
  {
  varp = get_varp(& options[opt_idx]);
  }
  if ((unsigned long )varp == (unsigned long )((void *)0)) {
    return (-1);
  }
  if ((int )options[opt_idx].flags & 4) {
    if ((unsigned long )stringval != (unsigned long )((void *)0)) {
      if ((unsigned long )((char_u **)varp) == (unsigned long )(& curbuf->b_p_key)) {
        {
        *stringval = vim_strsave((char_u *)"*****");
        }
      } else {
        {
        *stringval = vim_strsave(*((char_u **)varp));
        }
      }
    }
    return (0);
  }
  if ((int )options[opt_idx].flags & 2) {
    *numval = *((long *)varp);
  } else {
    *numval = (long )*((int *)varp);
  }
  return (1);
}
}
void set_option_value(char_u *name___1 , long number , char_u *string___0 ) 
{ 
  int opt_idx ;
  char_u *varp ;

  {
  {
  opt_idx = findoption(name___1);
  }
  if (opt_idx == -1) {
    {
    emsg2((char_u *)"Unknown option: %s", name___1);
    }
  } else { //Added block
  if ((int )options[opt_idx].flags & 4) {
    {
    set_string_option(opt_idx, string___0);
    }
  } else {
    {
    varp = get_varp(& options[opt_idx]);
    }
    if ((unsigned long )varp != (unsigned long )((void *)0)) {
      if ((int )options[opt_idx].flags & 2) {
        {
        set_num_option(opt_idx, varp, number, (char_u *)((void *)0));
        }
      } else {
        {
        set_bool_option(opt_idx, varp, (int )number);
        }
      }
    }
  }
  }
  return;
}
}
char_u *get_term_code(char_u *tname ) 
{ 
  int opt_idx ;
  char_u *varp ;
  char_u *tmp ;

  {
  if ((int )*(tname + 0) != 116) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((int )*(tname + 1) != 95) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((int )*(tname + 2) == 0) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((int )*(tname + 3) == 0) {
    return ((char_u *)((void *)0));
  }
  }
  }
  }
  {
  opt_idx = findoption(tname);
  }
  if (opt_idx >= 0) {
    {
    varp = get_varp(& options[opt_idx]);
    }
    if ((unsigned long )varp != (unsigned long )((void *)0)) {
      varp = *((char_u **)varp);
    }
    return (varp);
  }
  {
  tmp = find_termcode(tname + 2);
  }
  return (tmp);
}
}
char_u *get_highlight_default(void) 
{ 
  int i___0 ;

  {
  {
  i___0 = findoption((char_u *)"hl");
  }
  if (i___0 >= 0) {
    return (options[i___0].def_val[0]);
  }
  return ((char_u *)((void *)0));
}
}
static int find_key_option(char_u *arg ) 
{ 
  int key ;
  int modifiers ;

  {
  if ((int )*(arg + 0) == 116) {
    if ((int )*(arg + 1) == 95) {
      if (*(arg + 2)) {
        if (*(arg + 3)) {
          key = (int )*(arg + 2) + ((int )*(arg + 3) << 8);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    {
    arg --;
    key = find_special_key(& arg, & modifiers, 1);
    }
    if (modifiers) {
      key = 0;
    }
  }
  return (key);
}
}
static void showoptions(int all ) 
{ 
  struct vimoption *p___0 ;
  int col ;
  int isterm ;
  char_u *varp ;
  struct vimoption **items ;
  int item_count ;
  int run ;
  int row ;
  int rows ;
  int cols ;
  int i___0 ;
  int len___0 ;
  char_u *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = alloc((unsigned int )(sizeof(struct vimoption *) * (sizeof(options) / sizeof(struct vimoption ))));
  items = (struct vimoption **)tmp;
  }
  if ((unsigned long )items == (unsigned long )((void *)0)) {
    return;
  }
  if (all == 2) {
    {
    msg_puts_title((char_u *)"\n--- Terminal codes ---");
    }
  } else {
    {
    msg_puts_title((char_u *)"\n--- Options ---");
    }
  }
  run = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (run <= 2) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    item_count = 0;
    p___0 = & options[0];
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )p___0->fullname != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      isterm = istermoption(p___0);
      varp = get_varp(p___0);
      }
      if ((unsigned long )varp != (unsigned long )((void *)0)) {
        if (all == 2) {
          if (isterm) {
            goto _L___0;
          } else {
            goto _L___2;
          }
        } else { //Added block
        _L___2: 
        if (all == 1) {
          if (! isterm) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if (all == 0) {
          {
          tmp___3 = option_not_default(p___0);
          }
          if (tmp___3) {
            _L___0: 
            if ((int )p___0->flags & 1) {
              len___0 = 1;
            } else {
              {
              option_value2string(p___0);
              tmp___0 = strlen((char const   *)p___0->fullname);
              tmp___1 = vim_strsize(NameBuff);
              len___0 = (int )((tmp___0 + (size_t )tmp___1) + 1UL);
              }
            }
            if (len___0 <= 17) {
              if (run == 1) {
                tmp___2 = item_count;
                item_count ++;
                *(items + tmp___2) = p___0;
              } else {
                goto _L;
              }
            } else { //Added block
            _L: 
            if (len___0 > 17) {
              if (run == 2) {
                tmp___2 = item_count;
                item_count ++;
                *(items + tmp___2) = p___0;
              }
            }
            }
          }
        }
        }
        }
      }
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (run == 1) {
      cols = (int )(((Columns + 3L) - 3L) / 20L);
      if (cols == 0) {
        cols = 1;
      }
      rows = ((item_count + cols) - 1) / cols;
    } else {
      rows = item_count;
    }
    row = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (row < rows) {
        if (! (! got_int)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      {
      msg_putchar('\n');
      }
      if (got_int) {
        goto while_break___1;
      }
      col = 0;
      i___0 = row;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (i___0 < item_count)) {
          goto while_break___2;
        }
        {
        msg_col = col;
        showoneopt(*(items + i___0));
        col += 20;
        i___0 += rows;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      out_flush();
      ui_breakcheck();
      row ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    run ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)items);
  }
  return;
}
}
static int option_not_default(struct vimoption *p___0 ) 
{ 
  char_u *varp ;
  int dvi ;
  int tmp ;

  {
  {
  varp = get_varp(p___0);
  }
  if ((unsigned long )varp == (unsigned long )((void *)0)) {
    return (0);
  }
  if ((int )p___0->flags & 1024) {
    dvi = 0;
  } else { //Added block
  if (p_cp) {
    dvi = 0;
  } else {
    dvi = 1;
  }
  }
  if ((int )p___0->flags & 2) {
    return (*((long *)varp) != (long )p___0->def_val[dvi]);
  }
  if ((int )p___0->flags & 1) {
    return (*((int *)varp) != (int )((long )p___0->def_val[dvi]));
  }
  {
  tmp = strcmp((char const   *)((char *)*((char_u **)varp)), (char const   *)((char *)p___0->def_val[dvi]));
  }
  return (tmp);
}
}
static void showoneopt(struct vimoption *p___0 ) 
{ 
  char_u *varp ;

  {
  {
  varp = get_varp(p___0);
  }
  if ((int )p___0->flags & 1) {
    if (! *((int *)varp)) {
      {
      msg_puts((char_u *)"no");
      }
    } else {
      {
      msg_puts((char_u *)"  ");
      }
    }
  } else {
    {
    msg_puts((char_u *)"  ");
    }
  }
  {
  msg_puts((char_u *)p___0->fullname);
  }
  if (! ((int )p___0->flags & 1)) {
    {
    msg_putchar('=');
    option_value2string(p___0);
    msg_outtrans(NameBuff);
    }
  }
  return;
}
}
int makeset(FILE *fd ) 
{ 
  struct vimoption *p___0 ;
  char_u *s ;
  char_u *varp ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  p___0 = & options[0];
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___7 = istermoption(p___0);
    }
    if (tmp___7) {
      goto while_break;
    }
    if (! ((int )p___0->flags & 512)) {
      {
      tmp___5 = istermoption(p___0);
      }
      if (! tmp___5) {
        {
        tmp___6 = option_not_default(p___0);
        }
        if (tmp___6) {
          {
          varp = get_varp(p___0);
          }
          if ((int )p___0->flags & 1) {
            if (*((int *)varp)) {
              tmp = "";
            } else {
              tmp = "no";
            }
            {
            tmp___0 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"set %s%s",
                              tmp, p___0->fullname);
            }
            if (tmp___0 < 0) {
              return (0);
            }
          } else { //Added block
          if ((int )p___0->flags & 2) {
            {
            tmp___1 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"set %s=%ld",
                              p___0->fullname, *((long *)varp));
            }
            if (tmp___1 < 0) {
              return (0);
            }
          } else {
            {
            tmp___2 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"set %s=",
                              p___0->fullname);
            }
            if (tmp___2 < 0) {
              return (0);
            }
            s = *((char_u **)varp);
            if ((unsigned long )s != (unsigned long )((void *)0)) {
              {
              tmp___3 = putescstr(fd, s, 1);
              }
              if (tmp___3 == 0) {
                return (0);
              }
            }
          }
          }
          {
          tmp___4 = put_eol(fd);
          }
          if (tmp___4 < 0) {
            return (0);
          }
        }
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
void clear_termoptions(void) 
{ 
  struct vimoption *p___0 ;
  int tmp ;

  {
  {
  mch_setmouse(0);
  clear_xterm_clip();
  mch_restore_title(3);
  stoptermcap();
  p___0 = & options[0];
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0->fullname != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = istermoption(p___0);
    }
    if (tmp) {
      if ((int )p___0->flags & 8) {
        {
        free_string_option(*((char_u **)p___0->var));
        }
      }
      if ((int )p___0->flags & 128) {
        {
        free_string_option(p___0->def_val[0]);
        }
      }
      *((char_u **)p___0->var) = empty_option;
      p___0->def_val[0] = empty_option;
      p___0->flags = (short_u )((int )p___0->flags & -137);
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  clear_termcodes();
  }
  return;
}
}
void set_term_defaults(void) 
{ 
  struct vimoption *p___0 ;
  int tmp ;

  {
  p___0 = & options[0];
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0->fullname != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = istermoption(p___0);
    }
    if (tmp) {
      if ((unsigned long )p___0->def_val[0] != (unsigned long )*((char_u **)p___0->var)) {
        if ((int )p___0->flags & 128) {
          {
          free_string_option(p___0->def_val[0]);
          p___0->flags = (short_u )((int )p___0->flags & -129);
          }
        }
        p___0->def_val[0] = *((char_u **)p___0->var);
        if ((int )p___0->flags & 8) {
          p___0->flags = (short_u )((int )p___0->flags | 128);
          p___0->flags = (short_u )((int )p___0->flags & -9);
        }
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int istermoption(struct vimoption *p___0 ) 
{ 
  int tmp ;

  {
  if ((int )*(p___0->fullname + 0) == 116) {
    if ((int )*(p___0->fullname + 1) == 95) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void comp_col(void) 
{ 
  int last_has_status ;
  int tmp ;
  int tmp___0 ;

  {
  if (p_ls == 2L) {
    tmp = 1;
  } else { //Added block
  if (p_ls == 1L) {
    if ((unsigned long )firstwin != (unsigned long )lastwin) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  }
  last_has_status = tmp;
  sc_col = 0;
  ru_col = 0;
  if (p_ru) {
    if (ru_wid) {
      tmp___0 = ru_wid;
    } else {
      tmp___0 = 17;
    }
    ru_col = tmp___0 + 1;
    if (! last_has_status) {
      sc_col = ru_col;
    }
  }
  if (p_sc) {
    sc_col += 10;
    if (! p_ru) {
      sc_col ++;
    } else { //Added block
    if (last_has_status) {
      sc_col ++;
    }
    }
  }
  sc_col = (int )(Columns - (long )sc_col);
  ru_col = (int )(Columns - (long )ru_col);
  if (sc_col <= 0) {
    sc_col = 1;
  }
  if (ru_col <= 0) {
    ru_col = 1;
  }
  return;
}
}
static char_u *get_varp(struct vimoption *p___0 ) 
{ 


  {
  if (! ((int )p___0->flags & 32)) {
    return (p___0->var);
  } else { //Added block
  if ((unsigned long )p___0->var == (unsigned long )((void *)0)) {
    return (p___0->var);
  }
  }
  {
  if ((long )p___0->var == 20L) {
    goto case_20;
  }
  if ((long )p___0->var == 25L) {
    goto case_25;
  }
  if ((long )p___0->var == 29L) {
    goto case_29;
  }
  if ((long )p___0->var == 41L) {
    goto case_41;
  }
  if ((long )p___0->var == 18L) {
    goto case_18;
  }
  if ((long )p___0->var == 35L) {
    goto case_35;
  }
  if ((long )p___0->var == 1L) {
    goto case_1;
  }
  if ((long )p___0->var == 2L) {
    goto case_2;
  }
  if ((long )p___0->var == 3L) {
    goto case_3;
  }
  if ((long )p___0->var == 4L) {
    goto case_4;
  }
  if ((long )p___0->var == 5L) {
    goto case_5;
  }
  if ((long )p___0->var == 6L) {
    goto case_6;
  }
  if ((long )p___0->var == 7L) {
    goto case_7;
  }
  if ((long )p___0->var == 8L) {
    goto case_8;
  }
  if ((long )p___0->var == 9L) {
    goto case_9;
  }
  if ((long )p___0->var == 10L) {
    goto case_10;
  }
  if ((long )p___0->var == 12L) {
    goto case_12;
  }
  if ((long )p___0->var == 14L) {
    goto case_14;
  }
  if ((long )p___0->var == 13L) {
    goto case_13;
  }
  if ((long )p___0->var == 15L) {
    goto case_15;
  }
  if ((long )p___0->var == 16L) {
    goto case_16;
  }
  if ((long )p___0->var == 17L) {
    goto case_17;
  }
  if ((long )p___0->var == 19L) {
    goto case_19;
  }
  if ((long )p___0->var == 21L) {
    goto case_21;
  }
  if ((long )p___0->var == 22L) {
    goto case_22;
  }
  if ((long )p___0->var == 23L) {
    goto case_23;
  }
  if ((long )p___0->var == 24L) {
    goto case_24;
  }
  if ((long )p___0->var == 28L) {
    goto case_28;
  }
  if ((long )p___0->var == 30L) {
    goto case_30;
  }
  if ((long )p___0->var == 31L) {
    goto case_31;
  }
  if ((long )p___0->var == 32L) {
    goto case_32;
  }
  if ((long )p___0->var == 33L) {
    goto case_33;
  }
  if ((long )p___0->var == 34L) {
    goto case_34;
  }
  if ((long )p___0->var == 36L) {
    goto case_36;
  }
  if ((long )p___0->var == 37L) {
    goto case_37;
  }
  if ((long )p___0->var == 38L) {
    goto case_38;
  }
  if ((long )p___0->var == 39L) {
    goto case_39;
  }
  if ((long )p___0->var == 40L) {
    goto case_40;
  }
  goto switch_default;
  case_20: /* CIL Label */ 
  return ((char_u *)(& curwin->w_p_list));
  case_25: /* CIL Label */ 
  return ((char_u *)(& curwin->w_p_nu));
  case_29: /* CIL Label */ 
  return ((char_u *)(& curwin->w_p_scroll));
  case_41: /* CIL Label */ 
  return ((char_u *)(& curwin->w_p_wrap));
  case_18: /* CIL Label */ 
  return ((char_u *)(& curwin->w_p_lbr));
  case_35: /* CIL Label */ 
  return ((char_u *)(& curwin->w_p_scb));
  case_1: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ai));
  case_2: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_bin));
  case_3: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cin));
  case_4: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cink));
  case_5: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cino));
  case_6: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cinw));
  case_7: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_com));
  case_8: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cpt));
  case_9: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_eol));
  case_10: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_et));
  case_12: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ff));
  case_14: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ft));
  case_13: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_fo));
  case_15: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_inf));
  case_16: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_isk));
  case_17: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_key));
  case_19: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_lisp));
  case_21: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ml));
  case_22: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_mps));
  case_23: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_changed));
  case_24: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_nf));
  case_28: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ro));
  case_30: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_si));
  case_31: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_sn));
  case_32: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_sts));
  case_33: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_swf));
  case_34: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_syn));
  case_36: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_sw));
  case_37: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ts));
  case_38: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_tw));
  case_39: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_tx));
  case_40: /* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_wm));
  switch_default: /* CIL Label */ 
  {
  emsg((char_u *)"get_varp ERROR");
  }
  switch_break: /* CIL Label */ ;
  }
  return ((char_u *)(& curbuf->b_p_wm));
}
}
void win_copy_options(WIN *wp_from , WIN *wp_to ) 
{ 


  {
  wp_to->w_p_list = wp_from->w_p_list;
  wp_to->w_p_nu = wp_from->w_p_nu;
  wp_to->w_p_wrap = wp_from->w_p_wrap;
  wp_to->w_p_lbr = wp_from->w_p_lbr;
  wp_to->w_p_scb = wp_from->w_p_scb;
  return;
}
}
void buf_copy_options(BUF *bp_from , BUF *bp_to , int flags___0 ) 
{ 
  int should_copy ;
  char_u *save_p_isk ;
  int dont_do_help ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  should_copy = 1;
  save_p_isk = (char_u *)((void *)0);
  if ((unsigned long )bp_to == (unsigned long )((void *)0)) {
    return;
  } else {
    {
    tmp = buf_valid(bp_to);
    }
    if (! tmp) {
      return;
    }
  }
  if ((unsigned long )bp_from != (unsigned long )((void *)0)) {
    {
    tmp___3 = buf_valid(bp_from);
    }
    if (tmp___3) {
      if ((unsigned long )bp_from != (unsigned long )bp_to) {
        {
        tmp___0 = vim_strchr(p_cpo, 'S');
        }
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
          goto _L;
        } else { //Added block
        if (! (flags___0 & 1)) {
          _L: 
          if (bp_to->b_p_initialized) {
            should_copy = 0;
          } else { //Added block
          if (! (flags___0 & 1)) {
            {
            tmp___1 = vim_strchr(p_cpo, 's');
            }
            if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
              should_copy = 0;
            }
          }
          }
        }
        }
        if (should_copy) {
          goto _L___0;
        } else { //Added block
        if (flags___0 & 2) {
          _L___0: 
          if (flags___0 & 4) {
            if (bp_to->b_help) {
              tmp___2 = 1;
            } else { //Added block
            if (bp_from->b_help) {
              tmp___2 = 1;
            } else {
              tmp___2 = 0;
            }
            }
          } else {
            tmp___2 = 0;
          }
          dont_do_help = tmp___2;
          if (dont_do_help) {
            save_p_isk = bp_to->b_p_isk;
            bp_to->b_p_isk = (char_u *)((void *)0);
          }
          if (! bp_to->b_p_initialized) {
            {
            free_buf_options(bp_to, 1);
            bp_to->b_p_ro = 0;
            bp_to->b_p_tx = bp_from->b_p_tx;
            bp_to->b_p_ff = vim_strsave(bp_from->b_p_ff);
            }
          } else {
            {
            free_buf_options(bp_to, 0);
            }
          }
          {
          bp_to->b_p_ai = bp_from->b_p_ai;
          bp_to->b_p_ai_save = bp_from->b_p_ai_save;
          bp_to->b_p_sw = bp_from->b_p_sw;
          bp_to->b_p_tw = bp_from->b_p_tw;
          bp_to->b_p_tw_save = bp_from->b_p_tw_save;
          bp_to->b_p_tw_nobin = bp_from->b_p_tw_nobin;
          bp_to->b_p_wm = bp_from->b_p_wm;
          bp_to->b_p_wm_save = bp_from->b_p_wm_save;
          bp_to->b_p_wm_nobin = bp_from->b_p_wm_nobin;
          bp_to->b_p_bin = bp_from->b_p_bin;
          bp_to->b_p_et = bp_from->b_p_et;
          bp_to->b_p_et_nobin = bp_from->b_p_et_nobin;
          bp_to->b_p_ml = bp_from->b_p_ml;
          bp_to->b_p_ml_nobin = bp_from->b_p_ml_nobin;
          bp_to->b_p_inf = bp_from->b_p_inf;
          bp_to->b_p_swf = bp_from->b_p_swf;
          bp_to->b_p_cpt = vim_strsave(bp_from->b_p_cpt);
          bp_to->b_p_sts = bp_from->b_p_sts;
          bp_to->b_p_sn = bp_from->b_p_sn;
          bp_to->b_p_com = vim_strsave(bp_from->b_p_com);
          bp_to->b_p_fo = vim_strsave(bp_from->b_p_fo);
          bp_to->b_p_nf = vim_strsave(bp_from->b_p_nf);
          bp_to->b_p_mps = vim_strsave(bp_from->b_p_mps);
          bp_to->b_p_si = bp_from->b_p_si;
          bp_to->b_p_si_save = bp_from->b_p_si_save;
          bp_to->b_p_cin = bp_from->b_p_cin;
          bp_to->b_p_cin_save = bp_from->b_p_cin_save;
          bp_to->b_p_cink = vim_strsave(bp_from->b_p_cink);
          bp_to->b_p_cino = vim_strsave(bp_from->b_p_cino);
          bp_to->b_p_ft = empty_option;
          bp_to->b_p_cinw = vim_strsave(bp_from->b_p_cinw);
          bp_to->b_p_lisp = bp_from->b_p_lisp;
          bp_to->b_p_lisp_save = bp_from->b_p_lisp_save;
          bp_to->b_p_syn = empty_option;
          bp_to->b_p_key = vim_strsave(bp_from->b_p_key);
          }
          if (dont_do_help) {
            bp_to->b_p_isk = save_p_isk;
          } else { //Added block
          if (! keep_help_flag) {
            if (bp_from->b_help) {
              if (! bp_to->b_help) {
                if ((unsigned long )help_save_isk != (unsigned long )((void *)0)) {
                  {
                  bp_to->b_p_isk = vim_strsave(help_save_isk);
                  }
                  if ((unsigned long )bp_to->b_p_isk != (unsigned long )((void *)0)) {
                    {
                    init_chartab();
                    }
                  }
                  bp_to->b_p_ts = help_save_ts;
                  bp_to->b_help = 0;
                } else {
                  {
                  bp_to->b_p_isk = vim_strsave(bp_from->b_p_isk);
                  memmove((void *)(bp_to->b_chartab), (void const   *)(bp_from->b_chartab),
                          (size_t )256);
                  bp_to->b_p_ts = bp_from->b_p_ts;
                  bp_to->b_help = bp_from->b_help;
                  }
                }
              } else {
                {
                bp_to->b_p_isk = vim_strsave(bp_from->b_p_isk);
                memmove((void *)(bp_to->b_chartab), (void const   *)(bp_from->b_chartab),
                        (size_t )256);
                bp_to->b_p_ts = bp_from->b_p_ts;
                bp_to->b_help = bp_from->b_help;
                }
              }
            } else {
              {
              bp_to->b_p_isk = vim_strsave(bp_from->b_p_isk);
              memmove((void *)(bp_to->b_chartab), (void const   *)(bp_from->b_chartab),
                      (size_t )256);
              bp_to->b_p_ts = bp_from->b_p_ts;
              bp_to->b_help = bp_from->b_help;
              }
            }
          } else {
            {
            bp_to->b_p_isk = vim_strsave(bp_from->b_p_isk);
            memmove((void *)(bp_to->b_chartab), (void const   *)(bp_from->b_chartab),
                    (size_t )256);
            bp_to->b_p_ts = bp_from->b_p_ts;
            bp_to->b_help = bp_from->b_help;
            }
          }
          }
        }
        }
        if (should_copy) {
          bp_to->b_p_initialized = 1;
        }
      }
    }
  }
  {
  check_buf_options(bp_to);
  }
  return;
}
}
static int expand_option_idx  =    -1;
static char_u expand_option_name[5]  = {      (char_u )'t',      (char_u )'_',      (char_u )'\000',      (char_u )'\000', 
        (char_u )'\000'};
void set_context_in_set_cmd(char_u *arg ) 
{ 
  int nextchar ;
  int flags___0 ;
  int opt_idx ;
  char_u *p___0 ;
  char_u *s ;
  char_u *after_blank ;
  int is_term_option ;
  int key ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  flags___0 = 0;
  opt_idx = 0;
  after_blank = (char_u *)((void *)0);
  is_term_option = 0;
  expand_context = 4;
  if ((int )*arg == 0) {
    expand_pattern = arg;
    return;
  }
  {
  tmp = strlen((char const   *)((char *)arg));
  p___0 = (arg + tmp) - 1;
  }
  if ((int )*p___0 == 32) {
    if ((int )*(p___0 - 1) != 92) {
      expand_pattern = p___0 + 1;
      return;
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0 > (unsigned long )arg)) {
      goto while_break;
    }
    s = p___0;
    if ((int )*p___0 == 32) {
      goto _L;
    } else { //Added block
    if ((int )*p___0 == 44) {
      _L: 
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if ((unsigned long )s > (unsigned long )arg) {
          if (! ((int )*(s - 1) == 92)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        s --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    }
    if ((int )*p___0 == 32) {
      if (((p___0 - s) & 1L) == 0L) {
        p___0 ++;
        goto while_break;
      }
    }
    if ((unsigned long )after_blank == (unsigned long )((void *)0)) {
      if ((int )*p___0 == 32) {
        if (p___0 - s < 2L) {
          after_blank = p___0 + 1;
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if ((int )*p___0 == 44) {
        if ((unsigned long )p___0 == (unsigned long )s) {
          after_blank = p___0 + 1;
        }
      }
      }
    }
    p___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___0 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"no"),
                    (size_t )2);
  }
  if (tmp___0 == 0) {
    expand_context = 5;
    p___0 += 2;
  }
  {
  tmp___1 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"inv"),
                    (size_t )3);
  }
  if (tmp___1 == 0) {
    expand_context = 5;
    p___0 += 3;
  }
  arg = p___0;
  expand_pattern = arg;
  if ((int )*arg == 60) {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((int )*p___0 != 62)) {
        goto while_break___1;
      }
      tmp___2 = p___0;
      p___0 ++;
      if ((int )*tmp___2 == 0) {
        return;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    key = get_special_key_code(arg + 1);
    }
    if (key == 0) {
      expand_context = 0;
      return;
    }
    p___0 ++;
    nextchar = (int )*p___0;
    is_term_option = 1;
    expand_option_name[2] = (char_u )(key & 255);
    expand_option_name[3] = (char_u )(((unsigned int )key >> 8) & 255U);
  } else { //Added block
  if ((int )*(p___0 + 0) == 116) {
    if ((int )*(p___0 + 1) == 95) {
      p___0 += 2;
      if ((int )*p___0 != 0) {
        p___0 ++;
      }
      if ((int )*p___0 == 0) {
        return;
      }
      p___0 ++;
      nextchar = (int )*p___0;
      is_term_option = 1;
      expand_option_name[2] = *(p___0 + -2);
      expand_option_name[3] = *(p___0 + -1);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
      tmp___3 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___3 + (int )*p___0) & 8)) {
        if (! ((int )*p___0 == 95)) {
          if (! ((int )*p___0 == 42)) {
            goto while_break___2;
          }
        }
      }
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    if ((int )*p___0 == 0) {
      return;
    }
    {
    nextchar = (int )*p___0;
    *p___0 = (char_u )'\000';
    opt_idx = findoption(arg);
    *p___0 = (char_u )nextchar;
    }
    if (opt_idx == -1) {
      expand_context = 0;
      return;
    } else { //Added block
    if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
      expand_context = 0;
      return;
    }
    }
    flags___0 = (int )options[opt_idx].flags;
    if (flags___0 & 1) {
      expand_context = 0;
      return;
    }
  }
  }
  if (nextchar == 45) {
    goto _L___2;
  } else { //Added block
  if (nextchar == 43) {
    _L___2: 
    if ((int )*(p___0 + 1) == 61) {
      p___0 ++;
      nextchar = '=';
    }
  }
  }
  if (nextchar != 61) {
    if (nextchar != 58) {
      expand_context = -1;
      return;
    } else {
      goto _L___3;
    }
  } else { //Added block
  _L___3: 
  if (expand_context == 5) {
    expand_context = -1;
    return;
  }
  }
  if (expand_context != 5) {
    if ((int )*(p___0 + 1) == 0) {
      expand_context = 7;
      if (is_term_option) {
        expand_option_idx = -1;
      } else {
        expand_option_idx = opt_idx;
      }
      expand_pattern = p___0 + 1;
      return;
    }
  }
  expand_context = 0;
  if (is_term_option) {
    return;
  } else { //Added block
  if (flags___0 & 2) {
    return;
  }
  }
  if ((unsigned long )after_blank != (unsigned long )((void *)0)) {
    expand_pattern = after_blank;
  } else {
    expand_pattern = p___0 + 1;
  }
  if (flags___0 & 16) {
    p___0 = options[opt_idx].var;
    if ((unsigned long )p___0 == (unsigned long )((char_u *)(& p_bdir))) {
      goto _L___4;
    } else { //Added block
    if ((unsigned long )p___0 == (unsigned long )((char_u *)(& p_dir))) {
      goto _L___4;
    } else { //Added block
    if ((unsigned long )p___0 == (unsigned long )((char_u *)(& p_path))) {
      _L___4: 
      expand_context = 3;
      if ((unsigned long )p___0 == (unsigned long )((char_u *)(& p_path))) {
        expand_set_path = 1;
      }
    } else {
      expand_context = 2;
    }
    }
    }
  }
  return;
}
}
int ExpandSettings(vim_regexp *prog , int *num_file , char_u ***file ) 
{ 
  int num_normal ;
  int num_term ;
  int opt_idx ;
  int match ;
  int count___2 ;
  char_u *str___1 ;
  int loop ;
  int is_term_opt ;
  char_u name_buf[23] ;
  int save_reg_ic ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;

  {
  num_normal = 0;
  num_term = 0;
  count___2 = 0;
  loop = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (loop <= 1)) {
      goto while_break;
    }
    if (expand_context != 5) {
      {
      tmp___0 = vim_regexec(prog, (char_u *)"all", 1);
      }
      if (tmp___0) {
        if (loop == 0) {
          num_normal ++;
        } else {
          {
          tmp = count___2;
          count___2 ++;
          *(*file + tmp) = vim_strsave((char_u *)"all");
          }
        }
      }
      {
      tmp___2 = vim_regexec(prog, (char_u *)"termcap", 1);
      }
      if (tmp___2) {
        if (loop == 0) {
          num_normal ++;
        } else {
          {
          tmp___1 = count___2;
          count___2 ++;
          *(*file + tmp___1) = vim_strsave((char_u *)"termcap");
          }
        }
      }
    }
    opt_idx = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      str___1 = (char_u *)options[opt_idx].fullname;
      if (! ((unsigned long )str___1 != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      if (expand_context == 5) {
        if (! ((int )options[opt_idx].flags & 1)) {
          goto __Cont;
        }
      }
      {
      is_term_opt = istermoption(& options[opt_idx]);
      }
      if (is_term_opt) {
        if (num_normal > 0) {
          goto __Cont;
        }
      }
      {
      match = 0;
      tmp___4 = vim_regexec(prog, str___1, 1);
      }
      if (tmp___4) {
        match = 1;
      } else { //Added block
      if ((unsigned long )options[opt_idx].shortname != (unsigned long )((void *)0)) {
        {
        tmp___5 = vim_regexec(prog, (char_u *)options[opt_idx].shortname, 1);
        }
        if (tmp___5) {
          match = 1;
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (is_term_opt) {
        {
        name_buf[0] = (char_u )'<';
        name_buf[1] = (char_u )'t';
        name_buf[2] = (char_u )'_';
        name_buf[3] = *(str___1 + 2);
        name_buf[4] = *(str___1 + 3);
        name_buf[5] = (char_u )'>';
        name_buf[6] = (char_u )'\000';
        tmp___3 = vim_regexec(prog, name_buf, 1);
        }
        if (tmp___3) {
          match = 1;
          str___1 = name_buf;
        }
      }
      }
      }
      if (match) {
        if (loop == 0) {
          if (is_term_opt) {
            num_term ++;
          } else {
            num_normal ++;
          }
        } else {
          {
          tmp___6 = count___2;
          count___2 ++;
          *(*file + tmp___6) = vim_strsave(str___1);
          }
        }
      }
      __Cont: 
      opt_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (expand_context != 5) {
      if (num_normal == 0) {
        opt_idx = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
          str___1 = get_termcode(opt_idx);
          }
          if (! ((unsigned long )str___1 != (unsigned long )((void *)0))) {
            goto while_break___1;
          }
          {
          tmp___7 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___7 + (int )*(str___1 + 0)) & 16384) {
            {
            tmp___8 = __ctype_b_loc();
            }
            if (! ((int const   )*(*tmp___8 + (int )*(str___1 + 1)) & 16384)) {
              goto __Cont___0;
            }
          } else {
            goto __Cont___0;
          }
          {
          name_buf[0] = (char_u )'t';
          name_buf[1] = (char_u )'_';
          name_buf[2] = *(str___1 + 0);
          name_buf[3] = *(str___1 + 1);
          name_buf[4] = (char_u )'\000';
          match = 0;
          tmp___10 = vim_regexec(prog, name_buf, 1);
          }
          if (tmp___10) {
            match = 1;
          } else {
            {
            name_buf[0] = (char_u )'<';
            name_buf[1] = (char_u )'t';
            name_buf[2] = (char_u )'_';
            name_buf[3] = *(str___1 + 0);
            name_buf[4] = *(str___1 + 1);
            name_buf[5] = (char_u )'>';
            name_buf[6] = (char_u )'\000';
            tmp___9 = vim_regexec(prog, name_buf, 1);
            }
            if (tmp___9) {
              match = 1;
            }
          }
          if (match) {
            if (loop == 0) {
              num_term ++;
            } else {
              {
              tmp___11 = count___2;
              count___2 ++;
              *(*file + tmp___11) = vim_strsave(name_buf);
              }
            }
          }
          __Cont___0: 
          opt_idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        opt_idx = 0;
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
          str___1 = get_key_name(opt_idx);
          }
          if (! ((unsigned long )str___1 != (unsigned long )((void *)0))) {
            goto while_break___2;
          }
          {
          name_buf[0] = (char_u )'<';
          strcpy((char * __restrict  )((char *)(name_buf + 1)), (char const   * __restrict  )((char *)str___1));
          strcat((char * __restrict  )((char *)(name_buf)), (char const   * __restrict  )((char *)">"));
          save_reg_ic = reg_ic;
          reg_ic = 1;
          tmp___13 = vim_regexec(prog, name_buf, 1);
          }
          if (tmp___13) {
            if (loop == 0) {
              num_term ++;
            } else {
              {
              tmp___12 = count___2;
              count___2 ++;
              *(*file + tmp___12) = vim_strsave(name_buf);
              }
            }
          }
          reg_ic = save_reg_ic;
          opt_idx ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    if (loop == 0) {
      if (num_normal > 0) {
        *num_file = num_normal;
      } else { //Added block
      if (num_term > 0) {
        *num_file = num_term;
      } else {
        return (1);
      }
      }
      {
      tmp___14 = alloc((unsigned int )((unsigned long )*num_file * sizeof(char_u *)));
      *file = (char_u **)tmp___14;
      }
      if ((unsigned long )*file == (unsigned long )((void *)0)) {
        *file = (char_u **)"";
        return (0);
      }
    }
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
int ExpandOldSetting(int *num_file , char_u ***file ) 
{ 
  char_u *var___0 ;
  char_u *buf___3 ;
  char_u *tmp ;

  {
  {
  var___0 = (char_u *)((void *)0);
  *num_file = 0;
  tmp = alloc((unsigned int )sizeof(char_u *));
  *file = (char_u **)tmp;
  }
  if ((unsigned long )*file == (unsigned long )((void *)0)) {
    return (0);
  }
  if (expand_option_idx < 0) {
    {
    var___0 = find_termcode(expand_option_name + 2);
    }
    if ((unsigned long )var___0 == (unsigned long )((void *)0)) {
      {
      expand_option_idx = findoption(expand_option_name);
      }
    }
  }
  if (expand_option_idx >= 0) {
    {
    option_value2string(& options[expand_option_idx]);
    var___0 = NameBuff;
    }
  } else { //Added block
  if ((unsigned long )var___0 == (unsigned long )((void *)0)) {
    var___0 = (char_u *)"";
  }
  }
  {
  buf___3 = vim_strsave_escaped(var___0, escape_chars);
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    {
    vim_free((void *)*file);
    *file = (char_u **)((void *)0);
    }
    return (0);
  }
  *(*(file + 0)) = buf___3;
  *num_file = 1;
  return (1);
}
}
static void option_value2string(struct vimoption *opp ) 
{ 
  char_u *varp ;
  long wc ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  {
  varp = get_varp(opp);
  }
  if ((int )opp->flags & 2) {
    if ((unsigned long )((long *)varp) == (unsigned long )(& p_wc)) {
      goto _L;
    } else { //Added block
    if ((unsigned long )((long *)varp) == (unsigned long )(& p_wcm)) {
      _L: 
      wc = *((long *)varp);
      if (wc >= 512L) {
        {
        tmp = get_special_key_name((int )wc, 0);
        strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)tmp));
        }
      } else {
        {
        tmp___1 = find_special_key_in_table((int )wc);
        }
        if (tmp___1 >= 0) {
          {
          tmp = get_special_key_name((int )wc, 0);
          strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)tmp));
          }
        } else {
          {
          tmp___0 = transchar((int )wc);
          strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)tmp___0));
          }
        }
      }
    } else {
      {
      sprintf((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )"%ld",
              *((long *)varp));
      }
    }
    }
  } else {
    varp = *((char_u **)varp);
    if ((unsigned long )varp == (unsigned long )((void *)0)) {
      *(NameBuff + 0) = (char_u )'\000';
    }
    if ((unsigned long )opp->var == (unsigned long )((char_u *)17)) {
      if (*varp) {
        {
        strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)"*****"));
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if ((int )opp->flags & 16) {
      {
      home_replace((BUF *)((void *)0), varp, NameBuff, 1024, 0);
      }
    } else { //Added block
    if ((unsigned long )((char_u **)opp->var) == (unsigned long )(& p_pt)) {
      {
      str2specialbuf(p_pt, NameBuff, 1024);
      }
    } else {
      {
      strncpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)varp),
              (size_t )1024);
      }
    }
    }
    }
  }
  return;
}
}
int has_format_option(int x___0 ) 
{ 
  char_u *tmp ;

  {
  if (p_paste) {
    return (0);
  }
  {
  tmp = vim_strchr(curbuf->b_p_fo, x___0);
  }
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
int shortmess(int x___0 ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = vim_strchr(p_shm, x___0);
  }
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    tmp___2 = 1;
  } else {
    {
    tmp___0 = vim_strchr(p_shm, 'a');
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
      tmp___1 = vim_strchr((char_u *)"rmfixlnw", x___0);
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  }
  return (tmp___2);
}
}
static int old_p_paste  =    0;
static int save_sm___0  =    0;
static int save_ru  =    0;
static void paste_option_changed(void) 
{ 
  BUF *buf___3 ;

  {
  if (p_paste) {
    if (! old_p_paste) {
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
          goto while_break;
        }
        buf___3->b_p_tw_save = buf___3->b_p_tw;
        buf___3->b_p_wm_save = buf___3->b_p_wm;
        buf___3->b_p_sts_save = buf___3->b_p_sts;
        buf___3->b_p_ai_save = buf___3->b_p_ai;
        buf___3->b_p_si_save = buf___3->b_p_si;
        buf___3->b_p_cin_save = buf___3->b_p_cin;
        buf___3->b_p_lisp_save = buf___3->b_p_lisp;
        buf___3 = buf___3->b_next;
      }
      while_break: /* CIL Label */ ;
      }
      save_sm___0 = p_sm;
      save_ru = p_ru;
    }
    buf___3 = firstbuf;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      buf___3->b_p_tw = 0L;
      buf___3->b_p_wm = 0L;
      buf___3->b_p_sts = 0L;
      buf___3->b_p_ai = 0;
      buf___3->b_p_si = 0;
      buf___3->b_p_cin = 0;
      buf___3->b_p_lisp = 0;
      buf___3 = buf___3->b_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    p_sm = 0;
    if (p_ru) {
      {
      status_redraw_all();
      }
    }
    p_ru = 0;
  } else { //Added block
  if (old_p_paste) {
    buf___3 = firstbuf;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
        goto while_break___1;
      }
      buf___3->b_p_tw = buf___3->b_p_tw_save;
      buf___3->b_p_wm = buf___3->b_p_wm_save;
      buf___3->b_p_sts = buf___3->b_p_sts_save;
      buf___3->b_p_ai = buf___3->b_p_ai_save;
      buf___3->b_p_si = buf___3->b_p_si_save;
      buf___3->b_p_cin = buf___3->b_p_cin_save;
      buf___3->b_p_lisp = buf___3->b_p_lisp_save;
      buf___3 = buf___3->b_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    p_sm = save_sm___0;
    if (p_ru != save_ru) {
      {
      status_redraw_all();
      }
    }
    p_ru = save_ru;
  }
  }
  old_p_paste = p_paste;
  return;
}
}
void vimrc_found(void) 
{ 
  int opt_idx ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = option_was_set((char_u *)"cp");
  }
  if (! tmp___0) {
    p_cp = 0;
    opt_idx = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = istermoption(& options[opt_idx]);
      }
      if (tmp) {
        goto while_break;
      }
      if (! ((int )options[opt_idx].flags & 1280)) {
        {
        set_option_default(opt_idx, 1);
        }
      }
      opt_idx ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    init_chartab();
    }
  }
  return;
}
}
void change_compatible(int on ) 
{ 
  int tmp ;

  {
  if (p_cp != on) {
    {
    p_cp = on;
    compatible_set();
    }
  }
  {
  tmp = findoption((char_u *)"cp");
  options[tmp].flags = (short_u )((int )options[tmp].flags | 256);
  }
  return;
}
}
int option_was_set(char_u *name___1 ) 
{ 
  int idx ;

  {
  {
  idx = findoption(name___1);
  }
  if (idx < 0) {
    return (0);
  }
  if ((int )options[idx].flags & 256) {
    return (1);
  }
  return (0);
}
}
static void compatible_set(void) 
{ 
  int opt_idx ;
  int tmp ;

  {
  opt_idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = istermoption(& options[opt_idx]);
    }
    if (tmp) {
      goto while_break;
    }
    if ((int )options[opt_idx].flags & 2048) {
      if (p_cp) {
        {
        set_option_default(opt_idx, 1);
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (! ((int )options[opt_idx].flags & 1024)) {
      if (! p_cp) {
        {
        set_option_default(opt_idx, 1);
        }
      }
    }
    }
    opt_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  init_chartab();
  }
  return;
}
}
static void fill_breakat_flags(void) 
{ 
  char_u *c ;
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 256)) {
      goto while_break;
    }
    breakat_flags[i___0] = (char)0;
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )p_breakat != (unsigned long )((void *)0)) {
    c = p_breakat;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! *c) {
        goto while_break___0;
      }
      breakat_flags[*c] = (char)1;
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
static int check_opt_strings(char_u *val , char **values , int list ) 
{ 
  int i___0 ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *val) {
      goto while_break;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )*(values + i___0) == (unsigned long )((void *)0)) {
        return (0);
      }
      {
      tmp = strlen((char const   *)*(values + i___0));
      len___0 = (int )tmp;
      tmp___0 = strncmp((char const   *)*(values + i___0), (char const   *)((char *)val),
                        (size_t )len___0);
      }
      if (tmp___0 == 0) {
        if (list) {
          if ((int )*(val + len___0) == 44) {
            val += len___0 + 1;
            goto while_break___0;
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if ((int )*(val + len___0) == 0) {
          return (1);
        }
        }
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int check_opt_wim(void) 
{ 
  char_u new_wim_flags[4] ;
  char_u *p___0 ;
  int i___0 ;
  int idx ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  idx = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 4)) {
      goto while_break;
    }
    new_wim_flags[i___0] = (char_u )0;
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  p___0 = p_wim;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break___0;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp + (int )*(p___0 + i___0)) & 1024)) {
        goto while_break___1;
      }
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((int )*(p___0 + i___0) != 0) {
      if ((int )*(p___0 + i___0) != 44) {
        if ((int )*(p___0 + i___0) != 58) {
          return (0);
        }
      }
    }
    if (i___0 == 7) {
      {
      tmp___2 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"longest"),
                        (size_t )7);
      }
      if (tmp___2 == 0) {
        new_wim_flags[idx] = (char_u )((int )new_wim_flags[idx] | 2);
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (i___0 == 4) {
      {
      tmp___1 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"full"),
                        (size_t )4);
      }
      if (tmp___1 == 0) {
        new_wim_flags[idx] = (char_u )((int )new_wim_flags[idx] | 1);
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (i___0 == 4) {
      {
      tmp___0 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"list"),
                        (size_t )4);
      }
      if (tmp___0 == 0) {
        new_wim_flags[idx] = (char_u )((int )new_wim_flags[idx] | 4);
      } else {
        return (0);
      }
    } else {
      return (0);
    }
    }
    }
    p___0 += i___0;
    if ((int )*p___0 == 0) {
      goto while_break___0;
    }
    if ((int )*p___0 == 44) {
      if (idx == 3) {
        return (0);
      }
      idx ++;
    }
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (idx < 3)) {
      goto while_break___2;
    }
    new_wim_flags[idx + 1] = new_wim_flags[idx];
    idx ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (i___0 < 4)) {
      goto while_break___3;
    }
    wim_flags[i___0] = new_wim_flags[i___0];
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  return (1);
}
}
int can_bs(int what ) 
{ 
  char_u *tmp ;

  {
  {
  if ((int )*p_bs == 50) {
    goto case_50;
  }
  if ((int )*p_bs == 49) {
    goto case_49;
  }
  if ((int )*p_bs == 48) {
    goto case_48;
  }
  goto switch_break;
  case_50: /* CIL Label */ 
  return (1);
  case_49: /* CIL Label */ 
  return (what != 115);
  case_48: /* CIL Label */ 
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
  tmp = vim_strchr(p_bs, what);
  }
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#pragma merger("0","/tmp/cil-tVUl1r6X.i","-O0")
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
extern void (*sigset(int  , void (*func)(int  ) ))(int  ) ;
extern Display *XOpenDisplay(char const   * ) ;
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
extern int XCloseDisplay(Display * ) ;
extern int XFlush(Display * ) ;
extern int XFree(void * ) ;
extern int XGetErrorText(Display * , int  , char * , int  ) ;
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
extern int XSync(Display * , int  ) ;
extern int XGetWMIconName(Display * , Window  , XTextProperty * ) ;
extern int XGetWMName(Display * , Window  , XTextProperty * ) ;
extern int XGetWMNormalHints(Display * , Window  , XSizeHints * , long * ) ;
extern void XSetWMIconName(Display * , Window  , XTextProperty * ) ;
extern void XSetWMName(Display * , Window  , XTextProperty * ) ;
extern void XtAppProcessEvent(XtAppContext  , XtInputMask  ) ;
extern XtInputMask XtAppPending(XtAppContext  ) ;
extern void XtRealizeWidget(Widget  ) ;
extern void XtDestroyWidget(Widget  ) ;
extern Widget XtVaCreatePopupShell(char const   * , WidgetClass  , Widget   , ...)  __attribute__((__sentinel__(0))) ;
extern Widget XtVaAppCreateShell(char const   * , char const   * , WidgetClass  ,
                                 Display *  , ...)  __attribute__((__sentinel__(0))) ;
extern Display *XtOpenDisplay(XtAppContext  , char const   * , char const   * , char const   * ,
                              XrmOptionDescRec * , Cardinal  , int * , char ** ) ;
void mch_write(char_u *s , int len___0 ) ;
int mch_inchar(char_u *buf___3 , int maxlen , long wtime ) ;
int mch_char_avail(void) ;
void mch_delay(long msec , int ignoreinput ) ;
void mch_suspend(void) ;
int vim_is_xterm(char_u *name___1 ) ;
int use_xterm_mouse(void) ;
int vim_is_iris(char_u *name___1 ) ;
int vim_is_fastterm(char_u *name___1 ) ;
void mch_settmode(int tmode ) ;
void get_stty(void) ;
int mch_get_winsize(void) ;
void mch_set_winsize(void) ;
void mch_breakcheck(void) ;
void setup_xterm_clip(void) ;
void start_xterm_trace(int button ) ;
void stop_xterm_trace(void) ;
int clip_xterm_own_selection(void) ;
void clip_xterm_lose_selection(void) ;
void clip_xterm_request_selection(void) ;
void clip_xterm_set_selection(void) ;
void set_mouse_termcode(int n , char_u *s ) ;
void del_mouse_termcode(int n ) ;
void getlinecol(void) ;
int term_is_8bit(char_u *name___1 ) ;
void out_str_nf(char_u *s ) ;
void term_set_winsize(int width , int height ) ;
void term_settitle(char_u *title ) ;
int vim_is_input_buf_full(void) ;
int vim_is_input_buf_empty(void) ;
void add_to_input_buf(char_u *s , int len___0 ) ;
int read_from_input_buf(char_u *buf___3 , long maxlen ) ;
void fill_input_buf(int exit_on_error ) ;
int check_col(int col ) ;
int check_row(int row ) ;
void open_app_context(void) ;
void x11_setup_atoms(Display *dpy ) ;
void clip_x11_request_selection(Widget myShell , Display *dpy ) ;
void clip_x11_lose_selection(Widget myShell ) ;
int clip_x11_own_selection(Widget myShell ) ;
void clip_x11_set_selection(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
extern __pid_t wait(int *__stat_loc ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
extern int select(int  , fd_set * , fd_set * , fd_set * , struct timeval * ) ;
extern WidgetClass topLevelShellWidgetClass ;
extern WidgetClass applicationShellWidgetClass ;
extern char const   XtStrings[] ;
static Widget xterm_Shell  =    (Widget )0;
static void xterm_update(void) ;
Window x11_window  =    (Window )0;
Display *x11_display  =    (Display *)((void *)0);
int got_x_error  =    0;
static int get_x11_windis(void) ;
static void set_x11_title(char_u *title ) ;
static void set_x11_icon(char_u *icon ) ;
static int get_x11_title(int test_only ) ;
static int get_x11_icon(int test_only ) ;
static char_u *oldtitle  =    (char_u *)((void *)0);
static int did_set_title___0  =    0;
static char_u *oldicon  =    (char_u *)((void *)0);
static int did_set_icon  =    0;
static void may_core_dump(void) ;
static int WaitForChar(long msec ) ;
static int RealWaitForChar(int fd , long msec , int *check_for_gpm ) ;
static int do_xterm_trace(void) ;
static void handle_resize(void) ;
static void sig_winch(int sigarg ) ;
static void catch_sigint(int sigarg ) ;
static void sig_alarm(int sigarg ) ;
static void deathtrap(int sigarg ) ;
static void set_signals(void) ;
static void catch_signals(void (*func_deadly)() , void (*func_other)() ) ;
static int have_wildcard(int num , char_u **file ) ;
static int have_dollars(int num , char_u **file ) ;
static int pstrcmp(void const   *a , void const   *b ) ;
static int unix_expandpath(struct growarray *gap , char_u *path , int wildoff , int flags___0 ) ;
static int save_patterns(int num_pat , char_u **pat , int *num_file , char_u ***file ) ;
static int do_resize___0  =    0;
static char_u *extra_shell_arg  =    (char_u *)((void *)0);
static int show_shell_mess  =    1;
static int deadly_signal  =    0;
static int curr_tmode  =    0;
static struct signalinfo signal_info[22]  = 
  {      {1, (char *)"HUP", (char)1}, 
        {3, (char *)"QUIT", (char)1}, 
        {4, (char *)"ILL", (char)1}, 
        {5, (char *)"TRAP", (char)1}, 
        {6, (char *)"ABRT", (char)1}, 
        {8, (char *)"FPE", (char)1}, 
        {7, (char *)"BUS", (char)1}, 
        {11, (char *)"SEGV", (char)1}, 
        {31, (char *)"SYS", (char)1}, 
        {14, (char *)"ALRM", (char)0}, 
        {15, (char *)"TERM", (char)1}, 
        {26, (char *)"VTALRM", (char)1}, 
        {27, (char *)"PROF", (char)1}, 
        {24, (char *)"XCPU", (char)1}, 
        {25, (char *)"XFSZ", (char)1}, 
        {10, (char *)"USR1", (char)1}, 
        {12, (char *)"USR2", (char)1}, 
        {2, (char *)"INT", (char)0}, 
        {28, (char *)"WINCH", (char)0}, 
        {20, (char *)"TSTP", (char)0}, 
        {13, (char *)"PIPE", (char)0}, 
        {-1, (char *)"Unknown!", (char)0}};
void mch_write(char_u *s , int len___0 ) 
{ 


  {
  {
  write(1, (void const   *)((char *)s), (size_t )len___0);
  }
  if (p_wd) {
    {
    RealWaitForChar(read_cmd_fd, p_wd, (int *)((void *)0));
    }
  }
  return;
}
}
static int once_already  =    0;
int mch_inchar(char_u *buf___3 , int maxlen , long wtime ) 
{ 
  int len___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (do_resize___0) {
    {
    handle_resize();
    }
  }
  if (wtime >= 0L) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = WaitForChar(wtime);
      }
      if (! (tmp == 0)) {
        goto while_break;
      }
      if (! do_resize___0) {
        once_already = 0;
        return (0);
      }
      {
      handle_resize();
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if (once_already == 2) {
    {
    updatescript(0);
    }
  } else { //Added block
  if (once_already == 1) {
    {
    setcursor();
    once_already = 2;
    }
    return (0);
  } else {
    {
    tmp___2 = WaitForChar(p_ut);
    }
    if (tmp___2 == 0) {
      {
      tmp___0 = has_cursorhold();
      }
      if (tmp___0) {
        {
        tmp___1 = get_real_state();
        }
        if (tmp___1 == 257) {
          {
          apply_autocmds((EVENT_T )39, (char_u *)((void *)0), (char_u *)((void *)0),
                         0, curbuf);
          update_screen(10);
          once_already = 1;
          }
          return (0);
        } else {
          {
          updatescript(0);
          }
        }
      } else {
        {
        updatescript(0);
        }
      }
    }
  }
  }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (do_resize___0) {
      {
      handle_resize();
      }
    }
    {
    WaitForChar(-1L);
    }
    if (do_resize___0) {
      goto __Cont;
    }
    {
    len___0 = read_from_input_buf(buf___3, (long )maxlen);
    }
    if (len___0 > 0) {
      once_already = 0;
      return (len___0);
    }
    __Cont: ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
static void handle_resize(void) 
{ 


  {
  {
  do_resize___0 = 0;
  set_winsize(0, 0, 0);
  }
  return;
}
}
int mch_char_avail(void) 
{ 
  int tmp ;

  {
  {
  tmp = WaitForChar(0L);
  }
  return (tmp);
}
}
void mch_delay(long msec , int ignoreinput ) 
{ 
  int old_tmode ;
  struct timespec ts ;

  {
  if (ignoreinput) {
    {
    old_tmode = curr_tmode;
    settmode(1);
    ts.tv_sec = msec / 1000L;
    ts.tv_nsec = (msec % 1000L) * 1000000L;
    nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
    settmode(old_tmode);
    }
  } else {
    {
    WaitForChar(msec);
    }
  }
  return;
}
}
static void sig_winch(int sigarg ) 
{ 


  {
  {
  sigset(28, (void (*)(int  ))((void (*)())(& sig_winch)));
  do_resize___0 = 1;
  }
  return;
}
}
static void catch_sigint(int sigarg ) 
{ 


  {
  {
  sigset(2, (void (*)(int  ))((void (*)())(& catch_sigint)));
  got_int = 1;
  }
  return;
}
}
static void sig_alarm(int sigarg ) 
{ 


  {
  return;
}
}
static int entered___1  =    0;
static void deathtrap(int sigarg ) 
{ 
  int i___0 ;

  {
  entered___1 ++;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (signal_info[i___0].sig != -1)) {
      goto while_break;
    }
    if (sigarg == signal_info[i___0].sig) {
      goto while_break;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  deadly_signal = sigarg;
  full_screen = 0;
  if (entered___1 >= 3) {
    {
    reset_signals();
    may_core_dump();
    }
    if (entered___1 >= 4) {
      {
      _exit(8);
      }
    }
    {
    exit(7);
    }
  }
  if (entered___1 == 2) {
    {
    out_str((char_u *)"Vim: Double signal, exiting\n");
    out_flush();
    getout(1);
    }
  }
  {
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Vim: Caught %s %s\n",
          "deadly signal", signal_info[i___0].name);
  preserve_exit();
  }
  return;
}
}
void mch_suspend(void) 
{ 


  {
  {
  out_flush();
  settmode(0);
  out_flush();
  kill(0, 20);
  vim_free((void *)oldtitle);
  oldtitle = (char_u *)((void *)0);
  settmode(2);
  need_check_timestamps = 1;
  }
  return;
}
}
void mch_windinit(void) 
{ 


  {
  {
  Columns = 80L;
  Rows = 24L;
  out_flush();
  set_signals();
  }
  return;
}
}
static void set_signals(void) 
{ 
  void (*tmp)(int  ) ;

  {
  {
  sigset(28, (void (*)(int  ))((void (*)())(& sig_winch)));
  }
  if (restricted) {
    tmp = (void (*)(int  ))1;
  } else {
    tmp = (void (*)(int  ))0;
  }
  {
  sigset(20, tmp);
  sigset(13, (void (*)(int  ))1);
  sigset(2, (void (*)(int  ))((void (*)())(& catch_sigint)));
  sigset(14, (void (*)(int  ))1);
  catch_signals((void (*)())(& deathtrap), (void (*)())((void (*)(int  ))-1));
  }
  return;
}
}
void reset_signals(void) 
{ 


  {
  {
  catch_signals((void (*)())((void (*)(int  ))0), (void (*)())((void (*)(int  ))0));
  }
  return;
}
}
static void catch_signals(void (*func_deadly)() , void (*func_other)() ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (signal_info[i___0].sig != -1)) {
      goto while_break;
    }
    if (signal_info[i___0].deadly) {
      {
      sigset(signal_info[i___0].sig, (void (*)(int  ))func_deadly);
      }
    } else { //Added block
    if ((unsigned long )func_other != (unsigned long )((void (*)(int  ))-1)) {
      {
      sigset(signal_info[i___0].sig, (void (*)(int  ))func_other);
      }
    }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int mch_check_win(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
  tmp = isatty(1);
  }
  if (tmp) {
    return (1);
  }
  return (0);
}
}
int mch_input_isatty(void) 
{ 
  int tmp ;

  {
  {
  tmp = isatty(read_cmd_fd);
  }
  if (tmp) {
    return (1);
  }
  return (0);
}
}
static int x_error_handler(Display *dpy , XErrorEvent *error_event ) ;
static int x_error_check(Display *dpy , XErrorEvent *error_event ) ;
static int test_x11_window(Display *dpy ) ;
static int x_error_handler(Display *dpy , XErrorEvent *error_event ) 
{ 


  {
  {
  XGetErrorText(dpy, (int )error_event->error_code, (char *)IObuff, 1025);
  strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"\nVim: Got X error\n"));
  preserve_exit();
  }
  return (0);
}
}
static int x_error_check(Display *dpy , XErrorEvent *error_event ) 
{ 


  {
  got_x_error = 1;
  return (0);
}
}
static int test_x11_window(Display *dpy ) 
{ 
  int (*old_handler)() ;
  XTextProperty text_prop ;
  int (*tmp)(Display * , XErrorEvent * ) ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = XSetErrorHandler(& x_error_check);
  old_handler = (int (*)())tmp;
  got_x_error = 0;
  tmp___0 = XGetWMName(dpy, x11_window, & text_prop);
  }
  if (tmp___0) {
    {
    XFree((void *)text_prop.value);
    }
  }
  {
  XSync(dpy, 0);
  XSetErrorHandler((int (*)(Display * , XErrorEvent * ))old_handler);
  }
  if (got_x_error) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static int get_x11_thing(int get_title , int test_only ) ;
static int result  =    -1;
static int x11_display_from  =    0;
static int get_x11_windis(void) 
{ 
  char *winid ;
  long tmp ;
  int tmp___0 ;
  void (*sig_save)() ;
  void (*tmp___1)(int  ) ;
  int tmp___2 ;

  {
  {
  XSetErrorHandler(& x_error_handler);
  }
  if (x11_window == 0UL) {
    {
    winid = getenv("WINDOWID");
    }
    if ((unsigned long )winid != (unsigned long )((void *)0)) {
      {
      tmp = atol((char const   *)winid);
      x11_window = (Window )tmp;
      }
    }
  }
  if ((unsigned long )xterm_dpy != (unsigned long )((void *)0)) {
    if (x11_window != 0UL) {
      if (x11_display_from == 1) {
        if ((unsigned long )x11_display != (unsigned long )((void *)0)) {
          {
          XCloseDisplay(x11_display);
          }
        }
      }
      {
      x11_display = xterm_dpy;
      x11_display_from = 3;
      tmp___0 = test_x11_window(x11_display);
      }
      if (tmp___0 == 0) {
        x11_window = (Window )0;
        x11_display = (Display *)((void *)0);
        x11_display_from = 0;
        return (0);
      }
      return (1);
    }
  }
  if (x11_window == 0UL) {
    result = -1;
  } else { //Added block
  if ((unsigned long )x11_display == (unsigned long )((void *)0)) {
    result = -1;
  }
  }
  if (result != -1) {
    return (result);
  }
  if (x11_window != 0UL) {
    if ((unsigned long )x11_display == (unsigned long )((void *)0)) {
      {
      tmp___1 = sigset(14, (void (*)(int  ))((void (*)())(& sig_alarm)));
      sig_save = (void (*)())tmp___1;
      alarm(2U);
      x11_display = XOpenDisplay((char const   *)((void *)0));
      alarm(0U);
      sigset(14, (void (*)(int  ))sig_save);
      }
      if ((unsigned long )x11_display != (unsigned long )((void *)0)) {
        {
        tmp___2 = test_x11_window(x11_display);
        }
        if (tmp___2 == 0) {
          {
          x11_window = (Window )0;
          XCloseDisplay(x11_display);
          x11_display = (Display *)((void *)0);
          }
        } else {
          x11_display_from = 1;
        }
      }
    }
  }
  if (x11_window == 0UL) {
    result = 0;
    return (result);
  } else { //Added block
  if ((unsigned long )x11_display == (unsigned long )((void *)0)) {
    result = 0;
    return (result);
  }
  }
  result = 1;
  return (result);
}
}
static int get_x11_title(int test_only ) 
{ 
  int retval ;

  {
  {
  retval = get_x11_thing(1, test_only);
  }
  return (retval);
}
}
static int get_x11_icon(int test_only ) 
{ 
  int retval ;
  int tmp ;

  {
  {
  retval = 0;
  retval = get_x11_thing(0, test_only);
  }
  if ((unsigned long )oldicon == (unsigned long )((void *)0)) {
    if (! test_only) {
      {
      tmp = strncmp((char const   *)((char *)term_strings[0]), (char const   *)((char *)"builtin_"),
                    (size_t )8);
      }
      if (tmp == 0) {
        oldicon = term_strings[0] + 8;
      } else {
        oldicon = term_strings[0];
      }
    }
  }
  return (retval);
}
}
static int get_x11_thing(int get_title , int test_only ) 
{ 
  XTextProperty text_prop ;
  int retval ;
  int status ;
  Window root ;
  Window parent ;
  Window win ;
  Window *children ;
  unsigned int num_children ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  retval = 0;
  tmp___1 = get_x11_windis();
  }
  if (tmp___1 == 1) {
    if (get_title) {
      {
      status = XGetWMName(x11_display, x11_window, & text_prop);
      }
    } else {
      {
      status = XGetWMIconName(x11_display, x11_window, & text_prop);
      }
    }
    {
    tmp___0 = vim_is_xterm(term_strings[0]);
    }
    if (tmp___0) {
      win = x11_window;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (! status)) {
          if (! ((unsigned long )text_prop.value == (unsigned long )((void *)0))) {
            goto while_break;
          }
        }
        {
        tmp = XQueryTree(x11_display, win, & root, & parent, & children, & num_children);
        }
        if (! tmp) {
          goto while_break;
        }
        if (children) {
          {
          XFree((void *)children);
          }
        }
        if (parent == root) {
          goto while_break;
        } else { //Added block
        if (parent == 0UL) {
          goto while_break;
        }
        }
        win = parent;
        if (get_title) {
          {
          status = XGetWMName(x11_display, win, & text_prop);
          }
        } else {
          {
          status = XGetWMIconName(x11_display, win, & text_prop);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    if (status) {
      if ((unsigned long )text_prop.value != (unsigned long )((void *)0)) {
        retval = 1;
        if (! test_only) {
          if (get_title) {
            {
            oldtitle = vim_strsave(text_prop.value);
            }
          } else {
            {
            oldicon = vim_strsave(text_prop.value);
            }
          }
        }
        {
        XFree((void *)text_prop.value);
        }
      }
    }
  }
  return (retval);
}
}
static void set_x11_title(char_u *title ) 
{ 
  XTextProperty text_prop ;

  {
  {
  text_prop.value = title;
  text_prop.nitems = strlen((char const   *)((char *)title));
  text_prop.encoding = (Atom )31;
  text_prop.format = 8;
  XSetWMName(x11_display, x11_window, & text_prop);
  XFlush(x11_display);
  }
  return;
}
}
static void set_x11_icon(char_u *icon ) 
{ 
  XTextProperty text_prop ;

  {
  {
  text_prop.value = icon;
  text_prop.nitems = strlen((char const   *)((char *)icon));
  text_prop.encoding = (Atom )31;
  text_prop.format = 8;
  XSetWMIconName(x11_display, x11_window, & text_prop);
  XFlush(x11_display);
  }
  return;
}
}
int mch_can_restore_title(void) 
{ 
  int tmp ;

  {
  {
  tmp = get_x11_title(1);
  }
  return (tmp);
}
}
int mch_can_restore_icon(void) 
{ 
  int tmp ;

  {
  {
  tmp = get_x11_icon(1);
  }
  return (tmp);
}
}
static int recursive___1  =    0;
void mch_settitle(char_u *title , char_u *icon ) 
{ 
  int type ;
  int tmp ;

  {
  type = 0;
  if ((unsigned long )term_strings[0] == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )title == (unsigned long )((void *)0)) {
    if ((unsigned long )icon == (unsigned long )((void *)0)) {
      return;
    }
  }
  if (recursive___1) {
    return;
  }
  {
  recursive___1 ++;
  tmp = get_x11_windis();
  }
  if (tmp == 1) {
    type = 1;
  }
  if (type) {
    goto _L;
  } else { //Added block
  if ((int )*(term_strings[45]) != 0) {
    _L: 
    if ((unsigned long )title != (unsigned long )((void *)0)) {
      if ((unsigned long )oldtitle == (unsigned long )((void *)0)) {
        {
        get_x11_title(0);
        }
      }
      if ((int )*(term_strings[45]) != 0) {
        {
        term_settitle(title);
        }
      } else {
        {
        set_x11_title(title);
        }
      }
      did_set_title___0 = 1;
    }
  }
  }
  if (type) {
    goto _L___0;
  } else { //Added block
  if ((int )*(term_strings[43]) != 0) {
    _L___0: 
    if ((unsigned long )icon != (unsigned long )((void *)0)) {
      if ((unsigned long )oldicon == (unsigned long )((void *)0)) {
        {
        get_x11_icon(0);
        }
      }
      if ((int )*(term_strings[43]) != 0) {
        {
        out_str(term_strings[43]);
        out_str_nf(icon);
        out_str(term_strings[44]);
        out_flush();
        }
      } else {
        {
        set_x11_icon(icon);
        }
      }
      did_set_icon = 1;
    }
  }
  }
  recursive___1 --;
  return;
}
}
void mch_restore_title(int which ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  if (which & 2) {
    if (did_set_icon) {
      tmp = oldicon;
    } else {
      tmp = (char_u *)((void *)0);
    }
  } else {
    tmp = (char_u *)((void *)0);
  }
  if (which & 1) {
    if (did_set_title___0) {
      if (oldtitle) {
        tmp___0 = oldtitle;
      } else {
        tmp___0 = p_titleold;
      }
      tmp___1 = tmp___0;
    } else {
      tmp___1 = (char_u *)((void *)0);
    }
  } else {
    tmp___1 = (char_u *)((void *)0);
  }
  {
  mch_settitle(tmp___1, tmp);
  }
  return;
}
}
int vim_is_xterm(char_u *name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  tmp = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"xterm"),
                    (size_t )5);
  }
  if (tmp == 0) {
    tmp___2 = 1;
  } else {
    {
    tmp___0 = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"kterm"),
                          (size_t )5);
    }
    if (tmp___0 == 0) {
      tmp___2 = 1;
    } else {
      {
      tmp___1 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"builtin_xterm"));
      }
      if (tmp___1 == 0) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    }
  }
  return (tmp___2);
}
}
int use_xterm_mouse(void) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = strncasecmp((char const   *)((char *)p_ttym), (char const   *)((char *)"xterm"),
                        (size_t )5);
  }
  if (tmp___1 == 0) {
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + (int )*(p_ttym + 5)) & 2048) {
      {
      tmp = atoi((char const   *)((char *)(p_ttym + 5)));
      }
      return (tmp);
    }
    return (1);
  }
  return (0);
}
}
int vim_is_iris(char_u *name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  tmp = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"iris-ansi"),
                    (size_t )9);
  }
  if (tmp == 0) {
    tmp___1 = 1;
  } else {
    {
    tmp___0 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"builtin_iris-ansi"));
    }
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
int vim_is_fastterm(char_u *name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  tmp = vim_is_xterm(name___1);
  }
  if (tmp) {
    return (1);
  } else {
    {
    tmp___0 = vim_is_iris(name___1);
    }
    if (tmp___0) {
      return (1);
    }
  }
  {
  tmp___1 = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"hpterm"),
                        (size_t )6);
  }
  if (tmp___1 == 0) {
    tmp___6 = 1;
  } else {
    {
    tmp___2 = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"sun-cmd"),
                          (size_t )7);
    }
    if (tmp___2 == 0) {
      tmp___6 = 1;
    } else {
      {
      tmp___3 = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"screen"),
                            (size_t )6);
      }
      if (tmp___3 == 0) {
        tmp___6 = 1;
      } else {
        {
        tmp___4 = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"rxvt"),
                              (size_t )4);
        }
        if (tmp___4 == 0) {
          tmp___6 = 1;
        } else {
          {
          tmp___5 = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"dtterm"),
                                (size_t )6);
          }
          if (tmp___5 == 0) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        }
      }
    }
  }
  return (tmp___6);
}
}
int mch_get_user_name(char_u *s , int len___0 ) 
{ 
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = getuid();
  tmp___0 = mch_get_uname(tmp, s, len___0);
  }
  return (tmp___0);
}
}
int mch_get_uname(uid_t uid , char_u *s , int len___0 ) 
{ 
  struct passwd *pw ;

  {
  {
  pw = getpwuid(uid);
  }
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
    if ((unsigned long )pw->pw_name != (unsigned long )((void *)0)) {
      if ((int )*(pw->pw_name) != 0) {
        {
        strncpy((char * __restrict  )((char *)s), (char const   * __restrict  )pw->pw_name,
                (size_t )len___0);
        }
        return (1);
      }
    }
  }
  {
  sprintf((char * __restrict  )((char *)s), (char const   * __restrict  )"%d", (int )uid);
  }
  return (0);
}
}
void mch_get_host_name(char_u *s , int len___0 ) 
{ 
  struct utsname vutsname ;

  {
  {
  uname(& vutsname);
  strncpy((char * __restrict  )((char *)s), (char const   * __restrict  )(vutsname.nodename),
          (size_t )len___0);
  }
  return;
}
}
long mch_get_pid(void) 
{ 
  __pid_t tmp ;

  {
  {
  tmp = getpid();
  }
  return ((long )tmp);
}
}
int mch_dirname(char_u *buf___3 , int len___0 ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp___1 = getcwd((char *)buf___3, (size_t )len___0);
  }
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    strcpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )tmp___0);
    }
    return (0);
  }
  return (1);
}
}
static int dont_fchdir  =    0;
int mch_FullName(char_u *fname , char_u *buf___3 , int len___0 , int force ) 
{ 
  int l ;
  int fd ;
  char_u olddir[1024] ;
  char_u *p___0 ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  fd = -1;
  retval = 1;
  *buf___3 = (char_u )'\000';
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    return (0);
  }
  if (force) {
    goto _L___0;
  } else {
    {
    tmp___4 = mch_isFullName(fname);
    }
    if (! tmp___4) {
      _L___0: 
      {
      p___0 = vim_strrchr(fname, '/');
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        if (! dont_fchdir) {
          {
          fd = open(".", 0, 0);
          }
          if (fd >= 0) {
            {
            tmp = fchdir(fd);
            }
            if (tmp < 0) {
              {
              close(fd);
              fd = -1;
              dont_fchdir = 1;
              }
            }
          }
        }
        if (fd < 0) {
          {
          tmp___1 = mch_dirname(olddir, 1024);
          }
          if (tmp___1 == 0) {
            p___0 = (char_u *)((void *)0);
            retval = 0;
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if (p___0 - fname >= (long )len___0) {
          retval = 0;
        } else {
          {
          strncpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)fname),
                  (size_t )(p___0 - fname));
          *(buf___3 + (p___0 - fname)) = (char_u )'\000';
          tmp___0 = chdir((char const   *)((char *)buf___3));
          }
          if (tmp___0) {
            retval = 0;
          } else {
            fname = p___0 + 1;
          }
          *buf___3 = (char_u )'\000';
        }
        }
      }
      {
      tmp___2 = mch_dirname(buf___3, len___0);
      }
      if (tmp___2 == 0) {
        retval = 0;
        *buf___3 = (char_u )'\000';
      }
      {
      tmp___3 = strlen((char const   *)((char *)buf___3));
      l = (int )tmp___3;
      }
      if (l) {
        if ((int )*(buf___3 + (l - 1)) != 47) {
          {
          strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)"/"));
          }
        }
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        if (fd >= 0) {
          {
          fchdir(fd);
          close(fd);
          }
        } else {
          {
          chdir((char const   *)((char *)(olddir)));
          }
        }
      }
    }
  }
  {
  strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)fname));
  }
  return (retval);
}
}
int mch_isFullName(char_u *fname ) 
{ 
  int tmp ;

  {
  if ((int )*fname == 47) {
    tmp = 1;
  } else { //Added block
  if ((int )*fname == 126) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
long mch_getperm(char_u *name___1 ) 
{ 
  struct stat statb ;
  int tmp ;

  {
  {
  tmp = stat((char const   * __restrict  )((char *)name___1), (struct stat * __restrict  )(& statb));
  }
  if (tmp) {
    return (-1L);
  }
  return ((long )statb.st_mode);
}
}
int mch_setperm(char_u *name___1 , long perm ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = chmod((char const   *)((char *)name___1), (mode_t )perm);
  }
  if (tmp___1 == 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
void mch_hide(char_u *name___1 ) 
{ 


  {
  return;
}
}
int mch_isdir(char_u *name___1 ) 
{ 
  struct stat statb ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )*name___1 == 0) {
    return (0);
  }
  {
  tmp = stat((char const   * __restrict  )((char *)name___1), (struct stat * __restrict  )(& statb));
  }
  if (tmp) {
    return (0);
  }
  if ((statb.st_mode & 61440U) == 16384U) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
void mch_windexit(int r ) 
{ 
  int tmp ;

  {
  {
  settmode(0);
  exiting = 1;
  mch_restore_title(3);
  stoptermcap();
  }
  if (newline_on_exit) {
    {
    out_char((unsigned int )'\n');
    }
  } else { //Added block
  if (msg_didout) {
    {
    tmp = swapping_screen();
    }
    if (tmp) {
      {
      msg_clr_eos();
      }
    } else {
      {
      out_char((unsigned int )'\n');
      }
    }
  } else {
    {
    msg_clr_eos();
    }
  }
  }
  if (full_screen) {
    {
    cursor_on();
    }
  }
  {
  out_flush();
  ml_close_all(1);
  may_core_dump();
  exit(r);
  }
}
}
static void may_core_dump(void) 
{ 
  __pid_t tmp ;

  {
  if (deadly_signal != 0) {
    {
    sigset(deadly_signal, (void (*)(int  ))0);
    tmp = getpid();
    kill(tmp, deadly_signal);
    }
  }
  return;
}
}
static int first  =    1;
static struct termios told  ;
void mch_settmode(int tmode ) 
{ 
  struct termios tnew ;

  {
  if (first) {
    {
    first = 0;
    tcgetattr(read_cmd_fd, & told);
    }
  }
  tnew = told;
  if (tmode == 2) {
    tnew.c_iflag &= 4294967039U;
    tnew.c_lflag &= 4294934500U;
    tnew.c_oflag &= 4294967291U;
    tnew.c_cc[6] = (cc_t )1;
    tnew.c_cc[5] = (cc_t )0;
  } else { //Added block
  if (tmode == 1) {
    tnew.c_lflag &= 4294967287U;
  }
  }
  {
  tcsetattr(read_cmd_fd, 0, (struct termios  const  *)(& tnew));
  curr_tmode = tmode;
  }
  return;
}
}
void get_stty(void) 
{ 
  char_u buf___3[2] ;
  char_u *p___0 ;
  struct termios keys___0 ;
  int tmp ;

  {
  {
  tmp = tcgetattr(read_cmd_fd, & keys___0);
  }
  if (tmp != -1) {
    {
    buf___3[0] = keys___0.c_cc[2];
    intr_char = (int )keys___0.c_cc[0];
    buf___3[1] = (char_u )'\000';
    add_termcode((char_u *)"kb", buf___3, 0);
    p___0 = find_termcode((char_u *)"kD");
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      if ((int )*(p___0 + 0) == (int )buf___3[0]) {
        if ((int )*(p___0 + 1) == (int )buf___3[1]) {
          {
          do_fixdel();
          }
        }
      }
    }
  }
  return;
}
}
static int ison  =    0;
void mch_setmouse(int on ) 
{ 
  int xterm_mouse_vers ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (on == ison) {
    return;
  }
  {
  xterm_mouse_vers = use_xterm_mouse();
  }
  if (xterm_mouse_vers > 0) {
    if (on) {
      if (xterm_mouse_vers > 1) {
        tmp = "\033[?1002h";
      } else {
        tmp = "\033[?1000h";
      }
      {
      out_str_nf((char_u *)tmp);
      }
    } else {
      if (xterm_mouse_vers > 1) {
        tmp___0 = "\033[?1002l";
      } else {
        tmp___0 = "\033[?1000l";
      }
      {
      out_str_nf((char_u *)tmp___0);
      }
    }
    ison = on;
  }
  return;
}
}
void check_mouse_termcode(void) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp___2 = use_xterm_mouse();
  }
  if (tmp___2) {
    {
    tmp___1 = term_is_8bit(term_strings[0]);
    }
    if (tmp___1) {
      tmp___0 = "\233M";
    } else {
      tmp___0 = "\033[M";
    }
    {
    set_mouse_termcode(251, (char_u *)tmp___0);
    }
    if ((int )*p_mouse != 0) {
      {
      mch_setmouse(0);
      setmouse();
      }
    }
  } else {
    {
    del_mouse_termcode(251);
    }
  }
  return;
}
}
int mch_screenmode(char_u *arg ) 
{ 


  {
  {
  emsg((char_u *)"Screen mode setting not supported");
  }
  return (0);
}
}
int mch_get_winsize(void) 
{ 
  int old_Rows___0 ;
  int old_Columns ;
  char_u *p___0 ;
  struct winsize ws ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
  old_Rows___0 = (int )Rows;
  old_Columns = (int )Columns;
  Columns = 0L;
  Rows = 0L;
  tmp = ioctl(1, 21523UL, & ws);
  }
  if (tmp == 0) {
    Columns = (long )ws.ws_col;
    Rows = (long )ws.ws_row;
  }
  if (Columns == 0L) {
    goto _L;
  } else { //Added block
  if (Rows == 0L) {
    _L: 
    {
    tmp___1 = getenv("LINES");
    p___0 = (char_u *)tmp___1;
    }
    if (p___0) {
      {
      tmp___0 = atoi((char const   *)((char *)p___0));
      Rows = (long )tmp___0;
      }
    }
    {
    tmp___3 = getenv("COLUMNS");
    p___0 = (char_u *)tmp___3;
    }
    if (p___0) {
      {
      tmp___2 = atoi((char const   *)((char *)p___0));
      Columns = (long )tmp___2;
      }
    }
  }
  }
  if (Columns == 0L) {
    {
    getlinecol();
    }
  } else { //Added block
  if (Rows == 0L) {
    {
    getlinecol();
    }
  }
  }
  if (Columns <= 0L) {
    Columns = (long )old_Columns;
    Rows = (long )old_Rows___0;
    return (0);
  } else { //Added block
  if (Rows <= 0L) {
    Columns = (long )old_Columns;
    Rows = (long )old_Rows___0;
    return (0);
  }
  }
  {
  check_winsize();
  }
  return (1);
}
}
void mch_set_winsize(void) 
{ 


  {
  if (*(term_strings[48])) {
    {
    term_set_winsize((int )Rows, (int )Columns);
    out_flush();
    screen_start();
    }
  }
  return;
}
}
int mch_call_shell(char_u *cmd , int options___0 ) 
{ 
  char_u *newcmd ;
  pid_t pid ;
  pid_t wait_pid ;
  int status ;
  int retval ;
  char **argv ;
  int argc ;
  int i___0 ;
  char_u *p___0 ;
  int inquote ;
  int did_settmode ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int fd ;
  int *tmp___4 ;

  {
  {
  newcmd = (char_u *)((void *)0);
  wait_pid = 0;
  status = -1;
  retval = -1;
  argv = (char **)((void *)0);
  did_settmode = 0;
  out_flush();
  }
  if (options___0 & 4) {
    {
    settmode(0);
    }
  }
  {
  newcmd = vim_strsave(p_sh);
  }
  if ((unsigned long )newcmd == (unsigned long )((void *)0)) {
    goto error;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break;
    }
    p___0 = newcmd;
    inquote = 0;
    argc = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (i___0 == 1) {
        *(argv + argc) = (char *)p___0;
      }
      argc ++;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (*p___0) {
          if (! inquote) {
            if ((int )*p___0 != 32) {
              if (! ((int )*p___0 != 9)) {
                goto while_break___1;
              }
            } else {
              goto while_break___1;
            }
          }
        } else {
          goto while_break___1;
        }
        if ((int )*p___0 == 34) {
          inquote = ! inquote;
        }
        p___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      if ((int )*p___0 == 0) {
        goto while_break___0;
      }
      if (i___0 == 1) {
        tmp = p___0;
        p___0 ++;
        *tmp = (char_u )'\000';
      }
      {
      p___0 = skipwhite(p___0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (i___0 == 0) {
      {
      tmp___0 = alloc((unsigned int )((unsigned long )(argc + 4) * sizeof(char *)));
      argv = (char **)tmp___0;
      }
      if ((unsigned long )argv == (unsigned long )((void *)0)) {
        goto error;
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )cmd != (unsigned long )((void *)0)) {
    if ((unsigned long )extra_shell_arg != (unsigned long )((void *)0)) {
      tmp___1 = argc;
      argc ++;
      *(argv + tmp___1) = (char *)extra_shell_arg;
    }
    tmp___2 = argc;
    argc ++;
    *(argv + tmp___2) = (char *)p_shcf;
    tmp___3 = argc;
    argc ++;
    *(argv + tmp___3) = (char *)cmd;
  }
  {
  *(argv + argc) = (char *)((void *)0);
  pid = fork();
  }
  if (pid == -1) {
    {
    msg_puts((char_u *)"\nCannot fork\n");
    }
  } else { //Added block
  if (pid == 0) {
    {
    reset_signals();
    }
    if (! show_shell_mess) {
      goto _L;
    } else { //Added block
    if (options___0 & 2) {
      _L: 
      {
      fd = open("/dev/null", 2, 0);
      fclose(stdin);
      fclose(stdout);
      fclose(stderr);
      }
      if (fd >= 0) {
        {
        dup(fd);
        dup(fd);
        dup(fd);
        close(fd);
        }
      }
    }
    }
    {
    execvp((char const   *)*(argv + 0), (char * const  *)argv);
    exit(122);
    }
  } else {
    {
    catch_signals((void (*)())((void (*)(int  ))1), (void (*)())((void (*)(int  ))-1));
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (wait_pid != pid)) {
        goto while_break___2;
      }
      {
      wait_pid = wait(& status);
      }
      if (wait_pid <= 0) {
        {
        tmp___4 = __errno_location();
        }
        if (*tmp___4 == 10) {
          goto while_break___2;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    settmode(2);
    did_settmode = 1;
    set_signals();
    ui_get_winsize();
    }
    if ((status & 127) == 0) {
      retval = (status & 65280) >> 8;
      if (retval) {
        if (retval == 122) {
          {
          msg_puts((char_u *)"\nCannot execute shell ");
          msg_outtrans(p_sh);
          msg_putchar('\n');
          }
        } else { //Added block
        if (! (options___0 & 16)) {
          {
          msg_putchar('\n');
          msg_outnum((long )retval);
          msg_puts((char_u *)" returned\n");
          }
        }
        }
      }
    } else {
      {
      msg_puts((char_u *)"\nCommand terminated\n");
      }
    }
  }
  }
  {
  vim_free((void *)argv);
  }
  error: 
  if (! did_settmode) {
    {
    settmode(2);
    }
  }
  {
  resettitle();
  vim_free((void *)newcmd);
  }
  return (retval);
}
}
void mch_breakcheck(void) 
{ 
  int tmp ;

  {
  if (curr_tmode == 2) {
    {
    tmp = RealWaitForChar(read_cmd_fd, 0L, (int *)((void *)0));
    }
    if (tmp) {
      {
      fill_input_buf(0);
      }
    }
  }
  return;
}
}
static int WaitForChar(long msec ) 
{ 
  int rest ;
  int avail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = vim_is_input_buf_empty();
  }
  if (! tmp) {
    return (1);
  }
  {
  rest = 0;
  tmp___0 = do_xterm_trace();
  }
  if (tmp___0) {
    rest = (int )msec;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (rest != 0) {
      msec = 50L;
      if (rest >= 0) {
        if (rest < 50) {
          msec = (long )rest;
        }
      }
      if (rest >= 0) {
        rest = (int )((long )rest - msec);
      }
    }
    {
    avail = RealWaitForChar(read_cmd_fd, msec, (int *)((void *)0));
    }
    if (! avail) {
      {
      tmp___1 = vim_is_input_buf_empty();
      }
      if (! tmp___1) {
        return (1);
      }
      if (rest == 0) {
        goto while_break;
      } else {
        {
        tmp___2 = do_xterm_trace();
        }
        if (! tmp___2) {
          goto while_break;
        }
      }
    }
    if (! avail) {
      if (! (rest != 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (avail);
}
}
static int RealWaitForChar(int fd , long msec , int *check_for_gpm ) 
{ 
  int ret ;
  struct timeval tv ;
  fd_set rfds ;
  fd_set efds ;
  int maxfd ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  struct timeval *tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (msec >= 0L) {
      tv.tv_sec = msec / 1000L;
      tv.tv_usec = (msec % 1000L) * 1000L;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& efds.__fds_bits[0]): "memory");
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    rfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
    efds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
    maxfd = fd;
    if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
      rfds.__fds_bits[((_XPrivDisplay )xterm_dpy)->fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << ((_XPrivDisplay )xterm_dpy)->fd % (8 * (int )sizeof(__fd_mask )));
      if (maxfd < ((_XPrivDisplay )xterm_dpy)->fd) {
        maxfd = ((_XPrivDisplay )xterm_dpy)->fd;
      }
    }
    if (msec >= 0L) {
      tmp = & tv;
    } else {
      tmp = (struct timeval *)((void *)0);
    }
    {
    ret = select(maxfd + 1, & rfds, (fd_set *)((void *)0), & efds, tmp);
    }
    if (ret > 0) {
      if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
        if ((rfds.__fds_bits[((_XPrivDisplay )xterm_dpy)->fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << ((_XPrivDisplay )xterm_dpy)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
          xterm_update();
          ret --;
          }
          if (ret == 0) {
            {
            tmp___0 = vim_is_input_buf_empty();
            }
            if (tmp___0) {
              if (msec < 0L) {
                goto while_continue;
              }
            }
          }
        }
      }
    }
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return (ret > 0);
}
}
static int pstrcmp(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
  tmp = strcmp((char const   *)*((char **)a), (char const   *)*((char **)b));
  }
  return (tmp);
}
}
int mch_expandpath(struct growarray *gap , char_u *path , int flags___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = unix_expandpath(gap, path, 0, flags___0);
  }
  return (tmp);
}
}
static int unix_expandpath(struct growarray *gap , char_u *path , int wildoff , int flags___0 ) 
{ 
  char_u *buf___3 ;
  char_u *path_end ;
  char_u *p___0 ;
  char_u *s ;
  char_u *e ;
  int start_len ;
  int c ;
  char_u *pat ;
  DIR *dirp ;
  vim_regexp *prog ;
  struct dirent *dp ;
  int starts_with_dot ;
  int matches___0 ;
  int len___0 ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  start_len = gap->ga_len;
  tmp = strlen((char const   *)((char *)path));
  buf___3 = alloc((unsigned int )((tmp + 250UL) + 5UL));
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    return (0);
  }
  p___0 = buf___3;
  s = buf___3;
  e = (char_u *)((void *)0);
  path_end = path;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *path_end) {
      goto while_break;
    }
    if ((unsigned long )path_end >= (unsigned long )(path + wildoff)) {
      {
      tmp___3 = rem_backslash(path_end);
      }
      if (tmp___3) {
        tmp___0 = p___0;
        p___0 ++;
        tmp___1 = path_end;
        path_end ++;
        *tmp___0 = *tmp___1;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*path_end == 47) {
      if ((unsigned long )e != (unsigned long )((void *)0)) {
        goto while_break;
      } else {
        s = p___0 + 1;
      }
    } else {
      {
      tmp___2 = vim_strchr((char_u *)"*?[{~$", (int )*path_end);
      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        e = p___0;
      }
    }
    }
    tmp___4 = p___0;
    p___0 ++;
    tmp___5 = path_end;
    path_end ++;
    *tmp___4 = *tmp___5;
  }
  while_break: /* CIL Label */ ;
  }
  e = p___0;
  *e = (char_u )'\000';
  p___0 = buf___3 + wildoff;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )p___0 < (unsigned long )s)) {
      goto while_break___0;
    }
    {
    tmp___6 = rem_backslash(p___0);
    }
    if (tmp___6) {
      {
      strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)(p___0 + 1)));
      e --;
      s --;
      }
    }
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  starts_with_dot = (int )*s == 46;
  pat = file_pat_to_reg_pat(s, e, (char *)((void *)0), 0);
  }
  if ((unsigned long )pat == (unsigned long )((void *)0)) {
    {
    vim_free((void *)buf___3);
    }
    return (0);
  }
  {
  reg_ic = 0;
  prog = vim_regcomp(pat, 1);
  vim_free((void *)pat);
  }
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
    vim_free((void *)buf___3);
    }
    return (0);
  }
  c = (int )*s;
  *s = (char_u )'\000';
  if ((int )*buf___3 == 0) {
    tmp___7 = ".";
  } else {
    tmp___7 = (char const   *)((char *)buf___3);
  }
  {
  dirp = opendir(tmp___7);
  *s = (char_u )c;
  }
  if ((unsigned long )dirp != (unsigned long )((void *)0)) {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      dp = readdir(dirp);
      }
      if ((unsigned long )dp == (unsigned long )((void *)0)) {
        goto while_break___1;
      }
      if ((int )dp->d_name[0] != 46) {
        goto _L___0;
      } else { //Added block
      if (starts_with_dot) {
        _L___0: 
        {
        tmp___11 = vim_regexec(prog, (char_u *)(dp->d_name), 1);
        }
        if (tmp___11) {
          {
          strcpy((char * __restrict  )((char *)s), (char const   * __restrict  )(dp->d_name));
          tmp___8 = strlen((char const   *)((char *)buf___3));
          len___0 = (int )tmp___8;
          strcpy((char * __restrict  )((char *)(buf___3 + len___0)), (char const   * __restrict  )((char *)path_end));
          tmp___10 = mch_has_wildcard(path_end);
          }
          if (tmp___10) {
            {
            unix_expandpath(gap, buf___3, len___0 + 1, flags___0);
            }
          } else {
            if (*path_end) {
              {
              backslash_halve((buf___3 + len___0) + 1);
              }
            }
            {
            tmp___9 = mch_getperm(buf___3);
            }
            if (tmp___9 >= 0L) {
              {
              addfile(gap, buf___3, flags___0);
              }
            }
          }
        }
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    closedir(dirp);
    }
  }
  {
  vim_free((void *)buf___3);
  vim_free((void *)prog);
  matches___0 = gap->ga_len - start_len;
  }
  if (matches___0) {
    {
    qsort((void *)((char_u **)gap->ga_data + start_len), (size_t )matches___0, sizeof(char_u *),
          & pstrcmp);
    }
  }
  return (matches___0);
}
}
static int did_find_nul  =    0;
int mch_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) 
{ 
  int i___0 ;
  size_t len___0 ;
  char_u *p___0 ;
  int dir ;
  int j ;
  char_u *tempname ;
  char_u *command ;
  FILE *fd ;
  char_u *buffer ;
  int shell_style ;
  int check_spaces ;
  int ampersent ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  char_u *tmp___15 ;
  char_u *tmp___16 ;
  long tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
  shell_style = 0;
  ampersent = 0;
  *num_file = 0;
  *file = (char_u **)((void *)0);
  tmp___0 = have_wildcard(num_pat, pat);
  }
  if (! tmp___0) {
    {
    tmp = save_patterns(num_pat, pat, num_file, file);
    }
    return (tmp);
  }
  if (secure) {
    goto _L;
  } else { //Added block
  if (restricted) {
    _L: 
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < num_pat)) {
        goto while_break;
      }
      {
      tmp___1 = vim_strchr(*(pat + i___0), '`');
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
        tmp___2 = check_restricted();
        }
        if (tmp___2) {
          return (0);
        } else {
          {
          tmp___3 = check_secure();
          }
          if (tmp___3) {
            return (0);
          }
        }
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  }
  {
  tempname = vim_tempname('o');
  }
  if ((unsigned long )tempname == (unsigned long )((void *)0)) {
    {
    emsg(e_notmp);
    }
    return (0);
  }
  if (num_pat == 1) {
    if ((int )*(*(pat + 0)) == 96) {
      {
      tmp___6 = strlen((char const   *)((char *)*(pat + 0)));
      }
      if ((int )*((*(pat + 0) + tmp___6) - 1) == 96) {
        shell_style = 3;
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    {
    len___0 = strlen((char const   *)((char *)p_sh));
    }
    if (len___0 >= 3UL) {
      {
      tmp___5 = strcmp((char const   *)((char *)((p_sh + len___0) - 3)), (char const   *)((char *)"csh"));
      }
      if (tmp___5 == 0) {
        shell_style = 1;
      } else {
        {
        tmp___4 = strcmp((char const   *)((char *)((p_sh + len___0) - 3)), (char const   *)((char *)"zsh"));
        }
        if (tmp___4 == 0) {
          shell_style = 2;
        }
      }
    }
  }
  {
  tmp___7 = strlen((char const   *)((char *)tempname));
  len___0 = tmp___7 + 29UL;
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < num_pat)) {
      goto while_break___0;
    }
    {
    tmp___8 = strlen((char const   *)((char *)*(pat + i___0)));
    len___0 += tmp___8 + 3UL;
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  command = alloc((unsigned int )len___0);
  }
  if ((unsigned long )command == (unsigned long )((void *)0)) {
    {
    vim_free((void *)tempname);
    }
    return (0);
  }
  if (shell_style == 3) {
    {
    strcpy((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)(*(pat + 0) + 1)));
    tmp___9 = strlen((char const   *)((char *)command));
    p___0 = (command + tmp___9) - 1;
    *p___0 = (char_u )' ';
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if ((unsigned long )p___0 > (unsigned long )command) {
        if (! ((int )*p___0 == 32)) {
          if (! ((int )*p___0 == 9)) {
            goto while_break___1;
          }
        }
      } else {
        goto while_break___1;
      }
      p___0 --;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((int )*p___0 == 38) {
      ampersent = 1;
      *p___0 = (char_u )' ';
    }
    {
    strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)">"));
    }
  } else {
    if (flags___0 & 4) {
      {
      strcpy((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)"set nonomatch; "));
      }
    } else {
      {
      strcpy((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)"unset nonomatch; "));
      }
    }
    if (shell_style == 1) {
      {
      strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)"glob >"));
      }
    } else { //Added block
    if (shell_style == 2) {
      {
      strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)"print -N >"));
      }
    } else {
      {
      strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)"echo >"));
      }
    }
    }
  }
  {
  strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)tempname));
  }
  if (shell_style != 3) {
    i___0 = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (i___0 < num_pat)) {
        goto while_break___2;
      }
      {
      strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)" "));
      strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)*(pat + i___0)));
      i___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  if (flags___0 & 32) {
    show_shell_mess = 0;
  }
  if (ampersent) {
    {
    strcat((char * __restrict  )((char *)command), (char const   * __restrict  )((char *)"&"));
    }
  }
  if (shell_style == 2) {
    extra_shell_arg = (char_u *)"-G";
  } else { //Added block
  if (shell_style == 1) {
    {
    tmp___10 = have_dollars(num_pat, pat);
    }
    if (! tmp___10) {
      extra_shell_arg = (char_u *)"-f";
    }
  }
  }
  if (flags___0 & 32) {
    tmp___11 = 16;
  } else {
    tmp___11 = 0;
  }
  {
  i___0 = call_shell(command, 2 | tmp___11);
  }
  if (ampersent) {
    {
    mch_delay(10L, 1);
    }
  }
  {
  extra_shell_arg = (char_u *)((void *)0);
  show_shell_mess = 1;
  vim_free((void *)command);
  }
  if (i___0) {
    {
    unlink((char const   *)((char *)tempname));
    vim_free((void *)tempname);
    }
    if (! (flags___0 & 32)) {
      {
      must_redraw = 50;
      msg_putchar('\n');
      cmdline_row = (int )(Rows - 1L);
      }
    }
    return (0);
  }
  {
  fd = fopen((char const   * __restrict  )((char *)tempname), (char const   * __restrict  )"r");
  }
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
    emsg2(e_notopen, tempname);
    vim_free((void *)tempname);
    }
    return (0);
  }
  {
  fseek(fd, 0L, 2);
  tmp___12 = ftell(fd);
  len___0 = (size_t )tmp___12;
  fseek(fd, 0L, 0);
  buffer = alloc((unsigned int )(len___0 + 1UL));
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
    unlink((char const   *)((char *)tempname));
    vim_free((void *)tempname);
    fclose(fd);
    }
    return (0);
  }
  {
  tmp___13 = fread((void * __restrict  )((char *)buffer), (size_t )1, len___0, (FILE * __restrict  )fd);
  i___0 = (int )tmp___13;
  fclose(fd);
  unlink((char const   *)((char *)tempname));
  }
  if ((size_t )i___0 != len___0) {
    {
    emsg2(e_notread, tempname);
    vim_free((void *)tempname);
    vim_free((void *)buffer);
    }
    return (0);
  }
  {
  vim_free((void *)tempname);
  }
  if (shell_style == 0) {
    *(buffer + len___0) = (char_u )'\n';
    p___0 = buffer;
    i___0 = 0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! ((int )*p___0 != 10)) {
        goto while_break___3;
      }
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if ((int )*p___0 != 32) {
          if (! ((int )*p___0 != 10)) {
            goto while_break___4;
          }
        } else {
          goto while_break___4;
        }
        p___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      p___0 = skipwhite(p___0);
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  } else { //Added block
  if (shell_style == 3) {
    *(buffer + len___0) = (char_u )'\000';
    p___0 = buffer;
    i___0 = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! ((int )*p___0 != 0)) {
        goto while_break___5;
      }
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        if ((int )*p___0 != 10) {
          if (! ((int )*p___0 != 0)) {
            goto while_break___6;
          }
        } else {
          goto while_break___6;
        }
        p___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      if ((int )*p___0 != 0) {
        p___0 ++;
      }
      {
      p___0 = skipwhite(p___0);
      i___0 ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
    check_spaces = 0;
    if (shell_style == 2) {
      if (! did_find_nul) {
        if (len___0) {
          {
          tmp___14 = strlen((char const   *)((char *)buffer));
          }
          if ((size_t )((int )tmp___14) < len___0 - 1UL) {
            did_find_nul = 1;
          } else {
            check_spaces = 1;
          }
        } else {
          check_spaces = 1;
        }
      }
    }
    if (len___0) {
      if ((int )*(buffer + (len___0 - 1UL)) == 0) {
        len___0 --;
      } else {
        *(buffer + len___0) = (char_u )'\000';
      }
    } else {
      *(buffer + len___0) = (char_u )'\000';
    }
    i___0 = 0;
    p___0 = buffer;
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      if (! ((unsigned long )p___0 < (unsigned long )(buffer + len___0))) {
        goto while_break___7;
      }
      if ((int )*p___0 == 0) {
        i___0 ++;
        *p___0 = (char_u )'\000';
      } else { //Added block
      if ((int )*p___0 == 32) {
        if (check_spaces) {
          i___0 ++;
          *p___0 = (char_u )'\000';
        }
      }
      }
      p___0 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    if (len___0) {
      i___0 ++;
    }
  }
  }
  if (i___0 == 0) {
    {
    vim_free((void *)buffer);
    }
    goto notfound;
  }
  {
  *num_file = i___0;
  tmp___15 = alloc((unsigned int )(sizeof(char_u *) * (unsigned long )i___0));
  *file = (char_u **)tmp___15;
  }
  if ((unsigned long )*file == (unsigned long )((void *)0)) {
    {
    vim_free((void *)buffer);
    }
    return (0);
  }
  p___0 = buffer;
  i___0 = 0;
  {
  while (1) {
    while_continue___8: /* CIL Label */ ;
    if (! (i___0 < *num_file)) {
      goto while_break___8;
    }
    *(*file + i___0) = p___0;
    if (shell_style == 0) {
      goto _L___3;
    } else { //Added block
    if (shell_style == 3) {
      _L___3: 
      {
      while (1) {
        while_continue___9: /* CIL Label */ ;
        if (shell_style == 0) {
          if ((int )*p___0 == 32) {
            goto while_break___9;
          } else {
            goto _L___2;
          }
        } else { //Added block
        _L___2: 
        if (! ((int )*p___0 != 10)) {
          goto while_break___9;
        }
        }
        p___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      if ((unsigned long )p___0 == (unsigned long )(buffer + len___0)) {
        *p___0 = (char_u )'\000';
      } else {
        {
        tmp___16 = p___0;
        p___0 ++;
        *tmp___16 = (char_u )'\000';
        p___0 = skipwhite(p___0);
        }
      }
    } else {
      {
      while (1) {
        while_continue___10: /* CIL Label */ ;
        if (*p___0) {
          if (! ((unsigned long )p___0 < (unsigned long )(buffer + len___0))) {
            goto while_break___10;
          }
        } else {
          goto while_break___10;
        }
        p___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      p___0 ++;
    }
    }
    i___0 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  j = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue___11: /* CIL Label */ ;
    if (! (i___0 < *num_file)) {
      goto while_break___11;
    }
    if (! (flags___0 & 4)) {
      {
      tmp___17 = mch_getperm(*(*file + i___0));
      }
      if (tmp___17 < 0L) {
        goto __Cont;
      }
    }
    {
    dir = mch_isdir(*(*file + i___0));
    }
    if (dir) {
      if (! (flags___0 & 1)) {
        goto __Cont;
      } else {
        goto _L___4;
      }
    } else { //Added block
    _L___4: 
    if (! dir) {
      if (! (flags___0 & 2)) {
        goto __Cont;
      }
    }
    }
    {
    tmp___18 = strlen((char const   *)((char *)*(*file + i___0)));
    p___0 = alloc((unsigned int )((tmp___18 + 1UL) + (size_t )dir));
    }
    if (p___0) {
      {
      strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)*(*file + i___0)));
      }
      if (dir) {
        {
        strcat((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)"/"));
        }
      }
      tmp___19 = j;
      j ++;
      *(*file + tmp___19) = p___0;
    }
    __Cont: 
    i___0 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
  vim_free((void *)buffer);
  *num_file = j;
  }
  if (*num_file == 0) {
    {
    vim_free((void *)*file);
    *file = (char_u **)((void *)0);
    }
    goto notfound;
  }
  return (1);
  notfound: 
  if (flags___0 & 4) {
    {
    tmp___20 = save_patterns(num_pat, pat, num_file, file);
    }
    return (tmp___20);
  }
  return (0);
}
}
static int save_patterns(int num_pat , char_u **pat , int *num_file , char_u ***file ) 
{ 
  int i___0 ;
  char_u *tmp ;

  {
  {
  tmp = alloc((unsigned int )((unsigned long )num_pat * sizeof(char_u *)));
  *file = (char_u **)tmp;
  }
  if ((unsigned long )*file == (unsigned long )((void *)0)) {
    return (0);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < num_pat)) {
      goto while_break;
    }
    {
    *(*file + i___0) = vim_strsave(*(pat + i___0));
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  *num_file = num_pat;
  return (1);
}
}
int mch_has_wildcard(char_u *p___0 ) 
{ 
  char_u *tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == 92) {
      if ((int )*(p___0 + 1) != 0) {
        p___0 ++;
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
      tmp = vim_strchr((char_u *)"*?[{`\'~$", (int )*p___0);
      }
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        return (1);
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int have_wildcard(int num , char_u **file ) 
{ 
  int i___0 ;
  int tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < num)) {
      goto while_break;
    }
    {
    tmp = mch_has_wildcard(*(file + i___0));
    }
    if (tmp) {
      return (1);
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int have_dollars(int num , char_u **file ) 
{ 
  int i___0 ;
  char_u *tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < num)) {
      goto while_break;
    }
    {
    tmp = vim_strchr(*(file + i___0), '$');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      return (1);
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int xterm_trace  =    -1;
static int xterm_button  ;
void setup_xterm_clip(void) 
{ 
  int z ;
  char *strp ;
  Widget AppShell ;
  int (*oldhandler)() ;
  int (*tmp)(Display * , XErrorEvent * ) ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
  z = 0;
  strp = (char *)"";
  open_app_context();
  }
  if ((unsigned long )app_context != (unsigned long )((void *)0)) {
    if ((unsigned long )xterm_Shell == (unsigned long )((Widget )0)) {
      {
      tmp = XSetErrorHandler(& x_error_check);
      oldhandler = (int (*)())tmp;
      xterm_dpy = XtOpenDisplay(app_context, (char const   *)xterm_display, "vim_xterm",
                                "Vim_xterm", (XrmOptionDescRec *)((void *)0), (Cardinal )0,
                                & z, & strp);
      XSetErrorHandler((int (*)(Display * , XErrorEvent * ))oldhandler);
      }
      if ((unsigned long )xterm_dpy == (unsigned long )((void *)0)) {
        return;
      }
      {
      AppShell = XtVaAppCreateShell("vim_xterm", "Vim_xterm", applicationShellWidgetClass,
                                    xterm_dpy, (void *)0);
      }
      if ((unsigned long )AppShell == (unsigned long )((Widget )0)) {
        return;
      }
      {
      xterm_Shell = XtVaCreatePopupShell("VIM", topLevelShellWidgetClass, AppShell,
                                         (char *)(& XtStrings[453]), 0, (char *)(& XtStrings[872]),
                                         1, (char *)(& XtStrings[234]), 1, (void *)0);
      x11_setup_atoms(xterm_dpy);
      }
      if ((unsigned long )xterm_Shell == (unsigned long )((Widget )0)) {
        return;
      }
      if ((unsigned long )x11_display == (unsigned long )((void *)0)) {
        x11_display = xterm_dpy;
      }
      {
      XtRealizeWidget(xterm_Shell);
      XSync(xterm_dpy, 0);
      xterm_update();
      }
    }
  }
  if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
    {
    clip_init(1);
    }
    if (x11_window == 0UL) {
      {
      strp = getenv("WINDOWID");
      }
      if ((unsigned long )strp != (unsigned long )((void *)0)) {
        {
        tmp___0 = atol((char const   *)strp);
        x11_window = (Window )tmp___0;
        }
      }
    }
    {
    tmp___1 = test_x11_window(xterm_dpy);
    }
    if (tmp___1 == 0) {
      x11_window = (Window )0;
    }
    if (x11_window != 0UL) {
      xterm_trace = 0;
    }
  }
  return;
}
}
void start_xterm_trace(int button ) 
{ 


  {
  if (x11_window == 0UL) {
    return;
  } else { //Added block
  if (xterm_trace < 0) {
    return;
  } else { //Added block
  if ((unsigned long )xterm_Shell == (unsigned long )((Widget )0)) {
    return;
  }
  }
  }
  {
  xterm_trace = 1;
  xterm_button = button;
  do_xterm_trace();
  }
  return;
}
}
void stop_xterm_trace(void) 
{ 


  {
  if (xterm_trace < 0) {
    return;
  }
  xterm_trace = 0;
  return;
}
}
static char_u *mouse_code  ;
static char_u mouse_name[2]  = {      (char_u )251,      (char_u )'X'};
static int prev_row  =    0;
static int prev_col  =    0;
static XSizeHints xterm_hints  ;
static int do_xterm_trace(void) 
{ 
  Window root ;
  Window child ;
  int root_x ;
  int root_y ;
  int win_x ;
  int win_y ;
  int row ;
  int col ;
  int_u mask_return ;
  char_u buf___3[50] ;
  char_u *strp ;
  long got_hints ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;

  {
  if (xterm_trace <= 0) {
    return (0);
  }
  if (xterm_trace == 1) {
    {
    XGetWMNormalHints(xterm_dpy, x11_window, & xterm_hints, & got_hints);
    }
    if (! (got_hints & (1L << 6))) {
      xterm_trace = -1;
      return (0);
    } else { //Added block
    if (xterm_hints.width_inc <= 1) {
      xterm_trace = -1;
      return (0);
    } else { //Added block
    if (xterm_hints.height_inc <= 1) {
      xterm_trace = -1;
      return (0);
    }
    }
    }
    {
    mouse_code = find_termcode(mouse_name);
    prev_row = mouse_row;
    prev_row = mouse_col;
    xterm_trace = 2;
    XQueryPointer(xterm_dpy, x11_window, & root, & child, & root_x, & root_y, & win_x,
                  & win_y, & mask_return);
    xterm_hints.y = (win_y - xterm_hints.height_inc * mouse_row) - xterm_hints.height_inc / 2;
    }
    if (xterm_hints.y <= xterm_hints.height_inc / 2) {
      xterm_hints.y = 2;
    }
    xterm_hints.x = (win_x - xterm_hints.width_inc * mouse_col) - xterm_hints.width_inc / 2;
    if (xterm_hints.x <= xterm_hints.width_inc / 2) {
      xterm_hints.x = 2;
    }
    return (1);
  }
  if ((unsigned long )mouse_code == (unsigned long )((void *)0)) {
    xterm_trace = 0;
    return (0);
  }
  {
  XQueryPointer(xterm_dpy, x11_window, & root, & child, & root_x, & root_y, & win_x,
                & win_y, & mask_return);
  row = check_row((win_y - xterm_hints.y) / xterm_hints.height_inc);
  col = check_col((win_x - xterm_hints.x) / xterm_hints.width_inc);
  }
  if (row == prev_row) {
    if (col == prev_col) {
      return (1);
    }
  }
  {
  strcpy((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )((char *)mouse_code));
  tmp = strlen((char const   *)((char *)(buf___3)));
  strp = buf___3 + tmp;
  tmp___0 = strp;
  strp ++;
  *tmp___0 = (char_u )((xterm_button | 67) & -33);
  tmp___1 = strp;
  strp ++;
  *tmp___1 = (char_u )((col + 32) + 1);
  tmp___2 = strp;
  strp ++;
  *tmp___2 = (char_u )((row + 32) + 1);
  *strp = (char_u )0;
  tmp___3 = strlen((char const   *)((char *)(buf___3)));
  add_to_input_buf(buf___3, (int )tmp___3);
  prev_row = row;
  prev_col = col;
  }
  return (1);
}
}
void clear_xterm_clip(void) 
{ 


  {
  if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
    {
    XtDestroyWidget(xterm_Shell);
    xterm_Shell = (Widget )0;
    }
  }
  if ((unsigned long )xterm_dpy != (unsigned long )((void *)0)) {
    if ((unsigned long )x11_display == (unsigned long )xterm_dpy) {
      x11_display = (Display *)((void *)0);
    }
    xterm_dpy = (Display *)((void *)0);
  }
  return;
}
}
static void xterm_update(void) 
{ 
  XtInputMask tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = XtAppPending(app_context);
    }
    if (tmp) {
      {
      tmp___0 = vim_is_input_buf_full();
      }
      if (tmp___0) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    XtAppProcessEvent(app_context, (XtInputMask )15);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int clip_xterm_own_selection(void) 
{ 
  int tmp ;

  {
  if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
    {
    tmp = clip_x11_own_selection(xterm_Shell);
    }
    return (tmp);
  }
  return (0);
}
}
void clip_xterm_lose_selection(void) 
{ 


  {
  if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
    {
    clip_x11_lose_selection(xterm_Shell);
    }
  }
  return;
}
}
void clip_xterm_request_selection(void) 
{ 


  {
  if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
    {
    clip_x11_request_selection(xterm_Shell, xterm_dpy);
    }
  }
  return;
}
}
void clip_xterm_set_selection(void) 
{ 


  {
  {
  clip_x11_set_selection();
  }
  return;
}
}
#pragma merger("0","/tmp/cil-8goyHUav.i","-O0")
char_u *all_cflags ;
char_u *all_lflags ;
char_u *compiled_user ;
char_u *compiled_sys ;
char_u *default_vim_dir  =    (char_u *)"/vim/source/share/vim";
char_u *default_vimruntime_dir  =    (char_u *)"";
char_u *all_cflags  =    (char_u *)"cilly --merge --keepmerged -c -I. -Iproto -DHAVE_CONFIG_H     -O0     ";
char_u *all_lflags  =    (char_u *)"cilly --merge --keepmerged  -o vim      -lXt -lX11 -lXdmcp -lncurses     ";
char_u *compiled_user  =    (char_u *)"qxin6";
char_u *compiled_sys  =    (char_u *)"qx-debloat";
#pragma merger("0","/tmp/cil-tVOikzOv.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
static void qf_msg(void) ;
static void qf_free(int idx ) ;
static char_u *qf_types(int c , int nr ) ;
static int qf_get_fnum(char_u *directory , char_u *fname ) ;
static char_u *qf_push_dir(char_u *dirbuf , struct dir_stack_t **stackptr ) ;
static char_u *qf_pop_dir(struct dir_stack_t **stackptr ) ;
static char_u *qf_guess_filepath(char_u *filename ) ;
static void qf_clean_dir_stack(struct dir_stack_t **stackptr ) ;
static struct dir_stack_t *dir_stack  =    (struct dir_stack_t *)((void *)0);
struct qf_list qf_lists[10]  ;
static int qf_curlist  =    0;
static int qf_listcount  =    0;
static struct fmtpattern fmt_pat[7]  = {      {(char_u )'f', (char *)"\\f\\+"}, 
        {(char_u )'n', (char *)"\\d\\+"}, 
        {(char_u )'l', (char *)"\\d\\+"}, 
        {(char_u )'c', (char *)"\\d\\+"}, 
        {(char_u )'t', (char *)"."}, 
        {(char_u )'m', (char *)".\\+"}, 
        {(char_u )'r', (char *)".*"}};
int qf_init(char_u *efile , char_u *errorformat ) 
{ 
  char_u *namebuf ;
  char_u *errmsg ;
  char_u *fmtstr ;
  int col ;
  int type ;
  int valid ;
  long lnum ;
  int enr ;
  FILE *fd ;
  struct qf_line *qfp ;
  struct qf_line *qfprev ;
  char_u *efmp ;
  struct eformat *fmt_first ;
  struct eformat *fmt_last ;
  struct eformat *fmt_ptr ;
  char_u *efm ;
  char_u *ptr ;
  char_u *srcptr ;
  int len___0 ;
  int i___0 ;
  int round ;
  int idx ;
  int multiline ;
  int multiscan ;
  int retval ;
  char_u *directory ;
  char_u *currfile ;
  char_u *tail ;
  struct dir_stack_t *file_stack ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  char_u *tmp___12 ;
  char_u *tmp___13 ;
  char_u *tmp___14 ;
  char_u tmp___15 ;
  char_u *tmp___16 ;
  char_u *tmp___17 ;
  char_u tmp___18 ;
  char_u *tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;
  char_u *tmp___22 ;
  char_u *tmp___23 ;
  char_u *tmp___24 ;
  char_u *tmp___25 ;
  char_u *tmp___26 ;
  char_u *tmp___27 ;
  char_u *tmp___28 ;
  char_u *tmp___29 ;
  char_u *tmp___30 ;
  vim_regexp *tmp___31 ;
  char_u *tmp___32 ;
  int tmp___33 ;
  char_u *tmp___34 ;
  long tmp___35 ;
  long tmp___36 ;
  long tmp___37 ;
  int tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  char_u *tmp___42 ;
  char_u *tmp___43 ;
  char_u *tmp___44 ;
  long tmp___45 ;
  char_u *tmp___46 ;
  char_u *tmp___47 ;
  char_u *tmp___48 ;
  char_u *tmp___49 ;
  char_u *tmp___50 ;
  char_u *tmp___51 ;
  char_u *tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;

  {
  fmtstr = (char_u *)((void *)0);
  col = 0;
  type = 0;
  lnum = 0L;
  enr = 0;
  qfp = (struct qf_line *)((void *)0);
  qfprev = (struct qf_line *)((void *)0);
  fmt_first = (struct eformat *)((void *)0);
  fmt_last = (struct eformat *)((void *)0);
  idx = 0;
  multiline = 0;
  multiscan = 0;
  retval = -1;
  directory = (char_u *)((void *)0);
  currfile = (char_u *)((void *)0);
  tail = (char_u *)((void *)0);
  file_stack = (struct dir_stack_t *)((void *)0);
  if ((unsigned long )efile == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  namebuf = alloc(1025U);
  errmsg = alloc(1025U);
  }
  if ((unsigned long )namebuf == (unsigned long )((void *)0)) {
    goto qf_init_end;
  } else { //Added block
  if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
    goto qf_init_end;
  }
  }
  {
  fd = fopen((char const   * __restrict  )((char *)efile), (char const   * __restrict  )"r");
  }
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
    emsg2(e_openerrf, efile);
    }
    goto qf_init_end;
  }
  if (qf_listcount == 10) {
    {
    qf_free(0);
    i___0 = 1;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < 10)) {
        goto while_break;
      }
      qf_lists[i___0 - 1] = qf_lists[i___0];
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    qf_curlist = 9;
  } else {
    tmp = qf_listcount;
    qf_listcount ++;
    qf_curlist = tmp;
  }
  {
  qf_lists[qf_curlist].qf_index = 0;
  qf_lists[qf_curlist].qf_count = 0;
  efm = errorformat;
  tmp___0 = strlen((char const   *)((char *)efm));
  i___0 = (int )(21UL + (tmp___0 << 2));
  round = 7;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! round) {
      goto while_break___0;
    }
    {
    round --;
    tmp___1 = strlen((char const   *)fmt_pat[round].pattern);
    i___0 = (int )((size_t )i___0 + tmp___1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  fmtstr = alloc((unsigned int )i___0);
  }
  if ((unsigned long )fmtstr == (unsigned long )((void *)0)) {
    goto error2;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! *(efm + 0)) {
      goto while_break___1;
    }
    {
    tmp___2 = alloc((unsigned int )sizeof(struct eformat ));
    fmt_ptr = (struct eformat *)tmp___2;
    }
    if ((unsigned long )fmt_ptr == (unsigned long )((void *)0)) {
      goto error2;
    }
    if ((unsigned long )fmt_first == (unsigned long )((void *)0)) {
      fmt_first = fmt_ptr;
    } else {
      fmt_last->next = fmt_ptr;
    }
    fmt_last = fmt_ptr;
    fmt_ptr->prefix = (char_u )'\000';
    fmt_ptr->flags = (char_u )'\000';
    fmt_ptr->next = (struct eformat *)((void *)0);
    fmt_ptr->prog = (vim_regexp *)((void *)0);
    round = 7;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! round) {
        goto while_break___2;
      }
      round --;
      fmt_ptr->addr[round] = (char_u )'\000';
    }
    while_break___2: /* CIL Label */ ;
    }
    len___0 = 0;
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if ((int )*(efm + len___0) != 0) {
        if (! ((int )*(efm + len___0) != 44)) {
          goto while_break___3;
        }
      } else {
        goto while_break___3;
      }
      if ((int )*(efm + len___0) == 92) {
        if ((int )*(efm + (len___0 + 1)) != 0) {
          len___0 ++;
        }
      }
      len___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    ptr = fmtstr;
    tmp___3 = ptr;
    ptr ++;
    *tmp___3 = (char_u )'^';
    efmp = efm;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ((unsigned long )efmp < (unsigned long )(efm + len___0))) {
        goto while_break___4;
      }
      if ((int )*efmp == 37) {
        efmp ++;
        idx = 0;
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          if (! (idx < 7)) {
            goto while_break___5;
          }
          if ((int )fmt_pat[idx].convchar == (int )*efmp) {
            goto while_break___5;
          }
          idx ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        if (idx < 7) {
          if (fmt_ptr->addr[idx]) {
            {
            sprintf((char * __restrict  )((char *)errmsg), (char const   * __restrict  )"Too many %%%c in format string",
                    (int )*efmp);
            emsg(errmsg);
            }
            goto error2;
          }
          if (idx) {
            if (idx < 6) {
              {
              tmp___4 = vim_strchr((char_u *)"DXOPQ", (int )fmt_ptr->prefix);
              }
              if (tmp___4) {
                {
                sprintf((char * __restrict  )((char *)errmsg), (char const   * __restrict  )"Unexpected %%%c in format string",
                        (int )*efmp);
                emsg(errmsg);
                }
                goto error2;
              } else {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else { //Added block
          _L___0: 
          if (idx == 6) {
            {
            tmp___5 = vim_strchr((char_u *)"OPQ", (int )fmt_ptr->prefix);
            }
            if (! tmp___5) {
              {
              sprintf((char * __restrict  )((char *)errmsg), (char const   * __restrict  )"Unexpected %%%c in format string",
                      (int )*efmp);
              emsg(errmsg);
              }
              goto error2;
            }
          }
          }
          round ++;
          fmt_ptr->addr[idx] = (char_u )round;
          tmp___6 = ptr;
          ptr ++;
          *tmp___6 = (char_u )'\\';
          tmp___7 = ptr;
          ptr ++;
          *tmp___7 = (char_u )'(';
          srcptr = (char_u *)fmt_pat[idx].pattern;
          {
          while (1) {
            while_continue___6: /* CIL Label */ ;
            tmp___9 = srcptr;
            srcptr ++;
            tmp___8 = *tmp___9;
            *ptr = tmp___8;
            if (! ((int )tmp___8 != 0)) {
              goto while_break___6;
            }
            ptr ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          tmp___10 = ptr;
          ptr ++;
          *tmp___10 = (char_u )'\\';
          tmp___11 = ptr;
          ptr ++;
          *tmp___11 = (char_u )')';
        } else { //Added block
        if ((int )*efmp == 42) {
          efmp ++;
          if ((int )*efmp == 91) {
            goto _L___1;
          } else { //Added block
          if ((int )*efmp == 92) {
            _L___1: 
            tmp___17 = ptr;
            ptr ++;
            tmp___18 = *efmp;
            *tmp___17 = tmp___18;
            if ((int )tmp___18 == 91) {
              if ((int )*(efmp + 1) == 94) {
                tmp___12 = ptr;
                ptr ++;
                efmp ++;
                *tmp___12 = *efmp;
              }
              if ((unsigned long )efmp < (unsigned long )(efm + len___0)) {
                tmp___13 = ptr;
                ptr ++;
                efmp ++;
                *tmp___13 = *efmp;
                {
                while (1) {
                  while_continue___7: /* CIL Label */ ;
                  if ((unsigned long )efmp < (unsigned long )(efm + len___0)) {
                    tmp___14 = ptr;
                    ptr ++;
                    efmp ++;
                    tmp___15 = *efmp;
                    *tmp___14 = tmp___15;
                    if (! ((int )tmp___15 != 93)) {
                      goto while_break___7;
                    }
                  } else {
                    goto while_break___7;
                  }
                }
                while_break___7: /* CIL Label */ ;
                }
                if ((unsigned long )efmp == (unsigned long )(efm + len___0)) {
                  {
                  emsg((char_u *)"Missing ] in format string");
                  }
                  goto error2;
                }
              }
            } else { //Added block
            if ((unsigned long )efmp < (unsigned long )(efm + len___0)) {
              tmp___16 = ptr;
              ptr ++;
              efmp ++;
              *tmp___16 = *efmp;
            }
            }
            tmp___19 = ptr;
            ptr ++;
            *tmp___19 = (char_u )'\\';
            tmp___20 = ptr;
            ptr ++;
            *tmp___20 = (char_u )'+';
          } else {
            {
            sprintf((char * __restrict  )((char *)errmsg), (char const   * __restrict  )"Unsupported %%%c in format string",
                    (int )*efmp);
            emsg(errmsg);
            }
            goto error2;
          }
          }
        } else {
          {
          tmp___26 = vim_strchr((char_u *)"%\\.^$~[", (int )*efmp);
          }
          if ((unsigned long )tmp___26 != (unsigned long )((void *)0)) {
            tmp___21 = ptr;
            ptr ++;
            *tmp___21 = *efmp;
          } else { //Added block
          if ((int )*efmp == 35) {
            tmp___22 = ptr;
            ptr ++;
            *tmp___22 = (char_u )'*';
          } else { //Added block
          if ((unsigned long )efmp == (unsigned long )(efm + 1)) {
            {
            tmp___24 = vim_strchr((char_u *)"+-", (int )*efmp);
            }
            if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
              tmp___23 = efmp;
              efmp ++;
              fmt_ptr->flags = *tmp___23;
            }
            {
            tmp___25 = vim_strchr((char_u *)"DXAEWCZGOPQ", (int )*efmp);
            }
            if ((unsigned long )tmp___25 != (unsigned long )((void *)0)) {
              fmt_ptr->prefix = *efmp;
            } else {
              {
              sprintf((char * __restrict  )((char *)errmsg), (char const   * __restrict  )"Invalid %%%c in format string prefix",
                      (int )*efmp);
              emsg(errmsg);
              }
              goto error2;
            }
          } else {
            {
            sprintf((char * __restrict  )((char *)errmsg), (char const   * __restrict  )"Invalid %%%c in format string",
                    (int )*efmp);
            emsg(errmsg);
            }
            goto error2;
          }
          }
          }
        }
        }
      } else {
        if ((int )*efmp == 92) {
          if ((unsigned long )(efmp + 1) < (unsigned long )(efm + len___0)) {
            efmp ++;
          } else {
            goto _L___2;
          }
        } else {
          _L___2: 
          {
          tmp___28 = vim_strchr((char_u *)".*^$~[", (int )*efmp);
          }
          if ((unsigned long )tmp___28 != (unsigned long )((void *)0)) {
            tmp___27 = ptr;
            ptr ++;
            *tmp___27 = (char_u )'\\';
          }
        }
        if (*efmp) {
          tmp___29 = ptr;
          ptr ++;
          *tmp___29 = *efmp;
        }
      }
      efmp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    tmp___30 = ptr;
    ptr ++;
    *tmp___30 = (char_u )'$';
    *ptr = (char_u )'\000';
    tmp___31 = vim_regcomp(fmtstr, 1);
    fmt_ptr->prog = tmp___31;
    }
    if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
      goto error2;
    }
    {
    efm = skip_to_option_part(efm + len___0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  if ((unsigned long )fmt_first == (unsigned long )((void *)0)) {
    {
    emsg((char_u *)"\'errorformat\' contains no pattern");
    }
    goto error2;
  }
  got_int = 0;
  {
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
    tmp___54 = fgets((char * __restrict  )((char *)IObuff), 1024, (FILE * __restrict  )fd);
    }
    if ((unsigned long )tmp___54 != (unsigned long )((void *)0)) {
      if (! (! got_int)) {
        goto while_break___8;
      }
    } else {
      goto while_break___8;
    }
    {
    *(IObuff + 1024) = (char_u )'\000';
    efmp = vim_strrchr(IObuff, '\n');
    }
    if ((unsigned long )efmp != (unsigned long )((void *)0)) {
      *efmp = (char_u )'\000';
    }
    valid = 1;
    restofline: 
    fmt_ptr = fmt_first;
    {
    while (1) {
      while_continue___9: /* CIL Label */ ;
      if (! ((unsigned long )fmt_ptr != (unsigned long )((void *)0))) {
        goto while_break___9;
      }
      idx = (int )fmt_ptr->prefix;
      if (multiscan) {
        {
        tmp___32 = vim_strchr((char_u *)"OPQ", idx);
        }
        if (! tmp___32) {
          goto __Cont;
        }
      }
      *(namebuf + 0) = (char_u )'\000';
      if (! multiscan) {
        *(errmsg + 0) = (char_u )'\000';
      }
      {
      lnum = 0L;
      col = 0;
      enr = -1;
      type = 0;
      tail = (char_u *)((void *)0);
      tmp___38 = vim_regexec(fmt_ptr->prog, IObuff, 1);
      }
      if (tmp___38) {
        if (idx == 67) {
          goto _L___3;
        } else { //Added block
        if (idx == 90) {
          _L___3: 
          if (! multiline) {
            goto __Cont;
          }
        }
        }
        if (idx == 69) {
          type = 'E';
        } else {
          if (idx == 87) {
            tmp___33 = 'W';
          } else {
            tmp___33 = 0;
          }
          type = tmp___33;
        }
        i___0 = (int )fmt_ptr->addr[0];
        if (i___0 > 0) {
          {
          len___0 = (int )((fmt_ptr->prog)->endp[i___0] - (fmt_ptr->prog)->startp[i___0]);
          strncpy((char * __restrict  )((char *)namebuf), (char const   * __restrict  )((char *)(fmt_ptr->prog)->startp[i___0]),
                  (size_t )len___0);
          *(namebuf + len___0) = (char_u )'\000';
          tmp___34 = vim_strchr((char_u *)"OPQ", idx);
          }
          if (tmp___34) {
            {
            tmp___35 = mch_getperm(namebuf);
            }
            if (tmp___35 == -1L) {
              goto __Cont;
            }
          }
        }
        i___0 = (int )fmt_ptr->addr[1];
        if (i___0 > 0) {
          {
          tmp___36 = atol((char const   *)((char *)(fmt_ptr->prog)->startp[i___0]));
          enr = (int )tmp___36;
          }
        }
        i___0 = (int )fmt_ptr->addr[2];
        if (i___0 > 0) {
          {
          lnum = atol((char const   *)((char *)(fmt_ptr->prog)->startp[i___0]));
          }
        }
        i___0 = (int )fmt_ptr->addr[3];
        if (i___0 > 0) {
          {
          tmp___37 = atol((char const   *)((char *)(fmt_ptr->prog)->startp[i___0]));
          col = (int )tmp___37;
          }
        }
        i___0 = (int )fmt_ptr->addr[4];
        if (i___0 > 0) {
          type = (int )*((fmt_ptr->prog)->startp[i___0]);
        }
        if ((int )fmt_ptr->flags == 43) {
          if (! multiscan) {
            {
            strcpy((char * __restrict  )((char *)errmsg), (char const   * __restrict  )((char *)IObuff));
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          i___0 = (int )fmt_ptr->addr[5];
          if (i___0 > 0) {
            {
            len___0 = (int )((fmt_ptr->prog)->endp[i___0] - (fmt_ptr->prog)->startp[i___0]);
            strncpy((char * __restrict  )((char *)errmsg), (char const   * __restrict  )((char *)(fmt_ptr->prog)->startp[i___0]),
                    (size_t )len___0);
            *(errmsg + len___0) = (char_u )'\000';
            }
          }
        }
        i___0 = (int )fmt_ptr->addr[6];
        if (i___0 > 0) {
          tail = (fmt_ptr->prog)->startp[i___0];
        }
        goto while_break___9;
      }
      __Cont: 
      fmt_ptr = fmt_ptr->next;
    }
    while_break___9: /* CIL Label */ ;
    }
    multiscan = 0;
    if (! fmt_ptr) {
      goto _L___7;
    } else { //Added block
    if (idx == 68) {
      goto _L___7;
    } else { //Added block
    if (idx == 88) {
      _L___7: 
      if (fmt_ptr) {
        if (idx == 68) {
          if ((int )*namebuf == 0) {
            {
            emsg((char_u *)"Missing or empty directory name");
            }
            goto error1;
          }
          {
          directory = qf_push_dir(namebuf, & dir_stack);
          }
          if ((unsigned long )directory == (unsigned long )((void *)0)) {
            goto error1;
          }
        } else { //Added block
        if (idx == 88) {
          {
          directory = qf_pop_dir(& dir_stack);
          }
        }
        }
      }
      {
      *(namebuf + 0) = (char_u )'\000';
      lnum = 0L;
      valid = 0;
      strcpy((char * __restrict  )((char *)errmsg), (char const   * __restrict  )((char *)IObuff));
      }
      if (! fmt_ptr) {
        multiline = 0;
      }
    } else { //Added block
    if (fmt_ptr) {
      {
      tmp___48 = vim_strchr((char_u *)"AEW", idx);
      }
      if (tmp___48) {
        multiline = 1;
      } else {
        {
        tmp___47 = vim_strchr((char_u *)"CZ", idx);
        }
        if (tmp___47) {
          if ((unsigned long )qfprev == (unsigned long )((void *)0)) {
            goto error1;
          }
          if (*errmsg) {
            {
            tmp___39 = strlen((char const   *)((char *)qfprev->qf_text));
            len___0 = (int )tmp___39;
            tmp___40 = strlen((char const   *)((char *)errmsg));
            ptr = alloc((unsigned int )(((size_t )len___0 + tmp___40) + 2UL));
            }
            if ((unsigned long )ptr == (unsigned long )((void *)0)) {
              goto error1;
            }
            {
            strcpy((char * __restrict  )((char *)ptr), (char const   * __restrict  )((char *)qfprev->qf_text));
            vim_free((void *)qfprev->qf_text);
            qfprev->qf_text = ptr;
            ptr += len___0;
            *ptr = (char_u )'\n';
            ptr ++;
            strcpy((char * __restrict  )((char *)ptr), (char const   * __restrict  )((char *)errmsg));
            }
          }
          if (qfp->qf_nr == -1) {
            qfp->qf_nr = enr;
          }
          {
          tmp___41 = vim_isprintc(type);
          }
          if (tmp___41) {
            if (! qfp->qf_type) {
              qfp->qf_type = (char_u )type;
            }
          }
          if (! qfp->qf_lnum) {
            qfp->qf_lnum = lnum;
          }
          if (! qfp->qf_col) {
            qfp->qf_col = col;
          }
          if (! qfp->qf_fnum) {
            if (*namebuf) {
              tmp___43 = namebuf;
            } else { //Added block
            if (directory) {
              tmp___43 = namebuf;
            } else {
              if (currfile) {
                if (valid) {
                  tmp___42 = currfile;
                } else {
                  tmp___42 = (char_u *)0;
                }
              } else {
                tmp___42 = (char_u *)0;
              }
              tmp___43 = tmp___42;
            }
            }
            {
            qfp->qf_fnum = qf_get_fnum(directory, tmp___43);
            }
          }
          if (idx == 90) {
            multiline = 0;
          }
          {
          line_breakcheck();
          }
          goto while_continue___8;
        } else {
          {
          tmp___46 = vim_strchr((char_u *)"OPQ", idx);
          }
          if (tmp___46) {
            valid = 0;
            if ((int )*namebuf == 0) {
              goto _L___6;
            } else {
              {
              tmp___45 = mch_getperm(namebuf);
              }
              if (tmp___45 >= 0L) {
                _L___6: 
                if (*namebuf) {
                  if (idx == 80) {
                    {
                    currfile = namebuf;
                    qf_push_dir(currfile, & file_stack);
                    }
                  } else {
                    goto _L___5;
                  }
                } else { //Added block
                _L___5: 
                if (idx == 81) {
                  {
                  currfile = qf_pop_dir(& file_stack);
                  }
                }
                }
                *namebuf = (char_u )'\000';
                if (tail) {
                  if (*tail) {
                    {
                    tmp___44 = skipwhite(tail);
                    strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___44));
                    multiscan = 1;
                    }
                    goto restofline;
                  }
                }
              }
            }
          }
        }
      }
      if ((int )fmt_ptr->flags == 45) {
        goto while_continue___8;
      }
    }
    }
    }
    }
    {
    tmp___49 = alloc((unsigned int )sizeof(struct qf_line ));
    qfp = (struct qf_line *)tmp___49;
    }
    if ((unsigned long )qfp == (unsigned long )((void *)0)) {
      goto error2;
    }
    if (*namebuf) {
      tmp___51 = namebuf;
    } else { //Added block
    if (directory) {
      tmp___51 = namebuf;
    } else {
      if (currfile) {
        if (valid) {
          tmp___50 = currfile;
        } else {
          tmp___50 = (char_u *)0;
        }
      } else {
        tmp___50 = (char_u *)0;
      }
      tmp___51 = tmp___50;
    }
    }
    {
    qfp->qf_fnum = qf_get_fnum(directory, tmp___51);
    tmp___52 = vim_strsave(errmsg);
    qfp->qf_text = tmp___52;
    }
    if ((unsigned long )tmp___52 == (unsigned long )((void *)0)) {
      goto error1;
    }
    {
    tmp___53 = vim_isprintc(type);
    }
    if (! tmp___53) {
      type = 0;
    }
    qfp->qf_lnum = lnum;
    qfp->qf_col = col;
    qfp->qf_nr = enr;
    qfp->qf_type = (char_u )type;
    qfp->qf_valid = (char_u )valid;
    if (qf_lists[qf_curlist].qf_count == 0) {
      qf_lists[qf_curlist].qf_start = qfp;
      qfp->qf_prev = qfp;
    } else {
      qfp->qf_prev = qfprev;
      qfprev->qf_next = qfp;
    }
    qfp->qf_next = qfp;
    qfp->qf_cleared = (char_u )0;
    qfprev = qfp;
    (qf_lists[qf_curlist].qf_count) ++;
    if (qf_lists[qf_curlist].qf_index == 0) {
      if (qfp->qf_valid) {
        qf_lists[qf_curlist].qf_index = qf_lists[qf_curlist].qf_count;
        qf_lists[qf_curlist].qf_ptr = qfp;
      }
    }
    {
    line_breakcheck();
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
  tmp___55 = ferror(fd);
  }
  if (! tmp___55) {
    if (qf_lists[qf_curlist].qf_index == 0) {
      qf_lists[qf_curlist].qf_ptr = qf_lists[qf_curlist].qf_start;
      qf_lists[qf_curlist].qf_index = 1;
      qf_lists[qf_curlist].qf_nonevalid = 1;
    } else {
      qf_lists[qf_curlist].qf_nonevalid = 0;
    }
    retval = qf_lists[qf_curlist].qf_count;
    goto qf_init_ok;
  }
  {
  emsg(e_readerrf);
  }
  error1: 
  {
  vim_free((void *)qfp);
  }
  error2: 
  {
  qf_free(qf_curlist);
  qf_listcount --;
  }
  if (qf_curlist > 0) {
    qf_curlist --;
  }
  qf_init_ok: 
  {
  fclose(fd);
  fmt_ptr = fmt_first;
  }
  {
  while (1) {
    while_continue___10: /* CIL Label */ ;
    if (! ((unsigned long )fmt_ptr != (unsigned long )((void *)0))) {
      goto while_break___10;
    }
    {
    fmt_first = fmt_ptr->next;
    vim_free((void *)fmt_ptr->prog);
    vim_free((void *)fmt_ptr);
    fmt_ptr = fmt_first;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
  qf_clean_dir_stack(& dir_stack);
  qf_clean_dir_stack(& file_stack);
  }
  qf_init_end: 
  {
  vim_free((void *)namebuf);
  vim_free((void *)errmsg);
  vim_free((void *)fmtstr);
  }
  return (retval);
}
}
static int qf_get_fnum(char_u *directory , char_u *fname ) 
{ 
  char_u *ptr ;
  int fnum ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    return (0);
  } else { //Added block
  if ((int )*fname == 0) {
    return (0);
  } else { //Added block
  if (directory) {
    {
    tmp___1 = mch_isFullName(fname);
    }
    if (tmp___1) {
      {
      tmp___0 = buflist_add(fname);
      }
      return (tmp___0);
    } else {
      {
      ptr = concat_fnames(directory, fname, 1);
      }
      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
        {
        tmp = mch_getperm(ptr);
        }
        if (tmp < 0L) {
          {
          vim_free((void *)ptr);
          directory = qf_guess_filepath(fname);
          }
          if (directory) {
            {
            ptr = concat_fnames(directory, fname, 1);
            }
          } else {
            {
            ptr = vim_strsave(fname);
            }
          }
        }
        {
        fnum = buflist_add(ptr);
        vim_free((void *)ptr);
        }
        return (fnum);
      } else {
        {
        tmp___0 = buflist_add(fname);
        }
        return (tmp___0);
      }
    }
  } else {
    {
    tmp___0 = buflist_add(fname);
    }
    return (tmp___0);
  }
  }
  }
}
}
static char_u *qf_push_dir(char_u *dirbuf , struct dir_stack_t **stackptr ) 
{ 
  struct dir_stack_t *ds_new ;
  struct dir_stack_t *ds_ptr ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = alloc((unsigned int )sizeof(struct dir_stack_t ));
  ds_new = (struct dir_stack_t *)tmp;
  }
  if ((unsigned long )ds_new == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  ds_new->next = *stackptr;
  *stackptr = ds_new;
  tmp___1 = mch_isFullName(dirbuf);
  }
  if (tmp___1) {
    {
    (*stackptr)->dirname = vim_strsave(dirbuf);
    }
  } else { //Added block
  if ((unsigned long )(*stackptr)->next == (unsigned long )((void *)0)) {
    {
    (*stackptr)->dirname = vim_strsave(dirbuf);
    }
  } else { //Added block
  if (*stackptr) {
    if ((unsigned long )dir_stack != (unsigned long )*stackptr) {
      {
      (*stackptr)->dirname = vim_strsave(dirbuf);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    ds_new = (*stackptr)->next;
    (*stackptr)->dirname = (char_u *)((void *)0);
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ds_new) {
        goto while_break;
      }
      {
      vim_free((void *)(*stackptr)->dirname);
      (*stackptr)->dirname = concat_fnames(ds_new->dirname, dirbuf, 1);
      tmp___0 = mch_isdir((*stackptr)->dirname);
      }
      if (tmp___0 == 1) {
        goto while_break;
      }
      ds_new = ds_new->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )(*stackptr)->next != (unsigned long )ds_new)) {
        goto while_break___0;
      }
      {
      ds_ptr = (*stackptr)->next;
      (*stackptr)->next = ((*stackptr)->next)->next;
      vim_free((void *)ds_ptr->dirname);
      vim_free((void *)ds_ptr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((unsigned long )ds_new == (unsigned long )((void *)0)) {
      {
      vim_free((void *)(*stackptr)->dirname);
      (*stackptr)->dirname = vim_strsave(dirbuf);
      }
    }
  }
  }
  }
  if ((unsigned long )(*stackptr)->dirname != (unsigned long )((void *)0)) {
    return ((*stackptr)->dirname);
  } else {
    {
    ds_ptr = *stackptr;
    *stackptr = (*stackptr)->next;
    vim_free((void *)ds_ptr);
    }
    return ((char_u *)((void *)0));
  }
}
}
static char_u *qf_pop_dir(struct dir_stack_t **stackptr ) 
{ 
  struct dir_stack_t *ds_ptr ;
  char_u *tmp ;

  {
  if ((unsigned long )*stackptr != (unsigned long )((void *)0)) {
    {
    ds_ptr = *stackptr;
    *stackptr = (*stackptr)->next;
    vim_free((void *)ds_ptr->dirname);
    vim_free((void *)ds_ptr);
    }
  }
  if (*stackptr) {
    tmp = (*stackptr)->dirname;
  } else {
    tmp = (char_u *)((void *)0);
  }
  return (tmp);
}
}
static void qf_clean_dir_stack(struct dir_stack_t **stackptr ) 
{ 
  struct dir_stack_t *ds_ptr ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    ds_ptr = *stackptr;
    if (! ((unsigned long )ds_ptr != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    *stackptr = (*stackptr)->next;
    vim_free((void *)ds_ptr->dirname);
    vim_free((void *)ds_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char_u *qf_guess_filepath(char_u *filename ) 
{ 
  struct dir_stack_t *ds_ptr ;
  struct dir_stack_t *ds_tmp ;
  char_u *fullname ;
  long tmp ;
  char_u *tmp___0 ;

  {
  if ((unsigned long )dir_stack == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  ds_ptr = dir_stack->next;
  fullname = (char_u *)((void *)0);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ds_ptr) {
      goto while_break;
    }
    {
    vim_free((void *)fullname);
    fullname = concat_fnames(ds_ptr->dirname, filename, 1);
    }
    if ((unsigned long )fullname != (unsigned long )((void *)0)) {
      {
      tmp = mch_getperm(fullname);
      }
      if (tmp >= 0L) {
        goto while_break;
      }
    }
    ds_ptr = ds_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)fullname);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )dir_stack->next != (unsigned long )ds_ptr)) {
      goto while_break___0;
    }
    {
    ds_tmp = dir_stack->next;
    dir_stack->next = (dir_stack->next)->next;
    vim_free((void *)ds_tmp->dirname);
    vim_free((void *)ds_tmp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((unsigned long )ds_ptr == (unsigned long )((void *)0)) {
    tmp___0 = (char_u *)((void *)0);
  } else {
    tmp___0 = ds_ptr->dirname;
  }
  return (tmp___0);
}
}
static char_u *e_no_more_items  =    (char_u *)"No more items";
void qf_jump(int dir , int errornr , int forceit ) 
{ 
  struct qf_line *qf_ptr ;
  struct qf_line *old_qf_ptr ;
  int qf_index ;
  int old_qf_fnum ;
  int old_qf_index ;
  char_u *err ;
  char_u *ptr ;
  linenr_t i___0 ;
  BUF *old_curbuf ;
  linenr_t old_lnum ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  err = e_no_more_items;
  if (qf_curlist >= qf_listcount) {
    {
    emsg(e_quickfix);
    }
    return;
  } else { //Added block
  if (qf_lists[qf_curlist].qf_count == 0) {
    {
    emsg(e_quickfix);
    }
    return;
  }
  }
  qf_ptr = qf_lists[qf_curlist].qf_ptr;
  old_qf_ptr = qf_ptr;
  qf_index = qf_lists[qf_curlist].qf_index;
  old_qf_index = qf_index;
  if (dir == 1) {
    goto _L___2;
  } else { //Added block
  if (dir == 3) {
    _L___2: 
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      tmp = errornr;
      errornr --;
      if (! tmp) {
        goto while_break;
      }
      old_qf_ptr = qf_ptr;
      old_qf_index = qf_index;
      old_qf_fnum = qf_ptr->qf_fnum;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (qf_index == qf_lists[qf_curlist].qf_count) {
          goto _L;
        } else { //Added block
        if ((unsigned long )qf_ptr->qf_next == (unsigned long )((void *)0)) {
          _L: 
          qf_ptr = old_qf_ptr;
          qf_index = old_qf_index;
          if ((unsigned long )err != (unsigned long )((void *)0)) {
            {
            emsg(err);
            }
            goto theend;
          }
          errornr = 0;
          goto while_break___0;
        }
        }
        qf_index ++;
        qf_ptr = qf_ptr->qf_next;
        if (! qf_lists[qf_curlist].qf_nonevalid) {
          if (! (! qf_ptr->qf_valid)) {
            goto _L___0;
          }
        } else { //Added block
        _L___0: 
        if (dir == 3) {
          if (! (qf_ptr->qf_fnum == old_qf_fnum)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      err = (char_u *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if (dir == -1) {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      tmp___0 = errornr;
      errornr --;
      if (! tmp___0) {
        goto while_break___1;
      }
      old_qf_ptr = qf_ptr;
      old_qf_index = qf_index;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (qf_index == 1) {
          goto _L___1;
        } else { //Added block
        if ((unsigned long )qf_ptr->qf_prev == (unsigned long )((void *)0)) {
          _L___1: 
          qf_ptr = old_qf_ptr;
          qf_index = old_qf_index;
          if ((unsigned long )err != (unsigned long )((void *)0)) {
            {
            emsg(err);
            }
            goto theend;
          }
          errornr = 0;
          goto while_break___2;
        }
        }
        qf_index --;
        qf_ptr = qf_ptr->qf_prev;
        if (! qf_lists[qf_curlist].qf_nonevalid) {
          if (! (! qf_ptr->qf_valid)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      err = (char_u *)((void *)0);
    }
    while_break___1: /* CIL Label */ ;
    }
  } else { //Added block
  if (errornr != 0) {
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (errornr < qf_index) {
        if (qf_index > 1) {
          if (! ((unsigned long )qf_ptr->qf_prev != (unsigned long )((void *)0))) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
      } else {
        goto while_break___3;
      }
      qf_index --;
      qf_ptr = qf_ptr->qf_prev;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (errornr > qf_index) {
        if (qf_index < qf_lists[qf_curlist].qf_count) {
          if (! ((unsigned long )qf_ptr->qf_next != (unsigned long )((void *)0))) {
            goto while_break___4;
          }
        } else {
          goto while_break___4;
        }
      } else {
        goto while_break___4;
      }
      qf_index ++;
      qf_ptr = qf_ptr->qf_next;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  }
  }
  }
  old_curbuf = curbuf;
  old_lnum = curwin->w_cursor.lnum;
  if (qf_ptr->qf_fnum == 0) {
    goto _L___4;
  } else {
    {
    tmp___7 = buflist_getfile(qf_ptr->qf_fnum, (linenr_t )1, 5, forceit);
    }
    if (tmp___7 == 1) {
      _L___4: 
      if ((unsigned long )curbuf == (unsigned long )old_curbuf) {
        {
        setpcmark();
        }
      }
      i___0 = qf_ptr->qf_lnum;
      if (i___0 > 0L) {
        if (i___0 > curbuf->b_ml.ml_line_count) {
          i___0 = curbuf->b_ml.ml_line_count;
        }
        curwin->w_cursor.lnum = i___0;
      }
      if (qf_ptr->qf_col > 0) {
        {
        curwin->w_cursor.col = (colnr_t )(qf_ptr->qf_col - 1);
        adjust_cursor();
        }
      } else {
        {
        beginline(5);
        }
      }
      {
      update_topline_redraw();
      tmp___1 = qf_types((int )qf_ptr->qf_type, qf_ptr->qf_nr);
      }
      if (qf_ptr->qf_cleared) {
        tmp___2 = (char_u *)" (line deleted)";
      } else {
        tmp___2 = (char_u *)"";
      }
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"(%d of %d)%s%s: %s",
              qf_index, qf_lists[qf_curlist].qf_count, tmp___2, tmp___1, qf_ptr->qf_text);
      err = vim_strchr(IObuff, '\n');
      }
      if ((unsigned long )err != (unsigned long )((void *)0)) {
        ptr = err;
        {
        while (1) {
          while_continue___5: /* CIL Label */ ;
          tmp___4 = *err;
          *ptr = tmp___4;
          if (! ((int )tmp___4 != 0)) {
            goto while_break___5;
          }
          tmp___3 = err;
          err ++;
          if ((int )*tmp___3 == 10) {
            *ptr = (char_u )' ';
            {
            while (1) {
              while_continue___6: /* CIL Label */ ;
              if (! ((int )*err == 32)) {
                if (! ((int )*err == 9)) {
                  if (! ((int )*err == 10)) {
                    goto while_break___6;
                  }
                }
              }
              err ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          ptr ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      i___0 = (linenr_t )msg_scroll;
      if ((unsigned long )curbuf == (unsigned long )old_curbuf) {
        if (curwin->w_cursor.lnum == old_lnum) {
          msg_scroll = 1;
        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: 
      if (! msg_scrolled) {
        {
        tmp___5 = shortmess('O');
        }
        if (tmp___5) {
          msg_scroll = 0;
        }
      }
      }
      {
      msg(IObuff);
      msg_scroll = (int )i___0;
      tmp___6 = linetabsize(IObuff);
      }
      if ((long )tmp___6 < (long )((int )p_ch - 1) * Columns + (long )sc_col) {
        keep_msg = IObuff;
        keep_msg_attr = 0;
      }
    } else { //Added block
    if (qf_ptr->qf_fnum != 0) {
      qf_ptr = old_qf_ptr;
      qf_index = old_qf_index;
    }
    }
  }
  theend: 
  qf_lists[qf_curlist].qf_ptr = qf_ptr;
  qf_lists[qf_curlist].qf_index = qf_index;
  return;
}
}
void qf_list(char_u *arg , int all ) 
{ 
  BUF *buf___3 ;
  char_u *fname ;
  char_u *ptr ;
  struct qf_line *qfp ;
  int i___0 ;
  int idx1 ;
  int idx2 ;
  int need_return ;
  int last_printed ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  char_u *tmp___3 ;
  char_u tmp___4 ;
  char_u *tmp___5 ;

  {
  idx1 = 1;
  idx2 = -1;
  need_return = 1;
  last_printed = 1;
  if (qf_curlist >= qf_listcount) {
    {
    emsg(e_quickfix);
    }
    return;
  } else { //Added block
  if (qf_lists[qf_curlist].qf_count == 0) {
    {
    emsg(e_quickfix);
    }
    return;
  }
  }
  {
  tmp = get_list_range(& arg, & idx1, & idx2);
  }
  if (tmp) {
    if ((int )*arg != 0) {
      {
      emsg(e_trailing);
      }
      return;
    }
  } else {
    {
    emsg(e_trailing);
    }
    return;
  }
  i___0 = qf_lists[qf_curlist].qf_count;
  if (idx1 < 0) {
    if (- idx1 > i___0) {
      idx1 = 0;
    } else {
      idx1 = (idx1 + i___0) + 1;
    }
  }
  if (idx2 < 0) {
    if (- idx2 > i___0) {
      idx2 = 0;
    } else {
      idx2 = (idx2 + i___0) + 1;
    }
  }
  more_back_used = 1;
  if (qf_lists[qf_curlist].qf_nonevalid) {
    all = 1;
  }
  qfp = qf_lists[qf_curlist].qf_start;
  i___0 = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! got_int) {
      if (! (i___0 <= qf_lists[qf_curlist].qf_count)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (qfp->qf_valid) {
      goto _L;
    } else { //Added block
    if (all) {
      _L: 
      if (idx1 <= i___0) {
        if (i___0 <= idx2) {
          if (need_return) {
            {
            msg_putchar('\n');
            need_return = 0;
            }
          }
          if (more_back == 0) {
            fname = (char_u *)((void *)0);
            if (qfp->qf_fnum != 0) {
              {
              buf___3 = buflist_findnr(qfp->qf_fnum);
              }
              if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
                fname = buf___3->b_fname;
              }
            }
            if ((unsigned long )fname == (unsigned long )((void *)0)) {
              {
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%2d",
                      i___0);
              }
            } else {
              {
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%2d %s",
                      i___0, fname);
              }
            }
            if (i___0 == qf_lists[qf_curlist].qf_index) {
              tmp___0 = highlight_attr[6];
            } else {
              tmp___0 = highlight_attr[2];
            }
            {
            msg_outtrans_attr(IObuff, tmp___0);
            }
            if (qfp->qf_lnum == 0L) {
              *(IObuff + 0) = (char_u )'\000';
            } else { //Added block
            if (qfp->qf_col == 0) {
              {
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )":%ld",
                      qfp->qf_lnum);
              }
            } else {
              {
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )":%ld, col %d",
                      qfp->qf_lnum, qfp->qf_col);
              }
            }
            }
            {
            tmp___1 = qf_types((int )qfp->qf_type, qfp->qf_nr);
            tmp___2 = strlen((char const   *)((char *)IObuff));
            sprintf((char * __restrict  )((char *)IObuff + tmp___2), (char const   * __restrict  )"%s: ",
                    tmp___1);
            msg_puts_attr(IObuff, highlight_attr[9]);
            fname = qfp->qf_text;
            tmp___5 = vim_strchr(fname, '\n');
            }
            if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
              {
              msg_prt_line(qfp->qf_text);
              }
            } else {
              ptr = IObuff;
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                tmp___4 = *fname;
                *ptr = tmp___4;
                if (! ((int )tmp___4 != 0)) {
                  goto while_break___0;
                }
                tmp___3 = fname;
                fname ++;
                if ((int )*tmp___3 == 10) {
                  *ptr = (char_u )' ';
                  {
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    if (! ((int )*fname == 32)) {
                      if (! ((int )*fname == 9)) {
                        if (! ((int )*fname == 10)) {
                          goto while_break___1;
                        }
                      }
                    }
                    fname ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                }
                ptr ++;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              msg_prt_line(IObuff);
              }
            }
            {
            out_flush();
            need_return = 1;
            last_printed = i___0;
            }
          }
        }
      }
    }
    }
    if (more_back) {
      more_back = more_back * 2 - 1;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (i___0 > last_printed - more_back) {
          if (! (i___0 > idx1)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          qfp = qfp->qf_prev;
          i___0 --;
          if (i___0 > idx1) {
            if (! qfp->qf_valid) {
              if (! (! all)) {
                goto while_break___3;
              }
            } else {
              goto while_break___3;
            }
          } else {
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      more_back = 0;
    } else {
      qfp = qfp->qf_next;
      i___0 ++;
    }
    {
    ui_breakcheck();
    }
  }
  while_break: /* CIL Label */ ;
  }
  more_back_used = 0;
  return;
}
}
void qf_older(int count___2 ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = count___2;
    count___2 --;
    if (! tmp) {
      goto while_break;
    }
    if (qf_curlist == 0) {
      {
      emsg((char_u *)"At bottom of quickfix stack");
      }
      return;
    }
    qf_curlist --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  qf_msg();
  }
  return;
}
}
void qf_newer(int count___2 ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = count___2;
    count___2 --;
    if (! tmp) {
      goto while_break;
    }
    if (qf_curlist >= qf_listcount - 1) {
      {
      emsg((char_u *)"At top of quickfix stack");
      }
      return;
    }
    qf_curlist ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  qf_msg();
  }
  return;
}
}
static void qf_msg(void) 
{ 


  {
  {
  smsg((char_u *)"error list %d of %d; %d errors", qf_curlist + 1, qf_listcount, qf_lists[qf_curlist].qf_count);
  }
  return;
}
}
static void qf_free(int idx ) 
{ 
  struct qf_line *qfp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! qf_lists[idx].qf_count) {
      goto while_break;
    }
    {
    qfp = (qf_lists[idx].qf_start)->qf_next;
    vim_free((void *)(qf_lists[idx].qf_start)->qf_text);
    vim_free((void *)qf_lists[idx].qf_start);
    qf_lists[idx].qf_start = qfp;
    (qf_lists[idx].qf_count) --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void qf_mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) 
{ 
  int i___0 ;
  struct qf_line *qfp ;
  int idx ;

  {
  idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (idx < qf_listcount)) {
      goto while_break;
    }
    if (qf_lists[idx].qf_count) {
      i___0 = 0;
      qfp = qf_lists[idx].qf_start;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i___0 < qf_lists[idx].qf_count)) {
          goto while_break___0;
        }
        if (qfp->qf_fnum == curbuf->b_fnum) {
          if (qfp->qf_lnum >= line1) {
            if (qfp->qf_lnum <= line2) {
              if (amount == 2147483647L) {
                qfp->qf_cleared = (char_u )1;
              } else {
                qfp->qf_lnum += amount;
              }
            } else {
              goto _L;
            }
          } else { //Added block
          _L: 
          if (amount_after) {
            if (qfp->qf_lnum > line2) {
              qfp->qf_lnum += amount_after;
            }
          }
          }
        }
        i___0 ++;
        qfp = qfp->qf_next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char_u buf___2[20]  ;
static char_u cc[3]  ;
static char_u *qf_types(int c , int nr ) 
{ 
  char_u *p___0 ;

  {
  if (c == 87) {
    p___0 = (char_u *)" warning";
  } else { //Added block
  if (c == 119) {
    p___0 = (char_u *)" warning";
  } else { //Added block
  if (c == 69) {
    p___0 = (char_u *)"   error";
  } else { //Added block
  if (c == 101) {
    p___0 = (char_u *)"   error";
  } else { //Added block
  if (c == 0) {
    if (nr > 0) {
      p___0 = (char_u *)"   error";
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (c == 0) {
    p___0 = (char_u *)"";
  } else {
    cc[0] = (char_u )' ';
    cc[1] = (char_u )c;
    cc[2] = (char_u )'\000';
    p___0 = cc;
  }
  }
  }
  }
  }
  }
  if (nr <= 0) {
    return (p___0);
  }
  {
  sprintf((char * __restrict  )((char *)(buf___2)), (char const   * __restrict  )"%s %3d",
          p___0, nr);
  }
  return (buf___2);
}
}
#pragma merger("0","/tmp/cil-yZLjftJd.i","-O0")
int vim_regcomp_had_eol(void) ;
static int myisalnum(int c ) ;
static int myisalnum(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 8));
}
}
static int myisalpha(int c ) ;
static int myisalpha(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 1024));
}
}
static int myiscntrl(int c ) ;
static int myiscntrl(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 2));
}
}
static int myisdigit(int c ) ;
static int myisdigit(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 2048));
}
}
static int myisgraph(int c ) ;
static int myisgraph(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 32768));
}
}
static int myislower(int c ) ;
static int myislower(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 512));
}
}
static int myispunct(int c ) ;
static int myispunct(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 4));
}
}
static int myisupper(int c ) ;
static int myisupper(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 256));
}
}
static int myisxdigit(int c ) ;
static int myisxdigit(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  tmp = __ctype_b_loc();
  }
  return ((int )((int const   )*(*tmp + c) & 4096));
}
}
static int re_ismult(int c ) ;
static int cstrncmp(char_u *s1 , char_u *s2 , int n ) ;
static char_u *cstrchr(char_u *s , int c ) ;
static int re_ismult(int c ) 
{ 
  int tmp ;

  {
  if (c == (42 | (92 << 8))) {
    tmp = 1;
  } else { //Added block
  if (c == (43 | (92 << 8))) {
    tmp = 1;
  } else { //Added block
  if (c == (61 | (92 << 8))) {
    tmp = 1;
  } else { //Added block
  if (c == (123 | (92 << 8))) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  }
  return (tmp);
}
}
static char_u *reg_prev_sub  ;
static char_u REGEXP_INRANGE[5]  = {      (char_u )']',      (char_u )'^',      (char_u )'-',      (char_u )'\\', 
        (char_u )'\000'};
static char_u REGEXP_ABBR[5]  = {      (char_u )'r',      (char_u )'t',      (char_u )'e',      (char_u )'b', 
        (char_u )'\000'};
static int backslash_trans(int c ) ;
static int my_isblank(int c ) ;
static int my_istab(int c ) ;
static int my_isbspace(int c ) ;
static int my_isreturn(int c ) ;
static int my_isesc(int c ) ;
static int (*skip_class_name(char_u **pp ))(int  ) ;
static char_u *skip_range(char_u *p___0 ) ;
static void init_class_tab(void) ;
static int backslash_trans(int c ) 
{ 


  {
  {
  if (c == 114) {
    goto case_114;
  }
  if (c == 116) {
    goto case_116;
  }
  if (c == 101) {
    goto case_101;
  }
  if (c == 98) {
    goto case_98;
  }
  goto switch_break;
  case_114: /* CIL Label */ 
  return ('\r');
  case_116: /* CIL Label */ 
  return ('\t');
  case_101: /* CIL Label */ 
  return ('\033');
  case_98: /* CIL Label */ 
  return ('\b');
  switch_break: /* CIL Label */ ;
  }
  return (c);
}
}
static int my_isblank(int c ) 
{ 
  int tmp ;

  {
  if (c == 32) {
    tmp = 1;
  } else { //Added block
  if (c == 9) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
static int my_istab(int c ) 
{ 


  {
  return (c == 9);
}
}
static int my_isbspace(int c ) 
{ 


  {
  return (c == 8);
}
}
static int my_isreturn(int c ) 
{ 


  {
  return (c == 13);
}
}
static int my_isesc(int c ) 
{ 


  {
  return (c == 27);
}
}
static namedata_t const   class_names[16]  = 
  {      {sizeof("alnum:]") - 1UL, & myisalnum, {(char_u )'a', (char_u )'l', (char_u )'n',
                                             (char_u )'u', (char_u )'m', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("alpha:]") - 1UL, & myisalpha, {(char_u )'a', (char_u )'l', (char_u )'p',
                                             (char_u )'h', (char_u )'a', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("blank:]") - 1UL, & my_isblank, {(char_u )'b', (char_u )'l', (char_u )'a',
                                              (char_u )'n', (char_u )'k', (char_u )':',
                                              (char_u )']', (char_u )'\000'}}, 
        {sizeof("cntrl:]") - 1UL, & myiscntrl, {(char_u )'c', (char_u )'n', (char_u )'t',
                                             (char_u )'r', (char_u )'l', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("digit:]") - 1UL, & myisdigit, {(char_u )'d', (char_u )'i', (char_u )'g',
                                             (char_u )'i', (char_u )'t', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("graph:]") - 1UL, & myisgraph, {(char_u )'g', (char_u )'r', (char_u )'a',
                                             (char_u )'p', (char_u )'h', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("lower:]") - 1UL, & myislower, {(char_u )'l', (char_u )'o', (char_u )'w',
                                             (char_u )'e', (char_u )'r', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("print:]") - 1UL, & vim_isprintc, {(char_u )'p', (char_u )'r', (char_u )'i',
                                                (char_u )'n', (char_u )'t', (char_u )':',
                                                (char_u )']', (char_u )'\000'}}, 
        {sizeof("punct:]") - 1UL, & myispunct, {(char_u )'p', (char_u )'u', (char_u )'n',
                                             (char_u )'c', (char_u )'t', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("space:]") - 1UL, & vim_isspace, {(char_u )'s', (char_u )'p', (char_u )'a',
                                               (char_u )'c', (char_u )'e', (char_u )':',
                                               (char_u )']', (char_u )'\000'}}, 
        {sizeof("upper:]") - 1UL, & myisupper, {(char_u )'u', (char_u )'p', (char_u )'p',
                                             (char_u )'e', (char_u )'r', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("xdigit:]") - 1UL, & myisxdigit, {(char_u )'x', (char_u )'d', (char_u )'i',
                                               (char_u )'g', (char_u )'i', (char_u )'t',
                                               (char_u )':', (char_u )']', (char_u )'\000'}}, 
        {sizeof("tab:]") - 1UL,
      & my_istab, {(char_u )'t', (char_u )'a', (char_u )'b', (char_u )':', (char_u )']',
                   (char_u )'\000'}}, 
        {sizeof("return:]") - 1UL, & my_isreturn, {(char_u )'r', (char_u )'e', (char_u )'t',
                                                (char_u )'u', (char_u )'r', (char_u )'n',
                                                (char_u )':', (char_u )']', (char_u )'\000'}}, 
        {sizeof("backspace:]") - 1UL,
      & my_isbspace, {(char_u )'b', (char_u )'a', (char_u )'c', (char_u )'k', (char_u )'s',
                      (char_u )'p', (char_u )'a', (char_u )'c', (char_u )'e', (char_u )':',
                      (char_u )']', (char_u )'\000'}}, 
        {sizeof("escape:]") - 1UL, & my_isesc, {(char_u )'e', (char_u )'s', (char_u )'c',
                                             (char_u )'a', (char_u )'p', (char_u )'e',
                                             (char_u )':', (char_u )']', (char_u )'\000'}}};
static int (*skip_class_name(char_u **pp ))(int  ) 
{ 
  namedata_t const   *np___0 ;
  int tmp ;

  {
  if ((int )*(*pp + 1) != 58) {
    return ((int (*)(int  ))((void *)0));
  }
  np___0 = class_names;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )np___0 < (unsigned long )(class_names + sizeof(class_names) / sizeof(class_names[0])))) {
      goto while_break;
    }
    {
    tmp = strncmp((char const   *)((char *)(*pp + 2)), (char const   *)((char *)(np___0->name)),
                  (size_t )np___0->len);
    }
    if (tmp == 0) {
      *pp += np___0->len + 2UL;
      return ((int (*)(int  ))np___0->func);
    }
    np___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((int (*)(int  ))((void *)0));
}
}
static char_u *skip_range(char_u *p___0 ) 
{ 
  int cpo_lit ;
  char_u *tmp ;
  int tmp___0 ;
  int (*tmp___1)(int  ) ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  if (! reg_syn) {
    {
    tmp = vim_strchr(p_cpo, 'l');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  cpo_lit = tmp___0;
  if ((int )*p___0 == 94) {
    p___0 ++;
  }
  if ((int )*p___0 == 93) {
    p___0 ++;
  } else { //Added block
  if ((int )*p___0 == 45) {
    p___0 ++;
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*p___0 != 0) {
      if (! ((int )*p___0 != 93)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*p___0 == 45) {
      p___0 ++;
      if ((int )*p___0 != 93) {
        if ((int )*p___0 != 0) {
          p___0 ++;
        }
      }
    } else { //Added block
    if ((int )*p___0 == 92) {
      {
      tmp___2 = vim_strchr(REGEXP_INRANGE, (int )*(p___0 + 1));
      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        p___0 += 2;
      } else { //Added block
      if (! cpo_lit) {
        {
        tmp___3 = vim_strchr(REGEXP_ABBR, (int )*(p___0 + 1));
        }
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
          p___0 += 2;
        } else {
          goto _L;
        }
      } else {
        goto _L;
      }
      }
    } else { //Added block
    _L: 
    if ((int )*p___0 == 91) {
      {
      tmp___1 = skip_class_name(& p___0);
      }
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        p___0 ++;
      }
    } else {
      p___0 ++;
    }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
static char_u class_tab[256]  ;
static int done  =    0;
static void init_class_tab(void) 
{ 
  int i___0 ;

  {
  if (done) {
    return;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 256)) {
      goto while_break;
    }
    if (i___0 >= 48) {
      if (i___0 <= 55) {
        class_tab[i___0] = (char_u )15;
      } else {
        goto _L___4;
      }
    } else { //Added block
    _L___4: 
    if (i___0 >= 56) {
      if (i___0 <= 57) {
        class_tab[i___0] = (char_u )11;
      } else {
        goto _L___3;
      }
    } else { //Added block
    _L___3: 
    if (i___0 >= 97) {
      if (i___0 <= 102) {
        class_tab[i___0] = (char_u )122;
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if (i___0 >= 103) {
      if (i___0 <= 122) {
        class_tab[i___0] = (char_u )120;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (i___0 >= 65) {
      if (i___0 <= 70) {
        class_tab[i___0] = (char_u )186;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (i___0 >= 71) {
      if (i___0 <= 90) {
        class_tab[i___0] = (char_u )184;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (i___0 == 95) {
      class_tab[i___0] = (char_u )24;
    }
    }
    }
    }
    }
    }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  done = 1;
  return;
}
}
static char_u *regparse  ;
static int num_complex_braces  ;
static int regnpar  ;
static char_u *regcode  ;
static long regsize  ;
static char_u **regendp  ;
static int brace_min[10]  ;
static int brace_max[10]  ;
static int brace_count[10]  ;
static int had_eol  ;
static int reg_magic  ;
static char_u META[48]  = 
  {      (char_u )'.',      (char_u )'[',      (char_u )'(',      (char_u )')', 
        (char_u )'|',      (char_u )'=',      (char_u )'+',      (char_u )'*', 
        (char_u )'<',      (char_u )'>',      (char_u )'i',      (char_u )'I', 
        (char_u )'k',      (char_u )'K',      (char_u )'f',      (char_u )'F', 
        (char_u )'p',      (char_u )'P',      (char_u )'s',      (char_u )'S', 
        (char_u )'d',      (char_u )'D',      (char_u )'x',      (char_u )'X', 
        (char_u )'o',      (char_u )'O',      (char_u )'w',      (char_u )'W', 
        (char_u )'h',      (char_u )'H',      (char_u )'a',      (char_u )'A', 
        (char_u )'l',      (char_u )'L',      (char_u )'u',      (char_u )'U', 
        (char_u )'~',      (char_u )'1',      (char_u )'2',      (char_u )'3', 
        (char_u )'4',      (char_u )'5',      (char_u )'6',      (char_u )'7', 
        (char_u )'8',      (char_u )'9',      (char_u )'{',      (char_u )'\000'};
static void initchr(char_u *str___1 ) ;
static int getchr(void) ;
static int peekchr(void) ;
static int curchr  ;
static void skipchr(void) ;
static void ungetchr(void) ;
static char_u *reg(int paren , int *flagp ) ;
static char_u *regbranch(int *flagp ) ;
static char_u *regpiece(int *flagp ) ;
static char_u *regatom(int *flagp ) ;
static char_u *regnode(int op ) ;
static char_u *regnext(char_u *p___0 ) ;
static void regc(int b ) ;
static void unregc(void) ;
static void reginsert(int op , char_u *opnd ) ;
static void reginsert_limits(int op , int minval , int maxval , char_u *opnd ) ;
static int read_limits(int start___0 , int end , int *minval , int *maxval ) ;
static void regtail(char_u *p___0 , char_u *val ) ;
static void regoptail(char_u *p___0 , char_u *val ) ;
char_u *skip_regexp(char_u *p___0 , int dirc , int magic ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*(p___0 + 0) != 0)) {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == dirc) {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == 91) {
      if (magic) {
        goto _L;
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if ((int )*(p___0 + 0) == 92) {
      if ((int )*(p___0 + 1) == 91) {
        if (! magic) {
          _L: 
          {
          p___0 = skip_range(p___0 + 1);
          }
          if ((int )*(p___0 + 0) == 0) {
            goto while_break;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if ((int )*(p___0 + 0) == 92) {
      if ((int )*(p___0 + 1) != 0) {
        p___0 ++;
      }
    }
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
vim_regexp *vim_regcomp(char_u *expr , int magic ) 
{ 
  vim_regexp *r ;
  char_u *scan ;
  char_u *longest ;
  int len___0 ;
  int flags___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char_u *tmp___6 ;

  {
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
    emsg(e_null);
    rc_did_emsg = 1;
    }
    return ((vim_regexp *)((void *)0));
  }
  {
  reg_magic = magic;
  init_class_tab();
  initchr(expr);
  num_complex_braces = 0;
  regnpar = 1;
  regsize = 0L;
  regcode = (char_u *)-1;
  regendp = (char_u **)((void *)0);
  had_eol = 0;
  regc(156);
  tmp = reg(0, & flags___0);
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return ((vim_regexp *)((void *)0));
  }
  {
  tmp___0 = lalloc(sizeof(vim_regexp ) + (unsigned long )regsize, 1);
  r = (vim_regexp *)tmp___0;
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    return ((vim_regexp *)((void *)0));
  }
  {
  initchr(expr);
  num_complex_braces = 0;
  regnpar = 1;
  regcode = r->program;
  regendp = r->endp;
  regc(156);
  tmp___1 = reg(0, & flags___0);
  }
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
    vim_free((void *)r);
    }
    return ((vim_regexp *)((void *)0));
  }
  {
  r->regstart = (char_u )'\000';
  r->reganch = (char_u )0;
  r->regmust = (char_u *)((void *)0);
  r->regmlen = 0;
  scan = r->program + 1;
  tmp___6 = regnext(scan);
  }
  if ((int )*tmp___6 == 0) {
    scan += 3;
    if ((int )*scan == 1) {
      {
      r->reganch = (char_u )((int )r->reganch + 1);
      scan = regnext(scan);
      }
    }
    if ((int )*scan == 8) {
      r->regstart = *(scan + 3);
    } else { //Added block
    if ((int )*scan == 13) {
      goto _L;
    } else { //Added block
    if ((int )*scan == 14) {
      _L: 
      {
      tmp___3 = regnext(scan);
      }
      if ((int )*tmp___3 == 8) {
        {
        tmp___2 = regnext(scan);
        r->regstart = *(tmp___2 + 3);
        }
      }
    }
    }
    }
    if (flags___0 & 4) {
      goto _L___0;
    } else { //Added block
    if ((int )*scan == 13) {
      goto _L___0;
    } else { //Added block
    if ((int )*scan == 14) {
      _L___0: 
      longest = (char_u *)((void *)0);
      len___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
          goto while_break;
        }
        if ((int )*scan == 8) {
          {
          tmp___5 = strlen((char const   *)((char *)(scan + 3)));
          }
          if (tmp___5 >= (size_t )len___0) {
            {
            longest = scan + 3;
            tmp___4 = strlen((char const   *)((char *)(scan + 3)));
            len___0 = (int )tmp___4;
            }
          }
        }
        {
        scan = regnext(scan);
        }
      }
      while_break: /* CIL Label */ ;
      }
      r->regmust = longest;
      r->regmlen = len___0;
    }
    }
    }
  }
  return (r);
}
}
int vim_regcomp_had_eol(void) 
{ 


  {
  return (had_eol);
}
}
static char_u *reg(int paren , int *flagp ) 
{ 
  char_u *ret ;
  char_u *br ;
  char_u *ender ;
  int parno ;
  int flags___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  parno = 0;
  *flagp = 1;
  if (paren) {
    if (regnpar >= 10) {
      {
      emsg(e_toombra);
      rc_did_emsg = 1;
      }
      return ((char_u *)((void *)0));
    }
    {
    parno = regnpar;
    regnpar ++;
    ret = regnode(60 + parno);
    }
    if (regendp) {
      *(regendp + parno) = (char_u *)((void *)0);
    }
  } else {
    ret = (char_u *)((void *)0);
  }
  {
  br = regbranch(& flags___0);
  }
  if ((unsigned long )br == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
    regtail(ret, br);
    }
  } else {
    ret = br;
  }
  if (! (flags___0 & 1)) {
    *flagp &= -2;
  }
  *flagp |= flags___0 & 4;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = peekchr();
    }
    if (! (tmp == (124 | (92 << 8)))) {
      goto while_break;
    }
    {
    skipchr();
    br = regbranch(& flags___0);
    }
    if ((unsigned long )br == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    {
    regtail(ret, br);
    }
    if (! (flags___0 & 1)) {
      *flagp &= -2;
    }
    *flagp |= flags___0 & 4;
  }
  while_break: /* CIL Label */ ;
  }
  if (paren) {
    tmp___0 = 70 + parno;
  } else {
    tmp___0 = 0;
  }
  {
  ender = regnode(tmp___0);
  regtail(ret, ender);
  br = ret;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )br != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    regoptail(br, ender);
    br = regnext(br);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (paren) {
    {
    tmp___2 = getchr();
    }
    if (tmp___2 != (41 | (92 << 8))) {
      {
      emsg(e_toombra);
      rc_did_emsg = 1;
      }
      return ((char_u *)((void *)0));
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (! paren) {
    {
    tmp___1 = peekchr();
    }
    if (tmp___1 != 0) {
      if (curchr == (41 | (92 << 8))) {
        {
        emsg(e_toomket);
        rc_did_emsg = 1;
        }
        return ((char_u *)((void *)0));
      } else {
        {
        emsg(e_trailing);
        rc_did_emsg = 1;
        }
        return ((char_u *)((void *)0));
      }
    }
  }
  }
  if (paren) {
    if (regendp) {
      *(regendp + parno) = ender;
    }
  }
  return (ret);
}
}
static char_u *regbranch(int *flagp ) 
{ 
  char_u *ret ;
  char_u *chain ;
  char_u *latest ;
  int flags___0 ;
  int tmp ;

  {
  {
  *flagp = 0;
  ret = regnode(6);
  chain = (char_u *)((void *)0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = peekchr();
    }
    if (tmp != 0) {
      if (curchr != (124 | (92 << 8))) {
        if (! (curchr != (41 | (92 << 8)))) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    latest = regpiece(& flags___0);
    }
    if ((unsigned long )latest == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    *flagp |= flags___0 & 1;
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
      *flagp |= flags___0 & 4;
    } else {
      {
      regtail(chain, latest);
      }
    }
    chain = latest;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
    regnode(9);
    }
  }
  return (ret);
}
}
static char_u *regpiece(int *flagp ) 
{ 
  char_u *ret ;
  int op ;
  char_u *next ;
  int flags___0 ;
  int minval ;
  int maxval ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  ret = regatom(& flags___0);
  }
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  op = peekchr();
  tmp = re_ismult(op);
  }
  if (! tmp) {
    *flagp = flags___0;
    return (ret);
  }
  if (! (flags___0 & 1)) {
    if (op != (61 | (92 << 8))) {
      {
      emsg((char_u *)"*, \\+, or \\{ operand could be empty");
      rc_did_emsg = 1;
      }
      return ((char_u *)((void *)0));
    }
  }
  {
  *flagp = 4;
  skipchr();
  }
  if (op == (42 | (92 << 8))) {
    if (flags___0 & 2) {
      {
      reginsert(10, ret);
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (op == (42 | (92 << 8))) {
    {
    reginsert(6, ret);
    tmp___0 = regnode(7);
    regoptail(ret, tmp___0);
    regoptail(ret, ret);
    tmp___1 = regnode(6);
    regtail(ret, tmp___1);
    tmp___2 = regnode(9);
    regtail(ret, tmp___2);
    }
  } else { //Added block
  if (op == (43 | (92 << 8))) {
    if (flags___0 & 2) {
      {
      reginsert(11, ret);
      *flagp = 1;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (op == (43 | (92 << 8))) {
    {
    next = regnode(6);
    regtail(ret, next);
    tmp___3 = regnode(7);
    regtail(tmp___3, ret);
    tmp___4 = regnode(6);
    regtail(next, tmp___4);
    tmp___5 = regnode(9);
    regtail(ret, tmp___5);
    *flagp = 1;
    }
  } else { //Added block
  if (op == (61 | (92 << 8))) {
    {
    reginsert(6, ret);
    tmp___6 = regnode(6);
    regtail(ret, tmp___6);
    next = regnode(9);
    regtail(ret, next);
    regoptail(ret, next);
    }
  } else { //Added block
  if (op == (123 | (92 << 8))) {
    if (flags___0 & 2) {
      {
      tmp___7 = read_limits('{', '}', & minval, & maxval);
      }
      if (! tmp___7) {
        return ((char_u *)((void *)0));
      }
      {
      reginsert(12, ret);
      reginsert_limits(23, minval, maxval, ret);
      }
      if (minval > 0) {
        *flagp = 1;
      }
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (op == (123 | (92 << 8))) {
    {
    tmp___8 = read_limits('{', '}', & minval, & maxval);
    }
    if (! tmp___8) {
      return ((char_u *)((void *)0));
    }
    if (num_complex_braces >= 10) {
      {
      emsg((char_u *)"Too many complex \\{...}s");
      rc_did_emsg = 1;
      }
      return ((char_u *)((void *)0));
    }
    {
    reginsert(90 + num_complex_braces, ret);
    tmp___9 = regnode(7);
    regoptail(ret, tmp___9);
    regoptail(ret, ret);
    reginsert_limits(23, minval, maxval, ret);
    }
    if (minval > 0) {
      *flagp = 1;
    }
    num_complex_braces ++;
  }
  }
  }
  }
  }
  }
  }
  {
  tmp___10 = peekchr();
  tmp___11 = re_ismult(tmp___10);
  }
  if (tmp___11) {
    {
    emsg((char_u *)"Nested *, \\=, \\+, or \\{");
    rc_did_emsg = 1;
    }
    return ((char_u *)((void *)0));
  }
  return (ret);
}
}
static char_u *regatom(int *flagp ) 
{ 
  char_u *ret ;
  int flags___0 ;
  int cpo_lit ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *p___0 ;
  char_u *tmp___2 ;
  int refnum ;
  int tmp___3 ;
  char_u *p___1 ;
  char_u *tmp___4 ;
  int cclass ;
  int cclassend ;
  char_u *tmp___5 ;
  int tmp___6 ;
  int (*func)(int  ) ;
  int cu ;
  char_u *tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  int len___0 ;
  int chr ;
  int tmp___12 ;

  {
  *flagp = 0;
  if (! reg_syn) {
    {
    tmp = vim_strchr(p_cpo, 'l');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  {
  cpo_lit = tmp___0;
  tmp___1 = getchr();
  }
  {
  if (tmp___1 == (94 | (92 << 8))) {
    goto case_exp;
  }
  if (tmp___1 == (36 | (92 << 8))) {
    goto case_exp___0;
  }
  if (tmp___1 == (60 | (92 << 8))) {
    goto case_exp___1;
  }
  if (tmp___1 == (62 | (92 << 8))) {
    goto case_exp___2;
  }
  if (tmp___1 == (46 | (92 << 8))) {
    goto case_exp___3;
  }
  if (tmp___1 == (105 | (92 << 8))) {
    goto case_exp___4;
  }
  if (tmp___1 == (107 | (92 << 8))) {
    goto case_exp___5;
  }
  if (tmp___1 == (73 | (92 << 8))) {
    goto case_exp___6;
  }
  if (tmp___1 == (75 | (92 << 8))) {
    goto case_exp___7;
  }
  if (tmp___1 == (102 | (92 << 8))) {
    goto case_exp___8;
  }
  if (tmp___1 == (70 | (92 << 8))) {
    goto case_exp___9;
  }
  if (tmp___1 == (112 | (92 << 8))) {
    goto case_exp___10;
  }
  if (tmp___1 == (80 | (92 << 8))) {
    goto case_exp___11;
  }
  if (tmp___1 == (115 | (92 << 8))) {
    goto case_exp___12;
  }
  if (tmp___1 == (83 | (92 << 8))) {
    goto case_exp___13;
  }
  if (tmp___1 == (100 | (92 << 8))) {
    goto case_exp___14;
  }
  if (tmp___1 == (68 | (92 << 8))) {
    goto case_exp___15;
  }
  if (tmp___1 == (120 | (92 << 8))) {
    goto case_exp___16;
  }
  if (tmp___1 == (88 | (92 << 8))) {
    goto case_exp___17;
  }
  if (tmp___1 == (111 | (92 << 8))) {
    goto case_exp___18;
  }
  if (tmp___1 == (79 | (92 << 8))) {
    goto case_exp___19;
  }
  if (tmp___1 == (119 | (92 << 8))) {
    goto case_exp___20;
  }
  if (tmp___1 == (87 | (92 << 8))) {
    goto case_exp___21;
  }
  if (tmp___1 == (104 | (92 << 8))) {
    goto case_exp___22;
  }
  if (tmp___1 == (72 | (92 << 8))) {
    goto case_exp___23;
  }
  if (tmp___1 == (97 | (92 << 8))) {
    goto case_exp___24;
  }
  if (tmp___1 == (65 | (92 << 8))) {
    goto case_exp___25;
  }
  if (tmp___1 == (108 | (92 << 8))) {
    goto case_exp___26;
  }
  if (tmp___1 == (76 | (92 << 8))) {
    goto case_exp___27;
  }
  if (tmp___1 == (117 | (92 << 8))) {
    goto case_exp___28;
  }
  if (tmp___1 == (85 | (92 << 8))) {
    goto case_exp___29;
  }
  if (tmp___1 == (40 | (92 << 8))) {
    goto case_exp___30;
  }
  if (tmp___1 == 0) {
    goto case_0;
  }
  if (tmp___1 == (124 | (92 << 8))) {
    goto case_0;
  }
  if (tmp___1 == (41 | (92 << 8))) {
    goto case_0;
  }
  if (tmp___1 == (61 | (92 << 8))) {
    goto case_exp___33;
  }
  if (tmp___1 == (43 | (92 << 8))) {
    goto case_exp___34;
  }
  if (tmp___1 == (123 | (92 << 8))) {
    goto case_exp___35;
  }
  if (tmp___1 == (42 | (92 << 8))) {
    goto case_exp___36;
  }
  if (tmp___1 == (126 | (92 << 8))) {
    goto case_exp___37;
  }
  if (tmp___1 == (49 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (50 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (51 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (52 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (53 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (54 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (55 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (56 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (57 | (92 << 8))) {
    goto case_exp___38;
  }
  if (tmp___1 == (91 | (92 << 8))) {
    goto case_exp___47;
  }
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
  ret = regnode(1);
  }
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
  ret = regnode(2);
  had_eol = 1;
  }
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  {
  ret = regnode(13);
  }
  goto switch_break;
  case_exp___2: /* CIL Label */ 
  {
  ret = regnode(14);
  }
  goto switch_break;
  case_exp___3: /* CIL Label */ 
  {
  ret = regnode(3);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___4: /* CIL Label */ 
  {
  ret = regnode(15);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___5: /* CIL Label */ 
  {
  ret = regnode(16);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___6: /* CIL Label */ 
  {
  ret = regnode(19);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___7: /* CIL Label */ 
  {
  ret = regnode(20);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  {
  ret = regnode(17);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___9: /* CIL Label */ 
  {
  ret = regnode(21);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___10: /* CIL Label */ 
  {
  ret = regnode(18);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___11: /* CIL Label */ 
  {
  ret = regnode(22);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___12: /* CIL Label */ 
  {
  ret = regnode(24);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___13: /* CIL Label */ 
  {
  ret = regnode(25);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___14: /* CIL Label */ 
  {
  ret = regnode(26);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___15: /* CIL Label */ 
  {
  ret = regnode(27);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___16: /* CIL Label */ 
  {
  ret = regnode(28);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___17: /* CIL Label */ 
  {
  ret = regnode(29);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___18: /* CIL Label */ 
  {
  ret = regnode(30);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___19: /* CIL Label */ 
  {
  ret = regnode(31);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___20: /* CIL Label */ 
  {
  ret = regnode(32);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___21: /* CIL Label */ 
  {
  ret = regnode(33);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___22: /* CIL Label */ 
  {
  ret = regnode(34);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___23: /* CIL Label */ 
  {
  ret = regnode(35);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___24: /* CIL Label */ 
  {
  ret = regnode(36);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___25: /* CIL Label */ 
  {
  ret = regnode(37);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___26: /* CIL Label */ 
  {
  ret = regnode(38);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___27: /* CIL Label */ 
  {
  ret = regnode(39);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___28: /* CIL Label */ 
  {
  ret = regnode(40);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___29: /* CIL Label */ 
  {
  ret = regnode(41);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___30: /* CIL Label */ 
  {
  ret = reg(1, & flags___0);
  }
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  *flagp |= flags___0 & 5;
  goto switch_break;
  case_0: /* CIL Label */ 
  case_exp___31: /* CIL Label */ 
  case_exp___32: /* CIL Label */ 
  {
  emsg(e_internal);
  rc_did_emsg = 1;
  }
  return ((char_u *)((void *)0));
  case_exp___33: /* CIL Label */ 
  {
  emsg((char_u *)"\\= follows nothing");
  rc_did_emsg = 1;
  }
  return ((char_u *)((void *)0));
  case_exp___34: /* CIL Label */ 
  {
  emsg((char_u *)"\\+ follows nothing");
  rc_did_emsg = 1;
  }
  return ((char_u *)((void *)0));
  case_exp___35: /* CIL Label */ 
  {
  emsg((char_u *)"\\{ follows nothing");
  rc_did_emsg = 1;
  }
  return ((char_u *)((void *)0));
  case_exp___36: /* CIL Label */ 
  if (reg_magic) {
    {
    emsg((char_u *)"* follows nothing");
    rc_did_emsg = 1;
    }
    return ((char_u *)((void *)0));
  } else {
    {
    emsg((char_u *)"\\* follows nothing");
    rc_did_emsg = 1;
    }
    return ((char_u *)((void *)0));
  }
  case_exp___37: /* CIL Label */ 
  if (reg_prev_sub) {
    {
    ret = regnode(8);
    p___0 = reg_prev_sub;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break;
      }
      {
      tmp___2 = p___0;
      p___0 ++;
      regc((int )*tmp___2);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    regc('\000');
    }
    if (p___0 - reg_prev_sub) {
      *flagp |= 1;
      if (p___0 - reg_prev_sub == 1L) {
        *flagp |= 2;
      }
    }
  } else {
    {
    emsg(e_nopresub);
    rc_did_emsg = 1;
    }
    return ((char_u *)((void *)0));
  }
  goto switch_break;
  case_exp___38: /* CIL Label */ 
  case_exp___39: /* CIL Label */ 
  case_exp___40: /* CIL Label */ 
  case_exp___41: /* CIL Label */ 
  case_exp___42: /* CIL Label */ 
  case_exp___43: /* CIL Label */ 
  case_exp___44: /* CIL Label */ 
  case_exp___45: /* CIL Label */ 
  case_exp___46: /* CIL Label */ 
  {
  ungetchr();
  tmp___3 = getchr();
  refnum = tmp___3 - (48 | (92 << 8));
  }
  if (refnum < regnpar) {
    if ((unsigned long )regendp == (unsigned long )((void *)0)) {
      {
      ret = regnode(80 + refnum);
      }
    } else { //Added block
    if ((unsigned long )*(regendp + refnum) != (unsigned long )((void *)0)) {
      {
      ret = regnode(80 + refnum);
      }
    } else {
      {
      emsg((char_u *)"Illegal back reference");
      rc_did_emsg = 1;
      }
      return ((char_u *)((void *)0));
    }
    }
  } else {
    {
    emsg((char_u *)"Illegal back reference");
    rc_did_emsg = 1;
    }
    return ((char_u *)((void *)0));
  }
  goto switch_break;
  case_exp___47: /* CIL Label */ 
  {
  p___1 = skip_range(regparse);
  }
  if ((int )*p___1 == 93) {
    if ((int )*regparse == 94) {
      {
      ret = regnode(5);
      regparse ++;
      }
    } else {
      {
      ret = regnode(4);
      }
    }
    if ((int )*regparse == 93) {
      {
      tmp___4 = regparse;
      regparse ++;
      regc((int )*tmp___4);
      }
    } else { //Added block
    if ((int )*regparse == 45) {
      {
      tmp___4 = regparse;
      regparse ++;
      regc((int )*tmp___4);
      }
    }
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((int )*regparse != 0) {
        if (! ((int )*regparse != 93)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      if ((int )*regparse == 45) {
        regparse ++;
        if ((int )*regparse == 93) {
          {
          regc('-');
          }
        } else { //Added block
        if ((int )*regparse == 0) {
          {
          regc('-');
          }
        } else {
          cclass = (int )*(regparse - 2) + 1;
          cclassend = (int )*regparse;
          if (cclass > cclassend + 1) {
            {
            emsg(e_invrange);
            rc_did_emsg = 1;
            }
            return ((char_u *)((void *)0));
          }
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (cclass <= cclassend)) {
              goto while_break___1;
            }
            {
            regc(cclass);
            cclass ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          regparse ++;
        }
        }
      } else { //Added block
      if ((int )*regparse == 92) {
        {
        tmp___10 = vim_strchr(REGEXP_INRANGE, (int )*(regparse + 1));
        }
        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
          {
          regparse ++;
          tmp___5 = regparse;
          regparse ++;
          tmp___6 = backslash_trans((int )*tmp___5);
          regc(tmp___6);
          }
        } else { //Added block
        if (! cpo_lit) {
          {
          tmp___11 = vim_strchr(REGEXP_ABBR, (int )*(regparse + 1));
          }
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
            {
            regparse ++;
            tmp___5 = regparse;
            regparse ++;
            tmp___6 = backslash_trans((int )*tmp___5);
            regc(tmp___6);
            }
          } else {
            goto _L;
          }
        } else {
          goto _L;
        }
        }
      } else { //Added block
      _L: 
      if ((int )*regparse == 91) {
        {
        func = skip_class_name(& regparse);
        }
        if ((unsigned long )func == (unsigned long )((void *)0)) {
          {
          tmp___7 = regparse;
          regparse ++;
          regc((int )*tmp___7);
          }
        } else {
          cu = 1;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! (cu <= 255)) {
              goto while_break___2;
            }
            {
            tmp___8 = (*func)(cu);
            }
            if (tmp___8) {
              {
              regc(cu);
              }
            }
            cu ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else {
        {
        tmp___9 = regparse;
        regparse ++;
        regc((int )*tmp___9);
        }
      }
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    regc('\000');
    }
    if ((int )*regparse != 93) {
      {
      emsg(e_toomsbra);
      rc_did_emsg = 1;
      }
      return ((char_u *)((void *)0));
    }
    {
    skipchr();
    *flagp |= 3;
    }
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
  ungetchr();
  len___0 = 0;
  ret = regnode(8);
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
    chr = peekchr();
    }
    if (chr != 0) {
      if (! (chr < 92 << 8)) {
        if (! (len___0 == 0)) {
          goto while_break___3;
        }
      }
    } else {
      goto while_break___3;
    }
    {
    regc(chr);
    skipchr();
    len___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  if (len___0 > 1) {
    {
    tmp___12 = re_ismult(chr);
    }
    if (tmp___12) {
      {
      unregc();
      ungetchr();
      len___0 --;
      }
    }
  }
  {
  regc('\000');
  *flagp |= 1;
  }
  if (len___0 == 1) {
    *flagp |= 2;
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return (ret);
}
}
static char_u *regnode(int op ) 
{ 
  char_u *ret ;
  char_u *ptr ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  ret = regcode;
  if ((unsigned long )ret == (unsigned long )((char_u *)-1)) {
    regsize += 3L;
    return (ret);
  }
  ptr = ret;
  tmp = ptr;
  ptr ++;
  *tmp = (char_u )op;
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (char_u )'\000';
  tmp___1 = ptr;
  ptr ++;
  *tmp___1 = (char_u )'\000';
  regcode = ptr;
  return (ret);
}
}
static void regc(int b ) 
{ 
  char_u *tmp ;

  {
  if ((unsigned long )regcode != (unsigned long )((char_u *)-1)) {
    tmp = regcode;
    regcode ++;
    *tmp = (char_u )b;
  } else {
    regsize ++;
  }
  return;
}
}
static void unregc(void) 
{ 


  {
  if ((unsigned long )regcode != (unsigned long )((char_u *)-1)) {
    regcode --;
  } else {
    regsize --;
  }
  return;
}
}
static void reginsert(int op , char_u *opnd ) 
{ 
  char_u *src ;
  char_u *dst ;
  char_u *place ;
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  if ((unsigned long )regcode == (unsigned long )((char_u *)-1)) {
    regsize += 3L;
    return;
  }
  src = regcode;
  regcode += 3;
  dst = regcode;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )src > (unsigned long )opnd)) {
      goto while_break;
    }
    dst --;
    src --;
    *dst = *src;
  }
  while_break: /* CIL Label */ ;
  }
  place = opnd;
  tmp = place;
  place ++;
  *tmp = (char_u )op;
  tmp___0 = place;
  place ++;
  *tmp___0 = (char_u )'\000';
  *place = (char_u )'\000';
  return;
}
}
static void reginsert_limits(int op , int minval , int maxval , char_u *opnd ) 
{ 
  char_u *src ;
  char_u *dst ;
  char_u *place ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;

  {
  if ((unsigned long )regcode == (unsigned long )((char_u *)-1)) {
    regsize += 7L;
    return;
  }
  src = regcode;
  regcode += 7;
  dst = regcode;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )src > (unsigned long )opnd)) {
      goto while_break;
    }
    dst --;
    src --;
    *dst = *src;
  }
  while_break: /* CIL Label */ ;
  }
  {
  place = opnd;
  tmp = place;
  place ++;
  *tmp = (char_u )op;
  tmp___0 = place;
  place ++;
  *tmp___0 = (char_u )'\000';
  tmp___1 = place;
  place ++;
  *tmp___1 = (char_u )'\000';
  tmp___2 = place;
  place ++;
  *tmp___2 = (char_u )(((unsigned int )minval >> 8) & 255U);
  tmp___3 = place;
  place ++;
  *tmp___3 = (char_u )(minval & 255);
  tmp___4 = place;
  place ++;
  *tmp___4 = (char_u )(((unsigned int )maxval >> 8) & 255U);
  tmp___5 = place;
  place ++;
  *tmp___5 = (char_u )(maxval & 255);
  regtail(opnd, place);
  }
  return;
}
}
static void regtail(char_u *p___0 , char_u *val ) 
{ 
  char_u *scan ;
  char_u *temp ;
  int offset ;

  {
  if ((unsigned long )p___0 == (unsigned long )((char_u *)-1)) {
    return;
  }
  scan = p___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    temp = regnext(scan);
    }
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
      goto while_break;
    }
    scan = temp;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*scan == 7) {
    offset = (int )(scan - val);
  } else {
    offset = (int )(val - scan);
  }
  *(scan + 1) = (char_u )(((unsigned int )offset >> 8) & 255U);
  *(scan + 2) = (char_u )(offset & 255);
  return;
}
}
static void regoptail(char_u *p___0 , char_u *val ) 
{ 


  {
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    return;
  } else { //Added block
  if ((unsigned long )p___0 == (unsigned long )((char_u *)-1)) {
    return;
  } else { //Added block
  if ((int )*p___0 != 6) {
    if ((int )*p___0 < 90) {
      return;
    } else { //Added block
    if ((int )*p___0 > 99) {
      return;
    }
    }
  }
  }
  }
  {
  regtail(p___0 + 3, val);
  }
  return;
}
}
static int prevchr  ;
static int nextchr  ;
static int at_start  ;
static int prev_at_start  ;
static void initchr(char_u *str___1 ) 
{ 


  {
  regparse = str___1;
  nextchr = -1;
  prevchr = nextchr;
  curchr = prevchr;
  at_start = 1;
  prev_at_start = 0;
  return;
}
}
static int peekchr(void) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  if (curchr < 0) {
    curchr = (int )*(regparse + 0);
    {
    if (curchr == 46) {
      goto case_46;
    }
    if (curchr == 91) {
      goto case_46;
    }
    if (curchr == 126) {
      goto case_46;
    }
    if (curchr == 42) {
      goto case_42;
    }
    if (curchr == 94) {
      goto case_94;
    }
    if (curchr == 36) {
      goto case_36;
    }
    if (curchr == 92) {
      goto case_92;
    }
    goto switch_break;
    case_46: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_126: /* CIL Label */ 
    if (reg_magic) {
      curchr |= 92 << 8;
    }
    goto switch_break;
    case_42: /* CIL Label */ 
    if (reg_magic) {
      if (! at_start) {
        if (prev_at_start) {
          if (! (prevchr == (94 | (92 << 8)))) {
            curchr = 42 | (92 << 8);
          }
        } else {
          curchr = 42 | (92 << 8);
        }
      }
    }
    goto switch_break;
    case_94: /* CIL Label */ 
    if (at_start) {
      curchr = 94 | (92 << 8);
      at_start = 1;
      prev_at_start = 0;
    } else { //Added block
    if (prevchr == (40 | (92 << 8))) {
      curchr = 94 | (92 << 8);
      at_start = 1;
      prev_at_start = 0;
    } else { //Added block
    if (prevchr == (124 | (92 << 8))) {
      curchr = 94 | (92 << 8);
      at_start = 1;
      prev_at_start = 0;
    }
    }
    }
    goto switch_break;
    case_36: /* CIL Label */ 
    if ((int )*(regparse + 1) == 0) {
      curchr = 36 | (92 << 8);
    } else { //Added block
    if ((int )*(regparse + 1) == 92) {
      if ((int )*(regparse + 2) == 124) {
        curchr = 36 | (92 << 8);
      } else { //Added block
      if ((int )*(regparse + 2) == 41) {
        curchr = 36 | (92 << 8);
      }
      }
    }
    }
    goto switch_break;
    case_92: /* CIL Label */ 
    regparse ++;
    if ((int )*(regparse + 0) == 0) {
      curchr = '\\';
      regparse --;
    } else {
      {
      tmp___0 = vim_strchr(META, (int )*(regparse + 0));
      }
      if (tmp___0) {
        {
        curchr = -1;
        prev_at_start = at_start;
        at_start = 0;
        peekchr();
        curchr ^= 92 << 8;
        }
      } else {
        {
        tmp = vim_strchr(REGEXP_ABBR, (int )*(regparse + 0));
        }
        if (tmp) {
          {
          curchr = backslash_trans((int )*(regparse + 0));
          }
        } else {
          curchr = (int )*(regparse + 0);
        }
      }
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  return (curchr);
}
}
static void skipchr(void) 
{ 


  {
  regparse ++;
  prev_at_start = at_start;
  at_start = 0;
  prevchr = curchr;
  curchr = nextchr;
  nextchr = -1;
  return;
}
}
static int getchr(void) 
{ 
  int chr ;

  {
  {
  chr = peekchr();
  skipchr();
  }
  return (chr);
}
}
static void ungetchr(void) 
{ 


  {
  nextchr = curchr;
  curchr = prevchr;
  at_start = prev_at_start;
  prev_at_start = 0;
  regparse --;
  return;
}
}
static int read_limits(int start___0 , int end , int *minval , int *maxval ) 
{ 
  int reverse ;
  char_u *first_char ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  reverse = 0;
  if ((int )*regparse == 45) {
    regparse ++;
    reverse = 1;
  }
  {
  first_char = regparse;
  tmp = getdigits(& regparse);
  *minval = (int )tmp;
  }
  if ((int )*regparse == 44) {
    {
    regparse ++;
    tmp___1 = myisdigit((int )*regparse);
    }
    if (tmp___1) {
      {
      tmp___0 = getdigits(& regparse);
      *maxval = (int )tmp___0;
      }
    } else {
      *maxval = 32767;
    }
  } else {
    {
    tmp___2 = myisdigit((int )*first_char);
    }
    if (tmp___2) {
      *maxval = *minval;
    } else {
      *maxval = 32767;
    }
  }
  if ((int )*regparse == 92) {
    regparse ++;
  }
  if ((int )*regparse != end) {
    if ((int )*regparse != 0) {
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Syntax error in \\%c...%c",
              start___0, end);
      emsg(IObuff);
      rc_did_emsg = 1;
      }
      return (0);
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (*maxval == 0) {
    if (*minval == 0) {
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Syntax error in \\%c...%c",
              start___0, end);
      emsg(IObuff);
      rc_did_emsg = 1;
      }
      return (0);
    }
  }
  }
  if (! reverse) {
    if (*minval > *maxval) {
      tmp___3 = *minval;
      *minval = *maxval;
      *maxval = tmp___3;
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (reverse) {
    if (*minval < *maxval) {
      tmp___3 = *minval;
      *minval = *maxval;
      *maxval = tmp___3;
    }
  }
  }
  {
  skipchr();
  }
  return (1);
}
}
static char_u *reginput  ;
static char_u *regbol  ;
static char_u **regstartp  ;
static int need_clear_subexpr  ;
static int regtry(vim_regexp *prog , char_u *string___0 ) ;
static void clear_subexpr(void) ;
static int regmatch(char_u *prog ) ;
static int regrepeat(char_u *p___0 ) ;
int vim_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) 
{ 
  char_u *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;

  {
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
    emsg(e_null);
    }
    return (0);
  } else { //Added block
  if ((unsigned long )string___0 == (unsigned long )((void *)0)) {
    {
    emsg(e_null);
    }
    return (0);
  }
  }
  if ((int )prog->program[0] != 156) {
    {
    emsg(e_re_corr);
    }
    return (0);
  }
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
    s = string___0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      s = cstrchr(s, (int )*(prog->regmust + 0));
      }
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {
      tmp = cstrncmp(s, prog->regmust, prog->regmlen);
      }
      if (tmp == 0) {
        goto while_break;
      }
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  if (at_bol) {
    regbol = string___0;
  } else {
    regbol = (char_u *)((void *)0);
  }
  if (prog->reganch) {
    if ((int )prog->regstart != 0) {
      if ((int )prog->regstart != (int )*(string___0 + 0)) {
        if (! reg_ic) {
          return (0);
        } else {
          {
          tmp___0 = tolower((int )prog->regstart);
          tmp___1 = tolower((int )*(string___0 + 0));
          }
          if (tmp___0 != tmp___1) {
            return (0);
          }
        }
      }
    }
    {
    tmp___2 = regtry(prog, string___0);
    }
    return (tmp___2);
  }
  s = string___0;
  if ((int )prog->regstart != 0) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      s = cstrchr(s, (int )prog->regstart);
      }
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      tmp___3 = regtry(prog, s);
      }
      if (tmp___3) {
        return (1);
      }
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___4 = regtry(prog, s);
      }
      if (tmp___4) {
        return (1);
      }
      tmp___5 = s;
      s ++;
      if (! ((int )*tmp___5 != 0)) {
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return (0);
}
}
static int regtry(vim_regexp *prog , char_u *string___0 ) 
{ 
  int tmp ;

  {
  {
  reginput = string___0;
  regstartp = prog->startp;
  regendp = prog->endp;
  need_clear_subexpr = 1;
  tmp = regmatch(prog->program + 1);
  }
  if (tmp) {
    {
    clear_subexpr();
    prog->startp[0] = string___0;
    prog->endp[0] = reginput;
    }
    return (1);
  } else {
    return (0);
  }
}
}
static void clear_subexpr(void) 
{ 


  {
  if (need_clear_subexpr) {
    {
    memset((void *)regstartp, 0, sizeof(char_u *) * 10UL);
    memset((void *)regendp, 0, sizeof(char_u *) * 10UL);
    need_clear_subexpr = 0;
    }
  }
  return;
}
}
static int break_count  =    0;
static int regmatch(char_u *prog ) 
{ 
  char_u *scan ;
  char_u *next ;
  int minval ;
  int maxval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int len___0 ;
  char_u *opnd ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char_u *tmp___19 ;
  char_u *tmp___20 ;
  int no ;
  char_u *save ;
  int tmp___21 ;
  int no___0 ;
  char_u *save___0 ;
  int tmp___22 ;
  int no___1 ;
  int len___1 ;
  int tmp___23 ;
  char_u *save___1 ;
  int tmp___24 ;
  int no___2 ;
  int no___3 ;
  char_u *save___2 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int nextch ;
  int nextch_ic ;
  int no___4 ;
  char_u *save___3 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
  minval = -1;
  maxval = -1;
  break_count ++;
  if ((break_count & 4095) == 0) {
    {
    ui_breakcheck();
    }
  }
  scan = prog;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (got_int) {
      return (0);
    }
    {
    next = regnext(scan);
    }
    {
    if ((int )*scan == 1) {
      goto case_1;
    }
    if ((int )*scan == 2) {
      goto case_2;
    }
    if ((int )*scan == 13) {
      goto case_13;
    }
    if ((int )*scan == 14) {
      goto case_14;
    }
    if ((int )*scan == 3) {
      goto case_3;
    }
    if ((int )*scan == 15) {
      goto case_15;
    }
    if ((int )*scan == 16) {
      goto case_16;
    }
    if ((int )*scan == 17) {
      goto case_17;
    }
    if ((int )*scan == 18) {
      goto case_18;
    }
    if ((int )*scan == 19) {
      goto case_19;
    }
    if ((int )*scan == 20) {
      goto case_20;
    }
    if ((int )*scan == 21) {
      goto case_21;
    }
    if ((int )*scan == 22) {
      goto case_22;
    }
    if ((int )*scan == 24) {
      goto case_24;
    }
    if ((int )*scan == 25) {
      goto case_25;
    }
    if ((int )*scan == 26) {
      goto case_26;
    }
    if ((int )*scan == 27) {
      goto case_27;
    }
    if ((int )*scan == 28) {
      goto case_28;
    }
    if ((int )*scan == 29) {
      goto case_29;
    }
    if ((int )*scan == 30) {
      goto case_30;
    }
    if ((int )*scan == 31) {
      goto case_31;
    }
    if ((int )*scan == 32) {
      goto case_32;
    }
    if ((int )*scan == 33) {
      goto case_33;
    }
    if ((int )*scan == 34) {
      goto case_34;
    }
    if ((int )*scan == 35) {
      goto case_35;
    }
    if ((int )*scan == 36) {
      goto case_36;
    }
    if ((int )*scan == 37) {
      goto case_37;
    }
    if ((int )*scan == 38) {
      goto case_38;
    }
    if ((int )*scan == 39) {
      goto case_39;
    }
    if ((int )*scan == 40) {
      goto case_40;
    }
    if ((int )*scan == 41) {
      goto case_41;
    }
    if ((int )*scan == 8) {
      goto case_8;
    }
    if ((int )*scan == 4) {
      goto case_4;
    }
    if ((int )*scan == 5) {
      goto case_5;
    }
    if ((int )*scan == 9) {
      goto case_9;
    }
    if ((int )*scan == 7) {
      goto case_7;
    }
    if ((int )*scan == 61) {
      goto case_61;
    }
    if ((int )*scan == 62) {
      goto case_61;
    }
    if ((int )*scan == 63) {
      goto case_61;
    }
    if ((int )*scan == 64) {
      goto case_61;
    }
    if ((int )*scan == 65) {
      goto case_61;
    }
    if ((int )*scan == 66) {
      goto case_61;
    }
    if ((int )*scan == 67) {
      goto case_61;
    }
    if ((int )*scan == 68) {
      goto case_61;
    }
    if ((int )*scan == 69) {
      goto case_61;
    }
    if ((int )*scan == 71) {
      goto case_71;
    }
    if ((int )*scan == 72) {
      goto case_71;
    }
    if ((int )*scan == 73) {
      goto case_71;
    }
    if ((int )*scan == 74) {
      goto case_71;
    }
    if ((int )*scan == 75) {
      goto case_71;
    }
    if ((int )*scan == 76) {
      goto case_71;
    }
    if ((int )*scan == 77) {
      goto case_71;
    }
    if ((int )*scan == 78) {
      goto case_71;
    }
    if ((int )*scan == 79) {
      goto case_71;
    }
    if ((int )*scan == 81) {
      goto case_81;
    }
    if ((int )*scan == 82) {
      goto case_81;
    }
    if ((int )*scan == 83) {
      goto case_81;
    }
    if ((int )*scan == 84) {
      goto case_81;
    }
    if ((int )*scan == 85) {
      goto case_81;
    }
    if ((int )*scan == 86) {
      goto case_81;
    }
    if ((int )*scan == 87) {
      goto case_81;
    }
    if ((int )*scan == 88) {
      goto case_81;
    }
    if ((int )*scan == 89) {
      goto case_81;
    }
    if ((int )*scan == 6) {
      goto case_6;
    }
    if ((int )*scan == 23) {
      goto case_23;
    }
    if ((int )*scan == 90) {
      goto case_90;
    }
    if ((int )*scan == 91) {
      goto case_90;
    }
    if ((int )*scan == 92) {
      goto case_90;
    }
    if ((int )*scan == 93) {
      goto case_90;
    }
    if ((int )*scan == 94) {
      goto case_90;
    }
    if ((int )*scan == 95) {
      goto case_90;
    }
    if ((int )*scan == 96) {
      goto case_90;
    }
    if ((int )*scan == 97) {
      goto case_90;
    }
    if ((int )*scan == 98) {
      goto case_90;
    }
    if ((int )*scan == 99) {
      goto case_90;
    }
    if ((int )*scan == 12) {
      goto case_12;
    }
    if ((int )*scan == 10) {
      goto case_12;
    }
    if ((int )*scan == 11) {
      goto case_12;
    }
    if ((int )*scan == 0) {
      goto case_0;
    }
    goto switch_default;
    case_1: /* CIL Label */ 
    if ((unsigned long )reginput != (unsigned long )regbol) {
      return (0);
    }
    goto switch_break;
    case_2: /* CIL Label */ 
    if ((int )*reginput != 0) {
      return (0);
    }
    goto switch_break;
    case_13: /* CIL Label */ 
    if ((unsigned long )reginput != (unsigned long )regbol) {
      {
      tmp = vim_iswordc((int )*(reginput + -1));
      }
      if (tmp) {
        return (0);
      }
    }
    if (! *(reginput + 0)) {
      return (0);
    } else {
      {
      tmp___0 = vim_iswordc((int )*(reginput + 0));
      }
      if (! tmp___0) {
        return (0);
      }
    }
    goto switch_break;
    case_14: /* CIL Label */ 
    if ((unsigned long )reginput == (unsigned long )regbol) {
      return (0);
    } else {
      {
      tmp___1 = vim_iswordc((int )*(reginput + -1));
      }
      if (! tmp___1) {
        return (0);
      }
    }
    if (*(reginput + 0)) {
      {
      tmp___2 = vim_iswordc((int )*(reginput + 0));
      }
      if (tmp___2) {
        return (0);
      }
    }
    goto switch_break;
    case_3: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_15: /* CIL Label */ 
    {
    tmp___3 = vim_isIDc((int )*reginput);
    }
    if (! tmp___3) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_16: /* CIL Label */ 
    {
    tmp___4 = vim_iswordc((int )*reginput);
    }
    if (! tmp___4) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_17: /* CIL Label */ 
    {
    tmp___5 = vim_isfilec((int )*reginput);
    }
    if (! tmp___5) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_18: /* CIL Label */ 
    {
    tmp___6 = charsize((int )*reginput);
    }
    if (tmp___6 != 1) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_19: /* CIL Label */ 
    {
    tmp___7 = myisdigit((int )*reginput);
    }
    if (tmp___7) {
      return (0);
    } else {
      {
      tmp___8 = vim_isIDc((int )*reginput);
      }
      if (! tmp___8) {
        return (0);
      }
    }
    reginput ++;
    goto switch_break;
    case_20: /* CIL Label */ 
    {
    tmp___9 = myisdigit((int )*reginput);
    }
    if (tmp___9) {
      return (0);
    } else {
      {
      tmp___10 = vim_iswordc((int )*reginput);
      }
      if (! tmp___10) {
        return (0);
      }
    }
    reginput ++;
    goto switch_break;
    case_21: /* CIL Label */ 
    {
    tmp___11 = myisdigit((int )*reginput);
    }
    if (tmp___11) {
      return (0);
    } else {
      {
      tmp___12 = vim_isfilec((int )*reginput);
      }
      if (! tmp___12) {
        return (0);
      }
    }
    reginput ++;
    goto switch_break;
    case_22: /* CIL Label */ 
    {
    tmp___13 = myisdigit((int )*reginput);
    }
    if (tmp___13) {
      return (0);
    } else {
      {
      tmp___14 = charsize((int )*reginput);
      }
      if (tmp___14 != 1) {
        return (0);
      }
    }
    reginput ++;
    goto switch_break;
    case_24: /* CIL Label */ 
    if (! ((int )*reginput == 32)) {
      if (! ((int )*reginput == 9)) {
        return (0);
      }
    }
    reginput ++;
    goto switch_break;
    case_25: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )*reginput == 32) {
      return (0);
    } else { //Added block
    if ((int )*reginput == 9) {
      return (0);
    }
    }
    }
    reginput ++;
    goto switch_break;
    case_26: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 1)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_27: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 1) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_28: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 2)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_29: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 2) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_30: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 4)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_31: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 4) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_32: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 8)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_33: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 8) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_34: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 16)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_35: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 16) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_36: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 32)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_37: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 32) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_38: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 64)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_39: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 64) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_40: /* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 128)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_41: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 128) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_8: /* CIL Label */ 
    opnd = scan + 3;
    if ((int )*opnd != (int )*reginput) {
      if (! reg_ic) {
        return (0);
      } else {
        {
        tmp___15 = tolower((int )*opnd);
        tmp___16 = tolower((int )*reginput);
        }
        if (tmp___15 != tmp___16) {
          return (0);
        }
      }
    }
    {
    tmp___17 = strlen((char const   *)((char *)opnd));
    len___0 = (int )tmp___17;
    }
    if (len___0 > 1) {
      {
      tmp___18 = cstrncmp(opnd, reginput, len___0);
      }
      if (tmp___18 != 0) {
        return (0);
      }
    }
    reginput += len___0;
    goto switch_break;
    case_4: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else {
      {
      tmp___19 = cstrchr(scan + 3, (int )*reginput);
      }
      if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
        return (0);
      }
    }
    reginput ++;
    goto switch_break;
    case_5: /* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else {
      {
      tmp___20 = cstrchr(scan + 3, (int )*reginput);
      }
      if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
        return (0);
      }
    }
    reginput ++;
    goto switch_break;
    case_9: /* CIL Label */ 
    goto switch_break;
    case_7: /* CIL Label */ 
    goto switch_break;
    case_61: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_69: /* CIL Label */ 
    {
    clear_subexpr();
    no = (int )*scan - 60;
    save = *(regstartp + no);
    *(regstartp + no) = reginput;
    tmp___21 = regmatch(next);
    }
    if (tmp___21) {
      return (1);
    }
    *(regstartp + no) = save;
    return (0);
    case_71: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_79: /* CIL Label */ 
    {
    clear_subexpr();
    no___0 = (int )*scan - 70;
    save___0 = *(regendp + no___0);
    *(regendp + no___0) = reginput;
    tmp___22 = regmatch(next);
    }
    if (tmp___22) {
      return (1);
    }
    *(regendp + no___0) = save___0;
    return (0);
    case_81: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_89: /* CIL Label */ 
    {
    clear_subexpr();
    no___1 = (int )*scan - 80;
    }
    if ((unsigned long )*(regendp + no___1) != (unsigned long )((void *)0)) {
      {
      len___1 = (int )(*(regendp + no___1) - *(regstartp + no___1));
      tmp___23 = cstrncmp(*(regstartp + no___1), reginput, len___1);
      }
      if (tmp___23 != 0) {
        return (0);
      }
      reginput += len___1;
    }
    goto switch_break;
    case_6: /* CIL Label */ 
    if ((int )*next != 6) {
      next = scan + 3;
    } else {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        save___1 = reginput;
        tmp___24 = regmatch(scan + 3);
        }
        if (tmp___24) {
          return (1);
        }
        {
        reginput = save___1;
        scan = regnext(scan);
        }
        if ((unsigned long )scan != (unsigned long )((void *)0)) {
          if (! ((int )*scan == 6)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      return (0);
    }
    goto switch_break;
    case_23: /* CIL Label */ 
    if ((int )*next == 12) {
      minval = (((int )*(scan + 3) & 255) << 8) + ((int )*(scan + 4) & 255);
      maxval = (((int )*(scan + 5) & 255) << 8) + ((int )*(scan + 6) & 255);
    } else { //Added block
    if ((int )*next >= 90) {
      if ((int )*next < 100) {
        no___2 = (int )*next - 90;
        brace_min[no___2] = (((int )*(scan + 3) & 255) << 8) + ((int )*(scan + 4) & 255);
        brace_max[no___2] = (((int )*(scan + 5) & 255) << 8) + ((int )*(scan + 6) & 255);
        brace_count[no___2] = 0;
      } else {
        {
        emsg(e_internal);
        }
        return (0);
      }
    } else {
      {
      emsg(e_internal);
      }
      return (0);
    }
    }
    goto switch_break;
    case_90: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_99: /* CIL Label */ 
    no___3 = (int )*scan - 90;
    (brace_count[no___3]) ++;
    if (brace_min[no___3] <= brace_max[no___3]) {
      tmp___26 = brace_min[no___3];
    } else {
      tmp___26 = brace_max[no___3];
    }
    if (brace_count[no___3] <= tmp___26) {
      {
      save___2 = reginput;
      tmp___25 = regmatch(scan + 3);
      }
      if (tmp___25) {
        return (1);
      }
      reginput = save___2;
      (brace_count[no___3]) --;
      return (0);
    }
    if (brace_min[no___3] <= brace_max[no___3]) {
      if (brace_count[no___3] <= brace_max[no___3]) {
        {
        save___2 = reginput;
        tmp___27 = regmatch(scan + 3);
        }
        if (tmp___27) {
          return (1);
        }
        reginput = save___2;
        (brace_count[no___3]) --;
      }
    } else { //Added block
    if (brace_count[no___3] <= brace_min[no___3]) {
      {
      save___2 = reginput;
      tmp___28 = regmatch(next);
      }
      if (tmp___28) {
        return (1);
      }
      reginput = save___2;
      next = scan + 3;
    }
    }
    goto switch_break;
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
    if ((int )*next == 8) {
      nextch = (int )*(next + 3);
      if (reg_ic) {
        {
        tmp___29 = myisupper(nextch);
        }
        if (tmp___29) {
          {
          nextch_ic = tolower(nextch);
          }
        } else {
          {
          nextch_ic = toupper(nextch);
          }
        }
      } else {
        nextch_ic = nextch;
      }
    } else {
      nextch = '\000';
      nextch_ic = '\000';
    }
    if ((int )*scan != 12) {
      if ((int )*scan == 10) {
        minval = 0;
      } else {
        minval = 1;
      }
      maxval = 32767;
    }
    {
    save___3 = reginput;
    no___4 = regrepeat(scan + 3);
    }
    if (minval <= maxval) {
      if (no___4 > maxval) {
        no___4 = maxval;
        reginput = save___3 + no___4;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (no___4 >= minval)) {
          goto while_break___1;
        }
        if (nextch == 0) {
          goto _L;
        } else { //Added block
        if ((int )*reginput == nextch) {
          goto _L;
        } else { //Added block
        if ((int )*reginput == nextch_ic) {
          _L: 
          {
          tmp___30 = regmatch(next);
          }
          if (tmp___30) {
            return (1);
          }
        }
        }
        }
        no___4 --;
        reginput = save___3 + no___4;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      if (no___4 < maxval) {
        return (0);
      }
      if (minval > no___4) {
        minval = no___4;
      }
      no___4 = maxval;
      reginput = save___3 + no___4;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (no___4 <= minval)) {
          goto while_break___2;
        }
        if (nextch == 0) {
          goto _L___0;
        } else { //Added block
        if ((int )*reginput == nextch) {
          goto _L___0;
        } else { //Added block
        if ((int )*reginput == nextch_ic) {
          _L___0: 
          {
          tmp___31 = regmatch(next);
          }
          if (tmp___31) {
            return (1);
          }
        }
        }
        }
        no___4 ++;
        reginput = save___3 + no___4;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    return (0);
    case_0: /* CIL Label */ 
    return (1);
    switch_default: /* CIL Label */ 
    {
    emsg(e_re_corr);
    }
    return (0);
    switch_break: /* CIL Label */ ;
    }
    scan = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  emsg(e_re_corr);
  }
  return (0);
}
}
static int regrepeat(char_u *p___0 ) 
{ 
  int count___2 ;
  char_u *scan ;
  char_u *opnd ;
  int mask ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int cu ;
  int cl ;
  char_u *tmp___12 ;
  char_u *tmp___13 ;

  {
  count___2 = 0;
  scan = reginput;
  opnd = p___0 + 3;
  {
  if ((int )*p___0 == 3) {
    goto case_3;
  }
  if ((int )*p___0 == 15) {
    goto case_15;
  }
  if ((int )*p___0 == 16) {
    goto case_16;
  }
  if ((int )*p___0 == 17) {
    goto case_17;
  }
  if ((int )*p___0 == 18) {
    goto case_18;
  }
  if ((int )*p___0 == 19) {
    goto case_19;
  }
  if ((int )*p___0 == 20) {
    goto case_20;
  }
  if ((int )*p___0 == 21) {
    goto case_21;
  }
  if ((int )*p___0 == 22) {
    goto case_22;
  }
  if ((int )*p___0 == 24) {
    goto case_24;
  }
  if ((int )*p___0 == 25) {
    goto case_25;
  }
  if ((int )*p___0 == 26) {
    goto case_26;
  }
  if ((int )*p___0 == 27) {
    goto case_27;
  }
  if ((int )*p___0 == 28) {
    goto case_28;
  }
  if ((int )*p___0 == 29) {
    goto case_29;
  }
  if ((int )*p___0 == 30) {
    goto case_30;
  }
  if ((int )*p___0 == 31) {
    goto case_31;
  }
  if ((int )*p___0 == 32) {
    goto case_32;
  }
  if ((int )*p___0 == 33) {
    goto case_33;
  }
  if ((int )*p___0 == 34) {
    goto case_34;
  }
  if ((int )*p___0 == 35) {
    goto case_35;
  }
  if ((int )*p___0 == 36) {
    goto case_36;
  }
  if ((int )*p___0 == 37) {
    goto case_37;
  }
  if ((int )*p___0 == 38) {
    goto case_38;
  }
  if ((int )*p___0 == 39) {
    goto case_39;
  }
  if ((int )*p___0 == 40) {
    goto case_40;
  }
  if ((int )*p___0 == 41) {
    goto case_41;
  }
  if ((int )*p___0 == 8) {
    goto case_8;
  }
  if ((int )*p___0 == 4) {
    goto case_4;
  }
  if ((int )*p___0 == 5) {
    goto case_5;
  }
  goto switch_default;
  case_3: /* CIL Label */ 
  {
  tmp = strlen((char const   *)((char *)scan));
  count___2 = (int )tmp;
  scan += count___2;
  }
  goto switch_break;
  case_15: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = vim_isIDc((int )*scan);
    }
    if (! tmp___0) {
      goto while_break;
    }
    scan ++;
    count___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  goto switch_break;
  case_16: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    tmp___1 = vim_iswordc((int )*scan);
    }
    if (! tmp___1) {
      goto while_break___0;
    }
    scan ++;
    count___2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  goto switch_break;
  case_17: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    tmp___2 = vim_isfilec((int )*scan);
    }
    if (! tmp___2) {
      goto while_break___1;
    }
    scan ++;
    count___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  goto switch_break;
  case_18: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
    tmp___3 = charsize((int )*scan);
    }
    if (! (tmp___3 == 1)) {
      goto while_break___2;
    }
    scan ++;
    count___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  goto switch_break;
  case_19: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
    tmp___4 = myisdigit((int )*scan);
    }
    if (tmp___4) {
      goto while_break___3;
    } else {
      {
      tmp___5 = vim_isIDc((int )*scan);
      }
      if (! tmp___5) {
        goto while_break___3;
      }
    }
    scan ++;
    count___2 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  goto switch_break;
  case_20: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
    tmp___6 = myisdigit((int )*scan);
    }
    if (tmp___6) {
      goto while_break___4;
    } else {
      {
      tmp___7 = vim_iswordc((int )*scan);
      }
      if (! tmp___7) {
        goto while_break___4;
      }
    }
    scan ++;
    count___2 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  goto switch_break;
  case_21: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
    tmp___8 = myisdigit((int )*scan);
    }
    if (tmp___8) {
      goto while_break___5;
    } else {
      {
      tmp___9 = vim_isfilec((int )*scan);
      }
      if (! tmp___9) {
        goto while_break___5;
      }
    }
    scan ++;
    count___2 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  goto switch_break;
  case_22: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
    tmp___10 = myisdigit((int )*scan);
    }
    if (tmp___10) {
      goto while_break___6;
    } else {
      {
      tmp___11 = charsize((int )*scan);
      }
      if (! (tmp___11 == 1)) {
        goto while_break___6;
      }
    }
    scan ++;
    count___2 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  goto switch_break;
  case_24: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___7: /* CIL Label */ ;
    if (! ((int )*scan == 32)) {
      if (! ((int )*scan == 9)) {
        goto while_break___7;
      }
    }
    scan ++;
    count___2 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  goto switch_break;
  case_25: /* CIL Label */ 
  count___2 = 0;
  {
  while (1) {
    while_continue___8: /* CIL Label */ ;
    if ((int )*scan != 0) {
      if ((int )*scan == 32) {
        goto while_break___8;
      } else { //Added block
      if ((int )*scan == 9) {
        goto while_break___8;
      }
      }
    } else {
      goto while_break___8;
    }
    scan ++;
    count___2 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  goto switch_break;
  case_26: /* CIL Label */ 
  mask = 1;
  do_class: 
  count___2 = 0;
  {
  while (1) {
    while_continue___9: /* CIL Label */ ;
    if (! ((int )class_tab[*scan] & mask)) {
      goto while_break___9;
    }
    scan ++;
    count___2 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  goto switch_break;
  case_27: /* CIL Label */ 
  mask = 1;
  do_nclass: 
  count___2 = 0;
  {
  while (1) {
    while_continue___10: /* CIL Label */ ;
    if ((int )*scan != 0) {
      if (! (! ((int )class_tab[*scan] & mask))) {
        goto while_break___10;
      }
    } else {
      goto while_break___10;
    }
    scan ++;
    count___2 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  goto switch_break;
  case_28: /* CIL Label */ 
  mask = 2;
  goto do_class;
  case_29: /* CIL Label */ 
  mask = 2;
  goto do_nclass;
  case_30: /* CIL Label */ 
  mask = 4;
  goto do_class;
  case_31: /* CIL Label */ 
  mask = 4;
  goto do_nclass;
  case_32: /* CIL Label */ 
  mask = 8;
  goto do_class;
  case_33: /* CIL Label */ 
  mask = 8;
  goto do_nclass;
  case_34: /* CIL Label */ 
  mask = 16;
  goto do_class;
  case_35: /* CIL Label */ 
  mask = 16;
  goto do_nclass;
  case_36: /* CIL Label */ 
  mask = 32;
  goto do_class;
  case_37: /* CIL Label */ 
  mask = 32;
  goto do_nclass;
  case_38: /* CIL Label */ 
  mask = 64;
  goto do_class;
  case_39: /* CIL Label */ 
  mask = 64;
  goto do_nclass;
  case_40: /* CIL Label */ 
  mask = 128;
  goto do_class;
  case_41: /* CIL Label */ 
  mask = 128;
  goto do_nclass;
  case_8: /* CIL Label */ 
  if (reg_ic) {
    {
    cu = toupper((int )*opnd);
    cl = tolower((int )*opnd);
    }
    {
    while (1) {
      while_continue___11: /* CIL Label */ ;
      if (! ((int )*scan == cu)) {
        if (! ((int )*scan == cl)) {
          goto while_break___11;
        }
      }
      count___2 ++;
      scan ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  } else {
    cu = (int )*opnd;
    {
    while (1) {
      while_continue___12: /* CIL Label */ ;
      if (! ((int )*scan == cu)) {
        goto while_break___12;
      }
      count___2 ++;
      scan ++;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  while (1) {
    while_continue___13: /* CIL Label */ ;
    if ((int )*scan != 0) {
      {
      tmp___12 = cstrchr(opnd, (int )*scan);
      }
      if (! ((unsigned long )tmp___12 != (unsigned long )((void *)0))) {
        goto while_break___13;
      }
    } else {
      goto while_break___13;
    }
    count___2 ++;
    scan ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  while (1) {
    while_continue___14: /* CIL Label */ ;
    if ((int )*scan != 0) {
      {
      tmp___13 = cstrchr(opnd, (int )*scan);
      }
      if (! ((unsigned long )tmp___13 == (unsigned long )((void *)0))) {
        goto while_break___14;
      }
    } else {
      goto while_break___14;
    }
    count___2 ++;
    scan ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  emsg(e_re_corr);
  count___2 = 0;
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  reginput = scan;
  return (count___2);
}
}
static char_u *regnext(char_u *p___0 ) 
{ 
  int offset ;

  {
  if ((unsigned long )p___0 == (unsigned long )((char_u *)-1)) {
    return ((char_u *)((void *)0));
  }
  offset = (((int )*(p___0 + 1) & 255) << 8) + ((int )*(p___0 + 2) & 255);
  if (offset == 0) {
    return ((char_u *)((void *)0));
  }
  if ((int )*p___0 == 7) {
    return (p___0 - offset);
  } else {
    return (p___0 + offset);
  }
}
}
static int cstrncmp(char_u *s1 , char_u *s2 , int n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (! reg_ic) {
    {
    tmp = strncmp((char const   *)((char *)s1), (char const   *)((char *)s2), (size_t )n);
    }
    return (tmp);
  }
  {
  tmp___0 = strncasecmp((char const   *)((char *)s1), (char const   *)((char *)s2),
                        (size_t )n);
  }
  return (tmp___0);
}
}
static char_u *cstrchr(char_u *s , int c ) 
{ 
  char_u *p___0 ;
  int cc___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! reg_ic) {
    {
    tmp = vim_strchr(s, c);
    }
    return (tmp);
  }
  {
  tmp___2 = myisupper(c);
  }
  if (tmp___2) {
    {
    cc___0 = tolower(c);
    }
  } else {
    {
    tmp___1 = myislower(c);
    }
    if (tmp___1) {
      {
      cc___0 = toupper(c);
      }
    } else {
      {
      tmp___0 = vim_strchr(s, c);
      }
      return (tmp___0);
    }
  }
  p___0 = s;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == c) {
      return (p___0);
    } else { //Added block
    if ((int )*p___0 == cc___0) {
      return (p___0);
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
static fptr do_upper(char_u *d , int c ) ;
static fptr do_Upper(char_u *d , int c ) ;
static fptr do_lower(char_u *d , int c ) ;
static fptr do_Lower(char_u *d , int c ) ;
static fptr do_upper(char_u *d , int c ) 
{ 
  int tmp ;

  {
  {
  tmp = toupper(c);
  *d = (char_u )tmp;
  }
  return ((void (*(*)(char_u * , int  ))())((void *)0));
}
}
static fptr do_Upper(char_u *d , int c ) 
{ 
  int tmp ;

  {
  {
  tmp = toupper(c);
  *d = (char_u )tmp;
  }
  return ((void (*(*)(char_u * , int  ))())(& do_Upper));
}
}
static fptr do_lower(char_u *d , int c ) 
{ 
  int tmp ;

  {
  {
  tmp = tolower(c);
  *d = (char_u )tmp;
  }
  return ((void (*(*)(char_u * , int  ))())((void *)0));
}
}
static fptr do_Lower(char_u *d , int c ) 
{ 
  int tmp ;

  {
  {
  tmp = tolower(c);
  *d = (char_u )tmp;
  }
  return ((void (*(*)(char_u * , int  ))())(& do_Lower));
}
}
char_u *regtilde(char_u *source , int magic ) 
{ 
  char_u *newsub ;
  char_u *tmpsub ;
  char_u *p___0 ;
  int len___0 ;
  int prevlen ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  newsub = source;
  p___0 = newsub;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == 126) {
      if (magic) {
        goto _L;
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: 
    if ((int )*p___0 == 92) {
      if ((int )*(p___0 + 1) == 126) {
        if (! magic) {
          _L: 
          if ((unsigned long )reg_prev_sub != (unsigned long )((void *)0)) {
            {
            tmp = strlen((char const   *)((char *)reg_prev_sub));
            prevlen = (int )tmp;
            tmp___0 = strlen((char const   *)((char *)newsub));
            tmpsub = alloc((unsigned int )(tmp___0 + (size_t )prevlen));
            }
            if ((unsigned long )tmpsub != (unsigned long )((void *)0)) {
              {
              len___0 = (int )(p___0 - newsub);
              memmove((void *)((char *)tmpsub), (void const   *)((char *)newsub),
                      (size_t )len___0);
              memmove((void *)((char *)(tmpsub + len___0)), (void const   *)((char *)reg_prev_sub),
                      (size_t )prevlen);
              }
              if (! magic) {
                p___0 ++;
              }
              {
              strcpy((char * __restrict  )((char *)((tmpsub + len___0) + prevlen)),
                     (char const   * __restrict  )((char *)(p___0 + 1)));
              }
              if ((unsigned long )newsub != (unsigned long )source) {
                {
                vim_free((void *)newsub);
                }
              }
              newsub = tmpsub;
              p___0 = (newsub + len___0) + prevlen;
            }
          } else { //Added block
          if (magic) {
            {
            strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)(p___0 + 1)));
            }
          } else {
            {
            strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)(p___0 + 2)));
            }
          }
          }
          p___0 --;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if ((int )*p___0 == 92) {
      if (*(p___0 + 1)) {
        p___0 ++;
      }
    }
    }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)reg_prev_sub);
  }
  if ((unsigned long )newsub != (unsigned long )source) {
    reg_prev_sub = newsub;
  } else {
    {
    reg_prev_sub = vim_strsave(newsub);
    }
  }
  return (newsub);
}
}
void vim_regnewptr(vim_regexp *prog , char_u *old_ptr , char_u *new_ptr ) 
{ 
  int j ;

  {
  j = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (j < 10)) {
      goto while_break;
    }
    if ((unsigned long )prog->startp[j] != (unsigned long )((void *)0)) {
      prog->startp[j] = new_ptr + (prog->startp[j] - old_ptr);
    }
    if ((unsigned long )prog->endp[j] != (unsigned long )((void *)0)) {
      prog->endp[j] = new_ptr + (prog->endp[j] - old_ptr);
    }
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int vim_regsub(vim_regexp *prog , char_u *source , char_u *dest , int copy , int magic ) 
{ 
  char_u *src ;
  char_u *dst ;
  char_u *s ;
  int c ;
  int no ;
  void (*(*func)(char_u * , int  ))() ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  void (*tmp___2)() ;
  void (*tmp___3)() ;
  char_u *tmp___4 ;

  {
  func = (void (*(*)(char_u * , int  ))())((void *)0);
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
    emsg(e_null);
    }
    return (0);
  } else { //Added block
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
    emsg(e_null);
    }
    return (0);
  } else { //Added block
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    {
    emsg(e_null);
    }
    return (0);
  }
  }
  }
  if ((int )prog->program[0] != 156) {
    {
    emsg(e_re_corr);
    }
    return (0);
  }
  src = source;
  dst = dest;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___4 = src;
    src ++;
    c = (int )*tmp___4;
    if (! (c != 0)) {
      goto while_break;
    }
    no = -1;
    if (c == 38) {
      if (magic) {
        no = 0;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (c == 92) {
      if ((int )*src != 0) {
        if ((int )*src == 38) {
          if (! magic) {
            src ++;
            no = 0;
          } else {
            goto _L___0;
          }
        } else { //Added block
        _L___0: 
        if (48 <= (int )*src) {
          if ((int )*src <= 57) {
            tmp = src;
            src ++;
            no = (int )*tmp - 48;
          } else {
            goto _L;
          }
        } else {
          _L: 
          {
          tmp___1 = vim_strchr((char_u *)"uUlLeE", (int )*src);
          }
          if (tmp___1) {
            tmp___0 = src;
            src ++;
            {
            if ((int )*tmp___0 == 117) {
              goto case_117;
            }
            if ((int )*tmp___0 == 85) {
              goto case_85;
            }
            if ((int )*tmp___0 == 108) {
              goto case_108;
            }
            if ((int )*tmp___0 == 76) {
              goto case_76;
            }
            if ((int )*tmp___0 == 101) {
              goto case_101;
            }
            if ((int )*tmp___0 == 69) {
              goto case_101;
            }
            goto switch_break;
            case_117: /* CIL Label */ 
            func = (void (*(*)(char_u * , int  ))())(& do_upper);
            goto while_continue;
            case_85: /* CIL Label */ 
            func = (void (*(*)(char_u * , int  ))())(& do_Upper);
            goto while_continue;
            case_108: /* CIL Label */ 
            func = (void (*(*)(char_u * , int  ))())(& do_lower);
            goto while_continue;
            case_76: /* CIL Label */ 
            func = (void (*(*)(char_u * , int  ))())(& do_Lower);
            goto while_continue;
            case_101: /* CIL Label */ 
            case_69: /* CIL Label */ 
            func = (void (*(*)(char_u * , int  ))())((void *)0);
            goto while_continue;
            switch_break: /* CIL Label */ ;
            }
          }
        }
        }
      }
    }
    }
    if (no < 0) {
      if (c == 92) {
        if ((int )*src != 0) {
          {
          if ((int )*src == 114) {
            goto case_114;
          }
          if ((int )*src == 110) {
            goto case_110;
          }
          if ((int )*src == 116) {
            goto case_116;
          }
          if ((int )*src == 98) {
            goto case_98;
          }
          goto switch_default;
          case_114: /* CIL Label */ 
          c = '\r';
          goto switch_break___0;
          case_110: /* CIL Label */ 
          c = '\n';
          goto switch_break___0;
          case_116: /* CIL Label */ 
          c = '\t';
          goto switch_break___0;
          case_98: /* CIL Label */ 
          c = 8;
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          c = (int )*src;
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
          src ++;
        }
      }
      if (copy) {
        if ((unsigned long )func == (unsigned long )((void (*(*)(char_u * , int  ))())((void *)0))) {
          *dst = (char_u )c;
        } else {
          {
          tmp___2 = (*func)(dst, c);
          func = (void (*(*)(char_u * , int  ))())tmp___2;
          }
        }
      }
      dst ++;
    } else { //Added block
    if ((unsigned long )prog->startp[no] != (unsigned long )((void *)0)) {
      if ((unsigned long )prog->endp[no] != (unsigned long )((void *)0)) {
        s = prog->startp[no];
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((unsigned long )s < (unsigned long )prog->endp[no])) {
            goto while_break___0;
          }
          if (copy) {
            if ((int )*s == 0) {
              {
              emsg(e_re_damg);
              }
              goto exit;
            }
          }
          if ((int )*s == 13) {
            if (copy) {
              *(dst + 0) = (char_u )22;
              *(dst + 1) = (char_u )'\r';
            }
            dst += 2;
          } else {
            if (copy) {
              if ((unsigned long )func == (unsigned long )((void (*(*)(char_u * ,
                                                                       int  ))())((void *)0))) {
                *dst = *s;
              } else {
                {
                tmp___3 = (*func)(dst, (int )*s);
                func = (void (*(*)(char_u * , int  ))())tmp___3;
                }
              }
            }
            dst ++;
          }
          s ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (copy) {
    *dst = (char_u )'\000';
  }
  exit: 
  return ((int )((dst - dest) + 1L));
}
}
#pragma merger("0","/tmp/cil-BEhIo2Hj.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
char *mediumVersion ;
void screen_stop_highlight(void) ;
void reset_cterm_colors(void) ;
void invalidate_botline_win(WIN *wp ) ;
void validate_cheight(void) ;
void win_rest_invalid(WIN *wp ) ;
vim_regexp *last_pat_prog(void) ;
void syntax_start(WIN *wp , linenr_t lnum ) ;
int syntax_check_changed(linenr_t lnum ) ;
int get_syntax_attr(colnr_t col , char_u *line ) ;
struct attr_entry *syn_term_attr2entry(int attr ) ;
struct attr_entry *syn_cterm_attr2entry(int attr ) ;
void term_windgoto(int row , int col ) ;
void term_cursor_right(int i___0 ) ;
void term_append_lines(int line_count ) ;
void term_delete_lines(int line_count ) ;
void term_fg_color(int n ) ;
void term_bg_color(int n ) ;
void scroll_region_set(WIN *wp , int off___0 ) ;
void clip_update_selection(void) ;
int clip_isautosel(void) ;
int highest_patch(void) ;
int win_alloc_lsize(WIN *wp ) ;
void win_free_lsize(WIN *wp ) ;
void win_drag_status_line(int offset ) ;
static int screen_attr  =    0;
static int screen_cur_row  ;
static int screen_cur_col  ;
vim_regexp *search_hl_prog  =    (vim_regexp *)((void *)0);
int search_hl_attr  ;
int search_hl_ic  ;
static char_u *current_LinePointer  ;
static void win_update(WIN *wp ) ;
static int win_line(WIN *wp , linenr_t lnum , int startrow , int endrow ) ;
static int char_needs_redraw(char_u *screenp_from , char_u *screenp_to , int len___0 ) ;
static void screen_line(int row , int endcol , int clear_rest ) ;
static void start_search_hl(void) ;
static void end_search_hl(void) ;
static void screen_start_highlight(int attr ) ;
static void comp_botline(void) ;
static void screen_char(char_u *p___0 , int row , int col ) ;
static void screenclear2(void) ;
static void lineclear(char_u *p___0 ) ;
static void check_cursor_moved(WIN *wp ) ;
static void curs_rows(int do_botline ) ;
static void validate_virtcol_win(WIN *wp ) ;
static int screen_ins_lines(int off___0 , int row , int line_count , int end ) ;
static void msg_pos_mode(void) ;
static int highlight_status(int *attr , int is_curwin ) ;
static void win_redr_custom(WIN *wp , int Ruler ) ;
static int build_stl_str_hl(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ,
                            struct stl_hlrec *hl ) ;
static void win_redr_ruler(WIN *wp , int always ) ;
static void get_rel_pos(WIN *wp , char_u *str___1 ) ;
static int get_scroll_overlap(linenr_t lnum , int dir ) ;
static void intro_message(void) ;
void update_screenline(void) 
{ 
  int row ;
  int old_cline_height ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (! tmp) {
    return;
  }
  if (must_redraw) {
    if (must_redraw < 30) {
      must_redraw = 30;
    }
    {
    update_screen(must_redraw);
    }
    return;
  }
  {
  tmp___0 = redrawing();
  }
  if (! tmp___0) {
    {
    redraw_later(40);
    }
    return;
  }
  if ((linenr_t )curwin->w_lsize_valid <= curwin->w_cursor.lnum - curwin->w_topline) {
    {
    update_screen(30);
    }
    return;
  } else { //Added block
  if (*(curwin->w_lsize_lnum + 0) != curwin->w_topline) {
    {
    update_screen(30);
    }
    return;
  }
  }
  if (clipboard.available) {
    {
    tmp___1 = clip_isautosel();
    }
    if (tmp___1) {
      {
      clip_update_selection();
      }
    }
  }
  {
  old_cline_height = (int )*(curwin->w_lsize + (curwin->w_cursor.lnum - curwin->w_topline));
  check_cursor_moved(curwin);
  }
  if (! (curwin->w_valid & 16)) {
    {
    curs_rows(0);
    }
  }
  {
  start_search_hl();
  validate_virtcol();
  cursor_off();
  row = win_line(curwin, curwin->w_cursor.lnum, curwin->w_cline_row, curwin->w_height);
  end_search_hl();
  }
  if (row == curwin->w_height + 1) {
    if (curwin->w_topline < curwin->w_cursor.lnum) {
      (curwin->w_botline) --;
      curwin->w_valid |= 64;
    }
    {
    update_topline();
    update_screen(30);
    }
  } else { //Added block
  if (! dollar_vcol) {
    if (old_cline_height != curwin->w_cline_height) {
      if (curwin->w_cline_height < old_cline_height) {
        {
        win_del_lines(curwin, row, old_cline_height - curwin->w_cline_height, 0, 1);
        }
      } else {
        {
        win_ins_lines(curwin, curwin->w_cline_row + curwin->w_cline_height, curwin->w_cline_height - old_cline_height,
                      0, 1);
        }
      }
      {
      update_screen(30);
      }
    } else {
      {
      tmp___2 = syntax_present(curbuf);
      }
      if (tmp___2) {
        if (row < cmdline_row) {
          {
          tmp___3 = syntax_check_changed(curwin->w_cursor.lnum + 1L);
          }
          if (tmp___3) {
            {
            update_screen(30);
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else { //Added block
      _L___0: 
      if (clear_cmdline) {
        {
        showmode();
        }
      } else { //Added block
      if (redraw_cmdline) {
        {
        showmode();
        }
      }
      }
      }
    }
  }
  }
  return;
}
}
void redraw_later(int type ) 
{ 


  {
  if (curwin->w_redr_type < type) {
    curwin->w_redr_type = type;
  }
  if (must_redraw < type) {
    must_redraw = type;
  }
  return;
}
}
void redraw_all_later(int type ) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_type < type) {
      wp->w_redr_type = type;
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  redraw_later(type);
  }
  return;
}
}
void redraw_curbuf_later(int type ) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_type < type) {
      if ((unsigned long )wp->w_buffer == (unsigned long )curbuf) {
        wp->w_redr_type = type;
      }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  redraw_later(type);
  }
  return;
}
}
void update_curbuf(int type ) 
{ 


  {
  {
  redraw_curbuf_later(type);
  update_screen(type);
  }
  return;
}
}
static int did_intro  =    0;
void update_screen(int type ) 
{ 
  WIN *wp ;
  int did_one ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (! tmp) {
    return;
  }
  dollar_vcol = (colnr_t )0;
  if (must_redraw) {
    if (type < must_redraw) {
      type = must_redraw;
    }
    must_redraw = 0;
  }
  if (curwin->w_lsize_valid == 0) {
    if (type < 40) {
      type = 40;
    }
  }
  {
  tmp___0 = redrawing();
  }
  if (! tmp___0) {
    {
    redraw_later(type);
    curwin->w_redr_type = type;
    curwin->w_lsize_valid = 0;
    }
    return;
  }
  if (msg_scrolled) {
    clear_cmdline = 1;
    if ((long )msg_scrolled > Rows - 5L) {
      type = 50;
    } else { //Added block
    if (type != 50) {
      {
      check_for_delay(0);
      tmp___1 = screen_ins_lines(0, 0, msg_scrolled, (int )Rows);
      }
      if (tmp___1 == 0) {
        type = 50;
      }
      {
      win_rest_invalid(firstwin);
      }
    }
    }
    msg_scrolled = 0;
    need_wait_return = 0;
  }
  {
  compute_cmdrow();
  }
  if (need_highlight_changed) {
    {
    highlight_changed();
    }
  }
  if (type == 50) {
    {
    screenclear();
    type = 40;
    }
  }
  if (clear_cmdline) {
    {
    check_for_delay(0);
    msg_clr_cmdline();
    }
  }
  if (type == 20) {
    {
    update_curswant();
    }
  }
  if (type == 10) {
    if (! (curwin->w_topline == *(curwin->w_lsize_lnum + 0))) {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (type == 20) {
    if (curwin->w_old_cursor_lnum == curwin->w_cursor.lnum) {
      if (curwin->w_valid & 4) {
        if (! (curwin->w_old_curswant == curwin->w_curswant)) {
          curwin->w_redr_type = type;
        }
      } else {
        curwin->w_redr_type = type;
      }
    } else {
      curwin->w_redr_type = type;
    }
  } else {
    curwin->w_redr_type = type;
  }
  }
  did_one = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_type) {
      {
      cursor_off();
      }
      if (! did_one) {
        {
        start_search_hl();
        did_one = 1;
        }
      }
      {
      win_update(wp);
      }
    }
    if (wp->w_redr_status) {
      {
      cursor_off();
      win_redr_status(wp);
      }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  if (did_one) {
    {
    end_search_hl();
    }
  }
  if (redraw_cmdline) {
    {
    showmode();
    }
  }
  if (! did_intro) {
    if (curbuf->b_ml.ml_line_count == 1L) {
      {
      tmp___2 = ml_get((linenr_t )1);
      }
      if ((int )*tmp___2 == 0) {
        if ((unsigned long )curbuf->b_fname == (unsigned long )((void *)0)) {
          if ((unsigned long )firstwin->w_next == (unsigned long )((void *)0)) {
            {
            tmp___3 = vim_strchr(p_shm, 'I');
            }
            if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
              {
              intro_message();
              }
            }
          }
        }
      }
    }
  }
  did_intro = 1;
  return;
}
}
void update_other_win(void) 
{ 
  WIN *wp ;
  int first___0 ;

  {
  first___0 = 1;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if ((unsigned long )wp != (unsigned long )curwin) {
      if ((unsigned long )wp->w_buffer == (unsigned long )curbuf) {
        if (first___0) {
          {
          cursor_off();
          start_search_hl();
          first___0 = 0;
          }
        }
        wp->w_redr_type = 40;
        if (! skip_redraw) {
          {
          win_update(wp);
          }
        }
      }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  end_search_hl();
  }
  return;
}
}
static int recursive___2  =    0;
static void win_update(WIN *wp ) 
{ 
  int type ;
  int row ;
  int endrow ;
  linenr_t lnum ;
  linenr_t lastline ;
  int done___0 ;
  int didline ;
  int srow ;
  int idx ;
  int i___0 ;
  long j ;
  int old_botline ;
  int must_start_top ;
  int must_end_bot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  linenr_t from ;
  linenr_t to ;
  colnr_t from1 ;
  colnr_t from2 ;
  colnr_t to1 ;
  colnr_t to2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  srow = 0;
  old_botline = (int )wp->w_botline;
  must_start_top = 0;
  must_end_bot = 0;
  if (clipboard.available) {
    {
    tmp = clip_isautosel();
    }
    if (tmp) {
      {
      clip_update_selection();
      }
    }
  }
  type = wp->w_redr_type;
  if (type == 40) {
    wp->w_redr_status = 1;
    wp->w_lsize_valid = 0;
  }
  {
  wp->w_redr_type = 0;
  idx = 0;
  row = 0;
  lnum = wp->w_topline;
  validate_virtcol_win(wp);
  endrow = wp->w_height;
  }
  if (type == 10) {
    goto _L___5;
  } else { //Added block
  if (type == 30) {
    goto _L___5;
  } else { //Added block
  if (type == 35) {
    goto _L___5;
  } else { //Added block
  if (type == 20) {
    _L___5: 
    if (wp->w_topline < *(wp->w_lsize_lnum + 0)) {
      j = *(wp->w_lsize_lnum + 0) - wp->w_topline;
      if (j < (long )(wp->w_height - 2)) {
        if (type != 30) {
          goto _L___2;
        } else { //Added block
        if (*(wp->w_lsize_lnum + 0) < curwin->w_cursor.lnum) {
          _L___2: 
          if (type != 35) {
            goto _L___0;
          } else { //Added block
          if (*(wp->w_lsize_lnum + 0) < curwin->w_cursor.lnum - 1L) {
            _L___0: 
            {
            lastline = *(wp->w_lsize_lnum + 0) - 1L;
            i___0 = plines_m_win(wp, wp->w_topline, lastline);
            }
            if (i___0 < wp->w_height - 2) {
              if (i___0 > 0) {
                {
                check_for_delay(0);
                }
              }
              {
              tmp___1 = win_ins_lines(wp, 0, i___0, 0, (unsigned long )wp == (unsigned long )firstwin);
              }
              if (tmp___1 == 1) {
                if (wp->w_lsize_valid) {
                  must_start_top = 1;
                  endrow = i___0;
                  if (type == 30) {
                    wp->w_redr_type = type;
                  } else { //Added block
                  if (type == 35) {
                    wp->w_redr_type = type;
                  }
                  }
                  tmp___0 = (int )((long )wp->w_lsize_valid + j);
                  wp->w_lsize_valid = tmp___0;
                  if (tmp___0 > wp->w_height) {
                    wp->w_lsize_valid = wp->w_height;
                  }
                  idx = wp->w_lsize_valid;
                  {
                  while (1) {
                    while_continue: /* CIL Label */ ;
                    if (! ((long )idx - j >= 0L)) {
                      goto while_break;
                    }
                    *(wp->w_lsize_lnum + idx) = *(wp->w_lsize_lnum + ((long )idx - j));
                    *(wp->w_lsize + idx) = *(wp->w_lsize + ((long )idx - j));
                    idx --;
                  }
                  while_break: /* CIL Label */ ;
                  }
                  idx = 0;
                }
              }
            } else { //Added block
            if ((unsigned long )lastwin == (unsigned long )firstwin) {
              {
              screenclear();
              must_start_top = 1;
              must_end_bot = 1;
              }
            }
            }
          } else {
            goto _L___1;
          }
          }
        } else {
          goto _L___1;
        }
        }
      } else { //Added block
      _L___1: 
      if ((unsigned long )lastwin == (unsigned long )firstwin) {
        {
        screenclear();
        must_start_top = 1;
        must_end_bot = 1;
        }
      }
      }
    } else {
      j = -1L;
      i___0 = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i___0 < wp->w_lsize_valid)) {
          goto while_break___0;
        }
        if (*(wp->w_lsize_lnum + i___0) == wp->w_topline) {
          j = (long )i___0;
          goto while_break___0;
        }
        row += (int )*(wp->w_lsize + i___0);
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (j == -1L) {
        row = 0;
        if ((unsigned long )lastwin == (unsigned long )firstwin) {
          {
          screenclear();
          must_start_top = 1;
          must_end_bot = 1;
          }
        }
      } else {
        if (row) {
          {
          check_for_delay(0);
          tmp___2 = win_del_lines(wp, 0, row, 0, (unsigned long )wp == (unsigned long )firstwin);
          }
          if (tmp___2 == 1) {
            must_end_bot = 1;
          }
        }
        if (row == 0) {
          goto _L___4;
        } else { //Added block
        if (must_end_bot) {
          _L___4: 
          if (wp->w_lsize_valid) {
            srow = row;
            row = 0;
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (type == 30) {
                if (lnum == wp->w_cursor.lnum) {
                  wp->w_lsize_valid = idx;
                  goto while_break___1;
                } else {
                  goto _L___3;
                }
              } else { //Added block
              _L___3: 
              if (type == 35) {
                if (lnum == wp->w_cursor.lnum - 1L) {
                  wp->w_lsize_valid = idx;
                  goto while_break___1;
                }
              }
              }
              *(wp->w_lsize + idx) = *(wp->w_lsize + j);
              *(wp->w_lsize_lnum + idx) = lnum;
              if ((row + srow) + (int )*(wp->w_lsize + j) > wp->w_height) {
                wp->w_lsize_valid = idx + 1;
                goto while_break___1;
              }
              lnum ++;
              tmp___3 = idx;
              idx ++;
              row += (int )*(wp->w_lsize + tmp___3);
              j ++;
              if ((int )j >= wp->w_lsize_valid) {
                wp->w_lsize_valid = idx;
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
            row = 0;
          }
        } else {
          row = 0;
        }
        }
      }
    }
    if (endrow == wp->w_height) {
      if (idx == 0) {
        wp->w_lsize_valid = 0;
      }
    }
  }
  }
  }
  }
  didline = 0;
  done___0 = didline;
  if (VIsual_active) {
    if ((unsigned long )wp->w_buffer == (unsigned long )curwin->w_buffer) {
      if (wp->w_redr_type == 40) {
        must_start_top = 1;
        must_end_bot = 1;
      }
      if (curwin->w_cursor.lnum < wp->w_old_cursor_lnum) {
        from = curwin->w_cursor.lnum;
        to = wp->w_old_cursor_lnum;
      } else {
        from = wp->w_old_cursor_lnum;
        to = curwin->w_cursor.lnum;
        if (from == 0L) {
          from = to;
        }
      }
      if (VIsual.lnum != wp->w_old_visual_lnum) {
        if (wp->w_old_visual_lnum < from) {
          if (wp->w_old_visual_lnum != 0L) {
            from = wp->w_old_visual_lnum;
          }
        }
        if (wp->w_old_visual_lnum > to) {
          to = wp->w_old_visual_lnum;
        }
        if (VIsual.lnum < from) {
          from = VIsual.lnum;
        }
        if (VIsual.lnum > to) {
          to = VIsual.lnum;
        }
      }
      if (VIsual_mode == 22) {
        if (VIsual.lnum != curwin->w_cursor.lnum) {
          tmp___4 = VIsual.lnum < curwin->w_cursor.lnum;
        } else {
          tmp___4 = VIsual.col < curwin->w_cursor.col;
        }
        if (tmp___4) {
          {
          getvcol(wp, & VIsual, & from1, (colnr_t *)((void *)0), & to1);
          getvcol(wp, & curwin->w_cursor, & from2, (colnr_t *)((void *)0), & to2);
          }
        } else {
          {
          getvcol(wp, & curwin->w_cursor, & from1, (colnr_t *)((void *)0), & to1);
          getvcol(wp, & VIsual, & from2, (colnr_t *)((void *)0), & to2);
          }
        }
        if (from2 < from1) {
          from1 = from2;
        }
        if (to2 > to1) {
          if ((int )*p_sel == 101) {
            if (from2 - 1U >= to1) {
              to1 = from2 - 1U;
            } else {
              to1 = to2;
            }
          } else {
            to1 = to2;
          }
        }
        to1 ++;
        if (curwin->w_curswant == 2147483647U) {
          to1 = (colnr_t )2147483647;
        }
        if (from1 != wp->w_old_cursor_fcol) {
          goto _L___6;
        } else { //Added block
        if (to1 != wp->w_old_cursor_lcol) {
          _L___6: 
          if (from > VIsual.lnum) {
            from = VIsual.lnum;
          }
          if (to < VIsual.lnum) {
            to = VIsual.lnum;
          }
        }
        }
        wp->w_old_cursor_fcol = from1;
        wp->w_old_cursor_lcol = to1;
      }
      if (from < wp->w_topline) {
        from = wp->w_topline;
      } else { //Added block
      if (must_start_top) {
        from = wp->w_topline;
      }
      }
      if (wp->w_valid & 32) {
        if (from >= wp->w_botline) {
          from = wp->w_botline - 1L;
        }
        if (to >= wp->w_botline) {
          to = wp->w_botline - 1L;
        }
      }
      if (lnum > from) {
        lnum = wp->w_topline;
        idx = 0;
        row = 0;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (lnum < from) {
          if (! (idx < wp->w_lsize_valid)) {
            goto while_break___2;
          }
        } else {
          goto while_break___2;
        }
        tmp___5 = idx;
        idx ++;
        row += (int )*(wp->w_lsize + tmp___5);
        lnum ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      if (! must_end_bot) {
        if (! must_start_top) {
          srow = row;
          j = (long )idx;
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if (! (j < (long )wp->w_lsize_valid)) {
              goto while_break___3;
            }
            if (*(wp->w_lsize_lnum + j) == to + 1L) {
              endrow = srow;
              goto while_break___3;
            }
            srow += (int )*(wp->w_lsize + j);
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
          endrow = wp->w_height;
        }
      } else {
        endrow = wp->w_height;
      }
      wp->w_old_cursor_lnum = curwin->w_cursor.lnum;
      wp->w_old_visual_lnum = VIsual.lnum;
      wp->w_old_curswant = curwin->w_curswant;
    } else {
      wp->w_old_cursor_lnum = (linenr_t )0;
      wp->w_old_visual_lnum = (linenr_t )0;
    }
  } else {
    wp->w_old_cursor_lnum = (linenr_t )0;
    wp->w_old_visual_lnum = (linenr_t )0;
  }
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    if (row == endrow) {
      didline = 1;
      goto while_break___4;
    }
    if (lnum > (wp->w_buffer)->b_ml.ml_line_count) {
      done___0 = 1;
      goto while_break___4;
    }
    {
    srow = row;
    row = win_line(wp, lnum, srow, endrow);
    }
    if (row > endrow) {
      {
      tmp___6 = plines_win(wp, lnum);
      *(wp->w_lsize + idx) = (char_u )tmp___6;
      tmp___7 = idx;
      idx ++;
      *(wp->w_lsize_lnum + tmp___7) = lnum;
      }
      goto while_break___4;
    }
    *(wp->w_lsize + idx) = (char_u )(row - srow);
    tmp___8 = idx;
    idx ++;
    *(wp->w_lsize_lnum + tmp___8) = lnum;
    lnum ++;
    if (lnum > (wp->w_buffer)->b_ml.ml_line_count) {
      done___0 = 1;
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  if (idx > wp->w_lsize_valid) {
    wp->w_lsize_valid = idx;
  }
  if (endrow != wp->w_height) {
    row = 0;
    idx = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (idx < wp->w_lsize_valid) {
        if (! (row < wp->w_height)) {
          goto while_break___5;
        }
      } else {
        goto while_break___5;
      }
      row += (int )*(wp->w_lsize + idx);
      idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    if (row < wp->w_height) {
      done___0 = 1;
    } else { //Added block
    if (row > wp->w_height) {
      lnum = *(wp->w_lsize_lnum + (idx - 1));
      srow = row - (int )*(wp->w_lsize + (idx - 1));
      didline = 0;
    } else {
      lnum = *(wp->w_lsize_lnum + (idx - 1)) + 1L;
      didline = 1;
    }
    }
  }
  wp->w_empty_rows = 0;
  if (! done___0) {
    if (! didline) {
      if (lnum == wp->w_topline) {
        wp->w_botline = lnum + 1L;
      } else { //Added block
      if ((int )*p_dy != 0) {
        {
        screen_fill((wp->w_winpos + wp->w_height) - 1, wp->w_winpos + wp->w_height,
                    (int )Columns - 3, (int )Columns, '@', '@', highlight_attr[1]);
        wp->w_botline = lnum;
        }
      } else {
        {
        screen_fill(wp->w_winpos + srow, wp->w_winpos + wp->w_height, 0, (int )Columns,
                    '@', ' ', highlight_attr[1]);
        wp->w_botline = lnum;
        wp->w_empty_rows = wp->w_height - srow;
        }
      }
      }
    } else {
      goto _L___7;
    }
  } else {
    _L___7: 
    {
    screen_fill(wp->w_winpos + row, wp->w_winpos + wp->w_height, 0, (int )Columns,
                '~', ' ', highlight_attr[1]);
    wp->w_empty_rows = wp->w_height - row;
    }
    if (done___0) {
      wp->w_botline = (wp->w_buffer)->b_ml.ml_line_count + 1L;
    } else {
      wp->w_botline = lnum;
    }
  }
  wp->w_valid |= 32;
  if ((unsigned long )wp == (unsigned long )curwin) {
    if (wp->w_botline != (linenr_t )old_botline) {
      if (! recursive___2) {
        {
        recursive___2 = 1;
        update_topline();
        }
        if (must_redraw) {
          {
          win_update(wp);
          must_redraw = 0;
          }
        }
        recursive___2 = 0;
      }
    }
  }
  if (wp->w_redr_type) {
    if (! recursive___2) {
      {
      recursive___2 = 1;
      win_update(wp);
      recursive___2 = 0;
      }
    }
  }
  return;
}
}
static int win_line(WIN *wp , linenr_t lnum , int startrow , int endrow ) 
{ 
  char_u *screenp ;
  int c ;
  int col ;
  long vcol ;
  long v ;
  int rcol ;
  int row ;
  int screen_row ;
  char_u *ptr ;
  char_u *line ;
  char_u extra[16] ;
  int n_extra ;
  char_u *p_extra ;
  int c_extra ;
  char_u *showbreak ;
  int saved_attr1 ;
  int n_attr ;
  int n_skip ;
  int n_number ;
  int fromcol ;
  int tocol ;
  int noinvcur ;
  FPOS *top ;
  FPOS *bot ;
  int area_highlighting ;
  int attr ;
  int area_attr ;
  int search_attr ;
  int syntax_attr ;
  int has_syntax ;
  int extra_check ;
  int char_attr ;
  int saved_attr2 ;
  int extra_attr ;
  char_u *matchp ;
  char_u *search_hl_start ;
  char_u *search_hl_end ;
  char_u *trail ;
  int need_showbreak ;
  int save_got_int ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FPOS pos___0 ;
  size_t tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int x___0 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char_u *tmp___12 ;
  int tmp___13 ;

  {
  c = 0;
  n_extra = 0;
  p_extra = (char_u *)((void *)0);
  c_extra = '\000';
  showbreak = (char_u *)((void *)0);
  saved_attr1 = 0;
  n_attr = 0;
  n_skip = 0;
  n_number = 0;
  noinvcur = 0;
  area_attr = 0;
  search_attr = 0;
  syntax_attr = 0;
  has_syntax = 0;
  saved_attr2 = 0;
  extra_attr = 0;
  search_hl_start = (char_u *)((void *)0);
  search_hl_end = (char_u *)((void *)0);
  trail = (char_u *)((void *)0);
  need_showbreak = 0;
  if (startrow > endrow) {
    return (startrow);
  }
  row = startrow;
  screen_row = row + wp->w_winpos;
  attr = highlight_attr[14];
  if (clipboard.available) {
    if (! clipboard.owned) {
      {
      tmp = clip_isautosel();
      }
      if (tmp) {
        attr = highlight_attr[15];
      }
    }
  }
  {
  extra_check = wp->w_p_lbr;
  save_got_int = got_int;
  got_int = 0;
  tmp___0 = syntax_present(wp->w_buffer);
  }
  if (tmp___0) {
    {
    syntax_start(wp, lnum);
    has_syntax = 1;
    extra_check = 1;
    }
  }
  col = 0;
  vcol = 0L;
  fromcol = -10;
  tocol = 2147483647;
  area_highlighting = 0;
  char_attr = 0;
  if (VIsual_active) {
    if ((unsigned long )wp->w_buffer == (unsigned long )curwin->w_buffer) {
      if (curwin->w_cursor.lnum != VIsual.lnum) {
        tmp___1 = curwin->w_cursor.lnum < VIsual.lnum;
      } else {
        tmp___1 = curwin->w_cursor.col <= VIsual.col;
      }
      if (tmp___1) {
        top = & curwin->w_cursor;
        bot = & VIsual;
      } else {
        top = & VIsual;
        bot = & curwin->w_cursor;
      }
      if (VIsual_mode == 22) {
        if (lnum >= top->lnum) {
          if (lnum <= bot->lnum) {
            fromcol = (int )wp->w_old_cursor_fcol;
            tocol = (int )wp->w_old_cursor_lcol;
          }
        }
      } else {
        if (lnum > top->lnum) {
          if (lnum <= bot->lnum) {
            fromcol = 0;
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if (lnum == top->lnum) {
          if (VIsual_mode == 86) {
            fromcol = 0;
          } else {
            {
            getvcol(wp, top, (colnr_t *)(& fromcol), (colnr_t *)((void *)0), (colnr_t *)((void *)0));
            }
          }
        }
        }
        if (VIsual_mode != 86) {
          if (lnum == bot->lnum) {
            if ((int )*p_sel == 101) {
              if (bot->col == 0U) {
                fromcol = -10;
                tocol = 2147483647;
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              pos___0 = *bot;
              if ((int )*p_sel == 101) {
                (pos___0.col) --;
              }
              {
              getvcol(wp, & pos___0, (colnr_t *)((void *)0), (colnr_t *)((void *)0),
                      (colnr_t *)(& tocol));
              tocol ++;
              }
            }
          }
        }
      }
      if (! highlight_match) {
        if (lnum == curwin->w_cursor.lnum) {
          if ((unsigned long )wp == (unsigned long )curwin) {
            noinvcur = 1;
          }
        }
      }
      if (fromcol >= 0) {
        area_highlighting = 1;
      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (highlight_match) {
    if ((unsigned long )wp == (unsigned long )curwin) {
      if (search_match_len) {
        if (lnum == curwin->w_cursor.lnum) {
          {
          getvcol(curwin, & curwin->w_cursor, (colnr_t *)(& fromcol), (colnr_t *)((void *)0),
                  (colnr_t *)((void *)0));
          curwin->w_cursor.col += (colnr_t )search_match_len;
          getvcol(curwin, & curwin->w_cursor, (colnr_t *)(& tocol), (colnr_t *)((void *)0),
                  (colnr_t *)((void *)0));
          curwin->w_cursor.col -= (colnr_t )search_match_len;
          area_highlighting = 1;
          attr = highlight_attr[5];
          }
          if (fromcol == tocol) {
            tocol = fromcol + 1;
          }
        }
      }
    }
  }
  }
  {
  ptr = ml_get_buf(wp->w_buffer, lnum, 0);
  matchp = ptr;
  line = ptr;
  rcol = 0;
  }
  if (wp->w_p_list) {
    if (lcs_trail) {
      {
      tmp___2 = strlen((char const   *)((char *)ptr));
      trail = ptr + tmp___2;
      }
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if ((unsigned long )trail > (unsigned long )ptr) {
          if (! ((int )*(trail + -1) == 32)) {
            if (! ((int )*(trail + -1) == 9)) {
              goto while_break;
            }
          }
        } else {
          goto while_break;
        }
        trail --;
      }
      while_break: /* CIL Label */ ;
      }
      extra_check = 1;
    }
  }
  if (wp->w_p_wrap) {
    v = (long )wp->w_skipcol;
  } else {
    v = (long )wp->w_leftcol;
  }
  if (v > 0L) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (vcol < v) {
        if (! *ptr) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      {
      c = win_lbr_chartabsize(wp, ptr, (colnr_t )vcol, (int *)((void *)0));
      ptr ++;
      vcol += (long )c;
      rcol ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (vcol > v) {
      vcol -= (long )c;
      ptr --;
      rcol --;
      n_skip = (int )(v - vcol);
    }
    if ((long )tocol <= vcol) {
      fromcol = 0;
    } else { //Added block
    if (fromcol >= 0) {
      if ((long )fromcol < vcol) {
        fromcol = (int )vcol;
      }
    }
    }
    if (wp->w_p_wrap) {
      need_showbreak = 1;
    }
  }
  if ((unsigned long )search_hl_prog != (unsigned long )((void *)0)) {
    reg_ic = search_hl_ic;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___4 = vim_regexec(search_hl_prog, matchp, (unsigned long )matchp == (unsigned long )line);
      }
      if (tmp___4) {
        search_hl_start = search_hl_prog->startp[0];
        search_hl_end = search_hl_prog->endp[0];
        if ((unsigned long )search_hl_start < (unsigned long )ptr) {
          if ((unsigned long )search_hl_end <= (unsigned long )ptr) {
            if ((int )*search_hl_end != 0) {
              if ((unsigned long )matchp == (unsigned long )search_hl_end) {
                matchp ++;
              } else {
                {
                tmp___3 = vim_strchr(p_cpo, 'c');
                }
                if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
                  matchp ++;
                } else {
                  matchp = search_hl_end;
                }
              }
              goto __Cont;
            }
          }
        }
        if ((unsigned long )search_hl_start == (unsigned long )search_hl_end) {
          if ((int )*search_hl_start == 0) {
            if ((unsigned long )search_hl_start > (unsigned long )line) {
              search_hl_start --;
            } else {
              search_hl_end ++;
            }
          } else {
            search_hl_end ++;
          }
        }
        if ((unsigned long )search_hl_start < (unsigned long )ptr) {
          search_attr = search_hl_attr;
        }
      } else {
        search_hl_start = (char_u *)((void *)0);
        search_hl_end = (char_u *)((void *)0);
      }
      goto while_break___1;
      __Cont: ;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((unsigned long )search_hl_start != (unsigned long )((void *)0)) {
      area_highlighting = 1;
    }
  }
  screenp = current_LinePointer;
  if (wp->w_p_nu) {
    {
    sprintf((char * __restrict  )((char *)(extra)), (char const   * __restrict  )"%7ld ",
            lnum);
    n_number = 8;
    n_extra = 8;
    p_extra = extra;
    c_extra = '\000';
    vcol -= 8L;
    n_attr = 8;
    extra_attr = highlight_attr[9];
    saved_attr2 = 0;
    }
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (area_highlighting) {
      if (n_number <= 0) {
        if (vcol == (long )fromcol) {
          if (noinvcur) {
            if ((colnr_t )vcol == wp->w_virtcol) {
              goto _L___6;
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else { //Added block
        _L___6: 
        if (noinvcur) {
          if ((colnr_t )vcol == wp->w_virtcol + 1U) {
            if (vcol >= (long )fromcol) {
              _L___3: 
              if (vcol < (long )tocol) {
                area_attr = attr;
              } else {
                goto _L___5;
              }
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else { //Added block
        _L___5: 
        if (area_attr) {
          if (vcol == (long )tocol) {
            area_attr = 0;
          } else { //Added block
          if (noinvcur) {
            if ((colnr_t )vcol == wp->w_virtcol) {
              area_attr = 0;
            }
          }
          }
        }
        }
        }
        if (! n_extra) {
          {
          while (1) {
            while_continue___3: /* CIL Label */ ;
            if ((unsigned long )search_hl_start != (unsigned long )((void *)0)) {
              if ((unsigned long )ptr >= (unsigned long )search_hl_start) {
                if ((unsigned long )ptr < (unsigned long )search_hl_end) {
                  search_attr = search_hl_attr;
                } else {
                  goto _L___8;
                }
              } else {
                goto _L___8;
              }
            } else { //Added block
            _L___8: 
            if ((unsigned long )ptr == (unsigned long )search_hl_end) {
              {
              search_attr = 0;
              reg_ic = search_hl_ic;
              tmp___5 = vim_strchr(p_cpo, 'c');
              }
              if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
                {
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  {
                  x___0 = vim_regexec(search_hl_prog, search_hl_start + 1, 0);
                  search_hl_start = search_hl_prog->startp[0];
                  }
                  if (x___0) {
                    if (! ((unsigned long )search_hl_prog->endp[0] <= (unsigned long )ptr)) {
                      goto while_break___4;
                    }
                  } else {
                    goto while_break___4;
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
              } else {
                {
                x___0 = vim_regexec(search_hl_prog, ptr, 0);
                }
              }
              if (x___0) {
                search_hl_start = search_hl_prog->startp[0];
                search_hl_end = search_hl_prog->endp[0];
                if ((unsigned long )search_hl_start != (unsigned long )search_hl_end) {
                  goto __Cont___0;
                }
                search_hl_end ++;
                if ((int )*search_hl_start == 0) {
                  if ((unsigned long )search_hl_start > (unsigned long )line) {
                    search_hl_start --;
                    goto __Cont___0;
                  }
                }
              }
            }
            }
            goto while_break___3;
            __Cont___0: ;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        if (area_attr) {
          char_attr = area_attr;
        } else { //Added block
        if (! search_attr) {
          if (has_syntax) {
            char_attr = syntax_attr;
          } else {
            char_attr = search_attr;
          }
        } else {
          char_attr = search_attr;
        }
        }
      }
    }
    if ((int )*p_sbr != 0) {
      if (need_showbreak) {
        showbreak = p_sbr;
        saved_attr1 = char_attr;
      } else { //Added block
      if ((long )col == Columns) {
        if ((int )*ptr != 0) {
          goto _L___10;
        } else { //Added block
        if (wp->w_p_list) {
          if (lcs_eol != 0) {
            goto _L___10;
          } else {
            goto _L___11;
          }
        } else { //Added block
        _L___11: 
        if (n_extra) {
          if (c_extra != 0) {
            goto _L___10;
          } else { //Added block
          if ((int )*p_extra != 0) {
            _L___10: 
            if (vcol != 0L) {
              showbreak = p_sbr;
              saved_attr1 = char_attr;
            }
          }
          }
        }
        }
        }
      }
      }
      if ((unsigned long )showbreak != (unsigned long )((void *)0)) {
        if ((int )*showbreak == 0) {
          showbreak = (char_u *)((void *)0);
          char_attr = saved_attr1;
        } else {
          tmp___6 = showbreak;
          showbreak ++;
          c = (int )*tmp___6;
          char_attr = highlight_attr[1];
        }
      }
      need_showbreak = 0;
    }
    if ((unsigned long )showbreak == (unsigned long )((void *)0)) {
      if (n_extra) {
        if (c_extra) {
          c = c_extra;
        } else {
          tmp___7 = p_extra;
          p_extra ++;
          c = (int )*tmp___7;
        }
        n_extra --;
      } else {
        tmp___8 = ptr;
        ptr ++;
        c = (int )*tmp___8;
        if (extra_check) {
          if (has_syntax) {
            {
            tmp___9 = rcol;
            rcol ++;
            syntax_attr = get_syntax_attr((colnr_t )tmp___9, line);
            }
            if (! area_attr) {
              if (! search_attr) {
                char_attr = syntax_attr;
              }
            }
          }
          if (wp->w_p_lbr) {
            if (breakat_flags[(char_u )c]) {
              if (! breakat_flags[*ptr]) {
                if (! wp->w_p_list) {
                  {
                  tmp___10 = win_lbr_chartabsize(wp, ptr - 1, (colnr_t )vcol, (int *)((void *)0));
                  n_extra = tmp___10 - 1;
                  c_extra = ' ';
                  }
                  if (c == 32) {
                    c = ' ';
                  } else { //Added block
                  if (c == 9) {
                    c = ' ';
                  }
                  }
                }
              }
            }
          }
          if ((unsigned long )trail != (unsigned long )((void *)0)) {
            if ((unsigned long )ptr > (unsigned long )trail) {
              if (c == 32) {
                c = lcs_trail;
                if (! area_attr) {
                  if (! search_attr) {
                    n_attr = 1;
                    extra_attr = highlight_attr[1];
                    saved_attr2 = char_attr;
                  }
                }
              }
            }
          }
        }
        {
        tmp___13 = safe_vim_isprintc(c);
        }
        if (! tmp___13) {
          if (c == 9) {
            if (! wp->w_p_list) {
              goto _L___15;
            } else { //Added block
            if (lcs_tab1) {
              _L___15: 
              n_extra = (int )(((long )((int )(wp->w_buffer)->b_p_ts) - vcol % (long )((int )(wp->w_buffer)->b_p_ts)) - 1L);
              if (wp->w_p_list) {
                c = lcs_tab1;
                c_extra = lcs_tab2;
                if (! area_attr) {
                  if (! search_attr) {
                    n_attr = n_extra + 1;
                    extra_attr = highlight_attr[1];
                    saved_attr2 = char_attr;
                  }
                }
              } else {
                c_extra = ' ';
                c = ' ';
              }
            } else {
              goto _L___14;
            }
            }
          } else { //Added block
          _L___14: 
          if (c == 0) {
            if (wp->w_p_list) {
              if (lcs_eol != 0) {
                p_extra = (char_u *)"";
                n_extra = 1;
                c_extra = '\000';
                c = lcs_eol;
                ptr --;
                char_attr = highlight_attr[1];
              } else {
                goto _L___13;
              }
            } else {
              goto _L___13;
            }
          } else { //Added block
          _L___13: 
          if (c != 0) {
            {
            p_extra = transchar(c);
            tmp___11 = charsize(c);
            n_extra = tmp___11 - 1;
            c_extra = '\000';
            tmp___12 = p_extra;
            p_extra ++;
            c = (int )*tmp___12;
            }
          }
          }
          }
        }
      }
      if (n_attr) {
        char_attr = extra_attr;
      }
    }
    if (c == 0) {
      if (area_attr) {
        if (vcol == (long )fromcol) {
          goto _L___16;
        } else {
          goto _L___17;
        }
      } else { //Added block
      _L___17: 
      if (search_attr) {
        if ((int )*line == 0) {
          if (wp->w_leftcol == 0U) {
            _L___16: 
            if ((long )col >= Columns) {
              screenp --;
              col --;
            }
            *screenp = (char_u )' ';
            *(screenp + Columns) = (char_u )char_attr;
            col ++;
          }
        }
      }
      }
      {
      screen_line(screen_row, col, 1);
      row ++;
      }
      if ((unsigned long )wp == (unsigned long )curwin) {
        if (lnum == curwin->w_cursor.lnum) {
          curwin->w_cline_row = startrow;
          curwin->w_cline_height = row - startrow;
          curwin->w_valid |= 24;
        }
      }
      goto while_break___2;
    }
    if ((long )col >= Columns) {
      {
      screen_line(screen_row, col, 1);
      col = 0;
      row ++;
      screen_row ++;
      }
      if (! wp->w_p_wrap) {
        goto while_break___2;
      }
      if (row == endrow) {
        row ++;
        goto while_break___2;
      }
      if (p_tf) {
        if (screen_cur_row == screen_row - 1) {
          if ((long )screen_cur_col != Columns) {
            {
            screen_char((*(LinePointers + (screen_row - 1)) + Columns) - 1, screen_row - 1,
                        (int )(Columns - 1L));
            }
          }
          {
          screen_char(*(LinePointers + screen_row), screen_row - 1, (int )Columns);
          screen_start();
          }
        }
      }
      screenp = current_LinePointer;
    }
    if (lcs_ext) {
      if (! wp->w_p_wrap) {
        if ((long )col == Columns - 1L) {
          if ((int )*ptr != 0) {
            c = lcs_ext;
            char_attr = highlight_attr[1];
          } else { //Added block
          if (wp->w_p_list) {
            if (lcs_eol != 0) {
              c = lcs_ext;
              char_attr = highlight_attr[1];
            } else {
              goto _L___18;
            }
          } else { //Added block
          _L___18: 
          if (n_extra) {
            if (c_extra != 0) {
              c = lcs_ext;
              char_attr = highlight_attr[1];
            } else { //Added block
            if ((int )*p_extra != 0) {
              c = lcs_ext;
              char_attr = highlight_attr[1];
            }
            }
          }
          }
          }
        }
      }
    }
    if (n_number > 0) {
      *screenp = (char_u )c;
      *(screenp + Columns) = (char_u )char_attr;
      screenp ++;
      col ++;
      n_number --;
    } else { //Added block
    if (n_skip <= 0) {
      *screenp = (char_u )c;
      *(screenp + Columns) = (char_u )char_attr;
      screenp ++;
      col ++;
      n_number --;
    } else {
      n_skip --;
    }
    }
    vcol ++;
    if (n_attr) {
      n_attr --;
      if (n_attr == 0) {
        char_attr = saved_attr2;
      }
    }
    if (dollar_vcol) {
      if ((unsigned long )wp == (unsigned long )curwin) {
        if (vcol >= (long )wp->w_virtcol) {
          {
          screen_line(screen_row, col, 0);
          }
          goto while_break___2;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  if (! got_int) {
    got_int = save_got_int;
  }
  return (row);
}
}
static int char_needs_redraw(char_u *screenp_from , char_u *screenp_to , int len___0 ) 
{ 


  {
  if (len___0 > 0) {
    if ((int )*screenp_from != (int )*screenp_to) {
      return (1);
    } else { //Added block
    if ((int )*(screenp_from + Columns) != (int )*(screenp_to + Columns)) {
      return (1);
    }
    }
  }
  return (0);
}
}
static void screen_line(int row , int endcol , int clear_rest ) 
{ 
  char_u *screenp_from ;
  char_u *screenp_to ;
  int col ;
  int hl ;
  int force ;
  int redraw_this ;
  int redraw_next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  col = 0;
  force = 0;
  screenp_from = current_LinePointer;
  screenp_to = *(LinePointers + row);
  redraw_next = char_needs_redraw(screenp_from, screenp_to, endcol - col);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (col < endcol)) {
      goto while_break;
    }
    redraw_this = redraw_next;
    if (force) {
      tmp___0 = 1;
    } else {
      {
      tmp = char_needs_redraw(screenp_from + 1, screenp_to + 1, (endcol - col) - 1);
      }
      if (tmp) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    }
    redraw_next = tmp___0;
    if (redraw_this) {
      if (p_wiv) {
        if (! force) {
          if (*(screenp_to + Columns)) {
            if ((int )*(screenp_from + Columns) != (int )*(screenp_to + Columns)) {
              {
              windgoto(row, col);
              out_str(term_strings[1]);
              screen_start();
              force = 1;
              redraw_next = 1;
              }
              if (col > 0) {
                if (*((screenp_to + Columns) - 1)) {
                  {
                  screen_attr = (int )*((screenp_to + Columns) - 1);
                  term_windgoto(row, col);
                  screen_stop_highlight();
                  }
                } else {
                  screen_attr = 0;
                }
              } else {
                screen_attr = 0;
              }
            }
          }
        }
      }
      {
      *screenp_to = *screenp_from;
      tmp___1 = vim_is_xterm(term_strings[0]);
      }
      if (tmp___1) {
        hl = (int )*(screenp_to + Columns);
        if (hl > 31) {
          redraw_next = 1;
        } else { //Added block
        if (hl & 2) {
          redraw_next = 1;
        }
        }
      }
      {
      *(screenp_to + Columns) = *(screenp_from + Columns);
      screen_char(screenp_to, row, col);
      }
    } else { //Added block
    if (p_wiv) {
      if (col > 0) {
        if ((int )*(screenp_to + Columns) == (int )*((screenp_to + Columns) - 1)) {
          screen_attr = 0;
        } else { //Added block
        if (screen_attr) {
          {
          screen_stop_highlight();
          }
        }
        }
      }
    }
    }
    screenp_to ++;
    screenp_from ++;
    col ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (clear_rest) {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((long )col < Columns) {
        if ((int )*screenp_to == 32) {
          if (! ((int )*(screenp_to + Columns) == 0)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      screenp_to ++;
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((long )col < Columns) {
      {
      screen_fill(row, row + 1, col, (int )Columns, ' ', ' ', 0);
      }
    }
  }
  return;
}
}
void status_redraw_all(void) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_status_height) {
      {
      wp->w_redr_status = 1;
      redraw_later(40);
      }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void redraw_statuslines(void) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_status) {
      {
      win_redr_status(wp);
      }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char_u *m_gettail(char_u *s ) ;
static int status_match_len(char_u *s ) ;
static char_u *m_gettail(char_u *s ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((int )*s == 0) {
    return (s);
  }
  {
  tmp = strlen((char const   *)((char *)s));
  p___0 = (s + tmp) - 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = vim_ispathsep((int )*p___0);
    }
    if (tmp___0) {
      if (! ((unsigned long )p___0 > (unsigned long )s)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    p___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    tmp___1 = vim_ispathsep((int )*p___0);
    }
    if (tmp___1) {
      goto while_break___0;
    } else { //Added block
    if (! ((unsigned long )p___0 > (unsigned long )s)) {
      goto while_break___0;
    }
    }
    p___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (*(p___0 + 1)) {
    {
    tmp___2 = vim_ispathsep((int )*p___0);
    }
    if (tmp___2) {
      {
      tmp___3 = vim_ispathsep((int )*(p___0 + 1));
      }
      if (! tmp___3) {
        p___0 ++;
      }
    }
  }
  return (p___0);
}
}
static int status_match_len(char_u *s ) 
{ 
  int len___0 ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  len___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp = rem_backslash(s);
    }
    if (tmp) {
      s ++;
    } else { //Added block
    if (expand_context == 21) {
      if ((int )*(s + 0) == 92) {
        if ((int )*(s + 1) != 0) {
          s ++;
        }
      }
    }
    }
    {
    tmp___0 = s;
    s ++;
    tmp___1 = charsize((int )*tmp___0);
    len___0 += tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (len___0);
}
}
static int first_match___0  =    0;
void win_redr_status_matches(int num_matches___0 , char_u **matches___0 , int match ) 
{ 
  int fmatch ;
  int row ;
  char_u *buf___3 ;
  int len___0 ;
  int fillchar ;
  int attr ;
  int i___0 ;
  int highlight ;
  char_u *selstart ;
  char_u *selend ;
  int add_left ;
  char_u *s ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  int tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char_u *tmp___17 ;
  char_u *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  fmatch = expand_context == 2;
  highlight = 1;
  selstart = (char_u *)((void *)0);
  selend = (char_u *)((void *)0);
  add_left = 0;
  if ((unsigned long )matches___0 == (unsigned long )((void *)0)) {
    return;
  }
  {
  buf___3 = alloc((unsigned int )Columns + 1U);
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
    return;
  }
  if (match == -1) {
    match = 0;
    highlight = 0;
  }
  if (fmatch) {
    {
    tmp = m_gettail(*(matches___0 + match));
    tmp___0 = tmp;
    }
  } else {
    tmp___0 = *(matches___0 + match);
  }
  {
  tmp___1 = status_match_len(tmp___0);
  len___0 = tmp___1 + 3;
  }
  if (match == 0) {
    first_match___0 = 0;
  } else { //Added block
  if (match < first_match___0) {
    first_match___0 = match;
    add_left = 1;
  } else {
    i___0 = first_match___0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < match)) {
        goto while_break;
      }
      if (fmatch) {
        {
        tmp___2 = m_gettail(*(matches___0 + i___0));
        tmp___3 = tmp___2;
        }
      } else {
        tmp___3 = *(matches___0 + i___0);
      }
      {
      tmp___4 = status_match_len(tmp___3);
      len___0 += tmp___4 + 2;
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (first_match___0 > 0) {
      len___0 += 2;
    }
    if ((long )len___0 > Columns) {
      first_match___0 = match;
      len___0 = 2;
      i___0 = match;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (i___0 < num_matches___0)) {
          goto while_break___0;
        }
        if (fmatch) {
          {
          tmp___5 = m_gettail(*(matches___0 + i___0));
          tmp___6 = tmp___5;
          }
        } else {
          tmp___6 = *(matches___0 + i___0);
        }
        {
        tmp___7 = status_match_len(tmp___6);
        len___0 += tmp___7 + 2;
        }
        if ((long )len___0 >= Columns) {
          goto while_break___0;
        }
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      if (i___0 == num_matches___0) {
        add_left = 1;
      }
    }
  }
  }
  if (add_left) {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (first_match___0 > 0)) {
        goto while_break___1;
      }
      if (fmatch) {
        {
        tmp___8 = m_gettail(*(matches___0 + (first_match___0 - 1)));
        tmp___9 = tmp___8;
        }
      } else {
        tmp___9 = *(matches___0 + (first_match___0 - 1));
      }
      {
      tmp___10 = status_match_len(tmp___9);
      len___0 += tmp___10 + 2;
      }
      if ((long )len___0 >= Columns) {
        goto while_break___1;
      }
      first_match___0 --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  fillchar = highlight_status(& attr, 1);
  }
  if (first_match___0 == 0) {
    *buf___3 = (char_u )'\000';
    len___0 = 0;
  } else {
    {
    strcpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)"< "));
    len___0 = 2;
    }
  }
  i___0 = first_match___0;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (fmatch) {
      {
      tmp___17 = m_gettail(*(matches___0 + i___0));
      tmp___18 = tmp___17;
      }
    } else {
      tmp___18 = *(matches___0 + i___0);
    }
    {
    tmp___19 = status_match_len(tmp___18);
    }
    if (! ((long )((len___0 + tmp___19) + 2) < Columns)) {
      goto while_break___2;
    }
    if (i___0 == match) {
      selstart = buf___3 + len___0;
    }
    if (fmatch) {
      {
      tmp___11 = m_gettail(*(matches___0 + i___0));
      s = tmp___11;
      }
    } else {
      s = *(matches___0 + i___0);
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! *s) {
        goto while_break___3;
      }
      {
      tmp___12 = rem_backslash(s);
      }
      if (tmp___12) {
        s ++;
      } else { //Added block
      if (expand_context == 21) {
        if ((int )*(s + 0) == 92) {
          if ((int )*(s + 1) != 0) {
            s ++;
          }
        }
      }
      }
      {
      tmp___13 = transchar((int )*s);
      strcpy((char * __restrict  )((char *)(buf___3 + len___0)), (char const   * __restrict  )((char *)tmp___13));
      tmp___14 = strlen((char const   *)((char *)(buf___3 + len___0)));
      len___0 = (int )((size_t )len___0 + tmp___14);
      s ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    if (i___0 == match) {
      selend = buf___3 + len___0;
    }
    tmp___15 = len___0;
    len___0 ++;
    *(buf___3 + tmp___15) = (char_u )' ';
    tmp___16 = len___0;
    len___0 ++;
    *(buf___3 + tmp___16) = (char_u )' ';
    i___0 ++;
    if (i___0 == num_matches___0) {
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  if (i___0 != num_matches___0) {
    tmp___20 = len___0;
    len___0 ++;
    *(buf___3 + tmp___20) = (char_u )'>';
  }
  *(buf___3 + len___0) = (char_u )'\000';
  row = cmdline_row - 1;
  if (row >= 0) {
    if (! wild_menu_showing) {
      if (msg_scrolled) {
        if (! wild_menu_showing) {
          if ((long )cmdline_row == Rows - 1L) {
            {
            screen_del_lines(0, 0, 1, (int )Rows, 1);
            }
          } else {
            cmdline_row ++;
            row ++;
          }
          wild_menu_showing = 2;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (lastwin->w_status_height == 0) {
          {
          save_p_ls = (int )p_ls;
          p_ls = 2L;
          last_status();
          }
        }
        wild_menu_showing = 1;
      }
    }
    {
    screen_puts(buf___3, row, 0, attr);
    }
    if ((unsigned long )selstart != (unsigned long )((void *)0)) {
      if (highlight) {
        {
        *selend = (char_u )'\000';
        screen_puts(selstart, row, (int )(selstart - buf___3), highlight_attr[17]);
        }
      }
    }
    {
    screen_fill(row, row + 1, len___0, (int )Columns, fillchar, fillchar, attr);
    }
  }
  {
  lastwin->w_redr_status = 1;
  vim_free((void *)buf___3);
  }
  return;
}
}
void win_redr_status(WIN *wp ) 
{ 
  int row ;
  char_u *p___0 ;
  int len___0 ;
  int fillchar ;
  int attr ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  wp->w_redr_status = 0;
  if (wp->w_status_height == 0) {
    redraw_cmdline = 1;
  } else {
    {
    tmp___3 = redrawing();
    }
    if (tmp___3) {
      if (*p_stl) {
        {
        win_redr_custom(wp, 0);
        }
      } else {
        {
        fillchar = highlight_status(& attr, (unsigned long )wp == (unsigned long )curwin);
        p___0 = (wp->w_buffer)->b_fname;
        }
        if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
          {
          strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)"[No File]"));
          }
        } else {
          {
          home_replace(wp->w_buffer, p___0, NameBuff, 1024, 1);
          trans_characters(NameBuff, 1024);
          }
        }
        {
        p___0 = NameBuff;
        tmp = strlen((char const   *)((char *)p___0));
        len___0 = (int )tmp;
        }
        if ((wp->w_buffer)->b_help) {
          tmp___0 = len___0;
          len___0 ++;
          *(p___0 + tmp___0) = (char_u )' ';
        } else { //Added block
        if (wp->w_preview) {
          tmp___0 = len___0;
          len___0 ++;
          *(p___0 + tmp___0) = (char_u )' ';
        } else {
          {
          tmp___1 = buf_changed(wp->w_buffer);
          }
          if (tmp___1) {
            tmp___0 = len___0;
            len___0 ++;
            *(p___0 + tmp___0) = (char_u )' ';
          } else { //Added block
          if ((wp->w_buffer)->b_p_ro) {
            tmp___0 = len___0;
            len___0 ++;
            *(p___0 + tmp___0) = (char_u )' ';
          }
          }
        }
        }
        if ((wp->w_buffer)->b_help) {
          {
          strcpy((char * __restrict  )((char *)(p___0 + len___0)), (char const   * __restrict  )((char *)"[help]"));
          len___0 += 6;
          }
        }
        if (wp->w_preview) {
          {
          strcpy((char * __restrict  )((char *)(p___0 + len___0)), (char const   * __restrict  )((char *)"[Preview]"));
          len___0 += 9;
          }
        }
        {
        tmp___2 = buf_changed(wp->w_buffer);
        }
        if (tmp___2) {
          {
          strcpy((char * __restrict  )((char *)(p___0 + len___0)), (char const   * __restrict  )((char *)"[+]"));
          len___0 += 3;
          }
        }
        if ((wp->w_buffer)->b_p_ro) {
          {
          strcpy((char * __restrict  )((char *)(p___0 + len___0)), (char const   * __restrict  )((char *)"[RO]"));
          len___0 += 4;
          }
        }
        if (len___0 > ru_col - 1) {
          p___0 += len___0 - (ru_col - 1);
          *p___0 = (char_u )'<';
          len___0 = ru_col - 1;
        }
        {
        row = wp->w_winpos + wp->w_height;
        screen_puts(p___0, row, 0, attr);
        screen_fill(row, row + 1, len___0, ru_col, fillchar, fillchar, attr);
        win_redr_ruler(wp, 1);
        }
      }
    } else {
      wp->w_redr_status = 1;
    }
  }
  return;
}
}
static void win_redr_custom(WIN *wp , int Ruler ) 
{ 
  int attr ;
  int curattr ;
  int row ;
  int col ;
  int maxlen ;
  int n ;
  int len___0 ;
  int fillchar ;
  char_u buf___3[1024] ;
  char_u *p___0 ;
  char_u c ;
  struct stl_hlrec hl[50] ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  col = 0;
  row = wp->w_winpos + wp->w_height;
  fillchar = highlight_status(& attr, (unsigned long )wp == (unsigned long )curwin);
  maxlen = (int )Columns;
  p___0 = p_stl;
  }
  if (Ruler) {
    p___0 = p_ruf;
    if ((int )*p___0 == 37) {
      p___0 ++;
      if ((int )*p___0 == 45) {
        p___0 ++;
      }
      {
      tmp___0 = atoi((char const   *)((char *)p___0));
      }
      if (tmp___0) {
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          {
          tmp = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp + (int )*p___0) & 2048)) {
            goto while_break;
          }
          p___0 ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      tmp___1 = p___0;
      p___0 ++;
      if ((int )*tmp___1 != 40) {
        p___0 = p_ruf;
      }
    }
    col = ru_col;
    maxlen = (int )(Columns - (long )ru_col);
    if (! wp->w_status_height) {
      row = (int )(Rows - 1L);
      maxlen --;
      fillchar = ' ';
      attr = 0;
    }
  }
  if ((unsigned long )maxlen >= sizeof(buf___3)) {
    maxlen = (int )(sizeof(buf___3) - 1UL);
  }
  {
  len___0 = build_stl_str_hl(wp, buf___3, p___0, fillchar, maxlen, hl);
  p___0 = buf___3 + len___0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )p___0 < (unsigned long )(buf___3 + maxlen))) {
      goto while_break___0;
    }
    *p___0 = (char_u )fillchar;
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  *p___0 = (char_u )0;
  curattr = attr;
  p___0 = buf___3;
  n = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! ((unsigned long )hl[n].start != (unsigned long )((void *)0))) {
      goto while_break___1;
    }
    {
    c = *(hl[n].start + 0);
    *(hl[n].start + 0) = (char_u )0;
    screen_puts(p___0, row, col, curattr);
    *(hl[n].start + 0) = c;
    col = (int )((long )col + (hl[n].start - p___0));
    p___0 = hl[n].start;
    }
    if (hl[n].userhl == 0) {
      curattr = attr;
    } else { //Added block
    if ((unsigned long )wp == (unsigned long )curwin) {
      curattr = highlight_user[hl[n].userhl - 1];
    } else { //Added block
    if (! wp->w_status_height) {
      curattr = highlight_user[hl[n].userhl - 1];
    } else {
      curattr = highlight_stlnc[hl[n].userhl - 1];
    }
    }
    }
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  screen_puts(p___0, row, col, curattr);
  }
  return;
}
}
int build_stl_str(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ) 
{ 
  int tmp ;

  {
  {
  tmp = build_stl_str_hl(wp, out, fmt, fillchar, maxlen, (struct stl_hlrec *)((void *)0));
  }
  return (tmp);
}
}
static int build_stl_str_hl(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ,
                            struct stl_hlrec *hl ) 
{ 
  char_u *p___0 ;
  char_u *s ;
  char_u *t ;
  char_u *linecont ;
  WIN *o_curwin ;
  BUF *o_curbuf ;
  int empty_line ;
  colnr_t virtcol ;
  long l ;
  long n ;
  int prevchar_isflag ;
  int prevchar_isitem ;
  int itemisflag ;
  char_u *str___1 ;
  long num ;
  int itemcnt ;
  int curitem ;
  int groupitem[50] ;
  int groupdepth ;
  struct stl_item item[50] ;
  int minwid ;
  int maxwid ;
  int zeropad ;
  char_u base ;
  char_u opt ;
  char_u tmp[50] ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  long tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char_u *tmp___15 ;
  char_u *tmp___16 ;
  char_u *tmp___17 ;
  char_u *tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  char_u *tmp___32 ;
  char_u *tmp___33 ;
  char_u *tmp___34 ;
  char_u *tmp___35 ;
  char_u *tmp___36 ;
  int nbase ;
  int tmp___37 ;
  int tmp___38 ;
  char_u nstr[20] ;
  char_u *tmp___39 ;
  char_u *tmp___40 ;
  char_u *tmp___41 ;
  char_u *tmp___42 ;
  char_u *tmp___43 ;
  int tmp___44 ;
  long tmp___45 ;
  char_u *tmp___46 ;
  char_u *tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  char_u *tmp___50 ;
  size_t tmp___51 ;
  size_t tmp___52 ;

  {
  if (! fillchar) {
    fillchar = ' ';
  }
  {
  linecont = ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, 0);
  empty_line = (int )*linecont == 0;
  groupdepth = 0;
  p___0 = out;
  curitem = 0;
  prevchar_isflag = 1;
  prevchar_isitem = 0;
  s = fmt;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    if (*s) {
      if ((int )*s != 37) {
        prevchar_isitem = 0;
        prevchar_isflag = prevchar_isitem;
      }
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (*s) {
        if (! ((int )*s != 37)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      tmp___0 = p___0;
      p___0 ++;
      tmp___1 = s;
      s ++;
      *tmp___0 = *tmp___1;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (! *s) {
      goto while_break;
    }
    s ++;
    if ((int )*s == 37) {
      tmp___2 = p___0;
      p___0 ++;
      tmp___3 = s;
      s ++;
      *tmp___2 = *tmp___3;
      prevchar_isitem = 0;
      prevchar_isflag = prevchar_isitem;
      goto __Cont;
    }
    if ((int )*s == 61) {
      s ++;
      if (groupdepth > 0) {
        goto __Cont;
      }
      item[curitem].type = (enum __anonenum_type_169___0 )3;
      tmp___4 = curitem;
      curitem ++;
      item[tmp___4].start = p___0;
      goto __Cont;
    }
    if ((int )*s == 60) {
      s ++;
      item[curitem].type = (enum __anonenum_type_169___0 )5;
      tmp___5 = curitem;
      curitem ++;
      item[tmp___5].start = p___0;
      goto __Cont;
    }
    if ((int )*s == 41) {
      s ++;
      if (groupdepth < 1) {
        goto __Cont;
      }
      groupdepth --;
      l = p___0 - item[groupitem[groupdepth]].start;
      if (curitem > groupitem[groupdepth] + 1) {
        if (item[groupitem[groupdepth]].minwid == 0) {
          n = (long )(groupitem[groupdepth] + 1);
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! (n < (long )curitem)) {
              goto while_break___1;
            }
            if ((unsigned int )item[n].type == 0U) {
              goto while_break___1;
            }
            n ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          if (n == (long )curitem) {
            p___0 = item[groupitem[groupdepth]].start;
          }
        }
      }
      if ((long )item[groupitem[groupdepth]].maxwid < l) {
        {
        n = (long )item[groupitem[groupdepth]].maxwid;
        memmove((void *)((char *)item[groupitem[groupdepth]].start), (void const   *)((char *)((item[groupitem[groupdepth]].start + l) - n)),
                (size_t )n);
        t = item[groupitem[groupdepth]].start;
        *t = (char_u )'<';
        l -= n;
        p___0 -= l;
        n = (long )(groupitem[groupdepth] + 1);
        }
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! (n < (long )curitem)) {
            goto while_break___2;
          }
          item[n].start -= l;
          if ((unsigned long )item[n].start < (unsigned long )t) {
            item[n].start = t;
          }
          n ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
        tmp___9 = abs(item[groupitem[groupdepth]].minwid);
        }
        if ((long )tmp___9 > l) {
          n = (long )item[groupitem[groupdepth]].minwid;
          if (n < 0L) {
            n = 0L - n;
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              tmp___7 = l;
              l ++;
              if (! (tmp___7 < n)) {
                goto while_break___3;
              }
              tmp___6 = p___0;
              p___0 ++;
              *tmp___6 = (char_u )fillchar;
            }
            while_break___3: /* CIL Label */ ;
            }
          } else {
            {
            memmove((void *)((char *)((item[groupitem[groupdepth]].start + n) - l)),
                    (void const   *)((char *)item[groupitem[groupdepth]].start), (size_t )l);
            l = n - l;
            p___0 += l;
            n = (long )(groupitem[groupdepth] + 1);
            }
            {
            while (1) {
              while_continue___4: /* CIL Label */ ;
              if (! (n < (long )curitem)) {
                goto while_break___4;
              }
              item[n].start += l;
              n ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            t = item[groupitem[groupdepth]].start;
            {
            while (1) {
              while_continue___5: /* CIL Label */ ;
              if (! (l > 0L)) {
                goto while_break___5;
              }
              tmp___8 = t;
              t ++;
              *tmp___8 = (char_u )fillchar;
              l --;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      }
      goto __Cont;
    }
    minwid = 0;
    maxwid = 50;
    zeropad = 0;
    l = 1L;
    if ((int )*s == 48) {
      s ++;
      zeropad = 1;
    }
    if ((int )*s == 45) {
      s ++;
      l = -1L;
    }
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (*s) {
        {
        tmp___10 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___10 + (int )*s) & 2048)) {
          goto while_break___6;
        }
      } else {
        goto while_break___6;
      }
      minwid *= 10;
      minwid += (int )*s - 48;
      s ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    if ((int )*s == 42) {
      item[curitem].type = (enum __anonenum_type_169___0 )4;
      item[curitem].start = p___0;
      if (minwid > 9) {
        item[curitem].minwid = 1;
      } else {
        item[curitem].minwid = minwid;
      }
      s ++;
      curitem ++;
      goto __Cont;
    }
    if ((int )*s == 46) {
      {
      s ++;
      tmp___11 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___11 + (int )*s) & 2048) {
        maxwid = 0;
      }
      {
      while (1) {
        while_continue___7: /* CIL Label */ ;
        if (*s) {
          {
          tmp___12 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___12 + (int )*s) & 2048)) {
            goto while_break___7;
          }
        } else {
          goto while_break___7;
        }
        maxwid *= 10;
        maxwid += (int )*s - 48;
        s ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    if (minwid > 50) {
      tmp___13 = 50;
    } else {
      tmp___13 = minwid;
    }
    minwid = (int )((long )tmp___13 * l);
    if ((int )*s == 40) {
      tmp___14 = groupdepth;
      groupdepth ++;
      groupitem[tmp___14] = curitem;
      item[curitem].type = (enum __anonenum_type_169___0 )2;
      item[curitem].start = p___0;
      item[curitem].minwid = minwid;
      item[curitem].maxwid = maxwid;
      s ++;
      curitem ++;
      goto __Cont;
    }
    {
    tmp___15 = vim_strchr((char_u *)"fFtcvVlLnoObBrRhHmYyWwMpPa{", (int )*s);
    }
    if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
      s ++;
      goto __Cont;
    }
    tmp___16 = s;
    s ++;
    opt = *tmp___16;
    base = (char_u )'D';
    itemisflag = 0;
    num = -1L;
    str___1 = (char_u *)((void *)0);
    {
    if ((int )opt == 102) {
      goto case_102;
    }
    if ((int )opt == 70) {
      goto case_102;
    }
    if ((int )opt == 116) {
      goto case_102;
    }
    if ((int )opt == 123) {
      goto case_123;
    }
    if ((int )opt == 108) {
      goto case_108;
    }
    if ((int )opt == 76) {
      goto case_76;
    }
    if ((int )opt == 99) {
      goto case_99;
    }
    if ((int )opt == 118) {
      goto case_118;
    }
    if ((int )opt == 86) {
      goto case_118;
    }
    if ((int )opt == 112) {
      goto case_112;
    }
    if ((int )opt == 80) {
      goto case_80;
    }
    if ((int )opt == 97) {
      goto case_97;
    }
    if ((int )opt == 110) {
      goto case_110;
    }
    if ((int )opt == 79) {
      goto case_79;
    }
    if ((int )opt == 111) {
      goto case_111;
    }
    if ((int )opt == 66) {
      goto case_66;
    }
    if ((int )opt == 98) {
      goto case_98;
    }
    if ((int )opt == 114) {
      goto case_114;
    }
    if ((int )opt == 82) {
      goto case_114;
    }
    if ((int )opt == 104) {
      goto case_104;
    }
    if ((int )opt == 72) {
      goto case_104;
    }
    if ((int )opt == 121) {
      goto case_121;
    }
    if ((int )opt == 89) {
      goto case_89;
    }
    if ((int )opt == 119) {
      goto case_119;
    }
    if ((int )opt == 87) {
      goto case_119;
    }
    if ((int )opt == 109) {
      goto case_109;
    }
    if ((int )opt == 77) {
      goto case_109;
    }
    goto switch_break;
    case_102: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_116: /* CIL Label */ 
    if ((int )opt == 70) {
      t = (wp->w_buffer)->b_ffname;
    } else {
      t = (wp->w_buffer)->b_fname;
    }
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
      strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)"[No File]"));
      }
    } else {
      {
      home_replace(wp->w_buffer, t, NameBuff, 1024, 1);
      trans_characters(NameBuff, 1024);
      }
    }
    if ((int )opt != 116) {
      str___1 = NameBuff;
    } else {
      {
      str___1 = gettail(NameBuff);
      }
    }
    goto switch_break;
    case_123: /* CIL Label */ 
    itemisflag = 1;
    t = p___0;
    {
    while (1) {
      while_continue___8: /* CIL Label */ ;
      if (! ((int )*s != 125)) {
        goto while_break___8;
      }
      tmp___17 = p___0;
      p___0 ++;
      tmp___18 = s;
      s ++;
      *tmp___17 = *tmp___18;
    }
    while_break___8: /* CIL Label */ ;
    }
    s ++;
    *p___0 = (char_u )0;
    p___0 = t;
    if (RedrawingDisabled) {
      goto switch_break;
    }
    {
    sprintf((char * __restrict  )((char *)(tmp)), (char const   * __restrict  )"%d",
            curbuf->b_fnum);
    set_internal_string_var((char_u *)"actual_curbuf", tmp);
    o_curbuf = curbuf;
    o_curwin = curwin;
    curwin = wp;
    curbuf = wp->w_buffer;
    str___1 = eval_to_string_safe(p___0, & t);
    }
    if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
      if ((int )*str___1 != 0) {
        t = str___1;
        if ((int )*t == 45) {
          t ++;
        }
        {
        while (1) {
          while_continue___9: /* CIL Label */ ;
          if (*t) {
            {
            tmp___19 = __ctype_b_loc();
            }
            if (! ((int const   )*(*tmp___19 + (int )*t) & 2048)) {
              goto while_break___9;
            }
          } else {
            goto while_break___9;
          }
          t ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        if ((int )*t == 0) {
          {
          tmp___20 = atoi((char const   *)((char *)str___1));
          num = (long )tmp___20;
          vim_free((void *)str___1);
          str___1 = (char_u *)((void *)0);
          itemisflag = 0;
          }
        }
      }
    }
    {
    curwin = o_curwin;
    curbuf = o_curbuf;
    strcpy((char * __restrict  )((char *)(tmp)), (char const   * __restrict  )((char *)"g:actual_curbuf"));
    do_unlet(tmp, 1);
    }
    goto switch_break;
    case_108: /* CIL Label */ 
    if ((wp->w_buffer)->b_ml.ml_flags & 1) {
      num = 0L;
    } else {
      num = wp->w_cursor.lnum;
    }
    goto switch_break;
    case_76: /* CIL Label */ 
    num = (wp->w_buffer)->b_ml.ml_line_count;
    goto switch_break;
    case_99: /* CIL Label */ 
    if (! (State & 16)) {
      if (empty_line) {
        num = 0L;
      } else {
        num = (long )((int )wp->w_cursor.col + 1);
      }
    } else {
      num = (long )((int )wp->w_cursor.col + 1);
    }
    goto switch_break;
    case_118: /* CIL Label */ 
    case_86: /* CIL Label */ 
    virtcol = wp->w_virtcol;
    if (wp->w_p_list) {
      if (lcs_tab1 == 0) {
        {
        wp->w_p_list = 0;
        getvcol(wp, & wp->w_cursor, (colnr_t *)((void *)0), & virtcol, (colnr_t *)((void *)0));
        wp->w_p_list = 1;
        }
      }
    }
    if ((int )opt == 86) {
      if (! (State & 16)) {
        if (empty_line) {
          tmp___21 = 0;
        } else {
          tmp___21 = (int )wp->w_cursor.col;
        }
      } else {
        tmp___21 = (int )wp->w_cursor.col;
      }
      if (virtcol == (colnr_t )tmp___21) {
        goto switch_break;
      }
    }
    num = (long )virtcol + 1L;
    goto switch_break;
    case_112: /* CIL Label */ 
    num = (long )((int )((wp->w_cursor.lnum * 100L) / (wp->w_buffer)->b_ml.ml_line_count));
    goto switch_break;
    case_80: /* CIL Label */ 
    {
    str___1 = tmp;
    get_rel_pos(wp, str___1);
    }
    goto switch_break;
    case_97: /* CIL Label */ 
    {
    tmp[0] = (char_u )0;
    tmp___22 = append_arg_number(wp, tmp, 0, (int )sizeof(tmp));
    }
    if (tmp___22) {
      str___1 = tmp;
    }
    goto switch_break;
    case_110: /* CIL Label */ 
    num = (long )(wp->w_buffer)->b_fnum;
    goto switch_break;
    case_79: /* CIL Label */ 
    base = (char_u )'X';
    case_111: /* CIL Label */ 
    {
    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, (long *)((void *)0));
    }
    if ((wp->w_buffer)->b_ml.ml_flags & 1) {
      num = 0L;
    } else { //Added block
    if (l < 0L) {
      num = 0L;
    } else {
      if (! (State & 16)) {
        if (empty_line) {
          tmp___23 = 0;
        } else {
          tmp___23 = (int )wp->w_cursor.col;
        }
      } else {
        tmp___23 = (int )wp->w_cursor.col;
      }
      num = (l + 1L) + (long )tmp___23;
    }
    }
    goto switch_break;
    case_66: /* CIL Label */ 
    base = (char_u )'X';
    case_98: /* CIL Label */ 
    if (State & 16) {
      num = 0L;
    } else { //Added block
    if (empty_line) {
      num = 0L;
    } else {
      num = (long )*(linecont + wp->w_cursor.col);
    }
    }
    if (num == 10L) {
      num = 0L;
    } else { //Added block
    if (num == 13L) {
      {
      tmp___24 = get_fileformat(wp->w_buffer);
      }
      if (tmp___24 == 2) {
        num = (long )'\n';
      }
    }
    }
    goto switch_break;
    case_114: /* CIL Label */ 
    case_82: /* CIL Label */ 
    itemisflag = 1;
    if ((wp->w_buffer)->b_p_ro) {
      if ((int )opt == 82) {
        tmp___25 = ",RO";
      } else {
        tmp___25 = " [RO]";
      }
      str___1 = (char_u *)tmp___25;
    }
    goto switch_break;
    case_104: /* CIL Label */ 
    case_72: /* CIL Label */ 
    itemisflag = 1;
    if ((wp->w_buffer)->b_help) {
      if ((int )opt == 72) {
        tmp___26 = ",HLP";
      } else {
        tmp___26 = " [help]";
      }
      str___1 = (char_u *)tmp___26;
    }
    goto switch_break;
    case_121: /* CIL Label */ 
    if ((int )*((wp->w_buffer)->b_p_ft) != 0) {
      {
      sprintf((char * __restrict  )((char *)(tmp)), (char const   * __restrict  )" [%s]",
              (wp->w_buffer)->b_p_ft);
      str___1 = tmp;
      }
    }
    goto switch_break;
    case_89: /* CIL Label */ 
    itemisflag = 1;
    if ((int )*((wp->w_buffer)->b_p_ft) != 0) {
      {
      sprintf((char * __restrict  )((char *)(tmp)), (char const   * __restrict  )",%s",
              (wp->w_buffer)->b_p_ft);
      t = tmp;
      }
      {
      while (1) {
        while_continue___10: /* CIL Label */ ;
        if (! ((int )*t != 0)) {
          goto while_break___10;
        }
        {
        tmp___27 = toupper((int )*t);
        *t = (char_u )tmp___27;
        t ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      str___1 = tmp;
    }
    goto switch_break;
    case_119: /* CIL Label */ 
    case_87: /* CIL Label */ 
    itemisflag = 1;
    if (wp->w_preview) {
      if ((int )opt == 87) {
        tmp___28 = ",PRV";
      } else {
        tmp___28 = " [Preview]";
      }
      str___1 = (char_u *)tmp___28;
    }
    goto switch_break;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
    itemisflag = 1;
    tmp___30 = buf_changed(wp->w_buffer);
    }
    if (tmp___30) {
      if ((int )opt == 77) {
        tmp___29 = ",+";
      } else {
        tmp___29 = " [+]";
      }
      str___1 = (char_u *)tmp___29;
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    item[curitem].start = p___0;
    item[curitem].type = (enum __anonenum_type_169___0 )0;
    if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
      if (*str___1) {
        t = str___1;
        if (itemisflag) {
          if (*(t + 0)) {
            if (*(t + 1)) {
              if (! prevchar_isitem) {
                if ((int )*t == 44) {
                  t ++;
                } else {
                  goto _L;
                }
              } else { //Added block
              _L: 
              if (prevchar_isflag) {
                if ((int )*t == 32) {
                  t ++;
                }
              }
              }
            }
          }
          prevchar_isflag = 1;
        }
        {
        tmp___31 = strlen((char const   *)((char *)t));
        l = (long )tmp___31;
        }
        if (l > 0L) {
          prevchar_isitem = 1;
        }
        if (l > (long )maxwid) {
          t += (l - (long )maxwid) + 1L;
          tmp___32 = p___0;
          p___0 ++;
          *tmp___32 = (char_u )'<';
        }
        if (minwid > 0) {
          {
          while (1) {
            while_continue___11: /* CIL Label */ ;
            if (! (l < (long )minwid)) {
              goto while_break___11;
            }
            tmp___33 = p___0;
            p___0 ++;
            *tmp___33 = (char_u )fillchar;
            l ++;
          }
          while_break___11: /* CIL Label */ ;
          }
          minwid = 0;
        } else {
          minwid *= -1;
        }
        {
        while (1) {
          while_continue___12: /* CIL Label */ ;
          if (! *t) {
            goto while_break___12;
          }
          tmp___34 = p___0;
          p___0 ++;
          tmp___35 = t;
          t ++;
          *tmp___34 = *tmp___35;
          if ((int )*(p___0 + -1) == 32) {
            *(p___0 + -1) = (char_u )fillchar;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        {
        while (1) {
          while_continue___13: /* CIL Label */ ;
          if (! (l < (long )minwid)) {
            goto while_break___13;
          }
          tmp___36 = p___0;
          p___0 ++;
          *tmp___36 = (char_u )fillchar;
          l ++;
        }
        while_break___13: /* CIL Label */ ;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (num >= 0L) {
      if ((int )base == 68) {
        tmp___38 = 10;
      } else {
        if ((int )base == 79) {
          tmp___37 = 8;
        } else {
          tmp___37 = 16;
        }
        tmp___38 = tmp___37;
      }
      nbase = tmp___38;
      prevchar_isitem = 1;
      t = nstr;
      if ((int )opt == 86) {
        tmp___39 = t;
        t ++;
        *tmp___39 = (char_u )'-';
        minwid --;
      }
      tmp___40 = t;
      t ++;
      *tmp___40 = (char_u )'%';
      if (zeropad) {
        tmp___41 = t;
        t ++;
        *tmp___41 = (char_u )'0';
      }
      tmp___42 = t;
      t ++;
      *tmp___42 = (char_u )'*';
      tmp___43 = t;
      t ++;
      if (nbase == 16) {
        *tmp___43 = base;
      } else {
        if (nbase == 8) {
          tmp___44 = 'o';
        } else {
          tmp___44 = 'd';
        }
        *tmp___43 = (char_u )tmp___44;
      }
      *t = (char_u )0;
      n = num;
      l = 1L;
      {
      while (1) {
        while_continue___14: /* CIL Label */ ;
        if (! (n >= (long )nbase)) {
          goto while_break___14;
        }
        l ++;
        n /= (long )nbase;
      }
      while_break___14: /* CIL Label */ ;
      }
      if ((int )opt == 86) {
        l ++;
      }
      if (l > (long )maxwid) {
        l += 2L;
        n = l - (long )maxwid;
        {
        while (1) {
          while_continue___15: /* CIL Label */ ;
          tmp___45 = l;
          l --;
          if (! (tmp___45 > (long )maxwid)) {
            goto while_break___15;
          }
          num /= (long )nbase;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
        tmp___46 = t;
        t ++;
        *tmp___46 = (char_u )'>';
        tmp___47 = t;
        t ++;
        *tmp___47 = (char_u )'%';
        *t = *(t + -3);
        t ++;
        *t = (char_u )0;
        sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)(nstr)),
                0, num, n);
        }
      } else {
        {
        sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)(nstr)),
                minwid, num);
        }
      }
      {
      tmp___48 = strlen((char const   *)((char *)p___0));
      p___0 += tmp___48;
      }
    } else {
      item[curitem].type = (enum __anonenum_type_169___0 )1;
    }
    }
    if ((int )opt == 123) {
      {
      vim_free((void *)str___1);
      }
    }
    if (num >= 0L) {
      prevchar_isflag = 0;
    } else { //Added block
    if (! itemisflag) {
      if (str___1) {
        if (*str___1) {
          prevchar_isflag = 0;
        }
      }
    }
    }
    curitem ++;
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *p___0 = (char_u )0;
  itemcnt = curitem;
  tmp___49 = strlen((char const   *)((char *)out));
  num = (long )tmp___49;
  }
  if (maxlen) {
    if (num > (long )maxlen) {
      l = 0L;
      {
      while (1) {
        while_continue___16: /* CIL Label */ ;
        if (! (l < (long )itemcnt)) {
          goto while_break___16;
        }
        if ((unsigned int )item[l].type == 5U) {
          goto while_break___16;
        }
        l ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      if (itemcnt == 0) {
        s = out;
      } else {
        if (l == (long )itemcnt) {
          l = 0L;
        } else {
          l = l;
        }
        s = item[l].start;
      }
      if ((int )(s - out) > maxlen) {
        s = (out + maxlen) - 1;
        l = 0L;
        {
        while (1) {
          while_continue___17: /* CIL Label */ ;
          if (! (l < (long )itemcnt)) {
            goto while_break___17;
          }
          if ((unsigned long )item[l].start > (unsigned long )s) {
            goto while_break___17;
          }
          l ++;
        }
        while_break___17: /* CIL Label */ ;
        }
        tmp___50 = s;
        s ++;
        *tmp___50 = (char_u )'>';
        *s = (char_u )0;
        itemcnt = (int )l;
      } else {
        {
        p___0 = (s + num) - maxlen;
        tmp___51 = strlen((char const   *)((char *)p___0));
        memmove((void *)((char *)s), (void const   *)((char *)p___0), tmp___51 + 1UL);
        *s = (char_u )'<';
        }
        {
        while (1) {
          while_continue___18: /* CIL Label */ ;
          if (! (l < (long )itemcnt)) {
            goto while_break___18;
          }
          item[l].start -= num - (long )maxlen;
          l ++;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      num = (long )maxlen;
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: 
  if (num < (long )maxlen) {
    l = 0L;
    {
    while (1) {
      while_continue___19: /* CIL Label */ ;
      if (! (l < (long )itemcnt)) {
        goto while_break___19;
      }
      if ((unsigned int )item[l].type == 3U) {
        goto while_break___19;
      }
      l ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    if (l < (long )itemcnt) {
      {
      p___0 = (item[l].start + maxlen) - num;
      tmp___52 = strlen((char const   *)((char *)item[l].start));
      memmove((void *)((char *)p___0), (void const   *)((char *)item[l].start), tmp___52 + 1UL);
      s = item[l].start;
      }
      {
      while (1) {
        while_continue___20: /* CIL Label */ ;
        if (! ((unsigned long )s < (unsigned long )p___0)) {
          goto while_break___20;
        }
        *s = (char_u )fillchar;
        s ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      l ++;
      {
      while (1) {
        while_continue___21: /* CIL Label */ ;
        if (! (l < (long )itemcnt)) {
          goto while_break___21;
        }
        item[l].start += (long )maxlen - num;
        l ++;
      }
      while_break___21: /* CIL Label */ ;
      }
      num = (long )maxlen;
    }
  }
  }
  if ((unsigned long )hl != (unsigned long )((void *)0)) {
    l = 0L;
    {
    while (1) {
      while_continue___22: /* CIL Label */ ;
      if (! (l < (long )itemcnt)) {
        goto while_break___22;
      }
      if ((unsigned int )item[l].type == 4U) {
        hl->start = item[l].start;
        hl->userhl = item[l].minwid;
        hl ++;
      }
      l ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    hl->start = (char_u *)((void *)0);
    hl->userhl = 0;
  }
  return ((int )num);
}
}
void screen_putchar(int c , int row , int col , int attr ) 
{ 
  char_u buf___3[2] ;

  {
  {
  buf___3[0] = (char_u )c;
  buf___3[1] = (char_u )'\000';
  screen_puts(buf___3, row, col, attr);
  }
  return;
}
}
void screen_puts(char_u *text , int row , int col , int attr ) 
{ 
  char_u *screenp ;

  {
  if ((unsigned long )NextScreen != (unsigned long )((void *)0)) {
    if ((long )row < Rows) {
      screenp = *(LinePointers + row) + col;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (*text) {
          if (! ((long )col < Columns)) {
            goto while_break;
          }
        } else {
          goto while_break;
        }
        if ((int )*screenp != (int )*text) {
          {
          *screenp = *text;
          *(screenp + Columns) = (char_u )attr;
          screen_char(screenp, row, col);
          }
        } else { //Added block
        if ((int )*(screenp + Columns) != attr) {
          {
          *screenp = *text;
          *(screenp + Columns) = (char_u )attr;
          screen_char(screenp, row, col);
          }
        } else { //Added block
        if (exmode_active) {
          {
          *screenp = *text;
          *(screenp + Columns) = (char_u )attr;
          screen_char(screenp, row, col);
          }
        }
        }
        }
        screenp ++;
        col ++;
        text ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
static void start_search_hl(void) 
{ 


  {
  if (p_hls) {
    if (! no_hlsearch) {
      {
      search_hl_prog = last_pat_prog();
      search_hl_attr = highlight_attr[6];
      search_hl_ic = reg_ic;
      }
    }
  }
  return;
}
}
static void end_search_hl(void) 
{ 


  {
  if ((unsigned long )search_hl_prog != (unsigned long )((void *)0)) {
    {
    vim_free((void *)search_hl_prog);
    search_hl_prog = (vim_regexp *)((void *)0);
    }
  }
  return;
}
}
void screen_start(void) 
{ 


  {
  screen_cur_col = 9999;
  screen_cur_row = screen_cur_col;
  return;
}
}
void screen_down(void) 
{ 


  {
  screen_cur_col = 0;
  if ((long )screen_cur_row < Rows - 1L) {
    screen_cur_row ++;
  }
  return;
}
}
static void screen_start_highlight(int attr ) 
{ 
  struct attr_entry *aep ;

  {
  aep = (struct attr_entry *)((void *)0);
  screen_attr = attr;
  if (full_screen) {
    if (attr > 31) {
      if ((int )*(term_strings[34]) != 0) {
        {
        aep = syn_cterm_attr2entry(attr);
        }
      } else {
        {
        aep = syn_term_attr2entry(attr);
        }
      }
      if ((unsigned long )aep == (unsigned long )((void *)0)) {
        attr = 0;
      } else {
        attr = (int )aep->ae_attr;
      }
    }
    if (attr & 2) {
      if ((unsigned long )term_strings[16] != (unsigned long )((void *)0)) {
        {
        out_str(term_strings[16]);
        }
      }
    }
    if (attr & 16) {
      if ((unsigned long )term_strings[18] != (unsigned long )((void *)0)) {
        {
        out_str(term_strings[18]);
        }
      }
    }
    if (attr & 8) {
      if ((unsigned long )term_strings[22] != (unsigned long )((void *)0)) {
        {
        out_str(term_strings[22]);
        }
      }
    }
    if (attr & 4) {
      if ((unsigned long )term_strings[19] != (unsigned long )((void *)0)) {
        {
        out_str(term_strings[19]);
        }
      }
    }
    if (attr & 1) {
      if ((unsigned long )term_strings[15] != (unsigned long )((void *)0)) {
        {
        out_str(term_strings[15]);
        }
      }
    }
    if ((unsigned long )aep != (unsigned long )((void *)0)) {
      if ((int )*(term_strings[34]) != 0) {
        if (aep->ae_u.cterm.fg_color) {
          {
          term_fg_color((int )aep->ae_u.cterm.fg_color - 1);
          }
        }
        if (aep->ae_u.cterm.bg_color) {
          {
          term_bg_color((int )aep->ae_u.cterm.bg_color - 1);
          }
        }
      } else { //Added block
      if ((unsigned long )aep->ae_u.term.start != (unsigned long )((void *)0)) {
        {
        out_str(aep->ae_u.term.start);
        }
      }
      }
    }
  }
  return;
}
}
void screen_stop_highlight(void) 
{ 
  int do_ME ;
  struct attr_entry *aep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  do_ME = 0;
  if (screen_attr) {
    if (screen_attr > 31) {
      if ((int )*(term_strings[34]) != 0) {
        {
        aep = syn_cterm_attr2entry(screen_attr);
        }
        if ((unsigned long )aep != (unsigned long )((void *)0)) {
          if (aep->ae_u.cterm.fg_color) {
            do_ME = 1;
          } else { //Added block
          if (aep->ae_u.cterm.bg_color) {
            do_ME = 1;
          }
          }
        }
      } else {
        {
        aep = syn_term_attr2entry(screen_attr);
        }
        if ((unsigned long )aep != (unsigned long )((void *)0)) {
          if ((unsigned long )aep->ae_u.term.stop != (unsigned long )((void *)0)) {
            {
            tmp = strcmp((char const   *)((char *)aep->ae_u.term.stop), (char const   *)((char *)term_strings[14]));
            }
            if (tmp == 0) {
              do_ME = 1;
            } else {
              {
              out_str(aep->ae_u.term.stop);
              }
            }
          }
        }
      }
      if ((unsigned long )aep == (unsigned long )((void *)0)) {
        screen_attr = 0;
      } else {
        screen_attr = (int )aep->ae_attr;
      }
    }
    if (screen_attr & 16) {
      {
      tmp___0 = strcmp((char const   *)((char *)term_strings[17]), (char const   *)((char *)term_strings[14]));
      }
      if (tmp___0 == 0) {
        do_ME = 1;
      } else {
        {
        out_str(term_strings[17]);
        }
      }
    }
    if (screen_attr & 8) {
      {
      tmp___1 = strcmp((char const   *)((char *)term_strings[21]), (char const   *)((char *)term_strings[14]));
      }
      if (tmp___1 == 0) {
        do_ME = 1;
      } else {
        {
        out_str(term_strings[21]);
        }
      }
    }
    if (screen_attr & 4) {
      {
      tmp___2 = strcmp((char const   *)((char *)term_strings[20]), (char const   *)((char *)term_strings[14]));
      }
      if (tmp___2 == 0) {
        do_ME = 1;
      } else {
        {
        out_str(term_strings[20]);
        }
      }
    }
    if (do_ME) {
      {
      out_str(term_strings[14]);
      }
    } else { //Added block
    if (screen_attr & 2) {
      {
      out_str(term_strings[14]);
      }
    } else { //Added block
    if (screen_attr & 1) {
      {
      out_str(term_strings[14]);
      }
    }
    }
    }
    if ((int )*(term_strings[34]) != 0) {
      if (cterm_normal_fg_color) {
        {
        term_fg_color(cterm_normal_fg_color - 1);
        }
      }
      if (cterm_normal_bg_color) {
        {
        term_bg_color(cterm_normal_bg_color - 1);
        }
      }
      if (cterm_normal_fg_bold) {
        {
        out_str(term_strings[16]);
        }
      }
    }
  }
  screen_attr = 0;
  return;
}
}
void reset_cterm_colors(void) 
{ 


  {
  if ((int )*(term_strings[34]) != 0) {
    if (cterm_normal_fg_color) {
      {
      out_str(term_strings[50]);
      }
    } else { //Added block
    if (cterm_normal_bg_color) {
      {
      out_str(term_strings[50]);
      }
    }
    }
    if (cterm_normal_fg_bold) {
      {
      out_str(term_strings[14]);
      }
    }
  }
  return;
}
}
static void screen_char(char_u *p___0 , int row , int col ) 
{ 


  {
  if ((long )col == Columns - 1L) {
    if ((long )row == Rows - 1L) {
      return;
    }
  }
  if (screen_attr != (int )*(p___0 + Columns)) {
    {
    screen_stop_highlight();
    }
  }
  {
  windgoto(row, col);
  }
  if (screen_attr != (int )*(p___0 + Columns)) {
    {
    screen_start_highlight((int )*(p___0 + Columns));
    }
  }
  {
  out_char((unsigned int )*p___0);
  screen_cur_col ++;
  }
  return;
}
}
void screen_fill(int start_row , int end_row , int start_col , int end_col , int c1 ,
                 int c2 , int attr ) 
{ 
  int row ;
  int col ;
  char_u *screenp ;
  char_u *attrp ;
  int did_delete ;
  int c ;
  int norm_term ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  if ((long )end_row > Rows) {
    end_row = (int )Rows;
  }
  if ((long )end_col > Columns) {
    end_col = (int )Columns;
  }
  if ((unsigned long )NextScreen == (unsigned long )((void *)0)) {
    return;
  } else { //Added block
  if (start_row >= end_row) {
    return;
  } else { //Added block
  if (start_col >= end_col) {
    return;
  }
  }
  }
  norm_term = (int )*(term_strings[34]) == 0;
  row = start_row;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (row < end_row)) {
      goto while_break;
    }
    did_delete = 0;
    if (c2 == 32) {
      if ((long )end_col == Columns) {
        if ((int )*(term_strings[1]) != 0) {
          if (attr == 0) {
            goto _L;
          } else { //Added block
          if (norm_term) {
            if (attr <= 31) {
              if ((attr & -7) == 0) {
                _L: 
                col = start_col;
                screenp = *(LinePointers + row) + start_col;
                if (c1 != 32) {
                  col ++;
                  screenp ++;
                }
                attrp = screenp + Columns;
                {
                while (1) {
                  while_continue___0: /* CIL Label */ ;
                  if (col < end_col) {
                    if ((int )*screenp == 32) {
                      if (! ((int )*attrp == 0)) {
                        goto while_break___0;
                      }
                    } else {
                      goto while_break___0;
                    }
                  } else {
                    goto while_break___0;
                  }
                  col ++;
                  screenp ++;
                  attrp ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                if (col < end_col) {
                  {
                  screen_stop_highlight();
                  term_windgoto(row, col);
                  out_str(term_strings[1]);
                  screen_start();
                  col = end_col - col;
                  }
                  {
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    tmp___1 = col;
                    col --;
                    if (! tmp___1) {
                      goto while_break___1;
                    }
                    tmp = attrp;
                    attrp ++;
                    *tmp = (char_u )0;
                    tmp___0 = screenp;
                    screenp ++;
                    *tmp___0 = (char_u )' ';
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                }
                did_delete = 1;
              }
            }
          }
          }
        }
      }
    }
    screenp = *(LinePointers + row) + start_col;
    c = c1;
    col = start_col;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (col < end_col)) {
        goto while_break___2;
      }
      if ((int )*screenp != c) {
        goto _L___0;
      } else { //Added block
      if ((int )*(screenp + Columns) != attr) {
        _L___0: 
        *screenp = (char_u )c;
        *(screenp + Columns) = (char_u )attr;
        if (! did_delete) {
          {
          screen_char(screenp, row, col);
          }
        } else { //Added block
        if (c != 32) {
          {
          screen_char(screenp, row, col);
          }
        }
        }
      }
      }
      screenp ++;
      if (col == start_col) {
        if (did_delete) {
          goto while_break___2;
        }
        c = c2;
      }
      col ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    if ((long )row == Rows - 1L) {
      redraw_cmdline = 1;
      if (c1 == 32) {
        if (c2 == 32) {
          clear_cmdline = 0;
        }
      }
    }
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void comp_botline(void) 
{ 
  int n ;
  linenr_t lnum ;
  int done___0 ;

  {
  {
  check_cursor_moved(curwin);
  }
  if (curwin->w_valid & 16) {
    lnum = curwin->w_cursor.lnum;
    done___0 = curwin->w_cline_row;
  } else {
    lnum = curwin->w_topline;
    done___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lnum <= (curwin->w_buffer)->b_ml.ml_line_count)) {
      goto while_break;
    }
    {
    n = plines(lnum);
    }
    if (lnum == curwin->w_cursor.lnum) {
      curwin->w_cline_row = done___0;
      curwin->w_cline_height = n;
      curwin->w_valid |= 24;
    }
    if (done___0 + n > curwin->w_height) {
      goto while_break;
    }
    done___0 += n;
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  curwin->w_botline = lnum;
  curwin->w_valid |= 96;
  if (done___0 == 0) {
    curwin->w_empty_rows = 0;
  } else {
    curwin->w_empty_rows = curwin->w_height - done___0;
  }
  return;
}
}
static int entered___2  =    0;
void screenalloc(int clear ) 
{ 
  int new_row ;
  int old_row ;
  WIN *wp ;
  int outofmem ;
  int len___0 ;
  char_u *new_NextScreen ;
  char_u **new_LinePointers ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  outofmem = 0;
  if ((unsigned long )NextScreen != (unsigned long )((void *)0)) {
    if (Rows == (long )screen_Rows) {
      if (Columns == (long )screen_Columns) {
        return;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if (Rows == 0L) {
    return;
  } else { //Added block
  if (Columns == 0L) {
    return;
  } else { //Added block
  if (! full_screen) {
    if ((unsigned long )NextScreen == (unsigned long )((void *)0)) {
      return;
    }
  }
  }
  }
  }
  if (entered___2) {
    return;
  }
  {
  entered___2 = 1;
  comp_col();
  wp = firstwin;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    {
    win_free_lsize(wp);
    wp = wp->w_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp = lalloc((long_u )(((Rows + 1L) * Columns) * 2L), 0);
  new_NextScreen = tmp;
  tmp___0 = lalloc(sizeof(char_u *) * (unsigned long )Rows, 0);
  new_LinePointers = (char_u **)tmp___0;
  wp = firstwin;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! wp) {
      goto while_break___0;
    }
    {
    tmp___1 = win_alloc_lsize(wp);
    }
    if (tmp___1 == 0) {
      outofmem = 1;
      goto while_break___0;
    }
    wp = wp->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((unsigned long )new_NextScreen == (unsigned long )((void *)0)) {
    {
    do_outofmem_msg();
    vim_free((void *)new_NextScreen);
    new_NextScreen = (char_u *)((void *)0);
    vim_free((void *)new_LinePointers);
    new_LinePointers = (char_u **)((void *)0);
    }
  } else { //Added block
  if ((unsigned long )new_LinePointers == (unsigned long )((void *)0)) {
    {
    do_outofmem_msg();
    vim_free((void *)new_NextScreen);
    new_NextScreen = (char_u *)((void *)0);
    vim_free((void *)new_LinePointers);
    new_LinePointers = (char_u **)((void *)0);
    }
  } else { //Added block
  if (outofmem) {
    {
    do_outofmem_msg();
    vim_free((void *)new_NextScreen);
    new_NextScreen = (char_u *)((void *)0);
    vim_free((void *)new_LinePointers);
    new_LinePointers = (char_u **)((void *)0);
    }
  } else {
    new_row = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! ((long )new_row < Rows)) {
        goto while_break___1;
      }
      *(new_LinePointers + new_row) = new_NextScreen + ((long )new_row * Columns) * 2L;
      if (! clear) {
        {
        lineclear(*(new_LinePointers + new_row));
        old_row = (int )((long )new_row + ((long )screen_Rows - Rows));
        }
        if (old_row >= 0) {
          if ((long )screen_Columns < Columns) {
            len___0 = screen_Columns;
          } else {
            len___0 = (int )Columns;
          }
          {
          memmove((void *)((char *)*(new_LinePointers + new_row)), (void const   *)((char *)*(LinePointers + old_row)),
                  (size_t )len___0);
          memmove((void *)((char *)(*(new_LinePointers + new_row) + Columns)), (void const   *)((char *)(*(LinePointers + old_row) + screen_Columns)),
                  (size_t )len___0);
          }
        }
      }
      new_row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    current_LinePointer = new_NextScreen + (Rows * Columns) * 2L;
  }
  }
  }
  {
  vim_free((void *)NextScreen);
  vim_free((void *)LinePointers);
  NextScreen = new_NextScreen;
  LinePointers = new_LinePointers;
  must_redraw = 50;
  }
  if (clear) {
    {
    screenclear2();
    }
  }
  screen_Rows = (int )Rows;
  screen_Columns = (int )Columns;
  entered___2 = 0;
  return;
}
}
void screenclear(void) 
{ 


  {
  {
  check_for_delay(0);
  screenalloc(0);
  screenclear2();
  }
  return;
}
}
static void screenclear2(void) 
{ 
  int i___0 ;

  {
  if (starting == 2) {
    return;
  } else { //Added block
  if ((unsigned long )NextScreen == (unsigned long )((void *)0)) {
    return;
  }
  }
  {
  screen_stop_highlight();
  out_str(term_strings[7]);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((long )i___0 < Rows)) {
      goto while_break;
    }
    {
    lineclear(*(LinePointers + i___0));
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  screen_cleared = 1;
  win_rest_invalid(firstwin);
  clear_cmdline = 0;
  redraw_cmdline = 1;
  }
  if (must_redraw == 50) {
    must_redraw = 40;
  }
  {
  compute_cmdrow();
  msg_row = cmdline_row;
  msg_col = 0;
  screen_start();
  msg_scrolled = 0;
  msg_didany = 0;
  msg_didout = 0;
  }
  return;
}
}
static void lineclear(char_u *p___0 ) 
{ 


  {
  {
  memset((void *)p___0, ' ', (size_t )Columns);
  memset((void *)(p___0 + Columns), 0, (size_t )Columns);
  }
  return;
}
}
void update_topline_redraw(void) 
{ 


  {
  {
  update_topline();
  }
  if (must_redraw) {
    {
    update_screen(must_redraw);
    }
  }
  return;
}
}
void update_topline(void) 
{ 
  long line_count ;
  int temp ;
  linenr_t old_topline___0 ;
  int check_botline ;
  int save_so ;
  int tmp ;
  char_u *tmp___0 ;

  {
  {
  check_botline = 0;
  save_so = (int )p_so;
  tmp = screen_valid(1);
  }
  if (! tmp) {
    return;
  }
  if (mouse_dragging) {
    p_so = (long )(mouse_dragging - 1);
  }
  old_topline___0 = curwin->w_topline;
  if (curbuf->b_ml.ml_line_count == 1L) {
    {
    tmp___0 = ml_get((linenr_t )1);
    }
    if ((int )*tmp___0 == 0) {
      if (curwin->w_topline != 1L) {
        {
        redraw_later(40);
        }
      }
      curwin->w_topline = (linenr_t )1;
      curwin->w_botline = (linenr_t )2;
      curwin->w_valid |= 96;
      curwin->w_scbind_pos = 1L;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if (curwin->w_cursor.lnum < curwin->w_topline + p_so) {
    if (curwin->w_topline > 1L) {
      temp = curwin->w_height / 2 - 1;
      if (temp < 2) {
        temp = 2;
      }
      if ((curwin->w_topline + p_so) - curwin->w_cursor.lnum >= (linenr_t )temp) {
        {
        scroll_cursor_halfway(0);
        }
      } else {
        {
        scroll_cursor_top((int )p_sj, 0);
        check_botline = 1;
        }
      }
    } else {
      check_botline = 1;
    }
  } else {
    check_botline = 1;
  }
  }
  if (check_botline) {
    if (! (curwin->w_valid & 64)) {
      {
      validate_botline();
      }
    }
    if (curwin->w_cursor.lnum >= curwin->w_botline - p_so) {
      if (curwin->w_botline <= curbuf->b_ml.ml_line_count) {
        line_count = ((curwin->w_cursor.lnum - curwin->w_botline) + 1L) + p_so;
        if (line_count <= (long )(curwin->w_height + 1)) {
          {
          scroll_cursor_bot((int )p_sj, 0);
          }
        } else {
          {
          scroll_cursor_halfway(0);
          }
        }
      }
    }
  }
  if (curwin->w_topline != old_topline___0) {
    if (curwin->w_skipcol) {
      {
      curwin->w_skipcol = (colnr_t )0;
      redraw_later(40);
      }
    } else {
      {
      redraw_later(10);
      }
    }
  }
  p_so = (long )save_so;
  return;
}
}
void update_curswant(void) 
{ 


  {
  if (curwin->w_set_curswant) {
    {
    validate_virtcol();
    curwin->w_curswant = curwin->w_virtcol;
    curwin->w_set_curswant = 0;
    }
  }
  return;
}
}
void windgoto(int row , int col ) 
{ 
  char_u *p___0 ;
  int i___0 ;
  int plan ;
  int cost ;
  int wouldbe_col ;
  int noinvcurs ;
  char_u *bs ;
  int goto_cost ;
  int attr ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )NextScreen == (unsigned long )((void *)0)) {
    return;
  }
  if (row < 0) {
    row = 0;
  }
  if (col != screen_cur_col) {
    goto _L___1;
  } else { //Added block
  if (row != screen_cur_row) {
    _L___1: 
    if (screen_attr) {
      if ((int )*(term_strings[23]) == 0) {
        noinvcurs = 5;
      } else {
        noinvcurs = 0;
      }
    } else {
      noinvcurs = 0;
    }
    goto_cost = 7 + noinvcurs;
    if (row >= screen_cur_row) {
      if ((long )screen_cur_col < Columns) {
        bs = (char_u *)((void *)0);
        attr = screen_attr;
        if (row == screen_cur_row) {
          if (col < screen_cur_col) {
            if (*(term_strings[41])) {
              bs = term_strings[41];
            } else {
              bs = term_strings[32];
            }
            if (*bs) {
              {
              tmp = strlen((char const   *)((char *)bs));
              cost = (int )((size_t )(screen_cur_col - col) * tmp);
              }
            } else {
              cost = 999;
            }
            if (col + 1 < cost) {
              plan = 2;
              wouldbe_col = 0;
              cost = 1;
            } else {
              plan = 1;
              wouldbe_col = col;
            }
            if (noinvcurs) {
              cost += noinvcurs;
              attr = 0;
            }
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if (row > screen_cur_row) {
          plan = 3;
          wouldbe_col = 0;
          cost = (row - screen_cur_row) * 2;
          if (noinvcurs) {
            cost += noinvcurs;
            attr = 0;
          }
        } else {
          plan = 4;
          wouldbe_col = screen_cur_col;
          cost = 0;
        }
        }
        i___0 = col - wouldbe_col;
        if (i___0 > 0) {
          cost += i___0;
        }
        if (cost < goto_cost) {
          if (i___0 > 0) {
            p___0 = (*(LinePointers + row) + wouldbe_col) + Columns;
            {
            while (1) {
              while_continue: /* CIL Label */ ;
              if (i___0) {
                tmp___0 = p___0;
                p___0 ++;
                if (! ((int )*tmp___0 == attr)) {
                  goto while_break;
                }
              } else {
                goto while_break;
              }
              i___0 --;
            }
            while_break: /* CIL Label */ ;
            }
            if (i___0) {
              p___0 --;
              if ((int )*p___0 == 0) {
                cost += noinvcurs;
                {
                while (1) {
                  while_continue___0: /* CIL Label */ ;
                  if (i___0) {
                    tmp___1 = p___0;
                    p___0 ++;
                    if (! ((int )*tmp___1 == 0)) {
                      goto while_break___0;
                    }
                  } else {
                    goto while_break___0;
                  }
                  i___0 --;
                }
                while_break___0: /* CIL Label */ ;
                }
              }
              if (i___0) {
                cost = 999;
              }
            }
          }
        }
        if (cost < goto_cost) {
          if (plan == 1) {
            if (noinvcurs) {
              {
              screen_stop_highlight();
              }
            }
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (! (screen_cur_col > col)) {
                goto while_break___1;
              }
              {
              out_str(bs);
              screen_cur_col --;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          } else { //Added block
          if (plan == 2) {
            if (noinvcurs) {
              {
              screen_stop_highlight();
              }
            }
            {
            out_char((unsigned int )'\r');
            screen_cur_col = 0;
            }
          } else { //Added block
          if (plan == 3) {
            if (noinvcurs) {
              {
              screen_stop_highlight();
              }
            }
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              if (! (screen_cur_row < row)) {
                goto while_break___2;
              }
              {
              out_char((unsigned int )'\n');
              screen_cur_row ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            screen_cur_col = 0;
          }
          }
          }
          i___0 = col - screen_cur_col;
          if (i___0 > 0) {
            if ((int )*(term_strings[42] + 0) != 0) {
              if ((int )*(term_strings[42] + 1) == 0) {
                {
                while (1) {
                  while_continue___3: /* CIL Label */ ;
                  tmp___2 = i___0;
                  i___0 --;
                  if (! tmp___2) {
                    goto while_break___3;
                  }
                  {
                  out_char((unsigned int )*(term_strings[42]));
                  }
                }
                while_break___3: /* CIL Label */ ;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              p___0 = *(LinePointers + row) + screen_cur_col;
              {
              while (1) {
                while_continue___4: /* CIL Label */ ;
                tmp___4 = i___0;
                i___0 --;
                if (! tmp___4) {
                  goto while_break___4;
                }
                if ((int )*(p___0 + Columns) != screen_attr) {
                  {
                  screen_stop_highlight();
                  }
                }
                {
                tmp___3 = p___0;
                p___0 ++;
                out_char((unsigned int )*tmp___3);
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            }
          }
        }
      } else {
        cost = 999;
      }
    } else {
      cost = 999;
    }
    if (cost >= goto_cost) {
      if (noinvcurs) {
        {
        screen_stop_highlight();
        }
      }
      if (row == screen_cur_row) {
        if (col > screen_cur_col) {
          if ((int )*(term_strings[26]) != 0) {
            {
            term_cursor_right(col - screen_cur_col);
            }
          } else {
            {
            term_windgoto(row, col);
            }
          }
        } else {
          {
          term_windgoto(row, col);
          }
        }
      } else {
        {
        term_windgoto(row, col);
        }
      }
    }
    screen_cur_row = row;
    screen_cur_col = col;
  }
  }
  return;
}
}
void setcursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = redrawing();
  }
  if (tmp) {
    {
    validate_cursor();
    windgoto(curwin->w_winpos + curwin->w_wrow, curwin->w_wcol);
    }
  }
  return;
}
}
void scroll_cursor_top(int min_scroll , int always ) 
{ 
  int scrolled ;
  int extra ;
  int used ;
  int i___0 ;
  int sline ;
  int old_topline___0 ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  scrolled = 0;
  extra = 0;
  old_topline___0 = (int )curwin->w_topline;
  validate_cheight();
  used = curwin->w_cline_height;
  sline = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((linenr_t )sline < curwin->w_cursor.lnum)) {
      goto while_break;
    }
    {
    i___0 = plines(curwin->w_cursor.lnum - (linenr_t )sline);
    used += i___0;
    extra += i___0;
    }
    if (mouse_dragging) {
      tmp___0 = (long )(mouse_dragging - 1);
    } else {
      tmp___0 = p_so;
    }
    if ((long )extra <= tmp___0) {
      if (curwin->w_cursor.lnum + (linenr_t )sline < curbuf->b_ml.ml_line_count) {
        {
        tmp = plines(curwin->w_cursor.lnum + (linenr_t )sline);
        used += tmp;
        }
      }
    }
    if (used > curwin->w_height) {
      goto while_break;
    }
    if (curwin->w_cursor.lnum - (linenr_t )sline < curwin->w_topline) {
      scrolled += i___0;
    }
    if (curwin->w_cursor.lnum - (linenr_t )(sline - 1) >= curwin->w_topline) {
      goto _L;
    } else { //Added block
    if (scrolled >= min_scroll) {
      _L: 
      if (mouse_dragging) {
        tmp___1 = (long )(mouse_dragging - 1);
      } else {
        tmp___1 = p_so;
      }
      if ((long )extra > tmp___1) {
        goto while_break;
      }
    }
    }
    sline ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (used > curwin->w_height) {
    {
    scroll_cursor_halfway(0);
    }
  } else {
    if (curwin->w_cursor.lnum - (linenr_t )(sline - 1) < curwin->w_topline) {
      curwin->w_topline = curwin->w_cursor.lnum - (linenr_t )(sline - 1);
    } else { //Added block
    if (always) {
      curwin->w_topline = curwin->w_cursor.lnum - (linenr_t )(sline - 1);
    }
    }
    if (curwin->w_topline > curwin->w_cursor.lnum) {
      curwin->w_topline = curwin->w_cursor.lnum;
    }
    if (curwin->w_topline != (linenr_t )old_topline___0) {
      curwin->w_valid &= -114;
    }
  }
  return;
}
}
void scroll_cursor_bot(int min_scroll , int set_topbot ) 
{ 
  int used ;
  int scrolled ;
  int extra ;
  int sline ;
  int i___0 ;
  linenr_t lnum ;
  linenr_t line_count ;
  linenr_t old_topline___0 ;
  linenr_t old_botline ;
  linenr_t old_valid ;
  int old_empty_rows ;
  linenr_t cln ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  scrolled = 0;
  extra = 0;
  old_topline___0 = curwin->w_topline;
  old_botline = curwin->w_botline;
  old_valid = (linenr_t )curwin->w_valid;
  old_empty_rows = curwin->w_empty_rows;
  cln = curwin->w_cursor.lnum;
  if (set_topbot) {
    used = 0;
    curwin->w_botline = cln + 1L;
    curwin->w_topline = curwin->w_botline;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (curwin->w_topline != 1L)) {
        goto while_break;
      }
      {
      i___0 = plines(curwin->w_topline - 1L);
      }
      if (used + i___0 > curwin->w_height) {
        goto while_break;
      }
      used += i___0;
      (curwin->w_topline) --;
    }
    while_break: /* CIL Label */ ;
    }
    curwin->w_empty_rows = curwin->w_height - used;
    curwin->w_valid |= 96;
    if (curwin->w_topline != old_topline___0) {
      curwin->w_valid &= -18;
    }
  } else {
    {
    validate_botline();
    }
  }
  {
  validate_cheight();
  used = curwin->w_cline_height;
  }
  if (cln >= curwin->w_botline) {
    scrolled = used;
    if (cln == curwin->w_botline) {
      scrolled -= curwin->w_empty_rows;
    }
  }
  sline = 1;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((linenr_t )sline < cln)) {
      goto while_break___0;
    }
    if (scrolled <= 0) {
      goto _L___1;
    } else { //Added block
    if (scrolled >= min_scroll) {
      _L___1: 
      if (mouse_dragging) {
        tmp = (long )(mouse_dragging - 1);
      } else {
        tmp = p_so;
      }
      if ((long )extra >= tmp) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (cln + (linenr_t )sline > curbuf->b_ml.ml_line_count) {
      _L: 
      if (cln - (linenr_t )sline < curwin->w_botline) {
        goto while_break___0;
      }
    }
    }
    }
    {
    i___0 = plines(cln - (linenr_t )sline);
    used += i___0;
    }
    if (used > curwin->w_height) {
      goto while_break___0;
    }
    if (cln - (linenr_t )sline >= curwin->w_botline) {
      scrolled += i___0;
      if (cln - (linenr_t )sline == curwin->w_botline) {
        scrolled -= curwin->w_empty_rows;
      }
    }
    if (cln + (linenr_t )sline <= curbuf->b_ml.ml_line_count) {
      {
      i___0 = plines(cln + (linenr_t )sline);
      used += i___0;
      }
      if (used > curwin->w_height) {
        goto while_break___0;
      }
      if (mouse_dragging) {
        tmp___0 = (long )(mouse_dragging - 1);
      } else {
        tmp___0 = p_so;
      }
      if ((long )extra < tmp___0) {
        goto _L___2;
      } else { //Added block
      if (scrolled < min_scroll) {
        _L___2: 
        extra += i___0;
        if (cln + (linenr_t )sline >= curwin->w_botline) {
          scrolled += i___0;
          if (cln + (linenr_t )sline == curwin->w_botline) {
            scrolled -= curwin->w_empty_rows;
          }
        }
      }
      }
    }
    sline ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (scrolled <= 0) {
    line_count = (linenr_t )0;
  } else { //Added block
  if (used > curwin->w_height) {
    line_count = (linenr_t )used;
  } else {
    i___0 = 0;
    lnum = curwin->w_topline;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (i___0 < scrolled) {
        if (! (lnum < curwin->w_botline)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      {
      tmp___1 = plines(lnum);
      i___0 += tmp___1;
      lnum ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    if (i___0 >= scrolled) {
      line_count = lnum - curwin->w_topline;
    } else {
      line_count = (linenr_t )9999;
    }
  }
  }
  if (line_count >= (linenr_t )curwin->w_height) {
    if (line_count > (linenr_t )min_scroll) {
      {
      scroll_cursor_halfway(0);
      }
    } else {
      {
      scrollup(line_count);
      }
    }
  } else {
    {
    scrollup(line_count);
    }
  }
  if (curwin->w_topline == old_topline___0) {
    if (set_topbot) {
      curwin->w_botline = old_botline;
      curwin->w_empty_rows = old_empty_rows;
      curwin->w_valid = (int )old_valid;
    }
  }
  return;
}
}
void scroll_cursor_halfway(int atend ) 
{ 
  int above ;
  linenr_t topline ;
  int below ;
  linenr_t botline ;
  int used ;
  int i___0 ;
  linenr_t cln ;

  {
  {
  above = 0;
  below = 0;
  cln = curwin->w_cursor.lnum;
  botline = cln;
  topline = botline;
  used = plines(cln);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (topline > 1L)) {
      goto while_break;
    }
    if (below <= above) {
      if (botline + 1L <= curbuf->b_ml.ml_line_count) {
        {
        i___0 = plines(botline + 1L);
        used += i___0;
        }
        if (used > curwin->w_height) {
          goto while_break;
        }
        below += i___0;
        botline ++;
      } else {
        below ++;
        if (atend) {
          used ++;
        }
      }
    }
    if (below > above) {
      {
      i___0 = plines(topline - 1L);
      used += i___0;
      }
      if (used > curwin->w_height) {
        goto while_break;
      }
      above += i___0;
      topline --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  curwin->w_topline = topline;
  curwin->w_valid &= -114;
  return;
}
}
void cursor_correct(void) 
{ 
  int above ;
  linenr_t topline ;
  int below ;
  linenr_t botline ;
  int above_wanted ;
  int below_wanted ;
  linenr_t cln ;
  int max_off ;
  int tmp ;
  int tmp___0 ;

  {
  above = 0;
  below = 0;
  above_wanted = (int )p_so;
  below_wanted = (int )p_so;
  if (mouse_dragging) {
    above_wanted = mouse_dragging - 1;
    below_wanted = mouse_dragging - 1;
  }
  if (curwin->w_topline == 1L) {
    above_wanted = 0;
    max_off = curwin->w_height / 2;
    if (below_wanted > max_off) {
      below_wanted = max_off;
    }
  }
  {
  validate_botline();
  }
  if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1L) {
    below_wanted = 0;
    max_off = (curwin->w_height - 1) / 2;
    if (above_wanted > max_off) {
      above_wanted = max_off;
    }
  }
  cln = curwin->w_cursor.lnum;
  if (cln >= curwin->w_topline + (linenr_t )above_wanted) {
    if (cln < curwin->w_botline - (linenr_t )below_wanted) {
      return;
    }
  }
  topline = curwin->w_topline;
  botline = curwin->w_botline - 1L;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (above < above_wanted) {
      goto _L;
    } else { //Added block
    if (below < below_wanted) {
      _L: 
      if (! (topline < botline)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    }
    if (below < below_wanted) {
      if (below <= above) {
        {
        tmp = plines(botline);
        below += tmp;
        botline --;
        }
      } else { //Added block
      if (above >= above_wanted) {
        {
        tmp = plines(botline);
        below += tmp;
        botline --;
        }
      }
      }
    }
    if (above < above_wanted) {
      if (above < below) {
        {
        tmp___0 = plines(topline);
        above += tmp___0;
        topline ++;
        }
      } else { //Added block
      if (below >= below_wanted) {
        {
        tmp___0 = plines(topline);
        above += tmp___0;
        topline ++;
        }
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (topline == botline) {
    curwin->w_cursor.lnum = topline;
  } else { //Added block
  if (botline == 0L) {
    curwin->w_cursor.lnum = topline;
  } else { //Added block
  if (topline > botline) {
    curwin->w_cursor.lnum = botline;
  } else {
    if (cln < topline) {
      if (curwin->w_topline > 1L) {
        curwin->w_cursor.lnum = topline;
        curwin->w_valid &= -28;
      }
    }
    if (cln > botline) {
      if (curwin->w_botline <= curbuf->b_ml.ml_line_count) {
        curwin->w_cursor.lnum = botline;
        curwin->w_valid &= -28;
      }
    }
  }
  }
  }
  return;
}
}
static void check_cursor_moved(WIN *wp ) 
{ 


  {
  if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum) {
    wp->w_valid &= -32;
    wp->w_valid_cursor = wp->w_cursor;
    wp->w_valid_leftcol = wp->w_leftcol;
  } else { //Added block
  if (wp->w_cursor.col != wp->w_valid_cursor.col) {
    wp->w_valid &= -8;
    wp->w_valid_cursor.col = wp->w_cursor.col;
    wp->w_valid_leftcol = wp->w_leftcol;
  } else { //Added block
  if (wp->w_leftcol != wp->w_valid_leftcol) {
    wp->w_valid &= -8;
    wp->w_valid_cursor.col = wp->w_cursor.col;
    wp->w_valid_leftcol = wp->w_leftcol;
  }
  }
  }
  return;
}
}
void changed_cline_bef_curs(void) 
{ 


  {
  curwin->w_valid &= -16;
  return;
}
}
void changed_line_abv_curs(void) 
{ 


  {
  curwin->w_valid &= -32;
  return;
}
}
void set_topline(WIN *wp , linenr_t lnum ) 
{ 


  {
  wp->w_botline += lnum - wp->w_topline;
  wp->w_topline = lnum;
  wp->w_valid &= -50;
  return;
}
}
void validate_botline(void) 
{ 


  {
  if (! (curwin->w_valid & 32)) {
    {
    comp_botline();
    }
  }
  return;
}
}
void invalidate_botline(void) 
{ 


  {
  curwin->w_valid &= -97;
  return;
}
}
void invalidate_botline_win(WIN *wp ) 
{ 


  {
  wp->w_valid &= -97;
  return;
}
}
void approximate_botline(void) 
{ 


  {
  curwin->w_valid &= -33;
  return;
}
}
int botline_approximated(void) 
{ 


  {
  return (curwin->w_valid & 64);
}
}
int cursor_valid(void) 
{ 


  {
  {
  check_cursor_moved(curwin);
  }
  return ((curwin->w_valid & 3) == 3);
}
}
void validate_cursor(void) 
{ 


  {
  {
  check_cursor_moved(curwin);
  }
  if ((curwin->w_valid & 3) != 3) {
    {
    curs_columns(1);
    }
  }
  return;
}
}
void validate_cline_row(void) 
{ 


  {
  {
  update_topline();
  check_cursor_moved(curwin);
  }
  if (! (curwin->w_valid & 16)) {
    {
    curs_rows(0);
    }
  }
  return;
}
}
int may_validate_crow(void) 
{ 


  {
  if (curwin->w_cursor.lnum < curwin->w_topline) {
    return (0);
  } else { //Added block
  if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
    return (0);
  } else { //Added block
  if (! (curwin->w_valid & 96)) {
    return (0);
  } else { //Added block
  if (curwin->w_cursor.lnum >= curwin->w_botline) {
    return (0);
  }
  }
  }
  }
  {
  check_cursor_moved(curwin);
  }
  if ((curwin->w_valid & 24) != 24) {
    {
    curs_rows(1);
    }
  }
  return (1);
}
}
static void curs_rows(int do_botline ) 
{ 
  linenr_t lnum ;
  int i___0 ;
  int lsize_invalid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = redrawing();
  }
  if (tmp) {
    if (curwin->w_lsize_valid == 0) {
      tmp___0 = 1;
    } else { //Added block
    if (*(curwin->w_lsize_lnum + 0) != curwin->w_topline) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    }
  } else {
    tmp___0 = 1;
  }
  lsize_invalid = tmp___0;
  i___0 = 0;
  curwin->w_cline_row = 0;
  lnum = curwin->w_topline;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (lnum < curwin->w_cursor.lnum)) {
      goto while_break;
    }
    if (lsize_invalid) {
      {
      tmp___1 = plines(lnum);
      curwin->w_cline_row += tmp___1;
      }
    } else {
      tmp___2 = i___0;
      i___0 ++;
      curwin->w_cline_row += (int )*(curwin->w_lsize + tmp___2);
    }
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  check_cursor_moved(curwin);
  }
  if (! (curwin->w_valid & 8)) {
    if (lsize_invalid) {
      {
      curwin->w_cline_height = plines(lnum);
      }
    } else { //Added block
    if (i___0 > curwin->w_lsize_valid) {
      curwin->w_cline_height = 0;
    } else {
      curwin->w_cline_height = (int )*(curwin->w_lsize + i___0);
    }
    }
  }
  curwin->w_valid |= 24;
  if (do_botline) {
    if (lsize_invalid) {
      {
      validate_botline();
      }
    }
  }
  return;
}
}
void validate_virtcol(void) 
{ 


  {
  {
  validate_virtcol_win(curwin);
  }
  return;
}
}
static void validate_virtcol_win(WIN *wp ) 
{ 


  {
  {
  check_cursor_moved(wp);
  }
  if (! (wp->w_valid & 4)) {
    {
    getvcol(wp, & wp->w_cursor, (colnr_t *)((void *)0), & wp->w_virtcol, (colnr_t *)((void *)0));
    wp->w_valid |= 4;
    }
  }
  return;
}
}
void validate_cheight(void) 
{ 


  {
  {
  check_cursor_moved(curwin);
  }
  if (! (curwin->w_valid & 8)) {
    {
    curwin->w_cline_height = plines(curwin->w_cursor.lnum);
    curwin->w_valid |= 8;
    }
  }
  return;
}
}
void validate_cursor_col(void) 
{ 


  {
  {
  validate_virtcol();
  }
  if (! (curwin->w_valid & 2)) {
    curwin->w_wcol = (int )curwin->w_virtcol;
    if (curwin->w_p_nu) {
      curwin->w_wcol += 8;
    }
    if (curwin->w_p_wrap) {
      if ((long )curwin->w_wcol >= Columns) {
        curwin->w_wcol = (int )((long )curwin->w_wcol % Columns);
      }
    }
    curwin->w_valid |= 2;
  }
  return;
}
}
void curs_columns(int scroll ) 
{ 
  int diff ;
  int extra ;
  int new_leftcol ;
  colnr_t startcol ;
  colnr_t endcol ;
  colnr_t prev_skipcol ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  {
  update_topline();
  }
  if (! (curwin->w_valid & 16)) {
    {
    curs_rows(0);
    }
  }
  {
  getvcol(curwin, & curwin->w_cursor, & startcol, & curwin->w_virtcol, & endcol);
  }
  if (startcol > dollar_vcol) {
    dollar_vcol = (colnr_t )0;
  }
  curwin->w_wcol = (int )curwin->w_virtcol;
  if (curwin->w_p_nu) {
    curwin->w_wcol += 8;
    endcol += 8U;
  }
  curwin->w_wrow = curwin->w_cline_row;
  if (curwin->w_p_wrap) {
    if ((long )curwin->w_wcol >= Columns) {
      extra = (int )((long )curwin->w_wcol / Columns);
      curwin->w_wcol = (int )((long )curwin->w_wcol - (long )extra * Columns);
      curwin->w_wrow += extra;
      if (*p_sbr) {
        {
        tmp = ml_get_cursor();
        }
        if ((int )*tmp == 0) {
          {
          tmp___0 = strlen((char const   *)((char *)p_sbr));
          }
          if (curwin->w_wcol == (int )tmp___0) {
            curwin->w_wcol = 0;
          }
        }
      }
    }
  } else { //Added block
  if (scroll) {
    extra = (int )startcol - (int )curwin->w_leftcol;
    if (extra < 0) {
      goto _L;
    } else {
      extra = ((int )endcol - (int )((long )curwin->w_leftcol + Columns)) + 1;
      if (extra > 0) {
        _L: 
        if (extra < 0) {
          diff = - extra;
        } else {
          diff = extra;
        }
        if (p_ss == 0L) {
          new_leftcol = (int )((long )curwin->w_wcol - Columns / 2L);
        } else { //Added block
        if ((long )diff >= Columns / 2L) {
          new_leftcol = (int )((long )curwin->w_wcol - Columns / 2L);
        } else {
          if ((long )diff < p_ss) {
            diff = (int )p_ss;
          }
          if (extra < 0) {
            new_leftcol = (int )(curwin->w_leftcol - (colnr_t )diff);
          } else {
            new_leftcol = (int )(curwin->w_leftcol + (colnr_t )diff);
          }
        }
        }
        if (new_leftcol < 0) {
          curwin->w_leftcol = (colnr_t )0;
        } else {
          curwin->w_leftcol = (colnr_t )new_leftcol;
        }
        {
        redraw_later(40);
        }
      }
    }
    curwin->w_wcol = (int )((colnr_t )curwin->w_wcol - curwin->w_leftcol);
  } else { //Added block
  if (curwin->w_wcol > (int )curwin->w_leftcol) {
    curwin->w_wcol = (int )((colnr_t )curwin->w_wcol - curwin->w_leftcol);
  } else {
    curwin->w_wcol = 0;
  }
  }
  }
  prev_skipcol = curwin->w_skipcol;
  if (curwin->w_wrow > curwin->w_height - 1) {
    goto _L___0;
  } else { //Added block
  if (prev_skipcol) {
    _L___0: 
    if (curwin->w_height) {
      if (curwin->w_cursor.lnum == curwin->w_topline) {
        if (curwin->w_skipcol > curwin->w_virtcol) {
          {
          extra = (int )((((long )(curwin->w_skipcol - curwin->w_virtcol) + Columns) - 1L) / Columns);
          win_ins_lines(curwin, 0, extra, 0, 0);
          curwin->w_skipcol = (colnr_t )((long )curwin->w_skipcol - (long )extra * Columns);
          }
        } else { //Added block
        if (curwin->w_wrow > curwin->w_height - 1) {
          endcol = (colnr_t )((long )((curwin->w_wrow - curwin->w_height) + 1) * Columns);
          if (endcol > curwin->w_skipcol) {
            {
            win_del_lines(curwin, 0, (int )((endcol - prev_skipcol) / (colnr_t )((int )Columns)),
                          0, 0);
            curwin->w_skipcol = endcol;
            }
          }
        }
        }
        curwin->w_wrow = (int )((long )curwin->w_wrow - (long )curwin->w_skipcol / Columns);
      } else {
        curwin->w_skipcol = (colnr_t )0;
      }
    } else {
      curwin->w_skipcol = (colnr_t )0;
    }
  } else {
    curwin->w_skipcol = (colnr_t )0;
  }
  }
  if (prev_skipcol != curwin->w_skipcol) {
    {
    redraw_later(40);
    }
  }
  curwin->w_valid |= 7;
  return;
}
}
void scrolldown(long line_count ) 
{ 
  long done___0 ;
  int wrow ;
  int moved ;
  int tmp ;
  long tmp___0 ;
  linenr_t tmp___1 ;
  int tmp___2 ;

  {
  {
  done___0 = 0L;
  moved = 0;
  validate_cursor();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___0 = line_count;
    line_count --;
    if (! tmp___0) {
      goto while_break;
    }
    if (curwin->w_topline == 1L) {
      goto while_break;
    }
    {
    (curwin->w_topline) --;
    tmp = plines(curwin->w_topline);
    done___0 += (long )tmp;
    (curwin->w_botline) --;
    curwin->w_valid &= -33;
    }
  }
  while_break: /* CIL Label */ ;
  }
  curwin->w_wrow = (int )((long )curwin->w_wrow + done___0);
  curwin->w_cline_row = (int )((long )curwin->w_cline_row + done___0);
  wrow = curwin->w_wrow;
  if (curwin->w_p_wrap) {
    {
    validate_virtcol();
    validate_cheight();
    wrow = (int )((long )wrow + ((long )(curwin->w_cline_height - 1) - (long )curwin->w_virtcol / Columns));
    }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (wrow >= curwin->w_height) {
      if (! (curwin->w_cursor.lnum > 1L)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    tmp___1 = curwin->w_cursor.lnum;
    (curwin->w_cursor.lnum) --;
    tmp___2 = plines(tmp___1);
    wrow -= tmp___2;
    curwin->w_valid &= -32;
    moved = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (moved) {
    {
    coladvance(curwin->w_curswant);
    }
  }
  return;
}
}
void scrollup(long line_count ) 
{ 


  {
  curwin->w_topline += line_count;
  curwin->w_botline += line_count;
  curwin->w_valid &= -50;
  if (curwin->w_topline > curbuf->b_ml.ml_line_count) {
    curwin->w_topline = curbuf->b_ml.ml_line_count;
  }
  if (curwin->w_cursor.lnum < curwin->w_topline) {
    {
    curwin->w_cursor.lnum = curwin->w_topline;
    curwin->w_valid &= -32;
    coladvance(curwin->w_curswant);
    }
  }
  return;
}
}
void scrolldown_clamp(void) 
{ 
  int end_row ;
  int tmp ;

  {
  if (curwin->w_topline == 1L) {
    return;
  }
  {
  validate_cursor();
  tmp = plines(curwin->w_topline - 1L);
  end_row = curwin->w_wrow + tmp;
  }
  if (curwin->w_p_wrap) {
    {
    validate_cheight();
    validate_virtcol();
    end_row = (int )((long )end_row + ((long )(curwin->w_cline_height - 1) - (long )curwin->w_virtcol / Columns));
    }
  }
  if ((long )end_row < (long )curwin->w_height - p_so) {
    (curwin->w_topline) --;
    (curwin->w_botline) --;
    curwin->w_valid &= -50;
  }
  return;
}
}
void scrollup_clamp(void) 
{ 
  int start_row ;
  int tmp ;

  {
  if (curwin->w_topline == curbuf->b_ml.ml_line_count) {
    return;
  }
  {
  validate_cursor();
  tmp = plines(curwin->w_topline);
  start_row = curwin->w_wrow - tmp;
  }
  if (curwin->w_p_wrap) {
    {
    validate_virtcol();
    start_row = (int )((long )start_row - (long )curwin->w_virtcol / Columns);
    }
  }
  if ((long )start_row >= p_so) {
    (curwin->w_topline) ++;
    (curwin->w_botline) ++;
    curwin->w_valid &= -50;
  }
  return;
}
}
int win_ins_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) 
{ 
  int did_delete ;
  int nextrow ;
  int lastrow ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (invalid) {
    wp->w_lsize_valid = 0;
  }
  {
  tmp = redrawing();
  }
  if (tmp) {
    if (line_count <= 0) {
      return (0);
    } else { //Added block
    if (wp->w_height < 5) {
      return (0);
    }
    }
  } else {
    return (0);
  }
  if (line_count > wp->w_height - row) {
    line_count = wp->w_height - row;
  }
  if (mayclear) {
    if (Rows - (long )line_count < 5L) {
      {
      screenclear();
      }
      return (0);
    }
  }
  if (row + line_count >= wp->w_height) {
    {
    screen_fill(wp->w_winpos + row, wp->w_winpos + wp->w_height, 0, (int )Columns,
                ' ', ' ', 0);
    }
    return (1);
  }
  clear_cmdline = 1;
  if (scroll_region) {
    {
    scroll_region_set(wp, row);
    retval = screen_ins_lines(wp->w_winpos + row, 0, line_count, wp->w_height - row);
    scroll_region_reset();
    }
    return (retval);
  }
  if (wp->w_next) {
    if (p_tf) {
      return (0);
    }
  }
  did_delete = 0;
  if (wp->w_next) {
    goto _L;
  } else { //Added block
  if (wp->w_status_height) {
    _L: 
    {
    tmp___0 = screen_del_lines(0, (wp->w_winpos + wp->w_height) - line_count, line_count,
                               (int )Rows, 0);
    }
    if (tmp___0 == 1) {
      did_delete = 1;
    } else { //Added block
    if (wp->w_next) {
      return (0);
    }
    }
  }
  }
  if (! did_delete) {
    wp->w_redr_status = 1;
    redraw_cmdline = 1;
    nextrow = (wp->w_winpos + wp->w_height) + wp->w_status_height;
    lastrow = nextrow + line_count;
    if ((long )lastrow > Rows) {
      lastrow = (int )Rows;
    }
    {
    screen_fill(nextrow - line_count, lastrow - line_count, 0, (int )Columns, ' ',
                ' ', 0);
    }
  }
  {
  tmp___1 = screen_ins_lines(0, wp->w_winpos + row, line_count, (int )Rows);
  }
  if (tmp___1 == 0) {
    if (did_delete) {
      {
      wp->w_redr_status = 1;
      win_rest_invalid(wp->w_next);
      }
    }
    return (0);
  }
  return (1);
}
}
int win_del_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) 
{ 
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (invalid) {
    wp->w_lsize_valid = 0;
  }
  {
  tmp = redrawing();
  }
  if (tmp) {
    if (line_count <= 0) {
      return (0);
    }
  } else {
    return (0);
  }
  if (line_count > wp->w_height - row) {
    line_count = wp->w_height - row;
  }
  if (mayclear) {
    if (Rows - (long )line_count < 5L) {
      {
      screenclear();
      }
      return (0);
    }
  }
  if (row + line_count >= wp->w_height) {
    {
    screen_fill(wp->w_winpos + row, wp->w_winpos + wp->w_height, 0, (int )Columns,
                ' ', ' ', 0);
    }
    return (1);
  }
  clear_cmdline = 1;
  if (scroll_region) {
    {
    scroll_region_set(wp, row);
    retval = screen_del_lines(wp->w_winpos + row, 0, line_count, wp->w_height - row,
                              0);
    scroll_region_reset();
    }
    return (retval);
  }
  if (wp->w_next) {
    if (p_tf) {
      return (0);
    }
  }
  {
  tmp___0 = screen_del_lines(0, wp->w_winpos + row, line_count, (int )Rows, 0);
  }
  if (tmp___0 == 0) {
    return (0);
  }
  if (wp->w_next) {
    goto _L;
  } else { //Added block
  if (wp->w_status_height) {
    goto _L;
  } else { //Added block
  if ((long )cmdline_row < Rows - 1L) {
    _L: 
    {
    tmp___1 = screen_ins_lines(0, (wp->w_winpos + wp->w_height) - line_count, line_count,
                               (int )Rows);
    }
    if (tmp___1 == 0) {
      {
      wp->w_redr_status = 1;
      win_rest_invalid(wp->w_next);
      }
    }
  } else {
    redraw_cmdline = 1;
  }
  }
  }
  return (1);
}
}
void win_rest_invalid(WIN *wp ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    wp->w_lsize_valid = 0;
    wp->w_redr_type = 40;
    wp->w_redr_status = 1;
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  redraw_cmdline = 1;
  return;
}
}
static int screen_ins_lines(int off___0 , int row , int line_count , int end ) 
{ 
  int i___0 ;
  int j ;
  char_u *temp ;
  int cursor_row ;
  int type ;
  int result_empty ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (tmp) {
    if (line_count <= 0) {
      return (0);
    } else { //Added block
    if ((long )line_count > p_ttyscroll) {
      return (0);
    }
    }
  } else {
    return (0);
  }
  result_empty = row + line_count >= end;
  if ((int )*(term_strings[8]) != 0) {
    if (result_empty) {
      type = 8;
    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: 
  if ((int )*(term_strings[3]) != 0) {
    if (line_count > 1) {
      type = 1;
    } else { //Added block
    if ((int )*(term_strings[2]) == 0) {
      type = 1;
    } else {
      goto _L___3;
    }
    }
  } else { //Added block
  _L___3: 
  if ((int )*(term_strings[5]) != 0) {
    if (result_empty) {
      if (line_count > 1) {
        type = 2;
      } else { //Added block
      if ((int )*(term_strings[1]) == 0) {
        type = 2;
      } else {
        goto _L___2;
      }
      }
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if ((int )*(term_strings[2]) != 0) {
    type = 3;
  } else { //Added block
  if ((int )*(term_strings[1]) != 0) {
    if (result_empty) {
      type = 4;
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((int )*(term_strings[4]) != 0) {
    if (result_empty) {
      type = 5;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(term_strings[25]) != 0) {
    if (row == 0) {
      if ((int )*(term_strings[9]) == 0) {
        type = 6;
      } else { //Added block
      if (*(term_strings[1])) {
        type = 6;
      } else {
        return (0);
      }
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  }
  }
  }
  }
  }
  }
  if (type == 8) {
    {
    tmp___0 = screen_del_lines(off___0, row, line_count, end, 0);
    }
    return (tmp___0);
  } else { //Added block
  if (type == 2) {
    {
    tmp___0 = screen_del_lines(off___0, row, line_count, end, 0);
    }
    return (tmp___0);
  } else { //Added block
  if (type == 4) {
    {
    tmp___0 = screen_del_lines(off___0, row, line_count, end, 0);
    }
    return (tmp___0);
  } else { //Added block
  if (type == 5) {
    {
    tmp___0 = screen_del_lines(off___0, row, line_count, end, 0);
    }
    return (tmp___0);
  }
  }
  }
  }
  if (*(term_strings[10])) {
    {
    screen_del_lines(off___0, end - line_count, line_count, end, 0);
    }
  }
  if ((int )*(term_strings[33]) != 0) {
    cursor_row = row;
  } else {
    cursor_row = row + off___0;
  }
  row += off___0;
  end += off___0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < line_count)) {
      goto while_break;
    }
    j = (end - 1) - i___0;
    temp = *(LinePointers + j);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      j -= line_count;
      if (! (j >= row)) {
        goto while_break___0;
      }
      *(LinePointers + (j + line_count)) = *(LinePointers + j);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    *(LinePointers + (j + line_count)) = temp;
    lineclear(temp);
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  screen_stop_highlight();
  windgoto(cursor_row, 0);
  }
  if (type == 1) {
    {
    term_append_lines(line_count);
    screen_start();
    }
  } else {
    i___0 = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i___0 < line_count)) {
        goto while_break___1;
      }
      if (type == 3) {
        if (i___0) {
          if (cursor_row != 0) {
            {
            windgoto(cursor_row, 0);
            }
          }
        }
        {
        out_str(term_strings[2]);
        }
      } else {
        {
        out_str(term_strings[25]);
        }
      }
      {
      screen_start();
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  if (type == 6) {
    if (*(term_strings[9])) {
      i___0 = 0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (i___0 < line_count)) {
          goto while_break___2;
        }
        {
        windgoto(off___0 + i___0, 0);
        out_str(term_strings[1]);
        screen_start();
        i___0 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  return (1);
}
}
int screen_del_lines(int off___0 , int row , int line_count , int end , int force ) 
{ 
  int j ;
  int i___0 ;
  char_u *temp ;
  int cursor_row ;
  int cursor_end ;
  int result_empty ;
  int can_delete ;
  int type ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (tmp) {
    if (line_count <= 0) {
      return (0);
    } else { //Added block
    if (! force) {
      if ((long )line_count > p_ttyscroll) {
        return (0);
      }
    }
    }
  } else {
    return (0);
  }
  result_empty = row + line_count >= end;
  if ((int )*(term_strings[10]) == 0) {
    tmp___0 = 1;
  } else { //Added block
  if (*(term_strings[1])) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  }
  can_delete = tmp___0;
  if ((int )*(term_strings[8]) != 0) {
    if (result_empty) {
      type = 8;
    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: 
  if (row == 0) {
    if (line_count == 1) {
      type = 7;
    } else { //Added block
    if ((int )*(term_strings[5]) == 0) {
      type = 7;
    } else {
      goto _L___3;
    }
    }
  } else { //Added block
  _L___3: 
  if ((int )*(term_strings[5]) != 0) {
    if (line_count > 1) {
      if (can_delete) {
        type = 2;
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: 
  if ((int )*(term_strings[1]) != 0) {
    if (result_empty) {
      type = 4;
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((int )*(term_strings[4]) != 0) {
    if (can_delete) {
      type = 5;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: 
  if ((int )*(term_strings[5]) != 0) {
    if (can_delete) {
      type = 2;
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  }
  }
  }
  }
  }
  if ((int )*(term_strings[33]) != 0) {
    cursor_row = row;
    cursor_end = end;
  } else {
    cursor_row = row + off___0;
    cursor_end = end + off___0;
  }
  row += off___0;
  end += off___0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < line_count)) {
      goto while_break;
    }
    j = row + i___0;
    temp = *(LinePointers + j);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      j += line_count;
      if (! (j <= end - 1)) {
        goto while_break___0;
      }
      *(LinePointers + (j - line_count)) = *(LinePointers + j);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    *(LinePointers + (j - line_count)) = temp;
    lineclear(temp);
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  screen_stop_highlight();
  }
  if (type == 8) {
    {
    windgoto(cursor_row, 0);
    out_str(term_strings[8]);
    screen_start();
    }
  } else { //Added block
  if (type == 2) {
    {
    windgoto(cursor_row, 0);
    term_delete_lines(line_count);
    screen_start();
    }
  } else { //Added block
  if (type == 7) {
    {
    windgoto(cursor_end - 1, 0);
    i___0 = line_count;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      i___0 --;
      if (! (i___0 >= 0)) {
        goto while_break___1;
      }
      {
      out_char((unsigned int )'\n');
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    i___0 = line_count;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      i___0 --;
      if (! (i___0 >= 0)) {
        goto while_break___2;
      }
      if (type == 5) {
        {
        windgoto(cursor_row, 0);
        out_str(term_strings[4]);
        }
      } else {
        {
        windgoto(cursor_row + i___0, 0);
        out_str(term_strings[1]);
        }
      }
      {
      screen_start();
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  }
  }
  if (*(term_strings[10])) {
    if (type == 5) {
      goto _L___5;
    } else { //Added block
    if (type == 2) {
      _L___5: 
      i___0 = line_count;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! (i___0 > 0)) {
          goto while_break___3;
        }
        {
        windgoto(cursor_end - i___0, 0);
        out_str(term_strings[1]);
        screen_start();
        i___0 --;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    }
  }
  return (1);
}
}
int showmode(void) 
{ 
  int need_clear ;
  int length ;
  int do_mode ;
  int attr ;
  int nwr_save ;
  int sub_attr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  length = 0;
  if (p_smd) {
    if (State & 16) {
      tmp = 1;
    } else { //Added block
    if (restart_edit) {
      tmp = 1;
    } else { //Added block
    if (VIsual_active) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
    }
  } else {
    tmp = 0;
  }
  do_mode = tmp;
  if (do_mode) {
    goto _L;
  } else { //Added block
  if (Recording) {
    _L: 
    {
    tmp___0 = redrawing();
    }
    if (tmp___0) {
      {
      tmp___1 = char_avail();
      }
      if (tmp___1) {
        if (! KeyTyped) {
          redraw_cmdline = 1;
          return (0);
        }
      }
    } else {
      redraw_cmdline = 1;
      return (0);
    }
    {
    nwr_save = need_wait_return;
    check_for_delay(0);
    need_clear = clear_cmdline;
    }
    if (clear_cmdline) {
      if ((long )cmdline_row < Rows - 1L) {
        {
        msg_clr_cmdline();
        }
      }
    }
    {
    msg_pos_mode();
    cursor_off();
    attr = highlight_attr[8];
    }
    if (do_mode) {
      {
      msg_puts_attr((char_u *)"--", attr);
      }
      if ((unsigned long )edit_submode != (unsigned long )((void *)0)) {
        {
        msg_puts_attr(edit_submode, attr);
        }
        if ((unsigned long )edit_submode_extra != (unsigned long )((void *)0)) {
          {
          msg_puts_attr((char_u *)" ", attr);
          }
          if ((int )edit_submode_highl < 18) {
            sub_attr = highlight_attr[(int )edit_submode_highl];
          } else {
            sub_attr = attr;
          }
          {
          msg_puts_attr(edit_submode_extra, sub_attr);
          }
        }
      } else {
        if (State == 16) {
          {
          msg_puts_attr((char_u *)" INSERT", attr);
          }
        } else { //Added block
        if (State == 528) {
          {
          msg_puts_attr((char_u *)" REPLACE", attr);
          }
        } else { //Added block
        if (State == 784) {
          {
          msg_puts_attr((char_u *)" VREPLACE", attr);
          }
        } else { //Added block
        if (restart_edit == 73) {
          {
          msg_puts_attr((char_u *)" (insert)", attr);
          }
        } else { //Added block
        if (restart_edit == 82) {
          {
          msg_puts_attr((char_u *)" (replace)", attr);
          }
        } else { //Added block
        if (restart_edit == 86) {
          {
          msg_puts_attr((char_u *)" (vreplace)", attr);
          }
        }
        }
        }
        }
        }
        }
        if (State & 16) {
          if (p_paste) {
            {
            msg_puts_attr((char_u *)" (paste)", attr);
            }
          }
        }
        if (VIsual_active) {
          if (VIsual_select) {
            {
            msg_puts_attr((char_u *)" SELECT", attr);
            }
          } else {
            {
            msg_puts_attr((char_u *)" VISUAL", attr);
            }
          }
          if (VIsual_mode == 22) {
            {
            msg_puts_attr((char_u *)" BLOCK", attr);
            }
          } else { //Added block
          if (VIsual_mode == 86) {
            {
            msg_puts_attr((char_u *)" LINE", attr);
            }
          }
          }
        }
      }
      {
      msg_puts_attr((char_u *)" --", attr);
      need_clear = 1;
      }
    }
    if (Recording) {
      {
      msg_puts_attr((char_u *)"recording", attr);
      need_clear = 1;
      }
    }
    if (need_clear) {
      {
      msg_clr_eos();
      }
    } else { //Added block
    if (clear_cmdline) {
      {
      msg_clr_eos();
      }
    }
    }
    msg_didout = 0;
    length = msg_col;
    msg_col = 0;
    need_wait_return = nwr_save;
  } else { //Added block
  if (clear_cmdline) {
    {
    msg_clr_cmdline();
    }
  }
  }
  }
  if (lastwin->w_status_height == 0) {
    {
    win_redr_ruler(lastwin, 1);
    }
  }
  redraw_cmdline = 0;
  clear_cmdline = 0;
  return (length);
}
}
static void msg_pos_mode(void) 
{ 


  {
  msg_col = 0;
  msg_row = (int )(Rows - 1L);
  return;
}
}
void unshowmode(int force ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = redrawing();
  }
  if (tmp) {
    if (! force) {
      {
      tmp___0 = char_avail();
      }
      if (tmp___0) {
        if (! KeyTyped) {
          redraw_cmdline = 1;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      {
      msg_pos_mode();
      }
      if (Recording) {
        {
        msg_puts_attr((char_u *)"recording", highlight_attr[8]);
        }
      }
      {
      msg_clr_eos();
      }
    }
  } else {
    redraw_cmdline = 1;
  }
  return;
}
}
static int highlight_status(int *attr , int is_curwin ) 
{ 


  {
  if (is_curwin) {
    *attr = highlight_attr[11];
  } else {
    *attr = highlight_attr[12];
  }
  if (*attr) {
    if (highlight_attr[11] != highlight_attr[12]) {
      return (' ');
    } else { //Added block
    if (! is_curwin) {
      return (' ');
    } else { //Added block
    if ((unsigned long )firstwin == (unsigned long )lastwin) {
      return (' ');
    }
    }
    }
  }
  if (is_curwin) {
    return ('^');
  }
  return ('=');
}
}
void showruler(int always ) 
{ 
  int tmp ;

  {
  if (! always) {
    {
    tmp = redrawing();
    }
    if (! tmp) {
      return;
    }
  }
  if (*p_stl) {
    if (curwin->w_status_height) {
      {
      win_redr_custom(curwin, 0);
      }
    } else {
      {
      win_redr_ruler(curwin, always);
      }
    }
  } else {
    {
    win_redr_ruler(curwin, always);
    }
  }
  if (p_icon) {
    goto _L;
  } else { //Added block
  if (p_title) {
    _L: 
    if (stl_syntax & 3) {
      {
      maketitle();
      }
    }
  }
  }
  return;
}
}
static void win_redr_ruler(WIN *wp , int always ) 
{ 
  char_u buffer[30] ;
  int row ;
  int fillchar ;
  int attr ;
  int empty_line ;
  colnr_t virtcol ;
  int i___0 ;
  int o ;
  char_u *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  empty_line = 0;
  if (! p_ru) {
    return;
  }
  if (wp->w_cursor.lnum > (wp->w_buffer)->b_ml.ml_line_count) {
    return;
  }
  if (*p_ruf) {
    {
    win_redr_custom(wp, 1);
    }
    return;
  }
  {
  tmp = ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, 0);
  }
  if ((int )*tmp == 0) {
    empty_line = 1;
  }
  {
  validate_virtcol_win(wp);
  }
  if (redraw_cmdline) {
    goto _L;
  } else { //Added block
  if (always) {
    goto _L;
  } else { //Added block
  if (wp->w_cursor.lnum != wp->w_ru_cursor.lnum) {
    goto _L;
  } else { //Added block
  if (wp->w_cursor.col != wp->w_ru_cursor.col) {
    goto _L;
  } else { //Added block
  if (wp->w_virtcol != wp->w_ru_virtcol) {
    goto _L;
  } else { //Added block
  if (wp->w_topline != wp->w_ru_topline) {
    goto _L;
  } else { //Added block
  if (empty_line != (int )wp->w_ru_empty) {
    _L: 
    {
    cursor_off();
    }
    if (wp->w_status_height) {
      {
      row = wp->w_winpos + wp->w_height;
      fillchar = highlight_status(& attr, (unsigned long )wp == (unsigned long )curwin);
      }
    } else {
      row = (int )(Rows - 1L);
      fillchar = ' ';
      attr = 0;
    }
    virtcol = wp->w_virtcol;
    if (wp->w_p_list) {
      if (lcs_tab1 == 0) {
        {
        wp->w_p_list = 0;
        getvcol(wp, & wp->w_cursor, (colnr_t *)((void *)0), & virtcol, (colnr_t *)((void *)0));
        wp->w_p_list = 1;
        }
      }
    }
    if ((wp->w_buffer)->b_ml.ml_flags & 1) {
      tmp___0 = 0L;
    } else {
      tmp___0 = wp->w_cursor.lnum;
    }
    {
    sprintf((char * __restrict  )((char *)(buffer)), (char const   * __restrict  )"%ld,",
            tmp___0);
    }
    if (! (State & 16)) {
      if (empty_line) {
        tmp___1 = 0;
      } else {
        tmp___1 = (int )wp->w_cursor.col + 1;
      }
    } else {
      tmp___1 = (int )wp->w_cursor.col + 1;
    }
    {
    tmp___2 = strlen((char const   *)((char *)(buffer)));
    col_print(buffer + tmp___2, tmp___1, (int )virtcol + 1);
    tmp___3 = strlen((char const   *)((char *)(buffer)));
    i___0 = (int )tmp___3;
    }
    if (wp->w_status_height) {
      o = 3;
    } else {
      o = 4;
    }
    if ((long )((ru_col + i___0) + o) < Columns) {
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((long )((ru_col + i___0) + o) < Columns)) {
          goto while_break;
        }
        tmp___4 = i___0;
        i___0 ++;
        buffer[tmp___4] = (char_u )fillchar;
      }
      while_break: /* CIL Label */ ;
      }
      {
      get_rel_pos(wp, buffer + i___0);
      }
    }
    {
    screen_puts(buffer, row, ru_col, attr);
    tmp___5 = strlen((char const   *)((char *)(buffer)));
    screen_fill(row, row + 1, ru_col + (int )tmp___5, (int )Columns, fillchar, fillchar,
                attr);
    wp->w_ru_cursor = wp->w_cursor;
    wp->w_ru_virtcol = wp->w_virtcol;
    wp->w_ru_empty = (char )empty_line;
    wp->w_ru_topline = wp->w_topline;
    }
  }
  }
  }
  }
  }
  }
  }
  return;
}
}
static void get_rel_pos(WIN *wp , char_u *str___1 ) 
{ 
  long above ;
  long below ;
  char const   *tmp ;

  {
  above = wp->w_topline - 1L;
  below = ((wp->w_buffer)->b_ml.ml_line_count - wp->w_botline) + 1L;
  if (below <= 0L) {
    if (above == 0L) {
      tmp = "All";
    } else {
      tmp = "Bot";
    }
    {
    strcpy((char * __restrict  )((char *)str___1), (char const   * __restrict  )((char *)tmp));
    }
  } else { //Added block
  if (above <= 0L) {
    {
    strcpy((char * __restrict  )((char *)str___1), (char const   * __restrict  )((char *)"Top"));
    }
  } else {
    {
    sprintf((char * __restrict  )((char *)str___1), (char const   * __restrict  )"%2d%%",
            (int )((above * 100L) / (above + below)));
    }
  }
  }
  return;
}
}
void check_for_delay(int check_msg_scroll ) 
{ 


  {
  if (emsg_on_display) {
    goto _L;
  } else { //Added block
  if (check_msg_scroll) {
    if (msg_scroll) {
      _L: 
      {
      out_flush();
      ui_delay(1000L, 1);
      emsg_on_display = 0;
      }
      if (check_msg_scroll) {
        msg_scroll = 0;
      }
    }
  }
  }
  return;
}
}
int screen_valid(int clear ) 
{ 


  {
  {
  screenalloc(clear);
  }
  return ((unsigned long )NextScreen != (unsigned long )((void *)0));
}
}
static int on_status_line  =    0;
static int prev_row___0  =    -1;
static int prev_col___0  =    -1;
int jump_to_mouse(int flags___0 , int *inclusive ) 
{ 
  WIN *wp ;
  WIN *old_curwin___0 ;
  FPOS old_cursor ;
  int count___2 ;
  int first___0 ;
  int row ;
  int col ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  row = mouse_row;
  col = mouse_col;
  mouse_past_bottom = 0;
  mouse_past_eol = 0;
  if (flags___0 & 4) {
    if (prev_row___0 == mouse_row) {
      if (prev_col___0 == mouse_col) {
        retnomove: 
        if (on_status_line) {
          return (3);
        }
        if (flags___0 & 16) {
          {
          end_visual_mode();
          update_curbuf(40);
          }
        }
        return (2);
      }
    }
  }
  prev_row___0 = mouse_row;
  prev_col___0 = mouse_col;
  if (flags___0 & 8) {
    goto retnomove;
  }
  old_curwin___0 = curwin;
  old_cursor = curwin->w_cursor;
  if (! (flags___0 & 1)) {
    if (row < 0) {
      return (1);
    } else { //Added block
    if (col < 0) {
      return (1);
    }
    }
    wp = firstwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! wp->w_next) {
        goto while_break;
      }
      if (row < (wp->w_next)->w_winpos) {
        goto while_break;
      }
      wp = wp->w_next;
    }
    while_break: /* CIL Label */ ;
    }
    row -= wp->w_winpos;
    if (row >= wp->w_height) {
      on_status_line = (row - wp->w_height) + 1;
    } else {
      on_status_line = 0;
    }
    if (VIsual_active) {
      if ((unsigned long )wp->w_buffer != (unsigned long )curwin->w_buffer) {
        {
        end_visual_mode();
        update_curbuf(40);
        }
      } else { //Added block
      if (! on_status_line) {
        if (flags___0 & 16) {
          {
          end_visual_mode();
          update_curbuf(40);
          }
        }
      }
      }
    }
    {
    win_enter(wp, 1);
    }
    if (on_status_line) {
      if ((unsigned long )curwin == (unsigned long )old_curwin___0) {
        return (3);
      } else {
        return (259);
      }
    }
    curwin->w_cursor.lnum = curwin->w_topline;
  } else { //Added block
  if (on_status_line) {
    {
    count___2 = (((row - curwin->w_winpos) - curwin->w_height) + 1) - on_status_line;
    win_drag_status_line(count___2);
    }
    return (3);
  } else {
    if (flags___0 & 16) {
      {
      end_visual_mode();
      update_curbuf(40);
      }
    }
    row -= curwin->w_winpos;
    if (row < 0) {
      count___2 = 0;
      first___0 = 1;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (curwin->w_topline > 1L)) {
          goto while_break___0;
        }
        {
        tmp = plines(curwin->w_topline - 1L);
        count___2 += tmp;
        }
        if (! first___0) {
          if (count___2 > - row) {
            goto while_break___0;
          }
        }
        first___0 = 0;
        (curwin->w_topline) --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      curwin->w_valid &= -114;
      redraw_later(10);
      row = 0;
      }
    } else { //Added block
    if (row >= curwin->w_height) {
      count___2 = 0;
      first___0 = 1;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! (curwin->w_topline < curbuf->b_ml.ml_line_count)) {
          goto while_break___1;
        }
        {
        tmp___0 = plines(curwin->w_topline);
        count___2 += tmp___0;
        }
        if (! first___0) {
          if (count___2 > (row - curwin->w_height) + 1) {
            goto while_break___1;
          }
        }
        first___0 = 0;
        (curwin->w_topline) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      redraw_later(10);
      curwin->w_valid &= -114;
      row = curwin->w_height - 1;
      }
    }
    }
    curwin->w_cursor.lnum = curwin->w_topline;
  }
  }
  if (curwin->w_p_wrap) {
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! row) {
        goto while_break___2;
      }
      {
      count___2 = plines(curwin->w_cursor.lnum);
      }
      if (count___2 > row) {
        col = (int )((long )col + (long )row * Columns);
        goto while_break___2;
      }
      if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {
        mouse_past_bottom = 1;
        goto while_break___2;
      }
      row -= count___2;
      (curwin->w_cursor.lnum) ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    curwin->w_cursor.lnum += (linenr_t )row;
    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
      mouse_past_bottom = 1;
    }
    col = (int )((colnr_t )col + curwin->w_leftcol);
  }
  if (curwin->w_p_nu) {
    col -= 8;
    if (col < 0) {
      col = 0;
    }
  }
  if (flags___0 & 2) {
    if (! VIsual_active) {
      {
      check_visual_highlight();
      VIsual = old_cursor;
      VIsual_active = 1;
      VIsual_reselect = 1;
      may_start_select('o');
      setmouse();
      }
      if (p_smd) {
        redraw_cmdline = 1;
      }
    }
  }
  {
  curwin->w_curswant = (colnr_t )col;
  curwin->w_set_curswant = 0;
  tmp___1 = coladvance((colnr_t )col);
  }
  if (tmp___1 == 0) {
    if ((unsigned long )inclusive != (unsigned long )((void *)0)) {
      *inclusive = 1;
    }
    mouse_past_eol = 1;
  } else { //Added block
  if ((unsigned long )inclusive != (unsigned long )((void *)0)) {
    *inclusive = 0;
  }
  }
  if ((unsigned long )curwin == (unsigned long )old_curwin___0) {
    if (curwin->w_cursor.lnum == old_cursor.lnum) {
      if (curwin->w_cursor.col == old_cursor.col) {
        return (2);
      }
    }
  }
  return (258);
}
}
int redrawing(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (! RedrawingDisabled) {
    if (p_lz) {
      {
      tmp = char_avail();
      }
      if (tmp) {
        if (! KeyTyped) {
          tmp___0 = 0;
        } else {
          tmp___0 = 1;
        }
      } else {
        tmp___0 = 1;
      }
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int messaging(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (p_lz) {
    {
    tmp = char_avail();
    }
    if (tmp) {
      if (! KeyTyped) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
int onepage(int dir , long count___2 ) 
{ 
  linenr_t lp ;
  long n ;
  int off___0 ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  retval = 1;
  if (curbuf->b_ml.ml_line_count == 1L) {
    {
    beep_flush();
    }
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (count___2 > 0L)) {
      goto while_break;
    }
    {
    validate_botline();
    }
    if (dir == 1) {
      if (curwin->w_topline >= curbuf->b_ml.ml_line_count - p_so) {
        if (curwin->w_botline > curbuf->b_ml.ml_line_count) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
      tmp___0 = tmp;
    } else {
      tmp___0 = curwin->w_topline == 1L;
    }
    if (tmp___0) {
      {
      beep_flush();
      retval = 0;
      }
      goto while_break;
    }
    if (dir == 1) {
      if (curwin->w_botline > curbuf->b_ml.ml_line_count) {
        curwin->w_topline = curbuf->b_ml.ml_line_count;
        curwin->w_valid &= -18;
      } else {
        {
        lp = curwin->w_botline;
        off___0 = get_scroll_overlap(lp, -1);
        curwin->w_topline = curwin->w_botline - (linenr_t )off___0;
        curwin->w_cursor.lnum = curwin->w_topline;
        curwin->w_valid &= -124;
        }
      }
    } else {
      {
      lp = curwin->w_topline - 1L;
      off___0 = get_scroll_overlap(lp, 1);
      lp += (linenr_t )off___0;
      }
      if (lp > curbuf->b_ml.ml_line_count) {
        lp = curbuf->b_ml.ml_line_count;
      }
      curwin->w_cursor.lnum = lp;
      n = 0L;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (n <= (long )curwin->w_height) {
          if (! (lp >= 1L)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        {
        tmp___1 = plines(lp);
        n += (long )tmp___1;
        lp --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      if (n <= (long )curwin->w_height) {
        curwin->w_topline = (linenr_t )1;
        curwin->w_valid &= -50;
      } else { //Added block
      if (lp >= curwin->w_topline - 2L) {
        {
        (curwin->w_topline) --;
        comp_botline();
        curwin->w_cursor.lnum = curwin->w_botline - 1L;
        curwin->w_valid &= -28;
        }
      } else {
        curwin->w_topline = lp + 2L;
        curwin->w_valid &= -50;
      }
      }
    }
    count___2 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
  cursor_correct();
  beginline(6);
  curwin->w_valid &= -8;
  }
  if (dir == 1) {
    if (curwin->w_cursor.lnum < curwin->w_topline + p_so) {
      {
      scroll_cursor_top(1, 0);
      }
    }
  }
  {
  update_screen(10);
  }
  return (retval);
}
}
static int get_scroll_overlap(linenr_t lnum , int dir ) 
{ 
  int h1 ;
  int h2 ;
  int h3 ;
  int h4 ;
  int min_height ;

  {
  {
  min_height = curwin->w_height - 2;
  h1 = plines_check(lnum);
  }
  if (h1 > min_height) {
    return (0);
  } else {
    {
    h2 = plines_check(lnum + (linenr_t )dir);
    }
    if (h2 + h1 > min_height) {
      return (0);
    } else {
      {
      h3 = plines_check(lnum + (linenr_t )(dir * 2));
      }
      if (h3 + h2 > min_height) {
        return (0);
      } else {
        {
        h4 = plines_check(lnum + (linenr_t )(dir * 3));
        }
        if ((h4 + h3) + h2 > min_height) {
          return (1);
        } else { //Added block
        if ((h3 + h2) + h1 > min_height) {
          return (1);
        } else {
          return (2);
        }
        }
      }
    }
  }
}
}
void halfpage(int flag , linenr_t Prenum ) 
{ 
  long scrolled ;
  int i___0 ;
  int n ;
  int room ;

  {
  scrolled = 0L;
  if (Prenum) {
    if (Prenum > (linenr_t )curwin->w_height) {
      curwin->w_p_scroll = (long )curwin->w_height;
    } else {
      curwin->w_p_scroll = Prenum;
    }
  }
  if (curwin->w_p_scroll <= (long )curwin->w_height) {
    n = (int )curwin->w_p_scroll;
  } else {
    n = curwin->w_height;
  }
  {
  validate_botline();
  room = curwin->w_empty_rows;
  }
  if (flag) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (n > 0) {
        if (! (curwin->w_botline <= curbuf->b_ml.ml_line_count)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      {
      i___0 = plines(curwin->w_topline);
      n -= i___0;
      }
      if (n < 0) {
        if (scrolled) {
          goto while_break;
        }
      }
      (curwin->w_topline) ++;
      curwin->w_valid &= -18;
      scrolled += (long )i___0;
      room += i___0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        i___0 = plines(curwin->w_botline);
        }
        if (i___0 > room) {
          goto while_break___0;
        }
        (curwin->w_botline) ++;
        room -= i___0;
        if (! (curwin->w_botline <= curbuf->b_ml.ml_line_count)) {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
        (curwin->w_cursor.lnum) ++;
        curwin->w_valid &= -15;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (n > 0) {
      curwin->w_cursor.lnum += (linenr_t )n;
      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
      }
    }
  } else {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (n > 0) {
        if (! (curwin->w_topline > 1L)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      {
      i___0 = plines(curwin->w_topline - 1L);
      n -= i___0;
      }
      if (n < 0) {
        if (scrolled) {
          goto while_break___1;
        }
      }
      scrolled += (long )i___0;
      (curwin->w_topline) --;
      curwin->w_valid &= -114;
      if (curwin->w_cursor.lnum > 1L) {
        (curwin->w_cursor.lnum) --;
        curwin->w_valid &= -15;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    if (n > 0) {
      if (curwin->w_cursor.lnum > (linenr_t )n) {
        curwin->w_cursor.lnum -= (linenr_t )n;
      } else {
        curwin->w_cursor.lnum = (linenr_t )1;
      }
    }
  }
  {
  cursor_correct();
  beginline(6);
  update_screen(10);
  }
  return;
}
}
static char *lines[16]  = 
  {      (char *)"VIM - Vi IMproved",      (char *)"",      (char *)"version ",      (char *)"by Bram Moolenaar et al.", 
        (char *)"",      (char *)"Vim is freely distributable",      (char *)"type  :help uganda<Enter>     if you like Vim ",      (char *)"", 
        (char *)"type  :q<Enter>               to exit         ",      (char *)"type  :help<Enter>  or  <F1>  for on-line help",      (char *)"type  :help version5<Enter>   for version info",      (char *)((void *)0), 
        (char *)"",      (char *)"Running in Vi compatible mode",      (char *)"type  :set nocp<Enter>        for Vim defaults",      (char *)"type  :help cp-default<Enter> for info on this"};
static void intro_message(void) 
{ 
  int i___0 ;
  int row ;
  int col ;
  char_u vers[20] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  row = ((int )Rows - (int )(sizeof(lines) / sizeof(char *))) / 2;
  if (! p_cp) {
    row += 2;
  }
  if (row > 2) {
    if (Columns >= 50L) {
      i___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < (int )(sizeof(lines) / sizeof(char *)))) {
          goto while_break;
        }
        if ((unsigned long )lines[i___0] == (unsigned long )((void *)0)) {
          if (! p_cp) {
            goto while_break;
          }
          goto __Cont;
        }
        {
        tmp = strlen((char const   *)lines[i___0]);
        col = (int )tmp;
        }
        if (i___0 == 2) {
          {
          strcpy((char * __restrict  )((char *)(vers)), (char const   * __restrict  )mediumVersion);
          tmp___3 = highest_patch();
          }
          if (tmp___3) {
            {
            tmp___2 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___2 + (int )*(mediumVersion + 3)) & 1024) {
              {
              tmp___0 = highest_patch();
              sprintf((char * __restrict  )((char *)(vers) + 4), (char const   * __restrict  )".%d%s",
                      tmp___0, mediumVersion + 4);
              }
            } else {
              {
              tmp___1 = highest_patch();
              sprintf((char * __restrict  )((char *)(vers) + 3), (char const   * __restrict  )".%d",
                      tmp___1);
              }
            }
          }
          {
          tmp___4 = strlen((char const   *)((char *)(vers)));
          col = (int )((size_t )col + tmp___4);
          }
        }
        col = (int )((Columns - (long )col) / 2L);
        if (col < 0) {
          col = 0;
        }
        {
        screen_puts((char_u *)lines[i___0], row, col, 0);
        }
        if (i___0 == 2) {
          {
          screen_puts(vers, row, col + 8, 0);
          }
        }
        row ++;
        __Cont: 
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
void do_intro(void) 
{ 


  {
  {
  screenclear();
  intro_message();
  wait_return(1);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-myjHm73r.i","-O0")
char_u *get_file_name_in_path(char_u *line , int col , int options___0 , long count___2 ) ;
static void save_re_pat(int idx , char_u *pat , int magic ) ;
static int inmacro(char_u *opt , char_u *s ) ;
static int check_linecomment(char_u *line ) ;
static int cls(void) ;
static int skip_chars(int cclass , int dir ) ;
static void back_in_line(void) ;
static void find_first_blank(FPOS *posp ) ;
static void findsent_forward(long count___2 , int at_start_sent ) ;
static void show_pat_in_path(char_u *line , int type , int did_show , int action ,
                             FILE *fp___0 , linenr_t *lnum , long count___2 ) ;
static void wvsp_one(FILE *fp___0 , int idx , char *s , int sc ) ;
static char_u *top_bot_msg  =    (char_u *)"search hit TOP, continuing at BOTTOM";
static char_u *bot_top_msg  =    (char_u *)"search hit BOTTOM, continuing at TOP";
static struct spat spats[2]  = {      {(char_u *)((void *)0), 1, 0, {'/', 0, 0, 0L}}, 
        {(char_u *)((void *)0), 1, 0, {'/', 0, 0, 0L}}};
static int last_idx  =    0;
static struct spat saved_spats[2]  ;
static int saved_last_idx  =    0;
static int saved_no_hlsearch  =    0;
static char_u *mr_pattern  =    (char_u *)((void *)0);
vim_regexp *search_regcomp(char_u *pat , int pat_save , int pat_use , int options___0 ) 
{ 
  int magic ;
  int i___0 ;
  vim_regexp *tmp ;

  {
  rc_did_emsg = 0;
  magic = p_magic;
  if ((unsigned long )pat == (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if ((int )*pat == 0) {
    _L: 
    if (pat_use == 2) {
      i___0 = last_idx;
    } else {
      i___0 = pat_use;
    }
    if ((unsigned long )spats[i___0].pat == (unsigned long )((void *)0)) {
      if (pat_use == 1) {
        {
        emsg(e_nopresub);
        }
      } else {
        {
        emsg(e_noprevre);
        }
      }
      rc_did_emsg = 1;
      return ((vim_regexp *)((void *)0));
    }
    pat = spats[i___0].pat;
    magic = spats[i___0].magic;
    no_smartcase = spats[i___0].no_scs;
  } else { //Added block
  if (options___0 & 32) {
    {
    add_to_history(1, pat, 1);
    }
  }
  }
  }
  mr_pattern = pat;
  if (! (options___0 & 1024)) {
    if (pat_save == 0) {
      {
      save_re_pat(0, pat, magic);
      }
    } else { //Added block
    if (pat_save == 2) {
      {
      save_re_pat(0, pat, magic);
      }
    }
    }
    if (pat_save == 1) {
      {
      save_re_pat(1, pat, magic);
      }
    } else { //Added block
    if (pat_save == 2) {
      {
      save_re_pat(1, pat, magic);
      }
    }
    }
  }
  {
  set_reg_ic(pat);
  tmp = vim_regcomp(pat, magic);
  }
  return (tmp);
}
}
char_u *get_search_pat(void) 
{ 


  {
  return (mr_pattern);
}
}
static void save_re_pat(int idx , char_u *pat , int magic ) 
{ 


  {
  if ((unsigned long )spats[idx].pat != (unsigned long )pat) {
    {
    vim_free((void *)spats[idx].pat);
    spats[idx].pat = vim_strsave(pat);
    spats[idx].magic = magic;
    spats[idx].no_scs = no_smartcase;
    last_idx = idx;
    }
    if (p_hls) {
      {
      redraw_all_later(40);
      }
    }
    no_hlsearch = 0;
  }
  return;
}
}
static int save_level___0  =    0;
void save_search_patterns(void) 
{ 
  int tmp ;

  {
  tmp = save_level___0;
  save_level___0 ++;
  if (tmp == 0) {
    saved_spats[0] = spats[0];
    if ((unsigned long )spats[0].pat != (unsigned long )((void *)0)) {
      {
      saved_spats[0].pat = vim_strsave(spats[0].pat);
      }
    }
    saved_spats[1] = spats[1];
    if ((unsigned long )spats[1].pat != (unsigned long )((void *)0)) {
      {
      saved_spats[1].pat = vim_strsave(spats[1].pat);
      }
    }
    saved_last_idx = last_idx;
    saved_no_hlsearch = no_hlsearch;
  }
  return;
}
}
void restore_search_patterns(void) 
{ 


  {
  save_level___0 --;
  if (save_level___0 == 0) {
    {
    vim_free((void *)spats[0].pat);
    spats[0] = saved_spats[0];
    vim_free((void *)spats[1].pat);
    spats[1] = saved_spats[1];
    last_idx = saved_last_idx;
    no_hlsearch = saved_no_hlsearch;
    }
  }
  return;
}
}
void set_reg_ic(char_u *pat ) 
{ 
  char_u *p___0 ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;

  {
  reg_ic = p_ic;
  if (reg_ic) {
    if (! no_smartcase) {
      if (p_scs) {
        if (ctrl_x_mode) {
          if (! curbuf->b_p_inf) {
            goto _L;
          }
        } else {
          _L: 
          p___0 = pat;
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (! *p___0) {
              goto while_break;
            }
            {
            tmp = __ctype_b_loc();
            tmp___0 = p___0;
            p___0 ++;
            }
            if ((int const   )*(*tmp + (int )*tmp___0) & 256) {
              reg_ic = 0;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  no_smartcase = 0;
  return;
}
}
char_u *last_search_pat(void) 
{ 


  {
  return (spats[last_idx].pat);
}
}
void set_last_search_pat(char_u *s , int idx , int magic , int setlast ) 
{ 


  {
  {
  vim_free((void *)spats[idx].pat);
  spats[idx].pat = vim_strsave(s);
  spats[idx].magic = magic;
  spats[idx].no_scs = 0;
  spats[idx].off.dir = '/';
  spats[idx].off.line = 0;
  spats[idx].off.end = 0;
  spats[idx].off.off = 0L;
  }
  if (setlast) {
    last_idx = idx;
  }
  if (save_level___0) {
    {
    vim_free((void *)saved_spats[idx].pat);
    saved_spats[idx] = spats[0];
    }
    if ((unsigned long )spats[idx].pat != (unsigned long )((void *)0)) {
      {
      saved_spats[idx].pat = vim_strsave(spats[idx].pat);
      }
    }
    saved_last_idx = last_idx;
  }
  if (p_hls) {
    if (idx == last_idx) {
      if (! no_hlsearch) {
        {
        redraw_all_later(40);
        }
      }
    }
  }
  return;
}
}
vim_regexp *last_pat_prog(void) 
{ 
  vim_regexp *prog ;

  {
  if ((unsigned long )spats[last_idx].pat == (unsigned long )((void *)0)) {
    return ((vim_regexp *)((void *)0));
  }
  {
  emsg_off ++;
  prog = search_regcomp((char_u *)"", 0, last_idx, 1024);
  emsg_off --;
  }
  return (prog);
}
}
int searchit(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *str___1 , long count___2 ,
             int options___0 , int pat_use ) 
{ 
  int found ;
  linenr_t lnum ;
  vim_regexp *prog ;
  char_u *ptr ;
  char_u *match ;
  char_u *matchend ;
  int loop ;
  FPOS start_pos ;
  int at_first_line ;
  int extra_col ;
  int match_ok ;
  char_u *p___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
  match = (char_u *)((void *)0);
  matchend = (char_u *)((void *)0);
  prog = search_regcomp(str___1, 0, pat_use, options___0 & 1056);
  }
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    if (options___0 & 12) {
      if (! rc_did_emsg) {
        {
        emsg2((char_u *)"Invalid search string: %s", mr_pattern);
        }
      }
    }
    return (0);
  }
  if (options___0 & 256) {
    extra_col = 0;
  } else {
    extra_col = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    start_pos = *pos___0;
    found = 0;
    at_first_line = 1;
    if (pos___0->lnum == 0L) {
      pos___0->lnum = (linenr_t )1;
      pos___0->col = (colnr_t )0;
      at_first_line = 0;
    }
    if (dir == -1) {
      if (start_pos.col == 0U) {
        lnum = pos___0->lnum - 1L;
        at_first_line = 0;
      } else {
        lnum = pos___0->lnum;
      }
    } else {
      lnum = pos___0->lnum;
    }
    loop = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (loop <= 1)) {
        goto while_break___0;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (lnum > 0L) {
          if (! (lnum <= buf___3->b_ml.ml_line_count)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        {
        ptr = ml_get_buf(buf___3, lnum, 0);
        tmp___5 = vim_regexec(prog, ptr, 1);
        }
        if (tmp___5) {
          match = prog->startp[0];
          matchend = prog->endp[0];
          if (dir == 1) {
            if (at_first_line) {
              match_ok = 1;
              {
              while (1) {
                while_continue___2: /* CIL Label */ ;
                if (options___0 & 64) {
                  tmp___1 = (int )(matchend - ptr) - 1 < (int )start_pos.col + extra_col;
                } else {
                  tmp___1 = (int )(match - ptr) - ((int )*match == 0) < (int )start_pos.col + extra_col;
                }
                if (! tmp___1) {
                  goto while_break___2;
                }
                {
                tmp = vim_strchr(p_cpo, 'c');
                }
                if ((unsigned long )tmp != (unsigned long )((void *)0)) {
                  p___0 = matchend;
                  if ((unsigned long )match == (unsigned long )p___0) {
                    if ((int )*p___0 != 0) {
                      p___0 ++;
                    }
                  }
                } else {
                  p___0 = match;
                  if ((int )*p___0 != 0) {
                    p___0 ++;
                  }
                }
                if ((int )*p___0 != 0) {
                  {
                  tmp___0 = vim_regexec(prog, p___0, 0);
                  }
                  if (tmp___0) {
                    match = prog->startp[0];
                    matchend = prog->endp[0];
                  } else {
                    match_ok = 0;
                    goto while_break___2;
                  }
                } else {
                  match_ok = 0;
                  goto while_break___2;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
              if (! match_ok) {
                goto __Cont;
              }
            }
          }
          if (dir == -1) {
            match_ok = 0;
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              if (! at_first_line) {
                match_ok = 1;
                match = prog->startp[0];
                matchend = prog->endp[0];
              } else {
                if (options___0 & 64) {
                  tmp___2 = ((prog->endp[0] - ptr) - 1L) + (long )extra_col <= (long )((int )start_pos.col);
                } else {
                  tmp___2 = (prog->startp[0] - ptr) + (long )extra_col <= (long )((int )start_pos.col);
                }
                if (tmp___2) {
                  match_ok = 1;
                  match = prog->startp[0];
                  matchend = prog->endp[0];
                } else {
                  goto while_break___3;
                }
              }
              {
              tmp___3 = vim_strchr(p_cpo, 'c');
              }
              if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
                p___0 = matchend;
                if ((unsigned long )p___0 == (unsigned long )match) {
                  if ((int )*p___0 != 0) {
                    p___0 ++;
                  }
                }
              } else {
                p___0 = match;
                if ((int )*p___0 != 0) {
                  p___0 ++;
                }
              }
              if ((int )*p___0 == 0) {
                goto while_break___3;
              } else {
                {
                tmp___4 = vim_regexec(prog, p___0, 0);
                }
                if (! tmp___4) {
                  goto while_break___3;
                }
              }
            }
            while_break___3: /* CIL Label */ ;
            }
            if (! match_ok) {
              goto __Cont;
            }
          }
          pos___0->lnum = lnum;
          if (options___0 & 64) {
            if (! (options___0 & 128)) {
              pos___0->col = (colnr_t )((int )((matchend - ptr) - 1L));
            } else {
              pos___0->col = (colnr_t )((int )(match - ptr));
            }
          } else {
            pos___0->col = (colnr_t )((int )(match - ptr));
          }
          found = 1;
          goto while_break___1;
        }
        {
        line_breakcheck();
        }
        if (got_int) {
          goto while_break___1;
        }
        if (loop) {
          if (lnum == start_pos.lnum) {
            goto while_break___1;
          }
        }
        __Cont: 
        lnum += (linenr_t )dir;
        at_first_line = 0;
      }
      while_break___1: /* CIL Label */ ;
      }
      at_first_line = 0;
      if (! p_ws) {
        goto while_break___0;
      } else { //Added block
      if (got_int) {
        goto while_break___0;
      } else { //Added block
      if (found) {
        goto while_break___0;
      }
      }
      }
      if (dir == -1) {
        {
        lnum = buf___3->b_ml.ml_line_count;
        tmp___6 = shortmess('s');
        }
        if (! tmp___6) {
          if (options___0 & 12) {
            {
            give_warning(top_bot_msg, 1);
            }
          }
        }
      } else {
        {
        lnum = (linenr_t )1;
        tmp___7 = shortmess('s');
        }
        if (! tmp___7) {
          if (options___0 & 12) {
            {
            give_warning(bot_top_msg, 1);
            }
          }
        }
      }
      loop ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (got_int) {
      goto while_break;
    }
    count___2 --;
    if (count___2 > 0L) {
      if (! found) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)prog);
  }
  if (! found) {
    if (got_int) {
      {
      emsg(e_interr);
      }
    } else { //Added block
    if ((options___0 & 12) == 12) {
      if (p_ws) {
        {
        emsg2(e_patnotf2, mr_pattern);
        }
      } else { //Added block
      if (lnum == 0L) {
        {
        emsg2((char_u *)"search hit TOP without match for: %s", mr_pattern);
        }
      } else {
        {
        emsg2((char_u *)"search hit BOTTOM without match for: %s", mr_pattern);
        }
      }
      }
    }
    }
    return (0);
  }
  search_match_len = (int )(matchend - match);
  return (1);
}
}
int do_search(OPARG *oap , int dirc , char_u *str___1 , long count___2 , int options___0 ) 
{ 
  FPOS pos___0 ;
  char_u *searchstr ;
  struct soffset old_off ;
  int retval ;
  char_u *p___0 ;
  long c ;
  char_u *dircp ;
  char_u *tmp ;
  char_u *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char_u *msgbuf ;
  char_u *trunc ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  if (spats[0].off.line) {
    {
    tmp = vim_strchr(p_cpo, 'o');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      spats[0].off.line = 0;
      spats[0].off.off = 0L;
    }
  }
  old_off = spats[0].off;
  pos___0 = curwin->w_cursor;
  if (dirc == 0) {
    dirc = spats[0].off.dir;
  } else {
    spats[0].off.dir = dirc;
  }
  if (options___0 & 1) {
    if (dirc == 47) {
      dirc = '?';
    } else {
      dirc = '/';
    }
  }
  if (no_hlsearch) {
    if (! (options___0 & 1024)) {
      {
      redraw_all_later(40);
      no_hlsearch = 0;
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    searchstr = str___1;
    dircp = (char_u *)((void *)0);
    if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
      goto _L;
    } else { //Added block
    if ((int )*str___1 == 0) {
      goto _L;
    } else { //Added block
    if ((int )*str___1 == dirc) {
      _L: 
      if ((unsigned long )spats[0].pat == (unsigned long )((void *)0)) {
        {
        emsg(e_noprevre);
        retval = 0;
        }
        goto end_do_search;
      }
      searchstr = (char_u *)"";
    }
    }
    }
    if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
      if ((int )*str___1 != 0) {
        {
        p___0 = skip_regexp(str___1, dirc, p_magic);
        }
        if ((int )*p___0 == dirc) {
          dircp = p___0;
          tmp___0 = p___0;
          p___0 ++;
          *tmp___0 = (char_u )'\000';
        }
        spats[0].off.line = 0;
        spats[0].off.end = 0;
        spats[0].off.off = 0L;
        if ((int )*p___0 == 43) {
          spats[0].off.line = 1;
        } else { //Added block
        if ((int )*p___0 == 45) {
          spats[0].off.line = 1;
        } else {
          {
          tmp___1 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___1 + (int )*p___0) & 2048) {
            spats[0].off.line = 1;
          } else { //Added block
          if (options___0 & 16) {
            if ((int )*p___0 == 101) {
              goto _L___0;
            } else { //Added block
            if ((int )*p___0 == 115) {
              goto _L___0;
            } else { //Added block
            if ((int )*p___0 == 98) {
              _L___0: 
              if ((int )*p___0 == 101) {
                spats[0].off.end = 64;
              }
              p___0 ++;
            }
            }
            }
          }
          }
        }
        }
        {
        tmp___5 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___5 + (int )*p___0) & 2048) {
          goto _L___1;
        } else { //Added block
        if ((int )*p___0 == 43) {
          goto _L___1;
        } else { //Added block
        if ((int )*p___0 == 45) {
          _L___1: 
          {
          tmp___2 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___2 + (int )*p___0) & 2048) {
            {
            spats[0].off.off = atol((char const   *)((char *)p___0));
            }
          } else {
            {
            tmp___3 = __ctype_b_loc();
            }
            if ((int const   )*(*tmp___3 + (int )*(p___0 + 1)) & 2048) {
              {
              spats[0].off.off = atol((char const   *)((char *)p___0));
              }
            } else { //Added block
            if ((int )*p___0 == 45) {
              spats[0].off.off = -1L;
            } else {
              spats[0].off.off = 1L;
            }
            }
          }
          p___0 ++;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
            tmp___4 = __ctype_b_loc();
            }
            if (! ((int const   )*(*tmp___4 + (int )*p___0) & 2048)) {
              goto while_break___0;
            }
            p___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        }
        }
        searchcmdlen = (int )(p___0 - str___1);
        str___1 = p___0;
      }
    }
    if (options___0 & 2) {
      {
      tmp___12 = messaging();
      }
      if (tmp___12) {
        if ((int )*searchstr == 0) {
          p___0 = spats[last_idx].pat;
        } else {
          p___0 = searchstr;
        }
        {
        tmp___6 = strlen((char const   *)((char *)p___0));
        msgbuf = alloc((unsigned int )(tmp___6 + 40UL));
        }
        if ((unsigned long )msgbuf != (unsigned long )((void *)0)) {
          {
          *(msgbuf + 0) = (char_u )dirc;
          strcpy((char * __restrict  )((char *)(msgbuf + 1)), (char const   * __restrict  )((char *)p___0));
          }
          if (spats[0].off.line) {
            goto _L___2;
          } else { //Added block
          if (spats[0].off.end) {
            goto _L___2;
          } else { //Added block
          if (spats[0].off.off) {
            _L___2: 
            {
            tmp___7 = strlen((char const   *)((char *)msgbuf));
            p___0 = msgbuf + tmp___7;
            tmp___8 = p___0;
            p___0 ++;
            *tmp___8 = (char_u )dirc;
            }
            if (spats[0].off.end) {
              tmp___9 = p___0;
              p___0 ++;
              *tmp___9 = (char_u )'e';
            } else { //Added block
            if (! spats[0].off.line) {
              tmp___10 = p___0;
              p___0 ++;
              *tmp___10 = (char_u )'s';
            }
            }
            if (spats[0].off.off > 0L) {
              tmp___11 = p___0;
              p___0 ++;
              *tmp___11 = (char_u )'+';
            } else { //Added block
            if (spats[0].off.line) {
              tmp___11 = p___0;
              p___0 ++;
              *tmp___11 = (char_u )'+';
            }
            }
            if (spats[0].off.off != 0L) {
              {
              sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )"%ld",
                      spats[0].off.off);
              }
            } else { //Added block
            if (spats[0].off.line) {
              {
              sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )"%ld",
                      spats[0].off.off);
              }
            } else {
              *p___0 = (char_u )'\000';
            }
            }
          }
          }
          }
          {
          msg_start();
          trunc = msg_strtrunc(msgbuf);
          }
          if ((unsigned long )trunc != (unsigned long )((void *)0)) {
            {
            msg_outtrans(trunc);
            vim_free((void *)trunc);
            }
          } else {
            {
            msg_outtrans(msgbuf);
            }
          }
          {
          msg_clr_eos();
          msg_check();
          vim_free((void *)msgbuf);
          gotocmdline(0);
          out_flush();
          msg_nowait = 1;
          }
        }
      }
    }
    if (! spats[0].off.line) {
      if (spats[0].off.off) {
        if (spats[0].off.off > 0L) {
          c = spats[0].off.off;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (! c) {
              goto while_break___1;
            }
            {
            tmp___13 = decl(& pos___0);
            }
            if (tmp___13 == -1) {
              goto while_break___1;
            }
            c --;
          }
          while_break___1: /* CIL Label */ ;
          }
          if (c) {
            pos___0.lnum = (linenr_t )0;
            pos___0.col = (colnr_t )2147483647;
          }
        } else {
          c = spats[0].off.off;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! c) {
              goto while_break___2;
            }
            {
            tmp___14 = incl(& pos___0);
            }
            if (tmp___14 == -1) {
              goto while_break___2;
            }
            c ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          if (c) {
            pos___0.lnum = curbuf->b_ml.ml_line_count + 1L;
            pos___0.col = (colnr_t )0;
          }
        }
      }
    }
    if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
      if ((int )*str___1 == 59) {
        tmp___15 = 0;
      } else {
        tmp___15 = 128;
      }
    } else {
      tmp___15 = 128;
    }
    if (dirc == 47) {
      tmp___16 = 1;
    } else {
      tmp___16 = -1;
    }
    {
    tmp___17 = searchit(curbuf, & pos___0, tmp___16, searchstr, count___2, spats[0].off.end + (options___0 & (1324 + tmp___15)),
                        2);
    c = (long )tmp___17;
    }
    if ((unsigned long )dircp != (unsigned long )((void *)0)) {
      *dircp = (char_u )dirc;
    }
    if (c == 0L) {
      retval = 0;
      goto end_do_search;
    }
    if (spats[0].off.end) {
      if ((unsigned long )oap != (unsigned long )((void *)0)) {
        oap->inclusive = 1;
      }
    }
    retval = 1;
    if (! (options___0 & 128)) {
      goto _L___3;
    } else { //Added block
    if ((int )*str___1 == 59) {
      _L___3: 
      if (spats[0].off.line) {
        c = pos___0.lnum + spats[0].off.off;
        if (c < 1L) {
          pos___0.lnum = (linenr_t )1;
        } else { //Added block
        if (c > curbuf->b_ml.ml_line_count) {
          pos___0.lnum = curbuf->b_ml.ml_line_count;
        } else {
          pos___0.lnum = c;
        }
        }
        pos___0.col = (colnr_t )0;
        retval = 2;
      } else { //Added block
      if (spats[0].off.off > 0L) {
        c = spats[0].off.off;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          if (! c) {
            goto while_break___3;
          }
          {
          tmp___18 = incl(& pos___0);
          }
          if (tmp___18 == -1) {
            goto while_break___3;
          }
          c --;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        c = (long )pos___0.col + spats[0].off.off;
        if (c >= 0L) {
          pos___0.col = (colnr_t )c;
        } else {
          c = spats[0].off.off;
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (! c) {
              goto while_break___4;
            }
            {
            tmp___19 = decl(& pos___0);
            }
            if (tmp___19 == -1) {
              goto while_break___4;
            }
            c ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
      }
    }
    }
    if (! (options___0 & 16)) {
      goto while_break;
    } else { //Added block
    if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
      goto while_break;
    } else { //Added block
    if ((int )*str___1 != 59) {
      goto while_break;
    }
    }
    }
    str___1 ++;
    dirc = (int )*str___1;
    if (dirc != 63) {
      if (dirc != 47) {
        {
        retval = 0;
        emsg((char_u *)"Expected \'?\' or \'/\'  after \';\'");
        }
        goto end_do_search;
      }
    }
    str___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (options___0 & 512) {
    {
    setpcmark();
    }
  }
  curwin->w_cursor = pos___0;
  curwin->w_set_curswant = 1;
  end_do_search: 
  if (options___0 & 1024) {
    spats[0].off = old_off;
  }
  return (retval);
}
}
int search_for_exact_line(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *pat ) 
{ 
  linenr_t start___0 ;
  char_u *ptr ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  start___0 = (linenr_t )0;
  if (buf___3->b_ml.ml_line_count == 0L) {
    return (0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    pos___0->lnum += (linenr_t )dir;
    if (pos___0->lnum < 1L) {
      if (p_ws) {
        {
        pos___0->lnum = buf___3->b_ml.ml_line_count;
        tmp = shortmess('s');
        }
        if (! tmp) {
          {
          give_warning(top_bot_msg, 1);
          }
        }
      } else {
        pos___0->lnum = (linenr_t )1;
        goto while_break;
      }
    } else { //Added block
    if (pos___0->lnum > buf___3->b_ml.ml_line_count) {
      if (p_ws) {
        {
        pos___0->lnum = (linenr_t )1;
        tmp___0 = shortmess('s');
        }
        if (! tmp___0) {
          {
          give_warning(bot_top_msg, 1);
          }
        }
      } else {
        pos___0->lnum = (linenr_t )1;
        goto while_break;
      }
    }
    }
    if (pos___0->lnum == start___0) {
      goto while_break;
    }
    if (start___0 == 0L) {
      start___0 = pos___0->lnum;
    }
    {
    ptr = ml_get_buf(buf___3, pos___0->lnum, 0);
    p___0 = skipwhite(ptr);
    pos___0->col = (colnr_t )(p___0 - ptr);
    }
    if (continue_status & 1) {
      if (! (continue_status & 16)) {
        if (p_ic) {
          ptr = pat;
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
            tmp___1 = tolower((int )*p___0);
            }
            if (tmp___1 == (int )*ptr) {
              if (! *p___0) {
                goto while_break___0;
              }
            } else {
              goto while_break___0;
            }
            p___0 ++;
            ptr ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          if ((int )*p___0 == (int )*ptr) {
            return (1);
          }
        } else {
          {
          tmp___2 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)pat));
          }
          if (tmp___2 == 0) {
            return (1);
          }
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (*p___0) {
      if (p_ic) {
        ptr = pat;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
          tmp___3 = tolower((int )*p___0);
          }
          if (tmp___3 == (int )*ptr) {
            if (! *p___0) {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
          p___0 ++;
          ptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        if ((int )*ptr == 0) {
          return (1);
        }
      } else {
        {
        tmp___4 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)pat),
                          (size_t )completion_length);
        }
        if (tmp___4 == 0) {
          return (1);
        }
      }
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int lastc___0  =    '\000';
static int lastcdir  ;
static int lastctype  ;
int searchc(int c , int dir , int type , long count___2 ) 
{ 
  int col ;
  char_u *p___0 ;
  int len___0 ;
  size_t tmp ;
  long tmp___0 ;

  {
  if (c != 0) {
    if (! KeyStuffed) {
      lastc___0 = c;
      lastcdir = dir;
      lastctype = type;
    }
  } else {
    if (lastc___0 == 0) {
      return (0);
    }
    if (dir) {
      dir = - lastcdir;
    } else {
      dir = lastcdir;
    }
    type = lastctype;
    c = lastc___0;
  }
  {
  p___0 = ml_get_curline();
  col = (int )curwin->w_cursor.col;
  tmp = strlen((char const   *)((char *)p___0));
  len___0 = (int )tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___0 = count___2;
    count___2 --;
    if (! tmp___0) {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      col += dir;
      if (col < 0) {
        return (0);
      } else { //Added block
      if (col >= len___0) {
        return (0);
      }
      }
      if ((int )*(p___0 + col) == c) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (type) {
    col -= dir;
  }
  curwin->w_cursor.col = (colnr_t )col;
  return (1);
}
}
FPOS *findmatch(OPARG *oap , int initc ) 
{ 
  FPOS *tmp ;

  {
  {
  tmp = findmatchlimit(oap, initc, 0, 0);
  }
  return (tmp);
}
}
static FPOS pos  ;
FPOS *findmatchlimit(OPARG *oap , int initc , int flags___0 , int maxtravel ) 
{ 
  int findc ;
  int c ;
  int count___2 ;
  int backwards ;
  int inquote ;
  char_u *linep ;
  char_u *ptr ;
  int do_quotes ;
  int at_start___0 ;
  int hash_dir ;
  int comment_dir ;
  FPOS match_pos ;
  int start_in_quotes ;
  int traveled ;
  int ignore_cend ;
  int cpo_match ;
  int dir ;
  int comment_col ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;

  {
  {
  findc = 0;
  count___2 = 0;
  backwards = 0;
  inquote = 0;
  hash_dir = 0;
  comment_dir = 0;
  traveled = 0;
  ignore_cend = 0;
  comment_col = 2147483647;
  pos = curwin->w_cursor;
  linep = ml_get(pos.lnum);
  tmp = vim_strchr(p_cpo, '%');
  cpo_match = (unsigned long )tmp != (unsigned long )((void *)0);
  }
  if (flags___0 & 1) {
    dir = -1;
  } else { //Added block
  if (flags___0 & 2) {
    dir = 1;
  } else {
    dir = 0;
  }
  }
  if (initc == 47) {
    goto _L___2;
  } else { //Added block
  if (initc == 42) {
    _L___2: 
    comment_dir = dir;
    if (initc == 47) {
      ignore_cend = 1;
    }
    if (dir == 1) {
      backwards = 0;
    } else {
      backwards = 1;
    }
    initc = '\000';
  } else { //Added block
  if (initc != 35) {
    if (initc != 0) {
      ptr = curbuf->b_p_mps;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! *ptr) {
          goto while_break;
        }
        if ((int )*ptr == initc) {
          findc = initc;
          initc = (int )*(ptr + 2);
          backwards = 1;
          goto while_break;
        }
        ptr += 2;
        if ((int )*ptr == initc) {
          findc = initc;
          initc = (int )*(ptr + -2);
          backwards = 0;
          goto while_break;
        }
        ptr += 2;
      }
      while_break: /* CIL Label */ ;
      }
      if (! findc) {
        return ((FPOS *)((void *)0));
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    if (initc == 35) {
      hash_dir = dir;
    } else {
      if (! cpo_match) {
        {
        ptr = skipwhite(linep);
        }
        if ((int )*ptr == 35) {
          if (pos.col <= (colnr_t )(ptr - linep)) {
            {
            ptr = skipwhite(ptr + 1);
            tmp___0 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"if"),
                              (size_t )2);
            }
            if (tmp___0 == 0) {
              hash_dir = 1;
            } else {
              {
              tmp___1 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"endif"),
                                (size_t )5);
              }
              if (tmp___1 == 0) {
                hash_dir = 1;
              } else {
                {
                tmp___2 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"el"),
                                  (size_t )2);
                }
                if (tmp___2 == 0) {
                  hash_dir = 1;
                }
              }
            }
          } else {
            goto _L;
          }
        } else { //Added block
        _L: 
        if ((int )*(linep + pos.col) == 47) {
          if ((int )*(linep + (pos.col + 1U)) == 42) {
            comment_dir = 1;
            backwards = 0;
            (pos.col) ++;
          } else { //Added block
          if (pos.col > 0U) {
            if ((int )*(linep + (pos.col - 1U)) == 42) {
              comment_dir = -1;
              backwards = 1;
              (pos.col) --;
            }
          }
          }
        } else { //Added block
        if ((int )*(linep + pos.col) == 42) {
          if ((int )*(linep + (pos.col + 1U)) == 47) {
            comment_dir = -1;
            backwards = 1;
          } else { //Added block
          if (pos.col > 0U) {
            if ((int )*(linep + (pos.col - 1U)) == 47) {
              comment_dir = 1;
              backwards = 0;
            }
          }
          }
        }
        }
        }
      }
      if (! hash_dir) {
        if (! comment_dir) {
          if ((int )*(linep + pos.col) == 0) {
            if (pos.col) {
              (pos.col) --;
            }
          }
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            initc = (int )*(linep + pos.col);
            if (initc == 0) {
              goto while_break___0;
            }
            ptr = curbuf->b_p_mps;
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (! *ptr) {
                goto while_break___1;
              }
              if ((int )*ptr == initc) {
                findc = (int )*(ptr + 2);
                backwards = 0;
                goto while_break___1;
              }
              ptr += 2;
              if ((int )*ptr == initc) {
                findc = (int )*(ptr + -2);
                backwards = 1;
                goto while_break___1;
              }
              ptr ++;
              if (! *ptr) {
                goto while_break___1;
              }
              ptr ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            if (findc) {
              goto while_break___0;
            }
            (pos.col) ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          if (! findc) {
            if (! cpo_match) {
              {
              tmp___3 = skipwhite(linep);
              }
              if ((int )*tmp___3 == 35) {
                hash_dir = 1;
              } else {
                return ((FPOS *)((void *)0));
              }
            } else {
              return ((FPOS *)((void *)0));
            }
          }
        }
      }
    }
    if (hash_dir) {
      if ((unsigned long )oap != (unsigned long )((void *)0)) {
        oap->motion_type = 1;
      }
      if (initc != 35) {
        {
        tmp___4 = skipwhite(linep);
        ptr = skipwhite(tmp___4 + 1);
        tmp___6 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"if"),
                          (size_t )2);
        }
        if (tmp___6 == 0) {
          hash_dir = 1;
        } else {
          {
          tmp___7 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"el"),
                            (size_t )2);
          }
          if (tmp___7 == 0) {
            hash_dir = 1;
          } else {
            {
            tmp___5 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"endif"),
                              (size_t )5);
            }
            if (tmp___5 == 0) {
              hash_dir = -1;
            } else {
              return ((FPOS *)((void *)0));
            }
          }
        }
      }
      pos.col = (colnr_t )0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (! got_int)) {
          goto while_break___2;
        }
        if (hash_dir > 0) {
          if (pos.lnum == curbuf->b_ml.ml_line_count) {
            goto while_break___2;
          }
        } else { //Added block
        if (pos.lnum == 1L) {
          goto while_break___2;
        }
        }
        {
        pos.lnum += (linenr_t )hash_dir;
        linep = ml_get(pos.lnum);
        line_breakcheck();
        ptr = skipwhite(linep);
        }
        if ((int )*ptr != 35) {
          goto while_continue___2;
        }
        {
        pos.col = (colnr_t )(ptr - linep);
        ptr = skipwhite(ptr + 1);
        }
        if (hash_dir > 0) {
          {
          tmp___10 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"if"),
                             (size_t )2);
          }
          if (tmp___10 == 0) {
            count___2 ++;
          } else {
            {
            tmp___9 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"el"),
                              (size_t )2);
            }
            if (tmp___9 == 0) {
              if (count___2 == 0) {
                return (& pos);
              }
            } else {
              {
              tmp___8 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"endif"),
                                (size_t )5);
              }
              if (tmp___8 == 0) {
                if (count___2 == 0) {
                  return (& pos);
                }
                count___2 --;
              }
            }
          }
        } else {
          {
          tmp___13 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"if"),
                             (size_t )2);
          }
          if (tmp___13 == 0) {
            if (count___2 == 0) {
              return (& pos);
            }
            count___2 --;
          } else { //Added block
          if (initc == 35) {
            {
            tmp___12 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"el"),
                               (size_t )2);
            }
            if (tmp___12 == 0) {
              if (count___2 == 0) {
                return (& pos);
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            {
            tmp___11 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"endif"),
                               (size_t )5);
            }
            if (tmp___11 == 0) {
              count___2 ++;
            }
          }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      return ((FPOS *)((void *)0));
    }
  }
  }
  }
  do_quotes = -1;
  start_in_quotes = 2;
  if (backwards) {
    if (comment_dir) {
      {
      comment_col = check_linecomment(linep);
      }
    }
  }
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (! got_int)) {
      goto while_break___3;
    }
    if (backwards) {
      if (pos.col == 0U) {
        if (pos.lnum == 1L) {
          goto while_break___3;
        }
        (pos.lnum) --;
        if (maxtravel) {
          tmp___14 = traveled;
          traveled ++;
          if (tmp___14 > maxtravel) {
            goto while_break___3;
          }
        }
        {
        linep = ml_get(pos.lnum);
        tmp___15 = strlen((char const   *)((char *)linep));
        pos.col = (colnr_t )tmp___15;
        do_quotes = -1;
        line_breakcheck();
        }
        if (comment_dir) {
          {
          comment_col = check_linecomment(linep);
          }
        }
      } else {
        (pos.col) --;
      }
    } else { //Added block
    if ((int )*(linep + pos.col) == 0) {
      if (pos.lnum == curbuf->b_ml.ml_line_count) {
        goto while_break___3;
      }
      (pos.lnum) ++;
      if (maxtravel) {
        tmp___16 = traveled;
        traveled ++;
        if (tmp___16 > maxtravel) {
          goto while_break___3;
        }
      }
      {
      linep = ml_get(pos.lnum);
      pos.col = (colnr_t )0;
      do_quotes = -1;
      line_breakcheck();
      }
    } else {
      (pos.col) ++;
    }
    }
    if (pos.col == 0U) {
      if (flags___0 & 4) {
        if ((int )*(linep + 0) == 123) {
          goto _L___3;
        } else { //Added block
        if ((int )*(linep + 0) == 125) {
          _L___3: 
          if ((int )*(linep + 0) == findc) {
            if (count___2 == 0) {
              return (& pos);
            }
          }
          goto while_break___3;
        }
        }
      }
    }
    if (comment_dir) {
      if (comment_dir == 1) {
        if ((int )*(linep + pos.col) == 42) {
          if ((int )*(linep + (pos.col + 1U)) == 47) {
            (pos.col) ++;
            return (& pos);
          }
        }
      } else { //Added block
      if (pos.col == 0U) {
        goto while_continue___3;
      } else { //Added block
      if ((int )*(linep + (pos.col - 1U)) == 47) {
        if ((int )*(linep + pos.col) == 42) {
          if ((int )pos.col < comment_col) {
            count___2 ++;
            match_pos = pos;
            (match_pos.col) --;
          } else {
            goto _L___6;
          }
        } else {
          goto _L___6;
        }
      } else { //Added block
      _L___6: 
      if ((int )*(linep + (pos.col - 1U)) == 42) {
        if ((int )*(linep + pos.col) == 47) {
          if (count___2 > 0) {
            pos = match_pos;
          } else { //Added block
          if (pos.col > 1U) {
            if ((int )*(linep + (pos.col - 2U)) == 47) {
              pos.col -= 2U;
            } else {
              goto _L___4;
            }
          } else { //Added block
          _L___4: 
          if (ignore_cend) {
            goto while_continue___3;
          } else {
            return ((FPOS *)((void *)0));
          }
          }
          }
          return (& pos);
        }
      }
      }
      }
      }
      goto while_continue___3;
    }
    if (cpo_match) {
      do_quotes = 0;
    } else { //Added block
    if (do_quotes == -1) {
      at_start___0 = do_quotes;
      ptr = linep;
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! *ptr) {
          goto while_break___4;
        }
        if ((unsigned long )ptr == (unsigned long )((linep + pos.col) + backwards)) {
          at_start___0 = do_quotes & 1;
        }
        if ((int )*ptr == 34) {
          if ((unsigned long )ptr == (unsigned long )linep) {
            goto _L___7;
          } else { //Added block
          if ((int )*(ptr + -1) != 92) {
            _L___7: 
            if ((unsigned long )ptr == (unsigned long )linep) {
              do_quotes ++;
            } else { //Added block
            if ((int )*(ptr + -1) != 39) {
              do_quotes ++;
            } else { //Added block
            if ((int )*(ptr + 1) != 39) {
              do_quotes ++;
            }
            }
            }
          }
          }
        }
        ptr ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      do_quotes &= 1;
      if (! do_quotes) {
        inquote = 0;
        if ((int )*(ptr + -1) == 92) {
          do_quotes = 1;
          if (start_in_quotes == 2) {
            inquote = ! at_start___0;
            if (inquote) {
              start_in_quotes = 1;
            }
          } else { //Added block
          if (backwards) {
            inquote = 1;
          }
          }
        }
        if (pos.lnum > 1L) {
          {
          ptr = ml_get(pos.lnum - 1L);
          }
          if (*ptr) {
            {
            tmp___17 = strlen((char const   *)((char *)ptr));
            }
            if ((int )*((ptr + tmp___17) - 1) == 92) {
              do_quotes = 1;
              if (start_in_quotes == 2) {
                inquote = at_start___0;
                if (inquote) {
                  start_in_quotes = 1;
                }
              } else { //Added block
              if (! backwards) {
                inquote = 1;
              }
              }
            }
          }
        }
      }
    }
    }
    if (start_in_quotes == 2) {
      start_in_quotes = 0;
    }
    c = (int )*(linep + pos.col);
    {
    if (c == 0) {
      goto case_0;
    }
    if (c == 34) {
      goto case_34;
    }
    if (c == 39) {
      goto case_39;
    }
    goto switch_default;
    case_0: /* CIL Label */ 
    if (pos.col == 0U) {
      inquote = 0;
      start_in_quotes = 0;
    } else { //Added block
    if ((int )*(linep + (pos.col - 1U)) != 92) {
      inquote = 0;
      start_in_quotes = 0;
    }
    }
    goto switch_break;
    case_34: /* CIL Label */ 
    if (do_quotes) {
      if (pos.col == 0U) {
        inquote = ! inquote;
        start_in_quotes = 0;
      } else { //Added block
      if ((int )*(linep + (pos.col - 1U)) != 92) {
        inquote = ! inquote;
        start_in_quotes = 0;
      }
      }
    }
    goto switch_break;
    case_39: /* CIL Label */ 
    if (! cpo_match) {
      if (initc != 39) {
        if (findc != 39) {
          if (backwards) {
            if (pos.col > 1U) {
              if ((int )*(linep + (pos.col - 2U)) == 39) {
                pos.col -= 2U;
                goto switch_break;
              } else { //Added block
              if ((int )*(linep + (pos.col - 2U)) == 92) {
                if (pos.col > 2U) {
                  if ((int )*(linep + (pos.col - 3U)) == 39) {
                    pos.col -= 3U;
                    goto switch_break;
                  }
                }
              }
              }
            }
          } else { //Added block
          if (*(linep + (pos.col + 1U))) {
            if ((int )*(linep + (pos.col + 1U)) == 92) {
              if (*(linep + (pos.col + 2U))) {
                if ((int )*(linep + (pos.col + 3U)) == 39) {
                  pos.col += 3U;
                  goto switch_break;
                } else {
                  goto _L___9;
                }
              } else {
                goto _L___9;
              }
            } else { //Added block
            _L___9: 
            if ((int )*(linep + (pos.col + 2U)) == 39) {
              pos.col += 2U;
              goto switch_break;
            }
            }
          }
          }
        }
      }
    }
    switch_default: /* CIL Label */ 
    if (! inquote) {
      goto _L___10;
    } else { //Added block
    if (start_in_quotes == 1) {
      _L___10: 
      if (c == initc) {
        count___2 ++;
      } else { //Added block
      if (c == findc) {
        if (count___2 == 0) {
          return (& pos);
        }
        count___2 --;
      }
      }
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  if (comment_dir == -1) {
    if (count___2 > 0) {
      pos = match_pos;
      return (& pos);
    }
  }
  return ((FPOS *)((void *)0));
}
}
static int check_linecomment(char_u *line ) 
{ 
  char_u *p___0 ;

  {
  p___0 = line;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    p___0 = vim_strchr(p___0, '/');
    }
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((int )*(p___0 + 1) == 47) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    return (2147483647);
  }
  return ((int )(p___0 - line));
}
}
void showmatch(void) 
{ 
  FPOS *lpos ;
  FPOS save_cursor ;
  FPOS mpos ;
  colnr_t vcol ;
  long save_so ;
  int tmp ;
  char_u *tmp___0 ;

  {
  {
  lpos = findmatch((OPARG *)((void *)0), '\000');
  }
  if ((unsigned long )lpos == (unsigned long )((void *)0)) {
    {
    vim_beep();
    }
  } else { //Added block
  if (lpos->lnum >= curwin->w_topline) {
    if (! curwin->w_p_wrap) {
      {
      getvcol(curwin, lpos, (colnr_t *)((void *)0), & vcol, (colnr_t *)((void *)0));
      }
    }
    if (curwin->w_p_wrap) {
      goto _L;
    } else { //Added block
    if (vcol >= curwin->w_leftcol) {
      if ((long )vcol < (long )curwin->w_leftcol + Columns) {
        _L: 
        {
        mpos = *lpos;
        update_screen(30);
        save_cursor = curwin->w_cursor;
        save_so = p_so;
        curwin->w_cursor = mpos;
        p_so = 0L;
        showruler(0);
        setcursor();
        cursor_on();
        out_flush();
        tmp___0 = vim_strchr(p_cpo, 'm');
        }
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
          {
          ui_delay(p_mat * 100L, 1);
          }
        } else {
          {
          tmp = char_avail();
          }
          if (! tmp) {
            {
            ui_delay(p_mat * 100L, 0);
            }
          }
        }
        curwin->w_cursor = save_cursor;
        p_so = save_so;
      }
    }
    }
  }
  }
  return;
}
}
int findsent(int dir , long count___2 ) 
{ 
  FPOS pos___0 ;
  FPOS tpos ;
  int c ;
  int (*func)(FPOS * ) ;
  int startlnum ;
  int noskip ;
  int cpo_J ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;

  {
  noskip = 0;
  pos___0 = curwin->w_cursor;
  if (dir == 1) {
    func = & incl;
  } else {
    func = & decl;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___14 = count___2;
    count___2 --;
    if (! tmp___14) {
      goto while_break;
    }
    {
    tmp___2 = gchar_pos(& pos___0);
    }
    if (tmp___2 == 0) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp = (*func)(& pos___0);
        }
        if (tmp == -1) {
          goto while_break___0;
        }
        {
        tmp___0 = gchar_pos(& pos___0);
        }
        if (! (tmp___0 == 0)) {
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      if (dir == 1) {
        goto found;
      }
    } else { //Added block
    if (dir == 1) {
      if (pos___0.col == 0U) {
        {
        tmp___1 = startPS(pos___0.lnum, '\000', 0);
        }
        if (tmp___1) {
          if (pos___0.lnum == curbuf->b_ml.ml_line_count) {
            return (0);
          }
          (pos___0.lnum) ++;
          goto found;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (dir == -1) {
      {
      decl(& pos___0);
      }
    }
    }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      c = gchar_pos(& pos___0);
      }
      if (! (c == 32)) {
        if (! (c == 9)) {
          if (dir == -1) {
            {
            tmp___5 = vim_strchr((char_u *)".!?)]\"\'", c);
            }
            if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
        }
      }
      {
      tmp___3 = decl(& pos___0);
      }
      if (tmp___3 == -1) {
        goto while_break___1;
      }
      {
      tmp___4 = ml_get(pos___0.lnum);
      }
      if ((int )*tmp___4 == 0) {
        if (dir == 1) {
          {
          incl(& pos___0);
          }
          goto found;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    startlnum = (int )pos___0.lnum;
    tmp___6 = vim_strchr(p_cpo, 'J');
    cpo_J = (unsigned long )tmp___6 != (unsigned long )((void *)0);
    }
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
      c = gchar_pos(& pos___0);
      }
      if (c == 0) {
        goto _L___1;
      } else { //Added block
      if (pos___0.col == 0U) {
        {
        tmp___7 = startPS(pos___0.lnum, '\000', 0);
        }
        if (tmp___7) {
          _L___1: 
          if (dir == -1) {
            if (pos___0.lnum != (linenr_t )startlnum) {
              (pos___0.lnum) ++;
            }
          }
          goto while_break___2;
        }
      }
      }
      if (c == 46) {
        goto _L___4;
      } else { //Added block
      if (c == 33) {
        goto _L___4;
      } else { //Added block
      if (c == 63) {
        _L___4: 
        tpos = pos___0;
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
          c = inc(& tpos);
          }
          if (c == -1) {
            goto while_break___3;
          }
          {
          c = gchar_pos(& tpos);
          tmp___8 = vim_strchr((char_u *)")]\"\'", c);
          }
          if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        if (c == -1) {
          goto _L___2;
        } else { //Added block
        if (! cpo_J) {
          if (c == 32) {
            goto _L___2;
          } else { //Added block
          if (c == 9) {
            goto _L___2;
          } else {
            goto _L___3;
          }
          }
        } else { //Added block
        _L___3: 
        if (c == 0) {
          goto _L___2;
        } else { //Added block
        if (cpo_J) {
          if (c == 32) {
            {
            tmp___10 = inc(& tpos);
            }
            if (tmp___10 >= 0) {
              {
              tmp___11 = gchar_pos(& tpos);
              }
              if (tmp___11 == 32) {
                _L___2: 
                {
                pos___0 = tpos;
                tmp___9 = gchar_pos(& pos___0);
                }
                if (tmp___9 == 0) {
                  {
                  inc(& pos___0);
                  }
                }
                goto while_break___2;
              }
            }
          }
        }
        }
        }
        }
      }
      }
      }
      {
      tmp___12 = (*func)(& pos___0);
      }
      if (tmp___12 == -1) {
        if (count___2) {
          return (0);
        }
        noskip = 1;
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    found: 
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! noskip) {
        {
        c = gchar_pos(& pos___0);
        }
        if (! (c == 32)) {
          if (! (c == 9)) {
            goto while_break___4;
          }
        }
      } else {
        goto while_break___4;
      }
      {
      tmp___13 = incl(& pos___0);
      }
      if (tmp___13 == -1) {
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  setpcmark();
  curwin->w_cursor = pos___0;
  }
  return (1);
}
}
int findpar(OPARG *oap , int dir , long count___2 , int what , int both ) 
{ 
  linenr_t curr ;
  int did_skip ;
  int first___0 ;
  char_u *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char_u *tmp___2 ;
  colnr_t tmp___3 ;
  char_u *tmp___4 ;
  size_t tmp___5 ;

  {
  curr = curwin->w_cursor.lnum;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___1 = count___2;
    count___2 --;
    if (! tmp___1) {
      goto while_break;
    }
    did_skip = 0;
    first___0 = 1;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp = ml_get(curr);
      }
      if ((int )*tmp != 0) {
        did_skip = 1;
      }
      if (! first___0) {
        if (did_skip) {
          {
          tmp___0 = startPS(curr, what, both);
          }
          if (tmp___0) {
            goto while_break___0;
          }
        }
      }
      curr += (linenr_t )dir;
      if (curr < 1L) {
        goto _L;
      } else { //Added block
      if (curr > curbuf->b_ml.ml_line_count) {
        _L: 
        if (count___2) {
          return (0);
        }
        curr -= (linenr_t )dir;
        goto while_break___0;
      }
      }
      first___0 = 0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  setpcmark();
  }
  if (both) {
    {
    tmp___2 = ml_get(curr);
    }
    if ((int )*tmp___2 == 125) {
      curr ++;
    }
  }
  curwin->w_cursor.lnum = curr;
  if (curr == curbuf->b_ml.ml_line_count) {
    {
    tmp___4 = ml_get(curr);
    tmp___5 = strlen((char const   *)((char *)tmp___4));
    tmp___3 = (colnr_t )tmp___5;
    curwin->w_cursor.col = tmp___3;
    }
    if (tmp___3 != 0U) {
      (curwin->w_cursor.col) --;
      oap->inclusive = 1;
    }
  } else {
    curwin->w_cursor.col = (colnr_t )0;
  }
  return (1);
}
}
static int inmacro(char_u *opt , char_u *s ) 
{ 
  char_u *macro ;

  {
  macro = opt;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(macro + 0)) {
      goto while_break;
    }
    if ((int )*(macro + 0) == (int )*(s + 0)) {
      if ((int )*(s + 1) == 0) {
        goto _L___0;
      } else { //Added block
      if ((int )*(s + 1) == 32) {
        _L___0: 
        if ((int )*(macro + 1) == 0) {
          goto while_break;
        } else { //Added block
        if ((int )*(macro + 1) == 32) {
          goto while_break;
        } else {
          goto _L;
        }
        }
      } else { //Added block
      _L: 
      if ((int )*(macro + 1) == (int )*(s + 1)) {
        goto while_break;
      }
      }
      }
    }
    macro ++;
    if ((int )*(macro + 0) == 0) {
      goto while_break;
    }
    macro ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((int )*(macro + 0) != 0);
}
}
int startPS(linenr_t lnum , int para , int both ) 
{ 
  char_u *s ;
  int tmp ;
  int tmp___0 ;

  {
  {
  s = ml_get(lnum);
  }
  if ((int )*s == para) {
    return (1);
  } else { //Added block
  if ((int )*s == 12) {
    return (1);
  } else { //Added block
  if (both) {
    if ((int )*s == 125) {
      return (1);
    }
  }
  }
  }
  if ((int )*s == 46) {
    {
    tmp = inmacro(p_sections, s + 1);
    }
    if (tmp) {
      return (1);
    } else { //Added block
    if (! para) {
      {
      tmp___0 = inmacro(p_para, s + 1);
      }
      if (tmp___0) {
        return (1);
      }
    }
    }
  }
  return (0);
}
}
static int stype  ;
static int cls(void) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
  c = gchar_cursor();
  }
  if (c == 32) {
    return (0);
  } else { //Added block
  if (c == 9) {
    return (0);
  } else { //Added block
  if (c == 0) {
    return (0);
  }
  }
  }
  {
  tmp = vim_iswordc(c);
  }
  if (tmp) {
    return (1);
  }
  if (stype == 0) {
    tmp___0 = 2;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
int fwd_word(long count___2 , int type , int eol ) 
{ 
  int sclass ;
  int i___0 ;
  int last_line ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    last_line = curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count;
    i___0 = inc_cursor();
    }
    if (i___0 == -1) {
      return (0);
    } else { //Added block
    if (i___0 == 1) {
      if (last_line) {
        return (0);
      }
    }
    }
    if (i___0 == 1) {
      if (eol) {
        if (count___2 == 0L) {
          return (1);
        }
      }
    }
    if (sclass != 0) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp = cls();
        }
        if (! (tmp == sclass)) {
          goto while_break___0;
        }
        {
        i___0 = inc_cursor();
        }
        if (i___0 == -1) {
          return (1);
        } else { //Added block
        if (i___0 == 1) {
          if (eol) {
            if (count___2 == 0L) {
              return (1);
            }
          }
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___1 = cls();
      }
      if (! (tmp___1 == 0)) {
        goto while_break___1;
      }
      if (curwin->w_cursor.col == 0U) {
        {
        tmp___0 = ml_get_curline();
        }
        if ((int )*tmp___0 == 0) {
          goto while_break___1;
        }
      }
      {
      i___0 = inc_cursor();
      }
      if (i___0 == -1) {
        return (1);
      } else { //Added block
      if (i___0 == 1) {
        if (eol) {
          if (count___2 == 0L) {
            return (1);
          }
        }
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
int bck_word(long count___2 , int type , int stop ) 
{ 
  int sclass ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    tmp = dec_cursor();
    }
    if (tmp == -1) {
      return (0);
    }
    if (! stop) {
      goto _L;
    } else {
      {
      tmp___5 = cls();
      }
      if (sclass == tmp___5) {
        goto _L;
      } else { //Added block
      if (sclass == 0) {
        _L: 
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
          tmp___2 = cls();
          }
          if (! (tmp___2 == 0)) {
            goto while_break___0;
          }
          if (curwin->w_cursor.col == 0U) {
            {
            tmp___0 = ml_get(curwin->w_cursor.lnum);
            }
            if ((int )*tmp___0 == 0) {
              goto finished;
            }
          }
          {
          tmp___1 = dec_cursor();
          }
          if (tmp___1 == -1) {
            return (1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        tmp___3 = cls();
        tmp___4 = skip_chars(tmp___3, -1);
        }
        if (tmp___4) {
          return (1);
        }
      }
      }
    }
    {
    inc_cursor();
    }
    finished: 
    stop = 0;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
int end_word(long count___2 , int type , int stop , int empty ) 
{ 
  int sclass ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    tmp = inc_cursor();
    }
    if (tmp == -1) {
      return (0);
    }
    {
    tmp___6 = cls();
    }
    if (tmp___6 == sclass) {
      if (sclass != 0) {
        {
        tmp___0 = skip_chars(sclass, 1);
        }
        if (tmp___0) {
          return (0);
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: 
    if (! stop) {
      goto _L;
    } else { //Added block
    if (sclass == 0) {
      _L: 
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp___3 = cls();
        }
        if (! (tmp___3 == 0)) {
          goto while_break___0;
        }
        if (empty) {
          if (curwin->w_cursor.col == 0U) {
            {
            tmp___1 = ml_get(curwin->w_cursor.lnum);
            }
            if ((int )*tmp___1 == 0) {
              goto finished;
            }
          }
        }
        {
        tmp___2 = inc_cursor();
        }
        if (tmp___2 == -1) {
          return (0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      tmp___4 = cls();
      tmp___5 = skip_chars(tmp___4, 1);
      }
      if (tmp___5) {
        return (0);
      }
    }
    }
    }
    {
    dec_cursor();
    }
    finished: 
    stop = 0;
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
int bckend_word(long count___2 , int type , int eol ) 
{ 
  int sclass ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    i___0 = dec_cursor();
    }
    if (i___0 == -1) {
      return (0);
    }
    if (eol) {
      if (i___0 == 1) {
        return (1);
      }
    }
    if (sclass != 0) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
        tmp = cls();
        }
        if (! (tmp == sclass)) {
          goto while_break___0;
        }
        {
        i___0 = dec_cursor();
        }
        if (i___0 == -1) {
          return (1);
        } else { //Added block
        if (eol) {
          if (i___0 == 1) {
            return (1);
          }
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___1 = cls();
      }
      if (! (tmp___1 == 0)) {
        goto while_break___1;
      }
      if (curwin->w_cursor.col == 0U) {
        {
        tmp___0 = ml_get(curwin->w_cursor.lnum);
        }
        if ((int )*tmp___0 == 0) {
          goto while_break___1;
        }
      }
      {
      i___0 = dec_cursor();
      }
      if (i___0 == -1) {
        return (1);
      } else { //Added block
      if (eol) {
        if (i___0 == 1) {
          return (1);
        }
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int skip_chars(int cclass , int dir ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___2 = cls();
    }
    if (! (tmp___2 == cclass)) {
      goto while_break;
    }
    if (dir == 1) {
      {
      tmp = inc_cursor();
      tmp___1 = tmp;
      }
    } else {
      {
      tmp___0 = dec_cursor();
      tmp___1 = tmp___0;
      }
    }
    if (tmp___1 == -1) {
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static void back_in_line(void) 
{ 
  int sclass ;
  int tmp ;

  {
  {
  sclass = cls();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (! (curwin->w_cursor.col == 0U))) {
      goto while_break;
    }
    {
    (curwin->w_cursor.col) --;
    tmp = cls();
    }
    if (tmp != sclass) {
      (curwin->w_cursor.col) ++;
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void find_first_blank(FPOS *posp ) 
{ 
  int c ;
  int tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = decl(posp);
    }
    if (! (tmp != -1)) {
      goto while_break;
    }
    {
    c = gchar_pos(posp);
    }
    if (! (c == 32)) {
      if (! (c == 9)) {
        {
        incl(posp);
        }
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void findsent_forward(long count___2 , int at_start_sent ) 
{ 
  long tmp ;

  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = count___2;
    count___2 --;
    if (! tmp) {
      goto while_break;
    }
    {
    findsent(1, 1L);
    }
    if (at_start_sent) {
      {
      find_first_blank(& curwin->w_cursor);
      }
    }
    if (count___2 == 0L) {
      {
      decl(& curwin->w_cursor);
      }
    } else { //Added block
    if (at_start_sent) {
      {
      decl(& curwin->w_cursor);
      }
    }
    }
    at_start_sent = ! at_start_sent;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int current_word(OPARG *oap , long count___2 , int include , int type ) 
{ 
  FPOS start_pos ;
  FPOS pos___0 ;
  int inclusive ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  inclusive = 1;
  stype = type;
  if (VIsual_active) {
    if ((int )*p_sel == 101) {
      if (VIsual.lnum != curwin->w_cursor.lnum) {
        tmp = VIsual.lnum < curwin->w_cursor.lnum;
      } else {
        tmp = VIsual.col < curwin->w_cursor.col;
      }
      if (tmp) {
        {
        dec_cursor();
        }
      }
    }
  }
  if (! VIsual_active) {
    goto _L;
  } else { //Added block
  if (curwin->w_cursor.lnum == VIsual.lnum) {
    if (curwin->w_cursor.col == VIsual.col) {
      _L: 
      {
      back_in_line();
      start_pos = curwin->w_cursor;
      tmp___6 = cls();
      }
      if ((tmp___6 == 0) == include) {
        {
        tmp___0 = end_word(1L, type, 1, 1);
        }
        if (tmp___0 == 0) {
          return (0);
        }
      } else {
        {
        tmp___1 = fwd_word(1L, type, 1);
        }
        if (tmp___1 == 0) {
          return (0);
        }
        {
        tmp___5 = oneleft();
        }
        if (tmp___5 == 0) {
          inclusive = 0;
        } else { //Added block
        if (include) {
          {
          tmp___4 = cls();
          }
          if (tmp___4 != 0) {
            {
            pos___0 = curwin->w_cursor;
            curwin->w_cursor = start_pos;
            tmp___3 = oneleft();
            }
            if (tmp___3 == 1) {
              {
              back_in_line();
              tmp___2 = cls();
              }
              if (tmp___2 == 0) {
                if (curwin->w_cursor.col > 0U) {
                  start_pos = curwin->w_cursor;
                }
              }
            }
            curwin->w_cursor = pos___0;
          }
        }
        }
      }
      if (VIsual_active) {
        {
        VIsual = start_pos;
        VIsual_mode = 'v';
        update_curbuf(40);
        }
      } else {
        oap->start = start_pos;
        oap->motion_type = 0;
      }
      count___2 --;
    }
  }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (count___2 > 0L)) {
      goto while_break;
    }
    inclusive = 1;
    if (VIsual_active) {
      if (curwin->w_cursor.lnum != VIsual.lnum) {
        tmp___16 = curwin->w_cursor.lnum < VIsual.lnum;
      } else {
        tmp___16 = curwin->w_cursor.col < VIsual.col;
      }
      if (tmp___16) {
        {
        tmp___7 = decl(& curwin->w_cursor);
        }
        if (tmp___7 == -1) {
          return (0);
        }
        {
        tmp___10 = cls();
        }
        if (include != (tmp___10 != 0)) {
          {
          tmp___8 = bck_word(1L, type, 1);
          }
          if (tmp___8 == 0) {
            return (0);
          }
        } else {
          {
          tmp___9 = bckend_word(1L, type, 1);
          }
          if (tmp___9 == 0) {
            return (0);
          }
          {
          incl(& curwin->w_cursor);
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      {
      tmp___11 = incl(& curwin->w_cursor);
      }
      if (tmp___11 == -1) {
        return (0);
      }
      {
      tmp___15 = cls();
      }
      if (include != (tmp___15 == 0)) {
        {
        tmp___12 = fwd_word(1L, type, 1);
        }
        if (tmp___12 == 0) {
          return (0);
        }
        {
        tmp___13 = oneleft();
        }
        if (tmp___13 == 0) {
          inclusive = 0;
        }
      } else {
        {
        tmp___14 = end_word(1L, type, 1, 1);
        }
        if (tmp___14 == 0) {
          return (0);
        }
      }
    }
    count___2 --;
  }
  while_break: /* CIL Label */ ;
  }
  if (VIsual_active) {
    if ((int )*p_sel == 101) {
      if (inclusive) {
        if (VIsual.lnum != curwin->w_cursor.lnum) {
          tmp___17 = VIsual.lnum < curwin->w_cursor.lnum;
        } else {
          tmp___17 = VIsual.col < curwin->w_cursor.col;
        }
        if (tmp___17) {
          {
          inc_cursor();
          }
        }
      }
    }
  } else {
    oap->inclusive = inclusive;
  }
  return (1);
}
}
int current_sent(OPARG *oap , long count___2 , int include ) 
{ 
  FPOS start_pos ;
  FPOS pos___0 ;
  int start_blank ;
  int c ;
  int at_start_sent ;
  long ncount ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  start_pos = curwin->w_cursor;
  pos___0 = start_pos;
  findsent(1, 1L);
  }
  if (VIsual_active) {
    if (start_pos.lnum == VIsual.lnum) {
      if (! (start_pos.col == VIsual.col)) {
        goto extend;
      }
    } else {
      extend: 
      if (start_pos.lnum != VIsual.lnum) {
        tmp___2 = start_pos.lnum < VIsual.lnum;
      } else {
        tmp___2 = start_pos.col < VIsual.col;
      }
      if (tmp___2) {
        {
        at_start_sent = 1;
        decl(& pos___0);
        }
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (pos___0.lnum != curwin->w_cursor.lnum) {
            tmp = pos___0.lnum < curwin->w_cursor.lnum;
          } else {
            tmp = pos___0.col < curwin->w_cursor.col;
          }
          if (! tmp) {
            goto while_break;
          }
          {
          c = gchar_pos(& pos___0);
          }
          if (! (c == 32)) {
            if (! (c == 9)) {
              at_start_sent = 0;
              goto while_break;
            }
          }
          {
          incl(& pos___0);
          }
        }
        while_break: /* CIL Label */ ;
        }
        if (! at_start_sent) {
          {
          findsent(-1, 1L);
          }
          if (curwin->w_cursor.lnum == start_pos.lnum) {
            if (curwin->w_cursor.col == start_pos.col) {
              at_start_sent = 1;
            } else {
              {
              findsent(1, 1L);
              }
            }
          } else {
            {
            findsent(1, 1L);
            }
          }
        }
        if (include) {
          count___2 *= 2L;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          tmp___0 = count___2;
          count___2 --;
          if (! tmp___0) {
            goto while_break___0;
          }
          if (at_start_sent) {
            {
            find_first_blank(& curwin->w_cursor);
            }
          }
          {
          c = gchar_cursor();
          }
          if (! at_start_sent) {
            {
            findsent(-1, 1L);
            }
          } else { //Added block
          if (! include) {
            if (! (c == 32)) {
              if (! (c == 9)) {
                {
                findsent(-1, 1L);
                }
              }
            }
          }
          }
          at_start_sent = ! at_start_sent;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
        incl(& pos___0);
        at_start_sent = 1;
        }
        if (pos___0.lnum == curwin->w_cursor.lnum) {
          if (! (pos___0.col == curwin->w_cursor.col)) {
            goto _L;
          }
        } else {
          _L: 
          at_start_sent = 0;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (pos___0.lnum != curwin->w_cursor.lnum) {
              tmp___1 = pos___0.lnum < curwin->w_cursor.lnum;
            } else {
              tmp___1 = pos___0.col < curwin->w_cursor.col;
            }
            if (! tmp___1) {
              goto while_break___1;
            }
            {
            c = gchar_pos(& pos___0);
            }
            if (! (c == 32)) {
              if (! (c == 9)) {
                at_start_sent = 1;
                goto while_break___1;
              }
            }
            {
            incl(& pos___0);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          if (at_start_sent) {
            {
            findsent(-1, 1L);
            }
          } else {
            curwin->w_cursor = start_pos;
          }
        }
        if (include) {
          count___2 *= 2L;
        }
        {
        findsent_forward(count___2, at_start_sent);
        }
      }
      return (1);
    }
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
    c = gchar_pos(& pos___0);
    }
    if (c == 32) {
      tmp___3 = 1;
    } else { //Added block
    if (c == 9) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
    }
    if (! tmp___3) {
      goto while_break___2;
    }
    {
    incl(& pos___0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  if (pos___0.lnum == curwin->w_cursor.lnum) {
    if (pos___0.col == curwin->w_cursor.col) {
      {
      start_blank = 1;
      find_first_blank(& start_pos);
      }
    } else {
      {
      start_blank = 0;
      findsent(-1, 1L);
      start_pos = curwin->w_cursor;
      }
    }
  } else {
    {
    start_blank = 0;
    findsent(-1, 1L);
    start_pos = curwin->w_cursor;
    }
  }
  if (include) {
    ncount = count___2 * 2L;
  } else {
    ncount = count___2;
  }
  if (! include) {
    if (start_blank) {
      ncount --;
    }
  }
  if (ncount) {
    {
    findsent_forward(ncount, 1);
    }
  }
  if (include) {
    if (start_blank) {
      {
      find_first_blank(& curwin->w_cursor);
      }
    } else {
      {
      c = gchar_cursor();
      }
      if (c == 32) {
        tmp___4 = 0;
      } else { //Added block
      if (c == 9) {
        tmp___4 = 0;
      } else {
        tmp___4 = 1;
      }
      }
      if (tmp___4) {
        {
        find_first_blank(& start_pos);
        }
      }
    }
  }
  if (VIsual_active) {
    if (start_pos.lnum == curwin->w_cursor.lnum) {
      if (start_pos.col == curwin->w_cursor.col) {
        goto extend;
      }
    }
    {
    VIsual = start_pos;
    VIsual_mode = 'v';
    update_curbuf(40);
    }
  } else {
    {
    tmp___5 = incl(& curwin->w_cursor);
    }
    if (tmp___5 == -1) {
      oap->inclusive = 1;
    } else {
      oap->inclusive = 0;
    }
    oap->start = start_pos;
    oap->motion_type = 0;
  }
  return (1);
}
}
int current_block(OPARG *oap , long count___2 , int include , int what , int other ) 
{ 
  FPOS old_pos ;
  FPOS *pos___0 ;
  FPOS start_pos ;
  FPOS *end_pos ;
  FPOS old_start ;
  FPOS old_end ;
  char_u *save_cpo ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  pos___0 = (FPOS *)((void *)0);
  old_pos = curwin->w_cursor;
  old_end = curwin->w_cursor;
  old_start = old_end;
  if (! VIsual_active) {
    goto _L;
  } else { //Added block
  if (VIsual.lnum == curwin->w_cursor.lnum) {
    if (VIsual.col == curwin->w_cursor.col) {
      _L: 
      {
      setpcmark();
      }
      if (what == 123) {
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          {
          tmp___0 = inindent(1);
          }
          if (! tmp___0) {
            goto while_break;
          }
          {
          tmp = inc_cursor();
          }
          if (tmp != 0) {
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
      tmp___1 = gchar_cursor();
      }
      if (tmp___1 == what) {
        (curwin->w_cursor.col) ++;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (VIsual.lnum != curwin->w_cursor.lnum) {
      tmp___2 = VIsual.lnum < curwin->w_cursor.lnum;
    } else {
      tmp___2 = VIsual.col < curwin->w_cursor.col;
    }
    if (tmp___2) {
      old_start = VIsual;
      curwin->w_cursor = VIsual;
    } else {
      old_end = VIsual;
    }
  }
  }
  save_cpo = p_cpo;
  p_cpo = (char_u *)"%";
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    tmp___3 = count___2;
    count___2 --;
    if (! (tmp___3 > 0L)) {
      goto while_break___0;
    }
    {
    pos___0 = findmatch((OPARG *)((void *)0), what);
    }
    if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
      goto while_break___0;
    }
    curwin->w_cursor = *pos___0;
    start_pos = *pos___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  p_cpo = save_cpo;
  if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
    curwin->w_cursor = old_pos;
    return (0);
  } else {
    {
    end_pos = findmatch((OPARG *)((void *)0), other);
    }
    if ((unsigned long )end_pos == (unsigned long )((void *)0)) {
      curwin->w_cursor = old_pos;
      return (0);
    }
  }
  curwin->w_cursor = *end_pos;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (! include)) {
      goto while_break___1;
    }
    {
    incl(& start_pos);
    decl(& curwin->w_cursor);
    }
    if (what == 123) {
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
        tmp___5 = inindent(1);
        }
        if (! tmp___5) {
          goto while_break___2;
        }
        {
        tmp___4 = decl(& curwin->w_cursor);
        }
        if (tmp___4 != 0) {
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    if (start_pos.lnum != old_start.lnum) {
      tmp___6 = start_pos.lnum < old_start.lnum;
    } else {
      tmp___6 = start_pos.col < old_start.col;
    }
    if (tmp___6) {
      goto while_break___1;
    } else {
      if (old_end.lnum != curwin->w_cursor.lnum) {
        tmp___7 = old_end.lnum < curwin->w_cursor.lnum;
      } else {
        tmp___7 = old_end.col < curwin->w_cursor.col;
      }
      if (tmp___7) {
        goto while_break___1;
      } else { //Added block
      if (VIsual_active) {
        {
        curwin->w_cursor = old_start;
        decl(& curwin->w_cursor);
        pos___0 = findmatch((OPARG *)((void *)0), what);
        }
        if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
          curwin->w_cursor = old_pos;
          return (0);
        }
        {
        start_pos = *pos___0;
        curwin->w_cursor = *pos___0;
        end_pos = findmatch((OPARG *)((void *)0), other);
        }
        if ((unsigned long )end_pos == (unsigned long )((void *)0)) {
          curwin->w_cursor = old_pos;
          return (0);
        }
        curwin->w_cursor = *end_pos;
      } else {
        goto while_break___1;
      }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  if (VIsual_active) {
    if ((int )*p_sel == 101) {
      (curwin->w_cursor.col) ++;
    }
    {
    VIsual = start_pos;
    VIsual_mode = 'v';
    update_curbuf(40);
    showmode();
    }
  } else {
    oap->start = start_pos;
    oap->motion_type = 0;
    oap->inclusive = 1;
  }
  return (1);
}
}
int current_par(OPARG *oap , long count___2 , int include , int type ) 
{ 
  linenr_t start_lnum ;
  linenr_t end_lnum ;
  int white_in_front ;
  int dir ;
  int start_is_white ;
  int prev_start_is_white ;
  int retval ;
  int do_white ;
  int t ;
  int i___0 ;
  linenr_t tmp ;
  linenr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  linenr_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  retval = 1;
  do_white = 0;
  if (type == 83) {
    return (0);
  }
  start_lnum = curwin->w_cursor.lnum;
  if (VIsual_active) {
    if (start_lnum != VIsual.lnum) {
      extend: 
      if (start_lnum < VIsual.lnum) {
        dir = -1;
      } else {
        dir = 1;
      }
      i___0 = (int )count___2;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        i___0 --;
        if (! (i___0 >= 0)) {
          goto while_break;
        }
        if (dir == -1) {
          tmp = (linenr_t )1;
        } else {
          tmp = curbuf->b_ml.ml_line_count;
        }
        if (start_lnum == tmp) {
          retval = 0;
          goto while_break;
        }
        prev_start_is_white = -1;
        t = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (t < 2)) {
            goto while_break___0;
          }
          {
          start_lnum += (linenr_t )dir;
          start_is_white = linewhite(start_lnum);
          }
          if (prev_start_is_white == start_is_white) {
            start_lnum -= (linenr_t )dir;
            goto while_break___0;
          }
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (dir == -1) {
              tmp___0 = (linenr_t )1;
            } else {
              tmp___0 = curbuf->b_ml.ml_line_count;
            }
            if (start_lnum == tmp___0) {
              goto while_break___1;
            }
            {
            tmp___1 = linewhite(start_lnum + (linenr_t )dir);
            }
            if (start_is_white != tmp___1) {
              goto while_break___1;
            } else { //Added block
            if (! start_is_white) {
              if (dir > 0) {
                tmp___2 = 1;
              } else {
                tmp___2 = 0;
              }
              {
              tmp___3 = startPS(start_lnum + (linenr_t )tmp___2, 0, 0);
              }
              if (tmp___3) {
                goto while_break___1;
              }
            }
            }
            start_lnum += (linenr_t )dir;
          }
          while_break___1: /* CIL Label */ ;
          }
          if (! include) {
            goto while_break___0;
          }
          if (dir == -1) {
            tmp___4 = (linenr_t )1;
          } else {
            tmp___4 = curbuf->b_ml.ml_line_count;
          }
          if (start_lnum == tmp___4) {
            goto while_break___0;
          }
          prev_start_is_white = start_is_white;
          t ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
      curwin->w_cursor.lnum = start_lnum;
      curwin->w_cursor.col = (colnr_t )0;
      return (retval);
    }
  }
  {
  white_in_front = linewhite(start_lnum);
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (start_lnum > 1L)) {
      goto while_break___2;
    }
    if (white_in_front) {
      {
      tmp___5 = linewhite(start_lnum - 1L);
      }
      if (! tmp___5) {
        goto while_break___2;
      }
    } else {
      {
      tmp___6 = linewhite(start_lnum - 1L);
      }
      if (tmp___6) {
        goto while_break___2;
      } else {
        {
        tmp___7 = startPS(start_lnum, 0, 0);
        }
        if (tmp___7) {
          goto while_break___2;
        }
      }
    }
    start_lnum --;
  }
  while_break___2: /* CIL Label */ ;
  }
  end_lnum = start_lnum;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
    tmp___8 = linewhite(end_lnum);
    }
    if (tmp___8) {
      if (! (end_lnum < curbuf->b_ml.ml_line_count)) {
        goto while_break___3;
      }
    } else {
      goto while_break___3;
    }
    end_lnum ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  end_lnum --;
  i___0 = (int )count___2;
  if (! include) {
    if (white_in_front) {
      i___0 --;
    }
  }
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    tmp___12 = i___0;
    i___0 --;
    if (! tmp___12) {
      goto while_break___4;
    }
    if (end_lnum == curbuf->b_ml.ml_line_count) {
      return (0);
    }
    if (! include) {
      {
      do_white = linewhite(end_lnum + 1L);
      }
    }
    if (include) {
      goto _L;
    } else { //Added block
    if (! do_white) {
      _L: 
      end_lnum ++;
      {
      while (1) {
        while_continue___5: /* CIL Label */ ;
        if (end_lnum < curbuf->b_ml.ml_line_count) {
          {
          tmp___9 = linewhite(end_lnum + 1L);
          }
          if (tmp___9) {
            goto while_break___5;
          } else {
            {
            tmp___10 = startPS(end_lnum + 1L, 0, 0);
            }
            if (tmp___10) {
              goto while_break___5;
            }
          }
        } else {
          goto while_break___5;
        }
        end_lnum ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    }
    if (i___0 == 0) {
      if (white_in_front) {
        goto while_break___4;
      }
    }
    if (include) {
      goto _L___0;
    } else { //Added block
    if (do_white) {
      _L___0: 
      {
      while (1) {
        while_continue___6: /* CIL Label */ ;
        if (end_lnum < curbuf->b_ml.ml_line_count) {
          {
          tmp___11 = linewhite(end_lnum + 1L);
          }
          if (! tmp___11) {
            goto while_break___6;
          }
        } else {
          goto while_break___6;
        }
        end_lnum ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  if (! white_in_front) {
    {
    tmp___14 = linewhite(end_lnum);
    }
    if (! tmp___14) {
      if (include) {
        {
        while (1) {
          while_continue___7: /* CIL Label */ ;
          if (start_lnum > 1L) {
            {
            tmp___13 = linewhite(start_lnum - 1L);
            }
            if (! tmp___13) {
              goto while_break___7;
            }
          } else {
            goto while_break___7;
          }
          start_lnum --;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
  }
  if (VIsual_active) {
    if (VIsual_mode == 86) {
      if (start_lnum == curwin->w_cursor.lnum) {
        goto extend;
      }
    }
    {
    VIsual.lnum = start_lnum;
    VIsual_mode = 'V';
    update_curbuf(40);
    showmode();
    }
  } else {
    oap->start.lnum = start_lnum;
    oap->motion_type = 1;
  }
  curwin->w_cursor.lnum = end_lnum;
  curwin->w_cursor.col = (colnr_t )0;
  return (1);
}
}
int linewhite(linenr_t lnum ) 
{ 
  char_u *p___0 ;
  char_u *tmp ;

  {
  {
  tmp = ml_get(lnum);
  p___0 = skipwhite(tmp);
  }
  return ((int )*p___0 == 0);
}
}
void find_pattern_in_path(char_u *ptr , int dir , int len___0 , int whole , int skip_comments ,
                          int type , long count___2 , int action , linenr_t start_lnum ,
                          linenr_t end_lnum ) 
{ 
  SearchedFile *files ;
  SearchedFile *bigger ;
  int max_path_depth ;
  long match_count ;
  char_u *pat ;
  int pat_reg_ic ;
  char_u *new_fname ;
  char_u *curr_fname ;
  char_u *prev_fname ;
  linenr_t lnum ;
  int depth___1 ;
  int depth_displayed ;
  int old_files ;
  int already_searched ;
  char_u *file_line ;
  char_u *line ;
  char_u *p___0 ;
  char_u save_char ;
  int define_matched ;
  vim_regexp *prog ;
  vim_regexp *include_prog ;
  vim_regexp *define_prog ;
  int matched ;
  int did_show ;
  int found ;
  int i___0 ;
  char_u *already ;
  char_u *startp ;
  char const   *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  FILE *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int reuse ;
  int add_r ;
  char_u *aux ;
  int tmp___18 ;
  char_u *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char_u *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char_u *tmp___28 ;
  char_u *tmp___29 ;
  long tmp___30 ;
  linenr_t *tmp___31 ;
  FILE *tmp___32 ;
  linenr_t *tmp___33 ;
  FILE *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
  {
  max_path_depth = 50;
  match_count = 1L;
  pat_reg_ic = 0;
  curr_fname = curbuf->b_fname;
  prev_fname = (char_u *)((void *)0);
  prog = (vim_regexp *)((void *)0);
  include_prog = (vim_regexp *)((void *)0);
  define_prog = (vim_regexp *)((void *)0);
  matched = 0;
  did_show = 0;
  found = 0;
  already = (char_u *)((void *)0);
  startp = (char_u *)((void *)0);
  file_line = alloc(512U);
  }
  if ((unsigned long )file_line == (unsigned long )((void *)0)) {
    return;
  }
  if (type != 3) {
    if (type != 2) {
      if (! (continue_status & 16)) {
        {
        pat = alloc((unsigned int )(len___0 + 5));
        }
        if ((unsigned long )pat == (unsigned long )((void *)0)) {
          goto fpip_end;
        }
        if (whole) {
          tmp = "\\<%.*s\\>";
        } else {
          tmp = "%.*s";
        }
        {
        sprintf((char * __restrict  )((char *)pat), (char const   * __restrict  )tmp,
                len___0, ptr);
        set_reg_ic(pat);
        pat_reg_ic = reg_ic;
        prog = vim_regcomp(pat, p_magic);
        vim_free((void *)pat);
        }
        if ((unsigned long )prog == (unsigned long )((void *)0)) {
          goto fpip_end;
        }
      }
    }
  }
  if ((int )*p_inc != 0) {
    {
    include_prog = vim_regcomp(p_inc, p_magic);
    }
    if ((unsigned long )include_prog == (unsigned long )((void *)0)) {
      goto fpip_end;
    }
  }
  if (type == 2) {
    if ((int )*p_def != 0) {
      {
      define_prog = vim_regcomp(p_def, p_magic);
      }
      if ((unsigned long )define_prog == (unsigned long )((void *)0)) {
        goto fpip_end;
      }
    }
  }
  {
  tmp___0 = lalloc((unsigned long )max_path_depth * sizeof(SearchedFile ), 1);
  files = (SearchedFile *)tmp___0;
  }
  if ((unsigned long )files == (unsigned long )((void *)0)) {
    goto fpip_end;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < max_path_depth)) {
      goto while_break;
    }
    (files + i___0)->fp = (FILE *)((void *)0);
    (files + i___0)->name = (char_u *)((void *)0);
    (files + i___0)->lnum = (linenr_t )0;
    (files + i___0)->matched = 0;
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  old_files = max_path_depth;
  depth_displayed = -1;
  depth___1 = depth_displayed;
  lnum = start_lnum;
  if (end_lnum > curbuf->b_ml.ml_line_count) {
    end_lnum = curbuf->b_ml.ml_line_count;
  }
  if (lnum > end_lnum) {
    lnum = end_lnum;
  }
  {
  line = ml_get(lnum);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    reg_ic = 0;
    if ((unsigned long )include_prog != (unsigned long )((void *)0)) {
      {
      tmp___17 = vim_regexec(include_prog, line, 1);
      }
      if (tmp___17) {
        {
        new_fname = get_file_name_in_path(include_prog->endp[0] + 1, 0, 2, 1L);
        already_searched = 0;
        }
        if ((unsigned long )new_fname != (unsigned long )((void *)0)) {
          i___0 = 0;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (i___0 == depth___1 + 1) {
              i___0 = old_files;
            }
            if (i___0 == max_path_depth) {
              goto while_break___1;
            }
            {
            tmp___1 = strcmp((char const   *)((char *)new_fname), (char const   *)((char *)(files + i___0)->name));
            }
            if (tmp___1 == 0) {
              if (type != 3) {
                if (action == 4) {
                  if ((files + i___0)->matched) {
                    {
                    msg_putchar('\n');
                    }
                    if (! got_int) {
                      {
                      msg_home_replace_hl(new_fname);
                      msg_puts((char_u *)" (includes previously listed match)");
                      prev_fname = (char_u *)((void *)0);
                      }
                    }
                  }
                }
              }
              {
              vim_free((void *)new_fname);
              new_fname = (char_u *)((void *)0);
              already_searched = 1;
              }
              goto while_break___1;
            }
            i___0 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
        if (type == 3) {
          if (action == 4) {
            goto _L;
          } else { //Added block
          if ((unsigned long )new_fname == (unsigned long )((void *)0)) {
            if (! already_searched) {
              _L: 
              if (did_show) {
                {
                msg_putchar('\n');
                }
              } else {
                {
                gotocmdline(1);
                msg_puts_title((char_u *)"--- Included files ");
                }
                if (action != 4) {
                  {
                  msg_puts_title((char_u *)"not found ");
                  }
                }
                {
                msg_puts_title((char_u *)"in path ---\n");
                }
              }
              did_show = 1;
              {
              while (1) {
                while_continue___2: /* CIL Label */ ;
                if (depth_displayed < depth___1) {
                  if (! (! got_int)) {
                    goto while_break___2;
                  }
                } else {
                  goto while_break___2;
                }
                depth_displayed ++;
                i___0 = 0;
                {
                while (1) {
                  while_continue___3: /* CIL Label */ ;
                  if (! (i___0 < depth_displayed)) {
                    goto while_break___3;
                  }
                  {
                  msg_puts((char_u *)"  ");
                  i___0 ++;
                  }
                }
                while_break___3: /* CIL Label */ ;
                }
                {
                msg_home_replace((files + depth_displayed)->name);
                msg_puts((char_u *)" -->\n");
                }
              }
              while_break___2: /* CIL Label */ ;
              }
              if (! got_int) {
                i___0 = 0;
                {
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  if (! (i___0 <= depth_displayed)) {
                    goto while_break___4;
                  }
                  {
                  msg_puts((char_u *)"  ");
                  i___0 ++;
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
                p___0 = include_prog->endp[0] + 1;
                {
                while (1) {
                  while_continue___5: /* CIL Label */ ;
                  {
                  tmp___2 = vim_isfilec((int )*p___0);
                  }
                  if (tmp___2) {
                    goto while_break___5;
                  }
                  p___0 ++;
                }
                while_break___5: /* CIL Label */ ;
                }
                i___0 = 0;
                {
                while (1) {
                  while_continue___6: /* CIL Label */ ;
                  {
                  tmp___3 = vim_isfilec((int )*(p___0 + i___0));
                  }
                  if (! tmp___3) {
                    goto while_break___6;
                  }
                  i___0 ++;
                }
                while_break___6: /* CIL Label */ ;
                }
                if ((int )*(p___0 + -1) == 34) {
                  p___0 --;
                  i___0 ++;
                } else { //Added block
                if ((int )*(p___0 + -1) == 60) {
                  p___0 --;
                  i___0 ++;
                }
                }
                if ((int )*(p___0 + i___0) == 34) {
                  i___0 ++;
                } else { //Added block
                if ((int )*(p___0 + i___0) == 62) {
                  i___0 ++;
                }
                }
                {
                save_char = *(p___0 + i___0);
                *(p___0 + i___0) = (char_u )'\000';
                msg_outtrans_attr(p___0, highlight_attr[2]);
                *(p___0 + i___0) = save_char;
                }
                if ((unsigned long )new_fname == (unsigned long )((void *)0)) {
                  if (action == 4) {
                    if (already_searched) {
                      {
                      msg_puts((char_u *)"  (Already listed)");
                      }
                    } else {
                      {
                      msg_puts((char_u *)"  NOT FOUND");
                      }
                    }
                  }
                }
              }
              {
              out_flush();
              }
            }
          }
          }
        }
        if ((unsigned long )new_fname != (unsigned long )((void *)0)) {
          if (depth___1 + 1 == old_files) {
            {
            tmp___4 = lalloc((unsigned long )(max_path_depth * 2) * sizeof(SearchedFile ),
                             1);
            bigger = (SearchedFile *)tmp___4;
            }
            if ((unsigned long )bigger != (unsigned long )((void *)0)) {
              i___0 = 0;
              {
              while (1) {
                while_continue___7: /* CIL Label */ ;
                if (! (i___0 <= depth___1)) {
                  goto while_break___7;
                }
                *(bigger + i___0) = *(files + i___0);
                i___0 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
              i___0 = depth___1 + 1;
              {
              while (1) {
                while_continue___8: /* CIL Label */ ;
                if (! (i___0 < old_files + max_path_depth)) {
                  goto while_break___8;
                }
                (bigger + i___0)->fp = (FILE *)((void *)0);
                (bigger + i___0)->name = (char_u *)((void *)0);
                (bigger + i___0)->lnum = (linenr_t )0;
                (bigger + i___0)->matched = 0;
                i___0 ++;
              }
              while_break___8: /* CIL Label */ ;
              }
              i___0 = old_files;
              {
              while (1) {
                while_continue___9: /* CIL Label */ ;
                if (! (i___0 < max_path_depth)) {
                  goto while_break___9;
                }
                *(bigger + (i___0 + max_path_depth)) = *(files + i___0);
                i___0 ++;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
              old_files += max_path_depth;
              max_path_depth *= 2;
              vim_free((void *)files);
              files = bigger;
              }
            }
          }
          {
          tmp___5 = fopen((char const   * __restrict  )((char *)new_fname), (char const   * __restrict  )"r");
          (files + (depth___1 + 1))->fp = tmp___5;
          }
          if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
            {
            vim_free((void *)new_fname);
            }
          } else {
            depth___1 ++;
            if (depth___1 == old_files) {
              {
              vim_free((void *)(files + old_files)->name);
              old_files ++;
              }
            }
            curr_fname = new_fname;
            (files + depth___1)->name = curr_fname;
            (files + depth___1)->lnum = (linenr_t )0;
            (files + depth___1)->matched = 0;
            if (action == 5) {
              {
              sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Scanning included file: %s",
                      (char *)new_fname);
              msg_trunc_attr(IObuff, 1, highlight_attr[10]);
              }
            }
          }
        }
      } else {
        goto _L___8;
      }
    } else {
      _L___8: 
      p___0 = line;
      search_line: 
      define_matched = 0;
      reg_ic = 0;
      if ((unsigned long )define_prog != (unsigned long )((void *)0)) {
        {
        tmp___7 = vim_regexec(define_prog, line, 1);
        }
        if (tmp___7) {
          p___0 = define_prog->endp[0] + 1;
          {
          while (1) {
            while_continue___10: /* CIL Label */ ;
            if (*p___0) {
              {
              tmp___6 = vim_isIDc((int )*p___0);
              }
              if (tmp___6) {
                goto while_break___10;
              }
            } else {
              goto while_break___10;
            }
            p___0 ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          define_matched = 1;
        }
      }
      if ((unsigned long )define_prog == (unsigned long )((void *)0)) {
        goto _L___7;
      } else { //Added block
      if (define_matched) {
        _L___7: 
        reg_ic = pat_reg_ic;
        if (define_matched) {
          goto _L___6;
        } else { //Added block
        if (continue_status & 16) {
          _L___6: 
          {
          startp = skipwhite(p___0);
          }
          if (p_ic) {
            {
            tmp___8 = strncasecmp((char const   *)((char *)startp), (char const   *)((char *)ptr),
                                  (size_t )len___0);
            }
            if (tmp___8) {
              tmp___9 = 0;
            } else {
              tmp___9 = 1;
            }
            matched = tmp___9;
          } else {
            {
            tmp___10 = strncmp((char const   *)((char *)startp), (char const   *)((char *)ptr),
                               (size_t )len___0);
            }
            if (tmp___10) {
              tmp___11 = 0;
            } else {
              tmp___11 = 1;
            }
            matched = tmp___11;
          }
          if (matched) {
            if (define_matched) {
              if (whole) {
                {
                tmp___12 = vim_isIDc((int )*(startp + len___0));
                }
                if (tmp___12) {
                  matched = 0;
                }
              }
            }
          }
        } else { //Added block
        if (prog) {
          {
          tmp___16 = vim_regexec(prog, p___0, (unsigned long )p___0 == (unsigned long )line);
          }
          if (tmp___16) {
            matched = 1;
            startp = prog->startp[0];
            if (! define_matched) {
              if (skip_comments) {
                fo_do_comments = 1;
                if ((int )*line != 35) {
                  goto _L___0;
                } else {
                  {
                  tmp___13 = skipwhite(line + 1);
                  tmp___14 = strncmp((char const   *)((char *)tmp___13), (char const   *)((char *)"define"),
                                     (size_t )6);
                  }
                  if (tmp___14 != 0) {
                    _L___0: 
                    {
                    tmp___15 = get_leader_len(line, (char_u **)((void *)0), 0);
                    }
                    if (tmp___15) {
                      matched = 0;
                    }
                  }
                }
                {
                p___0 = skipwhite(line);
                }
                if (matched) {
                  goto _L___4;
                } else { //Added block
                if ((int )*(p___0 + 0) == 47) {
                  if ((int )*(p___0 + 1) == 42) {
                    goto _L___4;
                  } else {
                    goto _L___5;
                  }
                } else { //Added block
                _L___5: 
                if ((int )*(p___0 + 0) == 42) {
                  _L___4: 
                  p___0 = line;
                  {
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
                    if (*p___0) {
                      if (! ((unsigned long )p___0 < (unsigned long )startp)) {
                        goto while_break___11;
                      }
                    } else {
                      goto while_break___11;
                    }
                    if (matched) {
                      if ((int )*(p___0 + 0) == 47) {
                        if ((int )*(p___0 + 1) == 42) {
                          goto _L___2;
                        } else { //Added block
                        if ((int )*(p___0 + 1) == 47) {
                          _L___2: 
                          matched = 0;
                          if ((int )*(p___0 + 1) == 47) {
                            goto while_break___11;
                          }
                          p___0 ++;
                        } else {
                          goto _L___3;
                        }
                        }
                      } else {
                        goto _L___3;
                      }
                    } else { //Added block
                    _L___3: 
                    if (! matched) {
                      if ((int )*(p___0 + 0) == 42) {
                        if ((int )*(p___0 + 1) == 47) {
                          matched = 1;
                          p___0 ++;
                        }
                      }
                    }
                    }
                    p___0 ++;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                }
                }
                }
                fo_do_comments = 0;
              }
            }
          }
        }
        }
        }
      }
      }
    }
    if (matched) {
      if (action == 5) {
        reuse = 0;
        if (depth___1 == -1) {
          if (lnum == curwin->w_cursor.lnum) {
            goto while_break___0;
          }
        }
        found = 1;
        p___0 = startp;
        aux = p___0;
        if (continue_status & 1) {
          {
          p___0 += completion_length;
          tmp___18 = vim_iswordc((int )*p___0);
          }
          if (tmp___18) {
            goto exit_matched;
          }
          {
          while (1) {
            while_continue___12: /* CIL Label */ ;
            if (*p___0) {
              if ((int )*p___0 != 10) {
                {
                tmp___19 = p___0;
                p___0 ++;
                tmp___20 = vim_iswordc((int )*tmp___19);
                }
                if (tmp___20) {
                  goto while_break___12;
                }
              } else {
                goto while_break___12;
              }
            } else {
              goto while_break___12;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
        }
        {
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
          tmp___21 = vim_iswordc((int )*p___0);
          }
          if (! tmp___21) {
            goto while_break___13;
          }
          p___0 ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        i___0 = (int )(p___0 - aux);
        if (continue_status & 1) {
          if (i___0 == completion_length) {
            {
            strncpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)aux),
                    (size_t )i___0);
            }
            if (depth___1 < 0) {
              if (lnum < end_lnum) {
                {
                lnum ++;
                line = ml_get(lnum);
                }
                if (! ((unsigned long )line != (unsigned long )((void *)0))) {
                  goto _L___10;
                }
              } else {
                goto _L___10;
              }
            } else { //Added block
            _L___10: 
            if (depth___1 >= 0) {
              {
              line = file_line;
              tmp___22 = vim_fgets(line, 512, (files + depth___1)->fp);
              }
              if (tmp___22) {
                goto exit_matched;
              }
            } else {
              goto exit_matched;
            }
            }
            {
            p___0 = skipwhite(line);
            aux = p___0;
            already = aux;
            }
            {
            while (1) {
              while_continue___14: /* CIL Label */ ;
              if (*p___0) {
                if ((int )*p___0 != 10) {
                  {
                  tmp___23 = p___0;
                  p___0 ++;
                  tmp___24 = vim_iswordc((int )*tmp___23);
                  }
                  if (tmp___24) {
                    goto while_break___14;
                  }
                } else {
                  goto while_break___14;
                }
              } else {
                goto while_break___14;
              }
            }
            while_break___14: /* CIL Label */ ;
            }
            {
            while (1) {
              while_continue___15: /* CIL Label */ ;
              {
              tmp___25 = vim_iswordc((int )*p___0);
              }
              if (! tmp___25) {
                goto while_break___15;
              }
              p___0 ++;
            }
            while_break___15: /* CIL Label */ ;
            }
            if ((unsigned long )p___0 > (unsigned long )aux) {
              if ((int )*aux != 41) {
                if ((int )*(IObuff + (i___0 - 1)) != 9) {
                  if ((int )*(IObuff + (i___0 - 1)) != 32) {
                    tmp___26 = i___0;
                    i___0 ++;
                    *(IObuff + tmp___26) = (char_u )' ';
                  }
                  if (p_js) {
                    if ((int )*(IObuff + (i___0 - 2)) == 46) {
                      tmp___27 = i___0;
                      i___0 ++;
                      *(IObuff + tmp___27) = (char_u )' ';
                    } else {
                      {
                      tmp___28 = vim_strchr(p_cpo, 'j');
                      }
                      if ((unsigned long )tmp___28 == (unsigned long )((void *)0)) {
                        if ((int )*(IObuff + (i___0 - 2)) == 63) {
                          tmp___27 = i___0;
                          i___0 ++;
                          *(IObuff + tmp___27) = (char_u )' ';
                        } else { //Added block
                        if ((int )*(IObuff + (i___0 - 2)) == 33) {
                          tmp___27 = i___0;
                          i___0 ++;
                          *(IObuff + tmp___27) = (char_u )' ';
                        }
                        }
                      }
                    }
                  }
                }
              }
              if (p___0 - aux >= (long )(1025 - i___0)) {
                p___0 = ((aux + 1025) - i___0) - 1;
              }
              {
              strncpy((char * __restrict  )((char *)(IObuff + i___0)), (char const   * __restrict  )((char *)aux),
                      (size_t )(p___0 - aux));
              i___0 = (int )((long )i___0 + (p___0 - aux));
              reuse |= 8;
              }
            }
            *(IObuff + i___0) = (char_u )'\000';
            aux = IObuff;
            if (i___0 == completion_length) {
              goto exit_matched;
            }
          }
        }
        if ((unsigned long )curr_fname == (unsigned long )curbuf->b_fname) {
          tmp___29 = (char_u *)((void *)0);
        } else {
          tmp___29 = curr_fname;
        }
        {
        add_r = ins_compl_add_infercase(aux, i___0, tmp___29, dir, reuse);
        }
        if (add_r == 1) {
          dir = 1;
        } else { //Added block
        if (add_r == -1) {
          goto while_break___0;
        }
        }
      } else { //Added block
      if (action == 4) {
        found = 1;
        if (! did_show) {
          {
          gotocmdline(1);
          }
        }
        if ((unsigned long )curr_fname != (unsigned long )prev_fname) {
          if (did_show) {
            {
            msg_putchar('\n');
            }
          }
          if (! got_int) {
            {
            msg_home_replace_hl(curr_fname);
            }
          }
          prev_fname = curr_fname;
        }
        did_show = 1;
        if (! got_int) {
          tmp___30 = match_count;
          match_count ++;
          if (depth___1 == -1) {
            tmp___31 = & lnum;
          } else {
            tmp___31 = & (files + depth___1)->lnum;
          }
          if (depth___1 == -1) {
            tmp___32 = (FILE *)((void *)0);
          } else {
            tmp___32 = (files + depth___1)->fp;
          }
          {
          show_pat_in_path(line, type, 1, action, tmp___32, tmp___31, tmp___30);
          }
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___16: /* CIL Label */ ;
          if (! (i___0 <= depth___1)) {
            goto while_break___16;
          }
          (files + i___0)->matched = 1;
          i___0 ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      } else {
        count___2 --;
        if (count___2 <= 0L) {
          found = 1;
          if (depth___1 == -1) {
            if (lnum == curwin->w_cursor.lnum) {
              {
              emsg((char_u *)"Match is on current line");
              }
            } else {
              goto _L___11;
            }
          } else { //Added block
          _L___11: 
          if (action == 1) {
            if (depth___1 == -1) {
              tmp___33 = & lnum;
            } else {
              tmp___33 = & (files + depth___1)->lnum;
            }
            if (depth___1 == -1) {
              tmp___34 = (FILE *)((void *)0);
            } else {
              tmp___34 = (files + depth___1)->fp;
            }
            {
            show_pat_in_path(line, type, did_show, action, tmp___34, tmp___33, 1L);
            did_show = 1;
            }
          } else {
            if (action == 3) {
              {
              tmp___35 = win_split(0, 0, 0);
              }
              if (tmp___35 == 0) {
                goto while_break___0;
              }
            }
            if (depth___1 == -1) {
              {
              setpcmark();
              curwin->w_cursor.lnum = lnum;
              }
            } else {
              {
              tmp___36 = getfile(0, (files + depth___1)->name, (char_u *)((void *)0),
                                 1, (files + depth___1)->lnum, 0);
              }
              if (tmp___36 > 0) {
                goto while_break___0;
              }
              curwin->w_cursor.lnum = (files + depth___1)->lnum;
            }
          }
          }
          if (action != 1) {
            curwin->w_cursor.col = (colnr_t )(startp - line);
            curwin->w_set_curswant = 1;
          }
          goto while_break___0;
        }
      }
      }
      exit_matched: 
      matched = 0;
      if ((unsigned long )define_prog == (unsigned long )((void *)0)) {
        if (action == 5) {
          if (! (continue_status & 16)) {
            p___0 = startp + 1;
            if (*p___0) {
              goto search_line;
            }
          }
        }
      }
    }
    {
    line_breakcheck();
    }
    if (action == 5) {
      {
      ins_compl_check_keys();
      }
    }
    if (got_int) {
      goto while_break___0;
    } else { //Added block
    if (completion_interrupted) {
      goto while_break___0;
    }
    }
    {
    while (1) {
      while_continue___17: /* CIL Label */ ;
      if (depth___1 >= 0) {
        if (! already) {
          {
          line = file_line;
          tmp___37 = vim_fgets(line, 512, (files + depth___1)->fp);
          }
          if (! tmp___37) {
            goto while_break___17;
          }
        } else {
          goto while_break___17;
        }
      } else {
        goto while_break___17;
      }
      {
      fclose((files + depth___1)->fp);
      old_files --;
      (files + old_files)->name = (files + depth___1)->name;
      (files + old_files)->matched = (files + depth___1)->matched;
      depth___1 --;
      }
      if (depth___1 == -1) {
        curr_fname = curbuf->b_fname;
      } else {
        curr_fname = (files + depth___1)->name;
      }
      if (depth___1 < depth_displayed) {
        depth_displayed = depth___1;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    if (depth___1 >= 0) {
      ((files + depth___1)->lnum) ++;
    } else { //Added block
    if (! already) {
      lnum ++;
      if (lnum > end_lnum) {
        goto while_break___0;
      }
      {
      line = ml_get(lnum);
      }
    }
    }
    already = (char_u *)((void *)0);
  }
  while_break___0: /* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___18: /* CIL Label */ ;
    if (! (i___0 <= depth___1)) {
      goto while_break___18;
    }
    {
    fclose((files + i___0)->fp);
    vim_free((void *)(files + i___0)->name);
    i___0 ++;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
  i___0 = old_files;
  {
  while (1) {
    while_continue___19: /* CIL Label */ ;
    if (! (i___0 < max_path_depth)) {
      goto while_break___19;
    }
    {
    vim_free((void *)(files + i___0)->name);
    i___0 ++;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  {
  vim_free((void *)files);
  }
  if (type == 3) {
    if (! did_show) {
      if (action != 4) {
        {
        msg((char_u *)"All included files were found");
        }
      } else {
        {
        msg((char_u *)"No included files");
        }
      }
    }
  } else { //Added block
  if (! found) {
    if (action != 5) {
      if (got_int) {
        {
        emsg(e_interr);
        }
      } else { //Added block
      if (completion_interrupted) {
        {
        emsg(e_interr);
        }
      } else { //Added block
      if (type == 2) {
        {
        emsg((char_u *)"Couldn\'t find definition");
        }
      } else {
        {
        emsg((char_u *)"Couldn\'t find pattern");
        }
      }
      }
      }
    }
  }
  }
  if (action == 1) {
    {
    msg_end();
    }
  } else { //Added block
  if (action == 4) {
    {
    msg_end();
    }
  }
  }
  fpip_end: 
  {
  vim_free((void *)file_line);
  }
  if (! (continue_status & 16)) {
    {
    vim_free((void *)prog);
    }
  }
  {
  vim_free((void *)include_prog);
  vim_free((void *)define_prog);
  }
  return;
}
}
static void show_pat_in_path(char_u *line , int type , int did_show , int action ,
                             FILE *fp___0 , linenr_t *lnum , long count___2 ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  if (did_show) {
    {
    msg_putchar('\n');
    }
  } else {
    {
    gotocmdline(1);
    }
  }
  if (got_int) {
    return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = strlen((char const   *)((char *)line));
    p___0 = (line + tmp) - 1;
    }
    if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
      if ((unsigned long )p___0 >= (unsigned long )line) {
        if ((int )*p___0 == 10) {
          p___0 --;
        }
      }
      if ((unsigned long )p___0 >= (unsigned long )line) {
        if ((int )*p___0 == 13) {
          p___0 --;
        }
      }
      *(p___0 + 1) = (char_u )'\000';
    }
    if (action == 4) {
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%3ld: ",
              count___2);
      msg_puts(IObuff);
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%4ld",
              *lnum);
      msg_puts_attr(IObuff, highlight_attr[9]);
      msg_puts((char_u *)" ");
      }
    }
    {
    msg_prt_line(line);
    out_flush();
    }
    if (got_int) {
      goto while_break;
    } else { //Added block
    if (type != 2) {
      goto while_break;
    } else { //Added block
    if ((unsigned long )p___0 < (unsigned long )line) {
      goto while_break;
    } else { //Added block
    if ((int )*p___0 != 92) {
      goto while_break;
    }
    }
    }
    }
    if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
      {
      tmp___0 = vim_fgets(line, 512, fp___0);
      }
      if (tmp___0) {
        goto while_break;
      }
      (*lnum) ++;
    } else {
      (*lnum) ++;
      if (*lnum > curbuf->b_ml.ml_line_count) {
        goto while_break;
      }
      {
      line = ml_get(*lnum);
      }
    }
    {
    msg_putchar('\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int hlsearch_on  =    0;
int read_viminfo_search_pattern(char_u *line , FILE *fp___0 , int force ) 
{ 
  char_u *lp ;
  int idx ;
  int magic ;
  int no_scs ;
  int off_line ;
  int off_end ;
  long off___0 ;
  int setlast ;
  char_u *val ;
  int tmp ;

  {
  idx = -1;
  magic = 0;
  no_scs = 0;
  off_line = 0;
  off_end = 0;
  off___0 = 0L;
  setlast = 0;
  lp = line;
  if ((int )*(lp + 0) == 126) {
    if ((int )*(lp + 1) == 109) {
      goto _L;
    } else { //Added block
    if ((int )*(lp + 1) == 77) {
      _L: 
      if ((int )*(lp + 1) == 77) {
        magic = 1;
      }
      if ((int )*(lp + 2) == 115) {
        no_scs = 1;
      }
      if ((int )*(lp + 3) == 76) {
        off_line = 1;
      }
      if ((int )*(lp + 4) == 69) {
        off_end = 1;
      }
      {
      lp += 5;
      off___0 = getdigits(& lp);
      }
    }
    }
  }
  if ((int )*(lp + 0) == 126) {
    setlast = 1;
    lp ++;
  }
  if ((int )*(lp + 0) == 47) {
    idx = 0;
  } else { //Added block
  if ((int )*(lp + 0) == 38) {
    idx = 1;
  } else { //Added block
  if ((int )*(lp + 0) == 104) {
    hlsearch_on = 0;
  } else { //Added block
  if ((int )*(lp + 0) == 72) {
    hlsearch_on = 1;
  }
  }
  }
  }
  if (idx >= 0) {
    if (force) {
      goto _L___0;
    } else { //Added block
    if ((unsigned long )spats[idx].pat == (unsigned long )((void *)0)) {
      _L___0: 
      {
      val = viminfo_readstring(lp + 1, fp___0);
      }
      if ((unsigned long )val != (unsigned long )((void *)0)) {
        {
        set_last_search_pat(val, idx, magic, setlast);
        vim_free((void *)val);
        spats[idx].no_scs = no_scs;
        spats[idx].off.line = off_line;
        spats[idx].off.end = off_end;
        spats[idx].off.off = off___0;
        }
        if (setlast) {
          no_hlsearch = ! hlsearch_on;
        }
      }
    }
    }
  }
  {
  tmp = vim_fgets(line, 512, fp___0);
  }
  return (tmp);
}
}
void write_viminfo_search_pattern(FILE *fp___0 ) 
{ 
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp___2 = get_viminfo_parameter('/');
  }
  if (tmp___2 != 0) {
    if (no_hlsearch) {
      tmp___0 = 'h';
    } else {
      {
      tmp___1 = find_viminfo_parameter('h');
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        tmp___0 = 'h';
      } else {
        tmp___0 = 'H';
      }
    }
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# hlsearch on (H) or off (h):\n~%c",
            tmp___0);
    wvsp_one(fp___0, 0, (char *)"", '/');
    wvsp_one(fp___0, 1, (char *)"Substitute ", '&');
    }
  }
  return;
}
}
static void wvsp_one(FILE *fp___0 , int idx , char *s , int sc ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned long )spats[idx].pat != (unsigned long )((void *)0)) {
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# Last %sSearch Pattern:\n~",
            s);
    }
    if (last_idx == idx) {
      tmp = "~";
    } else {
      tmp = "";
    }
    if (spats[idx].off.end) {
      tmp___0 = 'E';
    } else {
      tmp___0 = 'e';
    }
    if (spats[idx].off.line) {
      tmp___1 = 'L';
    } else {
      tmp___1 = 'l';
    }
    if (spats[idx].no_scs) {
      tmp___2 = 's';
    } else {
      tmp___2 = 'S';
    }
    if (spats[idx].magic) {
      tmp___3 = 'M';
    } else {
      tmp___3 = 'm';
    }
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"%c%c%c%c%ld%s%c",
            tmp___3, tmp___2, tmp___1, tmp___0, spats[idx].off.off, tmp, sc);
    viminfo_writestring(fp___0, spats[idx].pat);
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-aNPjgWpH.i","-O0")
int syn_check_group(char_u *pp , int len___0 ) ;
static struct growarray highlight_ga  ;
static int include_link  =    0;
static char *hl_name_table[7]  = {      (char *)"bold",      (char *)"standout",      (char *)"underline",      (char *)"italic", 
        (char *)"reverse",      (char *)"inverse",      (char *)"NONE"};
static int hl_attr_table[7]  = {      2,      16,      8,      4, 
        1,      1,      0};
static int get_attr_entry(struct growarray *table , struct attr_entry *aep ) ;
static int syn_namen2id(char_u *linep , int len___0 ) ;
static void syn_unadd_group(void) ;
static void set_hl_attr(int idx ) ;
static void highlight_list_one(int id ) ;
static int highlight_list_arg(int id , int didh , int type , int iarg , char_u *sarg ,
                              char *name___1 ) ;
static int syn_add_group(char_u *name___1 ) ;
static int syn_list_header(int did_header , int outlen , int id ) ;
static int hl_has_settings(int idx , int check_link ) ;
static void highlight_clear(int idx ) ;
static char *spo_name_tab[7]  = {      (char *)"ms=",      (char *)"me=",      (char *)"hs=",      (char *)"he=", 
        (char *)"rs=",      (char *)"re=",      (char *)"lc="};
static int current_attr  =    0;
static int current_id  =    0;
static int current_trans_id  =    0;
static char_u **syn_cmdlinep  ;
static int current_syn_inc_tag  =    0;
static int running_syn_inc_tag  =    0;
static int keepend_level  =    -1;
static int next_match_col  ;
static int next_match_m_endcol  ;
static int next_match_h_startcol  ;
static int next_match_h_endcol  ;
static int next_match_idx  ;
static int next_match_flags  ;
static int next_match_eos_col  ;
static int next_match_eoe_col  ;
static int next_match_end_idx  ;
static BUF *syn_buf  ;
static linenr_t current_lnum  =    (linenr_t )0;
static int current_state_stored  =    0;
static colnr_t current_col  =    (colnr_t )0;
static int current_finished  =    0;
static struct growarray current_state  =    {0, 0, 0, 0, (void *)0};
static short *current_next_list  =    (short *)((void *)0);
static int current_next_flags  =    0;
static int current_line_id  =    0;
static void syn_sync(WIN *wp , linenr_t start_lnum ) ;
static int syn_match_linecont(linenr_t lnum ) ;
static void syn_start_line(void) ;
static void syn_free_all_states(BUF *buf___3 ) ;
static void syn_clear_states(int start___0 , int end ) ;
static void store_current_state(void) ;
static void invalidate_current_state(void) ;
static void validate_current_state(void) ;
static void copy_state_to_current(struct syn_state *from ) ;
static void move_state(int from , int to ) ;
static int syn_finish_line(int syncing ) ;
static int syn_current_attr(int syncing , char_u *line ) ;
static int did_match_already(int idx ) ;
static struct state_item *push_next_match(struct state_item *cur_si , char_u *line ) ;
static void check_state_ends(char_u *line ) ;
static void update_si_attr(int idx ) ;
static void check_keepend(void) ;
static void update_si_end(struct state_item *sip , char_u *line , int startcol ) ;
static short *copy_id_list(short *list ) ;
static int in_id_list(short *list , int id , int inctag , int contained ) ;
static int syn_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) ;
static int push_current(int idx ) ;
static void pop_current(void) ;
static char_u *find_endp(int idx , char_u *sstart , int at_bol , char_u **hl_endp ,
                         int *flagsp , char_u **end_endp , int *end_idx ) ;
static char_u *syn_add_end_off(struct syn_pattern *spp , int idx , int extra ) ;
static char_u *syn_add_start_off(struct syn_pattern *spp , int idx , int extra ) ;
static int check_keyword_id(char_u *line , int startcol , int *endcol , int *flags___0 ,
                            short **next_list , struct state_item *cur_si ) ;
static void syn_cmd_case(EXARG *eap , int syncing ) ;
static void syntax_sync_clear(void) ;
static void syn_remove_pattern(BUF *buf___3 , int idx ) ;
static void syn_clear_pattern(BUF *buf___3 , int i___0 ) ;
static void syn_clear_cluster(BUF *buf___3 , int i___0 ) ;
static void syn_cmd_clear(EXARG *eap , int syncing ) ;
static void syn_clear_one(int id , int syncing ) ;
static void syn_cmd_on(EXARG *eap , int syncing ) ;
static void syn_cmd_manual(EXARG *eap , int syncing ) ;
static void syn_cmd_off(EXARG *eap , int syncing ) ;
static void syn_cmd_onoff(EXARG *eap , char *name___1 ) ;
static void syn_cmd_list(EXARG *eap , int syncing ) ;
static void syn_lines_msg(void) ;
static void syn_list_one(int id , int syncing , int link_only ) ;
static void syn_list_cluster(int id ) ;
static void put_id_list(char_u *name___1 , short *list , int attr ) ;
static void put_pattern(char *s , int c , struct syn_pattern *spp , int attr ) ;
static int syn_list_keywords(int id , struct keyentry **ktabp , int did_header , int attr ) ;
static void syn_clear_keyword(int id , struct keyentry **ktabp ) ;
static void free_keywtab(struct keyentry **ktabp ) ;
static void add_keyword(char_u *name___1 , int id , int flags___0 , short *next_list ) ;
static char_u *get_group_name(char_u *arg , char_u **name_end ) ;
static char_u *get_syn_options(char_u *arg , int *flagsp , int keyword , int *sync_idx ,
                               short **cont_list , short **next_list ) ;
static void syn_cmd_include(EXARG *eap , int syncing ) ;
static void syn_cmd_keyword(EXARG *eap , int syncing ) ;
static void syn_cmd_match(EXARG *eap , int syncing ) ;
static void syn_cmd_region(EXARG *eap , int syncing ) ;
static int syn_compare_stub(void const   *v1 , void const   *v2 ) ;
static void syn_cmd_cluster(EXARG *eap , int syncing ) ;
static int syn_scl_name2id(char_u *name___1 ) ;
static int syn_scl_namen2id(char_u *linep , int len___0 ) ;
static int syn_check_cluster(char_u *pp , int len___0 ) ;
static int syn_add_cluster(char_u *name___1 ) ;
static void init_syn_patterns(void) ;
static char_u *get_syn_pattern(char_u *arg , struct syn_pattern *ci ) ;
static void syn_cmd_sync(EXARG *eap , int syncing ) ;
static int get_id_list(char_u **arg , int keylen , short **list ) ;
static void syn_combine_list(short **clstr1 , short **clstr2 , int list_op ) ;
static void syn_incl_toplevel(int id , int *flagsp ) ;
void syntax_start(WIN *wp , linenr_t lnum ) 
{ 
  long to ;
  long from ;
  long first___0 ;
  long diff ;
  int idx ;
  char_u *tmp ;

  {
  reg_syn = 1;
  if ((unsigned long )syn_buf != (unsigned long )wp->w_buffer) {
    {
    invalidate_current_state();
    syn_buf = wp->w_buffer;
    }
  }
  if ((long )syn_buf->b_syn_states_len != Rows + 10L) {
    {
    syn_free_all_states(syn_buf);
    tmp = alloc_clear((unsigned int )((int )((unsigned long )(Rows + 10L) * sizeof(struct syn_state ))));
    syn_buf->b_syn_states = (struct syn_state *)tmp;
    }
    if ((unsigned long )syn_buf->b_syn_states == (unsigned long )((void *)0)) {
      syn_buf->b_syn_states_len = 0;
      goto theend;
    }
    syn_buf->b_syn_states_len = (int )(Rows + 10L);
    syn_buf->b_syn_states_lnum = (linenr_t )0;
    syn_buf->b_syn_change_lnum = (linenr_t )2147483647;
  }
  if (syn_buf->b_syn_change_lnum != 2147483647L) {
    if (syn_buf->b_syn_change_lnum < (syn_buf->b_syn_states_lnum + (linenr_t )syn_buf->b_syn_states_len) - 1L) {
      if (syn_buf->b_syn_change_lnum < syn_buf->b_syn_states_lnum) {
        idx = 0;
      } else {
        idx = (int )((syn_buf->b_syn_change_lnum - syn_buf->b_syn_states_lnum) + 1L);
      }
      {
      syn_clear_states(idx, syn_buf->b_syn_states_len);
      }
    }
    if (syn_buf->b_syn_change_lnum <= current_lnum) {
      {
      invalidate_current_state();
      }
    }
    syn_buf->b_syn_change_lnum = (linenr_t )2147483647;
  }
  if (wp->w_topline < syn_buf->b_syn_states_lnum) {
    to = (long )(syn_buf->b_syn_states_len - 1);
    if (wp->w_topline > 10L) {
      first___0 = wp->w_topline - 10L;
    } else {
      first___0 = 0L;
    }
    from = to - (syn_buf->b_syn_states_lnum - first___0);
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (from >= 0L)) {
        goto while_break;
      }
      {
      move_state((int )from, (int )to);
      from --;
      to --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    syn_clear_states(0, (int )(to + 1L));
    syn_buf->b_syn_states_lnum = first___0;
    }
  } else {
    diff = (wp->w_topline + (linenr_t )wp->w_height) - (syn_buf->b_syn_states_lnum + (linenr_t )syn_buf->b_syn_states_len);
    if (diff > 0L) {
      to = 0L;
      from = to + diff;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! (from < (long )syn_buf->b_syn_states_len)) {
          goto while_break___0;
        }
        {
        move_state((int )from, (int )to);
        from ++;
        to ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      syn_clear_states((int )to, syn_buf->b_syn_states_len);
      syn_buf->b_syn_states_lnum += diff;
      }
    }
  }
  if (current_state.ga_itemsize != 0) {
    if (current_lnum < lnum) {
      if (current_lnum >= syn_buf->b_syn_states_lnum) {
        if (current_lnum < syn_buf->b_syn_states_lnum + (linenr_t )syn_buf->b_syn_states_len) {
          if (current_lnum < syn_buf->b_ml.ml_line_count) {
            {
            syn_finish_line(0);
            }
            if (! current_state_stored) {
              {
              current_lnum ++;
              store_current_state();
              }
            }
            if (current_lnum != lnum) {
              {
              invalidate_current_state();
              }
            }
          } else {
            {
            invalidate_current_state();
            }
          }
        } else {
          {
          invalidate_current_state();
          }
        }
      } else {
        {
        invalidate_current_state();
        }
      }
    } else {
      {
      invalidate_current_state();
      }
    }
  } else {
    {
    invalidate_current_state();
    }
  }
  if (current_state.ga_itemsize == 0) {
    diff = syn_buf->b_syn_sync_minlines;
    if (diff < Rows * 2L) {
      diff = Rows * 2L;
    }
    if (lnum >= syn_buf->b_syn_states_lnum) {
      if (lnum <= (syn_buf->b_syn_states_lnum + (linenr_t )syn_buf->b_syn_states_len) + diff) {
        idx = (int )(lnum - syn_buf->b_syn_states_lnum);
        if (idx >= syn_buf->b_syn_states_len) {
          idx = syn_buf->b_syn_states_len - 1;
        }
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! (idx >= 0)) {
            goto while_break___1;
          }
          if ((syn_buf->b_syn_states + idx)->sst_ga.ga_itemsize != 0) {
            {
            current_lnum = syn_buf->b_syn_states_lnum + (linenr_t )idx;
            copy_state_to_current(syn_buf->b_syn_states + idx);
            }
            goto while_break___1;
          }
          idx --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  if (current_state.ga_itemsize == 0) {
    {
    syn_sync(wp, lnum);
    }
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (current_lnum < lnum)) {
      goto while_break___2;
    }
    {
    syn_start_line();
    syn_finish_line(0);
    current_lnum ++;
    store_current_state();
    line_breakcheck();
    }
    if (got_int) {
      current_lnum = lnum;
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  syn_start_line();
  }
  theend: 
  reg_syn = 0;
  return;
}
}
static void syn_sync(WIN *wp , linenr_t start_lnum ) 
{ 
  BUF *curbuf_save ;
  WIN *curwin_save ;
  FPOS cursor_save ;
  int idx ;
  linenr_t lnum ;
  linenr_t end_lnum ;
  linenr_t break_lnum ;
  int had_sync_point ;
  struct state_item *cur_si ;
  struct syn_pattern *spp ;
  char_u *line ;
  int found_flags ;
  int found_match_idx ;
  linenr_t found_current_lnum ;
  int found_current_col ;
  colnr_t found_m_endcol ;
  size_t tmp ;
  int tmp___0 ;
  FPOS *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  {
  found_flags = 0;
  found_match_idx = 0;
  found_current_lnum = (linenr_t )0;
  found_current_col = 0;
  found_m_endcol = (colnr_t )0;
  invalidate_current_state();
  start_lnum -= syn_buf->b_syn_sync_minlines + 10L;
  }
  if (start_lnum < 1L) {
    start_lnum = (linenr_t )1;
  }
  current_lnum = start_lnum;
  if (syn_buf->b_syn_sync_flags & 1) {
    curwin_save = curwin;
    curwin = wp;
    curbuf_save = curbuf;
    curbuf = syn_buf;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (start_lnum > 1L)) {
        goto while_break;
      }
      {
      line = ml_get(start_lnum - 1L);
      }
      if ((int )*line == 0) {
        goto while_break;
      } else {
        {
        tmp = strlen((char const   *)((char *)line));
        }
        if ((int )*((line + tmp) - 1) != 92) {
          goto while_break;
        }
      }
      start_lnum --;
    }
    while_break: /* CIL Label */ ;
    }
    {
    current_lnum = start_lnum;
    cursor_save = wp->w_cursor;
    wp->w_cursor.lnum = start_lnum;
    wp->w_cursor.col = (colnr_t )0;
    tmp___1 = find_start_comment((int )syn_buf->b_syn_sync_maxlines);
    }
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      idx = syn_buf->b_syn_patterns.ga_len;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        idx --;
        if (! (idx >= 0)) {
          goto while_break___0;
        }
        if ((int )((struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + idx)->sp_syn_id == (int )syn_buf->b_syn_sync_id) {
          if ((int )((struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + idx)->sp_type == 2) {
            {
            validate_current_state();
            tmp___0 = push_current(idx);
            }
            if (tmp___0 == 1) {
              {
              update_si_attr(current_state.ga_len - 1);
              }
            }
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    wp->w_cursor = cursor_save;
    curwin = curwin_save;
    curbuf = curbuf_save;
  } else { //Added block
  if (syn_buf->b_syn_sync_flags & 2) {
    if (syn_buf->b_syn_sync_maxlines) {
      if (start_lnum > syn_buf->b_syn_sync_maxlines) {
        break_lnum = start_lnum - syn_buf->b_syn_sync_maxlines;
      } else {
        break_lnum = (linenr_t )0;
      }
    } else {
      break_lnum = (linenr_t )0;
    }
    end_lnum = start_lnum;
    lnum = start_lnum;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      lnum --;
      if (! (lnum > break_lnum)) {
        goto while_break___1;
      }
      {
      line_breakcheck();
      }
      if (got_int) {
        {
        invalidate_current_state();
        current_lnum = start_lnum;
        }
        goto while_break___1;
      }
      if (lnum > 1L) {
        {
        tmp___2 = syn_match_linecont(lnum - 1L);
        }
        if (tmp___2) {
          goto while_continue___1;
        }
      }
      {
      validate_current_state();
      current_lnum = lnum;
      }
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (current_lnum < end_lnum)) {
          goto while_break___2;
        }
        {
        syn_start_line();
        }
        {
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
          had_sync_point = syn_finish_line(1);
          }
          if (had_sync_point) {
            if (current_state.ga_len) {
              cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
              spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + cur_si->si_idx;
              found_flags = (int )spp->sp_flags;
              found_match_idx = spp->sp_sync_idx;
              found_current_lnum = current_lnum;
              found_current_col = (int )current_col;
              found_m_endcol = (colnr_t )cur_si->si_m_endcol;
              if (found_m_endcol > current_col) {
                current_col = found_m_endcol;
              } else {
                current_col ++;
              }
              {
              current_col ++;
              tmp___3 = ml_get_buf(syn_buf, current_lnum, 0);
              check_state_ends(tmp___3);
              current_col --;
              }
            } else {
              goto while_break___3;
            }
          } else {
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        current_lnum ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      if (found_flags) {
        {
        ga_clear(& current_state);
        }
        if (found_match_idx >= 0) {
          {
          tmp___4 = push_current(found_match_idx);
          }
          if (tmp___4 == 1) {
            {
            update_si_attr(current_state.ga_len - 1);
            }
          }
        }
        if (found_flags & 16) {
          if (current_state.ga_len) {
            {
            cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
            cur_si->si_h_startcol = found_current_col;
            line = ml_get_buf(syn_buf, current_lnum, 0);
            update_si_end(cur_si, line, (int )current_col);
            }
          }
          {
          current_col = found_m_endcol;
          current_lnum = found_current_lnum;
          syn_finish_line(0);
          current_lnum ++;
          }
        } else {
          current_lnum = start_lnum;
        }
        goto while_break___1;
      }
      {
      end_lnum = lnum;
      invalidate_current_state();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    if (lnum <= break_lnum) {
      {
      invalidate_current_state();
      current_lnum = break_lnum + 1L;
      }
    }
  }
  }
  {
  validate_current_state();
  }
  return;
}
}
static int syn_match_linecont(linenr_t lnum ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )syn_buf->b_syn_linecont_prog != (unsigned long )((void *)0)) {
    {
    reg_ic = syn_buf->b_syn_linecont_ic;
    tmp = ml_get_buf(syn_buf, lnum, 0);
    tmp___0 = syn_regexec(syn_buf->b_syn_linecont_prog, tmp, 1);
    }
    return (tmp___0);
  }
  return (0);
}
}
static void syn_start_line(void) 
{ 
  char_u *line ;
  struct state_item *cur_si ;
  int i___0 ;

  {
  current_finished = 0;
  current_col = (colnr_t )0;
  if (current_state.ga_len) {
    {
    line = ml_get_buf(syn_buf, current_lnum, 0);
    i___0 = 0;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < current_state.ga_len)) {
        goto while_break;
      }
      cur_si = (struct state_item *)current_state.ga_data + i___0;
      if (cur_si->si_flags & 1024) {
        {
        cur_si->si_h_startcol = 0;
        update_si_end(cur_si, line, 0);
        }
      } else { //Added block
      if (i___0 == current_state.ga_len - 1) {
        {
        cur_si->si_h_startcol = 0;
        update_si_end(cur_si, line, 0);
        }
      }
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    check_state_ends(line);
    }
  }
  next_match_idx = -1;
  current_line_id ++;
  return;
}
}
static void syn_free_all_states(BUF *buf___3 ) 
{ 
  int idx ;

  {
  if ((unsigned long )buf___3->b_syn_states != (unsigned long )((void *)0)) {
    idx = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (idx < buf___3->b_syn_states_len)) {
        goto while_break;
      }
      {
      ga_clear(& (buf___3->b_syn_states + idx)->sst_ga);
      idx ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)buf___3->b_syn_states);
    buf___3->b_syn_states = (struct syn_state *)((void *)0);
    buf___3->b_syn_states_len = 0;
    }
  }
  return;
}
}
static void syn_clear_states(int start___0 , int end ) 
{ 
  int idx ;
  struct growarray *sp ;

  {
  idx = start___0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (idx < end)) {
      goto while_break;
    }
    {
    sp = & (syn_buf->b_syn_states + idx)->sst_ga;
    ga_clear(sp);
    sp->ga_itemsize = 0;
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void store_current_state(void) 
{ 
  long idx ;
  int i___0 ;
  struct growarray *to ;
  int tmp ;

  {
  idx = current_lnum - syn_buf->b_syn_states_lnum;
  if (idx >= 0L) {
    if (idx < (long )syn_buf->b_syn_states_len) {
      to = & (syn_buf->b_syn_states + idx)->sst_ga;
      if ((unsigned long )to->ga_data != (unsigned long )((void *)0)) {
        {
        ga_clear(to);
        }
      } else { //Added block
      if (to->ga_itemsize == 0) {
        to->ga_itemsize = (int )sizeof(struct buf_state );
        to->ga_growsize = 3;
      }
      }
      if (current_state.ga_len) {
        {
        tmp = ga_grow(to, current_state.ga_len);
        }
        if (tmp != 0) {
          i___0 = 0;
          {
          while (1) {
            while_continue: /* CIL Label */ ;
            if (! (i___0 < current_state.ga_len)) {
              goto while_break;
            }
            ((struct buf_state *)to->ga_data + i___0)->bs_idx = ((struct state_item *)current_state.ga_data + i___0)->si_idx;
            ((struct buf_state *)to->ga_data + i___0)->bs_flags = ((struct state_item *)current_state.ga_data + i___0)->si_flags;
            i___0 ++;
          }
          while_break: /* CIL Label */ ;
          }
          to->ga_len = current_state.ga_len;
          to->ga_room -= to->ga_len;
        }
      }
      (syn_buf->b_syn_states + idx)->sst_next_list = current_next_list;
      (syn_buf->b_syn_states + idx)->sst_next_flags = current_next_flags;
    }
  }
  current_state_stored = 1;
  return;
}
}
static void copy_state_to_current(struct syn_state *from ) 
{ 
  int i___0 ;
  struct growarray *ga ;
  int tmp ;

  {
  {
  ga = & from->sst_ga;
  ga_clear(& current_state);
  validate_current_state();
  keepend_level = -1;
  }
  if (ga->ga_len) {
    {
    tmp = ga_grow(& current_state, ga->ga_len);
    }
    if (tmp != 0) {
      i___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < ga->ga_len)) {
          goto while_break;
        }
        ((struct state_item *)current_state.ga_data + i___0)->si_idx = ((struct buf_state *)ga->ga_data + i___0)->bs_idx;
        ((struct state_item *)current_state.ga_data + i___0)->si_flags = ((struct buf_state *)ga->ga_data + i___0)->bs_flags;
        if (keepend_level < 0) {
          if (((struct state_item *)current_state.ga_data + i___0)->si_flags & 1024) {
            keepend_level = i___0;
          }
        }
        {
        ((struct state_item *)current_state.ga_data + i___0)->si_m_endcol = 0;
        ((struct state_item *)current_state.ga_data + i___0)->si_m_startcol = 0;
        ((struct state_item *)current_state.ga_data + i___0)->si_m_lnum = 0;
        ((struct state_item *)current_state.ga_data + i___0)->si_next_list = ((struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + ((struct state_item *)current_state.ga_data + i___0)->si_idx)->sp_next_list;
        update_si_attr(i___0);
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      current_state.ga_len = ga->ga_len;
      current_state.ga_room -= current_state.ga_len;
    }
  }
  current_next_list = from->sst_next_list;
  current_next_flags = from->sst_next_flags;
  return;
}
}
static void invalidate_current_state(void) 
{ 


  {
  {
  ga_clear(& current_state);
  current_state.ga_itemsize = 0;
  current_next_list = (short *)((void *)0);
  keepend_level = -1;
  }
  return;
}
}
static void validate_current_state(void) 
{ 


  {
  current_state.ga_itemsize = (int )sizeof(struct state_item );
  current_state.ga_growsize = 3;
  return;
}
}
static void move_state(int from , int to ) 
{ 


  {
  {
  ga_clear(& (syn_buf->b_syn_states + to)->sst_ga);
  *(syn_buf->b_syn_states + to) = *(syn_buf->b_syn_states + from);
  ga_init(& (syn_buf->b_syn_states + from)->sst_ga);
  (syn_buf->b_syn_states + from)->sst_ga.ga_itemsize = 0;
  }
  return;
}
}
void syn_changed(linenr_t lnum ) 
{ 


  {
  if (curbuf->b_syn_change_lnum > lnum) {
    curbuf->b_syn_change_lnum = lnum;
  }
  return;
}
}
int syntax_check_changed(linenr_t lnum ) 
{ 
  struct growarray *ssp ;
  int i___0 ;
  int retval ;
  long idx ;

  {
  retval = 1;
  reg_syn = 1;
  idx = lnum - syn_buf->b_syn_states_lnum;
  if (current_state.ga_itemsize != 0) {
    if (lnum == current_lnum + 1L) {
      if (idx >= 0L) {
        if (idx < (long )syn_buf->b_syn_states_len) {
          if (lnum < syn_buf->b_syn_change_lnum) {
            {
            syn_finish_line(0);
            ssp = & (syn_buf->b_syn_states + idx)->sst_ga;
            }
            if (ssp->ga_itemsize != 0) {
              if (ssp->ga_len == current_state.ga_len) {
                if ((unsigned long )(syn_buf->b_syn_states + idx)->sst_next_list == (unsigned long )current_next_list) {
                  i___0 = current_state.ga_len;
                  {
                  while (1) {
                    while_continue: /* CIL Label */ ;
                    i___0 --;
                    if (! (i___0 >= 0)) {
                      goto while_break;
                    }
                    if (((struct buf_state *)ssp->ga_data + i___0)->bs_idx != ((struct state_item *)current_state.ga_data + i___0)->si_idx) {
                      goto while_break;
                    }
                  }
                  while_break: /* CIL Label */ ;
                  }
                  if (i___0 < 0) {
                    retval = 0;
                  }
                }
              }
            }
            {
            current_lnum ++;
            store_current_state();
            }
          }
        }
      }
    }
  }
  reg_syn = 0;
  if (retval) {
    {
    syn_changed(lnum);
    }
  }
  return (retval);
}
}
static int syn_finish_line(int syncing ) 
{ 
  char_u *line ;
  struct state_item *cur_si ;

  {
  if (! current_finished) {
    {
    line = ml_get_buf(syn_buf, current_lnum, 0);
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (! current_finished)) {
        goto while_break;
      }
      {
      syn_current_attr(syncing, line);
      }
      if (syncing) {
        if (current_state.ga_len) {
          cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
          if ((int )((struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + cur_si->si_idx)->sp_flags & 48) {
            return (1);
          }
          {
          current_col ++;
          check_state_ends(line);
          current_col --;
          }
        }
      }
      current_col ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return (0);
}
}
int get_syntax_attr(colnr_t col , char_u *line ) 
{ 
  int attr ;

  {
  attr = 0;
  if (syn_buf->b_syn_states_len == 0) {
    return (0);
  }
  reg_syn = 1;
  if (current_state.ga_itemsize == 0) {
    {
    validate_current_state();
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (current_col <= col)) {
      goto while_break;
    }
    {
    attr = syn_current_attr(0, line);
    current_col ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  reg_syn = 0;
  return (attr);
}
}
static int try_next_column  =    0;
static int syn_current_attr(int syncing , char_u *line ) 
{ 
  int syn_id ;
  char_u *endp ;
  char_u *hl_endp ;
  char_u *eoep ;
  int end_idx ;
  int idx ;
  struct syn_pattern *spp ;
  struct state_item *cur_si ;
  struct state_item *sip ;
  int startcol ;
  int hl_startcol ;
  int eos_col ;
  int endcol ;
  int flags___0 ;
  short *next_list ;
  int found_match ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int lc_col ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  hl_endp = (char_u *)((void *)0);
  if ((int )*(line + current_col) == 0) {
    if (current_col != 0U) {
      if (next_match_idx >= 0) {
        if (next_match_col >= (int )current_col) {
          if (next_match_col != 2147483647) {
            {
            push_next_match((struct state_item *)((void *)0), line);
            }
          }
        }
      }
      current_finished = 1;
      current_state_stored = 0;
      return (0);
    }
  }
  if ((int )*(line + current_col) == 0) {
    current_finished = 1;
    current_state_stored = 0;
  } else { //Added block
  if ((int )*((line + current_col) + 1) == 0) {
    current_finished = 1;
    current_state_stored = 0;
  }
  }
  if (try_next_column) {
    next_match_idx = -1;
    try_next_column = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    found_match = 0;
    syn_id = 0;
    if (current_state.ga_len) {
      cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
    } else {
      cur_si = (struct state_item *)((void *)0);
    }
    if ((unsigned long )cur_si == (unsigned long )((void *)0)) {
      goto _L___8;
    } else { //Added block
    if ((unsigned long )cur_si->si_cont_list != (unsigned long )((void *)0)) {
      _L___8: 
      if (! syncing) {
        if ((unsigned long )syn_buf->b_keywtab != (unsigned long )((void *)0)) {
          goto _L___0;
        } else { //Added block
        if ((unsigned long )syn_buf->b_keywtab_ic != (unsigned long )((void *)0)) {
          _L___0: 
          {
          tmp___0 = vim_iswordc_buf((int )*(line + current_col), syn_buf);
          }
          if (tmp___0) {
            if (current_col == 0U) {
              goto _L;
            } else {
              {
              tmp___1 = vim_iswordc_buf((int )*(line + (current_col - 1U)), syn_buf);
              }
              if (! tmp___1) {
                _L: 
                {
                syn_id = check_keyword_id(line, (int )current_col, & endcol, & flags___0,
                                          & next_list, cur_si);
                }
                if (syn_id) {
                  {
                  tmp = push_current(-1);
                  }
                  if (tmp == 1) {
                    cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
                    cur_si->si_m_startcol = (int )current_col;
                    cur_si->si_h_startcol = 0;
                    cur_si->si_m_endcol = endcol;
                    cur_si->si_h_endcol = endcol;
                    cur_si->si_ends = 1;
                    cur_si->si_end_idx = 0;
                    cur_si->si_flags = flags___0;
                    cur_si->si_id = syn_id;
                    cur_si->si_trans_id = syn_id;
                    if (flags___0 & 2) {
                      if (current_state.ga_len < 2) {
                        cur_si->si_attr = 0;
                        cur_si->si_trans_id = 0;
                      } else {
                        cur_si->si_attr = ((struct state_item *)current_state.ga_data + (current_state.ga_len - 2))->si_attr;
                        cur_si->si_trans_id = ((struct state_item *)current_state.ga_data + (current_state.ga_len - 2))->si_trans_id;
                      }
                    } else {
                      {
                      cur_si->si_attr = syn_id2attr(syn_id);
                      }
                    }
                    {
                    cur_si->si_cont_list = (short *)((void *)0);
                    cur_si->si_next_list = next_list;
                    check_keepend();
                    }
                  } else {
                    {
                    vim_free((void *)next_list);
                    }
                  }
                }
              }
            }
          }
        }
        }
      }
      if (syn_id == 0) {
        if (syn_buf->b_syn_patterns.ga_len) {
          if (next_match_idx < 0) {
            goto _L___7;
          } else { //Added block
          if (next_match_col < (int )current_col) {
            _L___7: 
            next_match_idx = 0;
            next_match_col = 2147483647;
            idx = syn_buf->b_syn_patterns.ga_len;
            {
            while (1) {
              while_continue___0: /* CIL Label */ ;
              idx --;
              if (! (idx >= 0)) {
                goto while_break___0;
              }
              spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + idx;
              if ((int )spp->sp_syncing == syncing) {
                if ((int )spp->sp_type == 1) {
                  goto _L___6;
                } else { //Added block
                if ((int )spp->sp_type == 2) {
                  _L___6: 
                  if ((unsigned long )current_next_list != (unsigned long )((short *)0)) {
                    {
                    tmp___6 = in_id_list(current_next_list, (int )spp->sp_syn_id,
                                         spp->sp_syn_inc_tag, 0);
                    }
                    if (tmp___6) {
                      goto _L___3;
                    } else {
                      goto _L___5;
                    }
                  } else { //Added block
                  _L___5: 
                  if ((unsigned long )current_next_list == (unsigned long )((short *)0)) {
                    if ((unsigned long )cur_si == (unsigned long )((void *)0)) {
                      if (! ((int )spp->sp_flags & 1)) {
                        goto _L___3;
                      } else {
                        goto _L___4;
                      }
                    } else { //Added block
                    _L___4: 
                    if ((unsigned long )cur_si != (unsigned long )((void *)0)) {
                      {
                      tmp___7 = in_id_list(cur_si->si_cont_list, (int )spp->sp_syn_id,
                                           spp->sp_syn_inc_tag, (int )spp->sp_flags & 1);
                      }
                      if (tmp___7) {
                        _L___3: 
                        if (spp->sp_line_id == current_line_id) {
                          if (spp->sp_startcol >= next_match_col) {
                            goto __Cont;
                          }
                        }
                        spp->sp_line_id = current_line_id;
                        lc_col = (int )(current_col - (colnr_t )spp->sp_offsets[6]);
                        if (lc_col < 0) {
                          lc_col = 0;
                        }
                        {
                        reg_ic = spp->sp_ic;
                        tmp___2 = syn_regexec(spp->sp_prog, line + lc_col, lc_col == 0);
                        }
                        if (! tmp___2) {
                          spp->sp_startcol = 2147483647;
                          goto __Cont;
                        }
                        {
                        tmp___3 = syn_add_start_off(spp, 0, -1);
                        startcol = (int )(tmp___3 - line);
                        }
                        if (startcol < 0) {
                          startcol = 0;
                        }
                        spp->sp_startcol = startcol;
                        if (startcol >= next_match_col) {
                          goto __Cont;
                        }
                        {
                        tmp___4 = did_match_already(idx);
                        }
                        if (tmp___4) {
                          try_next_column = 1;
                          goto __Cont;
                        }
                        {
                        endp = (spp->sp_prog)->endp[0];
                        tmp___5 = syn_add_start_off(spp, 2, -1);
                        hl_startcol = (int )(tmp___5 - line);
                        }
                        if ((int )spp->sp_off_flags & (1 << 4)) {
                          eos_col = (int )((((spp->sp_prog)->startp[0] - line) + (long )spp->sp_offsets[4]) - 1L);
                        } else {
                          eos_col = (int )(((endp - line) - 1L) + (long )spp->sp_offsets[4]);
                        }
                        flags___0 = 0;
                        eoep = line;
                        end_idx = 0;
                        if ((int )spp->sp_type == 2) {
                          if ((int )spp->sp_flags & 4) {
                            {
                            endp = find_endp(idx, endp, (unsigned long )endp == (unsigned long )line,
                                             & hl_endp, & flags___0, & eoep, & end_idx);
                            }
                          } else {
                            goto _L___1;
                          }
                        } else { //Added block
                        _L___1: 
                        if ((int )spp->sp_type == 1) {
                          {
                          hl_endp = syn_add_end_off(spp, 3, 0);
                          endp = syn_add_end_off(spp, 1, 0);
                          }
                          if ((unsigned long )(endp + syncing) <= (unsigned long )(line + startcol)) {
                            if ((unsigned long )(spp->sp_prog)->startp[0] == (unsigned long )(spp->sp_prog)->endp[0]) {
                              try_next_column = 1;
                            }
                            goto __Cont;
                          }
                        }
                        }
                        if ((unsigned long )endp != (unsigned long )((void *)0)) {
                          if (hl_startcol < startcol) {
                            hl_startcol = startcol;
                          }
                          if ((unsigned long )hl_endp == (unsigned long )((void *)0)) {
                            hl_endp = endp;
                          } else { //Added block
                          if ((unsigned long )hl_endp > (unsigned long )endp) {
                            hl_endp = endp;
                          }
                          }
                          next_match_idx = idx;
                          next_match_col = startcol;
                          next_match_m_endcol = (int )(endp - line);
                          next_match_h_endcol = (int )(hl_endp - line);
                          next_match_h_startcol = hl_startcol;
                          next_match_flags = flags___0;
                          next_match_eos_col = eos_col;
                          next_match_eoe_col = (int )(eoep - line);
                          next_match_end_idx = end_idx;
                        }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              __Cont: ;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          }
          if (next_match_idx >= 0) {
            if (next_match_col == (int )current_col) {
              {
              cur_si = push_next_match(cur_si, line);
              found_match = 1;
              }
            }
          }
        }
      }
    }
    }
    if ((unsigned long )current_next_list != (unsigned long )((void *)0)) {
      if (! found_match) {
        if (current_next_flags & 256) {
          if ((int )*(line + current_col) == 32) {
            goto while_break;
          } else { //Added block
          if ((int )*(line + current_col) == 9) {
            goto while_break;
          } else {
            goto _L___9;
          }
          }
        } else { //Added block
        _L___9: 
        if (current_next_flags & 512) {
          if ((int )*line == 0) {
            goto while_break;
          }
        }
        }
      }
      current_next_list = (short *)((void *)0);
      next_match_idx = -1;
      found_match = 1;
    }
    if (! found_match) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  current_attr = 0;
  current_id = 0;
  current_trans_id = 0;
  if ((unsigned long )cur_si != (unsigned long )((void *)0)) {
    idx = current_state.ga_len - 1;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (idx >= 0)) {
        goto while_break___1;
      }
      sip = (struct state_item *)current_state.ga_data + idx;
      if ((int )current_col >= sip->si_h_startcol) {
        if ((int )current_col <= sip->si_h_endcol) {
          current_attr = sip->si_attr;
          current_id = sip->si_id;
          current_trans_id = sip->si_trans_id;
          goto while_break___1;
        }
      }
      idx --;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (! syncing) {
      {
      current_col ++;
      check_state_ends(line);
      current_col --;
      }
    }
  }
  if ((unsigned long )current_next_list != (unsigned long )((void *)0)) {
    if ((int )*(line + (current_col + 1U)) == 0) {
      if (! (current_next_flags & 640)) {
        current_next_list = (short *)((void *)0);
      }
    }
  }
  return (current_attr);
}
}
static int did_match_already(int idx ) 
{ 
  int i___0 ;

  {
  i___0 = current_state.ga_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    if (((struct state_item *)current_state.ga_data + i___0)->si_m_startcol == (int )current_col) {
      if (((struct state_item *)current_state.ga_data + i___0)->si_m_lnum == (int )current_lnum) {
        if (((struct state_item *)current_state.ga_data + i___0)->si_idx == idx) {
          return (1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static struct state_item *push_next_match(struct state_item *cur_si , char_u *line ) 
{ 
  struct syn_pattern *spp ;
  int tmp ;
  int tmp___0 ;

  {
  {
  spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + next_match_idx;
  tmp___0 = push_current(next_match_idx);
  }
  if (tmp___0 == 1) {
    cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
    cur_si->si_h_startcol = next_match_h_startcol;
    cur_si->si_m_startcol = (int )current_col;
    cur_si->si_m_lnum = (int )current_lnum;
    cur_si->si_flags = (int )spp->sp_flags;
    cur_si->si_next_list = spp->sp_next_list;
    if ((int )spp->sp_type == 2) {
      if (! ((int )spp->sp_flags & 4)) {
        {
        update_si_end(cur_si, line, next_match_m_endcol);
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      cur_si->si_m_endcol = next_match_m_endcol - 1;
      cur_si->si_h_endcol = next_match_h_endcol - 1;
      cur_si->si_ends = 1;
      cur_si->si_flags |= next_match_flags;
      cur_si->si_eoe_col = next_match_eoe_col;
      cur_si->si_end_idx = next_match_end_idx;
    }
    if (keepend_level < 0) {
      if (cur_si->si_flags & 1024) {
        keepend_level = current_state.ga_len - 1;
      }
    }
    {
    check_keepend();
    update_si_attr(current_state.ga_len - 1);
    }
    if ((int )spp->sp_type == 2) {
      if ((int )spp->sp_syn_match_id != 0) {
        {
        tmp = push_current(next_match_idx);
        }
        if (tmp == 1) {
          {
          cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
          cur_si->si_h_startcol = next_match_h_startcol;
          cur_si->si_m_startcol = (int )current_col;
          cur_si->si_m_lnum = (int )current_lnum;
          cur_si->si_m_endcol = next_match_eos_col;
          cur_si->si_h_endcol = next_match_eos_col;
          cur_si->si_ends = 1;
          cur_si->si_end_idx = 0;
          cur_si->si_flags = 64;
          cur_si->si_next_list = (short *)((void *)0);
          check_keepend();
          update_si_attr(current_state.ga_len - 1);
          }
        }
      }
    }
  }
  next_match_idx = -1;
  return (cur_si);
}
}
static void check_state_ends(char_u *line ) 
{ 
  struct state_item *cur_si ;

  {
  cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (cur_si->si_m_endcol < (int )current_col) {
      if (cur_si->si_ends) {
        if (cur_si->si_end_idx) {
          if (cur_si->si_eoe_col >= (int )current_col) {
            {
            cur_si->si_idx = cur_si->si_end_idx;
            cur_si->si_end_idx = 0;
            cur_si->si_m_endcol = cur_si->si_eoe_col;
            cur_si->si_h_endcol = cur_si->si_eoe_col;
            cur_si->si_flags |= 64;
            update_si_attr(current_state.ga_len - 1);
            }
            goto while_break;
          } else {
            goto _L;
          }
        } else {
          _L: 
          current_next_list = cur_si->si_next_list;
          current_next_flags = cur_si->si_flags;
          if (! (current_next_flags & 640)) {
            if ((int )*(line + current_col) == 0) {
              current_next_list = (short *)((void *)0);
            }
          }
          {
          pop_current();
          }
          if (current_state.ga_len == 0) {
            goto while_break;
          }
          cur_si = (struct state_item *)current_state.ga_data + (current_state.ga_len - 1);
          if ((int )((struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + cur_si->si_idx)->sp_type == 2) {
            if (! (cur_si->si_flags & 1088)) {
              {
              update_si_end(cur_si, line, (int )current_col);
              }
              if (current_next_flags & 8) {
                if (keepend_level < 0) {
                  if ((int )*(line + current_col) == 0) {
                    goto while_break;
                  }
                }
              }
            }
          }
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void update_si_attr(int idx ) 
{ 
  struct state_item *sip ;
  struct syn_pattern *spp ;

  {
  sip = (struct state_item *)current_state.ga_data + idx;
  spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + sip->si_idx;
  if (sip->si_flags & 64) {
    sip->si_id = (int )spp->sp_syn_match_id;
  } else {
    sip->si_id = (int )spp->sp_syn_id;
  }
  {
  sip->si_attr = syn_id2attr(sip->si_id);
  sip->si_trans_id = sip->si_id;
  }
  if (sip->si_flags & 64) {
    sip->si_cont_list = (short *)((void *)0);
  } else {
    sip->si_cont_list = spp->sp_cont_list;
  }
  if ((int )spp->sp_flags & 2) {
    if (! (sip->si_flags & 64)) {
      if (idx == 0) {
        sip->si_attr = 0;
        sip->si_trans_id = 0;
        if ((unsigned long )sip->si_cont_list == (unsigned long )((void *)0)) {
          sip->si_cont_list = (short *)-1;
        }
      } else {
        sip->si_attr = ((struct state_item *)current_state.ga_data + (idx - 1))->si_attr;
        sip->si_trans_id = ((struct state_item *)current_state.ga_data + (idx - 1))->si_trans_id;
        if ((unsigned long )sip->si_cont_list == (unsigned long )((void *)0)) {
          sip->si_cont_list = ((struct state_item *)current_state.ga_data + (idx - 1))->si_cont_list;
        }
      }
    }
  }
  return;
}
}
static void check_keepend(void) 
{ 
  int i___0 ;
  int maxend ;
  struct state_item *sip ;

  {
  maxend = 2147483647;
  if (keepend_level < 0) {
    return;
  }
  i___0 = keepend_level;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < current_state.ga_len)) {
      goto while_break;
    }
    sip = (struct state_item *)current_state.ga_data + i___0;
    if (maxend < 2147483647) {
      if (sip->si_m_endcol > maxend) {
        sip->si_m_endcol = maxend;
      }
      if (sip->si_h_endcol > maxend) {
        sip->si_h_endcol = maxend;
      }
      if (sip->si_eoe_col > maxend) {
        sip->si_eoe_col = maxend;
      }
      sip->si_ends = 1;
    }
    if (sip->si_ends) {
      if (sip->si_flags & 1024) {
        if (maxend > sip->si_m_endcol) {
          maxend = sip->si_m_endcol;
        }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void update_si_end(struct state_item *sip , char_u *line , int startcol ) 
{ 
  char_u *endp ;
  char_u *hl_endp ;
  char_u *end_endp ;
  int end_idx ;
  size_t tmp ;

  {
  {
  end_idx = 0;
  endp = find_endp(sip->si_idx, line + startcol, startcol == 0, & hl_endp, & sip->si_flags,
                   & end_endp, & end_idx);
  }
  if ((unsigned long )endp == (unsigned long )((void *)0)) {
    if ((int )((struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + sip->si_idx)->sp_flags & 4) {
      {
      sip->si_ends = 1;
      tmp = strlen((char const   *)((char *)line));
      sip->si_m_endcol = (int )(tmp - 1UL);
      }
    } else {
      sip->si_ends = 0;
      sip->si_m_endcol = 2147483647;
    }
    sip->si_h_endcol = sip->si_m_endcol;
  } else {
    sip->si_m_endcol = (int )((endp - line) - 1L);
    sip->si_h_endcol = (int )((hl_endp - line) - 1L);
    sip->si_ends = 1;
    sip->si_eoe_col = (int )((end_endp - line) - 1L);
    sip->si_end_idx = end_idx;
  }
  {
  check_keepend();
  }
  return;
}
}
static int push_current(int idx ) 
{ 
  int tmp ;

  {
  {
  tmp = ga_grow(& current_state, 1);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  memset((void *)((struct state_item *)current_state.ga_data + current_state.ga_len),
         0, sizeof(struct state_item ));
  ((struct state_item *)current_state.ga_data + current_state.ga_len)->si_idx = idx;
  (current_state.ga_len) ++;
  (current_state.ga_room) --;
  }
  return (1);
}
}
static void pop_current(void) 
{ 


  {
  if (current_state.ga_len) {
    (current_state.ga_len) --;
    (current_state.ga_room) ++;
  }
  next_match_idx = -1;
  if (keepend_level >= current_state.ga_len) {
    keepend_level = -1;
  }
  return;
}
}
static char_u *find_endp(int idx , char_u *sstart , int at_bol , char_u **hl_endp ,
                         int *flagsp , char_u **end_endp , int *end_idx ) 
{ 
  char_u *endp ;
  struct syn_pattern *spp ;
  struct syn_pattern *spp_skip ;
  char_u *p___0 ;
  int start_idx ;
  int best_idx ;
  char_u *best_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + idx;
  if ((int )spp->sp_type != 2) {
    *hl_endp = sstart;
    return (sstart);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + idx;
    if ((int )spp->sp_type != 2) {
      goto while_break;
    }
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )spp->sp_type == 4) {
    spp_skip = spp;
    idx ++;
  } else {
    spp_skip = (struct syn_pattern *)((void *)0);
  }
  endp = sstart;
  start_idx = idx;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    best_idx = -1;
    best_ptr = (char_u *)((void *)0);
    idx = start_idx;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (idx < syn_buf->b_syn_patterns.ga_len)) {
        goto while_break___1;
      }
      spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + idx;
      if ((int )spp->sp_type != 3) {
        goto while_break___1;
      }
      reg_ic = spp->sp_ic;
      if (at_bol) {
        if ((unsigned long )endp == (unsigned long )sstart) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
      {
      tmp___0 = syn_regexec(spp->sp_prog, endp, tmp);
      }
      if (tmp___0) {
        if (best_idx == -1) {
          best_idx = idx;
          best_ptr = (spp->sp_prog)->startp[0];
        } else { //Added block
        if ((unsigned long )(spp->sp_prog)->startp[0] < (unsigned long )best_ptr) {
          best_idx = idx;
          best_ptr = (spp->sp_prog)->startp[0];
        }
        }
      }
      idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if (best_idx == -1) {
      goto while_break___0;
    }
    if ((unsigned long )spp_skip != (unsigned long )((void *)0)) {
      reg_ic = spp_skip->sp_ic;
      if (at_bol) {
        if ((unsigned long )endp == (unsigned long )sstart) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
      {
      tmp___2 = syn_regexec(spp_skip->sp_prog, endp, tmp___1);
      }
      if (tmp___2) {
        if ((unsigned long )(spp_skip->sp_prog)->startp[0] <= (unsigned long )best_ptr) {
          {
          p___0 = syn_add_end_off(spp_skip, 1, 1);
          }
          if ((unsigned long )p___0 <= (unsigned long )endp) {
            endp ++;
          } else { //Added block
          if ((unsigned long )p___0 <= (unsigned long )(spp_skip->sp_prog)->endp[0]) {
            endp = p___0;
          } else {
            endp = (spp_skip->sp_prog)->endp[0];
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              if ((int )*endp != 0) {
                if (! ((unsigned long )endp < (unsigned long )p___0)) {
                  goto while_break___2;
                }
              } else {
                goto while_break___2;
              }
              endp ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
          }
          if ((int )*endp == 0) {
            goto while_break___0;
          }
          goto __Cont;
        }
      }
    }
    {
    spp = (struct syn_pattern *)syn_buf->b_syn_patterns.ga_data + best_idx;
    p___0 = syn_add_end_off(spp, 1, 1);
    }
    if ((unsigned long )p___0 < (unsigned long )sstart) {
      p___0 = sstart;
    }
    {
    endp = syn_add_end_off(spp, 3, 1);
    }
    if ((unsigned long )endp < (unsigned long )sstart) {
      endp = sstart;
    }
    if ((unsigned long )endp > (unsigned long )p___0) {
      endp = p___0;
    }
    *end_endp = endp;
    if ((int )spp->sp_syn_match_id != (int )spp->sp_syn_id) {
      if ((int )spp->sp_syn_match_id != 0) {
        *end_idx = best_idx;
        if ((int )spp->sp_off_flags & (1 << 12)) {
          endp = (spp->sp_prog)->endp[0] + spp->sp_offsets[5];
        } else {
          endp = (spp->sp_prog)->startp[0] + spp->sp_offsets[5];
        }
        if ((unsigned long )endp < (unsigned long )sstart) {
          endp = sstart;
        }
        if ((unsigned long )endp > (unsigned long )p___0) {
          endp = p___0;
        }
        p___0 = endp;
      } else {
        *end_idx = 0;
      }
    } else {
      *end_idx = 0;
    }
    *hl_endp = endp;
    *flagsp = (int )spp->sp_flags;
    return (p___0);
    __Cont: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
static char_u *syn_add_end_off(struct syn_pattern *spp , int idx , int extra ) 
{ 


  {
  if ((int )spp->sp_off_flags & (1 << idx)) {
    return (((spp->sp_prog)->startp[0] + spp->sp_offsets[idx]) + extra);
  }
  return ((spp->sp_prog)->endp[0] + spp->sp_offsets[idx]);
}
}
static char_u *syn_add_start_off(struct syn_pattern *spp , int idx , int extra ) 
{ 


  {
  if ((int )spp->sp_off_flags & (1 << (idx + 7))) {
    return (((spp->sp_prog)->endp[0] + spp->sp_offsets[idx]) + extra);
  }
  return ((spp->sp_prog)->startp[0] + spp->sp_offsets[idx]);
}
}
static int check_keyword_id(char_u *line , int startcol , int *endcol , int *flags___0 ,
                            short **next_list , struct state_item *cur_si ) 
{ 
  struct keyentry *ktab ;
  char_u *p___0 ;
  int round ;
  int hash ;
  int len___0 ;
  char_u keyword[81] ;
  int tmp ;
  struct keyentry **tmp___0 ;
  char_u *tmp___1 ;
  char_u tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  p___0 = line + startcol;
  len___0 = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = vim_iswordc_buf((int )*(p___0 + len___0), syn_buf);
    }
    if (! tmp) {
      goto while_break;
    }
    len___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (len___0 > 80) {
    return (0);
  }
  {
  strncpy((char * __restrict  )((char *)(keyword)), (char const   * __restrict  )((char *)p___0),
          (size_t )len___0);
  keyword[len___0] = (char_u )'\000';
  round = 1;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (round <= 2)) {
      goto while_break___0;
    }
    if (round == 1) {
      tmp___0 = syn_buf->b_keywtab;
    } else {
      tmp___0 = syn_buf->b_keywtab_ic;
    }
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    p___0 = keyword;
    hash = 0;
    if (round == 1) {
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (! *p___0) {
          goto while_break___1;
        }
        tmp___1 = p___0;
        p___0 ++;
        hash += (int )*tmp___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      ktab = *(syn_buf->b_keywtab + (hash & 511));
    } else {
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! *p___0) {
          goto while_break___2;
        }
        {
        tmp___3 = tolower((int )*p___0);
        tmp___2 = (char_u )tmp___3;
        *p___0 = tmp___2;
        hash += (int )tmp___2;
        p___0 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      ktab = *(syn_buf->b_keywtab_ic + (hash & 511));
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! ((unsigned long )ktab != (unsigned long )((void *)0))) {
        goto while_break___3;
      }
      {
      tmp___4 = strcmp((char const   *)((char *)(keyword)), (char const   *)((char *)(ktab->keyword)));
      }
      if (tmp___4 == 0) {
        if ((unsigned long )current_next_list != (unsigned long )((short *)0)) {
          {
          tmp___5 = in_id_list(current_next_list, (int )ktab->syn_id, ktab->syn_inc_tag,
                               0);
          }
          if (tmp___5) {
            *endcol = (startcol + len___0) - 1;
            *flags___0 = (int )ktab->flags;
            *next_list = ktab->next_list;
            return ((int )ktab->syn_id);
          } else {
            goto _L___0;
          }
        } else { //Added block
        _L___0: 
        if ((unsigned long )current_next_list == (unsigned long )((short *)0)) {
          if ((unsigned long )cur_si == (unsigned long )((void *)0)) {
            if (! ((int )ktab->flags & 1)) {
              *endcol = (startcol + len___0) - 1;
              *flags___0 = (int )ktab->flags;
              *next_list = ktab->next_list;
              return ((int )ktab->syn_id);
            } else {
              goto _L;
            }
          } else { //Added block
          _L: 
          if ((unsigned long )cur_si != (unsigned long )((void *)0)) {
            {
            tmp___6 = in_id_list(cur_si->si_cont_list, (int )ktab->syn_id, ktab->syn_inc_tag,
                                 (int )ktab->flags & 1);
            }
            if (tmp___6) {
              *endcol = (startcol + len___0) - 1;
              *flags___0 = (int )ktab->flags;
              *next_list = ktab->next_list;
              return ((int )ktab->syn_id);
            }
          }
          }
        }
        }
      }
      ktab = ktab->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: 
    round ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (0);
}
}
static void syn_cmd_case(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  char_u *next ;
  int tmp ;
  int tmp___0 ;

  {
  {
  arg = eap->arg;
  eap->nextcmd = find_nextcmd(arg);
  }
  if (eap->skip) {
    return;
  }
  {
  next = skiptowhite(arg);
  tmp___0 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"match"),
                        (size_t )5);
  }
  if (tmp___0 == 0) {
    if (next - arg == 5L) {
      curbuf->b_syn_ic = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
    tmp = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"ignore"),
                      (size_t )6);
    }
    if (tmp == 0) {
      if (next - arg == 6L) {
        curbuf->b_syn_ic = 1;
      } else {
        {
        emsg2((char_u *)"Illegal argument: %s", arg);
        }
      }
    } else {
      {
      emsg2((char_u *)"Illegal argument: %s", arg);
      }
    }
  }
  return;
}
}
void syntax_clear(BUF *buf___3 ) 
{ 
  int i___0 ;

  {
  {
  curbuf->b_syn_ic = 0;
  free_keywtab(buf___3->b_keywtab);
  buf___3->b_keywtab = (struct keyentry **)((void *)0);
  free_keywtab(buf___3->b_keywtab_ic);
  buf___3->b_keywtab_ic = (struct keyentry **)((void *)0);
  i___0 = buf___3->b_syn_patterns.ga_len;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    {
    syn_clear_pattern(buf___3, i___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  ga_clear(& buf___3->b_syn_patterns);
  i___0 = buf___3->b_syn_clusters.ga_len;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break___0;
    }
    {
    syn_clear_cluster(buf___3, i___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  ga_clear(& buf___3->b_syn_clusters);
  buf___3->b_syn_sync_flags = 0;
  buf___3->b_syn_sync_minlines = 0L;
  buf___3->b_syn_sync_maxlines = 0L;
  vim_free((void *)buf___3->b_syn_linecont_prog);
  buf___3->b_syn_linecont_prog = (vim_regexp *)((void *)0);
  vim_free((void *)buf___3->b_syn_linecont_pat);
  buf___3->b_syn_linecont_pat = (char_u *)((void *)0);
  syn_free_all_states(buf___3);
  invalidate_current_state();
  }
  return;
}
}
static void syntax_sync_clear(void) 
{ 
  int i___0 ;

  {
  i___0 = curbuf->b_syn_patterns.ga_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    if (((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + i___0)->sp_syncing) {
      {
      syn_remove_pattern(curbuf, i___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  curbuf->b_syn_sync_flags = 0;
  curbuf->b_syn_sync_minlines = 0L;
  curbuf->b_syn_sync_maxlines = 0L;
  vim_free((void *)curbuf->b_syn_linecont_prog);
  curbuf->b_syn_linecont_prog = (vim_regexp *)((void *)0);
  vim_free((void *)curbuf->b_syn_linecont_pat);
  curbuf->b_syn_linecont_pat = (char_u *)((void *)0);
  }
  return;
}
}
static void syn_remove_pattern(BUF *buf___3 , int idx ) 
{ 
  struct syn_pattern *spp ;

  {
  {
  spp = (struct syn_pattern *)buf___3->b_syn_patterns.ga_data + idx;
  syn_clear_pattern(buf___3, idx);
  memmove((void *)((char *)spp), (void const   *)((char *)(spp + 1)), sizeof(struct syn_pattern ) * (unsigned long )((buf___3->b_syn_patterns.ga_len - idx) - 1));
  (buf___3->b_syn_patterns.ga_len) --;
  (buf___3->b_syn_patterns.ga_room) --;
  }
  return;
}
}
static void syn_clear_pattern(BUF *buf___3 , int i___0 ) 
{ 


  {
  {
  vim_free((void *)((struct syn_pattern *)buf___3->b_syn_patterns.ga_data + i___0)->sp_pattern);
  vim_free((void *)((struct syn_pattern *)buf___3->b_syn_patterns.ga_data + i___0)->sp_prog);
  }
  if (i___0 == 0) {
    {
    vim_free((void *)((struct syn_pattern *)buf___3->b_syn_patterns.ga_data + i___0)->sp_cont_list);
    vim_free((void *)((struct syn_pattern *)buf___3->b_syn_patterns.ga_data + i___0)->sp_next_list);
    }
  } else { //Added block
  if ((int )((struct syn_pattern *)buf___3->b_syn_patterns.ga_data + (i___0 - 1))->sp_type != 2) {
    {
    vim_free((void *)((struct syn_pattern *)buf___3->b_syn_patterns.ga_data + i___0)->sp_cont_list);
    vim_free((void *)((struct syn_pattern *)buf___3->b_syn_patterns.ga_data + i___0)->sp_next_list);
    }
  }
  }
  return;
}
}
static void syn_clear_cluster(BUF *buf___3 , int i___0 ) 
{ 


  {
  {
  vim_free((void *)((struct syn_cluster *)buf___3->b_syn_clusters.ga_data + i___0)->scl_name);
  vim_free((void *)((struct syn_cluster *)buf___3->b_syn_clusters.ga_data + i___0)->scl_name_u);
  vim_free((void *)((struct syn_cluster *)buf___3->b_syn_clusters.ga_data + i___0)->scl_list);
  }
  return;
}
}
static void syn_cmd_clear(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  char_u *arg_end ;
  int id ;
  short scl_id ;
  int tmp ;
  int tmp___0 ;

  {
  {
  arg = eap->arg;
  eap->nextcmd = find_nextcmd(arg);
  }
  if (eap->skip) {
    return;
  }
  if (curbuf->b_syn_topgrp != 0) {
    return;
  }
  {
  tmp___0 = ends_excmd((int )*arg);
  }
  if (tmp___0) {
    if (syncing) {
      {
      syntax_sync_clear();
      }
    } else {
      {
      syntax_clear(curbuf);
      }
    }
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp = ends_excmd((int )*arg);
      }
      if (tmp) {
        goto while_break;
      }
      {
      arg_end = skiptowhite(arg);
      }
      if ((int )*arg == 64) {
        {
        id = syn_scl_namen2id(arg + 1, (int )((arg_end - arg) - 1L));
        }
        if (id == 0) {
          {
          emsg2((char_u *)"No such syntax cluster: %s", arg);
          }
          goto while_break;
        } else {
          {
          scl_id = (short )(id - 15000);
          vim_free((void *)((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + (int )scl_id)->scl_list);
          ((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + (int )scl_id)->scl_list = (short *)((void *)0);
          }
        }
      } else {
        {
        id = syn_namen2id(arg, (int )(arg_end - arg));
        }
        if (id == 0) {
          {
          emsg2((char_u *)"No such highlight group name: %s", arg);
          }
          goto while_break;
        } else {
          {
          syn_clear_one(id, syncing);
          }
        }
      }
      {
      arg = skipwhite(arg_end);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  redraw_curbuf_later(40);
  syn_changed((linenr_t )0);
  }
  return;
}
}
static void syn_clear_one(int id , int syncing ) 
{ 
  struct syn_pattern *spp ;
  int idx ;

  {
  if (! syncing) {
    {
    syn_clear_keyword(id, curbuf->b_keywtab);
    syn_clear_keyword(id, curbuf->b_keywtab_ic);
    }
  }
  idx = curbuf->b_syn_patterns.ga_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    idx --;
    if (! (idx >= 0)) {
      goto while_break;
    }
    spp = (struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx;
    if ((int )spp->sp_syn_id != id) {
      goto __Cont;
    } else { //Added block
    if ((int )spp->sp_syncing != syncing) {
      goto __Cont;
    }
    }
    {
    syn_remove_pattern(curbuf, idx);
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void syn_cmd_on(EXARG *eap , int syncing ) 
{ 


  {
  {
  syn_cmd_onoff(eap, (char *)"syntax");
  }
  return;
}
}
static void syn_cmd_manual(EXARG *eap , int syncing ) 
{ 


  {
  {
  syn_cmd_onoff(eap, (char *)"manual");
  }
  return;
}
}
static void syn_cmd_off(EXARG *eap , int syncing ) 
{ 


  {
  {
  syn_cmd_onoff(eap, (char *)"nosyntax");
  }
  return;
}
}
static void syn_cmd_onoff(EXARG *eap , char *name___1 ) 
{ 
  char_u buf___3[100] ;

  {
  {
  eap->nextcmd = check_nextcmd(eap->arg);
  }
  if (! eap->skip) {
    {
    strcpy((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )((char *)"so "));
    sprintf((char * __restrict  )((char *)(buf___3) + 3), (char const   * __restrict  )"$VIMRUNTIME/syntax/%s.vim",
            name___1);
    do_cmdline(buf___3, (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
               1);
    }
  }
  return;
}
}
static void syn_cmd_list(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  int id ;
  char_u *arg_end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  arg = eap->arg;
  eap->nextcmd = find_nextcmd(arg);
  }
  if (eap->skip) {
    return;
  }
  {
  tmp = syntax_present(curbuf);
  }
  if (! tmp) {
    {
    msg((char_u *)"No Syntax items defined for this buffer");
    }
    return;
  }
  if (syncing) {
    if (curbuf->b_syn_sync_flags & 1) {
      {
      msg_puts((char_u *)"syncing on C-style comments");
      }
      if (curbuf->b_syn_sync_minlines) {
        {
        syn_lines_msg();
        }
      } else { //Added block
      if (curbuf->b_syn_sync_maxlines) {
        {
        syn_lines_msg();
        }
      }
      }
      return;
    } else { //Added block
    if (! (curbuf->b_syn_sync_flags & 2)) {
      {
      msg_puts((char_u *)"syncing starts ");
      msg_outnum(curbuf->b_syn_sync_minlines);
      msg_puts((char_u *)" lines before top line");
      }
      return;
    }
    }
    {
    msg_puts_title((char_u *)"\n--- Syntax sync items ---");
    }
    if (curbuf->b_syn_sync_minlines) {
      {
      msg_puts((char_u *)"\nsyncing on items");
      syn_lines_msg();
      }
    } else { //Added block
    if (curbuf->b_syn_sync_maxlines) {
      {
      msg_puts((char_u *)"\nsyncing on items");
      syn_lines_msg();
      }
    }
    }
  } else {
    {
    msg_puts_title((char_u *)"\n--- Syntax items ---");
    }
  }
  {
  tmp___1 = ends_excmd((int )*arg);
  }
  if (tmp___1) {
    id = 1;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (id <= highlight_ga.ga_len) {
        if (! (! got_int)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      {
      syn_list_one(id, syncing, 0);
      id ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    id = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (id < curbuf->b_syn_clusters.ga_len) {
        if (! (! got_int)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      {
      syn_list_cluster(id);
      id ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
      tmp___0 = ends_excmd((int )*arg);
      }
      if (tmp___0) {
        goto while_break___1;
      } else { //Added block
      if (! (! got_int)) {
        goto while_break___1;
      }
      }
      {
      arg_end = skiptowhite(arg);
      }
      if ((int )*arg == 64) {
        {
        id = syn_scl_namen2id(arg + 1, (int )((arg_end - arg) - 1L));
        }
        if (id == 0) {
          {
          emsg2((char_u *)"No such syntax cluster: %s", arg);
          }
        } else {
          {
          syn_list_cluster(id - 15000);
          }
        }
      } else {
        {
        id = syn_namen2id(arg, (int )(arg_end - arg));
        }
        if (id == 0) {
          {
          emsg2((char_u *)"No such highlight group name: %s", arg);
          }
        } else {
          {
          syn_list_one(id, syncing, 1);
          }
        }
      }
      {
      arg = skipwhite(arg_end);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  eap->nextcmd = check_nextcmd(arg);
  }
  return;
}
}
static void syn_lines_msg(void) 
{ 


  {
  {
  msg_puts((char_u *)"; ");
  }
  if (curbuf->b_syn_sync_minlines) {
    {
    msg_puts((char_u *)"minimal ");
    msg_outnum(curbuf->b_syn_sync_minlines);
    }
    if (curbuf->b_syn_sync_maxlines) {
      {
      msg_puts((char_u *)", ");
      }
    }
  }
  if (curbuf->b_syn_sync_maxlines) {
    {
    msg_puts((char_u *)"maximal ");
    msg_outnum(curbuf->b_syn_sync_maxlines);
    }
  }
  {
  msg_puts((char_u *)" lines before top line");
  }
  return;
}
}
static int last_matchgroup  ;
static void syn_list_one(int id , int syncing , int link_only ) 
{ 
  int attr ;
  int idx ;
  int did_header ;
  struct syn_pattern *spp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  did_header = 0;
  attr = highlight_attr[2];
  if (! syncing) {
    {
    did_header = syn_list_keywords(id, curbuf->b_keywtab, 0, attr);
    did_header = syn_list_keywords(id, curbuf->b_keywtab_ic, did_header, attr);
    }
  }
  idx = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (idx < curbuf->b_syn_patterns.ga_len) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    spp = (struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx;
    if ((int )spp->sp_syn_id != id) {
      goto __Cont;
    } else { //Added block
    if ((int )spp->sp_syncing != syncing) {
      goto __Cont;
    }
    }
    {
    syn_list_header(did_header, 999, id);
    did_header = 1;
    last_matchgroup = 0;
    }
    if ((int )spp->sp_type == 1) {
      {
      put_pattern((char *)"match", ' ', spp, attr);
      msg_putchar(' ');
      }
    } else { //Added block
    if ((int )spp->sp_type == 2) {
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((int )((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_type == 2)) {
          goto while_break___0;
        }
        {
        tmp = idx;
        idx ++;
        put_pattern((char *)"start", '=', (struct syn_pattern *)curbuf->b_syn_patterns.ga_data + tmp,
                    attr);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      if ((int )((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_type == 4) {
        {
        tmp___0 = idx;
        idx ++;
        put_pattern((char *)"skip", '=', (struct syn_pattern *)curbuf->b_syn_patterns.ga_data + tmp___0,
                    attr);
        }
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (idx < curbuf->b_syn_patterns.ga_len) {
          if (! ((int )((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_type == 3)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        {
        tmp___1 = idx;
        idx ++;
        put_pattern((char *)"end", '=', (struct syn_pattern *)curbuf->b_syn_patterns.ga_data + tmp___1,
                    attr);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      idx --;
      msg_putchar(' ');
      }
    }
    }
    if ((int )spp->sp_flags & 1) {
      {
      msg_puts_attr((char_u *)"contained", attr);
      msg_putchar(' ');
      }
    }
    if ((int )spp->sp_flags & 4) {
      {
      msg_puts_attr((char_u *)"oneline", attr);
      msg_putchar(' ');
      }
    }
    if ((int )spp->sp_flags & 1024) {
      {
      msg_puts_attr((char_u *)"keepend", attr);
      msg_putchar(' ');
      }
    }
    if ((int )spp->sp_flags & 2048) {
      {
      msg_puts_attr((char_u *)"excludenl", attr);
      msg_putchar(' ');
      }
    }
    if ((int )spp->sp_flags & 2) {
      {
      msg_puts_attr((char_u *)"transparent", attr);
      msg_putchar(' ');
      }
    }
    if ((unsigned long )spp->sp_cont_list != (unsigned long )((void *)0)) {
      {
      put_id_list((char_u *)"contains", spp->sp_cont_list, attr);
      }
    }
    if ((unsigned long )spp->sp_next_list != (unsigned long )((void *)0)) {
      {
      put_id_list((char_u *)"nextgroup", spp->sp_next_list, attr);
      }
      if ((int )spp->sp_flags & 256) {
        {
        msg_puts_attr((char_u *)"skipwhite", attr);
        msg_putchar(' ');
        }
      }
      if ((int )spp->sp_flags & 128) {
        {
        msg_puts_attr((char_u *)"skipnl", attr);
        msg_putchar(' ');
        }
      }
      if ((int )spp->sp_flags & 512) {
        {
        msg_puts_attr((char_u *)"skipempty", attr);
        msg_putchar(' ');
        }
      }
    }
    if ((int )spp->sp_flags & 48) {
      if ((int )spp->sp_flags & 16) {
        {
        msg_puts_attr((char_u *)"grouphere", attr);
        }
      } else {
        {
        msg_puts_attr((char_u *)"groupthere", attr);
        }
      }
      {
      msg_putchar(' ');
      }
      if (spp->sp_sync_idx >= 0) {
        {
        msg_outtrans(((struct hl_group *)highlight_ga.ga_data + ((int )((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + spp->sp_sync_idx)->sp_syn_id - 1))->sg_name);
        }
      } else {
        {
        msg_puts((char_u *)"NONE");
        }
      }
      {
      msg_putchar(' ');
      }
    }
    __Cont: 
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_link) {
    if (did_header) {
      goto _L;
    } else { //Added block
    if (link_only) {
      _L: 
      if (! got_int) {
        {
        syn_list_header(did_header, 999, id);
        msg_puts_attr((char_u *)"links to", attr);
        msg_putchar(' ');
        msg_outtrans(((struct hl_group *)highlight_ga.ga_data + (((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_link - 1))->sg_name);
        }
      }
    }
    }
  }
  return;
}
}
static void syn_list_cluster(int id ) 
{ 
  int endcol ;

  {
  {
  endcol = 15;
  msg_putchar('\n');
  msg_outtrans(((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + id)->scl_name);
  }
  if (msg_col >= endcol) {
    endcol = msg_col + 1;
  }
  if (Columns <= (long )endcol) {
    endcol = (int )(Columns - 1L);
  }
  {
  msg_advance(endcol);
  }
  if ((unsigned long )((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + id)->scl_list != (unsigned long )((void *)0)) {
    {
    put_id_list((char_u *)"cluster", ((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + id)->scl_list,
                highlight_attr[2]);
    }
  } else {
    {
    msg_puts_attr((char_u *)"cluster", highlight_attr[2]);
    msg_puts((char_u *)"=NONE");
    }
  }
  return;
}
}
static void put_id_list(char_u *name___1 , short *list , int attr ) 
{ 
  short *p___0 ;
  short scl_id ;

  {
  {
  msg_puts_attr(name___1, attr);
  msg_putchar('=');
  p___0 = list;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 >= 9999) {
      if ((int )*p___0 < 15000) {
        if (*(p___0 + 1)) {
          {
          msg_puts((char_u *)"ALLBUT");
          }
        } else {
          {
          msg_puts((char_u *)"ALL");
          }
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*p___0 >= 15000) {
      {
      scl_id = (short )((int )*p___0 - 15000);
      msg_putchar('@');
      msg_outtrans(((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + (int )scl_id)->scl_name);
      }
    } else {
      {
      msg_outtrans(((struct hl_group *)highlight_ga.ga_data + ((int )*p___0 - 1))->sg_name);
      }
    }
    }
    if (*(p___0 + 1)) {
      {
      msg_putchar(',');
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  msg_putchar(' ');
  }
  return;
}
}
static char *sepchars  =    (char *)"/+=-#@\"|\'^&";
static void put_pattern(char *s , int c , struct syn_pattern *spp , int attr ) 
{ 
  long n ;
  int mask ;
  int first___0 ;
  int i___0 ;
  char_u *tmp ;

  {
  if (last_matchgroup != (int )spp->sp_syn_match_id) {
    {
    last_matchgroup = (int )spp->sp_syn_match_id;
    msg_puts_attr((char_u *)"matchgroup", attr);
    msg_putchar('=');
    }
    if (last_matchgroup == 0) {
      {
      msg_outtrans((char_u *)"NONE");
      }
    } else {
      {
      msg_outtrans(((struct hl_group *)highlight_ga.ga_data + (last_matchgroup - 1))->sg_name);
      }
    }
    {
    msg_putchar(' ');
    }
  }
  {
  msg_puts_attr((char_u *)s, attr);
  msg_putchar(c);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = vim_strchr(spp->sp_pattern, (int )*(sepchars + i___0));
    }
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    i___0 ++;
    if ((int )*(sepchars + i___0) == 0) {
      i___0 = 0;
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  msg_putchar((int )*(sepchars + i___0));
  msg_outtrans(spp->sp_pattern);
  msg_putchar((int )*(sepchars + i___0));
  first___0 = 1;
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < 7)) {
      goto while_break___0;
    }
    mask = 1 << i___0;
    if ((int )spp->sp_off_flags & (mask + (mask << 7))) {
      if (! first___0) {
        {
        msg_putchar(',');
        }
      }
      {
      msg_puts((char_u *)spo_name_tab[i___0]);
      n = (long )spp->sp_offsets[i___0];
      }
      if (i___0 != 6) {
        if ((int )spp->sp_off_flags & mask) {
          {
          msg_putchar('s');
          }
        } else {
          {
          msg_putchar('e');
          }
        }
        if (n > 0L) {
          {
          msg_putchar('+');
          }
        }
      }
      if (n) {
        {
        msg_outnum(n);
        }
      } else { //Added block
      if (i___0 == 6) {
        {
        msg_outnum(n);
        }
      }
      }
      first___0 = 0;
    }
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  msg_putchar(' ');
  }
  return;
}
}
static int syn_list_keywords(int id , struct keyentry **ktabp , int did_header , int attr ) 
{ 
  int i___0 ;
  int outlen ;
  struct keyentry *ktab ;
  int prev_contained ;
  short *prev_next_list ;
  int prev_skipnl ;
  int prev_skipwhite ;
  int prev_skipempty ;
  size_t tmp ;
  int tmp___0 ;

  {
  prev_contained = 0;
  prev_next_list = (short *)((void *)0);
  prev_skipnl = 0;
  prev_skipwhite = 0;
  prev_skipempty = 0;
  if ((unsigned long )ktabp == (unsigned long )((void *)0)) {
    return (did_header);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 512)) {
      goto while_break;
    }
    ktab = *(ktabp + i___0);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )ktab != (unsigned long )((void *)0)) {
        if (! (! got_int)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      if ((int )ktab->syn_id == id) {
        if (prev_contained != ((int )ktab->flags & 1)) {
          outlen = 9999;
        } else { //Added block
        if (prev_skipnl != ((int )ktab->flags & 128)) {
          outlen = 9999;
        } else { //Added block
        if (prev_skipwhite != ((int )ktab->flags & 256)) {
          outlen = 9999;
        } else { //Added block
        if (prev_skipempty != ((int )ktab->flags & 512)) {
          outlen = 9999;
        } else { //Added block
        if ((unsigned long )prev_next_list != (unsigned long )ktab->next_list) {
          outlen = 9999;
        } else {
          {
          tmp = strlen((char const   *)((char *)(ktab->keyword)));
          outlen = (int )tmp;
          }
        }
        }
        }
        }
        }
        {
        tmp___0 = syn_list_header(did_header, outlen, id);
        }
        if (tmp___0) {
          prev_contained = 0;
          prev_next_list = (short *)((void *)0);
          prev_skipnl = 0;
          prev_skipwhite = 0;
          prev_skipempty = 0;
        }
        did_header = 1;
        if (prev_contained != ((int )ktab->flags & 1)) {
          {
          msg_puts_attr((char_u *)"contained", attr);
          msg_putchar(' ');
          prev_contained = (int )ktab->flags & 1;
          }
        }
        if ((unsigned long )ktab->next_list != (unsigned long )prev_next_list) {
          {
          put_id_list((char_u *)"nextgroup", ktab->next_list, attr);
          msg_putchar(' ');
          prev_next_list = ktab->next_list;
          }
          if ((int )ktab->flags & 128) {
            {
            msg_puts_attr((char_u *)"skipnl", attr);
            msg_putchar(' ');
            prev_skipnl = (int )ktab->flags & 128;
            }
          }
          if ((int )ktab->flags & 256) {
            {
            msg_puts_attr((char_u *)"skipwhite", attr);
            msg_putchar(' ');
            prev_skipwhite = (int )ktab->flags & 256;
            }
          }
          if ((int )ktab->flags & 512) {
            {
            msg_puts_attr((char_u *)"skipempty", attr);
            msg_putchar(' ');
            prev_skipempty = (int )ktab->flags & 512;
            }
          }
        }
        {
        msg_outtrans(ktab->keyword);
        }
      }
      ktab = ktab->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (did_header);
}
}
static void syn_clear_keyword(int id , struct keyentry **ktabp ) 
{ 
  int i___0 ;
  struct keyentry *ktab ;
  struct keyentry *ktab_prev ;
  struct keyentry *ktab_next ;

  {
  if ((unsigned long )ktabp == (unsigned long )((void *)0)) {
    return;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 512)) {
      goto while_break;
    }
    ktab_prev = (struct keyentry *)((void *)0);
    ktab = *(ktabp + i___0);
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )ktab != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      if ((int )ktab->syn_id == id) {
        ktab_next = ktab->next;
        if ((unsigned long )ktab_prev == (unsigned long )((void *)0)) {
          *(ktabp + i___0) = ktab_next;
        } else {
          ktab_prev->next = ktab_next;
        }
        {
        vim_free((void *)ktab);
        ktab = ktab_next;
        }
      } else {
        ktab_prev = ktab;
        ktab = ktab->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static void free_keywtab(struct keyentry **ktabp ) 
{ 
  int i___0 ;
  struct keyentry *ktab ;
  struct keyentry *ktab_next ;

  {
  if ((unsigned long )ktabp != (unsigned long )((void *)0)) {
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < 512)) {
        goto while_break;
      }
      ktab = *(ktabp + i___0);
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((unsigned long )ktab != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
        {
        ktab_next = ktab->next;
        vim_free((void *)ktab->next_list);
        vim_free((void *)ktab);
        ktab = ktab_next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)ktabp);
    }
  }
  return;
}
}
static void add_keyword(char_u *name___1 , int id , int flags___0 , short *next_list ) 
{ 
  struct keyentry *ktab ;
  struct keyentry ***ktabpp ;
  char_u *p___0 ;
  int hash ;
  size_t tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  {
  tmp = strlen((char const   *)((char *)name___1));
  tmp___0 = alloc((unsigned int )((int )(sizeof(struct keyentry ) + tmp)));
  ktab = (struct keyentry *)tmp___0;
  }
  if ((unsigned long )ktab == (unsigned long )((void *)0)) {
    return;
  }
  {
  strcpy((char * __restrict  )((char *)(ktab->keyword)), (char const   * __restrict  )((char *)name___1));
  ktab->syn_id = (short )id;
  ktab->syn_inc_tag = current_syn_inc_tag;
  ktab->flags = (short )flags___0;
  ktab->next_list = copy_id_list(next_list);
  }
  if (curbuf->b_syn_ic) {
    p___0 = ktab->keyword;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break;
      }
      {
      tmp___1 = tolower((int )*p___0);
      *p___0 = (char_u )tmp___1;
      p___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    ktabpp = & curbuf->b_keywtab_ic;
  } else {
    ktabpp = & curbuf->b_keywtab;
  }
  if ((unsigned long )*ktabpp == (unsigned long )((void *)0)) {
    {
    tmp___2 = alloc_clear((unsigned int )((int )(sizeof(struct keyentry *) * 512UL)));
    *ktabpp = (struct keyentry **)tmp___2;
    }
    if ((unsigned long )*ktabpp == (unsigned long )((void *)0)) {
      return;
    }
  }
  hash = 0;
  p___0 = ktab->keyword;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break___0;
    }
    hash += (int )*p___0;
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  hash &= 511;
  ktab->next = *(*ktabpp + hash);
  *(*ktabpp + hash) = ktab;
  return;
}
}
static char_u *get_group_name(char_u *arg , char_u **name_end ) 
{ 
  char_u *rest ;
  int tmp ;

  {
  {
  *name_end = skiptowhite(arg);
  rest = skipwhite(*name_end);
  tmp = ends_excmd((int )*arg);
  }
  if (tmp) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((int )*rest == 0) {
    return ((char_u *)((void *)0));
  }
  }
  return (rest);
}
}
static struct flag flagtab[13]  = 
  {      {(char *)"contained", 9, 1}, 
        {(char *)"oneline", 7, 4}, 
        {(char *)"keepend", 7, 1024}, 
        {(char *)"excludenl", 9, 2048}, 
        {(char *)"transparent", 11, 2}, 
        {(char *)"skipnl", 6, 128}, 
        {(char *)"skipwhite", 9, 256}, 
        {(char *)"skipempty", 9, 512}, 
        {(char *)"grouphere", 9, 16}, 
        {(char *)"groupthere", 10, 32}, 
        {(char *)"display", 7, 4096}, 
        {(char *)"extend", 6, 8192}, 
        {(char *)"fold", 4, 16384}};
static char_u *get_syn_options(char_u *arg , int *flagsp , int keyword , int *sync_idx ,
                               short **cont_list , short **next_list ) 
{ 
  int flags___0 ;
  char_u *gname_start ;
  char_u *gname ;
  int syn_id ;
  int len___0 ;
  int i___0 ;
  int fidx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  flags___0 = *flagsp;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    fidx = (int )(sizeof(flagtab) / sizeof(struct flag ));
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      fidx --;
      if (! (fidx >= 0)) {
        goto while_break___0;
      }
      {
      len___0 = flagtab[fidx].len;
      tmp___0 = strncasecmp((char const   *)((char *)arg), (char const   *)flagtab[fidx].name,
                            (size_t )len___0);
      }
      if (tmp___0 == 0) {
        {
        tmp___1 = ends_excmd((int )*(arg + len___0));
        }
        if (tmp___1) {
          goto _L___1;
        } else { //Added block
        if ((int )*(arg + len___0) == 32) {
          goto _L___1;
        } else { //Added block
        if ((int )*(arg + len___0) == 9) {
          _L___1: 
          if (keyword) {
            if (flagtab[fidx].val == 4096) {
              fidx = -1;
              goto while_break___0;
            } else { //Added block
            if (flagtab[fidx].val == 16384) {
              fidx = -1;
              goto while_break___0;
            } else { //Added block
            if (flagtab[fidx].val == 8192) {
              fidx = -1;
              goto while_break___0;
            }
            }
            }
          }
          {
          flags___0 |= flagtab[fidx].val;
          arg = skipwhite(arg + len___0);
          }
          if (flagtab[fidx].val == 16) {
            goto _L;
          } else { //Added block
          if (flagtab[fidx].val == 32) {
            _L: 
            if ((unsigned long )sync_idx == (unsigned long )((void *)0)) {
              {
              emsg((char_u *)"group[t]here not accepted here");
              }
              return ((char_u *)((void *)0));
            }
            {
            gname_start = arg;
            arg = skiptowhite(arg);
            }
            if ((unsigned long )gname_start == (unsigned long )arg) {
              return ((char_u *)((void *)0));
            }
            {
            gname = vim_strnsave(gname_start, (int )(arg - gname_start));
            }
            if ((unsigned long )gname == (unsigned long )((void *)0)) {
              return ((char_u *)((void *)0));
            }
            {
            tmp = strcmp((char const   *)((char *)gname), (char const   *)((char *)"NONE"));
            }
            if (tmp == 0) {
              *sync_idx = -2;
            } else {
              {
              syn_id = syn_name2id(gname);
              i___0 = curbuf->b_syn_patterns.ga_len;
              }
              {
              while (1) {
                while_continue___1: /* CIL Label */ ;
                i___0 --;
                if (! (i___0 >= 0)) {
                  goto while_break___1;
                }
                if ((int )((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + i___0)->sp_syn_id == syn_id) {
                  if ((int )((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + i___0)->sp_type == 2) {
                    *sync_idx = i___0;
                    goto while_break___1;
                  }
                }
              }
              while_break___1: /* CIL Label */ ;
              }
              if (i___0 < 0) {
                {
                emsg2((char_u *)"Didn\'t find region item for %s", gname);
                vim_free((void *)gname);
                }
                return ((char_u *)((void *)0));
              }
            }
            {
            vim_free((void *)gname);
            arg = skipwhite(arg);
            }
          }
          }
          goto while_break___0;
        }
        }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (fidx >= 0) {
      goto __Cont;
    }
    {
    tmp___5 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"contains"),
                          (size_t )8);
    }
    if (tmp___5 == 0) {
      if ((int )*(arg + 8) == 32) {
        goto _L___4;
      } else { //Added block
      if ((int )*(arg + 8) == 9) {
        goto _L___4;
      } else { //Added block
      if ((int )*(arg + 8) == 61) {
        _L___4: 
        if ((unsigned long )cont_list == (unsigned long )((void *)0)) {
          {
          emsg((char_u *)"contains argument not accepted here");
          }
          return ((char_u *)((void *)0));
        }
        {
        tmp___2 = get_id_list(& arg, 8, cont_list);
        }
        if (tmp___2 == 0) {
          return ((char_u *)((void *)0));
        }
      } else {
        goto _L___3;
      }
      }
      }
    } else {
      _L___3: 
      {
      tmp___4 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"nextgroup"),
                            (size_t )9);
      }
      if (tmp___4 == 0) {
        if ((int )*(arg + 9) == 32) {
          goto _L___2;
        } else { //Added block
        if ((int )*(arg + 9) == 9) {
          goto _L___2;
        } else { //Added block
        if ((int )*(arg + 9) == 61) {
          _L___2: 
          {
          tmp___3 = get_id_list(& arg, 9, next_list);
          }
          if (tmp___3 == 0) {
            return ((char_u *)((void *)0));
          }
        } else {
          goto while_break;
        }
        }
        }
      } else {
        goto while_break;
      }
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  *flagsp = flags___0;
  return (arg);
}
}
static void syn_incl_toplevel(int id , int *flagsp ) 
{ 
  short *grp_list ;
  char_u *tmp ;
  int tlg_id ;

  {
  if (*flagsp & 1) {
    return;
  } else { //Added block
  if (curbuf->b_syn_topgrp == 0) {
    return;
  }
  }
  *flagsp |= 1;
  if (curbuf->b_syn_topgrp >= 15000) {
    {
    tmp = alloc((unsigned int )(2UL * sizeof(short )));
    grp_list = (short *)tmp;
    tlg_id = curbuf->b_syn_topgrp - 15000;
    }
    if ((unsigned long )grp_list != (unsigned long )((void *)0)) {
      {
      *(grp_list + 0) = (short )id;
      *(grp_list + 1) = (short)0;
      syn_combine_list(& ((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + tlg_id)->scl_list,
                       & grp_list, 2);
      }
    }
  }
  return;
}
}
static void syn_cmd_include(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  int sgl_id ;
  char_u *group_name_end ;
  char_u *rest ;
  char_u *errormsg ;
  int prev_toplvl_grp ;
  int prev_syn_inc_tag ;
  int tmp ;
  int tmp___0 ;

  {
  {
  arg = eap->arg;
  sgl_id = 1;
  errormsg = (char_u *)((void *)0);
  eap->nextcmd = find_nextcmd(arg);
  }
  if (eap->skip) {
    return;
  }
  if ((int )*(arg + 0) == 64) {
    {
    arg ++;
    rest = get_group_name(arg, & group_name_end);
    }
    if ((unsigned long )rest == (unsigned long )((void *)0)) {
      {
      emsg((char_u *)"Filename required");
      }
      return;
    }
    {
    sgl_id = syn_check_cluster(arg, (int )(group_name_end - arg));
    eap->arg = rest;
    }
  }
  {
  eap->argt |= 24L;
  separate_nextcmd(eap);
  tmp = expand_filename(eap, syn_cmdlinep, & errormsg);
  }
  if (tmp == 0) {
    if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
      {
      emsg(errormsg);
      }
    }
    return;
  }
  {
  prev_syn_inc_tag = current_syn_inc_tag;
  running_syn_inc_tag ++;
  current_syn_inc_tag = running_syn_inc_tag;
  prev_toplvl_grp = curbuf->b_syn_topgrp;
  curbuf->b_syn_topgrp = sgl_id;
  tmp___0 = do_source(eap->arg, 0, 0);
  }
  if (tmp___0 == 0) {
    {
    emsg2(e_notopen, eap->arg);
    }
  }
  curbuf->b_syn_topgrp = prev_toplvl_grp;
  current_syn_inc_tag = prev_syn_inc_tag;
  return;
}
}
static void syn_cmd_keyword(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  char_u *group_name_end ;
  int syn_id ;
  char_u *rest ;
  char_u *keyword_copy ;
  char_u *p___0 ;
  char_u *first_arg ;
  int round ;
  int flags___0 ;
  short *next_list ;
  size_t tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  {
  arg = eap->arg;
  flags___0 = 0;
  next_list = (short *)((void *)0);
  rest = get_group_name(arg, & group_name_end);
  }
  if ((unsigned long )rest != (unsigned long )((void *)0)) {
    {
    syn_id = syn_check_group(arg, (int )(group_name_end - arg));
    tmp = strlen((char const   *)((char *)rest));
    keyword_copy = alloc((unsigned int )tmp + 1U);
    }
    if ((unsigned long )keyword_copy != (unsigned long )((void *)0)) {
      first_arg = rest;
      round = 1;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (round <= 2)) {
          goto while_break;
        }
        rest = first_arg;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if ((unsigned long )rest != (unsigned long )((void *)0)) {
            {
            tmp___3 = ends_excmd((int )*rest);
            }
            if (tmp___3) {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
          {
          rest = get_syn_options(rest, & flags___0, 1, (int *)((void *)0), (short **)((void *)0),
                                 & next_list);
          }
          if ((unsigned long )rest == (unsigned long )((void *)0)) {
            goto while_break___0;
          } else {
            {
            tmp___0 = ends_excmd((int )*rest);
            }
            if (tmp___0) {
              goto while_break___0;
            }
          }
          p___0 = keyword_copy;
          {
          while (1) {
            while_continue___1: /* CIL Label */ ;
            if (*rest) {
              if ((int )*rest == 32) {
                goto while_break___1;
              } else { //Added block
              if ((int )*rest == 9) {
                goto while_break___1;
              }
              }
            } else {
              goto while_break___1;
            }
            if ((int )*rest == 92) {
              if ((int )*(rest + 1) != 0) {
                rest ++;
              }
            }
            tmp___1 = p___0;
            p___0 ++;
            tmp___2 = rest;
            rest ++;
            *tmp___1 = *tmp___2;
          }
          while_break___1: /* CIL Label */ ;
          }
          *p___0 = (char_u )'\000';
          if (round == 2) {
            if (! eap->skip) {
              {
              p___0 = vim_strchr(keyword_copy, '[');
              }
              {
              while (1) {
                while_continue___2: /* CIL Label */ ;
                if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                  *p___0 = (char_u )'\000';
                }
                {
                add_keyword(keyword_copy, syn_id, flags___0, next_list);
                }
                if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
                  goto while_break___2;
                } else { //Added block
                if ((int )*(p___0 + 1) == 0) {
                  goto while_break___2;
                } else { //Added block
                if ((int )*(p___0 + 1) == 93) {
                  goto while_break___2;
                }
                }
                }
                *(p___0 + 0) = *(p___0 + 1);
                p___0 ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
          {
          rest = skipwhite(rest);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        if (round == 1) {
          {
          syn_incl_toplevel(syn_id, & flags___0);
          }
        }
        round ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
      vim_free((void *)keyword_copy);
      }
    }
  }
  if ((unsigned long )rest != (unsigned long )((void *)0)) {
    {
    eap->nextcmd = check_nextcmd(rest);
    }
  } else {
    {
    emsg2(e_invarg2, arg);
    }
  }
  {
  vim_free((void *)next_list);
  redraw_curbuf_later(40);
  }
  return;
}
}
static void syn_cmd_match(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  char_u *group_name_end ;
  char_u *rest ;
  struct syn_pattern item ;
  int syn_id ;
  int idx ;
  int flags___0 ;
  int sync_idx ;
  short *cont_list ;
  short *next_list ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  arg = eap->arg;
  flags___0 = 0;
  sync_idx = 0;
  cont_list = (short *)((void *)0);
  next_list = (short *)((void *)0);
  rest = get_group_name(arg, & group_name_end);
  }
  if (syncing) {
    tmp = & sync_idx;
  } else {
    tmp = (int *)((void *)0);
  }
  {
  rest = get_syn_options(rest, & flags___0, 0, tmp, & cont_list, & next_list);
  init_syn_patterns();
  memset((void *)(& item), 0, sizeof(item));
  rest = get_syn_pattern(rest, & item);
  tmp___0 = vim_regcomp_had_eol();
  }
  if (tmp___0) {
    if (! (flags___0 & 2048)) {
      flags___0 |= 8;
    }
  }
  if (syncing) {
    tmp___1 = & sync_idx;
  } else {
    tmp___1 = (int *)((void *)0);
  }
  {
  rest = get_syn_options(rest, & flags___0, 0, tmp___1, & cont_list, & next_list);
  }
  if ((unsigned long )rest != (unsigned long )((void *)0)) {
    {
    eap->nextcmd = check_nextcmd(rest);
    tmp___3 = ends_excmd((int )*rest);
    }
    if (tmp___3) {
      if (eap->skip) {
        rest = (char_u *)((void *)0);
      } else {
        {
        tmp___2 = ga_grow(& curbuf->b_syn_patterns, 1);
        }
        if (tmp___2 != 0) {
          {
          syn_id = syn_check_group(arg, (int )(group_name_end - arg));
          }
          if (syn_id != 0) {
            {
            syn_incl_toplevel(syn_id, & flags___0);
            idx = curbuf->b_syn_patterns.ga_len;
            *((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx) = item;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_syncing = (char )syncing;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_type = (char)1;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_syn_id = (short )syn_id;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_syn_inc_tag = current_syn_inc_tag;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_flags = (short )flags___0;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_sync_idx = sync_idx;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_cont_list = cont_list;
            ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_next_list = next_list;
            (curbuf->b_syn_patterns.ga_len) ++;
            (curbuf->b_syn_patterns.ga_room) --;
            }
            if (flags___0 & 48) {
              curbuf->b_syn_sync_flags |= 2;
            }
            {
            redraw_curbuf_later(40);
            }
            return;
          }
        }
      }
    } else {
      rest = (char_u *)((void *)0);
    }
  }
  {
  vim_free((void *)item.sp_prog);
  vim_free((void *)item.sp_pattern);
  vim_free((void *)cont_list);
  vim_free((void *)next_list);
  }
  if ((unsigned long )rest == (unsigned long )((void *)0)) {
    {
    emsg2(e_invarg2, arg);
    }
  }
  return;
}
}
static void syn_cmd_region(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  char_u *group_name_end ;
  char_u *rest ;
  char_u *key_end ;
  char_u *key ;
  char_u *p___0 ;
  int item ;
  struct pat_ptr *pat_ptrs[3] ;
  struct pat_ptr *ppp ;
  struct pat_ptr *ppp_next ;
  int pat_count ;
  int syn_id ;
  int matchgroup_id ;
  int not_enough ;
  int illegal ;
  int success___0 ;
  int idx ;
  int flags___0 ;
  short *cont_list ;
  short *next_list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  arg = eap->arg;
  key = (char_u *)((void *)0);
  pat_count = 0;
  matchgroup_id = 0;
  not_enough = 0;
  illegal = 0;
  success___0 = 0;
  flags___0 = 0;
  cont_list = (short *)((void *)0);
  next_list = (short *)((void *)0);
  rest = get_group_name(arg, & group_name_end);
  pat_ptrs[0] = (struct pat_ptr *)((void *)0);
  pat_ptrs[1] = (struct pat_ptr *)((void *)0);
  pat_ptrs[2] = (struct pat_ptr *)((void *)0);
  init_syn_patterns();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )rest != (unsigned long )((void *)0)) {
      {
      tmp___8 = ends_excmd((int )*rest);
      }
      if (tmp___8) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    rest = get_syn_options(rest, & flags___0, 0, (int *)((void *)0), & cont_list,
                           & next_list);
    }
    if ((unsigned long )rest == (unsigned long )((void *)0)) {
      goto while_break;
    } else {
      {
      tmp = ends_excmd((int )*rest);
      }
      if (tmp) {
        goto while_break;
      }
    }
    key_end = rest;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (*key_end) {
        if ((int )*key_end == 32) {
          goto while_break___0;
        } else { //Added block
        if ((int )*key_end == 9) {
          goto while_break___0;
        } else { //Added block
        if (! ((int )*key_end != 61)) {
          goto while_break___0;
        }
        }
        }
      } else {
        goto while_break___0;
      }
      key_end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    vim_free((void *)key);
    key = vim_strnsave_up(rest, (int )(key_end - rest));
    }
    if ((unsigned long )key == (unsigned long )((void *)0)) {
      rest = (char_u *)((void *)0);
      goto while_break;
    }
    {
    tmp___3 = strcmp((char const   *)((char *)key), (char const   *)((char *)"MATCHGROUP"));
    }
    if (tmp___3 == 0) {
      item = 3;
    } else {
      {
      tmp___2 = strcmp((char const   *)((char *)key), (char const   *)((char *)"START"));
      }
      if (tmp___2 == 0) {
        item = 0;
      } else {
        {
        tmp___1 = strcmp((char const   *)((char *)key), (char const   *)((char *)"END"));
        }
        if (tmp___1 == 0) {
          item = 2;
        } else {
          {
          tmp___0 = strcmp((char const   *)((char *)key), (char const   *)((char *)"SKIP"));
          }
          if (tmp___0 == 0) {
            if ((unsigned long )pat_ptrs[1] != (unsigned long )((void *)0)) {
              illegal = 1;
              goto while_break;
            }
            item = 1;
          } else {
            goto while_break;
          }
        }
      }
    }
    {
    rest = skipwhite(key_end);
    }
    if ((int )*rest != 61) {
      {
      rest = (char_u *)((void *)0);
      emsg2((char_u *)"Missing \'=\': %s", arg);
      }
      goto while_break;
    }
    {
    rest = skipwhite(rest + 1);
    }
    if ((int )*rest == 0) {
      not_enough = 1;
      goto while_break;
    }
    if (item == 3) {
      {
      p___0 = skiptowhite(rest);
      }
      if (p___0 - rest == 4L) {
        {
        tmp___4 = strncmp((char const   *)((char *)rest), (char const   *)((char *)"NONE"),
                          (size_t )4);
        }
        if (tmp___4 == 0) {
          matchgroup_id = 0;
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (eap->skip) {
        matchgroup_id = 0;
      } else {
        {
        matchgroup_id = syn_check_group(rest, (int )(p___0 - rest));
        }
        if (matchgroup_id == 0) {
          illegal = 1;
          goto while_break;
        }
      }
      }
      {
      rest = skipwhite(p___0);
      }
    } else {
      {
      tmp___5 = alloc((unsigned int )sizeof(struct pat_ptr ));
      ppp = (struct pat_ptr *)tmp___5;
      }
      if ((unsigned long )ppp == (unsigned long )((void *)0)) {
        rest = (char_u *)((void *)0);
        goto while_break;
      }
      {
      ppp->pp_next = pat_ptrs[item];
      pat_ptrs[item] = ppp;
      tmp___6 = alloc_clear((unsigned int )sizeof(struct syn_pattern ));
      ppp->pp_synp = (struct syn_pattern *)tmp___6;
      }
      if ((unsigned long )ppp->pp_synp == (unsigned long )((void *)0)) {
        rest = (char_u *)((void *)0);
        goto while_break;
      }
      {
      rest = get_syn_pattern(rest, ppp->pp_synp);
      }
      if (item == 2) {
        {
        tmp___7 = vim_regcomp_had_eol();
        }
        if (tmp___7) {
          if (! (flags___0 & 2048)) {
            (ppp->pp_synp)->sp_flags = (short )((int )(ppp->pp_synp)->sp_flags | 8);
          }
        }
      }
      ppp->pp_matchgroup_id = matchgroup_id;
      pat_count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)key);
  }
  if (illegal) {
    rest = (char_u *)((void *)0);
  } else { //Added block
  if (not_enough) {
    rest = (char_u *)((void *)0);
  }
  }
  if ((unsigned long )rest != (unsigned long )((void *)0)) {
    if ((unsigned long )pat_ptrs[0] == (unsigned long )((void *)0)) {
      not_enough = 1;
      rest = (char_u *)((void *)0);
    } else { //Added block
    if ((unsigned long )pat_ptrs[2] == (unsigned long )((void *)0)) {
      not_enough = 1;
      rest = (char_u *)((void *)0);
    }
    }
  }
  if ((unsigned long )rest != (unsigned long )((void *)0)) {
    {
    eap->nextcmd = check_nextcmd(rest);
    tmp___11 = ends_excmd((int )*rest);
    }
    if (tmp___11) {
      if (eap->skip) {
        rest = (char_u *)((void *)0);
      } else {
        {
        tmp___10 = ga_grow(& curbuf->b_syn_patterns, pat_count);
        }
        if (tmp___10 != 0) {
          {
          syn_id = syn_check_group(arg, (int )(group_name_end - arg));
          }
          if (syn_id != 0) {
            {
            syn_incl_toplevel(syn_id, & flags___0);
            idx = curbuf->b_syn_patterns.ga_len;
            item = 0;
            }
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              if (! (item <= 2)) {
                goto while_break___1;
              }
              ppp = pat_ptrs[item];
              {
              while (1) {
                while_continue___2: /* CIL Label */ ;
                if (! ((unsigned long )ppp != (unsigned long )((void *)0))) {
                  goto while_break___2;
                }
                *((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx) = *(ppp->pp_synp);
                ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_syncing = (char )syncing;
                if (item == 0) {
                  ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_type = (char)2;
                } else {
                  if (item == 1) {
                    tmp___9 = 4;
                  } else {
                    tmp___9 = 3;
                  }
                  ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_type = (char )tmp___9;
                }
                ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_flags = (short )((int )((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_flags | flags___0);
                ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_syn_id = (short )syn_id;
                ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_syn_inc_tag = current_syn_inc_tag;
                ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_syn_match_id = (short )ppp->pp_matchgroup_id;
                if (item == 0) {
                  ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_cont_list = cont_list;
                  ((struct syn_pattern *)curbuf->b_syn_patterns.ga_data + idx)->sp_next_list = next_list;
                }
                (curbuf->b_syn_patterns.ga_len) ++;
                (curbuf->b_syn_patterns.ga_room) --;
                idx ++;
                ppp = ppp->pp_next;
              }
              while_break___2: /* CIL Label */ ;
              }
              item ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
            redraw_curbuf_later(40);
            success___0 = 1;
            }
          }
        }
      }
    } else {
      rest = (char_u *)((void *)0);
    }
  }
  item = 0;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (item <= 2)) {
      goto while_break___3;
    }
    ppp = pat_ptrs[item];
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ((unsigned long )ppp != (unsigned long )((void *)0))) {
        goto while_break___4;
      }
      if (! success___0) {
        {
        vim_free((void *)(ppp->pp_synp)->sp_prog);
        vim_free((void *)(ppp->pp_synp)->sp_pattern);
        }
      }
      {
      vim_free((void *)ppp->pp_synp);
      ppp_next = ppp->pp_next;
      vim_free((void *)ppp);
      ppp = ppp_next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    item ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  if (! success___0) {
    {
    vim_free((void *)cont_list);
    vim_free((void *)next_list);
    }
    if (not_enough) {
      {
      emsg2((char_u *)"Not enough arguments: syntax region %s", arg);
      }
    } else { //Added block
    if (illegal) {
      {
      emsg2(e_invarg2, arg);
      }
    } else { //Added block
    if ((unsigned long )rest == (unsigned long )((void *)0)) {
      {
      emsg2(e_invarg2, arg);
      }
    }
    }
    }
  }
  return;
}
}
static int syn_compare_stub(void const   *v1 , void const   *v2 ) 
{ 
  short const   *s1 ;
  short const   *s2 ;
  int tmp ;
  int tmp___0 ;

  {
  s1 = (short const   *)v1;
  s2 = (short const   *)v2;
  if ((int const   )*s1 > (int const   )*s2) {
    tmp___0 = 1;
  } else {
    if ((int const   )*s1 < (int const   )*s2) {
      tmp = -1;
    } else {
      tmp = 0;
    }
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
static void syn_combine_list(short **clstr1 , short **clstr2 , int list_op ) 
{ 
  int count1 ;
  int count2 ;
  short *g1 ;
  short *g2 ;
  short *clstr ;
  int count___2 ;
  int round ;
  char_u *tmp ;

  {
  count1 = 0;
  count2 = 0;
  clstr = (short *)((void *)0);
  if ((unsigned long )*clstr2 == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )*clstr1 == (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if (list_op == 1) {
    _L: 
    if (list_op == 1) {
      {
      vim_free((void *)*clstr1);
      }
    }
    if (list_op == 1) {
      *clstr1 = *clstr2;
    } else { //Added block
    if (list_op == 2) {
      *clstr1 = *clstr2;
    } else {
      {
      vim_free((void *)*clstr2);
      }
    }
    }
    return;
  }
  }
  g1 = *clstr1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *g1) {
      goto while_break;
    }
    count1 ++;
    g1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  g2 = *clstr2;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! *g2) {
      goto while_break___0;
    }
    count2 ++;
    g2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  qsort((void *)*clstr1, (size_t )count1, sizeof(short ), & syn_compare_stub);
  qsort((void *)*clstr2, (size_t )count2, sizeof(short ), & syn_compare_stub);
  round = 1;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (round <= 2)) {
      goto while_break___1;
    }
    g1 = *clstr1;
    g2 = *clstr2;
    count___2 = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (*g1) {
        if (! *g2) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
      if ((int )*g1 < (int )*g2) {
        if (round == 2) {
          *(clstr + count___2) = *g1;
        }
        count___2 ++;
        g1 ++;
        goto while_continue___2;
      }
      if (list_op == 2) {
        if (round == 2) {
          *(clstr + count___2) = *g2;
        }
        count___2 ++;
      }
      if ((int )*g1 == (int )*g2) {
        g1 ++;
      }
      g2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! *g1) {
        goto while_break___3;
      }
      if (round == 2) {
        *(clstr + count___2) = *g1;
      }
      g1 ++;
      count___2 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    if (list_op == 2) {
      {
      while (1) {
        while_continue___4: /* CIL Label */ ;
        if (! *g2) {
          goto while_break___4;
        }
        if (round == 2) {
          *(clstr + count___2) = *g2;
        }
        g2 ++;
        count___2 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    if (round == 1) {
      if (count___2 == 0) {
        clstr = (short *)((void *)0);
        goto while_break___1;
      }
      {
      tmp = alloc((unsigned int )((unsigned long )(count___2 + 1) * sizeof(short )));
      clstr = (short *)tmp;
      }
      if ((unsigned long )clstr == (unsigned long )((void *)0)) {
        goto while_break___1;
      }
      *(clstr + count___2) = (short)0;
    }
    round ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  vim_free((void *)*clstr1);
  vim_free((void *)*clstr2);
  *clstr1 = clstr;
  }
  return;
}
}
static int syn_scl_name2id(char_u *name___1 ) 
{ 
  int i___0 ;
  char_u *name_u ;
  int tmp ;
  int tmp___0 ;

  {
  {
  name_u = vim_strsave_up(name___1);
  }
  if ((unsigned long )name_u == (unsigned long )((void *)0)) {
    return (0);
  }
  i___0 = curbuf->b_syn_clusters.ga_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    if ((unsigned long )((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + i___0)->scl_name_u != (unsigned long )((void *)0)) {
      {
      tmp = strcmp((char const   *)((char *)name_u), (char const   *)((char *)((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + i___0)->scl_name_u));
      }
      if (tmp == 0) {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)name_u);
  }
  if (i___0 < 0) {
    tmp___0 = 0;
  } else {
    tmp___0 = i___0 + 15000;
  }
  return (tmp___0);
}
}
static int syn_scl_namen2id(char_u *linep , int len___0 ) 
{ 
  char_u *name___1 ;
  int id ;

  {
  {
  id = 0;
  name___1 = vim_strnsave(linep, len___0);
  }
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    {
    id = syn_scl_name2id(name___1);
    vim_free((void *)name___1);
    }
  }
  return (id);
}
}
static int syn_check_cluster(char_u *pp , int len___0 ) 
{ 
  int id ;
  char_u *name___1 ;

  {
  {
  name___1 = vim_strnsave(pp, len___0);
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  id = syn_scl_name2id(name___1);
  }
  if (id == 0) {
    {
    id = syn_add_cluster(name___1);
    }
  } else {
    {
    vim_free((void *)name___1);
    }
  }
  return (id);
}
}
static int syn_add_cluster(char_u *name___1 ) 
{ 
  int len___0 ;
  int tmp ;

  {
  if ((unsigned long )curbuf->b_syn_clusters.ga_data == (unsigned long )((void *)0)) {
    curbuf->b_syn_clusters.ga_itemsize = (int )sizeof(struct syn_cluster );
    curbuf->b_syn_clusters.ga_growsize = 10;
  }
  {
  tmp = ga_grow(& curbuf->b_syn_clusters, 1);
  }
  if (tmp == 0) {
    {
    vim_free((void *)name___1);
    }
    return (0);
  }
  {
  len___0 = curbuf->b_syn_clusters.ga_len;
  memset((void *)((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + len___0),
         0, sizeof(struct syn_cluster ));
  ((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + len___0)->scl_name = name___1;
  ((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + len___0)->scl_name_u = vim_strsave_up(name___1);
  ((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + len___0)->scl_list = (short *)((void *)0);
  (curbuf->b_syn_clusters.ga_len) ++;
  (curbuf->b_syn_clusters.ga_room) --;
  }
  return (len___0 + 15000);
}
}
static void syn_cmd_cluster(EXARG *eap , int syncing ) 
{ 
  char_u *arg ;
  char_u *group_name_end ;
  char_u *rest ;
  int scl_id ;
  short *clstr_list ;
  int got_clstr ;
  int opt_len ;
  int list_op ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  arg = eap->arg;
  got_clstr = 0;
  eap->nextcmd = find_nextcmd(arg);
  }
  if (eap->skip) {
    return;
  }
  {
  rest = get_group_name(arg, & group_name_end);
  }
  if ((unsigned long )rest != (unsigned long )((void *)0)) {
    {
    tmp = syn_check_cluster(arg, (int )(group_name_end - arg));
    scl_id = tmp - 15000;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      {
      tmp___2 = strncasecmp((char const   *)((char *)rest), (char const   *)((char *)"add"),
                            (size_t )3);
      }
      if (tmp___2 == 0) {
        if ((int )*(rest + 3) == 32) {
          opt_len = 3;
          list_op = 2;
        } else { //Added block
        if ((int )*(rest + 3) == 9) {
          opt_len = 3;
          list_op = 2;
        } else { //Added block
        if ((int )*(rest + 3) == 61) {
          opt_len = 3;
          list_op = 2;
        } else {
          goto _L___0;
        }
        }
        }
      } else {
        _L___0: 
        {
        tmp___1 = strncasecmp((char const   *)((char *)rest), (char const   *)((char *)"remove"),
                              (size_t )6);
        }
        if (tmp___1 == 0) {
          if ((int )*(rest + 6) == 32) {
            opt_len = 6;
            list_op = 3;
          } else { //Added block
          if ((int )*(rest + 6) == 9) {
            opt_len = 6;
            list_op = 3;
          } else { //Added block
          if ((int )*(rest + 6) == 61) {
            opt_len = 6;
            list_op = 3;
          } else {
            goto _L;
          }
          }
          }
        } else {
          _L: 
          {
          tmp___0 = strncasecmp((char const   *)((char *)rest), (char const   *)((char *)"contains"),
                                (size_t )8);
          }
          if (tmp___0 == 0) {
            if ((int )*(rest + 8) == 32) {
              opt_len = 8;
              list_op = 1;
            } else { //Added block
            if ((int )*(rest + 8) == 9) {
              opt_len = 8;
              list_op = 1;
            } else { //Added block
            if ((int )*(rest + 8) == 61) {
              opt_len = 8;
              list_op = 1;
            } else {
              goto while_break;
            }
            }
            }
          } else {
            goto while_break;
          }
        }
      }
      {
      clstr_list = (short *)((void *)0);
      tmp___3 = get_id_list(& rest, opt_len, & clstr_list);
      }
      if (tmp___3 == 0) {
        {
        emsg2(e_invarg2, rest);
        }
        goto while_break;
      }
      {
      syn_combine_list(& ((struct syn_cluster *)curbuf->b_syn_clusters.ga_data + scl_id)->scl_list,
                       & clstr_list, list_op);
      got_clstr = 1;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (got_clstr) {
      {
      redraw_curbuf_later(40);
      }
    }
  }
  if (! got_clstr) {
    {
    emsg((char_u *)"No cluster specified");
    }
  }
  if ((unsigned long )rest == (unsigned long )((void *)0)) {
    {
    emsg2(e_invarg2, arg);
    }
  } else {
    {
    tmp___4 = ends_excmd((int )*rest);
    }
    if (! tmp___4) {
      {
      emsg2(e_invarg2, arg);
      }
    }
  }
  return;
}
}
static void init_syn_patterns(void) 
{ 


  {
  curbuf->b_syn_patterns.ga_itemsize = (int )sizeof(struct syn_pattern );
  curbuf->b_syn_patterns.ga_growsize = 10;
  return;
}
}
static char_u *get_syn_pattern(char_u *arg , struct syn_pattern *ci ) 
{ 
  char_u *end ;
  int *p___0 ;
  int idx ;
  char_u *cpo_save ;
  char_u *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;

  {
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((int )*(arg + 1) == 0) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((int )*(arg + 2) == 0) {
    return ((char_u *)((void *)0));
  }
  }
  }
  {
  end = skip_regexp(arg + 1, (int )*arg, 1);
  }
  if ((int )*end != (int )*arg) {
    {
    emsg2((char_u *)"Pattern delimiter not found: %s", arg);
    }
    return ((char_u *)((void *)0));
  }
  {
  tmp = vim_strnsave(arg + 1, (int )((end - arg) - 1L));
  ci->sp_pattern = tmp;
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  cpo_save = p_cpo;
  p_cpo = (char_u *)"";
  ci->sp_prog = vim_regcomp(ci->sp_pattern, 1);
  p_cpo = cpo_save;
  }
  if ((unsigned long )ci->sp_prog == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  ci->sp_ic = curbuf->b_syn_ic;
  end ++;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    idx = 7;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      idx --;
      if (! (idx >= 0)) {
        goto while_break___0;
      }
      {
      tmp___0 = strncmp((char const   *)((char *)end), (char const   *)spo_name_tab[idx],
                        (size_t )3);
      }
      if (tmp___0 == 0) {
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (idx >= 0) {
      p___0 = & ci->sp_offsets[idx];
      if (idx != 6) {
        {
        if ((int )*(end + 3) == 115) {
          goto case_115;
        }
        if ((int )*(end + 3) == 98) {
          goto case_98;
        }
        if ((int )*(end + 3) == 101) {
          goto case_101;
        }
        goto switch_default;
        case_115: /* CIL Label */ 
        goto switch_break;
        case_98: /* CIL Label */ 
        goto switch_break;
        case_101: /* CIL Label */ 
        idx += 7;
        goto switch_break;
        switch_default: /* CIL Label */ 
        idx = -1;
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      if (idx >= 0) {
        ci->sp_off_flags = (short )((int )ci->sp_off_flags | (1 << idx));
        if (idx == 6) {
          {
          end += 3;
          tmp___1 = getdigits(& end);
          *p___0 = (int )tmp___1;
          }
          if (! ((int )ci->sp_off_flags & 1)) {
            ci->sp_off_flags = (short )((int )ci->sp_off_flags | 1);
            ci->sp_offsets[0] = *p___0;
          }
        } else {
          end += 4;
          if ((int )*end == 43) {
            {
            end ++;
            tmp___2 = getdigits(& end);
            *p___0 = (int )tmp___2;
            }
          } else { //Added block
          if ((int )*end == 45) {
            {
            end ++;
            tmp___3 = getdigits(& end);
            *p___0 = (int )(- tmp___3);
            }
          }
          }
        }
        if ((int )*end != 44) {
          goto while_break;
        }
        end ++;
      }
    }
    if (! (idx >= 0)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___4 = ends_excmd((int )*end);
  }
  if (! tmp___4) {
    if (! ((int )*end == 32)) {
      if (! ((int )*end == 9)) {
        {
        emsg2((char_u *)"Garbage after pattern: %s", arg);
        }
        return ((char_u *)((void *)0));
      }
    }
  }
  {
  tmp___5 = skipwhite(end);
  }
  return (tmp___5);
}
}
static void syn_cmd_sync(EXARG *eap , int syncing ) 
{ 
  char_u *arg_start ;
  char_u *arg_end ;
  char_u *key ;
  char_u *next_arg ;
  int illegal ;
  int finished ;
  long n ;
  char_u *cpo_save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
  arg_start = eap->arg;
  key = (char_u *)((void *)0);
  illegal = 0;
  finished = 0;
  tmp = ends_excmd((int )*arg_start);
  }
  if (tmp) {
    {
    syn_cmd_list(eap, 1);
    }
    return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___13 = ends_excmd((int )*arg_start);
    }
    if (tmp___13) {
      goto while_break;
    }
    {
    arg_end = skiptowhite(arg_start);
    next_arg = skipwhite(arg_end);
    vim_free((void *)key);
    key = vim_strnsave_up(arg_start, (int )(arg_end - arg_start));
    tmp___12 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CCOMMENT"));
    }
    if (tmp___12 == 0) {
      if (! eap->skip) {
        curbuf->b_syn_sync_flags |= 1;
      }
      {
      tmp___2 = ends_excmd((int )*next_arg);
      }
      if (tmp___2) {
        if (! eap->skip) {
          {
          tmp___1 = syn_name2id((char_u *)"Comment");
          curbuf->b_syn_sync_id = (short )tmp___1;
          }
        }
      } else {
        {
        arg_end = skiptowhite(next_arg);
        }
        if (! eap->skip) {
          {
          tmp___0 = syn_check_group(next_arg, (int )(arg_end - next_arg));
          curbuf->b_syn_sync_id = (short )tmp___0;
          }
        }
        {
        next_arg = skipwhite(arg_end);
        }
      }
    } else {
      {
      tmp___9 = strncmp((char const   *)((char *)key), (char const   *)((char *)"LINES"),
                        (size_t )5);
      }
      if (tmp___9 == 0) {
        goto _L;
      } else {
        {
        tmp___10 = strncmp((char const   *)((char *)key), (char const   *)((char *)"MINLINES"),
                           (size_t )8);
        }
        if (tmp___10 == 0) {
          goto _L;
        } else {
          {
          tmp___11 = strncmp((char const   *)((char *)key), (char const   *)((char *)"MAXLINES"),
                             (size_t )8);
          }
          if (tmp___11 == 0) {
            _L: 
            if ((int )*(key + 0) == 76) {
              arg_end = key + 6;
            } else {
              arg_end = key + 9;
            }
            if ((int )*(arg_end + -1) != 61) {
              illegal = 1;
              goto while_break;
            } else {
              {
              tmp___3 = __ctype_b_loc();
              }
              if (! ((int const   )*(*tmp___3 + (int )*arg_end) & 2048)) {
                illegal = 1;
                goto while_break;
              }
            }
            {
            n = getdigits(& arg_end);
            }
            if (! eap->skip) {
              if ((int )*(key + 1) == 65) {
                curbuf->b_syn_sync_maxlines = n;
              } else {
                curbuf->b_syn_sync_minlines = n;
              }
            }
          } else {
            {
            tmp___8 = strcmp((char const   *)((char *)key), (char const   *)((char *)"LINECONT"));
            }
            if (tmp___8 == 0) {
              if ((unsigned long )curbuf->b_syn_linecont_pat != (unsigned long )((void *)0)) {
                {
                emsg((char_u *)"syntax sync: line continuations pattern specified twice");
                finished = 1;
                }
                goto while_break;
              }
              {
              arg_end = skip_regexp(next_arg + 1, (int )*next_arg, 1);
              }
              if ((int )*arg_end != (int )*next_arg) {
                illegal = 1;
                goto while_break;
              }
              if (! eap->skip) {
                {
                tmp___4 = vim_strnsave(next_arg + 1, (int )((arg_end - next_arg) - 1L));
                curbuf->b_syn_linecont_pat = tmp___4;
                }
                if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
                  finished = 1;
                  goto while_break;
                }
                {
                curbuf->b_syn_linecont_ic = curbuf->b_syn_ic;
                cpo_save = p_cpo;
                p_cpo = (char_u *)"";
                curbuf->b_syn_linecont_prog = vim_regcomp(curbuf->b_syn_linecont_pat,
                                                          1);
                p_cpo = cpo_save;
                }
                if ((unsigned long )curbuf->b_syn_linecont_prog == (unsigned long )((void *)0)) {
                  {
                  vim_free((void *)curbuf->b_syn_linecont_pat);
                  curbuf->b_syn_linecont_pat = (char_u *)((void *)0);
                  finished = 1;
                  }
                  goto while_break;
                }
              }
              {
              next_arg = skipwhite(arg_end + 1);
              }
            } else {
              {
              eap->arg = next_arg;
              tmp___7 = strcmp((char const   *)((char *)key), (char const   *)((char *)"MATCH"));
              }
              if (tmp___7 == 0) {
                {
                syn_cmd_match(eap, 1);
                }
              } else {
                {
                tmp___6 = strcmp((char const   *)((char *)key), (char const   *)((char *)"REGION"));
                }
                if (tmp___6 == 0) {
                  {
                  syn_cmd_region(eap, 1);
                  }
                } else {
                  {
                  tmp___5 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CLEAR"));
                  }
                  if (tmp___5 == 0) {
                    {
                    syn_cmd_clear(eap, 1);
                    }
                  } else {
                    illegal = 1;
                  }
                }
              }
              finished = 1;
              goto while_break;
            }
          }
        }
      }
    }
    arg_start = next_arg;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)key);
  }
  if (illegal) {
    {
    emsg2((char_u *)"Illegal arguments: %s", arg_start);
    }
  } else { //Added block
  if (! finished) {
    {
    eap->nextcmd = check_nextcmd(arg_start);
    redraw_curbuf_later(40);
    }
  }
  }
  return;
}
}
static int get_id_list(char_u **arg , int keylen , short **list ) 
{ 
  char_u *p___0 ;
  char_u *end ;
  int round ;
  int count___2 ;
  int total_count ;
  short *retval ;
  char_u *name___1 ;
  vim_regexp *prog ;
  int id ;
  int i___0 ;
  int failed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;

  {
  p___0 = (char_u *)((void *)0);
  total_count = 0;
  retval = (short *)((void *)0);
  failed = 0;
  round = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (round <= 2)) {
      goto while_break;
    }
    {
    p___0 = skipwhite(*arg + keylen);
    }
    if ((int )*p___0 != 61) {
      {
      emsg2((char_u *)"Missing equal sign: %s", *arg);
      }
      goto while_break;
    }
    {
    p___0 = skipwhite(p___0 + 1);
    tmp = ends_excmd((int )*p___0);
    }
    if (tmp) {
      {
      emsg2((char_u *)"Empty argument: %s", *arg);
      }
      goto while_break;
    }
    count___2 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___5 = ends_excmd((int )*p___0);
      }
      if (tmp___5) {
        goto while_break___0;
      }
      end = p___0;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (*end) {
          if ((int )*end == 32) {
            goto while_break___1;
          } else { //Added block
          if ((int )*end == 9) {
            goto while_break___1;
          } else { //Added block
          if (! ((int )*end != 44)) {
            goto while_break___1;
          }
          }
          }
        } else {
          goto while_break___1;
        }
        end ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      name___1 = alloc((unsigned int )((int )((end - p___0) + 3L)));
      }
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
        failed = 1;
        goto while_break___0;
      }
      {
      strncpy((char * __restrict  )((char *)(name___1 + 1)), (char const   * __restrict  )((char *)p___0),
              (size_t )(end - p___0));
      *(name___1 + ((end - p___0) + 1L)) = (char_u )'\000';
      tmp___3 = strcmp((char const   *)((char *)(name___1 + 1)), (char const   *)((char *)"ALLBUT"));
      }
      if (tmp___3 == 0) {
        goto _L;
      } else {
        {
        tmp___4 = strcmp((char const   *)((char *)(name___1 + 1)), (char const   *)((char *)"ALL"));
        }
        if (tmp___4 == 0) {
          _L: 
          {
          tmp___0 = toupper((int )*(*arg));
          }
          if (tmp___0 != 67) {
            {
            emsg2((char_u *)"%s not allowed here", name___1 + 1);
            failed = 1;
            vim_free((void *)name___1);
            }
            goto while_break___0;
          }
          if (count___2 != 0) {
            {
            emsg2((char_u *)"%s must be first in contains list", name___1 + 1);
            failed = 1;
            vim_free((void *)name___1);
            }
            goto while_break___0;
          }
          id = 9999 + current_syn_inc_tag;
        } else { //Added block
        if ((int )*(name___1 + 1) == 64) {
          {
          id = syn_check_cluster(name___1 + 2, (int )((end - p___0) - 1L));
          }
        } else {
          {
          tmp___2 = strpbrk((char const   *)((char *)(name___1 + 1)), (char const   *)((char *)((char_u *)"\\.*^$~[")));
          }
          if ((unsigned long )((char_u *)tmp___2) == (unsigned long )((void *)0)) {
            {
            id = syn_check_group(name___1 + 1, (int )(end - p___0));
            }
          } else {
            {
            *name___1 = (char_u )'^';
            strcat((char * __restrict  )((char *)name___1), (char const   * __restrict  )((char *)"$"));
            prog = vim_regcomp(name___1, 1);
            }
            if ((unsigned long )prog == (unsigned long )((void *)0)) {
              {
              failed = 1;
              vim_free((void *)name___1);
              }
              goto while_break___0;
            }
            reg_ic = 1;
            id = 0;
            i___0 = highlight_ga.ga_len;
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              i___0 --;
              if (! (i___0 >= 0)) {
                goto while_break___2;
              }
              {
              tmp___1 = vim_regexec(prog, ((struct hl_group *)highlight_ga.ga_data + i___0)->sg_name,
                                    1);
              }
              if (tmp___1) {
                if (round == 2) {
                  if (count___2 >= total_count) {
                    {
                    vim_free((void *)retval);
                    round = 1;
                    }
                  } else {
                    *(retval + count___2) = (short )(i___0 + 1);
                  }
                }
                count___2 ++;
                id = -1;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            {
            vim_free((void *)prog);
            }
          }
        }
        }
      }
      {
      vim_free((void *)name___1);
      }
      if (id == 0) {
        {
        emsg2((char_u *)"Unknown group name: %s", p___0);
        failed = 1;
        }
        goto while_break___0;
      }
      if (id > 0) {
        if (round == 2) {
          if (count___2 >= total_count) {
            {
            vim_free((void *)retval);
            round = 1;
            }
          } else {
            *(retval + count___2) = (short )id;
          }
        }
        count___2 ++;
      }
      {
      p___0 = skipwhite(end);
      }
      if ((int )*p___0 != 44) {
        goto while_break___0;
      }
      {
      p___0 = skipwhite(p___0 + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (failed) {
      goto while_break;
    }
    if (round == 1) {
      {
      tmp___6 = alloc((unsigned int )((unsigned long )(count___2 + 1) * sizeof(short )));
      retval = (short *)tmp___6;
      }
      if ((unsigned long )retval == (unsigned long )((void *)0)) {
        goto while_break;
      }
      *(retval + count___2) = (short)0;
      total_count = count___2;
    }
    round ++;
  }
  while_break: /* CIL Label */ ;
  }
  *arg = p___0;
  if (failed) {
    {
    vim_free((void *)retval);
    }
    return (0);
  } else { //Added block
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
    {
    vim_free((void *)retval);
    }
    return (0);
  }
  }
  if ((unsigned long )*list == (unsigned long )((void *)0)) {
    *list = retval;
  } else {
    {
    vim_free((void *)retval);
    }
  }
  return (1);
}
}
static short *copy_id_list(short *list ) 
{ 
  int len___0 ;
  int count___2 ;
  short *retval ;
  char_u *tmp ;

  {
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    return ((short *)((void *)0));
  }
  count___2 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *(list + count___2)) {
      goto while_break;
    }
    count___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  len___0 = (int )((unsigned long )(count___2 + 1) * sizeof(short ));
  tmp = alloc((unsigned int )len___0);
  retval = (short *)tmp;
  }
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
    {
    memmove((void *)((char *)retval), (void const   *)((char *)list), (size_t )len___0);
    }
  }
  return (retval);
}
}
static int in_id_list(short *list , int id , int inctag , int contained ) 
{ 
  int retval ;
  short scl_id ;
  short *scl_list ;
  int tmp ;

  {
  if ((unsigned long )list == (unsigned long )((short *)-1)) {
    return (! contained);
  }
  if ((int )*list >= 9999) {
    if ((int )*list < 15000) {
      if ((int )*list - 9999 != inctag) {
        return (0);
      }
      list ++;
      retval = 0;
    } else {
      retval = 1;
    }
  } else {
    retval = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *list) {
      goto while_break;
    }
    if ((int )*list == id) {
      return (retval);
    }
    scl_id = (short )((int )*list - 15000);
    if ((int )scl_id >= 0) {
      scl_list = ((struct syn_cluster *)syn_buf->b_syn_clusters.ga_data + (int )scl_id)->scl_list;
      if ((unsigned long )scl_list != (unsigned long )((void *)0)) {
        {
        tmp = in_id_list(scl_list, id, inctag, contained);
        }
        if (tmp) {
          return (retval);
        }
      }
    }
    list ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (! retval);
}
}
static struct subcommand subcommands[14]  = 
  {      {(char *)"case", & syn_cmd_case}, 
        {(char *)"clear", & syn_cmd_clear}, 
        {(char *)"cluster", & syn_cmd_cluster}, 
        {(char *)"include", & syn_cmd_include}, 
        {(char *)"keyword", & syn_cmd_keyword}, 
        {(char *)"list", & syn_cmd_list}, 
        {(char *)"manual", & syn_cmd_manual}, 
        {(char *)"match", & syn_cmd_match}, 
        {(char *)"on", & syn_cmd_on}, 
        {(char *)"off", & syn_cmd_off}, 
        {(char *)"region", & syn_cmd_region}, 
        {(char *)"sync", & syn_cmd_sync}, 
        {(char *)"", & syn_cmd_list}, 
        {(char *)((void *)0), (void (*)(EXARG * , int  ))((void *)0)}};
void do_syntax(EXARG *eap , char_u **cmdlinep ) 
{ 
  char_u *arg ;
  char_u *subcmd_end ;
  char_u *subcmd_name ;
  int i___0 ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  arg = eap->arg;
  syn_cmdlinep = cmdlinep;
  subcmd_end = arg;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp + (int )*subcmd_end) & 1024)) {
      goto while_break;
    }
    subcmd_end ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  subcmd_name = vim_strnsave(arg, (int )(subcmd_end - arg));
  }
  if ((unsigned long )subcmd_name != (unsigned long )((void *)0)) {
    if (eap->skip) {
      emsg_off ++;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )subcommands[i___0].name == (unsigned long )((void *)0)) {
        {
        emsg2((char_u *)"Invalid :syntax subcommand: %s", subcmd_name);
        }
        goto while_break___0;
      }
      {
      tmp___0 = strcmp((char const   *)((char *)subcmd_name), (char const   *)((char *)((char_u *)subcommands[i___0].name)));
      }
      if (tmp___0 == 0) {
        {
        eap->arg = skipwhite(subcmd_end);
        (*(subcommands[i___0].func))(eap, 0);
        }
        goto while_break___0;
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    vim_free((void *)subcmd_name);
    }
    if (eap->skip) {
      emsg_off --;
    }
  }
  return;
}
}
int syntax_present(BUF *buf___3 ) 
{ 
  int tmp ;

  {
  if (buf___3->b_syn_patterns.ga_len != 0) {
    tmp = 1;
  } else { //Added block
  if (buf___3->b_syn_clusters.ga_len != 0) {
    tmp = 1;
  } else { //Added block
  if ((unsigned long )curbuf->b_keywtab != (unsigned long )((void *)0)) {
    tmp = 1;
  } else { //Added block
  if ((unsigned long )curbuf->b_keywtab_ic != (unsigned long )((void *)0)) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  }
  }
  return (tmp);
}
}
static enum __anonenum_expand_what_169 expand_what  ;
void set_context_in_syntax_cmd(char_u *arg ) 
{ 
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;

  {
  expand_context = 12;
  expand_what = (enum __anonenum_expand_what_169 )0;
  expand_pattern = arg;
  include_link = 0;
  if ((int )*arg != 0) {
    {
    p___0 = skiptowhite(arg);
    }
    if ((int )*p___0 != 0) {
      {
      expand_pattern = skipwhite(p___0);
      tmp___4 = skiptowhite(expand_pattern);
      }
      if ((int )*tmp___4 != 0) {
        expand_context = 0;
      } else {
        {
        tmp___3 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"case"),
                              (size_t )(p___0 - arg));
        }
        if (tmp___3 == 0) {
          expand_what = (enum __anonenum_expand_what_169 )1;
        } else {
          {
          tmp = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"keyword"),
                            (size_t )(p___0 - arg));
          }
          if (tmp == 0) {
            expand_context = 13;
          } else {
            {
            tmp___0 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"region"),
                                  (size_t )(p___0 - arg));
            }
            if (tmp___0 == 0) {
              expand_context = 13;
            } else {
              {
              tmp___1 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"match"),
                                    (size_t )(p___0 - arg));
              }
              if (tmp___1 == 0) {
                expand_context = 13;
              } else {
                {
                tmp___2 = strncasecmp((char const   *)((char *)arg), (char const   *)((char *)"list"),
                                      (size_t )(p___0 - arg));
                }
                if (tmp___2 == 0) {
                  expand_context = 13;
                } else {
                  expand_context = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
static char *case_args[3]  = {      (char *)"match",      (char *)"ignore",      (char *)((void *)0)};
char_u *get_syntax_name(int idx ) 
{ 


  {
  if ((unsigned int )expand_what == 0U) {
    return ((char_u *)subcommands[idx].name);
  }
  return ((char_u *)case_args[idx]);
}
}
int syn_get_id(long line , long col , int trans___0 ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )curwin->w_buffer != (unsigned long )syn_buf) {
    {
    syntax_start(curwin, line);
    }
  } else { //Added block
  if (col < (long )current_col) {
    {
    syntax_start(curwin, line);
    }
  } else { //Added block
  if (line != current_lnum) {
    {
    syntax_start(curwin, line);
    }
  }
  }
  }
  {
  tmp = ml_get(line);
  get_syntax_attr((colnr_t )col, tmp);
  }
  if (trans___0) {
    tmp___0 = current_trans_id;
  } else {
    tmp___0 = current_id;
  }
  return (tmp___0);
}
}
static int syn_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) 
{ 
  int retval ;
  BUF *save_curbuf ;

  {
  {
  save_curbuf = curbuf;
  curbuf = syn_buf;
  retval = vim_regexec(prog, string___0, at_bol);
  curbuf = save_curbuf;
  }
  return (retval);
}
}
static char *highlight_init_both[9]  = 
  {      (char *)"ErrorMsg term=standout ctermbg=DarkRed ctermfg=White guibg=Red guifg=White",      (char *)"IncSearch term=reverse cterm=reverse gui=reverse",      (char *)"ModeMsg term=bold cterm=bold gui=bold",      (char *)"NonText term=bold ctermfg=Blue gui=bold guifg=Blue", 
        (char *)"StatusLine term=reverse,bold cterm=reverse,bold gui=reverse,bold",      (char *)"StatusLineNC term=reverse cterm=reverse gui=reverse",      (char *)"Visual term=reverse cterm=reverse gui=reverse guifg=Grey guibg=fg",      (char *)"VisualNOS term=underline,bold cterm=underline,bold gui=underline,bold", 
        (char *)((void *)0)};
static char *highlight_init_light[11]  = 
  {      (char *)"Directory term=bold ctermfg=DarkBlue guifg=Blue",      (char *)"LineNr term=underline ctermfg=Brown guifg=Brown",      (char *)"MoreMsg term=bold ctermfg=DarkGreen gui=bold guifg=SeaGreen",      (char *)"Normal gui=NONE", 
        (char *)"Question term=standout ctermfg=DarkGreen gui=bold guifg=SeaGreen",      (char *)"Search term=reverse ctermbg=Yellow ctermfg=NONE guibg=Yellow guifg=NONE",      (char *)"SpecialKey term=bold ctermfg=DarkBlue guifg=Blue",      (char *)"Title term=bold ctermfg=DarkMagenta gui=bold guifg=Magenta", 
        (char *)"WarningMsg term=standout ctermfg=DarkRed guifg=Red",      (char *)"WildMenu term=standout ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)((void *)0)};
static char *highlight_init_dark[11]  = 
  {      (char *)"Directory term=bold ctermfg=LightCyan guifg=Cyan",      (char *)"LineNr term=underline ctermfg=Yellow guifg=Yellow",      (char *)"MoreMsg term=bold ctermfg=LightGreen gui=bold guifg=SeaGreen",      (char *)"Normal gui=NONE", 
        (char *)"Question term=standout ctermfg=LightGreen gui=bold guifg=Green",      (char *)"Search term=reverse ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)"SpecialKey term=bold ctermfg=LightBlue guifg=Cyan",      (char *)"Title term=bold ctermfg=LightMagenta gui=bold guifg=Magenta", 
        (char *)"WarningMsg term=standout ctermfg=LightRed guifg=Red",      (char *)"WildMenu term=standout ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)((void *)0)};
static int had_both  =    0;
void init_highlight(int both ) 
{ 
  int i___0 ;
  char **pp ;
  int tmp ;

  {
  if (both) {
    had_both = 1;
    pp = highlight_init_both;
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )*(pp + i___0) != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {
      do_highlight((char_u *)*(pp + i___0), 0, 1);
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if (! had_both) {
    return;
  }
  }
  {
  tmp = tolower((int )*p_bg);
  }
  if (tmp == 108) {
    pp = highlight_init_light;
  } else {
    pp = highlight_init_dark;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )*(pp + i___0) != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    do_highlight((char_u *)*(pp + i___0), 0, 1);
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
static char *color_names[26]  = 
  {      (char *)"Black",      (char *)"DarkBlue",      (char *)"DarkGreen",      (char *)"DarkCyan", 
        (char *)"DarkRed",      (char *)"DarkMagenta",      (char *)"Brown",      (char *)"Gray", 
        (char *)"Grey",      (char *)"LightGray",      (char *)"LightGrey",      (char *)"DarkGray", 
        (char *)"DarkGrey",      (char *)"Blue",      (char *)"LightBlue",      (char *)"Green", 
        (char *)"LightGreen",      (char *)"Cyan",      (char *)"LightCyan",      (char *)"Red", 
        (char *)"LightRed",      (char *)"Magenta",      (char *)"LightMagenta",      (char *)"Yellow", 
        (char *)"White",      (char *)"NONE"};
static int color_numbers_16[26]  = 
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        7,      7,      7,      8, 
        8,      9,      9,      10, 
        10,      11,      11,      12, 
        12,      13,      13,      14, 
        15,      -1};
static int color_numbers_8[26]  = 
  {      0,      4,      2,      6, 
        1,      5,      3,      7, 
        7,      7,      7,      8, 
        8,      12,      12,      10, 
        10,      14,      14,      9, 
        9,      13,      13,      11, 
        15,      -1};
void do_highlight(char_u *line , int forceit , int init ) 
{ 
  char_u *name_end ;
  char_u *p___0 ;
  char_u *linep ;
  char_u *key_start ;
  char_u *arg_start ;
  char_u *key ;
  char_u *arg ;
  long i___0 ;
  int off___0 ;
  int len___0 ;
  int attr ;
  int id ;
  int idx ;
  int dodefault ;
  int doclear ;
  int dolink ;
  int error ;
  int color ;
  int is_normal_group ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *from_start ;
  char_u *from_end ;
  char_u *to_start ;
  char_u *to_end ;
  int from_id ;
  int to_id ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char_u *tmp___26 ;
  char_u buf___3[100] ;
  char_u *tname ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  char_u *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
  {
  key = (char_u *)((void *)0);
  arg = (char_u *)((void *)0);
  dodefault = 0;
  doclear = 0;
  dolink = 0;
  error = 0;
  is_normal_group = 0;
  tmp = ends_excmd((int )*line);
  }
  if (tmp) {
    i___0 = 1L;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (i___0 <= (long )highlight_ga.ga_len) {
        if (! (! got_int)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      {
      highlight_list_one((int )i___0);
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    return;
  }
  {
  name_end = skiptowhite(line);
  linep = skipwhite(name_end);
  tmp___0 = strncmp((char const   *)((char *)line), (char const   *)((char *)"default"),
                    (size_t )(name_end - line));
  }
  if (tmp___0 == 0) {
    {
    dodefault = 1;
    line = linep;
    name_end = skiptowhite(line);
    linep = skipwhite(name_end);
    }
  }
  {
  tmp___1 = strncmp((char const   *)((char *)line), (char const   *)((char *)"clear"),
                    (size_t )(name_end - line));
  }
  if (tmp___1 == 0) {
    doclear = 1;
  }
  {
  tmp___2 = strncmp((char const   *)((char *)line), (char const   *)((char *)"link"),
                    (size_t )(name_end - line));
  }
  if (tmp___2 == 0) {
    dolink = 1;
  }
  if (! doclear) {
    if (! dolink) {
      {
      tmp___3 = ends_excmd((int )*linep);
      }
      if (tmp___3) {
        {
        id = syn_namen2id(line, (int )(name_end - line));
        }
        if (id == 0) {
          {
          emsg2((char_u *)"highlight group not found: %s", line);
          }
        } else {
          {
          highlight_list_one(id);
          }
        }
        return;
      }
    }
  }
  if (dolink) {
    {
    from_start = linep;
    from_end = skiptowhite(from_start);
    to_start = skipwhite(from_end);
    to_end = skiptowhite(to_start);
    tmp___4 = ends_excmd((int )*from_start);
    }
    if (tmp___4) {
      {
      emsg2((char_u *)"Not enough arguments: \":highlight link %s\"", from_start);
      }
      return;
    } else {
      {
      tmp___5 = ends_excmd((int )*to_start);
      }
      if (tmp___5) {
        {
        emsg2((char_u *)"Not enough arguments: \":highlight link %s\"", from_start);
        }
        return;
      }
    }
    {
    tmp___6 = skipwhite(to_end);
    tmp___7 = ends_excmd((int )*tmp___6);
    }
    if (! tmp___7) {
      {
      emsg2((char_u *)"Too many arguments: \":highlight link %s\"", from_start);
      }
      return;
    }
    {
    from_id = syn_check_group(from_start, (int )(from_end - from_start));
    tmp___8 = strncmp((char const   *)((char *)to_start), (char const   *)((char *)"NONE"),
                      (size_t )4);
    }
    if (tmp___8 == 0) {
      to_id = 0;
    } else {
      {
      to_id = syn_check_group(to_start, (int )(to_end - to_start));
      }
    }
    if (from_id > 0) {
      if (! init) {
        goto _L___2;
      } else { //Added block
      if (((struct hl_group *)highlight_ga.ga_data + (from_id - 1))->sg_set == 0) {
        _L___2: 
        if (to_id > 0) {
          if (! forceit) {
            if (! init) {
              {
              tmp___9 = hl_has_settings(from_id - 1, dodefault);
              }
              if (tmp___9) {
                if ((unsigned long )sourcing_name == (unsigned long )((void *)0)) {
                  if (! dodefault) {
                    {
                    emsg((char_u *)"group has settings, highlight link ignored");
                    }
                  }
                }
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (! init) {
            ((struct hl_group *)highlight_ga.ga_data + (from_id - 1))->sg_set |= 8;
          }
          ((struct hl_group *)highlight_ga.ga_data + (from_id - 1))->sg_link = to_id;
        }
      }
      }
    }
    {
    redraw_curbuf_later(40);
    }
    return;
  }
  if (doclear) {
    {
    line = linep;
    tmp___10 = ends_excmd((int )*line);
    }
    if (tmp___10) {
      {
      emsg((char_u *)"Cannot clear all highlight groups");
      }
      return;
    }
    {
    name_end = skiptowhite(line);
    linep = skipwhite(name_end);
    }
  }
  {
  id = syn_check_group(line, (int )(name_end - line));
  }
  if (id == 0) {
    return;
  }
  idx = id - 1;
  if (dodefault) {
    {
    tmp___11 = hl_has_settings(idx, 1);
    }
    if (tmp___11) {
      return;
    }
  }
  {
  tmp___12 = strcmp((char const   *)((char *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_name_u),
                    (char const   *)((char *)"NORMAL"));
  }
  if (tmp___12 == 0) {
    is_normal_group = 1;
  }
  if (doclear) {
    {
    highlight_clear(idx);
    }
  } else {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp___43 = ends_excmd((int )*linep);
      }
      if (tmp___43) {
        goto while_break___0;
      }
      key_start = linep;
      if ((int )*linep == 61) {
        {
        emsg2((char_u *)"unexpected equal sign: %s", key_start);
        error = 1;
        }
        goto while_break___0;
      }
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        if (*linep) {
          if ((int )*linep == 32) {
            goto while_break___1;
          } else { //Added block
          if ((int )*linep == 9) {
            goto while_break___1;
          } else { //Added block
          if (! ((int )*linep != 61)) {
            goto while_break___1;
          }
          }
          }
        } else {
          goto while_break___1;
        }
        linep ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      vim_free((void *)key);
      key = vim_strnsave_up(key_start, (int )(linep - key_start));
      }
      if ((unsigned long )key == (unsigned long )((void *)0)) {
        error = 1;
        goto while_break___0;
      }
      {
      linep = skipwhite(linep);
      tmp___13 = strcmp((char const   *)((char *)key), (char const   *)((char *)"NONE"));
      }
      if (tmp___13 == 0) {
        if (! init) {
          goto _L___3;
        } else { //Added block
        if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set == 0) {
          _L___3: 
          if (! init) {
            ((struct hl_group *)highlight_ga.ga_data + idx)->sg_set |= 7;
          }
          {
          highlight_clear(idx);
          }
        }
        }
        goto while_continue___0;
      }
      if ((int )*linep != 61) {
        {
        emsg2((char_u *)"missing equal sign: %s", key_start);
        error = 1;
        }
        goto while_break___0;
      }
      {
      linep ++;
      linep = skipwhite(linep);
      }
      if ((int )*linep == 39) {
        {
        linep ++;
        arg_start = linep;
        linep = vim_strchr(linep, '\'');
        }
      } else {
        {
        arg_start = linep;
        linep = skiptowhite(linep);
        }
      }
      if ((unsigned long )linep == (unsigned long )arg_start) {
        {
        emsg2((char_u *)"missing argument: %s", key_start);
        error = 1;
        }
        goto while_break___0;
      }
      {
      vim_free((void *)arg);
      arg = vim_strnsave(arg_start, (int )(linep - arg_start));
      }
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
        error = 1;
        goto while_break___0;
      }
      if ((int )*linep == 39) {
        linep ++;
      }
      {
      tmp___40 = strcmp((char const   *)((char *)key), (char const   *)((char *)"TERM"));
      }
      if (tmp___40 == 0) {
        goto _L___9;
      } else {
        {
        tmp___41 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CTERM"));
        }
        if (tmp___41 == 0) {
          goto _L___9;
        } else {
          {
          tmp___42 = strcmp((char const   *)((char *)key), (char const   *)((char *)"GUI"));
          }
          if (tmp___42 == 0) {
            _L___9: 
            attr = 0;
            off___0 = 0;
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              if (! ((int )*(arg + off___0) != 0)) {
                goto while_break___2;
              }
              i___0 = (long )(sizeof(hl_attr_table) / sizeof(int ));
              {
              while (1) {
                while_continue___3: /* CIL Label */ ;
                i___0 --;
                if (! (i___0 >= 0L)) {
                  goto while_break___3;
                }
                {
                tmp___14 = strlen((char const   *)hl_name_table[i___0]);
                len___0 = (int )tmp___14;
                tmp___15 = strncasecmp((char const   *)((char *)(arg + off___0)),
                                       (char const   *)hl_name_table[i___0], (size_t )len___0);
                }
                if (tmp___15 == 0) {
                  attr |= hl_attr_table[i___0];
                  off___0 += len___0;
                  goto while_break___3;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
              if (i___0 < 0L) {
                {
                emsg2((char_u *)"Illegal value: %s", arg);
                error = 1;
                }
                goto while_break___2;
              }
              if ((int )*(arg + off___0) == 44) {
                off___0 ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            if (error) {
              goto while_break___0;
            }
            if ((int )*key == 84) {
              if (! init) {
                goto _L___4;
              } else { //Added block
              if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 1)) {
                _L___4: 
                if (! init) {
                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_set |= 1;
                }
                ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term = attr;
              }
              }
            } else { //Added block
            if ((int )*key == 67) {
              if (! init) {
                goto _L___5;
              } else { //Added block
              if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 2)) {
                _L___5: 
                if (! init) {
                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_set |= 2;
                }
                ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm = attr;
                ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold = 0;
              }
              }
            }
            }
          } else {
            {
            tmp___39 = strcmp((char const   *)((char *)key), (char const   *)((char *)"FONT"));
            }
            if (! (tmp___39 == 0)) {
              {
              tmp___37 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CTERMFG"));
              }
              if (tmp___37 == 0) {
                goto _L___8;
              } else {
                {
                tmp___38 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CTERMBG"));
                }
                if (tmp___38 == 0) {
                  _L___8: 
                  if (! init) {
                    goto _L___6;
                  } else { //Added block
                  if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 2)) {
                    _L___6: 
                    if (! init) {
                      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_set |= 2;
                    }
                    if ((int )*(key + 5) == 70) {
                      if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold) {
                        ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm &= -3;
                        ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold = 0;
                      }
                    }
                    {
                    tmp___22 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___22 + (int )*arg) & 2048) {
                      {
                      color = atoi((char const   *)((char *)arg));
                      }
                    } else {
                      {
                      tmp___21 = strcasecmp((char const   *)((char *)arg), (char const   *)((char *)"fg"));
                      }
                      if (tmp___21 == 0) {
                        if (cterm_normal_fg_color) {
                          color = cterm_normal_fg_color - 1;
                        } else {
                          {
                          emsg((char_u *)"FG color unknown");
                          error = 1;
                          }
                          goto while_break___0;
                        }
                      } else {
                        {
                        tmp___20 = strcasecmp((char const   *)((char *)arg), (char const   *)((char *)"bg"));
                        }
                        if (tmp___20 == 0) {
                          if (cterm_normal_bg_color) {
                            color = cterm_normal_bg_color - 1;
                          } else {
                            {
                            emsg((char_u *)"BG color unknown");
                            error = 1;
                            }
                            goto while_break___0;
                          }
                        } else {
                          {
                          off___0 = toupper((int )*arg);
                          i___0 = (long )(sizeof(color_names) / sizeof(char *));
                          }
                          {
                          while (1) {
                            while_continue___4: /* CIL Label */ ;
                            i___0 --;
                            if (! (i___0 >= 0L)) {
                              goto while_break___4;
                            }
                            if (off___0 == (int )*(color_names[i___0] + 0)) {
                              {
                              tmp___16 = strcasecmp((char const   *)((char *)(arg + 1)),
                                                    (char const   *)(color_names[i___0] + 1));
                              }
                              if (tmp___16 == 0) {
                                goto while_break___4;
                              }
                            }
                          }
                          while_break___4: /* CIL Label */ ;
                          }
                          if (i___0 < 0L) {
                            {
                            emsg2((char_u *)"Color name or number not recognized: %s",
                                  key_start);
                            error = 1;
                            }
                            goto while_break___0;
                          }
                          color = color_numbers_16[i___0];
                          if (color >= 0) {
                            {
                            tmp___19 = atoi((char const   *)((char *)term_strings[34]));
                            }
                            if (tmp___19 == 8) {
                              color = color_numbers_8[i___0];
                              if ((int )*(key + 5) == 70) {
                                if (color & 8) {
                                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm |= 2;
                                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold = 1;
                                } else {
                                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm &= -3;
                                }
                              }
                              color &= 7;
                            } else {
                              {
                              tmp___18 = atoi((char const   *)((char *)term_strings[34]));
                              }
                              if (tmp___18 == 16) {
                                if ((int )*(term_strings[39]) != 0) {
                                  p___0 = term_strings[39];
                                } else {
                                  p___0 = term_strings[35];
                                }
                                if ((int )*p___0 != 0) {
                                  {
                                  tmp___17 = strlen((char const   *)((char *)p___0));
                                  }
                                  if ((int )*((p___0 + tmp___17) - 1) == 109) {
                                    color = color_numbers_8[i___0];
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    if ((int )*(key + 5) == 70) {
                      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg = color + 1;
                      if (is_normal_group) {
                        {
                        cterm_normal_fg_color = color + 1;
                        cterm_normal_fg_bold = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm & 2;
                        must_redraw = 50;
                        term_fg_color(color);
                        }
                      }
                    } else {
                      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg = color + 1;
                      if (is_normal_group) {
                        {
                        cterm_normal_bg_color = color + 1;
                        must_redraw = 50;
                        term_bg_color(color);
                        tmp___25 = atoi((char const   *)((char *)term_strings[34]));
                        }
                        if (tmp___25 < 16) {
                          if (color == 0) {
                            tmp___23 = 1;
                          } else { //Added block
                          if (color == 4) {
                            tmp___23 = 1;
                          } else {
                            tmp___23 = 0;
                          }
                          }
                          i___0 = (long )tmp___23;
                        } else {
                          if (color < 7) {
                            tmp___24 = 1;
                          } else { //Added block
                          if (color == 8) {
                            tmp___24 = 1;
                          } else {
                            tmp___24 = 0;
                          }
                          }
                          i___0 = (long )tmp___24;
                        }
                        if (i___0) {
                          tmp___26 = (char_u *)"dark";
                        } else {
                          tmp___26 = (char_u *)"light";
                        }
                        {
                        set_option_value((char_u *)"bg", 0L, tmp___26);
                        }
                      }
                    }
                  }
                  }
                } else {
                  {
                  tmp___36 = strcmp((char const   *)((char *)key), (char const   *)((char *)"GUIFG"));
                  }
                  if (! (tmp___36 == 0)) {
                    {
                    tmp___35 = strcmp((char const   *)((char *)key), (char const   *)((char *)"GUIBG"));
                    }
                    if (! (tmp___35 == 0)) {
                      {
                      tmp___33 = strcmp((char const   *)((char *)key), (char const   *)((char *)"START"));
                      }
                      if (tmp___33 == 0) {
                        goto _L___7;
                      } else {
                        {
                        tmp___34 = strcmp((char const   *)((char *)key), (char const   *)((char *)"STOP"));
                        }
                        if (tmp___34 == 0) {
                          _L___7: 
                          if (! init) {
                            ((struct hl_group *)highlight_ga.ga_data + idx)->sg_set |= 1;
                          }
                          {
                          tmp___31 = strncmp((char const   *)((char *)arg), (char const   *)((char *)"t_"),
                                             (size_t )2);
                          }
                          if (tmp___31 == 0) {
                            off___0 = 0;
                            buf___3[0] = (char_u )0;
                            {
                            while (1) {
                              while_continue___5: /* CIL Label */ ;
                              if (! ((int )*(arg + off___0) != 0)) {
                                goto while_break___5;
                              }
                              len___0 = 0;
                              {
                              while (1) {
                                while_continue___6: /* CIL Label */ ;
                                if (*(arg + (off___0 + len___0))) {
                                  if (! ((int )*(arg + (off___0 + len___0)) != 44)) {
                                    goto while_break___6;
                                  }
                                } else {
                                  goto while_break___6;
                                }
                                len___0 ++;
                              }
                              while_break___6: /* CIL Label */ ;
                              }
                              {
                              tname = vim_strnsave(arg + off___0, len___0);
                              }
                              if ((unsigned long )tname == (unsigned long )((void *)0)) {
                                error = 1;
                                goto while_break___5;
                              }
                              {
                              p___0 = get_term_code(tname);
                              vim_free((void *)tname);
                              }
                              if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
                                p___0 = (char_u *)"";
                              }
                              {
                              tmp___27 = strlen((char const   *)((char *)(buf___3)));
                              tmp___28 = strlen((char const   *)((char *)p___0));
                              }
                              if ((int )(tmp___27 + tmp___28) >= 99) {
                                {
                                emsg2((char_u *)"terminal code too long: %s", arg);
                                error = 1;
                                }
                                goto while_break___5;
                              }
                              {
                              strcat((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )((char *)p___0));
                              off___0 += len___0;
                              }
                              if ((int )*(arg + off___0) == 44) {
                                off___0 ++;
                              }
                            }
                            while_break___5: /* CIL Label */ ;
                            }
                          } else {
                            p___0 = arg;
                            off___0 = 0;
                            {
                            while (1) {
                              while_continue___7: /* CIL Label */ ;
                              if (off___0 < 100) {
                                if (! *p___0) {
                                  goto while_break___7;
                                }
                              } else {
                                goto while_break___7;
                              }
                              {
                              len___0 = trans_special(& p___0, buf___3 + off___0,
                                                      0);
                              }
                              if (len___0) {
                                off___0 += len___0;
                              } else {
                                tmp___29 = off___0;
                                off___0 ++;
                                tmp___30 = p___0;
                                p___0 ++;
                                buf___3[tmp___29] = *tmp___30;
                              }
                            }
                            while_break___7: /* CIL Label */ ;
                            }
                            buf___3[off___0] = (char_u )'\000';
                          }
                          if (error) {
                            goto while_break___0;
                          }
                          {
                          tmp___32 = strcmp((char const   *)((char *)(buf___3)), (char const   *)((char *)"NONE"));
                          }
                          if (tmp___32 == 0) {
                            p___0 = (char_u *)((void *)0);
                          } else {
                            {
                            p___0 = vim_strsave(buf___3);
                            }
                          }
                          if ((int )*(key + 2) == 65) {
                            {
                            vim_free((void *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_start);
                            ((struct hl_group *)highlight_ga.ga_data + idx)->sg_start = p___0;
                            }
                          } else {
                            {
                            vim_free((void *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop);
                            ((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop = p___0;
                            }
                          }
                        } else {
                          {
                          emsg2((char_u *)"Illegal argument: %s", key_start);
                          error = 1;
                          }
                          goto while_break___0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (! init) {
        ((struct hl_group *)highlight_ga.ga_data + idx)->sg_link = 0;
      } else { //Added block
      if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 8)) {
        ((struct hl_group *)highlight_ga.ga_data + idx)->sg_link = 0;
      }
      }
      {
      linep = skipwhite(linep);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  if (error) {
    if (idx == highlight_ga.ga_len) {
      {
      syn_unadd_group();
      }
    } else {
      goto _L___10;
    }
  } else {
    _L___10: 
    if (is_normal_group) {
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr = 0;
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = 0;
    } else {
      {
      set_hl_attr(idx);
      }
    }
    {
    redraw_all_later(40);
    }
  }
  {
  vim_free((void *)key);
  vim_free((void *)arg);
  need_highlight_changed = 1;
  }
  return;
}
}
static int hl_has_settings(int idx , int check_link ) 
{ 
  int tmp ;

  {
  if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr != 0) {
    tmp = 1;
  } else { //Added block
  if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr != 0) {
    tmp = 1;
  } else { //Added block
  if (check_link) {
    if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 8) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  }
  }
  return (tmp);
}
}
static void highlight_clear(int idx ) 
{ 


  {
  {
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term = 0;
  vim_free((void *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_start);
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_start = (char_u *)((void *)0);
  vim_free((void *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop);
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop = (char_u *)((void *)0);
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr = 0;
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm = 0;
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold = 0;
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg = 0;
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg = 0;
  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = 0;
  }
  return;
}
}
struct growarray term_attr_table  =    {0, 0, 0, 0, (void *)0};
struct growarray cterm_attr_table  =    {0, 0, 0, 0, (void *)0};
static int recursive___3  =    0;
static int get_attr_entry(struct growarray *table , struct attr_entry *aep ) 
{ 
  int i___0 ;
  struct attr_entry *gap ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  table->ga_itemsize = (int )sizeof(struct attr_entry );
  table->ga_growsize = 7;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < table->ga_len)) {
      goto while_break;
    }
    gap = (struct attr_entry *)table->ga_data + i___0;
    if ((int )aep->ae_attr == (int )gap->ae_attr) {
      if ((unsigned long )table == (unsigned long )(& term_attr_table)) {
        if (((unsigned long )aep->ae_u.term.start == (unsigned long )((void *)0)) == ((unsigned long )gap->ae_u.term.start == (unsigned long )((void *)0))) {
          if ((unsigned long )aep->ae_u.term.start == (unsigned long )((void *)0)) {
            goto _L___2;
          } else {
            {
            tmp = strcmp((char const   *)((char *)aep->ae_u.term.start), (char const   *)((char *)gap->ae_u.term.start));
            }
            if (tmp == 0) {
              _L___2: 
              if (((unsigned long )aep->ae_u.term.stop == (unsigned long )((void *)0)) == ((unsigned long )gap->ae_u.term.stop == (unsigned long )((void *)0))) {
                if ((unsigned long )aep->ae_u.term.stop == (unsigned long )((void *)0)) {
                  return (i___0 + 32);
                } else {
                  {
                  tmp___0 = strcmp((char const   *)((char *)aep->ae_u.term.stop),
                                   (char const   *)((char *)gap->ae_u.term.stop));
                  }
                  if (tmp___0 == 0) {
                    return (i___0 + 32);
                  } else {
                    goto _L___3;
                  }
                }
              } else {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          }
        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: 
      if ((unsigned long )table == (unsigned long )(& cterm_attr_table)) {
        if ((int )aep->ae_u.cterm.fg_color == (int )gap->ae_u.cterm.fg_color) {
          if ((int )aep->ae_u.cterm.bg_color == (int )gap->ae_u.cterm.bg_color) {
            return (i___0 + 32);
          }
        }
      }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (table->ga_len + 32 == 256) {
    if (recursive___3) {
      {
      emsg((char_u *)"Too many different highlighting attributes in use");
      }
      return (0);
    }
    {
    recursive___3 = 1;
    ga_clear(& term_attr_table);
    ga_clear(& cterm_attr_table);
    must_redraw = 50;
    i___0 = 0;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < highlight_ga.ga_len)) {
        goto while_break___0;
      }
      {
      set_hl_attr(i___0);
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    recursive___3 = 0;
  }
  {
  tmp___1 = ga_grow(table, 1);
  }
  if (tmp___1 == 0) {
    return (0);
  }
  {
  gap = (struct attr_entry *)table->ga_data + table->ga_len;
  memset((void *)gap, 0, sizeof(struct attr_entry ));
  gap->ae_attr = aep->ae_attr;
  }
  if ((unsigned long )table == (unsigned long )(& term_attr_table)) {
    if ((unsigned long )aep->ae_u.term.start == (unsigned long )((void *)0)) {
      gap->ae_u.term.start = (char_u *)((void *)0);
    } else {
      {
      gap->ae_u.term.start = vim_strsave(aep->ae_u.term.start);
      }
    }
    if ((unsigned long )aep->ae_u.term.stop == (unsigned long )((void *)0)) {
      gap->ae_u.term.stop = (char_u *)((void *)0);
    } else {
      {
      gap->ae_u.term.stop = vim_strsave(aep->ae_u.term.stop);
      }
    }
  } else { //Added block
  if ((unsigned long )table == (unsigned long )(& cterm_attr_table)) {
    gap->ae_u.cterm.fg_color = aep->ae_u.cterm.fg_color;
    gap->ae_u.cterm.bg_color = aep->ae_u.cterm.bg_color;
  }
  }
  (table->ga_len) ++;
  (table->ga_room) --;
  return ((table->ga_len - 1) + 32);
}
}
struct attr_entry *syn_term_attr2entry(int attr ) 
{ 


  {
  attr -= 32;
  if (attr >= term_attr_table.ga_len) {
    return ((struct attr_entry *)((void *)0));
  }
  return ((struct attr_entry *)term_attr_table.ga_data + attr);
}
}
struct attr_entry *syn_cterm_attr2entry(int attr ) 
{ 


  {
  attr -= 32;
  if (attr >= cterm_attr_table.ga_len) {
    return ((struct attr_entry *)((void *)0));
  }
  return ((struct attr_entry *)cterm_attr_table.ga_data + attr);
}
}
static void highlight_list_one(int id ) 
{ 
  struct hl_group *sgp ;
  int didh ;

  {
  {
  didh = 0;
  sgp = (struct hl_group *)highlight_ga.ga_data + (id - 1);
  didh = highlight_list_arg(id, didh, 1, sgp->sg_term, (char_u *)((void *)0), (char *)"term");
  didh = highlight_list_arg(id, didh, 2, 0, sgp->sg_start, (char *)"start");
  didh = highlight_list_arg(id, didh, 2, 0, sgp->sg_stop, (char *)"stop");
  didh = highlight_list_arg(id, didh, 1, sgp->sg_cterm, (char_u *)((void *)0), (char *)"cterm");
  didh = highlight_list_arg(id, didh, 3, sgp->sg_cterm_fg, (char_u *)((void *)0),
                            (char *)"ctermfg");
  didh = highlight_list_arg(id, didh, 3, sgp->sg_cterm_bg, (char_u *)((void *)0),
                            (char *)"ctermbg");
  }
  if (sgp->sg_link) {
    {
    syn_list_header(didh, 9999, id);
    msg_puts_attr((char_u *)"links to", highlight_attr[2]);
    msg_putchar(' ');
    msg_outtrans(((struct hl_group *)highlight_ga.ga_data + (((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_link - 1))->sg_name);
    }
  }
  return;
}
}
static int highlight_list_arg(int id , int didh , int type , int iarg , char_u *sarg ,
                              char *name___1 ) 
{ 
  char_u buf___3[100] ;
  char_u *ts ;
  int i___0 ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (type == 2) {
    tmp___1 = (unsigned long )sarg != (unsigned long )((void *)0);
  } else {
    tmp___1 = iarg != 0;
  }
  if (tmp___1) {
    ts = buf___3;
    if (type == 3) {
      {
      sprintf((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )"%d",
              iarg - 1);
      }
    } else { //Added block
    if (type == 2) {
      ts = sarg;
    } else {
      buf___3[0] = (char_u )'\000';
      i___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (hl_attr_table[i___0] != 0)) {
          goto while_break;
        }
        if (iarg & hl_attr_table[i___0]) {
          if ((int )buf___3[0] != 0) {
            {
            strcat((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )((char *)","));
            }
          }
          {
          strcat((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )hl_name_table[i___0]);
          iarg &= ~ hl_attr_table[i___0];
          }
        }
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    }
    {
    tmp = vim_strsize(ts);
    tmp___0 = strlen((char const   *)name___1);
    syn_list_header(didh, (int )(((size_t )tmp + tmp___0) + 1UL), id);
    didh = 1;
    msg_puts_attr((char_u *)name___1, highlight_attr[2]);
    msg_puts_attr((char_u *)"=", highlight_attr[2]);
    msg_outtrans(ts);
    }
  }
  return (didh);
}
}
char_u *highlight_has_attr(int id , int flag , int modec ) 
{ 
  int attr ;

  {
  if (id <= 0) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if (id > highlight_ga.ga_len) {
    return ((char_u *)((void *)0));
  }
  }
  if (modec == 99) {
    attr = ((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_cterm;
  } else {
    attr = ((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_term;
  }
  if (attr & flag) {
    return ((char_u *)"1");
  }
  return ((char_u *)((void *)0));
}
}
static char_u name___0[20]  ;
char_u *highlight_color(int id , char_u *what , int modec ) 
{ 
  int n ;
  int fg ;
  int tmp ;

  {
  if (id <= 0) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if (id > highlight_ga.ga_len) {
    return ((char_u *)((void *)0));
  }
  }
  {
  tmp = tolower((int )*(what + 0));
  }
  if (tmp == 102) {
    fg = 1;
  } else {
    fg = 0;
  }
  if (modec == 99) {
    if (fg) {
      n = ((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_cterm_fg - 1;
    } else {
      n = ((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_cterm_bg - 1;
    }
    {
    sprintf((char * __restrict  )((char *)(name___0)), (char const   * __restrict  )"%d",
            n);
    }
    return (name___0);
  }
  return ((char_u *)((void *)0));
}
}
static int syn_list_header(int did_header , int outlen , int id ) 
{ 
  int endcol ;
  int newline ;

  {
  endcol = 15;
  newline = 1;
  if (! did_header) {
    {
    msg_putchar('\n');
    msg_outtrans(((struct hl_group *)highlight_ga.ga_data + (id - 1))->sg_name);
    }
  } else { //Added block
  if ((long )((msg_col + outlen) + 1) >= Columns) {
    {
    msg_putchar('\n');
    }
  } else {
    if (msg_col >= endcol) {
      newline = 0;
    }
    {
    msg_putchar(' ');
    }
  }
  }
  if (msg_col >= endcol) {
    endcol = msg_col + 1;
  }
  if (Columns <= (long )endcol) {
    endcol = (int )(Columns - 1L);
  }
  {
  msg_advance(endcol);
  }
  return (newline);
}
}
static void set_hl_attr(int idx ) 
{ 
  struct attr_entry at_en ;
  int tmp ;

  {
  {
  tmp = strcmp((char const   *)((char *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_name_u),
               (char const   *)((char *)"NORMAL"));
  }
  if (tmp == 0) {
    return;
  }
  if ((unsigned long )((struct hl_group *)highlight_ga.ga_data + idx)->sg_start == (unsigned long )((void *)0)) {
    if ((unsigned long )((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop == (unsigned long )((void *)0)) {
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term;
    } else {
      {
      at_en.ae_attr = (short )((struct hl_group *)highlight_ga.ga_data + idx)->sg_term;
      at_en.ae_u.term.start = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_start;
      at_en.ae_u.term.stop = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop;
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr = get_attr_entry(& term_attr_table,
                                                                                     & at_en);
      }
    }
  } else {
    {
    at_en.ae_attr = (short )((struct hl_group *)highlight_ga.ga_data + idx)->sg_term;
    at_en.ae_u.term.start = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_start;
    at_en.ae_u.term.stop = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop;
    ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr = get_attr_entry(& term_attr_table,
                                                                                   & at_en);
    }
  }
  if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg == 0) {
    if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg == 0) {
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm;
    } else {
      {
      at_en.ae_attr = (short )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm;
      at_en.ae_u.cterm.fg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg;
      at_en.ae_u.cterm.bg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg;
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = get_attr_entry(& cterm_attr_table,
                                                                                      & at_en);
      }
    }
  } else {
    {
    at_en.ae_attr = (short )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm;
    at_en.ae_u.cterm.fg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg;
    at_en.ae_u.cterm.bg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg;
    ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = get_attr_entry(& cterm_attr_table,
                                                                                    & at_en);
    }
  }
  return;
}
}
int syn_name2id(char_u *name___1 ) 
{ 
  int i___0 ;
  char_u *name_u ;
  int tmp ;

  {
  {
  name_u = vim_strsave_up(name___1);
  }
  if ((unsigned long )name_u == (unsigned long )((void *)0)) {
    return (0);
  }
  i___0 = highlight_ga.ga_len;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    if ((unsigned long )((struct hl_group *)highlight_ga.ga_data + i___0)->sg_name_u != (unsigned long )((void *)0)) {
      {
      tmp = strcmp((char const   *)((char *)name_u), (char const   *)((char *)((struct hl_group *)highlight_ga.ga_data + i___0)->sg_name_u));
      }
      if (tmp == 0) {
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)name_u);
  }
  return (i___0 + 1);
}
}
int highlight_exists(char_u *name___1 ) 
{ 
  int tmp ;

  {
  {
  tmp = syn_name2id(name___1);
  }
  return (tmp > 0);
}
}
static int syn_namen2id(char_u *linep , int len___0 ) 
{ 
  char_u *name___1 ;
  int id ;

  {
  {
  id = 0;
  name___1 = vim_strnsave(linep, len___0);
  }
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    {
    id = syn_name2id(name___1);
    vim_free((void *)name___1);
    }
  }
  return (id);
}
}
int syn_check_group(char_u *pp , int len___0 ) 
{ 
  int id ;
  char_u *name___1 ;

  {
  {
  name___1 = vim_strnsave(pp, len___0);
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  id = syn_name2id(name___1);
  }
  if (id == 0) {
    {
    id = syn_add_group(name___1);
    }
  } else {
    {
    vim_free((void *)name___1);
    }
  }
  return (id);
}
}
static int syn_add_group(char_u *name___1 ) 
{ 
  int tmp ;

  {
  if ((unsigned long )highlight_ga.ga_data == (unsigned long )((void *)0)) {
    highlight_ga.ga_itemsize = (int )sizeof(struct hl_group );
    highlight_ga.ga_growsize = 10;
  }
  {
  tmp = ga_grow(& highlight_ga, 1);
  }
  if (tmp == 0) {
    {
    vim_free((void *)name___1);
    }
    return (0);
  }
  {
  memset((void *)((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len),
         0, sizeof(struct hl_group ));
  ((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len)->sg_name = name___1;
  ((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len)->sg_name_u = vim_strsave_up(name___1);
  (highlight_ga.ga_len) ++;
  (highlight_ga.ga_room) --;
  }
  return (highlight_ga.ga_len);
}
}
static void syn_unadd_group(void) 
{ 


  {
  {
  (highlight_ga.ga_len) --;
  (highlight_ga.ga_room) ++;
  vim_free((void *)((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len)->sg_name);
  vim_free((void *)((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len)->sg_name_u);
  }
  return;
}
}
int syn_id2attr(int hl_id ) 
{ 
  int attr ;
  struct hl_group *sgp ;

  {
  {
  hl_id = syn_get_final_id(hl_id);
  sgp = (struct hl_group *)highlight_ga.ga_data + (hl_id - 1);
  }
  if (*(term_strings[34])) {
    attr = sgp->sg_cterm_attr;
  } else {
    attr = sgp->sg_term_attr;
  }
  return (attr);
}
}
int syn_get_final_id(int hl_id ) 
{ 
  int count___2 ;
  struct hl_group *sgp ;

  {
  if (hl_id > highlight_ga.ga_len) {
    return (0);
  } else { //Added block
  if (hl_id < 1) {
    return (0);
  }
  }
  count___2 = 100;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0)) {
      goto while_break;
    }
    sgp = (struct hl_group *)highlight_ga.ga_data + (hl_id - 1);
    if (sgp->sg_link == 0) {
      goto while_break;
    } else { //Added block
    if (sgp->sg_link > highlight_ga.ga_len) {
      goto while_break;
    }
    }
    hl_id = sgp->sg_link;
  }
  while_break: /* CIL Label */ ;
  }
  return (hl_id);
}
}
static int hl_flags[18]  = 
  {      '8',      '@',      'd',      'e', 
        'h',      'i',      'l',      'm', 
        'M',      'n',      'r',      's', 
        'S',      't',      'v',      'V', 
        'w',      'W'};
int highlight_changed(void) 
{ 
  int hlf ;
  int i___0 ;
  char_u *p___0 ;
  int attr ;
  char_u *end ;
  int id ;
  char_u userhl[10] ;
  int id_SNC ;
  int id_S ;
  int hlcnt ;
  size_t tmp ;
  int tmp___0 ;
  struct hl_group *hlt ;

  {
  id_SNC = -1;
  id_S = -1;
  need_highlight_changed = 0;
  hlf = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (hlf < 18)) {
      goto while_break;
    }
    highlight_attr[hlf] = 0;
    hlf ++;
  }
  while_break: /* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break___0;
    }
    if (i___0) {
      p___0 = p_hl;
    } else {
      {
      p___0 = get_highlight_default();
      }
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! *p___0) {
        goto while_break___1;
      }
      hlf = 0;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (hlf < 18)) {
          goto while_break___2;
        }
        if (hl_flags[hlf] == (int )*p___0) {
          goto while_break___2;
        }
        hlf ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      p___0 ++;
      if (hlf == 18) {
        return (0);
      } else { //Added block
      if ((int )*p___0 == 0) {
        return (0);
      }
      }
      attr = 0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (*p___0) {
          if (! ((int )*p___0 != 44)) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
        if ((int )*p___0 == 32) {
          goto __Cont___0;
        } else { //Added block
        if ((int )*p___0 == 9) {
          goto __Cont___0;
        }
        }
        if (attr > 31) {
          return (0);
        }
        {
        if ((int )*p___0 == 98) {
          goto case_98;
        }
        if ((int )*p___0 == 105) {
          goto case_105;
        }
        if ((int )*p___0 == 45) {
          goto case_45;
        }
        if ((int )*p___0 == 110) {
          goto case_45;
        }
        if ((int )*p___0 == 114) {
          goto case_114;
        }
        if ((int )*p___0 == 115) {
          goto case_115;
        }
        if ((int )*p___0 == 117) {
          goto case_117;
        }
        if ((int )*p___0 == 58) {
          goto case_58;
        }
        goto switch_default;
        case_98: /* CIL Label */ 
        attr |= 2;
        goto switch_break;
        case_105: /* CIL Label */ 
        attr |= 4;
        goto switch_break;
        case_45: /* CIL Label */ 
        case_110: /* CIL Label */ 
        goto switch_break;
        case_114: /* CIL Label */ 
        attr |= 1;
        goto switch_break;
        case_115: /* CIL Label */ 
        attr |= 16;
        goto switch_break;
        case_117: /* CIL Label */ 
        attr |= 8;
        goto switch_break;
        case_58: /* CIL Label */ 
        p___0 ++;
        if (attr) {
          return (0);
        } else { //Added block
        if ((int )*p___0 == 0) {
          return (0);
        }
        }
        {
        end = vim_strchr(p___0, ',');
        }
        if ((unsigned long )end == (unsigned long )((void *)0)) {
          {
          tmp = strlen((char const   *)((char *)p___0));
          end = p___0 + tmp;
          }
        }
        {
        id = syn_check_group(p___0, (int )(end - p___0));
        }
        if (id == 0) {
          return (0);
        }
        {
        attr = syn_id2attr(id);
        p___0 = end - 1;
        }
        if (hlf == 12) {
          {
          id_SNC = syn_get_final_id(id);
          }
        } else { //Added block
        if (hlf == 11) {
          {
          id_S = syn_get_final_id(id);
          }
        }
        }
        goto switch_break;
        switch_default: /* CIL Label */ 
        return (0);
        switch_break: /* CIL Label */ ;
        }
        __Cont___0: 
        p___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      highlight_attr[hlf] = attr;
      p___0 = skip_to_option_part(p___0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: 
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp___0 = ga_grow(& highlight_ga, 10);
  }
  if (tmp___0 == 0) {
    return (0);
  }
  hlcnt = highlight_ga.ga_len;
  if (id_S == 0) {
    {
    memset((void *)((struct hl_group *)highlight_ga.ga_data + (hlcnt + 9)), 0, sizeof(struct hl_group ));
    ((struct hl_group *)highlight_ga.ga_data + (hlcnt + 9))->sg_term = highlight_attr[11];
    id_S = hlcnt + 10;
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___4: /* CIL Label */ ;
    if (! (i___0 < 9)) {
      goto while_break___4;
    }
    {
    sprintf((char * __restrict  )((char *)(userhl)), (char const   * __restrict  )"User%d",
            i___0 + 1);
    id = syn_name2id(userhl);
    }
    if (id == 0) {
      highlight_user[i___0] = 0;
      highlight_stlnc[i___0] = 0;
    } else {
      {
      hlt = (struct hl_group *)highlight_ga.ga_data;
      highlight_user[i___0] = syn_id2attr(id);
      }
      if (id_SNC == 0) {
        {
        memset((void *)(hlt + (hlcnt + i___0)), 0, sizeof(struct hl_group ));
        (hlt + (hlcnt + i___0))->sg_term = highlight_attr[12];
        (hlt + (hlcnt + i___0))->sg_cterm = highlight_attr[12];
        }
      } else {
        {
        memmove((void *)((char *)(hlt + (hlcnt + i___0))), (void const   *)((char *)(hlt + (id_SNC - 1))),
                sizeof(struct hl_group ));
        }
      }
      (hlt + (hlcnt + i___0))->sg_link = 0;
      (hlt + (hlcnt + i___0))->sg_term ^= (hlt + (id - 1))->sg_term ^ (hlt + (id_S - 1))->sg_term;
      if ((unsigned long )(hlt + (id - 1))->sg_start != (unsigned long )(hlt + (id_S - 1))->sg_start) {
        (hlt + (hlcnt + i___0))->sg_start = (hlt + (id - 1))->sg_start;
      }
      if ((unsigned long )(hlt + (id - 1))->sg_stop != (unsigned long )(hlt + (id_S - 1))->sg_stop) {
        (hlt + (hlcnt + i___0))->sg_stop = (hlt + (id - 1))->sg_stop;
      }
      (hlt + (hlcnt + i___0))->sg_cterm ^= (hlt + (id - 1))->sg_cterm ^ (hlt + (id_S - 1))->sg_cterm;
      if ((hlt + (id - 1))->sg_cterm_fg != (hlt + (id_S - 1))->sg_cterm_fg) {
        (hlt + (hlcnt + i___0))->sg_cterm_fg = (hlt + (id - 1))->sg_cterm_fg;
      }
      if ((hlt + (id - 1))->sg_cterm_bg != (hlt + (id_S - 1))->sg_cterm_bg) {
        (hlt + (hlcnt + i___0))->sg_cterm_bg = (hlt + (id - 1))->sg_cterm_bg;
      }
      {
      highlight_ga.ga_len = (hlcnt + i___0) + 1;
      set_hl_attr(hlcnt + i___0);
      highlight_stlnc[i___0] = syn_id2attr((hlcnt + i___0) + 1);
      }
    }
    i___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  highlight_ga.ga_len = hlcnt;
  return (1);
}
}
static void highlight_list(void) ;
static void highlight_list_two(int cnt , int attr ) ;
void set_context_in_highlight_cmd(char_u *arg ) 
{ 
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;

  {
  expand_context = 13;
  expand_pattern = arg;
  include_link = 1;
  if ((int )*arg != 0) {
    {
    p___0 = skiptowhite(arg);
    }
    if ((int )*p___0 != 0) {
      include_link = 0;
      if ((int )*(arg + 1) == 105) {
        if ((int )*(arg + 0) == 78) {
          {
          highlight_list();
          }
        }
      }
      {
      tmp = strncmp((char const   *)((char *)"link"), (char const   *)((char *)arg),
                    (size_t )(p___0 - arg));
      }
      if (tmp == 0) {
        goto _L;
      } else {
        {
        tmp___0 = strncmp((char const   *)((char *)"clear"), (char const   *)((char *)arg),
                          (size_t )(p___0 - arg));
        }
        if (tmp___0 == 0) {
          _L: 
          {
          expand_pattern = skipwhite(p___0);
          p___0 = skiptowhite(expand_pattern);
          }
          if ((int )*p___0 != 0) {
            {
            expand_pattern = skipwhite(p___0);
            p___0 = skiptowhite(expand_pattern);
            }
          }
        }
      }
      if ((int )*p___0 != 0) {
        expand_context = 0;
      }
    }
  }
  return;
}
}
static void highlight_list(void) 
{ 
  int i___0 ;

  {
  i___0 = 10;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    {
    highlight_list_two(i___0, highlight_attr[2]);
    }
  }
  while_break: /* CIL Label */ ;
  }
  i___0 = 40;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break___0;
    }
    {
    highlight_list_two(55, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
static void highlight_list_two(int cnt , int attr ) 
{ 
  long tmp ;

  {
  {
  msg_puts_attr((char_u *)("NI!  \b" + cnt / 11), attr);
  msg_clr_eos();
  out_flush();
  }
  if (cnt == 55) {
    tmp = 40L;
  } else {
    tmp = (long )cnt * 50L;
  }
  {
  ui_delay(tmp, 0);
  }
  return;
}
}
char_u *get_highlight_name(int idx ) 
{ 


  {
  if (idx == highlight_ga.ga_len) {
    if (include_link) {
      return ((char_u *)"link");
    }
  }
  if (idx == highlight_ga.ga_len + 1) {
    if (include_link) {
      return ((char_u *)"clear");
    }
  }
  if (idx < 0) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if (idx >= highlight_ga.ga_len) {
    return ((char_u *)((void *)0));
  }
  }
  return (((struct hl_group *)highlight_ga.ga_data + idx)->sg_name);
}
}
#pragma merger("0","/tmp/cil-FIDR198i.i","-O0")
extern void rewind(FILE *__stream ) ;
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
extern __off_t ftello(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
void simplify_filename(char_u *filename ) ;
static char *mt_names[8]  = 
  {      (char *)"FSC",      (char *)"F C",      (char *)"F  ",      (char *)"FS ", 
        (char *)" SC",      (char *)"  C",      (char *)"   ",      (char *)" S "};
static char_u *nofile_fname  =    (char_u *)((void *)0);
static void taglen_advance(int l ) ;
static int get_tagfname(int first___0 , char_u *buf___3 ) ;
static int jumpto_tag(char_u *lbuf , int forceit ) ;
static int parse_tag_line(char_u *lbuf , struct tag_pointers *tagp ) ;
static int test_for_static(struct tag_pointers *tagp ) ;
static int parse_match(char_u *lbuf , struct tag_pointers *tagp ) ;
static char_u *tag_full_fname(struct tag_pointers *tagp ) ;
static char_u *expand_tag_fname(char_u *fname , char_u *tag_fname , int expand ) ;
static int test_for_current(char_u *fname , char_u *fname_end , char_u *tag_fname ) ;
static int find_extra(char_u **pp ) ;
static char_u *bottommsg  =    (char_u *)"at bottom of tag stack";
static char_u *topmsg  =    (char_u *)"at top of tag stack";
static char_u *tagmatchname  =    (char_u *)((void *)0);
static int num_matches  =    0;
static int max_num_matches  =    0;
static char_u **matches  =    (char_u **)((void *)0);
static int flags  ;
int do_tag(char_u *tag , int type , int count___2 , int forceit , int verbose ) 
{ 
  struct taggy *tagstack ;
  int tagstackidx ;
  int tagstacklen ;
  int cur_match ;
  int oldtagstackidx ;
  int prev_num_matches ;
  int new_tag ;
  int other_name ;
  int i___0 ;
  int j ;
  int k ;
  int idx ;
  int ic ;
  char_u *p___0 ;
  char_u *name___1 ;
  int no_regexp ;
  int error_cur_match ;
  char_u *command_end ;
  int save_pos ;
  struct filemark saved_fmark ;
  int taglen ;
  struct tag_pointers tagp ;
  struct tag_pointers tagp2 ;
  int new_num_matches ;
  char_u **new_matches ;
  int attr ;
  int use_tagstack ;
  int skip_msg ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int ask_for_selection ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;

  {
  tagstack = curwin->w_tagstack;
  tagstackidx = curwin->w_tagstackidx;
  tagstacklen = curwin->w_tagstacklen;
  cur_match = 0;
  oldtagstackidx = tagstackidx;
  new_tag = 0;
  no_regexp = 0;
  error_cur_match = 0;
  save_pos = 0;
  skip_msg = 0;
  if (type == 8) {
    type = 1;
    no_regexp = 1;
  }
  prev_num_matches = num_matches;
  nofile_fname = (char_u *)((void *)0);
  if (! p_tgst) {
    if (*tag) {
      use_tagstack = 0;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    use_tagstack = 1;
    if (*tag) {
      if (type == 1) {
        goto _L___0;
      } else { //Added block
      if (type == 7) {
        goto _L___0;
      } else { //Added block
      if (type == 9) {
        _L___0: 
        {
        while (1) {
          while_continue: /* CIL Label */ ;
          if (! (tagstackidx < tagstacklen)) {
            goto while_break;
          }
          {
          tagstacklen --;
          vim_free((void *)(tagstack + tagstacklen)->tagname);
          }
        }
        while_break: /* CIL Label */ ;
        }
        tagstacklen ++;
        if (tagstacklen > 20) {
          {
          tagstacklen = 20;
          vim_free((void *)(tagstack + 0)->tagname);
          i___0 = 1;
          }
          {
          while (1) {
            while_continue___0: /* CIL Label */ ;
            if (! (i___0 < tagstacklen)) {
              goto while_break___0;
            }
            *(tagstack + (i___0 - 1)) = *(tagstack + i___0);
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          tagstackidx --;
        }
        {
        tmp = vim_strsave(tag);
        (tagstack + tagstackidx)->tagname = tmp;
        }
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
          curwin->w_tagstacklen = tagstacklen - 1;
          goto end_do_tag;
        }
        curwin->w_tagstacklen = tagstacklen;
        new_tag = 1;
        save_pos = 1;
      } else {
        goto _L;
      }
      }
      }
    } else {
      _L: 
      if (tagstacklen == 0) {
        {
        emsg(e_tagstack);
        }
        goto end_do_tag;
      }
      if (type == 2) {
        tagstackidx -= count___2;
        if (tagstackidx < 0) {
          {
          emsg(bottommsg);
          }
          if (tagstackidx + count___2 == 0) {
            tagstackidx = 0;
            goto end_do_tag;
          }
          tagstackidx = 0;
        } else { //Added block
        if (tagstackidx >= tagstacklen) {
          {
          emsg(topmsg);
          }
          goto end_do_tag;
        }
        }
        saved_fmark = (tagstack + tagstackidx)->fmark;
        if (saved_fmark.fnum != curbuf->b_fnum) {
          {
          tmp___0 = buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum, 1, forceit);
          }
          if (tmp___0 == 0) {
            tagstackidx = oldtagstackidx;
            goto end_do_tag;
          }
        } else {
          curwin->w_cursor.lnum = saved_fmark.mark.lnum;
        }
        {
        curwin->w_cursor.col = saved_fmark.mark.col;
        curwin->w_set_curswant = 1;
        adjust_cursor();
        FreeWild(num_matches, matches);
        num_matches = 0;
        }
        goto end_do_tag;
      }
      if (type == 1) {
        save_pos = 1;
        tagstackidx += count___2 - 1;
        if (tagstackidx >= tagstacklen) {
          {
          tagstackidx = tagstacklen - 1;
          emsg(topmsg);
          save_pos = 0;
          }
        } else { //Added block
        if (tagstackidx < 0) {
          {
          emsg(bottommsg);
          tagstackidx = 0;
          }
          goto end_do_tag;
        }
        }
        cur_match = (tagstack + tagstackidx)->cur_match;
        new_tag = 1;
      } else {
        tagstackidx --;
        if (tagstackidx < 0) {
          tagstackidx = 0;
        }
        cur_match = (tagstack + tagstackidx)->cur_match;
        {
        if (type == 5) {
          goto case_5;
        }
        if (type == 7) {
          goto case_7;
        }
        if (type == 9) {
          goto case_7;
        }
        if (type == 6) {
          goto case_7;
        }
        if (type == 3) {
          goto case_3;
        }
        if (type == 4) {
          goto case_4;
        }
        goto switch_break;
        case_5: /* CIL Label */ 
        cur_match = count___2 - 1;
        goto switch_break;
        case_7: /* CIL Label */ 
        case_9: /* CIL Label */ 
        case_6: /* CIL Label */ 
        cur_match = 2147483646;
        goto switch_break;
        case_3: /* CIL Label */ 
        cur_match += count___2;
        goto switch_break;
        case_4: /* CIL Label */ 
        cur_match -= count___2;
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        if (cur_match >= 2147483647) {
          cur_match = 2147483646;
        } else { //Added block
        if (cur_match < 0) {
          {
          emsg((char_u *)"Cannot go before first matching tag");
          skip_msg = 1;
          cur_match = 0;
          }
        }
        }
      }
    }
    saved_fmark = (tagstack + tagstackidx)->fmark;
    if (save_pos) {
      (tagstack + tagstackidx)->fmark.mark = curwin->w_cursor;
      (tagstack + tagstackidx)->fmark.fnum = curbuf->b_fnum;
    }
    curwin->w_tagstackidx = tagstackidx;
    if (type != 7) {
      if (type != 9) {
        curwin->w_tagstack[tagstackidx].cur_match = cur_match;
      }
    }
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! use_tagstack) {
      name___1 = tag;
    } else {
      name___1 = (tagstack + tagstackidx)->tagname;
    }
    if ((unsigned long )tagmatchname == (unsigned long )((void *)0)) {
      tmp___2 = 1;
    } else {
      {
      tmp___1 = strcmp((char const   *)((char *)tagmatchname), (char const   *)((char *)name___1));
      }
      if (tmp___1 != 0) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    }
    other_name = tmp___2;
    if (new_tag) {
      goto _L___2;
    } else { //Added block
    if (cur_match >= num_matches) {
      if (max_num_matches != 2147483647) {
        goto _L___2;
      } else {
        goto _L___3;
      }
    } else { //Added block
    _L___3: 
    if (other_name) {
      _L___2: 
      if (other_name) {
        {
        vim_free((void *)tagmatchname);
        tagmatchname = vim_strsave(name___1);
        }
      }
      if (type == 7) {
        cur_match = 2147483646;
      } else { //Added block
      if (type == 9) {
        cur_match = 2147483646;
      }
      }
      max_num_matches = cur_match + 1;
      if (! no_regexp) {
        if ((int )*name___1 == 47) {
          flags = 4;
          name___1 ++;
        } else {
          flags = 8;
        }
      } else {
        flags = 8;
      }
      if (verbose) {
        flags |= 32;
      }
      {
      tmp___3 = find_tags(name___1, & new_num_matches, & new_matches, flags, max_num_matches);
      }
      if (tmp___3 == 1) {
        if (new_num_matches < max_num_matches) {
          max_num_matches = 2147483647;
        }
      }
      if (! new_tag) {
        if (! other_name) {
          idx = 0;
          j = 0;
          {
          while (1) {
            while_continue___2: /* CIL Label */ ;
            if (! (j < num_matches)) {
              goto while_break___2;
            }
            {
            parse_match(*(matches + j), & tagp);
            i___0 = idx;
            }
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              if (! (i___0 < new_num_matches)) {
                goto while_break___3;
              }
              {
              parse_match(*(new_matches + i___0), & tagp2);
              tmp___5 = strcmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)tagp2.tagname));
              }
              if (tmp___5 == 0) {
                p___0 = *(new_matches + i___0);
                k = i___0;
                {
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  if (! (k > idx)) {
                    goto while_break___4;
                  }
                  *(new_matches + k) = *(new_matches + (k - 1));
                  k --;
                }
                while_break___4: /* CIL Label */ ;
                }
                tmp___4 = idx;
                idx ++;
                *(new_matches + tmp___4) = p___0;
                goto while_break___3;
              }
              i___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
      {
      FreeWild(num_matches, matches);
      num_matches = new_num_matches;
      matches = new_matches;
      }
    }
    }
    }
    if (num_matches <= 0) {
      if (verbose) {
        {
        emsg((char_u *)"tag not found");
        }
      }
      g_do_tagpreview = 0;
    } else {
      ask_for_selection = 0;
      if (type == 7) {
        goto _L___5;
      } else { //Added block
      if (type == 9) {
        if (num_matches > 1) {
          _L___5: 
          {
          parse_match(*(matches + 0), & tagp);
          taglen = (int )((tagp.tagname_end - tagp.tagname) + 2L);
          }
          if (taglen < 18) {
            taglen = 18;
          }
          if ((long )taglen > Columns - 25L) {
            taglen = 2147483647;
          }
          {
          msg_puts_attr((char_u *)"  # pri kind tag", highlight_attr[13]);
          msg_clr_eos();
          taglen_advance(taglen);
          msg_puts_attr((char_u *)"file\n", highlight_attr[13]);
          i___0 = 0;
          }
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            if (! (i___0 < num_matches)) {
              goto while_break___5;
            }
            {
            parse_match(*(matches + i___0), & tagp);
            }
            if (! new_tag) {
              if (use_tagstack) {
                if (i___0 == (tagstack + tagstackidx)->cur_match) {
                  *IObuff = (char_u )'>';
                } else {
                  *IObuff = (char_u )' ';
                }
              } else {
                *IObuff = (char_u )' ';
              }
            } else {
              *IObuff = (char_u )' ';
            }
            {
            sprintf((char * __restrict  )((char *)IObuff + 1), (char const   * __restrict  )"%2d %s ",
                    i___0 + 1, mt_names[(int )*(*(matches + i___0) + 0) & 7]);
            msg_puts(IObuff);
            }
            if ((unsigned long )tagp.tagkind != (unsigned long )((void *)0)) {
              {
              msg_outtrans_len(tagp.tagkind, (int )(tagp.tagkind_end - tagp.tagkind));
              }
            }
            {
            msg_advance(13);
            msg_outtrans_len_attr(tagp.tagname, (int )(tagp.tagname_end - tagp.tagname),
                                  highlight_attr[13]);
            msg_putchar(' ');
            taglen_advance(taglen);
            p___0 = tag_full_fname(& tagp);
            }
            if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
              {
              msg_puts_long_attr(p___0, highlight_attr[2]);
              vim_free((void *)p___0);
              }
            }
            if (msg_col > 0) {
              {
              msg_putchar('\n');
              }
            }
            {
            msg_advance(15);
            command_end = tagp.command_end;
            }
            if ((unsigned long )command_end != (unsigned long )((void *)0)) {
              p___0 = command_end + 3;
              {
              while (1) {
                while_continue___6: /* CIL Label */ ;
                if (*p___0) {
                  if ((int )*p___0 != 13) {
                    if (! ((int )*p___0 != 10)) {
                      goto while_break___6;
                    }
                  } else {
                    goto while_break___6;
                  }
                } else {
                  goto while_break___6;
                }
                {
                while (1) {
                  while_continue___7: /* CIL Label */ ;
                  if (! ((int )*p___0 == 9)) {
                    goto while_break___7;
                  }
                  p___0 ++;
                }
                while_break___7: /* CIL Label */ ;
                }
                {
                tmp___6 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"file:"),
                                  (size_t )5);
                }
                if (tmp___6 == 0) {
                  {
                  tmp___7 = vim_isspace((int )*(p___0 + 5));
                  }
                  if (tmp___7) {
                    p___0 += 5;
                    goto while_continue___6;
                  }
                }
                if ((unsigned long )p___0 == (unsigned long )tagp.tagkind) {
                  p___0 = tagp.tagkind_end;
                  goto while_continue___6;
                } else { //Added block
                if ((unsigned long )(p___0 + 5) == (unsigned long )tagp.tagkind) {
                  {
                  tmp___8 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"kind:"),
                                    (size_t )5);
                  }
                  if (tmp___8 == 0) {
                    p___0 = tagp.tagkind_end;
                    goto while_continue___6;
                  }
                }
                }
                attr = highlight_attr[8];
                {
                while (1) {
                  while_continue___8: /* CIL Label */ ;
                  if (*p___0) {
                    if ((int )*p___0 != 13) {
                      if (! ((int )*p___0 != 10)) {
                        goto while_break___8;
                      }
                    } else {
                      goto while_break___8;
                    }
                  } else {
                    goto while_break___8;
                  }
                  {
                  tmp___9 = charsize((int )*p___0);
                  }
                  if ((long )(msg_col + tmp___9) >= Columns) {
                    {
                    msg_putchar('\n');
                    msg_advance(15);
                    }
                  }
                  {
                  tmp___10 = transchar((int )*p___0);
                  msg_puts_attr(tmp___10, attr);
                  p___0 ++;
                  }
                  if ((int )*p___0 == 9) {
                    {
                    msg_puts_attr((char_u *)" ", attr);
                    }
                    goto while_break___8;
                  }
                  if ((int )*p___0 == 58) {
                    attr = 0;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
              }
              while_break___6: /* CIL Label */ ;
              }
              if (msg_col > 15) {
                {
                msg_putchar('\n');
                msg_advance(15);
                }
              }
            } else {
              p___0 = tagp.command;
              {
              while (1) {
                while_continue___9: /* CIL Label */ ;
                if (*p___0) {
                  if ((int )*p___0 != 13) {
                    if (! ((int )*p___0 != 10)) {
                      goto while_break___9;
                    }
                  } else {
                    goto while_break___9;
                  }
                } else {
                  goto while_break___9;
                }
                p___0 ++;
              }
              while_break___9: /* CIL Label */ ;
              }
              command_end = p___0;
            }
            p___0 = tagp.command;
            if ((int )*p___0 == 47) {
              goto _L___4;
            } else { //Added block
            if ((int )*p___0 == 63) {
              _L___4: 
              p___0 ++;
              if ((int )*p___0 == 94) {
                p___0 ++;
              }
            }
            }
            {
            while (1) {
              while_continue___10: /* CIL Label */ ;
              if ((unsigned long )p___0 != (unsigned long )command_end) {
                {
                tmp___11 = vim_isspace((int )*p___0);
                }
                if (! tmp___11) {
                  goto while_break___10;
                }
              } else {
                goto while_break___10;
              }
              p___0 ++;
            }
            while_break___10: /* CIL Label */ ;
            }
            {
            while (1) {
              while_continue___11: /* CIL Label */ ;
              if (! ((unsigned long )p___0 != (unsigned long )command_end)) {
                goto while_break___11;
              }
              if ((int )*p___0 == 9) {
                tmp___13 = 1;
              } else {
                {
                tmp___12 = charsize((int )*p___0);
                tmp___13 = tmp___12;
                }
              }
              if ((long )(msg_col + tmp___13) > Columns) {
                {
                msg_putchar('\n');
                }
              }
              {
              msg_advance(15);
              }
              if ((int )*p___0 == 92) {
                if ((int )*(p___0 + 1) == (int )*(tagp.command)) {
                  p___0 ++;
                }
              }
              if ((int )*p___0 == 9) {
                {
                msg_putchar(' ');
                }
              } else {
                {
                tmp___14 = transchar((int )*p___0);
                msg_puts(tmp___14);
                }
              }
              p___0 ++;
              if ((unsigned long )p___0 == (unsigned long )(command_end - 2)) {
                if ((int )*p___0 == 36) {
                  if ((int )*(p___0 + 1) == (int )*(tagp.command)) {
                    goto while_break___11;
                  }
                }
              }
              if ((unsigned long )p___0 == (unsigned long )(command_end - 1)) {
                if ((int )*p___0 == (int )*(tagp.command)) {
                  if ((int )*p___0 == 47) {
                    goto while_break___11;
                  } else { //Added block
                  if ((int )*p___0 == 63) {
                    goto while_break___11;
                  }
                  }
                }
              }
            }
            while_break___11: /* CIL Label */ ;
            }
            if (msg_col) {
              {
              msg_putchar('\n');
              }
            }
            {
            ui_breakcheck();
            }
            if (got_int) {
              got_int = 0;
              goto while_break___5;
            }
            i___0 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
          ask_for_selection = 1;
        }
      }
      }
      if (ask_for_selection == 1) {
        {
        msg_puts((char_u *)"Enter nr of choice (<CR> to abort): ");
        i___0 = get_number(1);
        }
        if (KeyTyped) {
          {
          msg_putchar('\n');
          cmdline_row = msg_row - 1;
          need_wait_return = 0;
          msg_didany = 0;
          }
        }
        if (i___0 <= 0) {
          goto _L___6;
        } else { //Added block
        if (i___0 > num_matches) {
          goto _L___6;
        } else { //Added block
        if (got_int) {
          _L___6: 
          if (use_tagstack) {
            (tagstack + tagstackidx)->fmark = saved_fmark;
            tagstackidx ++;
          }
          goto while_break___1;
        }
        }
        }
        {
        msg_scrolled = 0;
        redraw_all_later(40);
        cur_match = i___0 - 1;
        }
      }
      if (cur_match >= num_matches) {
        if (type == 3) {
          goto _L___7;
        } else { //Added block
        if (type == 5) {
          _L___7: 
          if (num_matches == 1) {
            {
            emsg((char_u *)"There is only one matching tag");
            }
          } else {
            {
            emsg((char_u *)"Cannot go beyond last matching tag");
            }
          }
          skip_msg = 1;
        }
        }
        cur_match = num_matches - 1;
      }
      if (use_tagstack) {
        (tagstack + tagstackidx)->cur_match = cur_match;
        tagstackidx ++;
      }
      if ((unsigned long )nofile_fname != (unsigned long )((void *)0)) {
        if (error_cur_match != cur_match) {
          {
          smsg((char_u *)"File \"%s\" does not exist", nofile_fname);
          }
        }
      }
      ic = (int )*(*(matches + cur_match) + 0) & 4;
      if (type != 7) {
        if (type != 9) {
          if (num_matches > 1) {
            goto _L___9;
          } else { //Added block
          if (ic) {
            _L___9: 
            if (! skip_msg) {
              if (max_num_matches != 2147483647) {
                tmp___15 = " or more";
              } else {
                tmp___15 = "";
              }
              {
              sprintf((char * __restrict  )((char *)(msg_buf)), (char const   * __restrict  )"tag %d of %d%s",
                      cur_match + 1, num_matches, tmp___15);
              }
              if (ic) {
                {
                strcat((char * __restrict  )((char *)(msg_buf)), (char const   * __restrict  )((char *)"  Using tag with different case!"));
                }
              }
              if (num_matches > prev_num_matches) {
                goto _L___8;
              } else { //Added block
              if (new_tag) {
                _L___8: 
                if (num_matches > 1) {
                  if (ic) {
                    {
                    msg_attr(msg_buf, highlight_attr[16]);
                    }
                  } else {
                    {
                    msg(msg_buf);
                    }
                  }
                  msg_scroll = 1;
                } else {
                  {
                  give_warning(msg_buf, ic);
                  }
                }
              } else {
                {
                give_warning(msg_buf, ic);
                }
              }
              }
              if (ic) {
                if (! msg_scrolled) {
                  {
                  out_flush();
                  ui_delay(1000L, 1);
                  }
                }
              }
            }
          }
          }
        }
      }
      {
      tmp___16 = jumpto_tag(*(matches + cur_match), forceit);
      }
      if (tmp___16 == 99) {
        if (type == 4) {
          if (cur_match > 0) {
            goto _L___11;
          } else {
            goto _L___13;
          }
        } else { //Added block
        _L___13: 
        if (type == 1) {
          goto _L___12;
        } else { //Added block
        if (type == 3) {
          goto _L___12;
        } else { //Added block
        if (type == 5) {
          _L___12: 
          if (max_num_matches != 2147483647) {
            goto _L___11;
          } else { //Added block
          if (cur_match < num_matches - 1) {
            _L___11: 
            error_cur_match = cur_match;
            if (use_tagstack) {
              tagstackidx --;
            }
            if (type == 4) {
              cur_match --;
            } else {
              type = 3;
              cur_match ++;
            }
            goto __Cont;
          }
          }
        }
        }
        }
        }
        {
        emsg2((char_u *)"File \"%s\" does not exist", nofile_fname);
        }
      } else { //Added block
      if (tagstackidx > curwin->w_tagstacklen) {
        tagstackidx = curwin->w_tagstackidx;
      }
      }
    }
    goto while_break___1;
    __Cont: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  end_do_tag: 
  if (use_tagstack) {
    if (tagstackidx <= curwin->w_tagstacklen) {
      curwin->w_tagstackidx = tagstackidx;
    }
  }
  postponed_split = 0;
  return (0);
}
}
void tag_freematch(void) 
{ 


  {
  {
  vim_free((void *)tagmatchname);
  tagmatchname = (char_u *)((void *)0);
  }
  return;
}
}
static void taglen_advance(int l ) 
{ 


  {
  if (l == 2147483647) {
    {
    msg_putchar('\n');
    msg_advance(24);
    }
  } else {
    {
    msg_advance(13 + l);
    }
  }
  return;
}
}
void do_tags(void) 
{ 
  int i___0 ;
  char_u *name___1 ;
  struct taggy *tagstack ;
  int tagstackidx ;
  int tagstacklen ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tagstack = curwin->w_tagstack;
  tagstackidx = curwin->w_tagstackidx;
  tagstacklen = curwin->w_tagstacklen;
  msg_puts_title((char_u *)"\n  # TO tag         FROM line  in file/text");
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < tagstacklen)) {
      goto while_break;
    }
    if ((unsigned long )(tagstack + i___0)->tagname != (unsigned long )((void *)0)) {
      {
      name___1 = fm_getname(& (tagstack + i___0)->fmark, 30);
      }
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      {
      msg_putchar('\n');
      }
      if (i___0 == tagstackidx) {
        tmp = '>';
      } else {
        tmp = ' ';
      }
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%c%2d %2d %-15s %5ld  ",
              tmp, i___0 + 1, (tagstack + i___0)->cur_match + 1, (tagstack + i___0)->tagname,
              (tagstack + i___0)->fmark.mark.lnum);
      msg_outtrans(IObuff);
      }
      if ((tagstack + i___0)->fmark.fnum == curbuf->b_fnum) {
        tmp___0 = highlight_attr[2];
      } else {
        tmp___0 = 0;
      }
      {
      msg_outtrans_attr(name___1, tmp___0);
      vim_free((void *)name___1);
      }
    }
    {
    out_flush();
    }
    __Cont: 
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (tagstackidx == tagstacklen) {
    {
    msg_puts((char_u *)"\n>");
    }
  }
  return;
}
}
int find_tags(char_u *pat , int *num_matches___0 , char_u ***matchesp , int flags___0 ,
              int mincount ) 
{ 
  FILE *fp___0 ;
  char_u *lbuf ;
  char_u *tag_fname ;
  int first_file ;
  struct tag_pointers tagp ;
  int did_open ;
  int stop_searching ;
  int retval ;
  int is_static ;
  int is_current ;
  int eof ;
  char_u *p___0 ;
  char_u *s ;
  int i___0 ;
  vim_regexp *prog ;
  struct tag_search_info search_info ;
  off_t filesize ;
  int tagcmp ;
  off_t offset ;
  enum __anonenum_state_169 state ;
  int cmplen ;
  int match ;
  int match_no_ic ;
  int match_re ;
  int matchoff ;
  struct growarray ga_match[16] ;
  int match_count ;
  char_u **matches___0 ;
  int mtt ;
  int len___0 ;
  int help_save ;
  int patlen ;
  char_u *pathead ;
  int patheadlen ;
  int findall ;
  int tmp ;
  int sort_error ;
  int linear ;
  int has_re ;
  int help_only ;
  int name_only ;
  int noic ;
  int get_it_again ;
  int verbose ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  __off_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int cc___0 ;
  int tmp___19 ;
  int tmp___20 ;
  char_u *temp_end ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;

  {
  did_open = 0;
  stop_searching = 0;
  retval = 0;
  eof = 0;
  prog = (vim_regexp *)((void *)0);
  match_no_ic = 0;
  matchoff = 0;
  match_count = 0;
  if (mincount == 2147483647) {
    tmp = 1;
  } else { //Added block
  if (mincount == 200) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  findall = tmp;
  sort_error = 0;
  has_re = flags___0 & 4;
  help_only = flags___0 & 1;
  name_only = flags___0 & 2;
  noic = flags___0 & 8;
  get_it_again = 0;
  verbose = flags___0 & 32;
  help_save = curbuf->b_help;
  if (has_re) {
    {
    prog = vim_regcomp(pat, p_magic);
    }
  }
  {
  lbuf = alloc(512U);
  tag_fname = alloc(513U);
  mtt = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (mtt < 16)) {
      goto while_break;
    }
    {
    ga_init2(& ga_match[mtt], (int )sizeof(char_u *), 100);
    mtt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
    goto findtag_end;
  } else { //Added block
  if ((unsigned long )tag_fname == (unsigned long )((void *)0)) {
    goto findtag_end;
  }
  }
  if (help_only) {
    curbuf->b_help = 1;
  }
  {
  tmp___0 = strlen((char const   *)((char *)pat));
  patlen = (int )tmp___0;
  }
  if (p_tl != 0L) {
    if ((long )patlen > p_tl) {
      patlen = (int )p_tl;
    }
  }
  pathead = pat;
  patheadlen = patlen;
  if (has_re) {
    if ((int )*(pat + 0) == 94) {
      pathead = pat + 1;
    } else { //Added block
    if ((int )*(pat + 0) == 92) {
      if ((int )*(pat + 1) == 60) {
        pathead = pat + 2;
      }
    }
    }
    if ((unsigned long )pathead == (unsigned long )pat) {
      patheadlen = 0;
    } else {
      patheadlen = 0;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (! ((int )*(pathead + patheadlen) != 0)) {
          goto while_break___0;
        }
        if (p_magic) {
          tmp___1 = ".[~*\\$";
        } else {
          tmp___1 = "\\$";
        }
        {
        tmp___2 = vim_strchr((char_u *)tmp___1, (int )*(pathead + patheadlen));
        }
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
          goto while_break___0;
        }
        patheadlen ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    if (p_tl != 0L) {
      if ((long )patheadlen > p_tl) {
        patheadlen = (int )p_tl;
      }
    }
  }
  if (p_ic) {
    goto _L;
  } else { //Added block
  if (! noic) {
    _L: 
    if (findall) {
      tmp___3 = 1;
    } else { //Added block
    if (patheadlen == 0) {
      tmp___3 = 1;
    } else { //Added block
    if (! p_tbs) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
    }
    }
  } else {
    tmp___3 = 0;
  }
  }
  reg_ic = tmp___3;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (reg_ic) {
      tmp___4 = 1;
    } else { //Added block
    if (patheadlen == 0) {
      tmp___4 = 1;
    } else { //Added block
    if (! p_tbs) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
    }
    }
    linear = tmp___4;
    first_file = 1;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
      tmp___27 = get_tagfname(first_file, tag_fname);
      }
      if (! (tmp___27 == 1)) {
        goto while_break___2;
      }
      {
      fp___0 = fopen((char const   * __restrict  )((char *)tag_fname), (char const   * __restrict  )"r");
      }
      if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      did_open = 1;
      state = (enum __anonenum_state_169 )0;
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
        line_breakcheck();
        }
        if (flags___0 & 64) {
          {
          ins_compl_check_keys();
          }
        }
        if (got_int) {
          stop_searching = 1;
          goto while_break___3;
        } else { //Added block
        if (completion_interrupted) {
          stop_searching = 1;
          goto while_break___3;
        }
        }
        if (mincount == 200) {
          if (match_count >= 200) {
            stop_searching = 1;
            retval = 1;
            goto while_break___3;
          }
        }
        if (get_it_again) {
          goto line_read_in;
        }
        if ((unsigned int )state == 2U) {
          offset = search_info.low_offset + (search_info.high_offset - search_info.low_offset) / 2L;
          if (offset == search_info.curr_offset) {
            goto while_break___3;
          } else {
            search_info.curr_offset = offset;
          }
        } else { //Added block
        if ((unsigned int )state == 3U) {
          search_info.curr_offset -= 1024L;
          if (search_info.curr_offset < 0L) {
            {
            search_info.curr_offset = (off_t )0;
            rewind(fp___0);
            state = (enum __anonenum_state_169 )4;
            }
          }
        }
        }
        if ((unsigned int )state == 2U) {
          goto _L___0;
        } else { //Added block
        if ((unsigned int )state == 3U) {
          _L___0: 
          {
          fseeko(fp___0, search_info.curr_offset, 0);
          eof = vim_fgets(lbuf, 512, fp___0);
          }
          if (! eof) {
            if (search_info.curr_offset != 0L) {
              {
              search_info.curr_offset = ftello(fp___0);
              }
              if (search_info.curr_offset == search_info.high_offset) {
                {
                fseeko(fp___0, search_info.low_offset, 0);
                search_info.curr_offset = search_info.low_offset;
                }
              }
              {
              eof = vim_fgets(lbuf, 512, fp___0);
              }
            }
          }
          {
          while (1) {
            while_continue___4: /* CIL Label */ ;
            if (! eof) {
              {
              tmp___5 = vim_isblankline(lbuf);
              }
              if (! tmp___5) {
                goto while_break___4;
              }
            } else {
              goto while_break___4;
            }
            {
            search_info.curr_offset = ftello(fp___0);
            eof = vim_fgets(lbuf, 512, fp___0);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          if (eof) {
            {
            state = (enum __anonenum_state_169 )3;
            search_info.match_offset = ftello(fp___0);
            }
            goto __Cont___0;
          }
        } else {
          {
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
            eof = vim_fgets(lbuf, 512, fp___0);
            }
            if (! eof) {
              {
              tmp___6 = vim_isblankline(lbuf);
              }
              if (! tmp___6) {
                goto while_break___5;
              }
            } else {
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          if (eof) {
            goto while_break___3;
          }
        }
        }
        line_read_in: 
        if ((unsigned int )state == 0U) {
          if (linear) {
            state = (enum __anonenum_state_169 )1;
          } else {
            {
            tmp___8 = strncmp((char const   *)((char *)lbuf), (char const   *)((char *)"!_TAG_"),
                              (size_t )6);
            }
            if (tmp___8 > 0) {
              state = (enum __anonenum_state_169 )2;
            } else {
              {
              tmp___7 = strncmp((char const   *)((char *)lbuf), (char const   *)((char *)"!_TAG_FILE_SORTED\t"),
                                (size_t )18);
              }
              if (tmp___7 == 0) {
                if ((int )*(lbuf + 18) == 49) {
                  state = (enum __anonenum_state_169 )2;
                } else {
                  state = (enum __anonenum_state_169 )1;
                }
              }
            }
          }
          if ((unsigned int )state == 2U) {
            {
            tmp___10 = fileno(fp___0);
            filesize = lseek(tmp___10, 0L, 2);
            }
            if (filesize <= 0L) {
              state = (enum __anonenum_state_169 )1;
            } else {
              {
              tmp___9 = fileno(fp___0);
              lseek(tmp___9, 0L, 0);
              search_info.low_offset = (off_t )0;
              search_info.low_char = 0;
              search_info.high_offset = filesize;
              search_info.high_char = 255;
              }
            }
            goto __Cont___0;
          }
        }
        if (patheadlen) {
          {
          tagp.tagname = lbuf;
          tagp.tagname_end = vim_strchr(lbuf, '\t');
          }
          if ((unsigned long )tagp.tagname_end == (unsigned long )((void *)0)) {
            {
            emsg2(e_tagformat, tag_fname);
            stop_searching = 1;
            }
            goto while_break___3;
          }
          tagp.fname = (char_u *)((void *)0);
          p___0 = lbuf;
          {
          while (1) {
            while_continue___6: /* CIL Label */ ;
            if (! ((unsigned long )p___0 < (unsigned long )tagp.tagname_end)) {
              goto while_break___6;
            }
            if ((int )*p___0 == 58) {
              if ((unsigned long )tagp.fname == (unsigned long )((void *)0)) {
                tagp.fname = tagp.tagname_end + 1;
              }
              {
              tmp___11 = strncmp((char const   *)((char *)lbuf), (char const   *)((char *)tagp.fname),
                                 (size_t )(p___0 - lbuf));
              }
              if (tmp___11 == 0) {
                if ((int )*(tagp.fname + (p___0 - lbuf)) == 9) {
                  tagp.tagname = p___0 + 1;
                  goto while_break___6;
                }
              }
            }
            p___0 ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          cmplen = (int )(tagp.tagname_end - tagp.tagname);
          if (p_tl != 0L) {
            if ((long )cmplen > p_tl) {
              cmplen = (int )p_tl;
            }
          }
          if (has_re) {
            if (patheadlen < cmplen) {
              cmplen = patheadlen;
            } else {
              goto _L___1;
            }
          } else { //Added block
          _L___1: 
          if ((unsigned int )state == 1U) {
            if (patheadlen != cmplen) {
              goto __Cont___0;
            }
          }
          }
          if ((unsigned int )state == 2U) {
            if ((int )*(tagp.tagname + 0) < search_info.low_char) {
              sort_error = 1;
            } else { //Added block
            if ((int )*(tagp.tagname + 0) > search_info.high_char) {
              sort_error = 1;
            }
            }
            {
            tagcmp = strncmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)pathead),
                             (size_t )cmplen);
            }
            if (tagcmp == 0) {
              if (cmplen < patheadlen) {
                tagcmp = -1;
              } else { //Added block
              if (cmplen > patheadlen) {
                tagcmp = 1;
              }
              }
            }
            if (tagcmp == 0) {
              state = (enum __anonenum_state_169 )3;
              search_info.match_offset = search_info.curr_offset;
              goto __Cont___0;
            }
            if (tagcmp < 0) {
              {
              search_info.curr_offset = ftello(fp___0);
              }
              if (search_info.curr_offset < search_info.high_offset) {
                search_info.low_offset = search_info.curr_offset;
                search_info.low_char = (int )*(tagp.tagname + 0);
                goto __Cont___0;
              }
            }
            if (tagcmp > 0) {
              if (search_info.curr_offset != search_info.high_offset) {
                search_info.high_offset = search_info.curr_offset;
                search_info.high_char = (int )*(tagp.tagname + 0);
                goto __Cont___0;
              }
            }
            goto while_break___3;
          } else { //Added block
          if ((unsigned int )state == 3U) {
            {
            tmp___12 = strncasecmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)pathead),
                                   (size_t )cmplen);
            }
            if (tmp___12 != 0) {
              state = (enum __anonenum_state_169 )4;
            }
            goto __Cont___0;
          } else { //Added block
          if ((unsigned int )state == 4U) {
            {
            tmp___14 = strncasecmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)pathead),
                                   (size_t )cmplen);
            }
            if (tmp___14) {
              {
              tmp___13 = ftello(fp___0);
              }
              if (tmp___13 > search_info.match_offset) {
                goto while_break___3;
              } else {
                goto __Cont___0;
              }
            }
          } else {
            {
            tmp___15 = strncasecmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)pathead),
                                   (size_t )cmplen);
            }
            if (tmp___15) {
              goto __Cont___0;
            }
          }
          }
          }
          if ((unsigned long )tagp.fname == (unsigned long )((void *)0)) {
            tagp.fname = tagp.tagname_end + 1;
          }
          {
          tagp.fname_end = vim_strchr(tagp.fname, '\t');
          tagp.command = tagp.fname_end + 1;
          }
          if ((unsigned long )tagp.fname_end == (unsigned long )((void *)0)) {
            i___0 = 0;
          } else {
            i___0 = 1;
          }
        } else {
          {
          i___0 = parse_tag_line(lbuf, & tagp);
          }
        }
        if (i___0 == 0) {
          {
          emsg2(e_tagformat, tag_fname);
          stop_searching = 1;
          }
          goto while_break___3;
        }
        cmplen = (int )(tagp.tagname_end - tagp.tagname);
        if (p_tl != 0L) {
          if ((long )cmplen > p_tl) {
            cmplen = (int )p_tl;
          }
        }
        if (patlen != cmplen) {
          match = 0;
        } else { //Added block
        if (reg_ic) {
          {
          tmp___16 = strncasecmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)pat),
                                 (size_t )cmplen);
          match = tmp___16 == 0;
          }
          if (match) {
            {
            tmp___17 = strncmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)pat),
                               (size_t )cmplen);
            match_no_ic = tmp___17 == 0;
            }
          }
        } else {
          {
          tmp___18 = strncmp((char const   *)((char *)tagp.tagname), (char const   *)((char *)pat),
                             (size_t )cmplen);
          match = tmp___18 == 0;
          }
        }
        }
        match_re = 0;
        if (! match) {
          if ((unsigned long )prog != (unsigned long )((void *)0)) {
            {
            cc___0 = (int )*(tagp.tagname_end);
            *(tagp.tagname_end) = (char_u )'\000';
            match = vim_regexec(prog, tagp.tagname, 1);
            matchoff = (int )(prog->startp[0] - tagp.tagname);
            }
            if (match) {
              if (reg_ic) {
                {
                reg_ic = 0;
                match_no_ic = vim_regexec(prog, tagp.tagname, 1);
                reg_ic = 1;
                }
              }
            }
            *(tagp.tagname_end) = (char_u )cc___0;
            match_re = 1;
          }
        }
        if (match) {
          {
          is_current = test_for_current(tagp.fname, tagp.fname_end, tag_fname);
          }
          if ((unsigned long )tagp.tagname != (unsigned long )lbuf) {
            is_static = 1;
          } else {
            {
            is_static = test_for_static(& tagp);
            }
          }
          if (is_static) {
            if (is_current) {
              mtt = 0;
            } else {
              mtt = 3;
            }
          } else { //Added block
          if (is_current) {
            mtt = 1;
          } else {
            mtt = 2;
          }
          }
          if (reg_ic) {
            if (! match_no_ic) {
              mtt += 4;
            }
          }
          if (match_re) {
            mtt += 8;
          }
          {
          tmp___26 = ga_grow(& ga_match[mtt], 1);
          }
          if (tmp___26 == 1) {
            if (help_only) {
              {
              *(tagp.tagname_end) = (char_u )'\000';
              len___0 = (int )(tagp.tagname_end - tagp.tagname);
              p___0 = vim_strnsave(tagp.tagname, len___0 + 10);
              }
              if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                if (match_re) {
                  tmp___19 = matchoff;
                } else {
                  tmp___19 = 0;
                }
                {
                tmp___20 = help_heuristic(tagp.tagname, tmp___19, ! match_no_ic);
                sprintf((char * __restrict  )(((char *)p___0 + len___0) + 1), (char const   * __restrict  )"%06d",
                        tmp___20);
                }
              }
              *(tagp.tagname_end) = (char_u )'\t';
              len___0 ++;
            } else { //Added block
            if (name_only) {
              p___0 = (char_u *)((void *)0);
              len___0 = 0;
              if (get_it_again) {
                temp_end = tagp.command;
                if ((int )*temp_end == 47) {
                  {
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
                    if (*temp_end) {
                      if ((int )*temp_end != 13) {
                        if ((int )*temp_end != 10) {
                          if (! ((int )*temp_end != 36)) {
                            goto while_break___7;
                          }
                        } else {
                          goto while_break___7;
                        }
                      } else {
                        goto while_break___7;
                      }
                    } else {
                      goto while_break___7;
                    }
                    temp_end ++;
                  }
                  while_break___7: /* CIL Label */ ;
                  }
                }
                if ((unsigned long )(tagp.command + 2) < (unsigned long )temp_end) {
                  {
                  len___0 = (int )((temp_end - tagp.command) - 2L);
                  p___0 = vim_strnsave(tagp.command + 2, len___0);
                  }
                }
                get_it_again = 0;
              } else {
                {
                len___0 = (int )(tagp.tagname_end - tagp.tagname);
                p___0 = vim_strnsave(tagp.tagname, len___0);
                }
                if (State & 16) {
                  get_it_again = p_sft;
                }
              }
              len___0 ++;
            } else {
              {
              tmp___21 = strlen((char const   *)((char *)tag_fname));
              tmp___22 = strlen((char const   *)((char *)lbuf));
              len___0 = (int )((tmp___21 + tmp___22) + 3UL);
              p___0 = alloc((unsigned int )len___0);
              }
              if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
                {
                *(p___0 + 0) = (char_u )mtt;
                strcpy((char * __restrict  )((char *)(p___0 + 1)), (char const   * __restrict  )((char *)tag_fname));
                tmp___23 = strlen((char const   *)((char *)tag_fname));
                s = ((p___0 + 1) + tmp___23) + 1;
                strcpy((char * __restrict  )((char *)s), (char const   * __restrict  )((char *)lbuf));
                }
              }
            }
            }
            if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
              i___0 = ga_match[mtt].ga_len;
              {
              while (1) {
                while_continue___8: /* CIL Label */ ;
                i___0 --;
                if (i___0 >= 0) {
                  if (! (! got_int)) {
                    goto while_break___8;
                  }
                } else {
                  goto while_break___8;
                }
                {
                tmp___24 = memcmp((void const   *)*((char_u **)ga_match[mtt].ga_data + i___0),
                                  (void const   *)p___0, (size_t )len___0);
                }
                if (tmp___24 == 0) {
                  goto while_break___8;
                }
                {
                line_breakcheck();
                }
              }
              while_break___8: /* CIL Label */ ;
              }
              if (i___0 < 0) {
                tmp___25 = ga_match[mtt].ga_len;
                (ga_match[mtt].ga_len) ++;
                *((char_u **)ga_match[mtt].ga_data + tmp___25) = p___0;
                (ga_match[mtt].ga_room) --;
                match_count ++;
              } else {
                {
                vim_free((void *)p___0);
                }
              }
            }
          } else {
            retval = 1;
            stop_searching = 1;
            goto while_break___3;
          }
        }
        __Cont___0: ;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      fclose(fp___0);
      }
      if (sort_error) {
        {
        emsg2((char_u *)"Tags file not sorted: %s", tag_fname);
        sort_error = 0;
        }
      }
      if (match_count >= mincount) {
        retval = 1;
        stop_searching = 1;
      }
      if (stop_searching) {
        goto while_break___2;
      }
      __Cont: 
      first_file = 0;
    }
    while_break___2: /* CIL Label */ ;
    }
    if (stop_searching) {
      goto while_break___1;
    } else { //Added block
    if (linear) {
      goto while_break___1;
    } else { //Added block
    if (! p_ic) {
      if (noic) {
        goto while_break___1;
      }
    }
    }
    }
    reg_ic = 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  if (! stop_searching) {
    if (! did_open) {
      if (verbose) {
        {
        emsg((char_u *)"No tags file");
        }
      }
    }
    retval = 1;
  }
  findtag_end: 
  {
  vim_free((void *)lbuf);
  vim_free((void *)prog);
  vim_free((void *)tag_fname);
  }
  if (retval == 0) {
    match_count = 0;
  }
  if (match_count > 0) {
    {
    tmp___28 = lalloc((unsigned long )match_count * sizeof(char_u *), 1);
    matches___0 = (char_u **)tmp___28;
    }
  } else {
    matches___0 = (char_u **)((void *)0);
  }
  match_count = 0;
  mtt = 0;
  {
  while (1) {
    while_continue___9: /* CIL Label */ ;
    if (! (mtt < 16)) {
      goto while_break___9;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___10: /* CIL Label */ ;
      if (! (i___0 < ga_match[mtt].ga_len)) {
        goto while_break___10;
      }
      p___0 = *((char_u **)ga_match[mtt].ga_data + i___0);
      if ((unsigned long )matches___0 == (unsigned long )((void *)0)) {
        {
        vim_free((void *)p___0);
        }
      } else {
        tmp___29 = match_count;
        match_count ++;
        *(matches___0 + tmp___29) = p___0;
      }
      i___0 ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
    ga_clear(& ga_match[mtt]);
    mtt ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  *matchesp = matches___0;
  *num_matches___0 = match_count;
  curbuf->b_help = help_save;
  return (retval);
}
}
static char_u *np  =    (char_u *)((void *)0);
static struct visited *first_visited  =    (struct visited *)((void *)0);
static int get_tagfname(int first___0 , char_u *buf___3 ) 
{ 
  char_u *fname ;
  size_t path_len ;
  size_t fname_len ;
  struct visited *vp ;
  struct stat st ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;

  {
  if (first___0) {
    np = p_tags;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )first_visited != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {
      vp = first_visited->v_next;
      vim_free((void *)first_visited);
      first_visited = vp;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  if ((unsigned long )np == (unsigned long )((void *)0)) {
    return (0);
  }
  if (curbuf->b_help) {
    {
    tmp = gettail(p_hf);
    path_len = (size_t )(tmp - p_hf);
    }
    if (path_len + 9UL >= 512UL) {
      return (0);
    }
    {
    memmove((void *)((char *)buf___3), (void const   *)((char *)p_hf), path_len);
    strcpy((char * __restrict  )((char *)(buf___3 + path_len)), (char const   * __restrict  )((char *)"tags"));
    np = (char_u *)((void *)0);
    }
  } else {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((int )*np == 0) {
        return (0);
      }
      {
      copy_option_part(& np, buf___3, 512, (char *)" ,");
      }
      if ((int )*(buf___3 + 0) == 46) {
        {
        tmp___2 = vim_ispathsep((int )*(buf___3 + 1));
        }
        if (tmp___2) {
          {
          tmp___3 = vim_strchr(p_cpo, 'd');
          }
          if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
            if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
              {
              tmp___0 = gettail(curbuf->b_fname);
              path_len = (size_t )(tmp___0 - curbuf->b_fname);
              fname = buf___3 + 1;
              }
              {
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
                tmp___1 = vim_ispathsep((int )*fname);
                }
                if (! tmp___1) {
                  goto while_break___1;
                }
                fname ++;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
              fname_len = strlen((char const   *)((char *)fname));
              }
              if ((fname_len + path_len) + 1UL > 512UL) {
                goto __Cont;
              }
              {
              memmove((void *)((char *)(buf___3 + path_len)), (void const   *)((char *)fname),
                      fname_len + 1UL);
              memmove((void *)((char *)buf___3), (void const   *)((char *)curbuf->b_fname),
                      path_len);
              }
            }
          }
        }
      }
      {
      tmp___4 = stat((char const   * __restrict  )((char *)buf___3), (struct stat * __restrict  )(& st));
      }
      if (tmp___4 < 0) {
        goto __Cont;
      }
      vp = first_visited;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
          goto while_break___2;
        }
        if (vp->v_st.st_dev == st.st_dev) {
          if (vp->v_st.st_ino == st.st_ino) {
            goto while_break___2;
          }
        }
        vp = vp->v_next;
      }
      while_break___2: /* CIL Label */ ;
      }
      if ((unsigned long )vp != (unsigned long )((void *)0)) {
        goto __Cont;
      }
      {
      tmp___5 = alloc((unsigned int )sizeof(struct visited ));
      vp = (struct visited *)tmp___5;
      }
      if ((unsigned long )vp != (unsigned long )((void *)0)) {
        vp->v_st = st;
        vp->v_next = first_visited;
        first_visited = vp;
      }
      goto while_break___0;
      __Cont: ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return (1);
}
}
static int parse_tag_line(char_u *lbuf , struct tag_pointers *tagp ) 
{ 
  char_u *p___0 ;

  {
  {
  tagp->tagname = lbuf;
  p___0 = vim_strchr(lbuf, '\t');
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    return (0);
  }
  tagp->tagname_end = p___0;
  if ((int )*p___0 != 0) {
    p___0 ++;
  }
  {
  tagp->fname = p___0;
  p___0 = vim_strchr(p___0, '\t');
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    return (0);
  }
  tagp->fname_end = p___0;
  if ((int )*p___0 != 0) {
    p___0 ++;
  }
  if ((int )*p___0 == 0) {
    return (0);
  }
  tagp->command = p___0;
  return (1);
}
}
static int test_for_static(struct tag_pointers *tagp ) 
{ 
  char_u *p___0 ;
  int len___0 ;
  int tmp ;
  int tmp___0 ;

  {
  len___0 = (int )(tagp->fname_end - tagp->fname);
  p___0 = tagp->tagname + len___0;
  if ((unsigned long )p___0 < (unsigned long )tagp->tagname_end) {
    if ((int )*p___0 == 58) {
      {
      tmp = strncmp((char const   *)((char *)tagp->tagname), (char const   *)((char *)tagp->fname),
                    (size_t )len___0);
      }
      if (tmp == 0) {
        tagp->tagname = p___0 + 1;
        return (1);
      }
    }
  }
  p___0 = tagp->command;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    p___0 = vim_strchr(p___0, '\t');
    }
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    p___0 ++;
    tmp___0 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"file:"),
                      (size_t )5);
    }
    if (tmp___0 == 0) {
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int parse_match(char_u *lbuf , struct tag_pointers *tagp ) 
{ 
  int retval ;
  char_u *p___0 ;
  char_u *pc ;
  char_u *pt ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  {
  tagp->tag_fname = lbuf + 1;
  tmp = strlen((char const   *)((char *)tagp->tag_fname));
  lbuf += tmp + 2UL;
  retval = parse_tag_line(lbuf, tagp);
  tagp->tagkind = (char_u *)((void *)0);
  tagp->command_end = (char_u *)((void *)0);
  }
  if (retval == 1) {
    {
    p___0 = tagp->command;
    tmp___2 = find_extra(& p___0);
    }
    if (tmp___2 == 1) {
      tagp->command_end = p___0;
      p___0 += 3;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        {
        tmp___1 = __ctype_b_loc();
        }
        if (! ((int const   )*(*tmp___1 + (int )*p___0) & 1024)) {
          goto while_break;
        }
        {
        tmp___0 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"kind:"),
                          (size_t )5);
        }
        if (tmp___0 == 0) {
          tagp->tagkind = p___0 + 5;
          goto while_break;
        }
        {
        pc = vim_strchr(p___0, ':');
        pt = vim_strchr(p___0, '\t');
        }
        if ((unsigned long )pc == (unsigned long )((void *)0)) {
          tagp->tagkind = p___0;
          goto while_break;
        } else { //Added block
        if ((unsigned long )pt != (unsigned long )((void *)0)) {
          if ((unsigned long )pc > (unsigned long )pt) {
            tagp->tagkind = p___0;
            goto while_break;
          }
        }
        }
        if ((unsigned long )pt == (unsigned long )((void *)0)) {
          goto while_break;
        }
        p___0 = pt + 1;
      }
      while_break: /* CIL Label */ ;
      }
    }
    if ((unsigned long )tagp->tagkind != (unsigned long )((void *)0)) {
      p___0 = tagp->tagkind;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        if (*p___0) {
          if ((int )*p___0 != 9) {
            if ((int )*p___0 != 13) {
              if (! ((int )*p___0 != 10)) {
                goto while_break___0;
              }
            } else {
              goto while_break___0;
            }
          } else {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        p___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      tagp->tagkind_end = p___0;
    }
  }
  return (retval);
}
}
static char_u *tag_full_fname(struct tag_pointers *tagp ) 
{ 
  char_u *fullname ;
  int c ;

  {
  {
  c = (int )*(tagp->fname_end);
  *(tagp->fname_end) = (char_u )'\000';
  fullname = expand_tag_fname(tagp->fname, tagp->tag_fname, 0);
  *(tagp->fname_end) = (char_u )c;
  }
  return (fullname);
}
}
static int jumpto_tag(char_u *lbuf , int forceit ) 
{ 
  int save_secure ;
  int save_magic ;
  int save_p_ws ;
  int save_p_scs ;
  int save_p_ic ;
  linenr_t save_lnum ;
  int csave ;
  char_u *str___1 ;
  char_u *pbuf ;
  char_u *pbuf_end ;
  char_u *tofree_fname ;
  char_u *fname ;
  struct tag_pointers tagp ;
  int retval ;
  int getfile_result ;
  int search_options ;
  int save_no_hlsearch ;
  WIN *curwin_save ;
  char_u *full_fname ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int found ;
  int cc___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
  csave = 0;
  tofree_fname = (char_u *)((void *)0);
  retval = 0;
  curwin_save = (WIN *)((void *)0);
  full_fname = (char_u *)((void *)0);
  pbuf = alloc(512U);
  }
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
    tagp.fname_end = (char_u *)((void *)0);
    goto erret;
  } else {
    {
    tmp = parse_match(lbuf, & tagp);
    }
    if (tmp == 0) {
      tagp.fname_end = (char_u *)((void *)0);
      goto erret;
    }
  }
  csave = (int )*(tagp.fname_end);
  *(tagp.fname_end) = (char_u )'\000';
  fname = tagp.fname;
  str___1 = tagp.command;
  pbuf_end = pbuf;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (*str___1) {
      if ((int )*str___1 != 10) {
        if (! ((int )*str___1 != 13)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    tmp___0 = pbuf_end;
    pbuf_end ++;
    tmp___1 = str___1;
    str___1 ++;
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *pbuf_end = (char_u )'\000';
  str___1 = pbuf;
  tmp___2 = find_extra(& str___1);
  }
  if (tmp___2 == 1) {
    pbuf_end = str___1;
    *pbuf_end = (char_u )'\000';
  }
  {
  fname = expand_tag_fname(fname, tagp.tag_fname, 1);
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    goto erret;
  }
  {
  tofree_fname = fname;
  tmp___3 = mch_getperm(fname);
  }
  if (tmp___3 < 0L) {
    {
    retval = 99;
    vim_free((void *)nofile_fname);
    nofile_fname = vim_strsave(fname);
    }
    if ((unsigned long )nofile_fname == (unsigned long )((void *)0)) {
      nofile_fname = (char_u *)"";
    }
    goto erret;
  }
  RedrawingDisabled ++;
  if (g_do_tagpreview) {
    postponed_split = 0;
    curwin_save = curwin;
    if (! curwin->w_preview) {
      {
      full_fname = FullName_save(fname, 0);
      fname = full_fname;
      prepare_tagpreview();
      }
    }
  }
  if (postponed_split) {
    if (postponed_split > 0) {
      tmp___4 = postponed_split;
    } else {
      tmp___4 = 0;
    }
    {
    win_split(tmp___4, 0, 0);
    }
  }
  {
  keep_help_flag = curbuf->b_help;
  getfile_result = getfile(0, fname, (char_u *)((void *)0), 1, (linenr_t )0, forceit);
  keep_help_flag = 0;
  }
  if (getfile_result <= 0) {
    {
    curwin->w_set_curswant = 1;
    postponed_split = 0;
    save_secure = secure;
    secure = 1;
    save_magic = p_magic;
    p_magic = 0;
    save_no_hlsearch = no_hlsearch;
    tag_modified = 0;
    tmp___5 = vim_strchr(p_cpo, 't');
    }
    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
      search_options = 0;
    } else {
      search_options = 1024;
    }
    str___1 = pbuf;
    if ((int )*(pbuf + 0) == 47) {
      {
      tmp___6 = skip_regexp(pbuf + 1, (int )*(pbuf + 0), 0);
      str___1 = tmp___6 + 1;
      }
    } else { //Added block
    if ((int )*(pbuf + 0) == 63) {
      {
      tmp___6 = skip_regexp(pbuf + 1, (int )*(pbuf + 0), 0);
      str___1 = tmp___6 + 1;
      }
    }
    }
    if ((unsigned long )str___1 > (unsigned long )(pbuf_end - 1)) {
      {
      save_p_ws = p_ws;
      save_p_ic = p_ic;
      save_p_scs = p_scs;
      p_ws = 1;
      p_ic = 0;
      p_scs = 0;
      add_to_history(1, pbuf + 1, 1);
      save_lnum = curwin->w_cursor.lnum;
      curwin->w_cursor.lnum = (linenr_t )0;
      tmp___10 = do_search((OPARG *)((void *)0), (int )*(pbuf + 0), pbuf + 1, 1L,
                           search_options);
      }
      if (tmp___10) {
        retval = 1;
      } else {
        {
        found = 1;
        p_ic = 1;
        tmp___9 = do_search((OPARG *)((void *)0), (int )*(pbuf + 0), pbuf + 1, 1L,
                            search_options);
        }
        if (! tmp___9) {
          {
          found = 2;
          test_for_static(& tagp);
          cc___0 = (int )*(tagp.tagname_end);
          *(tagp.tagname_end) = (char_u )'\000';
          sprintf((char * __restrict  )((char *)pbuf), (char const   * __restrict  )"^%s\\s\\*(",
                  tagp.tagname);
          tmp___8 = do_search((OPARG *)((void *)0), '/', pbuf, 1L, search_options);
          }
          if (! tmp___8) {
            {
            sprintf((char * __restrict  )((char *)pbuf), (char const   * __restrict  )"^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*(",
                    tagp.tagname);
            tmp___7 = do_search((OPARG *)((void *)0), '/', pbuf, 1L, search_options);
            }
            if (! tmp___7) {
              found = 0;
            }
          }
          *(tagp.tagname_end) = (char_u )cc___0;
        }
        if (found == 0) {
          {
          emsg((char_u *)"Can\'t find tag pattern");
          curwin->w_cursor.lnum = save_lnum;
          }
        } else {
          if (found == 2) {
            goto _L;
          } else { //Added block
          if (! save_p_ic) {
            _L: 
            {
            msg((char_u *)"Couldn\'t find tag, just guessing!");
            }
            if (! msg_scrolled) {
              {
              out_flush();
              ui_delay(1000L, 1);
              }
            }
          }
          }
          retval = 1;
        }
      }
      {
      p_ws = save_p_ws;
      p_ic = save_p_ic;
      p_scs = save_p_scs;
      adjust_cursor();
      }
    } else {
      {
      curwin->w_cursor.lnum = (linenr_t )1;
      do_cmdline(pbuf, (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
                 3);
      retval = 1;
      }
    }
    if (tag_modified) {
      {
      secure = 2;
      emsg((char_u *)"WARNING: tag command changed a buffer!!!");
      }
    }
    if (secure == 2) {
      {
      wait_return(1);
      }
    }
    secure = save_secure;
    p_magic = save_magic;
    if (search_options) {
      no_hlsearch = save_no_hlsearch;
    }
    if (getfile_result == -1) {
      retval = 1;
    }
    if (curbuf->b_help) {
      {
      set_topline(curwin, curwin->w_cursor.lnum);
      update_topline();
      update_screen(40);
      }
    }
    if (g_do_tagpreview) {
      if ((unsigned long )curwin_save != (unsigned long )((void *)0)) {
        if ((unsigned long )curwin != (unsigned long )curwin_save) {
          {
          validate_cursor();
          update_screen(10);
          win_enter(curwin_save, 1);
          }
        }
      }
    }
    RedrawingDisabled --;
  } else {
    RedrawingDisabled --;
    if (postponed_split) {
      {
      close_window(curwin, 0);
      postponed_split = 0;
      }
    }
  }
  erret: 
  g_do_tagpreview = 0;
  if ((unsigned long )tagp.fname_end != (unsigned long )((void *)0)) {
    *(tagp.fname_end) = (char_u )csave;
  }
  {
  vim_free((void *)pbuf);
  vim_free((void *)tofree_fname);
  vim_free((void *)full_fname);
  }
  return (retval);
}
}
static char_u *expand_tag_fname(char_u *fname , char_u *tag_fname , int expand ) 
{ 
  char_u *p___0 ;
  char_u *retval ;
  char_u *expanded_fname ;
  int tmp ;
  int tmp___0 ;

  {
  expanded_fname = (char_u *)((void *)0);
  if (expand) {
    {
    tmp = mch_has_wildcard(fname);
    }
    if (tmp) {
      {
      expand_context = 2;
      expanded_fname = ExpandOne(fname, (char_u *)((void *)0), 65, 2);
      }
      if ((unsigned long )expanded_fname != (unsigned long )((void *)0)) {
        fname = expanded_fname;
      }
    }
  }
  if (p_tr) {
    goto _L;
  } else { //Added block
  if (curbuf->b_help) {
    _L: 
    {
    tmp___0 = mch_isFullName(fname);
    }
    if (tmp___0) {
      {
      retval = vim_strsave(fname);
      }
    } else {
      {
      p___0 = gettail(tag_fname);
      }
      if ((unsigned long )p___0 != (unsigned long )tag_fname) {
        {
        retval = alloc(1024U);
        }
        if ((unsigned long )retval != (unsigned long )((void *)0)) {
          {
          strcpy((char * __restrict  )((char *)retval), (char const   * __restrict  )((char *)tag_fname));
          strncpy((char * __restrict  )((char *)(retval + (p___0 - tag_fname))), (char const   * __restrict  )((char *)fname),
                  (size_t )(1024L - (p___0 - tag_fname)));
          simplify_filename(retval);
          }
        }
      } else {
        {
        retval = vim_strsave(fname);
        }
      }
    }
  } else {
    {
    retval = vim_strsave(fname);
    }
  }
  }
  {
  vim_free((void *)expanded_fname);
  }
  return (retval);
}
}
void simplify_filename(char_u *filename ) 
{ 
  int components ;
  char_u *p___0 ;
  char_u *tail ;
  char_u *start___0 ;
  char_u *orig ;
  char_u *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct stat orig_st ;
  struct stat new_st ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  components = 0;
  tmp = vim_strsave(filename);
  orig = tmp;
  }
  if ((unsigned long )orig == (unsigned long )((void *)0)) {
    return;
  }
  p___0 = filename;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = vim_ispathsep((int )*p___0);
    }
    if (! tmp___0) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  start___0 = p___0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    tmp___9 = vim_ispathsep((int )*p___0);
    }
    if (tmp___9) {
      {
      tmp___1 = strlen((char const   *)((char *)(p___0 + 1)));
      memmove((void *)((char *)p___0), (void const   *)((char *)(p___0 + 1)), tmp___1 + 1UL);
      }
    } else { //Added block
    if ((int )*(p___0 + 0) == 46) {
      {
      tmp___8 = vim_ispathsep((int )*(p___0 + 1));
      }
      if (tmp___8) {
        {
        tmp___2 = strlen((char const   *)((char *)(p___0 + 2)));
        memmove((void *)((char *)p___0), (void const   *)((char *)(p___0 + 2)), tmp___2 + 1UL);
        }
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((int )*(p___0 + 0) == 46) {
      if ((int )*(p___0 + 1) == 46) {
        {
        tmp___7 = vim_ispathsep((int )*(p___0 + 2));
        }
        if (tmp___7) {
          if (components > 0) {
            tail = p___0 + 3;
            {
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
              tmp___3 = vim_ispathsep((int )*tail);
              }
              if (! tmp___3) {
                goto while_break___1;
              }
              tail ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            p___0 --;
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              if ((unsigned long )p___0 > (unsigned long )start___0) {
                {
                tmp___4 = vim_ispathsep((int )*(p___0 + -1));
                }
                if (tmp___4) {
                  goto while_break___2;
                }
              } else {
                goto while_break___2;
              }
              p___0 --;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              if ((unsigned long )(p___0 - 1) > (unsigned long )start___0) {
                {
                tmp___5 = vim_ispathsep((int )*(p___0 + -2));
                }
                if (! tmp___5) {
                  goto while_break___3;
                }
              } else {
                goto while_break___3;
              }
              p___0 --;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
            tmp___6 = strlen((char const   *)((char *)tail));
            memmove((void *)((char *)p___0), (void const   *)((char *)tail), tmp___6 + 1UL);
            components --;
            }
          } else {
            p___0 += 3;
          }
        } else {
          {
          components ++;
          p___0 = getnextcomp(p___0);
          }
        }
      } else {
        {
        components ++;
        p___0 = getnextcomp(p___0);
        }
      }
    } else {
      {
      components ++;
      p___0 = getnextcomp(p___0);
      }
    }
    }
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      if (! ((int )*p___0 != 0)) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  tmp___10 = stat((char const   * __restrict  )((char *)orig), (struct stat * __restrict  )(& orig_st));
  }
  if (tmp___10 < 0) {
    {
    strcpy((char * __restrict  )((char *)filename), (char const   * __restrict  )((char *)orig));
    }
  } else {
    {
    tmp___11 = stat((char const   * __restrict  )((char *)filename), (struct stat * __restrict  )(& new_st));
    }
    if (tmp___11 < 0) {
      {
      strcpy((char * __restrict  )((char *)filename), (char const   * __restrict  )((char *)orig));
      }
    } else { //Added block
    if (orig_st.st_ino != new_st.st_ino) {
      {
      strcpy((char * __restrict  )((char *)filename), (char const   * __restrict  )((char *)orig));
      }
    } else { //Added block
    if (orig_st.st_dev != new_st.st_dev) {
      {
      strcpy((char * __restrict  )((char *)filename), (char const   * __restrict  )((char *)orig));
      }
    }
    }
    }
  }
  {
  vim_free((void *)orig);
  }
  return;
}
}
static int test_for_current(char_u *fname , char_u *fname_end , char_u *tag_fname ) 
{ 
  int c ;
  int retval ;
  char_u *fullname ;
  int tmp ;

  {
  retval = 0;
  if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
    {
    c = (int )*fname_end;
    *fname_end = (char_u )'\000';
    fullname = expand_tag_fname(fname, tag_fname, 1);
    }
    if ((unsigned long )fullname != (unsigned long )((void *)0)) {
      {
      tmp = fullpathcmp(fullname, curbuf->b_ffname, 1);
      retval = tmp & 1;
      vim_free((void *)fullname);
      }
    }
    *fname_end = (char_u )c;
  }
  return (retval);
}
}
static int find_extra(char_u **pp ) 
{ 
  char_u *str___1 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  str___1 = *pp;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp = __ctype_b_loc();
    }
    if ((int const   )*(*tmp + (int )*str___1) & 2048) {
      {
      str___1 = skipdigits(str___1);
      }
    } else { //Added block
    if ((int )*str___1 == 47) {
      goto _L;
    } else { //Added block
    if ((int )*str___1 == 63) {
      _L: 
      {
      str___1 = skip_regexp(str___1 + 1, (int )*str___1, 0);
      }
      if ((int )*str___1 != (int )*(*pp)) {
        str___1 = (char_u *)((void *)0);
      } else {
        str___1 ++;
      }
    } else {
      str___1 = (char_u *)((void *)0);
    }
    }
    }
    if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
      goto while_break;
    } else { //Added block
    if ((int )*str___1 != 59) {
      goto while_break;
    } else {
      {
      tmp___0 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___0 + (int )*(str___1 + 1)) & 2048)) {
        if (! ((int )*(str___1 + 1) == 47)) {
          if (! ((int )*(str___1 + 1) == 63)) {
            goto while_break;
          }
        }
      }
    }
    }
    str___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
    {
    tmp___1 = strncmp((char const   *)((char *)str___1), (char const   *)((char *)";\"\t"),
                      (size_t )3);
    }
    if (tmp___1 == 0) {
      *pp = str___1;
      return (1);
    }
  }
  return (0);
}
}
int expand_tags(int tagnames , char_u *pat , int *num_file , char_u ***file ) 
{ 
  int i___0 ;
  int c ;
  int tagnmflag ;
  char_u tagnm[100] ;
  struct tag_pointers t_p ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (tagnames) {
    tagnmflag = 2;
  } else {
    tagnmflag = 0;
  }
  if ((int )*(pat + 0) == 94) {
    if ((int )*(pat + 1) == 47) {
      {
      ret = find_tags(pat + 2, num_file, file, (4 | tagnmflag) | 32, 200);
      }
    } else {
      {
      ret = find_tags(pat, num_file, file, ((4 | tagnmflag) | 32) | 8, 200);
      }
    }
  } else {
    {
    ret = find_tags(pat, num_file, file, ((4 | tagnmflag) | 32) | 8, 200);
    }
  }
  if (ret == 1) {
    if (! tagnames) {
      i___0 = 0;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (i___0 < *num_file)) {
          goto while_break;
        }
        {
        parse_match(*(*file + i___0), & t_p);
        c = (int )(t_p.tagname_end - t_p.tagname);
        memmove((void *)((char *)(tagnm)), (void const   *)((char *)t_p.tagname),
                (size_t )c);
        tmp = c;
        c ++;
        tagnm[tmp] = (char_u )0;
        tmp___0 = c;
        c ++;
        }
        if ((unsigned long )t_p.tagkind != (unsigned long )((void *)0)) {
          if (*(t_p.tagkind)) {
            tagnm[tmp___0] = *(t_p.tagkind);
          } else {
            tagnm[tmp___0] = (char_u )'f';
          }
        } else {
          tagnm[tmp___0] = (char_u )'f';
        }
        {
        tmp___1 = c;
        c ++;
        tagnm[tmp___1] = (char_u )0;
        memmove((void *)((char *)(*(*file + i___0) + c)), (void const   *)((char *)t_p.fname),
                (size_t )(t_p.fname_end - t_p.fname));
        *(*(*file + i___0) + ((long )c + (t_p.fname_end - t_p.fname))) = (char_u )0;
        memmove((void *)((char *)*(*file + i___0)), (void const   *)((char *)(tagnm)),
                (size_t )c);
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return (ret);
}
}
#pragma merger("0","/tmp/cil-x_nT2aar.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
void del_termcode(char_u *name___1 ) ;
int find_term_bykeys(char_u *src ) ;
void ui_write(char_u *s , int len___0 ) ;
void screen_new_rows(void) ;
extern char PC ;
extern char *UP ;
extern char *BC ;
extern short ospeed ;
extern char *tgoto(char const   * , int  , int  ) ;
extern int tgetent(char * , char const   * ) ;
extern int tgetflag(char const   * ) ;
extern int tgetnum(char const   * ) ;
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
static struct builtin_term *find_builtin_term(char_u *term ) ;
static void parse_builtin_tcap(char_u *term ) ;
static void term_color(char_u *s , int n ) ;
static void gather_termleader(void) ;
static int get_bytes_from_buf(char_u *buf___3 , char_u *bytes , int num_bytes ) ;
static int term_is_builtin(char_u *name___1 ) ;
static int term_7to8bit(char_u *p___0 ) ;
static char_u *tgetent_error(char_u *tbuf , char_u *term ) ;
extern char *tgetstr(char * , char ** ) ;
static int need_get_crv  =    1;
static char_u *vim_tgetstr(char *s , char_u **pp ) ;
struct builtin_term builtin_termcaps[181]  = 
  {      {0, (char *)"ansi"}, 
        {1, (char *)"\033[K"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {14, (char *)"\033[0m"}, 
        {15, (char *)"\033[7m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {0, (char *)"xterm"}, 
        {1, (char *)"\033[K"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {6, (char *)"\033[%i%p1%d;%p2%dr"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {8, (char *)"\033[J"}, 
        {14, (char *)"\033[m"}, 
        {15, (char *)"\033[7m"}, 
        {16, (char *)"\033[1m"}, 
        {21, (char *)"\033[m"}, 
        {22, (char *)"\033[4m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {25, (char *)"\033M"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {28, (char *)"\033[?1h\033="}, 
        {29, (char *)"\033[?1l\033>"}, 
        {43, (char *)"\033]1;"}, 
        {44, (char *)"\a"}, 
        {45, (char *)"\033]2;"}, 
        {46, (char *)"\a"}, 
        {48, (char *)"\033[8;%p1%d;%p2%dt"}, 
        {47, (char *)"\033[3;%p1%d;%p2%dt"}, 
        {49, (char *)"\033[>c"}, 
        {107 + (117 << 8), (char *)"\033OA"}, 
        {107 + (100 << 8), (char *)"\033OB"}, 
        {107 + (114 << 8), (char *)"\033OC"}, 
        {107 + (108 << 8), (char *)"\033OD"}, 
        {253 + (4 << 8), (char *)"\033O2A"}, 
        {253 + (5 << 8), (char *)"\033O2B"}, 
        {37 + (105 << 8), (char *)"\033O2C"}, 
        {35 + (52 << 8), (char *)"\033O2D"}, 
        {253 + (55 << 8), (char *)"\033OP"}, 
        {253 + (56 << 8), (char *)"\033OQ"}, 
        {253 + (57 << 8), (char *)"\033OR"}, 
        {253 + (58 << 8), (char *)"\033OS"}, 
        {107 + (49 << 8), (char *)"\033[11~"}, 
        {107 + (50 << 8), (char *)"\033[12~"}, 
        {107 + (51 << 8), (char *)"\033[13~"}, 
        {107 + (52 << 8), (char *)"\033[14~"}, 
        {107 + (53 << 8), (char *)"\033[15~"}, 
        {107 + (54 << 8), (char *)"\033[17~"}, 
        {107 + (55 << 8), (char *)"\033[18~"}, 
        {107 + (56 << 8), (char *)"\033[19~"}, 
        {107 + (57 << 8), (char *)"\033[20~"}, 
        {107 + (59 << 8), (char *)"\033[21~"}, 
        {70 + (49 << 8), (char *)"\033[23~"}, 
        {70 + (50 << 8), (char *)"\033[24~"}, 
        {253 + (63 << 8), (char *)"\033O2P"}, 
        {253 + (64 << 8), (char *)"\033O2Q"}, 
        {253 + (65 << 8), (char *)"\033O2R"}, 
        {253 + (66 << 8), (char *)"\033O2S"}, 
        {253 + (6 << 8), (char *)"\033[11;2~"}, 
        {253 + (7 << 8), (char *)"\033[12;2~"}, 
        {253 + (8 << 8), (char *)"\033[13;2~"}, 
        {253 + (9 << 8), (char *)"\033[14;2~"}, 
        {253 + (10 << 8), (char *)"\033[15;2~"}, 
        {253 + (11 << 8), (char *)"\033[17;2~"}, 
        {253 + (12 << 8), (char *)"\033[18;2~"}, 
        {253 + (13 << 8), (char *)"\033[19;2~"}, 
        {253 + (14 << 8), (char *)"\033[20;2~"}, 
        {253 + (15 << 8), (char *)"\033[21;2~"}, 
        {253 + (16 << 8), (char *)"\033[23;2~"}, 
        {253 + (17 << 8), (char *)"\033[24;2~"}, 
        {37 + (49 << 8), (char *)"\033[28~"}, 
        {38 + (56 << 8), (char *)"\033[26~"}, 
        {107 + (73 << 8), (char *)"\033[2~"}, 
        {107 + (104 << 8), (char *)"\033[7~"}, 
        {35 + (50 << 8), (char *)"\033O2H"}, 
        {75 + (49 << 8), (char *)"\033[1~"}, 
        {253 + (60 << 8), (char *)"\033OH"}, 
        {64 + (55 << 8), (char *)"\033[8~"}, 
        {42 + (55 << 8), (char *)"\033O2F"}, 
        {75 + (52 << 8), (char *)"\033[4~"}, 
        {253 + (59 << 8), (char *)"\033OF"}, 
        {107 + (80 << 8), (char *)"\033[5~"}, 
        {107 + (78 << 8), (char *)"\033[6~"}, 
        {75 + (54 << 8), (char *)"\033Ok"}, 
        {75 + (55 << 8), (char *)"\033Om"}, 
        {75 + (56 << 8), (char *)"\033Oo"}, 
        {75 + (57 << 8), (char *)"\033Oj"}, 
        {75 + (65 << 8), (char *)"\033OM"}, 
        {253 + (70 << 8), (char *)"\033[3~"}, 
        {257, (char *)""}, 
        {107 + (48 << 8), (char *)"\033[10~"}, 
        {70 + (51 << 8), (char *)"\033[25~"}, 
        {70 + (54 << 8), (char *)"\033[29~"}, 
        {70 + (55 << 8), (char *)"\033[31~"}, 
        {70 + (56 << 8), (char *)"\033[32~"}, 
        {70 + (57 << 8), (char *)"\033[33~"}, 
        {70 + (65 << 8), (char *)"\033[34~"}, 
        {0, (char *)"iris-ansi"}, 
        {1, (char *)"\033[K"}, 
        {8, (char *)"\033[J"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {12, (char *)"\033[9/y\033[12/y"}, 
        {13, (char *)"\033[10/y\033[=1h\033[=2l"}, 
        {30, (char *)"\033[=6h"}, 
        {31, (char *)"\033[=6l"}, 
        {17, (char *)"\033[m"}, 
        {18, (char *)"\033[1;7m"}, 
        {14, (char *)"\033[m"}, 
        {15, (char *)"\033[7m"}, 
        {16, (char *)"\033[1m"}, 
        {21, (char *)"\033[m"}, 
        {34, (char *)"8"}, 
        {40, (char *)"\033[4%p1%dm"}, 
        {39, (char *)"\033[3%p1%dm"}, 
        {22, (char *)"\033[4m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {25, (char *)"\033M"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {43, (char *)"\033P3.y"}, 
        {44, (char *)"\234"}, 
        {45, (char *)"\033P1.y"}, 
        {46, (char *)"\234"}, 
        {48, (char *)"\033[203;%p1%d;%p2%d/y"}, 
        {107 + (117 << 8), (char *)"\033[A"}, 
        {107 + (100 << 8), (char *)"\033[B"}, 
        {107 + (108 << 8), (char *)"\033[D"}, 
        {107 + (114 << 8), (char *)"\033[C"}, 
        {253 + (4 << 8), (char *)"\033[161q"}, 
        {253 + (5 << 8), (char *)"\033[164q"}, 
        {35 + (52 << 8), (char *)"\033[158q"}, 
        {37 + (105 << 8), (char *)"\033[167q"}, 
        {107 + (49 << 8), (char *)"\033[001q"}, 
        {107 + (50 << 8), (char *)"\033[002q"}, 
        {107 + (51 << 8), (char *)"\033[003q"}, 
        {107 + (52 << 8), (char *)"\033[004q"}, 
        {107 + (53 << 8), (char *)"\033[005q"}, 
        {107 + (54 << 8), (char *)"\033[006q"}, 
        {107 + (55 << 8), (char *)"\033[007q"}, 
        {107 + (56 << 8), (char *)"\033[008q"}, 
        {107 + (57 << 8), (char *)"\033[009q"}, 
        {107 + (59 << 8), (char *)"\033[010q"}, 
        {70 + (49 << 8), (char *)"\033[011q"}, 
        {70 + (50 << 8), (char *)"\033[012q"}, 
        {253 + (6 << 8), (char *)"\033[013q"}, 
        {253 + (7 << 8), (char *)"\033[014q"}, 
        {253 + (8 << 8), (char *)"\033[015q"}, 
        {253 + (9 << 8), (char *)"\033[016q"}, 
        {253 + (10 << 8), (char *)"\033[017q"}, 
        {253 + (11 << 8), (char *)"\033[018q"}, 
        {253 + (12 << 8), (char *)"\033[019q"}, 
        {253 + (13 << 8), (char *)"\033[020q"}, 
        {253 + (14 << 8), (char *)"\033[021q"}, 
        {253 + (15 << 8), (char *)"\033[022q"}, 
        {253 + (16 << 8), (char *)"\033[023q"}, 
        {253 + (17 << 8), (char *)"\033[024q"}, 
        {107 + (73 << 8), (char *)"\033[139q"}, 
        {107 + (104 << 8), (char *)"\033[H"}, 
        {64 + (55 << 8), (char *)"\033[146q"}, 
        {107 + (80 << 8), (char *)"\033[150q"}, 
        {107 + (78 << 8), (char *)"\033[154q"}, 
        {0, (char *)"dumb"}, 
        {7, (char *)"\f"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {0, (char *)((void *)0)}};
static int need_gather  =    0;
static char_u termleader[257]  ;
static struct builtin_term *find_builtin_term(char_u *term ) 
{ 
  struct builtin_term *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  p___0 = builtin_termcaps;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0->bt_string != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (p___0->bt_entry == 0) {
      {
      tmp___2 = strcmp((char const   *)p___0->bt_string, (char const   *)((char *)"iris-ansi"));
      }
      if (tmp___2 == 0) {
        {
        tmp___3 = vim_is_iris(term);
        }
        if (tmp___3) {
          return (p___0);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        {
        tmp___0 = strcmp((char const   *)p___0->bt_string, (char const   *)((char *)"xterm"));
        }
        if (tmp___0 == 0) {
          {
          tmp___1 = vim_is_xterm(term);
          }
          if (tmp___1) {
            return (p___0);
          } else {
            goto _L;
          }
        } else {
          _L: 
          {
          tmp = strcmp((char const   *)((char *)term), (char const   *)p___0->bt_string);
          }
          if (tmp == 0) {
            return (p___0);
          }
        }
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (p___0);
}
}
static void parse_builtin_tcap(char_u *term ) 
{ 
  struct builtin_term *p___0 ;
  char_u name___1[2] ;
  int term_8bit ;
  char_u *s ;
  char_u *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  {
  p___0 = find_builtin_term(term);
  term_8bit = term_is_8bit(term);
  p___0 ++;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (p___0->bt_entry != 0) {
      if (! (p___0->bt_entry != 257)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (p___0->bt_entry < 256) {
      if ((unsigned long )term_strings[p___0->bt_entry] == (unsigned long )((void *)0)) {
        goto _L;
      } else { //Added block
      if ((unsigned long )term_strings[p___0->bt_entry] == (unsigned long )empty_option) {
        _L: 
        if (term_8bit) {
          {
          tmp___1 = term_7to8bit((char_u *)p___0->bt_string);
          }
          if (tmp___1 != 0) {
            {
            s = vim_strsave((char_u *)p___0->bt_string);
            }
            if ((unsigned long )s != (unsigned long )((void *)0)) {
              t = s;
              {
              while (1) {
                while_continue___0: /* CIL Label */ ;
                if (! *t) {
                  goto while_break___0;
                }
                {
                tmp___0 = term_7to8bit(t);
                }
                if (tmp___0) {
                  {
                  tmp = term_7to8bit(t);
                  *t = (char_u )tmp;
                  strcpy((char * __restrict  )((char *)(t + 1)), (char const   * __restrict  )((char *)(t + 2)));
                  }
                }
                t ++;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              term_strings[p___0->bt_entry] = s;
              set_term_option_alloced(& term_strings[p___0->bt_entry]);
              }
            }
          } else {
            term_strings[p___0->bt_entry] = (char_u *)p___0->bt_string;
          }
        } else {
          term_strings[p___0->bt_entry] = (char_u *)p___0->bt_string;
        }
      }
      }
    } else {
      {
      name___1[0] = (char_u )(p___0->bt_entry & 255);
      name___1[1] = (char_u )(((unsigned int )p___0->bt_entry >> 8) & 255U);
      tmp___2 = find_termcode(name___1);
      }
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
        add_termcode(name___1, (char_u *)p___0->bt_string, term_8bit);
        }
      }
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static char nr_colors[15]  ;
static char_u tstrbuf[2048]  ;
static char *key_names[31]  = 
  {      (char *)"ku",      (char *)"kd",      (char *)"kr",      (char *)"#4", 
        (char *)"%i",      (char *)"k1",      (char *)"k2",      (char *)"k3", 
        (char *)"k4",      (char *)"k5",      (char *)"k6",      (char *)"k7", 
        (char *)"k8",      (char *)"k9",      (char *)"k;",      (char *)"F1", 
        (char *)"F2",      (char *)"%1",      (char *)"&8",      (char *)"kb", 
        (char *)"kI",      (char *)"kD",      (char *)"kh",      (char *)"@7", 
        (char *)"kP",      (char *)"kN",      (char *)"K1",      (char *)"K3", 
        (char *)"K4",      (char *)"K5",      (char *)((void *)0)};
static struct __anonstruct_string_names_169 string_names[45]  = 
  {      {(enum SpecialKey )1, (char *)"ce"}, 
        {(enum SpecialKey )2, (char *)"al"}, 
        {(enum SpecialKey )3, (char *)"AL"}, 
        {(enum SpecialKey )4, (char *)"dl"}, 
        {(enum SpecialKey )5, (char *)"DL"}, 
        {(enum SpecialKey )6, (char *)"cs"}, 
        {(enum SpecialKey )7, (char *)"cl"}, 
        {(enum SpecialKey )8, (char *)"cd"}, 
        {(enum SpecialKey )11, (char *)"vi"}, 
        {(enum SpecialKey )12, (char *)"ve"}, 
        {(enum SpecialKey )38, (char *)"mb"}, 
        {(enum SpecialKey )13, (char *)"vs"}, 
        {(enum SpecialKey )14, (char *)"me"}, 
        {(enum SpecialKey )15, (char *)"mr"}, 
        {(enum SpecialKey )16, (char *)"md"}, 
        {(enum SpecialKey )17, (char *)"se"}, 
        {(enum SpecialKey )18, (char *)"so"}, 
        {(enum SpecialKey )19, (char *)"ZH"}, 
        {(enum SpecialKey )20, (char *)"ZR"}, 
        {(enum SpecialKey )21, (char *)"ue"}, 
        {(enum SpecialKey )22, (char *)"us"}, 
        {(enum SpecialKey )24, (char *)"cm"}, 
        {(enum SpecialKey )25, (char *)"sr"}, 
        {(enum SpecialKey )26, (char *)"RI"}, 
        {(enum SpecialKey )27, (char *)"vb"}, 
        {(enum SpecialKey )28, (char *)"ks"}, 
        {(enum SpecialKey )29, (char *)"ke"}, 
        {(enum SpecialKey )30, (char *)"ti"}, 
        {(enum SpecialKey )31, (char *)"te"}, 
        {(enum SpecialKey )32, (char *)"bc"}, 
        {(enum SpecialKey )36, (char *)"Sb"}, 
        {(enum SpecialKey )35, (char *)"Sf"}, 
        {(enum SpecialKey )40, (char *)"AB"}, 
        {(enum SpecialKey )39, (char *)"AF"}, 
        {(enum SpecialKey )41, (char *)"le"}, 
        {(enum SpecialKey )42, (char *)"nd"}, 
        {(enum SpecialKey )50, (char *)"op"}, 
        {(enum SpecialKey )49, (char *)"RV"}, 
        {(enum SpecialKey )43, (char *)"IS"}, 
        {(enum SpecialKey )44, (char *)"IE"}, 
        {(enum SpecialKey )45, (char *)"ts"}, 
        {(enum SpecialKey )46, (char *)"fs"}, 
        {(enum SpecialKey )47, (char *)"WP"}, 
        {(enum SpecialKey )48, (char *)"WS"}, 
        {(enum SpecialKey )0, (char *)((void *)0)}};
int set_termname(char_u *term ) 
{ 
  struct builtin_term *termp ;
  int builtin_first ;
  int try ;
  int termcap_cleared ;
  int width ;
  int height ;
  char_u *error_msg ;
  char_u *bs_p ;
  char_u *del_p ;
  int tmp ;
  char_u *p___0 ;
  int i___0 ;
  char_u tbuf[2048] ;
  char_u *tp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  char_u *p___1 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  BUF *old_curbuf ;
  int tmp___13 ;

  {
  {
  builtin_first = p_tbi;
  termcap_cleared = 0;
  width = 0;
  height = 0;
  error_msg = (char_u *)((void *)0);
  tmp = term_is_builtin(term);
  }
  if (tmp) {
    term += 8;
    builtin_first = 1;
  }
  if (builtin_first) {
    try = 0;
  } else {
    try = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (try < 3)) {
      goto while_break;
    }
    if (try == 1) {
      {
      error_msg = tgetent_error(tbuf, term);
      }
      if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
        tp = tstrbuf;
        if (! termcap_cleared) {
          {
          clear_termoptions();
          termcap_cleared = 1;
          }
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((unsigned long )string_names[i___0].name != (unsigned long )((void *)0))) {
            goto while_break___0;
          }
          if ((unsigned long )term_strings[(int )string_names[i___0].dest] == (unsigned long )((void *)0)) {
            {
            term_strings[(int )string_names[i___0].dest] = vim_tgetstr(string_names[i___0].name,
                                                                       & tp);
            }
          } else { //Added block
          if ((unsigned long )term_strings[(int )string_names[i___0].dest] == (unsigned long )empty_option) {
            {
            term_strings[(int )string_names[i___0].dest] = vim_tgetstr(string_names[i___0].name,
                                                                       & tp);
            }
          }
          }
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        if ((unsigned long )term_strings[23] == (unsigned long )((void *)0)) {
          goto _L;
        } else { //Added block
        if ((unsigned long )term_strings[23] == (unsigned long )empty_option) {
          _L: 
          {
          tmp___0 = tgetflag("ms");
          }
          if (tmp___0) {
            term_strings[23] = (char_u *)"y";
          }
        }
        }
        if ((unsigned long )term_strings[37] == (unsigned long )((void *)0)) {
          goto _L___0;
        } else { //Added block
        if ((unsigned long )term_strings[37] == (unsigned long )empty_option) {
          _L___0: 
          {
          tmp___1 = tgetflag("xs");
          }
          if (tmp___1) {
            term_strings[37] = (char_u *)"y";
          }
        }
        }
        if ((unsigned long )term_strings[10] == (unsigned long )((void *)0)) {
          goto _L___1;
        } else { //Added block
        if ((unsigned long )term_strings[10] == (unsigned long )empty_option) {
          _L___1: 
          {
          tmp___2 = tgetflag("db");
          }
          if (tmp___2) {
            term_strings[10] = (char_u *)"y";
          }
        }
        }
        if ((unsigned long )term_strings[9] == (unsigned long )((void *)0)) {
          goto _L___2;
        } else { //Added block
        if ((unsigned long )term_strings[9] == (unsigned long )empty_option) {
          _L___2: 
          {
          tmp___3 = tgetflag("da");
          }
          if (tmp___3) {
            term_strings[9] = (char_u *)"y";
          }
        }
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___1: /* CIL Label */ ;
          if (! ((unsigned long )key_names[i___0] != (unsigned long )((void *)0))) {
            goto while_break___1;
          }
          {
          tmp___5 = find_termcode((char_u *)key_names[i___0]);
          }
          if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
            {
            tmp___4 = vim_tgetstr(key_names[i___0], & tp);
            add_termcode((char_u *)key_names[i___0], tmp___4, 0);
            }
          }
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        tmp___6 = find_termcode((char_u *)"kl");
        }
        if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
          {
          p___0 = vim_tgetstr((char *)"kl", & tp);
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            if ((int )*p___0 != 8) {
              {
              add_termcode((char_u *)"kl", p___0, 0);
              }
            }
          }
        }
        if (height == 0) {
          {
          height = tgetnum("li");
          }
        }
        if (width == 0) {
          {
          width = tgetnum("co");
          }
        }
        {
        i___0 = tgetnum("Co");
        }
        if (i___0 > 0) {
          {
          sprintf((char * __restrict  )(nr_colors), (char const   * __restrict  )"%d",
                  i___0);
          term_strings[34] = (char_u *)(nr_colors);
          }
        }
        {
        tmp___7 = vim_tgetstr((char *)"bc", & tp);
        BC = (char *)tmp___7;
        tmp___8 = vim_tgetstr((char *)"up", & tp);
        UP = (char *)tmp___8;
        p___0 = vim_tgetstr((char *)"pc", & tp);
        }
        if (p___0) {
          PC = (char )*p___0;
        }
      }
    } else {
      if (try == 2) {
        if (builtin_first) {
          if (termcap_cleared) {
            goto while_break;
          }
        }
      }
      {
      termp = find_builtin_term(term);
      }
      if ((unsigned long )termp->bt_string == (unsigned long )((void *)0)) {
        if (try == 0) {
          goto __Cont;
        }
        if (termcap_cleared) {
          goto while_break;
        }
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "\r\n");
        }
        if ((unsigned long )error_msg != (unsigned long )((void *)0)) {
          {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                  (char *)error_msg);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                  "\r\n");
          }
        }
        {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "\'");
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)term);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "\' not known. Available builtin terminals are:\r\n");
        termp = & builtin_termcaps[0];
        }
        {
        while (1) {
          while_continue___2: /* CIL Label */ ;
          if (! ((unsigned long )termp->bt_string != (unsigned long )((void *)0))) {
            goto while_break___2;
          }
          if (termp->bt_entry == 0) {
            {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "    builtin_");
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    termp->bt_string);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s",
                    "\r\n");
            }
          }
          termp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        if (starting != 2) {
          {
          screen_start();
          wait_return(1);
          }
          return (0);
        }
        {
        term = (char_u *)"ansi";
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "defaulting to \'");
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)term);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", "\'\r\n");
        screen_start();
        out_flush();
        ui_delay(2000L, 1);
        set_string_option_direct((char_u *)"term", -1, term, 1);
        fflush(stderr);
        }
      }
      {
      out_flush();
      }
      if (! termcap_cleared) {
        {
        clear_termoptions();
        termcap_cleared = 1;
        }
      }
      {
      parse_builtin_tcap(term);
      }
    }
    __Cont: 
    try ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  tmp___9 = strcmp((char const   *)((char *)term), (char const   *)((char *)"pcterm"));
  }
  if (tmp___9 == 0) {
    term_strings[33] = (char_u *)"yes";
  } else {
    term_strings[33] = empty_option;
  }
  {
  get_stty();
  bs_p = find_termcode((char_u *)"kb");
  del_p = find_termcode((char_u *)"kD");
  }
  if ((unsigned long )bs_p == (unsigned long )((void *)0)) {
    {
    bs_p = (char_u *)"\b";
    add_termcode((char_u *)"kb", bs_p, 0);
    }
  } else { //Added block
  if ((int )*bs_p == 0) {
    {
    bs_p = (char_u *)"\b";
    add_termcode((char_u *)"kb", bs_p, 0);
    }
  }
  }
  if ((unsigned long )del_p == (unsigned long )((void *)0)) {
    goto _L___3;
  } else { //Added block
  if ((int )*del_p == 0) {
    _L___3: 
    if ((unsigned long )bs_p == (unsigned long )((void *)0)) {
      {
      add_termcode((char_u *)"kD", (char_u *)"\177", 0);
      }
    } else { //Added block
    if ((int )*bs_p != 127) {
      {
      add_termcode((char_u *)"kD", (char_u *)"\177", 0);
      }
    }
    }
  }
  }
  {
  p___1 = (char_u *)"";
  clip_init(0);
  tmp___11 = vim_is_xterm(term);
  }
  if (tmp___11) {
    {
    tmp___10 = use_xterm_mouse();
    }
    if (tmp___10) {
      p___1 = (char_u *)((void *)0);
    } else {
      p___1 = (char_u *)"xterm";
    }
    {
    setup_xterm_clip();
    }
  }
  if ((unsigned long )p___1 != (unsigned long )((void *)0)) {
    {
    set_option_value((char_u *)"ttym", 0L, p___1);
    }
  } else {
    {
    check_mouse_termcode();
    }
  }
  {
  tmp___12 = vim_is_fastterm(term);
  }
  if (tmp___12) {
    p_tf = 1;
  }
  {
  ttest(1);
  full_screen = 1;
  set_term_defaults();
  need_get_crv = 1;
  }
  if (starting != 2) {
    {
    starttermcap();
    setmouse();
    maketitle();
    }
  }
  if (width <= 0) {
    width = 80;
    height = 24;
  } else { //Added block
  if (height <= 0) {
    width = 80;
    height = 24;
  }
  }
  {
  set_winsize(width, height, 0);
  }
  if (starting != 2) {
    if (scroll_region) {
      {
      scroll_region_reset();
      }
    }
    {
    check_map_keycodes();
    old_curbuf = curbuf;
    curbuf = firstbuf;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! ((unsigned long )curbuf != (unsigned long )((void *)0))) {
        goto while_break___3;
      }
      if ((unsigned long )curbuf->b_ml.ml_mfp != (unsigned long )((void *)0)) {
        {
        apply_autocmds((EVENT_T )31, (char_u *)((void *)0), (char_u *)((void *)0),
                       0, curbuf);
        }
      }
      curbuf = curbuf->b_next;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    tmp___13 = buf_valid(old_curbuf);
    }
    if (tmp___13) {
      curbuf = old_curbuf;
    }
  }
  return (1);
}
}
static int has_mouse_termcode  =    0;
void set_mouse_termcode(int n , char_u *s ) 
{ 
  char_u name___1[2] ;

  {
  {
  name___1[0] = (char_u )n;
  name___1[1] = (char_u )'X';
  add_termcode(name___1, s, 0);
  has_mouse_termcode |= 1;
  }
  return;
}
}
void del_mouse_termcode(int n ) 
{ 
  char_u name___1[2] ;

  {
  {
  name___1[0] = (char_u )n;
  name___1[1] = (char_u )'X';
  del_termcode(name___1);
  has_mouse_termcode &= -2;
  }
  return;
}
}
static char_u *tgetent_error(char_u *tbuf , char_u *term ) 
{ 
  int i___0 ;

  {
  {
  i___0 = tgetent((char *)tbuf, (char const   *)((char *)term));
  }
  if (i___0 < 1) {
    {
    tgetent((char *)tbuf, (char const   *)((char *)"dumb"));
    }
    if (i___0 == -1) {
      return ((char_u *)"Cannot open termcap file");
    }
    if (i___0 == 0) {
      return ((char_u *)"Terminal entry not found in terminfo");
    }
  }
  return ((char_u *)((void *)0));
}
}
static char_u *vim_tgetstr(char *s , char_u **pp ) 
{ 
  char *p___0 ;

  {
  {
  p___0 = tgetstr(s, (char **)pp);
  }
  if ((unsigned long )p___0 == (unsigned long )((char *)-1)) {
    p___0 = (char *)((void *)0);
  }
  return ((char_u *)p___0);
}
}
void getlinecol(void) 
{ 
  char_u tbuf[2048] ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  if ((unsigned long )term_strings[0] != (unsigned long )((void *)0)) {
    if ((int )*(term_strings[0]) != 0) {
      {
      tmp___1 = tgetent_error(tbuf, term_strings[0]);
      }
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        if (Columns == 0L) {
          {
          tmp = tgetnum("co");
          Columns = (long )tmp;
          }
        }
        if (Rows == 0L) {
          {
          tmp___0 = tgetnum("li");
          Rows = (long )tmp___0;
          }
        }
      }
    }
  }
  return;
}
}
int add_termcap_entry(char_u *name___1 , int force ) 
{ 
  char_u *term ;
  int key ;
  struct builtin_term *termp ;
  char_u *string___0 ;
  int i___0 ;
  int builtin_first ;
  char_u tbuf[2048] ;
  char_u tstrbuf___0[2048] ;
  char_u *tp ;
  char_u *error_msg ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tp = tstrbuf___0;
  error_msg = (char_u *)((void *)0);
  if (! force) {
    {
    tmp = find_termcode(name___1);
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      return (1);
    }
  }
  term = term_strings[0];
  if ((unsigned long )term == (unsigned long )((void *)0)) {
    return (0);
  } else { //Added block
  if ((int )*term == 0) {
    return (0);
  }
  }
  {
  tmp___0 = term_is_builtin(term);
  }
  if (tmp___0) {
    term += 8;
    builtin_first = 1;
  } else {
    builtin_first = p_tbi;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break;
    }
    if (! builtin_first == i___0) {
      {
      termp = find_builtin_term(term);
      }
      if ((unsigned long )termp->bt_string != (unsigned long )((void *)0)) {
        key = (int )*(name___1 + 0) + ((int )*(name___1 + 1) << 8);
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (termp->bt_entry != 0)) {
            goto while_break___0;
          }
          if (termp->bt_entry == key) {
            {
            tmp___1 = term_is_8bit(term);
            add_termcode(name___1, (char_u *)termp->bt_string, tmp___1);
            }
            return (1);
          }
          termp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
      error_msg = tgetent_error(tbuf, term);
      }
      if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
        {
        string___0 = vim_tgetstr((char *)name___1, & tp);
        }
        if ((unsigned long )string___0 != (unsigned long )((void *)0)) {
          if ((int )*string___0 != 0) {
            {
            add_termcode(name___1, string___0, 0);
            }
            return (1);
          }
        }
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )sourcing_name == (unsigned long )((void *)0)) {
    if ((unsigned long )error_msg != (unsigned long )((void *)0)) {
      {
      emsg(error_msg);
      }
    } else {
      {
      emsg2((char_u *)"No \"%s\" entry in termcap", name___1);
      }
    }
  }
  return (0);
}
}
static int term_is_builtin(char_u *name___1 ) 
{ 
  int tmp ;

  {
  {
  tmp = strncmp((char const   *)((char *)name___1), (char const   *)((char *)"builtin_"),
                (size_t )8);
  }
  return (tmp == 0);
}
}
int term_is_8bit(char_u *name___1 ) 
{ 
  char *tmp ;

  {
  {
  tmp = strstr((char const   *)((char *)name___1), "8bit");
  }
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
static int term_7to8bit(char_u *p___0 ) 
{ 


  {
  if ((int )*p___0 == 27) {
    if ((int )*(p___0 + 1) == 91) {
      return (155);
    }
    if ((int )*(p___0 + 1) == 93) {
      return (157);
    }
    if ((int )*(p___0 + 1) == 79) {
      return (143);
    }
  }
  return (0);
}
}
void termcapinit(char_u *name___1 ) 
{ 
  char_u *term ;
  char *tmp ;
  char_u *tmp___0 ;

  {
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    if ((int )*name___1 == 0) {
      name___1 = (char_u *)((void *)0);
    }
  }
  term = name___1;
  if ((unsigned long )term == (unsigned long )((void *)0)) {
    {
    tmp = getenv((char const   *)((char *)((char_u *)"TERM")));
    term = (char_u *)tmp;
    }
  }
  if ((unsigned long )term == (unsigned long )((void *)0)) {
    term = (char_u *)"ansi";
  } else { //Added block
  if ((int )*term == 0) {
    term = (char_u *)"ansi";
  }
  }
  {
  set_string_option_direct((char_u *)"term", -1, term, 1);
  set_string_default((char *)"term", term);
  set_string_default((char *)"ttytype", term);
  }
  if ((unsigned long )term_strings[0] != (unsigned long )((void *)0)) {
    tmp___0 = term_strings[0];
  } else {
    tmp___0 = term;
  }
  {
  set_termname(tmp___0);
  }
  return;
}
}
static char_u out_buf[2048]  ;
static int out_pos  =    0;
void out_flush(void) 
{ 
  int len___0 ;

  {
  if (out_pos != 0) {
    {
    len___0 = out_pos;
    out_pos = 0;
    ui_write(out_buf, len___0);
    }
  }
  return;
}
}
void out_char(unsigned int c ) 
{ 
  int tmp ;

  {
  if (c == 10U) {
    {
    out_char((unsigned int )'\r');
    }
  }
  tmp = out_pos;
  out_pos ++;
  out_buf[tmp] = (char_u )c;
  if (out_pos >= 2047) {
    {
    out_flush();
    }
  } else { //Added block
  if (p_wd) {
    {
    out_flush();
    }
  }
  }
  return;
}
}
static void out_char_nf(unsigned int c ) ;
static void out_char_nf(unsigned int c ) 
{ 
  int tmp ;

  {
  if (c == 10U) {
    {
    out_char_nf((unsigned int )'\r');
    }
  }
  tmp = out_pos;
  out_pos ++;
  out_buf[tmp] = (char_u )c;
  if (out_pos >= 2047) {
    {
    out_flush();
    }
  }
  return;
}
}
void out_str_nf(char_u *s ) 
{ 
  char_u *tmp ;

  {
  if (out_pos > 2027) {
    {
    out_flush();
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    out_char_nf((unsigned int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  if (p_wd) {
    {
    out_flush();
    }
  }
  return;
}
}
void out_str(char_u *s ) 
{ 


  {
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    if (*s) {
      if (out_pos > 2027) {
        {
        out_flush();
        }
      }
      {
      tputs((char const   *)((char *)s), 1, (int (*)(int  ))((int (*)())(& out_char_nf)));
      }
      if (p_wd) {
        {
        out_flush();
        }
      }
    }
  }
  return;
}
}
void term_windgoto(int row , int col ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[24]), col, row);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_cursor_right(int i___0 ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[26]), 0, i___0);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_append_lines(int line_count ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[3]), 0, line_count);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_delete_lines(int line_count ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[5]), 0, line_count);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_set_winpos(int x___0 , int y ) 
{ 
  char *tmp ;

  {
  if (x___0 < 0) {
    x___0 = 0;
  }
  if (y < 0) {
    y = 0;
  }
  {
  tmp = tgoto((char const   *)((char *)term_strings[47]), y, x___0);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_set_winsize(int width , int height ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[48]), height, width);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_fg_color(int n ) 
{ 


  {
  if (*(term_strings[39])) {
    {
    term_color(term_strings[39], n);
    }
  } else { //Added block
  if (*(term_strings[35])) {
    {
    term_color(term_strings[35], n);
    }
  }
  }
  return;
}
}
void term_bg_color(int n ) 
{ 


  {
  if (*(term_strings[40])) {
    {
    term_color(term_strings[40], n);
    }
  } else { //Added block
  if (*(term_strings[36])) {
    {
    term_color(term_strings[36], n);
    }
  }
  }
  return;
}
}
static void term_color(char_u *s , int n ) 
{ 
  int i___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  i___0 = 2;
  if (n > 7) {
    {
    tmp___3 = atoi((char const   *)((char *)term_strings[34]));
    }
    if (tmp___3 == 16) {
      if ((int )*(s + 0) == 27) {
        if ((int )*(s + 1) == 91) {
          goto _L___0;
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: 
      if ((int )*(s + 0) == 155) {
        i___0 = 1;
        if (i___0 == 1) {
          _L___0: 
          if ((int )*(s + i___0) != 0) {
            {
            tmp___4 = strcmp((char const   *)((char *)((s + i___0) + 1)), (char const   *)((char *)"%p1%dm"));
            }
            if (tmp___4 == 0) {
              goto _L;
            } else {
              {
              tmp___5 = strcmp((char const   *)((char *)((s + i___0) + 1)), (char const   *)((char *)"%dm"));
              }
              if (tmp___5 == 0) {
                _L: 
                if ((int )*(s + i___0) == 51) {
                  if (i___0 == 2) {
                    tmp = "\033[9%p1%dm";
                  } else {
                    tmp = "\2339%p1%dm";
                  }
                  {
                  tmp___0 = tgoto(tmp, 0, n - 8);
                  out_str((char_u *)tmp___0);
                  }
                  return;
                }
                if ((int )*(s + i___0) == 52) {
                  if (i___0 == 2) {
                    tmp___1 = "\033[10%p1%dm";
                  } else {
                    tmp___1 = "\23310%p1%dm";
                  }
                  {
                  tmp___2 = tgoto(tmp___1, 0, n - 8);
                  out_str((char_u *)tmp___2);
                  }
                  return;
                }
              }
            }
          }
        }
      }
      }
    }
  }
  {
  tmp___6 = tgoto((char const   *)((char *)s), 0, n);
  out_str((char_u *)tmp___6);
  }
  return;
}
}
void term_settitle(char_u *title ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[45]), 0, 0);
  out_str((char_u *)tmp);
  out_str_nf(title);
  out_str(term_strings[46]);
  out_flush();
  }
  return;
}
}
void ttest(int pairs ) 
{ 
  char *t ;

  {
  {
  t = (char *)((void *)0);
  check_options();
  }
  if ((int )*(term_strings[7]) == 0) {
    t = (char *)"cl";
  }
  if ((int )*(term_strings[24]) == 0) {
    t = (char *)"cm";
  }
  if ((unsigned long )t != (unsigned long )((void *)0)) {
    {
    emsg2((char_u *)"terminal capability %s required", (char_u *)t);
    }
  }
  if ((int )*(term_strings[6]) != 0) {
    scroll_region = 1;
  } else {
    scroll_region = 0;
  }
  if (pairs) {
    if ((int )*(term_strings[14]) == 0) {
      term_strings[38] = empty_option;
      term_strings[16] = term_strings[38];
      term_strings[15] = term_strings[16];
      term_strings[14] = term_strings[15];
    }
    if ((int )*(term_strings[18]) == 0) {
      term_strings[17] = empty_option;
      term_strings[18] = term_strings[17];
    } else { //Added block
    if ((int )*(term_strings[17]) == 0) {
      term_strings[17] = empty_option;
      term_strings[18] = term_strings[17];
    }
    }
    if ((int )*(term_strings[22]) == 0) {
      term_strings[21] = empty_option;
      term_strings[22] = term_strings[21];
    } else { //Added block
    if ((int )*(term_strings[21]) == 0) {
      term_strings[21] = empty_option;
      term_strings[22] = term_strings[21];
    }
    }
    if ((int )*(term_strings[19]) == 0) {
      term_strings[20] = empty_option;
      term_strings[19] = term_strings[20];
    } else { //Added block
    if ((int )*(term_strings[20]) == 0) {
      term_strings[20] = empty_option;
      term_strings[19] = term_strings[20];
    }
    }
    if ((int )*(term_strings[12]) == 0) {
      term_strings[11] = empty_option;
    }
    if ((int )*(term_strings[14]) == 0) {
      term_strings[14] = term_strings[17];
      term_strings[15] = term_strings[18];
      term_strings[16] = term_strings[18];
    }
    if ((int )*(term_strings[18]) == 0) {
      term_strings[17] = term_strings[14];
      if ((int )*(term_strings[15]) == 0) {
        term_strings[18] = term_strings[16];
      } else {
        term_strings[18] = term_strings[15];
      }
    }
    if ((int )*(term_strings[19]) == 0) {
      term_strings[20] = term_strings[14];
      if ((int )*(term_strings[15]) == 0) {
        term_strings[19] = term_strings[16];
      } else {
        term_strings[19] = term_strings[15];
      }
    }
    if ((int )*(term_strings[36]) == 0) {
      term_strings[36] = empty_option;
      term_strings[35] = empty_option;
    } else { //Added block
    if ((int )*(term_strings[35]) == 0) {
      term_strings[36] = empty_option;
      term_strings[35] = empty_option;
    }
    }
    if ((int )*(term_strings[40]) == 0) {
      term_strings[40] = empty_option;
      term_strings[39] = empty_option;
    } else { //Added block
    if ((int )*(term_strings[39]) == 0) {
      term_strings[40] = empty_option;
      term_strings[39] = empty_option;
    }
    }
    if ((int )*(term_strings[36]) == 0) {
      if ((int )*(term_strings[40]) == 0) {
        term_strings[34] = empty_option;
      }
    }
    p_wiv = (int )*(term_strings[37]) != 0;
  }
  need_gather = 1;
  return;
}
}
static int get_bytes_from_buf(char_u *buf___3 , char_u *bytes , int num_bytes ) 
{ 
  int len___0 ;
  int i___0 ;
  char_u c ;
  int tmp ;
  int tmp___0 ;

  {
  len___0 = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < num_bytes)) {
      goto while_break;
    }
    tmp = len___0;
    len___0 ++;
    c = *(buf___3 + tmp);
    if ((int )c == 0) {
      return (-1);
    }
    if ((int )c == 128) {
      if ((int )*(buf___3 + len___0) == 0) {
        return (-1);
      } else { //Added block
      if ((int )*(buf___3 + (len___0 + 1)) == 0) {
        return (-1);
      }
      }
      tmp___0 = len___0;
      len___0 ++;
      if ((int )*(buf___3 + tmp___0) == 255) {
        c = (char_u )'\000';
      }
      len___0 ++;
    }
    *(bytes + i___0) = c;
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (len___0);
}
}
static int old_Rows  =    0;
void check_winsize(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (Columns < 12L) {
    Columns = 12L;
  }
  {
  tmp___0 = min_rows();
  }
  if (Rows < (long )tmp___0) {
    {
    tmp = min_rows();
    Rows = (long )tmp;
    }
  }
  if ((long )old_Rows != Rows) {
    {
    old_Rows = (int )Rows;
    screen_new_rows();
    }
  }
  return;
}
}
static int busy  =    0;
void set_winsize(int width , int height , int mustset ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (busy) {
    return;
  }
  if (width < 0) {
    return;
  } else { //Added block
  if (height < 0) {
    return;
  }
  }
  if (State == 1537) {
    State = 2048;
    return;
  } else { //Added block
  if (State == 2048) {
    State = 2048;
    return;
  }
  }
  busy ++;
  if (State != 1792) {
    if (State != 2560) {
      if (State != 3072) {
        {
        screenclear();
        }
      } else {
        {
        screen_start();
        }
      }
    } else {
      {
      screen_start();
      }
    }
  } else {
    {
    screen_start();
    }
  }
  if (mustset) {
    {
    Rows = (long )height;
    Columns = (long )width;
    check_winsize();
    ui_set_winsize();
    }
  } else {
    {
    tmp = ui_get_winsize();
    }
    if (tmp == 0) {
      if (height != 0) {
        {
        Rows = (long )height;
        Columns = (long )width;
        check_winsize();
        ui_set_winsize();
        }
      } else {
        {
        check_winsize();
        }
      }
    } else {
      {
      check_winsize();
      }
    }
  }
  if (starting != 2) {
    {
    maketitle();
    changed_line_abv_curs();
    invalidate_botline();
    }
    if (State == 1792) {
      {
      screenalloc(0);
      repeat_message();
      }
    } else { //Added block
    if (State == 2560) {
      {
      screenalloc(0);
      repeat_message();
      }
    } else { //Added block
    if (State == 3072) {
      {
      screenalloc(0);
      repeat_message();
      }
    } else { //Added block
    if (exmode_active) {
      {
      screenalloc(0);
      repeat_message();
      }
    } else { //Added block
    if (State == 8) {
      {
      update_screen(40);
      redrawcmdline();
      }
    } else {
      {
      update_topline();
      update_screen(40);
      tmp___0 = redrawing();
      }
      if (tmp___0) {
        {
        setcursor();
        }
      }
    }
    }
    }
    }
    }
    {
    cursor_on();
    }
  }
  {
  out_flush();
  busy --;
  }
  return;
}
}
static int cur_tmode  =    0;
void settmode(int tmode ) 
{ 


  {
  if (full_screen) {
    if (exmode_active) {
      tmode = 0;
    }
    if (tmode != 0) {
      goto _L;
    } else { //Added block
    if (cur_tmode != 0) {
      _L: 
      if (tmode != 2) {
        {
        mch_setmouse(0);
        }
      }
      {
      out_flush();
      mch_settmode(tmode);
      cur_tmode = tmode;
      }
      if (tmode == 2) {
        {
        setmouse();
        }
      }
      {
      out_flush();
      }
    }
    }
    if (cur_tmode == 2) {
      if (need_get_crv) {
        if (*(term_strings[49])) {
          {
          out_str(term_strings[49]);
          need_get_crv = 0;
          vpeekc();
          }
        }
      }
    }
  }
  return;
}
}
void starttermcap(void) 
{ 


  {
  {
  screen_stop_highlight();
  }
  if (full_screen) {
    if (! termcap_active) {
      {
      out_str(term_strings[30]);
      out_str(term_strings[28]);
      out_flush();
      termcap_active = 1;
      screen_start();
      }
    }
  }
  return;
}
}
void stoptermcap(void) 
{ 


  {
  {
  screen_stop_highlight();
  reset_cterm_colors();
  }
  if (termcap_active) {
    {
    out_str(term_strings[29]);
    out_flush();
    termcap_active = 0;
    cursor_on();
    out_str(term_strings[31]);
    screen_start();
    out_flush();
    }
  }
  return;
}
}
int swapping_screen(void) 
{ 


  {
  return ((int )*(term_strings[30]) != 0);
}
}
void setmouse(void) 
{ 
  int checkfor ;
  int tmp ;

  {
  if ((int )*p_mouse == 0) {
    return;
  } else { //Added block
  if (has_mouse_termcode == 0) {
    return;
  }
  }
  if (cur_tmode != 2) {
    {
    mch_setmouse(0);
    }
    return;
  }
  if (VIsual_active) {
    checkfor = 'v';
  } else { //Added block
  if (State == 1537) {
    checkfor = 'r';
  } else { //Added block
  if (State == 1792) {
    checkfor = 'r';
  } else { //Added block
  if (State == 2048) {
    checkfor = 'r';
  } else { //Added block
  if (State & 16) {
    checkfor = 'i';
  } else { //Added block
  if (State & 8) {
    checkfor = 'c';
  } else { //Added block
  if (State == 3072) {
    checkfor = ' ';
  } else { //Added block
  if (State == 2560) {
    checkfor = ' ';
  } else {
    checkfor = 'n';
  }
  }
  }
  }
  }
  }
  }
  }
  {
  tmp = mouse_has(checkfor);
  }
  if (tmp) {
    {
    mch_setmouse(1);
    }
  } else {
    {
    mch_setmouse(0);
    }
  }
  return;
}
}
int mouse_has(int c ) 
{ 
  char_u *p___0 ;
  char_u *tmp ;

  {
  p___0 = p_mouse;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    if ((int )*p___0 == 97) {
      goto case_97;
    }
    if ((int )*p___0 == 104) {
      goto case_104;
    }
    goto switch_default;
    case_97: /* CIL Label */ 
    {
    tmp = vim_strchr((char_u *)"nvich", c);
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      return (1);
    }
    goto switch_break;
    case_104: /* CIL Label */ 
    if (c != 114) {
      if (curbuf->b_help) {
        return (1);
      }
    }
    goto switch_break;
    switch_default: /* CIL Label */ 
    if (c == (int )*p___0) {
      return (1);
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int mouse_model_popup(void) 
{ 


  {
  return ((int )*(p_mousem + 0) == 112);
}
}
void scroll_start(void) 
{ 


  {
  if ((int )*(term_strings[13]) != 0) {
    {
    out_str(term_strings[13]);
    out_str(term_strings[12]);
    screen_start();
    }
  }
  return;
}
}
static int cursor_is_off  =    0;
void cursor_on(void) 
{ 


  {
  if (cursor_is_off) {
    {
    out_str(term_strings[12]);
    cursor_is_off = 0;
    }
  }
  return;
}
}
void cursor_off(void) 
{ 


  {
  if (full_screen) {
    if (! cursor_is_off) {
      {
      out_str(term_strings[11]);
      }
    }
    cursor_is_off = 1;
  }
  return;
}
}
void scroll_region_set(WIN *wp , int off___0 ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[6]), (wp->w_winpos + wp->w_height) - 1,
              wp->w_winpos + off___0);
  out_str((char_u *)tmp);
  screen_start();
  }
  return;
}
}
void scroll_region_reset(void) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[6]), (int )Rows - 1, 0);
  out_str((char_u *)tmp);
  screen_start();
  }
  return;
}
}
struct termcode *termcodes  =    (struct termcode *)((void *)0);
static int tc_max_len  =    0;
static int tc_len  =    0;
void clear_termcodes(void) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (tc_len > 0)) {
      goto while_break;
    }
    {
    tc_len --;
    vim_free((void *)(termcodes + tc_len)->code);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)termcodes);
  termcodes = (struct termcode *)((void *)0);
  tc_max_len = 0;
  BC = (char *)empty_option;
  UP = (char *)empty_option;
  PC = (char )'\000';
  ospeed = (short)0;
  need_gather = 1;
  }
  return;
}
}
void add_termcode(char_u *name___1 , char_u *string___0 , int use_8bit ) 
{ 
  struct termcode *new_tc ;
  int i___0 ;
  int j ;
  char_u *s ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;

  {
  if ((unsigned long )string___0 == (unsigned long )((void *)0)) {
    {
    del_termcode(name___1);
    }
    return;
  } else { //Added block
  if ((int )*string___0 == 0) {
    {
    del_termcode(name___1);
    }
    return;
  }
  }
  {
  s = vim_strsave(string___0);
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return;
  }
  if (use_8bit) {
    {
    tmp___1 = term_7to8bit(string___0);
    }
    if (tmp___1 != 0) {
      {
      tmp = strlen((char const   *)((char *)s));
      memmove((void *)((char *)s), (void const   *)((char *)(s + 1)), tmp);
      tmp___0 = term_7to8bit(string___0);
      *(s + 0) = (char_u )tmp___0;
      }
    }
  }
  need_gather = 1;
  if (tc_len == tc_max_len) {
    {
    tc_max_len += 20;
    tmp___2 = alloc((unsigned int )((unsigned long )tc_max_len * sizeof(struct termcode )));
    new_tc = (struct termcode *)tmp___2;
    }
    if ((unsigned long )new_tc == (unsigned long )((void *)0)) {
      tc_max_len -= 20;
      return;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (i___0 < tc_len)) {
        goto while_break;
      }
      *(new_tc + i___0) = *(termcodes + i___0);
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    vim_free((void *)termcodes);
    termcodes = new_tc;
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break___0;
    }
    if ((int )(termcodes + i___0)->name[0] < (int )*(name___1 + 0)) {
      goto __Cont;
    }
    if ((int )(termcodes + i___0)->name[0] == (int )*(name___1 + 0)) {
      if ((int )(termcodes + i___0)->name[1] < (int )*(name___1 + 1)) {
        goto __Cont;
      }
      if ((int )(termcodes + i___0)->name[1] == (int )*(name___1 + 1)) {
        {
        vim_free((void *)(termcodes + i___0)->code);
        tc_len --;
        }
        goto while_break___0;
      }
    }
    j = tc_len;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (j > i___0)) {
        goto while_break___1;
      }
      *(termcodes + j) = *(termcodes + (j - 1));
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
    goto while_break___0;
    __Cont: 
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  (termcodes + i___0)->name[0] = *(name___1 + 0);
  (termcodes + i___0)->name[1] = *(name___1 + 1);
  (termcodes + i___0)->code = s;
  tmp___3 = strlen((char const   *)((char *)s));
  (termcodes + i___0)->len = (int )tmp___3;
  tc_len ++;
  }
  return;
}
}
char_u *find_termcode(char_u *name___1 ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break;
    }
    if ((int )(termcodes + i___0)->name[0] == (int )*(name___1 + 0)) {
      if ((int )(termcodes + i___0)->name[1] == (int )*(name___1 + 1)) {
        return ((termcodes + i___0)->code);
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
char_u *get_termcode(int i___0 ) 
{ 


  {
  if (i___0 >= tc_len) {
    return ((char_u *)((void *)0));
  }
  return (& (termcodes + i___0)->name[0]);
}
}
void del_termcode(char_u *name___1 ) 
{ 
  int i___0 ;

  {
  if ((unsigned long )termcodes == (unsigned long )((void *)0)) {
    return;
  }
  need_gather = 1;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break;
    }
    if ((int )(termcodes + i___0)->name[0] == (int )*(name___1 + 0)) {
      if ((int )(termcodes + i___0)->name[1] == (int )*(name___1 + 1)) {
        {
        vim_free((void *)(termcodes + i___0)->code);
        tc_len --;
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! (i___0 < tc_len)) {
            goto while_break___0;
          }
          *(termcodes + i___0) = *(termcodes + (i___0 + 1));
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        return;
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static int held_button  =    3;
static int orig_num_clicks  =    1;
static int orig_mouse_code  =    0;
static int orig_mouse_col  =    0;
static int orig_mouse_row  =    0;
static linenr_t orig_topline  =    (linenr_t )0;
static struct timeval orig_mouse_time  =    {(__time_t )0, (__suseconds_t )0};
int check_termcode(int max_offset , char_u *buf___3 , int buflen ) 
{ 
  char_u *tp ;
  char_u *p___0 ;
  int slen ;
  int len___0 ;
  int offset ;
  char_u key_name[2] ;
  int new_slen ;
  int extra ;
  char_u string___0[7] ;
  int i___0 ;
  int j ;
  char_u bytes[3] ;
  int num_bytes ;
  int mouse_code___0 ;
  int modifiers ;
  int is_click ;
  int is_drag ;
  int wheel_code ;
  int current_button ;
  struct timeval mouse_time ;
  long timediff ;
  int cpo_koffset ;
  char_u *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
  slen = 0;
  mouse_code___0 = 0;
  wheel_code = 0;
  tmp = vim_strchr(p_cpo, 'K');
  cpo_koffset = (unsigned long )tmp != (unsigned long )((void *)0);
  }
  if (need_gather) {
    {
    gather_termleader();
    }
  }
  offset = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (offset < max_offset)) {
      goto while_break;
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      if (offset >= typelen) {
        goto while_break;
      }
      tp = (typebuf + typeoff) + offset;
      len___0 = typelen - offset;
    } else {
      if (offset >= buflen) {
        goto while_break;
      }
      tp = buf___3 + offset;
      len___0 = buflen - offset;
    }
    if ((int )*tp == 128) {
      offset += 2;
      goto __Cont;
    }
    i___0 = (int )*tp;
    p___0 = termleader;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (*p___0) {
        if (! ((int )*p___0 != i___0)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if ((int )*p___0 == 0) {
      goto __Cont;
    }
    if ((int )*tp == 27) {
      if (! p_ek) {
        if (State & 16) {
          goto __Cont;
        }
      }
    }
    new_slen = 0;
    key_name[0] = (char_u )'\000';
    i___0 = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i___0 < tc_len)) {
        goto while_break___1;
      }
      slen = (termcodes + i___0)->len;
      if (cpo_koffset) {
        if (offset) {
          if (len___0 < slen) {
            goto __Cont___0;
          }
        }
      }
      if (slen > len___0) {
        tmp___2 = len___0;
      } else {
        tmp___2 = slen;
      }
      {
      tmp___3 = strncmp((char const   *)((char *)(termcodes + i___0)->code), (char const   *)((char *)tp),
                        (size_t )tmp___2);
      }
      if (tmp___3 == 0) {
        if (len___0 < slen) {
          return (-1);
        }
        if ((int )(termcodes + i___0)->name[0] == 75) {
          {
          tmp___1 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___1 + (int )(termcodes + i___0)->name[1]) & 2048) {
            j = i___0 + 1;
            {
            while (1) {
              while_continue___2: /* CIL Label */ ;
              if (! (j < tc_len)) {
                goto while_break___2;
              }
              if ((termcodes + j)->len == slen) {
                {
                tmp___0 = strncmp((char const   *)((char *)(termcodes + i___0)->code),
                                  (char const   *)((char *)(termcodes + j)->code),
                                  (size_t )slen);
                }
                if (tmp___0 == 0) {
                  i___0 = j;
                  goto while_break___2;
                }
              }
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        key_name[0] = (termcodes + i___0)->name[0];
        key_name[1] = (termcodes + i___0)->name[1];
        goto while_break___1;
      }
      __Cont___0: 
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    if ((int )key_name[0] == 0) {
      if ((int )*(term_strings[49]) != 0) {
        if ((int )*(tp + 0) == 27) {
          if ((int )*(tp + 1) == 91) {
            if (len___0 >= 3) {
              goto _L;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: 
        if ((int )*(tp + 0) == 155) {
          if (len___0 >= 2) {
            _L: 
            j = 0;
            extra = 0;
            i___0 = 2 + ((int )*(tp + 0) != 155);
            {
            while (1) {
              while_continue___3: /* CIL Label */ ;
              if (i___0 < len___0) {
                {
                tmp___4 = __ctype_b_loc();
                }
                if (! ((int const   )*(*tmp___4 + (int )*(tp + i___0)) & 2048)) {
                  if (! ((int )*(tp + i___0) == 59)) {
                    goto while_break___3;
                  }
                }
              } else {
                goto while_break___3;
              }
              if ((int )*(tp + i___0) == 59) {
                j ++;
                if (j == 1) {
                  {
                  extra = atoi((char const   *)(((char *)tp + i___0) + 1));
                  }
                }
              }
              i___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            if (i___0 == len___0) {
              return (-1);
            }
            if (i___0 > 2 + ((int )*(tp + 0) != 155)) {
              if ((int )*(tp + i___0) == 99) {
                if ((int )*(tp + (1 + ((int )*(tp + 0) != 155))) == 62) {
                  if (j == 2) {
                    if (extra >= 95) {
                      {
                      set_option_value((char_u *)"ttymouse", 0L, (char_u *)"xterm2");
                      }
                    }
                  }
                }
                key_name[0] = (char_u )253;
                key_name[1] = (char_u )51;
                slen = i___0 + 1;
              } else {
                goto __Cont;
              }
            } else {
              goto __Cont;
            }
          } else {
            goto __Cont;
          }
        } else {
          goto __Cont;
        }
        }
      } else {
        goto __Cont;
      }
    }
    if ((int )key_name[0] == 251) {
      is_drag = 0;
      is_click = is_drag;
      if ((int )key_name[0] == 251) {
        {
        num_bytes = get_bytes_from_buf(tp + slen, bytes, 3);
        }
        if (num_bytes == -1) {
          return (-1);
        }
        mouse_code___0 = (int )bytes[0];
        mouse_col = ((int )bytes[1] - 32) - 1;
        mouse_row = ((int )bytes[2] - 32) - 1;
        slen += num_bytes;
        if (mouse_code___0 >= 96) {
          wheel_code = mouse_code___0;
        } else {
          {
          tmp___5 = use_xterm_mouse();
          }
          if (tmp___5 > 1) {
            if (mouse_code___0 & 64) {
              mouse_code___0 |= 67;
            }
          } else { //Added block
          if (! ((mouse_code___0 & 67) & -4)) {
            if ((mouse_code___0 & 3) == 3) {
              {
              stop_xterm_trace();
              }
            } else {
              {
              start_xterm_trace(mouse_code___0);
              }
            }
          }
          }
        }
      }
      current_button = mouse_code___0 & 3;
      if (current_button == 3) {
        if ((mouse_code___0 & 67) == 67) {
          is_drag = 1;
        }
        current_button = held_button;
      } else { //Added block
      if (wheel_code == 0) {
        {
        gettimeofday((struct timeval * __restrict  )(& mouse_time), (__timezone_ptr_t )((void *)0));
        timediff = (mouse_time.tv_usec - orig_mouse_time.tv_usec) / 1000L;
        }
        if (timediff < 0L) {
          (orig_mouse_time.tv_sec) --;
        }
        timediff += (mouse_time.tv_sec - orig_mouse_time.tv_sec) * 1000L;
        orig_mouse_time = mouse_time;
        if (mouse_code___0 == orig_mouse_code) {
          if (timediff < p_mouset) {
            if (orig_num_clicks != 4) {
              if (orig_mouse_col == mouse_col) {
                if (orig_mouse_row == mouse_row) {
                  if (orig_topline == curwin->w_topline) {
                    orig_num_clicks ++;
                  } else {
                    orig_num_clicks = 1;
                  }
                } else {
                  orig_num_clicks = 1;
                }
              } else {
                orig_num_clicks = 1;
              }
            } else {
              orig_num_clicks = 1;
            }
          } else {
            orig_num_clicks = 1;
          }
        } else {
          orig_num_clicks = 1;
        }
        orig_mouse_col = mouse_col;
        orig_mouse_row = mouse_row;
        orig_topline = curwin->w_topline;
        is_click = 1;
        orig_mouse_code = mouse_code___0;
      }
      }
      if (! is_drag) {
        held_button = mouse_code___0 & 3;
      }
      modifiers = 0;
      if (orig_mouse_code & 4) {
        modifiers |= 2;
      }
      if (orig_mouse_code & 16) {
        modifiers |= 4;
      }
      if (orig_mouse_code & 8) {
        modifiers |= 8;
      }
      if (orig_num_clicks == 2) {
        modifiers |= 16;
      } else { //Added block
      if (orig_num_clicks == 3) {
        modifiers |= 32;
      } else { //Added block
      if (orig_num_clicks == 4) {
        modifiers |= 64;
      }
      }
      }
      if (modifiers != 0) {
        tmp___6 = new_slen;
        new_slen ++;
        string___0[tmp___6] = (char_u )128;
        tmp___7 = new_slen;
        new_slen ++;
        string___0[tmp___7] = (char_u )252;
        tmp___8 = new_slen;
        new_slen ++;
        string___0[tmp___8] = (char_u )modifiers;
      }
      key_name[0] = (char_u )253;
      if (wheel_code != 0) {
        if (wheel_code & 1) {
          key_name[1] = (char_u )68;
        } else {
          key_name[1] = (char_u )67;
        }
      } else {
        {
        tmp___9 = get_pseudo_mouse_code(current_button, is_click, is_drag);
        key_name[1] = (char_u )tmp___9;
        }
      }
    }
    if ((int )key_name[1] == 0) {
      tmp___10 = new_slen;
      new_slen ++;
      string___0[tmp___10] = key_name[0];
    } else {
      tmp___11 = new_slen;
      new_slen ++;
      string___0[tmp___11] = (char_u )128;
      tmp___12 = new_slen;
      new_slen ++;
      string___0[tmp___12] = key_name[0];
      tmp___13 = new_slen;
      new_slen ++;
      string___0[tmp___13] = key_name[1];
    }
    string___0[new_slen] = (char_u )'\000';
    extra = new_slen - slen;
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      if (extra < 0) {
        {
        del_typebuf(- extra, offset);
        }
      } else { //Added block
      if (extra > 0) {
        {
        ins_typebuf(string___0 + slen, 0, offset, 0);
        }
      }
      }
      {
      memmove((void *)((char *)((typebuf + typeoff) + offset)), (void const   *)((char *)(string___0)),
              (size_t )new_slen);
      }
    } else {
      if (extra < 0) {
        {
        memmove((void *)((char *)(buf___3 + offset)), (void const   *)((char *)((buf___3 + offset) - extra)),
                (size_t )((buflen + offset) + extra));
        }
      } else { //Added block
      if (extra > 0) {
        {
        memmove((void *)((char *)((buf___3 + offset) + extra)), (void const   *)((char *)(buf___3 + offset)),
                (size_t )(buflen - offset));
        }
      }
      }
      {
      memmove((void *)((char *)(buf___3 + offset)), (void const   *)((char *)(string___0)),
              (size_t )new_slen);
      }
    }
    return ((len___0 + extra) + offset);
    __Cont: 
    offset ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
char_u *replace_termcodes(char_u *from , char_u **bufp , int from_part , int do_lt ) 
{ 
  int i___0 ;
  int slen ;
  int key ;
  int dlen ;
  char_u *src ;
  int do_backslash ;
  int do_special ;
  int do_key_code ;
  char_u *result___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char_u *tmp___17 ;
  char_u *tmp___18 ;

  {
  {
  dlen = 0;
  tmp = vim_strchr(p_cpo, 'B');
  do_backslash = (unsigned long )tmp == (unsigned long )((void *)0);
  tmp___0 = vim_strchr(p_cpo, '<');
  do_special = (unsigned long )tmp___0 == (unsigned long )((void *)0);
  tmp___1 = vim_strchr(p_cpo, 'k');
  do_key_code = (unsigned long )tmp___1 == (unsigned long )((void *)0);
  tmp___2 = strlen((char const   *)((char *)from));
  result___0 = alloc((unsigned int )tmp___2 * 6U + 1U);
  }
  if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
    *bufp = (char_u *)((void *)0);
    return (from);
  }
  src = from;
  if (from_part) {
    if ((int )*(src + 0) == 35) {
      {
      tmp___7 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___7 + (int )*(src + 1)) & 2048) {
        tmp___3 = dlen;
        dlen ++;
        *(result___0 + tmp___3) = (char_u )128;
        tmp___4 = dlen;
        dlen ++;
        *(result___0 + tmp___4) = (char_u )'k';
        if ((int )*(src + 1) == 48) {
          tmp___5 = dlen;
          dlen ++;
          *(result___0 + tmp___5) = (char_u )';';
        } else {
          tmp___6 = dlen;
          dlen ++;
          *(result___0 + tmp___6) = *(src + 1);
        }
        src += 2;
      }
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((int )*src != 0)) {
      goto while_break;
    }
    if (do_special) {
      if (do_lt) {
        goto _L;
      } else {
        {
        tmp___8 = strncmp((char const   *)((char *)src), (char const   *)((char *)"<lt>"),
                          (size_t )4);
        }
        if (tmp___8) {
          _L: 
          {
          slen = trans_special(& src, result___0 + dlen, 1);
          }
          if (slen) {
            dlen += slen;
            goto while_continue;
          }
        }
      }
    }
    if (do_key_code) {
      {
      i___0 = find_term_bykeys(src);
      }
      if (i___0 >= 0) {
        tmp___9 = dlen;
        dlen ++;
        *(result___0 + tmp___9) = (char_u )128;
        tmp___10 = dlen;
        dlen ++;
        *(result___0 + tmp___10) = (termcodes + i___0)->name[0];
        tmp___11 = dlen;
        dlen ++;
        *(result___0 + tmp___11) = (termcodes + i___0)->name[1];
        src += (termcodes + i___0)->len;
        goto while_continue;
      }
    }
    if ((int )*src == 128) {
      tmp___12 = dlen;
      dlen ++;
      *(result___0 + tmp___12) = (char_u )128;
      tmp___13 = dlen;
      dlen ++;
      *(result___0 + tmp___13) = (char_u )254;
      tmp___14 = dlen;
      dlen ++;
      *(result___0 + tmp___14) = (char_u )'X';
      src ++;
      goto while_continue;
    }
    key = (int )*src;
    if (key == 22) {
      goto _L___0;
    } else { //Added block
    if (do_backslash) {
      if (key == 92) {
        _L___0: 
        src ++;
        if ((int )*src == 0) {
          if (from_part) {
            tmp___15 = dlen;
            dlen ++;
            *(result___0 + tmp___15) = (char_u )key;
          }
          goto while_break;
        }
      }
    }
    }
    tmp___16 = dlen;
    dlen ++;
    tmp___17 = src;
    src ++;
    *(result___0 + tmp___16) = *tmp___17;
  }
  while_break: /* CIL Label */ ;
  }
  {
  *(result___0 + dlen) = (char_u )'\000';
  tmp___18 = vim_strsave(result___0);
  *bufp = tmp___18;
  }
  if ((unsigned long )tmp___18 != (unsigned long )((void *)0)) {
    from = *bufp;
  }
  {
  vim_free((void *)result___0);
  }
  return (from);
}
}
int find_term_bykeys(char_u *src ) 
{ 
  int i___0 ;
  int slen ;
  int tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break;
    }
    slen = (termcodes + i___0)->len;
    if (slen > 1) {
      {
      tmp = strncmp((char const   *)((char *)(termcodes + i___0)->code), (char const   *)((char *)src),
                    (size_t )slen);
      }
      if (tmp == 0) {
        return (i___0);
      }
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static void gather_termleader(void) 
{ 
  int i___0 ;
  int len___0 ;
  int tmp ;
  char_u *tmp___0 ;

  {
  len___0 = 0;
  termleader[len___0] = (char_u )'\000';
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break;
    }
    {
    tmp___0 = vim_strchr(termleader, (int )*((termcodes + i___0)->code + 0));
    }
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      tmp = len___0;
      len___0 ++;
      termleader[tmp] = *((termcodes + i___0)->code + 0);
      termleader[len___0] = (char_u )'\000';
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  need_gather = 0;
  return;
}
}
void show_termcodes(void) 
{ 
  int col ;
  int *items ;
  int item_count ;
  int run ;
  int row ;
  int rows ;
  int cols ;
  int i___0 ;
  int len___0 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if (tc_len == 0) {
    return;
  }
  {
  tmp = alloc((unsigned int )(sizeof(int ) * (unsigned long )tc_len));
  items = (int *)tmp;
  }
  if ((unsigned long )items == (unsigned long )((void *)0)) {
    return;
  }
  {
  msg_puts_title((char_u *)"\n--- Terminal keys ---");
  run = 1;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (run <= 2) {
      if (! (! got_int)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    item_count = 0;
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < tc_len)) {
        goto while_break___0;
      }
      {
      len___0 = show_one_termcode((termcodes + i___0)->name, (termcodes + i___0)->code,
                                  0);
      }
      if (len___0 <= 25) {
        if (run == 1) {
          tmp___0 = item_count;
          item_count ++;
          *(items + tmp___0) = i___0;
        } else {
          goto _L;
        }
      } else { //Added block
      _L: 
      if (len___0 > 25) {
        if (run == 2) {
          tmp___0 = item_count;
          item_count ++;
          *(items + tmp___0) = i___0;
        }
      }
      }
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (run == 1) {
      cols = (int )((Columns + 2L) / 27L);
      if (cols == 0) {
        cols = 1;
      }
      rows = ((item_count + cols) - 1) / cols;
    } else {
      rows = item_count;
    }
    row = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (row < rows) {
        if (! (! got_int)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      {
      msg_putchar('\n');
      }
      if (got_int) {
        goto while_break___1;
      }
      col = 0;
      i___0 = row;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (i___0 < item_count)) {
          goto while_break___2;
        }
        {
        msg_col = col;
        show_one_termcode((termcodes + *(items + i___0))->name, (termcodes + *(items + i___0))->code,
                          1);
        col += 27;
        i___0 += rows;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      out_flush();
      ui_breakcheck();
      row ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    run ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  vim_free((void *)items);
  }
  return;
}
}
int show_one_termcode(char_u *name___1 , char_u *code , int printit ) 
{ 
  char_u *p___0 ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )*(name___1 + 0) > 126) {
    *(IObuff + 0) = (char_u )' ';
    *(IObuff + 1) = (char_u )' ';
    *(IObuff + 2) = (char_u )' ';
    *(IObuff + 3) = (char_u )' ';
  } else {
    *(IObuff + 0) = (char_u )'t';
    *(IObuff + 1) = (char_u )'_';
    *(IObuff + 2) = *(name___1 + 0);
    *(IObuff + 3) = *(name___1 + 1);
  }
  {
  *(IObuff + 4) = (char_u )' ';
  p___0 = get_special_key_name((int )*(name___1 + 0) + ((int )*(name___1 + 1) << 8),
                               0);
  }
  if ((int )*(p___0 + 1) != 116) {
    {
    strcpy((char * __restrict  )((char *)(IObuff + 5)), (char const   * __restrict  )((char *)p___0));
    }
  } else {
    *(IObuff + 5) = (char_u )'\000';
  }
  {
  tmp = strlen((char const   *)((char *)IObuff));
  len___0 = (int )tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___0 = len___0;
    len___0 ++;
    *(IObuff + tmp___0) = (char_u )' ';
    if (! (len___0 < 17)) {
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  *(IObuff + len___0) = (char_u )'\000';
  if ((unsigned long )code == (unsigned long )((void *)0)) {
    len___0 += 4;
  } else {
    {
    tmp___1 = vim_strsize(code);
    len___0 += tmp___1;
    }
  }
  if (printit) {
    {
    msg_puts(IObuff);
    }
    if ((unsigned long )code == (unsigned long )((void *)0)) {
      {
      msg_puts((char_u *)"NULL");
      }
    } else {
      {
      msg_outtrans(code);
      }
    }
  }
  return (len___0);
}
}
char_u *translate_mapping(char_u *str___1 , int expmap ) 
{ 
  struct growarray ga ;
  int c ;
  int modifiers ;
  int cpo_bslash ;
  int cpo_special ;
  int cpo_keycode ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int i___0 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  {
  ga_init(& ga);
  ga.ga_itemsize = 1;
  ga.ga_growsize = 40;
  tmp = vim_strchr(p_cpo, 'B');
  cpo_bslash = (unsigned long )tmp != (unsigned long )((void *)0);
  tmp___0 = vim_strchr(p_cpo, '<');
  cpo_special = (unsigned long )tmp___0 != (unsigned long )((void *)0);
  tmp___1 = vim_strchr(p_cpo, 'k');
  cpo_keycode = (unsigned long )tmp___1 == (unsigned long )((void *)0);
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! *str___1) {
      goto while_break;
    }
    c = (int )*str___1;
    if (c == 128) {
      if ((int )*(str___1 + 1) != 0) {
        if ((int )*(str___1 + 2) != 0) {
          modifiers = 0;
          if ((int )*(str___1 + 1) == 252) {
            str___1 ++;
            str___1 ++;
            modifiers = (int )*str___1;
            str___1 ++;
            c = (int )*str___1;
          }
          if (cpo_special) {
            if (cpo_keycode) {
              if (c == 128) {
                if (! modifiers) {
                  i___0 = 0;
                  {
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
                    if (! (i___0 < tc_len)) {
                      goto while_break___0;
                    }
                    if ((int )(termcodes + i___0)->name[0] == (int )*(str___1 + 1)) {
                      if ((int )(termcodes + i___0)->name[1] == (int )*(str___1 + 2)) {
                        goto while_break___0;
                      }
                    }
                    i___0 ++;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                  if (i___0 < tc_len) {
                    {
                    ga_concat(& ga, (termcodes + i___0)->code);
                    str___1 += 2;
                    }
                    goto __Cont;
                  }
                }
              }
            }
          }
          if (c == 128) {
            if ((int )*(str___1 + 1) != 0) {
              if ((int )*(str___1 + 2) != 0) {
                if (expmap) {
                  if (cpo_special) {
                    {
                    ga_clear(& ga);
                    }
                    return ((char_u *)((void *)0));
                  }
                }
                if ((int )*(str___1 + 1) == 254) {
                  c = 128;
                } else {
                  if ((int )*(str___1 + 1) == 255) {
                    tmp___2 = 255 + (88 << 8);
                  } else {
                    tmp___2 = (int )*(str___1 + 1) + ((int )*(str___1 + 2) << 8);
                  }
                  c = tmp___2;
                }
                if (c == 255 + (88 << 8)) {
                  c = '\000';
                }
                str___1 += 2;
              }
            }
          }
          if (c >= 512) {
            goto _L;
          } else { //Added block
          if (modifiers) {
            _L: 
            if (expmap) {
              if (cpo_special) {
                {
                ga_clear(& ga);
                }
                return ((char_u *)((void *)0));
              }
            }
            {
            tmp___3 = get_special_key_name(c, modifiers);
            ga_concat(& ga, tmp___3);
            }
            goto __Cont;
          }
          }
        }
      }
    }
    if (c == 32) {
      goto _L___0;
    } else { //Added block
    if (c == 9) {
      goto _L___0;
    } else { //Added block
    if (c == 10) {
      goto _L___0;
    } else { //Added block
    if (c == 22) {
      goto _L___0;
    } else { //Added block
    if (c == 60) {
      if (! cpo_special) {
        goto _L___0;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: 
    if (c == 92) {
      if (! cpo_bslash) {
        _L___0: 
        if (cpo_bslash) {
          tmp___4 = 22;
        } else {
          tmp___4 = '\\';
        }
        {
        ga_append(& ga, tmp___4);
        }
      }
    }
    }
    }
    }
    }
    }
    if (c) {
      {
      ga_append(& ga, c);
      }
    }
    __Cont: 
    str___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
  ga_append(& ga, '\000');
  }
  return ((char_u *)ga.ga_data);
}
}
#pragma merger("0","/tmp/cil-LeEIQNhP.i","-O0")
extern Atom XInternAtom(Display * , char const   * , int  ) ;
extern void XFreeStringList(char ** ) ;
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
extern int XmbTextListToTextProperty(Display *display , char **list , int count ,
                                     XICCEncodingStyle style , XTextProperty *text_prop_return ) ;
extern int XmbTextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                     char ***list_return , int *count_return ) ;
extern Boolean XtDispatchEvent(XEvent * ) ;
extern Boolean XtOwnSelection(Widget  , Atom  , Time  , Boolean (*)(Widget  , Atom * ,
                                                                    Atom * , Atom * ,
                                                                    XtPointer * ,
                                                                    unsigned long * ,
                                                                    int * ) , void (*)(Widget  ,
                                                                                       Atom * ) ,
                              void (*)(Widget  , Atom * , Atom * ) ) ;
extern void XtToolkitInitialize(void) ;
extern XtAppContext XtCreateApplicationContext(void) ;
extern char *XtMalloc(Cardinal  ) ;
extern void XtFree(char * ) ;
extern void XtDisownSelection(Widget  , Atom  , Time  ) ;
extern void XtGetSelectionValue(Widget  , Atom  , Atom  , void (*)(Widget  , XtPointer  ,
                                                                   Atom * , Atom * ,
                                                                   XtPointer  , unsigned long * ,
                                                                   int * ) , XtPointer  ,
                                Time  ) ;
void clip_lose_selection(void) ;
void clip_copy_selection(void) ;
void clip_clear_selection(void) ;
int clip_gen_own_selection(void) ;
void clip_gen_lose_selection(void) ;
void read_error_exit(void) ;
void ui_write(char_u *s , int len___0 ) 
{ 


  {
  if (! silent_mode) {
    {
    mch_write(s, len___0);
    }
  }
  return;
}
}
int ui_inchar(char_u *buf___3 , int maxlen , long wtime ) 
{ 
  int tmp ;

  {
  {
  tmp = mch_inchar(buf___3, maxlen, wtime);
  }
  return (tmp);
}
}
int ui_char_avail(void) 
{ 
  int tmp ;

  {
  {
  tmp = mch_char_avail();
  }
  return (tmp);
}
}
void ui_delay(long msec , int ignoreinput ) 
{ 


  {
  {
  mch_delay(msec, ignoreinput);
  }
  return;
}
}
void ui_suspend(void) 
{ 


  {
  {
  mch_suspend();
  }
  return;
}
}
int ui_get_winsize(void) 
{ 
  int retval ;

  {
  {
  retval = mch_get_winsize();
  }
  if (retval == 1) {
    {
    set_number_default((char *)"lines", Rows);
    set_number_default((char *)"columns", Columns);
    }
  }
  return (retval);
}
}
void ui_set_winsize(void) 
{ 


  {
  {
  mch_set_winsize();
  }
  return;
}
}
void ui_breakcheck(void) 
{ 


  {
  {
  mch_breakcheck();
  }
  return;
}
}
void clip_init(int can_use ) 
{ 


  {
  clipboard.available = can_use;
  clipboard.owned = 0;
  clipboard.start.lnum = (linenr_t )0;
  clipboard.start.col = (colnr_t )0;
  clipboard.end.lnum = (linenr_t )0;
  clipboard.end.col = (colnr_t )0;
  clipboard.state = (short_u )0;
  return;
}
}
void clip_update_selection(void) 
{ 
  FPOS start___0 ;
  FPOS end ;
  int tmp ;

  {
  if (! redo_VIsual_busy) {
    if (VIsual_active) {
      if (VIsual.lnum != curwin->w_cursor.lnum) {
        tmp = VIsual.lnum < curwin->w_cursor.lnum;
      } else {
        tmp = VIsual.col < curwin->w_cursor.col;
      }
      if (tmp) {
        start___0 = VIsual;
        end = curwin->w_cursor;
      } else {
        start___0 = curwin->w_cursor;
        end = VIsual;
      }
      if (clipboard.start.lnum == start___0.lnum) {
        if (clipboard.start.col == start___0.col) {
          if (clipboard.end.lnum == end.lnum) {
            if (clipboard.end.col == end.col) {
              if (clipboard.vmode != VIsual_mode) {
                _L: 
                {
                clip_clear_selection();
                clipboard.start = start___0;
                clipboard.end = end;
                clipboard.vmode = VIsual_mode;
                clip_free_selection();
                clip_own_selection();
                clip_gen_set_selection();
                }
              }
            } else {
              goto _L;
            }
          } else {
            goto _L;
          }
        } else {
          goto _L;
        }
      } else {
        goto _L;
      }
    }
  }
  return;
}
}
void clip_own_selection(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! clipboard.owned) {
    if (clipboard.available) {
      {
      tmp = clip_gen_own_selection();
      clipboard.owned = tmp == 1;
      }
      if (clipboard.owned) {
        {
        tmp___0 = get_real_state();
        }
        if (tmp___0 == 2) {
          {
          tmp___1 = clip_isautosel();
          }
          if (tmp___1) {
            if (highlight_attr[14] != highlight_attr[15]) {
              {
              redraw_curbuf_later(40);
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
void clip_lose_selection(void) 
{ 
  int was_owned ;
  int tmp ;
  int tmp___0 ;

  {
  {
  was_owned = clipboard.owned;
  clip_free_selection();
  clipboard.owned = 0;
  clip_clear_selection();
  clip_gen_lose_selection();
  }
  if (was_owned) {
    {
    tmp = get_real_state();
    }
    if (tmp == 2) {
      {
      tmp___0 = clip_isautosel();
      }
      if (tmp___0) {
        if (highlight_attr[14] != highlight_attr[15]) {
          {
          update_curbuf(40);
          setcursor();
          cursor_on();
          out_flush();
          }
        }
      }
    }
  }
  return;
}
}
void clip_copy_selection(void) 
{ 
  int tmp ;

  {
  if (VIsual_active) {
    if (clipboard.available) {
      {
      tmp = clip_isautosel();
      }
      if (tmp) {
        {
        clip_update_selection();
        }
      }
      {
      clip_free_selection();
      clip_own_selection();
      }
      if (clipboard.owned) {
        {
        clip_get_selection();
        }
      }
      {
      clip_gen_set_selection();
      }
    }
  }
  return;
}
}
void clip_auto_select(void) 
{ 
  int tmp ;

  {
  {
  tmp = clip_isautosel();
  }
  if (tmp) {
    {
    clip_copy_selection();
    }
  }
  return;
}
}
int clip_isautosel(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = vim_strchr(p_cb, 't');
  }
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
void clip_clear_selection(void) 
{ 


  {
  clipboard.state = (short_u )0;
  return;
}
}
int clip_gen_own_selection(void) 
{ 
  int tmp ;

  {
  {
  tmp = clip_xterm_own_selection();
  }
  return (tmp);
}
}
void clip_gen_lose_selection(void) 
{ 


  {
  {
  clip_xterm_lose_selection();
  }
  return;
}
}
void clip_gen_set_selection(void) 
{ 


  {
  {
  clip_xterm_set_selection();
  }
  return;
}
}
void clip_gen_request_selection(void) 
{ 


  {
  {
  clip_xterm_request_selection();
  }
  return;
}
}
static char_u inbuf[256]  ;
static int inbufcount  =    0;
int vim_is_input_buf_full(void) 
{ 


  {
  return (inbufcount >= 250);
}
}
int vim_is_input_buf_empty(void) 
{ 


  {
  return (inbufcount == 0);
}
}
void add_to_input_buf(char_u *s , int len___0 ) 
{ 
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  if (inbufcount + len___0 > 256) {
    return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp___1 = len___0;
    len___0 --;
    if (! tmp___1) {
      goto while_break;
    }
    tmp = inbufcount;
    inbufcount ++;
    tmp___0 = s;
    s ++;
    inbuf[tmp] = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
int read_from_input_buf(char_u *buf___3 , long maxlen ) 
{ 


  {
  if (inbufcount == 0) {
    {
    fill_input_buf(1);
    }
  }
  if (maxlen > (long )inbufcount) {
    maxlen = (long )inbufcount;
  }
  {
  memmove((void *)((char *)buf___3), (void const   *)((char *)(inbuf)), (size_t )maxlen);
  inbufcount = (int )((long )inbufcount - maxlen);
  }
  if (inbufcount) {
    {
    memmove((void *)((char *)(inbuf)), (void const   *)((char *)(inbuf + maxlen)),
            (size_t )inbufcount);
    }
  }
  return ((int )maxlen);
}
}
static int did_read_something  =    0;
void fill_input_buf(int exit_on_error ) 
{ 
  int len___0 ;
  int try ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = vim_is_input_buf_full();
  }
  if (tmp) {
    return;
  }
  len___0 = 0;
  try = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (try < 100)) {
      goto while_break;
    }
    {
    tmp___0 = read(read_cmd_fd, (void *)((char *)(inbuf) + inbufcount), (size_t )(250 - inbufcount));
    len___0 = (int )tmp___0;
    }
    if (len___0 > 0) {
      goto while_break;
    } else { //Added block
    if (got_int) {
      goto while_break;
    }
    }
    if (! did_read_something) {
      {
      tmp___1 = isatty(read_cmd_fd);
      }
      if (! tmp___1) {
        if (read_cmd_fd == 0) {
          read_cmd_fd = 2;
        }
      }
    }
    if (! exit_on_error) {
      return;
    }
    try ++;
  }
  while_break: /* CIL Label */ ;
  }
  if (len___0 <= 0) {
    if (! got_int) {
      {
      read_error_exit();
      }
    }
  }
  did_read_something = 1;
  if (got_int) {
    inbuf[inbufcount] = (char_u )3;
    inbufcount = 1;
  } else {
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      tmp___2 = len___0;
      len___0 --;
      if (! (tmp___2 > 0)) {
        goto while_break___0;
      }
      if ((int )inbuf[inbufcount] == 3) {
        {
        memmove((void *)((char *)(inbuf)), (void const   *)((char *)(inbuf + inbufcount)),
                (size_t )(len___0 + 1));
        inbufcount = 0;
        got_int = 1;
        }
      }
      inbufcount ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
void read_error_exit(void) 
{ 


  {
  if (silent_mode) {
    {
    getout(0);
    }
  }
  {
  strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"Vim: Error reading input, exiting...\n"));
  preserve_exit();
  }
  return;
}
}
int check_col(int col ) 
{ 


  {
  if (col < 0) {
    return (0);
  }
  if (col >= screen_Columns) {
    return (screen_Columns - 1);
  }
  return (col);
}
}
int check_row(int row ) 
{ 


  {
  if (row < 0) {
    return (0);
  }
  if (row >= screen_Rows) {
    return (screen_Rows - 1);
  }
  return (row);
}
}
void open_app_context(void) 
{ 


  {
  if ((unsigned long )app_context == (unsigned long )((void *)0)) {
    {
    XtToolkitInitialize();
    app_context = XtCreateApplicationContext();
    }
  }
  return;
}
}
void x11_setup_atoms(Display *dpy ) 
{ 


  {
  {
  clipboard.xatom = XInternAtom(dpy, "_VIM_TEXT", 0);
  clipboard.xa_compound_text = XInternAtom(dpy, "COMPOUND_TEXT", 0);
  clipboard.xa_text = XInternAtom(dpy, "TEXT", 0);
  clipboard.xa_targets = XInternAtom(dpy, "TARGETS", 0);
  }
  return;
}
}
static void clip_x11_request_selection_cb(Widget w___0 , XtPointer success___0 , Atom *selection ,
                                          Atom *type , XtPointer value , long_u *length ,
                                          int *format ) ;
static void clip_x11_request_selection_cb(Widget w___0 , XtPointer success___0 , Atom *selection ,
                                          Atom *type , XtPointer value , long_u *length ,
                                          int *format ) 
{ 
  int motion_type ;
  long_u len___0 ;
  char_u *p___0 ;
  char **text_list ;
  char_u *tmp ;
  XTextProperty text_prop ;
  int n_text ;
  int status ;

  {
  text_list = (char **)((void *)0);
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
    clip_free_selection();
    *((int *)success___0) = 0;
    }
    return;
  } else { //Added block
  if (*length == 0UL) {
    {
    clip_free_selection();
    *((int *)success___0) = 0;
    }
    return;
  }
  }
  motion_type = 0;
  p___0 = (char_u *)value;
  len___0 = *length;
  if (*type == clipboard.xatom) {
    tmp = p___0;
    p___0 ++;
    motion_type = (int )*tmp;
    len___0 --;
  } else { //Added block
  if (*type == clipboard.xa_compound_text) {
    goto _L;
  } else { //Added block
  if (*type == clipboard.xa_text) {
    _L: 
    {
    n_text = 0;
    text_prop.value = (unsigned char *)value;
    text_prop.encoding = *type;
    text_prop.format = *format;
    text_prop.nitems = strlen((char const   *)((char *)value));
    status = XmbTextPropertyToTextList(xterm_dpy, (XTextProperty const   *)(& text_prop),
                                       & text_list, & n_text);
    }
    if (status != 0) {
      *((int *)success___0) = 0;
      return;
    } else { //Added block
    if (n_text < 1) {
      *((int *)success___0) = 0;
      return;
    }
    }
    {
    p___0 = (char_u *)*(text_list + 0);
    len___0 = strlen((char const   *)((char *)p___0));
    }
  }
  }
  }
  {
  clip_yank_selection(motion_type, p___0, (long )len___0);
  }
  if ((unsigned long )text_list != (unsigned long )((void *)0)) {
    {
    XFreeStringList(text_list);
    }
  }
  {
  XtFree((char *)value);
  *((int *)success___0) = 1;
  }
  return;
}
}
static int success  ;
void clip_x11_request_selection(Widget myShell , Display *dpy ) 
{ 
  XEvent event ;
  Atom type ;
  int i___0 ;
  int tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < 4)) {
      goto while_break;
    }
    {
    if (i___0 == 0) {
      goto case_0;
    }
    if (i___0 == 1) {
      goto case_1;
    }
    if (i___0 == 2) {
      goto case_2;
    }
    goto switch_default;
    case_0: /* CIL Label */ 
    type = clipboard.xatom;
    goto switch_break;
    case_1: /* CIL Label */ 
    type = clipboard.xa_compound_text;
    goto switch_break;
    case_2: /* CIL Label */ 
    type = clipboard.xa_text;
    goto switch_break;
    switch_default: /* CIL Label */ 
    type = (Atom )31;
    switch_break: /* CIL Label */ ;
    }
    {
    XtGetSelectionValue(myShell, (Atom )1, type, & clip_x11_request_selection_cb,
                        (XtPointer )(& success), (Time )0L);
    XFlush(dpy);
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
      tmp = XCheckTypedEvent(dpy, 31, & event);
      }
      if (tmp) {
        goto while_break___0;
      }
      {
      XSync(dpy, 0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    XtDispatchEvent(& event);
    }
    if (success) {
      return;
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
static Boolean clip_x11_convert_selection_cb(Widget w___0 , Atom *selection , Atom *target ,
                                             Atom *type , XtPointer *value , long_u *length ,
                                             int *format ) ;
static Boolean clip_x11_convert_selection_cb(Widget w___0 , Atom *selection , Atom *target ,
                                             Atom *type , XtPointer *value , long_u *length ,
                                             int *format ) 
{ 
  char_u *string___0 ;
  char_u *result___0 ;
  int motion_type ;
  Atom *array ;
  char *tmp ;
  char *tmp___0 ;
  XTextProperty text_prop ;
  char *string_nt ;
  char_u *tmp___1 ;

  {
  if (! clipboard.owned) {
    return ((Boolean )0);
  }
  if (*target == clipboard.xa_targets) {
    {
    tmp = XtMalloc((unsigned int )(sizeof(Atom ) * 5UL));
    array = (Atom *)tmp;
    }
    if ((unsigned long )array == (unsigned long )((void *)0)) {
      return ((Boolean )0);
    }
    *value = (XtPointer )array;
    *(array + 0) = (Atom )31;
    *(array + 1) = clipboard.xa_targets;
    *(array + 2) = clipboard.xatom;
    *(array + 3) = clipboard.xa_text;
    *(array + 4) = clipboard.xa_compound_text;
    *type = (Atom )4;
    *format = (int )(sizeof(Atom ) * 8UL);
    *length = (long_u )5;
    return ((Boolean )1);
  }
  if (*target != 31UL) {
    if (*target != clipboard.xatom) {
      if (*target != clipboard.xa_text) {
        if (*target != clipboard.xa_compound_text) {
          return ((Boolean )0);
        }
      }
    }
  }
  {
  clip_get_selection();
  motion_type = clip_convert_selection(& string___0, length);
  }
  if (motion_type < 0) {
    return ((Boolean )0);
  }
  if (*target == clipboard.xatom) {
    (*length) ++;
  }
  {
  tmp___0 = XtMalloc((Cardinal )*length);
  *value = (XtPointer )tmp___0;
  result___0 = (char_u *)*value;
  }
  if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
    {
    vim_free((void *)string___0);
    }
    return ((Boolean )0);
  }
  if (*target == 31UL) {
    {
    memmove((void *)((char *)result___0), (void const   *)((char *)string___0), *length);
    *type = (Atom )31;
    }
  } else { //Added block
  if (*target == clipboard.xa_compound_text) {
    goto _L;
  } else { //Added block
  if (*target == clipboard.xa_text) {
    _L: 
    {
    tmp___1 = alloc((unsigned int )*length + 1U);
    string_nt = (char *)tmp___1;
    memmove((void *)string_nt, (void const   *)((char *)string___0), *length);
    *(string_nt + *length) = (char )'\000';
    XmbTextListToTextProperty(xterm_dpy, & string_nt, 1, (XICCEncodingStyle )1, & text_prop);
    vim_free((void *)string_nt);
    XtFree((char *)*value);
    *value = (XtPointer )text_prop.value;
    *length = text_prop.nitems;
    *type = clipboard.xa_compound_text;
    }
  } else {
    {
    *(result___0 + 0) = (char_u )motion_type;
    memmove((void *)((char *)(result___0 + 1)), (void const   *)((char *)string___0),
            *length - 1UL);
    *type = clipboard.xatom;
    }
  }
  }
  }
  {
  *format = 8;
  vim_free((void *)string___0);
  }
  return ((Boolean )1);
}
}
static void clip_x11_lose_ownership_cb(Widget w___0 , Atom *selection ) ;
static void clip_x11_lose_ownership_cb(Widget w___0 , Atom *selection ) 
{ 


  {
  {
  clip_lose_selection();
  }
  return;
}
}
void clip_x11_lose_selection(Widget myShell ) 
{ 


  {
  {
  XtDisownSelection(myShell, (Atom )1, (Time )0L);
  }
  return;
}
}
int clip_x11_own_selection(Widget myShell ) 
{ 
  Boolean tmp ;

  {
  {
  tmp = XtOwnSelection(myShell, (Atom )1, (Time )0L, & clip_x11_convert_selection_cb,
                       & clip_x11_lose_ownership_cb, (void (*)(Widget  , Atom * ,
                                                               Atom * ))((void *)0));
  }
  if ((int )tmp == 0) {
    return (0);
  }
  return (1);
}
}
void clip_x11_set_selection(void) 
{ 


  {
  return;
}
}
#pragma merger("0","/tmp/cil-3y2lZ3a4.i","-O0")
void u_saveline(linenr_t lnum ) ;
static void u_getbot(void) ;
static int u_savecommon(linenr_t top , linenr_t bot , linenr_t newbot ) ;
static void u_doit(int count___2 ) ;
static void u_undoredo(void) ;
static void u_undo_end(void) ;
static void u_freelist(struct u_header *uhp ) ;
static void u_freeentry(struct u_entry *uep , long n ) ;
static char_u *u_blockalloc(long_u size ) ;
static void u_free_line(char_u *ptr ) ;
static char_u *u_alloc_line(unsigned int size ) ;
static char_u *u_save_line(linenr_t lnum ) ;
static long u_newcount  ;
static long u_oldcount  ;
static int undo_undoes  =    0;
int u_save_cursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = u_save(curwin->w_cursor.lnum - 1L, curwin->w_cursor.lnum + 1L);
  }
  return (tmp);
}
}
int u_save(linenr_t top , linenr_t bot ) 
{ 
  int tmp ;

  {
  if (undo_off) {
    return (1);
  }
  if (top > curbuf->b_ml.ml_line_count) {
    return (0);
  } else { //Added block
  if (top >= bot) {
    return (0);
  } else { //Added block
  if (bot > curbuf->b_ml.ml_line_count + 1L) {
    return (0);
  }
  }
  }
  if (top + 2L == bot) {
    {
    u_saveline(top + 1L);
    }
  }
  {
  tmp = u_savecommon(top, bot, (linenr_t )0);
  }
  return (tmp);
}
}
int u_savesub(linenr_t lnum ) 
{ 
  int tmp ;

  {
  if (undo_off) {
    return (1);
  }
  {
  tmp = u_savecommon(lnum - 1L, lnum + 1L, lnum + 1L);
  }
  return (tmp);
}
}
int u_inssub(linenr_t lnum ) 
{ 
  int tmp ;

  {
  if (undo_off) {
    return (1);
  }
  {
  tmp = u_savecommon(lnum - 1L, lnum, lnum + 1L);
  }
  return (tmp);
}
}
int u_savedel(linenr_t lnum , long nlines ) 
{ 
  linenr_t tmp ;
  int tmp___0 ;

  {
  if (undo_off) {
    return (1);
  }
  if (nlines == curbuf->b_ml.ml_line_count) {
    tmp = (linenr_t )2;
  } else {
    tmp = lnum;
  }
  {
  tmp___0 = u_savecommon(lnum - 1L, lnum + nlines, tmp);
  }
  return (tmp___0);
}
}
static int u_savecommon(linenr_t top , linenr_t bot , linenr_t newbot ) 
{ 
  linenr_t lnum ;
  long i___0 ;
  struct u_header *uhp ;
  struct u_entry *uep ;
  long size ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u **tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  linenr_t tmp___6 ;
  int tmp___7 ;

  {
  if (sandbox != 0) {
    {
    emsg(e_sandbox);
    }
    return (0);
  }
  if (curbuf->b_u_synced) {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )curbuf->b_u_curhead != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {
      u_freelist(curbuf->b_u_newhead);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((long )curbuf->b_u_numhead > p_ul) {
        if (! ((unsigned long )curbuf->b_u_oldhead != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      {
      u_freelist(curbuf->b_u_oldhead);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    if (p_ul < 0L) {
      return (1);
    }
    {
    tmp = u_alloc_line((unsigned int )sizeof(struct u_header ));
    uhp = (struct u_header *)tmp;
    }
    if ((unsigned long )uhp == (unsigned long )((void *)0)) {
      goto nomem;
    }
    uhp->uh_prev = (struct u_header *)((void *)0);
    uhp->uh_next = curbuf->b_u_newhead;
    if ((unsigned long )curbuf->b_u_newhead != (unsigned long )((void *)0)) {
      (curbuf->b_u_newhead)->uh_prev = uhp;
    }
    uhp->uh_entry = (struct u_entry *)((void *)0);
    uhp->uh_cursor = curwin->w_cursor;
    if (curbuf->b_changed) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    if (curbuf->b_ml.ml_flags & 1) {
      tmp___1 = 2;
    } else {
      tmp___1 = 0;
    }
    {
    uhp->uh_flags = tmp___0 + tmp___1;
    memmove((void *)((char *)(uhp->uh_namedm)), (void const   *)((char *)(curbuf->b_namedm)),
            sizeof(FPOS ) * 26UL);
    curbuf->b_u_newhead = uhp;
    }
    if ((unsigned long )curbuf->b_u_oldhead == (unsigned long )((void *)0)) {
      curbuf->b_u_oldhead = uhp;
    }
    (curbuf->b_u_numhead) ++;
  } else {
    {
    u_getbot();
    }
  }
  {
  size = (bot - top) - 1L;
  tmp___2 = u_alloc_line((unsigned int )sizeof(struct u_entry ));
  uep = (struct u_entry *)tmp___2;
  }
  if ((unsigned long )uep == (unsigned long )((void *)0)) {
    goto nomem;
  }
  uep->ue_size = size;
  uep->ue_top = top;
  uep->ue_lcount = (linenr_t )0;
  if (newbot) {
    uep->ue_bot = newbot;
  } else { //Added block
  if (bot > curbuf->b_ml.ml_line_count) {
    uep->ue_bot = (linenr_t )0;
  } else {
    uep->ue_lcount = curbuf->b_ml.ml_line_count;
  }
  }
  if (size) {
    {
    tmp___4 = u_alloc_line((unsigned int )(sizeof(char_u *) * (unsigned long )size));
    tmp___3 = (char_u **)tmp___4;
    uep->ue_array = tmp___3;
    }
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
      u_freeentry(uep, 0L);
      }
      goto nomem;
    }
    i___0 = 0L;
    lnum = top + 1L;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i___0 < size)) {
        goto while_break___1;
      }
      {
      tmp___6 = lnum;
      lnum ++;
      tmp___5 = u_save_line(tmp___6);
      *(uep->ue_array + i___0) = tmp___5;
      }
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
        {
        u_freeentry(uep, i___0);
        }
        goto nomem;
      }
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  uep->ue_next = (curbuf->b_u_newhead)->uh_entry;
  (curbuf->b_u_newhead)->uh_entry = uep;
  curbuf->b_u_synced = 0;
  undo_undoes = 0;
  return (1);
  nomem: 
  {
  tmp___7 = ask_yesno((char_u *)"No undo possible; continue anyway", 1);
  }
  if (tmp___7 == 121) {
    undo_off = 1;
    return (1);
  }
  {
  do_outofmem_msg();
  }
  return (0);
}
}
void u_undo(int count___2 ) 
{ 
  char_u *tmp ;

  {
  if (curbuf->b_u_synced == 0) {
    {
    u_sync();
    count___2 = 1;
    }
  }
  {
  tmp = vim_strchr(p_cpo, 'u');
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    undo_undoes = 1;
  } else {
    undo_undoes = ! undo_undoes;
  }
  {
  u_doit(count___2);
  }
  return;
}
}
void u_redo(int count___2 ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = vim_strchr(p_cpo, 'u');
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    undo_undoes = 0;
  }
  {
  u_doit(count___2);
  }
  return;
}
}
static void u_doit(int count___2 ) 
{ 
  int tmp ;

  {
  if (sandbox != 0) {
    {
    emsg(e_sandbox);
    }
    return;
  }
  u_newcount = 0L;
  u_oldcount = 0L;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = count___2;
    count___2 --;
    if (! tmp) {
      goto while_break;
    }
    if (undo_undoes) {
      if ((unsigned long )curbuf->b_u_curhead == (unsigned long )((void *)0)) {
        curbuf->b_u_curhead = curbuf->b_u_newhead;
      } else { //Added block
      if (p_ul > 0L) {
        curbuf->b_u_curhead = (curbuf->b_u_curhead)->uh_next;
      }
      }
      if (curbuf->b_u_numhead == 0) {
        {
        curbuf->b_u_curhead = curbuf->b_u_oldhead;
        beep_flush();
        }
        goto while_break;
      } else { //Added block
      if ((unsigned long )curbuf->b_u_curhead == (unsigned long )((void *)0)) {
        {
        curbuf->b_u_curhead = curbuf->b_u_oldhead;
        beep_flush();
        }
        goto while_break;
      }
      }
      {
      u_undoredo();
      }
    } else {
      if ((unsigned long )curbuf->b_u_curhead == (unsigned long )((void *)0)) {
        {
        beep_flush();
        }
        goto while_break;
      } else { //Added block
      if (p_ul <= 0L) {
        {
        beep_flush();
        }
        goto while_break;
      }
      }
      {
      u_undoredo();
      curbuf->b_u_curhead = (curbuf->b_u_curhead)->uh_prev;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  u_undo_end();
  }
  return;
}
}
static void u_undoredo(void) 
{ 
  char_u **newarray ;
  linenr_t oldsize ;
  linenr_t newsize ;
  linenr_t top ;
  linenr_t bot ;
  linenr_t lnum ;
  linenr_t newlnum ;
  long i___0 ;
  struct u_entry *uep ;
  struct u_entry *nuep ;
  struct u_entry *newlist ;
  int old_flags ;
  int new_flags ;
  FPOS namedm[26] ;
  int empty_buffer ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  newarray = (char_u **)((void *)0);
  newlnum = (linenr_t )2147483647;
  newlist = (struct u_entry *)((void *)0);
  old_flags = (curbuf->b_u_curhead)->uh_flags;
  if (curbuf->b_changed) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  if (curbuf->b_ml.ml_flags & 1) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  new_flags = tmp + tmp___0;
  if (old_flags & 1) {
    {
    changed();
    }
  } else {
    {
    unchanged(curbuf, 0);
    }
  }
  {
  setpcmark();
  changed_line_abv_curs();
  memmove((void *)((char *)(namedm)), (void const   *)((char *)(curbuf->b_namedm)),
          sizeof(FPOS ) * 26UL);
  curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;
  curbuf->b_op_start.col = (colnr_t )0;
  curbuf->b_op_end.lnum = (linenr_t )0;
  curbuf->b_op_end.col = (colnr_t )0;
  uep = (curbuf->b_u_curhead)->uh_entry;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )uep != (unsigned long )((void *)0))) {
      goto while_break;
    }
    top = uep->ue_top;
    bot = uep->ue_bot;
    if (bot == 0L) {
      bot = curbuf->b_ml.ml_line_count + 1L;
    }
    if (top > curbuf->b_ml.ml_line_count) {
      {
      emsg((char_u *)"u_undo: line numbers wrong");
      changed();
      }
      return;
    } else { //Added block
    if (top >= bot) {
      {
      emsg((char_u *)"u_undo: line numbers wrong");
      changed();
      }
      return;
    } else { //Added block
    if (bot > curbuf->b_ml.ml_line_count + 1L) {
      {
      emsg((char_u *)"u_undo: line numbers wrong");
      changed();
      }
      return;
    }
    }
    }
    if (top < newlnum) {
      newlnum = top;
      curwin->w_cursor.lnum = top + 1L;
    }
    oldsize = (bot - top) - 1L;
    newsize = uep->ue_size;
    empty_buffer = 0;
    if (oldsize) {
      {
      tmp___1 = u_alloc_line((unsigned int )(sizeof(char_u *) * (unsigned long )oldsize));
      newarray = (char_u **)tmp___1;
      }
      if ((unsigned long )newarray == (unsigned long )((void *)0)) {
        {
        do_outofmem_msg();
        }
        {
        while (1) {
          while_continue___0: /* CIL Label */ ;
          if (! ((unsigned long )uep != (unsigned long )((void *)0))) {
            goto while_break___0;
          }
          {
          nuep = uep->ue_next;
          u_freeentry(uep, uep->ue_size);
          uep = nuep;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        goto while_break;
      }
      lnum = bot - 1L;
      i___0 = oldsize;
      {
      while (1) {
        while_continue___1: /* CIL Label */ ;
        i___0 --;
        if (! (i___0 >= 0L)) {
          goto while_break___1;
        }
        {
        tmp___2 = u_save_line(lnum);
        *(newarray + i___0) = tmp___2;
        }
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
          {
          do_outofmem_msg();
          }
        }
        if (curbuf->b_ml.ml_line_count == 1L) {
          empty_buffer = 1;
        }
        {
        ml_delete(lnum, 0);
        lnum --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    if (newsize) {
      lnum = top;
      i___0 = 0L;
      {
      while (1) {
        while_continue___2: /* CIL Label */ ;
        if (! (i___0 < newsize)) {
          goto while_break___2;
        }
        if (empty_buffer) {
          if (lnum == 0L) {
            {
            ml_replace((linenr_t )1, *(uep->ue_array + i___0), 1);
            }
          } else {
            {
            ml_append(lnum, *(uep->ue_array + i___0), (colnr_t )0, 0);
            }
          }
        } else {
          {
          ml_append(lnum, *(uep->ue_array + i___0), (colnr_t )0, 0);
          }
        }
        {
        u_free_line(*(uep->ue_array + i___0));
        i___0 ++;
        lnum ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      u_free_line((char_u *)uep->ue_array);
      }
    }
    if (oldsize != newsize) {
      {
      mark_adjust(top + 1L, top + oldsize, (linenr_t )2147483647, newsize - oldsize);
      }
      if (curbuf->b_op_start.lnum > top + oldsize) {
        curbuf->b_op_start.lnum += newsize - oldsize;
      }
      if (curbuf->b_op_end.lnum > top + oldsize) {
        curbuf->b_op_end.lnum += newsize - oldsize;
      }
    }
    if (top + 1L < curbuf->b_op_start.lnum) {
      curbuf->b_op_start.lnum = top + 1L;
    }
    if (newsize == 0L) {
      if (top + 1L > curbuf->b_op_end.lnum) {
        curbuf->b_op_end.lnum = top + 1L;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if (top + newsize > curbuf->b_op_end.lnum) {
      curbuf->b_op_end.lnum = top + newsize;
    }
    }
    u_newcount += newsize;
    u_oldcount += oldsize;
    uep->ue_size = oldsize;
    uep->ue_array = newarray;
    uep->ue_bot = (top + newsize) + 1L;
    nuep = uep->ue_next;
    uep->ue_next = newlist;
    newlist = uep;
    uep = nuep;
  }
  while_break: /* CIL Label */ ;
  }
  (curbuf->b_u_curhead)->uh_entry = newlist;
  (curbuf->b_u_curhead)->uh_flags = new_flags;
  if (old_flags & 2) {
    if (curbuf->b_ml.ml_line_count == 1L) {
      {
      tmp___3 = ml_get((linenr_t )1);
      }
      if ((int )*tmp___3 == 0) {
        curbuf->b_ml.ml_flags |= 1;
      }
    }
  }
  i___0 = 0L;
  {
  while (1) {
    while_continue___3: /* CIL Label */ ;
    if (! (i___0 < 26L)) {
      goto while_break___3;
    }
    if ((curbuf->b_u_curhead)->uh_namedm[i___0].lnum) {
      curbuf->b_namedm[i___0] = (curbuf->b_u_curhead)->uh_namedm[i___0];
      (curbuf->b_u_curhead)->uh_namedm[i___0] = namedm[i___0];
    }
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  if ((curbuf->b_u_curhead)->uh_cursor.lnum + 1L == curwin->w_cursor.lnum) {
    if (curwin->w_cursor.lnum > 1L) {
      (curwin->w_cursor.lnum) --;
    }
  }
  if ((curbuf->b_u_curhead)->uh_cursor.lnum == curwin->w_cursor.lnum) {
    curwin->w_cursor.col = (curbuf->b_u_curhead)->uh_cursor.col;
  } else { //Added block
  if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count) {
    {
    beginline(6);
    }
  } else {
    curwin->w_cursor.col = (colnr_t )0;
  }
  }
  {
  adjust_cursor();
  }
  return;
}
}
static void u_undo_end(void) 
{ 
  char *tmp ;

  {
  u_oldcount -= u_newcount;
  if (u_oldcount != 0L) {
    {
    msgmore(- u_oldcount);
    }
  } else { //Added block
  if (u_newcount > p_report) {
    {
    tmp = plural(u_newcount);
    smsg((char_u *)"%ld change%s", u_newcount, tmp);
    }
  }
  }
  {
  update_topline();
  update_curbuf(40);
  }
  return;
}
}
void u_sync(void) 
{ 


  {
  if (curbuf->b_u_synced) {
    return;
  }
  {
  u_getbot();
  curbuf->b_u_curhead = (struct u_header *)((void *)0);
  }
  return;
}
}
void u_unchanged(BUF *buf___3 ) 
{ 
  struct u_header *uh ;

  {
  uh = buf___3->b_u_newhead;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! uh) {
      goto while_break;
    }
    uh->uh_flags |= 1;
    uh = uh->uh_next;
  }
  while_break: /* CIL Label */ ;
  }
  buf___3->b_did_warn = 0;
  return;
}
}
static void u_getbot(void) 
{ 
  struct u_entry *uep ;

  {
  if ((unsigned long )curbuf->b_u_newhead == (unsigned long )((void *)0)) {
    {
    emsg((char_u *)"undo list corrupt");
    }
    return;
  } else {
    uep = (curbuf->b_u_newhead)->uh_entry;
    if ((unsigned long )uep == (unsigned long )((void *)0)) {
      {
      emsg((char_u *)"undo list corrupt");
      }
      return;
    }
  }
  if (uep->ue_lcount != 0L) {
    uep->ue_bot = ((uep->ue_top + uep->ue_size) + 1L) + (curbuf->b_ml.ml_line_count - uep->ue_lcount);
    if (uep->ue_bot < 1L) {
      {
      emsg((char_u *)"undo line missing");
      uep->ue_bot = uep->ue_top + 1L;
      }
    } else { //Added block
    if (uep->ue_bot > curbuf->b_ml.ml_line_count) {
      {
      emsg((char_u *)"undo line missing");
      uep->ue_bot = uep->ue_top + 1L;
      }
    }
    }
    uep->ue_lcount = (linenr_t )0;
  }
  curbuf->b_u_synced = 1;
  return;
}
}
static void u_freelist(struct u_header *uhp ) 
{ 
  struct u_entry *uep ;
  struct u_entry *nuep ;

  {
  uep = uhp->uh_entry;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )uep != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    nuep = uep->ue_next;
    u_freeentry(uep, uep->ue_size);
    uep = nuep;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )curbuf->b_u_curhead == (unsigned long )uhp) {
    curbuf->b_u_curhead = (struct u_header *)((void *)0);
  }
  if ((unsigned long )uhp->uh_next == (unsigned long )((void *)0)) {
    curbuf->b_u_oldhead = uhp->uh_prev;
  } else {
    (uhp->uh_next)->uh_prev = uhp->uh_prev;
  }
  if ((unsigned long )uhp->uh_prev == (unsigned long )((void *)0)) {
    curbuf->b_u_newhead = uhp->uh_next;
  } else {
    (uhp->uh_prev)->uh_next = uhp->uh_next;
  }
  {
  u_free_line((char_u *)uhp);
  (curbuf->b_u_numhead) --;
  }
  return;
}
}
static void u_freeentry(struct u_entry *uep , long n ) 
{ 


  {
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! n) {
      goto while_break;
    }
    {
    n --;
    u_free_line(*(uep->ue_array + n));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  u_free_line((char_u *)uep);
  }
  return;
}
}
void u_clearall(BUF *buf___3 ) 
{ 
  struct u_header *tmp ;
  struct u_header *tmp___0 ;

  {
  tmp___0 = (struct u_header *)((void *)0);
  buf___3->b_u_curhead = tmp___0;
  tmp = tmp___0;
  buf___3->b_u_oldhead = tmp;
  buf___3->b_u_newhead = tmp;
  buf___3->b_u_synced = 1;
  buf___3->b_u_numhead = 0;
  buf___3->b_u_line_ptr = (char_u *)((void *)0);
  buf___3->b_u_line_lnum = (linenr_t )0;
  return;
}
}
void u_saveline(linenr_t lnum ) 
{ 
  char_u *tmp ;

  {
  if (lnum == curbuf->b_u_line_lnum) {
    return;
  }
  if (lnum < 1L) {
    return;
  } else { //Added block
  if (lnum > curbuf->b_ml.ml_line_count) {
    return;
  }
  }
  {
  u_clearline();
  curbuf->b_u_line_lnum = lnum;
  }
  if (curwin->w_cursor.lnum == lnum) {
    curbuf->b_u_line_colnr = curwin->w_cursor.col;
  } else {
    curbuf->b_u_line_colnr = (colnr_t )0;
  }
  {
  tmp = u_save_line(lnum);
  curbuf->b_u_line_ptr = tmp;
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    do_outofmem_msg();
    }
  }
  return;
}
}
void u_clearline(void) 
{ 


  {
  if ((unsigned long )curbuf->b_u_line_ptr != (unsigned long )((void *)0)) {
    {
    u_free_line(curbuf->b_u_line_ptr);
    curbuf->b_u_line_ptr = (char_u *)((void *)0);
    curbuf->b_u_line_lnum = (linenr_t )0;
    }
  }
  return;
}
}
void u_undoline(void) 
{ 
  colnr_t t ;
  char_u *oldp ;
  int tmp ;

  {
  if (undo_off) {
    return;
  }
  if ((unsigned long )curbuf->b_u_line_ptr == (unsigned long )((void *)0)) {
    {
    beep_flush();
    }
    return;
  } else { //Added block
  if (curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count) {
    {
    beep_flush();
    }
    return;
  }
  }
  {
  tmp = u_savecommon(curbuf->b_u_line_lnum - 1L, curbuf->b_u_line_lnum + 1L, (linenr_t )0);
  }
  if (tmp == 0) {
    return;
  }
  {
  oldp = u_save_line(curbuf->b_u_line_lnum);
  }
  if ((unsigned long )oldp == (unsigned long )((void *)0)) {
    {
    do_outofmem_msg();
    }
    return;
  }
  {
  ml_replace(curbuf->b_u_line_lnum, curbuf->b_u_line_ptr, 1);
  u_free_line(curbuf->b_u_line_ptr);
  curbuf->b_u_line_ptr = oldp;
  changed();
  syn_changed(curbuf->b_u_line_lnum);
  t = curbuf->b_u_line_colnr;
  }
  if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum) {
    curbuf->b_u_line_colnr = curwin->w_cursor.col;
  }
  {
  changed_cline_bef_curs();
  curwin->w_cursor.col = t;
  curwin->w_cursor.lnum = curbuf->b_u_line_lnum;
  approximate_botline();
  update_screen(30);
  }
  return;
}
}
static char_u *u_blockalloc(long_u size ) 
{ 
  struct m_block *p___0 ;
  struct m_block *mp ;
  struct m_block *next ;
  char_u *tmp ;

  {
  {
  tmp = lalloc(size + sizeof(struct m_block ), 0);
  p___0 = (struct m_block *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    mp = & curbuf->b_block_head;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      next = mp->mb_next;
      if ((unsigned long )next != (unsigned long )((void *)0)) {
        if (! ((unsigned long )next < (unsigned long )p___0)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      mp = next;
    }
    while_break: /* CIL Label */ ;
    }
    p___0->mb_next = next;
    mp->mb_next = p___0;
    p___0->mb_info.m_next = (info_t *)((void *)0);
    p___0->mb_info.m_size = (long_u )0;
    curbuf->b_mb_current = p___0;
    curbuf->b_m_search = (info_t *)((void *)0);
    p___0 ++;
  }
  return ((char_u *)p___0);
}
}
void u_blockfree(BUF *buf___3 ) 
{ 
  struct m_block *p___0 ;
  struct m_block *np___0 ;

  {
  p___0 = buf___3->b_block_head.mb_next;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    np___0 = p___0->mb_next;
    vim_free((void *)p___0);
    p___0 = np___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  buf___3->b_block_head.mb_next = (struct m_block *)((void *)0);
  buf___3->b_m_search = (info_t *)((void *)0);
  buf___3->b_mb_current = (struct m_block *)((void *)0);
  return;
}
}
static void u_free_line(char_u *ptr ) 
{ 
  info_t *next ;
  info_t *prev ;
  info_t *curr ;
  info_t *mp ;
  struct m_block *nextb ;

  {
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    return;
  } else { //Added block
  if ((unsigned long )ptr == (unsigned long )IObuff) {
    return;
  }
  }
  mp = (info_t *)(ptr - sizeof(long_u ));
  if ((unsigned long )curbuf->b_mb_current == (unsigned long )((void *)0)) {
    curbuf->b_mb_current = curbuf->b_block_head.mb_next;
    curbuf->b_m_search = (info_t *)((void *)0);
  } else { //Added block
  if ((unsigned long )mp < (unsigned long )((info_t *)curbuf->b_mb_current)) {
    curbuf->b_mb_current = curbuf->b_block_head.mb_next;
    curbuf->b_m_search = (info_t *)((void *)0);
  }
  }
  nextb = (curbuf->b_mb_current)->mb_next;
  if ((unsigned long )nextb != (unsigned long )((void *)0)) {
    if ((unsigned long )((info_t *)nextb) < (unsigned long )mp) {
      curbuf->b_mb_current = nextb;
      curbuf->b_m_search = (info_t *)((void *)0);
    }
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    nextb = (curbuf->b_mb_current)->mb_next;
    if ((unsigned long )nextb != (unsigned long )((void *)0)) {
      if (! ((unsigned long )((info_t *)nextb) < (unsigned long )mp)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    curbuf->b_mb_current = nextb;
  }
  while_break: /* CIL Label */ ;
  }
  curr = (info_t *)((void *)0);
  if ((unsigned long )curbuf->b_m_search == (unsigned long )((void *)0)) {
    next = & (curbuf->b_mb_current)->mb_info;
  } else { //Added block
  if ((unsigned long )mp < (unsigned long )(curbuf->b_m_search)->m_next) {
    next = & (curbuf->b_mb_current)->mb_info;
  } else {
    next = curbuf->b_m_search;
  }
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    prev = next->m_next;
    if ((unsigned long )prev == (unsigned long )((void *)0)) {
      prev = curr;
      curr = next;
      next = next->m_next;
      goto while_break___0;
    } else { //Added block
    if ((unsigned long )mp <= (unsigned long )prev) {
      prev = curr;
      curr = next;
      next = next->m_next;
      goto while_break___0;
    }
    }
    curr = prev->m_next;
    if ((unsigned long )curr == (unsigned long )((void *)0)) {
      prev = next;
      curr = prev->m_next;
      next = curr->m_next;
      goto while_break___0;
    } else { //Added block
    if ((unsigned long )mp <= (unsigned long )curr) {
      prev = next;
      curr = prev->m_next;
      next = curr->m_next;
      goto while_break___0;
    }
    }
    next = curr->m_next;
    if ((unsigned long )mp > (unsigned long )next) {
      if (! ((unsigned long )next != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if ((unsigned long )((char_u *)mp + mp->m_size) == (unsigned long )((char_u *)next)) {
    mp->m_size += next->m_size;
    mp->m_next = next->m_next;
  } else {
    mp->m_next = next;
  }
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
    if ((unsigned long )((char_u *)curr + curr->m_size) == (unsigned long )((char_u *)mp)) {
      curr->m_size += mp->m_size;
      curr->m_next = mp->m_next;
      curbuf->b_m_search = prev;
    } else {
      curr->m_next = mp;
      curbuf->b_m_search = curr;
    }
  } else {
    curr->m_next = mp;
    curbuf->b_m_search = curr;
  }
  return;
}
}
static char_u *u_alloc_line(unsigned int size ) 
{ 
  info_t *mp ;
  info_t *mprev ;
  info_t *mp2 ;
  struct m_block *mbp ;
  int size_align ;
  info_t *tmp ;
  info_t *tmp___0 ;
  int n ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  size = (unsigned int )((unsigned long )size + (sizeof(long_u ) + 1UL));
  if ((unsigned long )size < sizeof(info_t ) + 1UL) {
    size = (unsigned int )(sizeof(info_t ) + 1UL);
  }
  size_align = (int )(((unsigned long )size + (sizeof(long ) - 1UL)) & ~ (sizeof(long ) - 1UL));
  if ((unsigned long )curbuf->b_mb_current == (unsigned long )((void *)0)) {
    curbuf->b_mb_current = & curbuf->b_block_head;
    curbuf->b_m_search = & curbuf->b_block_head.mb_info;
  } else { //Added block
  if ((unsigned long )curbuf->b_m_search == (unsigned long )((void *)0)) {
    curbuf->b_mb_current = & curbuf->b_block_head;
    curbuf->b_m_search = & curbuf->b_block_head.mb_info;
  }
  }
  mprev = curbuf->b_m_search;
  mbp = curbuf->b_mb_current;
  mp = (curbuf->b_m_search)->m_next;
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
    if (mbp->mb_next) {
      mbp = mbp->mb_next;
    } else {
      mbp = & curbuf->b_block_head;
    }
    tmp = & mbp->mb_info;
    curbuf->b_m_search = tmp;
    mp = tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (mp->m_size < (long_u )size)) {
      goto while_break;
    }
    if ((unsigned long )mp == (unsigned long )curbuf->b_m_search) {
      if (mbp->mb_next) {
        mbp = mbp->mb_next;
      } else {
        mbp = & curbuf->b_block_head;
      }
      tmp___0 = & mbp->mb_info;
      curbuf->b_m_search = tmp___0;
      mp = tmp___0;
      if ((unsigned long )mbp == (unsigned long )curbuf->b_mb_current) {
        if (size_align > 511) {
          tmp___1 = size_align;
        } else {
          tmp___1 = 2044;
        }
        {
        n = tmp___1;
        tmp___2 = u_blockalloc((long_u )n);
        mp = (info_t *)tmp___2;
        }
        if ((unsigned long )mp == (unsigned long )((void *)0)) {
          return ((char_u *)((void *)0));
        }
        {
        mp->m_size = (long_u )n;
        u_free_line((char_u *)mp + sizeof(long_u ));
        mp = curbuf->b_m_search;
        mbp = curbuf->b_mb_current;
        }
      }
    }
    mprev = mp;
    mp = mp->m_next;
    if ((unsigned long )mp == (unsigned long )((void *)0)) {
      mp = & mbp->mb_info;
    }
  }
  while_break: /* CIL Label */ ;
  }
  if ((long )mp->m_size - (long )size_align >= (long )(sizeof(info_t ) + 1UL)) {
    mp2 = (info_t *)((char_u *)mp + size_align);
    mp2->m_size = mp->m_size - (long_u )size_align;
    mp2->m_next = mp->m_next;
    mprev->m_next = mp2;
    mp->m_size = (long_u )size_align;
  } else {
    mprev->m_next = mp->m_next;
  }
  curbuf->b_m_search = mprev;
  curbuf->b_mb_current = mbp;
  mp = (info_t *)((char_u *)mp + sizeof(long_u ));
  *((char_u *)mp) = (char_u )'\000';
  return ((char_u *)mp);
}
}
static char_u *u_save_line(linenr_t lnum ) 
{ 
  char_u *src ;
  char_u *dst ;
  unsigned int len___0 ;
  size_t tmp ;

  {
  {
  src = ml_get(lnum);
  tmp = strlen((char const   *)((char *)src));
  len___0 = (unsigned int )tmp;
  dst = u_alloc_line(len___0);
  }
  if ((unsigned long )dst != (unsigned long )((void *)0)) {
    {
    memmove((void *)((char *)dst), (void const   *)((char *)src), (size_t )(len___0 + 1U));
    }
  }
  return (dst);
}
}
int buf_changed(BUF *buf___3 ) 
{ 
  int tmp ;

  {
  if (buf___3->b_changed) {
    tmp = 1;
  } else { //Added block
  if ((int )*(buf___3->b_p_ff) != buf___3->b_start_ffc) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
int curbuf_changed(void) 
{ 
  int tmp ;

  {
  if (curbuf->b_changed) {
    tmp = 1;
  } else { //Added block
  if ((int )*(curbuf->b_p_ff) != curbuf->b_start_ffc) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-kWECkjeW.i","-O0")
void win_free(WIN *wp ) ;
static char_u *find_file_in_wildcard_path(char_u *path_so_far , char_u *wildcards ,
                                          int level , long *countptr ) ;
static int path_is_url(char_u *p___0 ) ;
static void reset_VIsual(void) ;
static int win_comp_pos(void) ;
static void win_exchange(long Prenum ) ;
static void win_rotate(int upwards , int count___2 ) ;
static void win_goto(WIN *wp ) ;
static void win_enter_ext(WIN *wp , int undo_sync , int curwin_invalid ) ;
static void win_append(WIN *after , WIN *wp ) ;
static void win_remove(WIN *wp ) ;
static void win_new_height(WIN *wp , int height ) ;
static WIN *prevwin  =    (WIN *)((void *)0);
void do_window(int nchar , long Prenum ) 
{ 
  long Prenum1 ;
  WIN *wp ;
  int xchar ;
  char_u *ptr ;
  int type ;
  int len___0 ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  type = 2;
  if (Prenum == 0L) {
    Prenum1 = 1L;
  } else {
    Prenum1 = Prenum;
  }
  {
  if (nchar == 83) {
    goto case_83;
  }
  if (nchar == 19) {
    goto case_83;
  }
  if (nchar == 115) {
    goto case_83;
  }
  if (nchar == 30) {
    goto case_30;
  }
  if (nchar == 94) {
    goto case_30;
  }
  if (nchar == 14) {
    goto case_14;
  }
  if (nchar == 110) {
    goto case_14;
  }
  if (nchar == 17) {
    goto case_17;
  }
  if (nchar == 113) {
    goto case_17;
  }
  if (nchar == 3) {
    goto case_3;
  }
  if (nchar == 99) {
    goto case_3;
  }
  if (nchar == 26) {
    goto case_26;
  }
  if (nchar == 122) {
    goto case_26;
  }
  if (nchar == 15) {
    goto case_15;
  }
  if (nchar == 111) {
    goto case_15;
  }
  if (nchar == 106) {
    goto case_106;
  }
  if (nchar == 107 + (100 << 8)) {
    goto case_106;
  }
  if (nchar == 10) {
    goto case_106;
  }
  if (nchar == 23) {
    goto case_23;
  }
  if (nchar == 119) {
    goto case_23;
  }
  if (nchar == 87) {
    goto case_23;
  }
  if (nchar == 107) {
    goto case_107;
  }
  if (nchar == 107 + (117 << 8)) {
    goto case_107;
  }
  if (nchar == 11) {
    goto case_107;
  }
  if (nchar == 116) {
    goto case_116;
  }
  if (nchar == 20) {
    goto case_116;
  }
  if (nchar == 98) {
    goto case_98;
  }
  if (nchar == 2) {
    goto case_98;
  }
  if (nchar == 112) {
    goto case_112;
  }
  if (nchar == 16) {
    goto case_112;
  }
  if (nchar == 120) {
    goto case_120;
  }
  if (nchar == 24) {
    goto case_120;
  }
  if (nchar == 18) {
    goto case_18;
  }
  if (nchar == 114) {
    goto case_18;
  }
  if (nchar == 82) {
    goto case_82;
  }
  if (nchar == 61) {
    goto case_61;
  }
  if (nchar == 43) {
    goto case_43;
  }
  if (nchar == 45) {
    goto case_45;
  }
  if (nchar == 31) {
    goto case_31;
  }
  if (nchar == 95) {
    goto case_31;
  }
  if (nchar == 125) {
    goto case_125;
  }
  if (nchar == 93) {
    goto case_93;
  }
  if (nchar == 29) {
    goto case_93;
  }
  if (nchar == 102) {
    goto case_102;
  }
  if (nchar == 6) {
    goto case_102;
  }
  if (nchar == 105) {
    goto case_105;
  }
  if (nchar == 9) {
    goto case_105;
  }
  if (nchar == 100) {
    goto case_100;
  }
  if (nchar == 4) {
    goto case_100;
  }
  if (nchar == 103) {
    goto case_103;
  }
  if (nchar == 7) {
    goto case_103;
  }
  goto switch_default___0;
  case_83: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_115: /* CIL Label */ 
  {
  reset_VIsual();
  win_split((int )Prenum, 1, 0);
  }
  goto switch_break;
  case_30: /* CIL Label */ 
  case_94: /* CIL Label */ 
  {
  reset_VIsual();
  stuffReadbuff((char_u *)":split #");
  }
  if (Prenum) {
    {
    stuffnumReadbuff(Prenum);
    }
  }
  {
  stuffcharReadbuff('\n');
  }
  goto switch_break;
  case_14: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
  reset_VIsual();
  stuffcharReadbuff(':');
  }
  if (Prenum) {
    {
    stuffnumReadbuff(Prenum);
    }
  }
  {
  stuffReadbuff((char_u *)"new\n");
  }
  goto switch_break;
  case_17: /* CIL Label */ 
  case_113: /* CIL Label */ 
  {
  reset_VIsual();
  stuffReadbuff((char_u *)":quit\n");
  }
  goto switch_break;
  case_3: /* CIL Label */ 
  case_99: /* CIL Label */ 
  {
  reset_VIsual();
  stuffReadbuff((char_u *)":close\n");
  }
  goto switch_break;
  case_26: /* CIL Label */ 
  case_122: /* CIL Label */ 
  {
  reset_VIsual();
  stuffReadbuff((char_u *)":pclose\n");
  }
  goto switch_break;
  case_15: /* CIL Label */ 
  case_111: /* CIL Label */ 
  {
  reset_VIsual();
  stuffReadbuff((char_u *)":only\n");
  }
  goto switch_break;
  case_106: /* CIL Label */ 
  case_exp: /* CIL Label */ 
  case_10: /* CIL Label */ 
  wp = curwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )wp->w_next != (unsigned long )((void *)0)) {
      tmp = Prenum1;
      Prenum1 --;
      if (! (tmp > 0L)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
  win_goto(wp);
  }
  goto switch_break;
  case_23: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_87: /* CIL Label */ 
  if ((unsigned long )lastwin == (unsigned long )firstwin) {
    {
    beep_flush();
    }
  } else {
    if (Prenum) {
      wp = firstwin;
      {
      while (1) {
        while_continue___0: /* CIL Label */ ;
        Prenum --;
        if (! (Prenum > 0L)) {
          goto while_break___0;
        }
        if ((unsigned long )wp->w_next == (unsigned long )((void *)0)) {
          goto while_break___0;
        } else {
          wp = wp->w_next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else { //Added block
    if (nchar == 87) {
      wp = curwin->w_prev;
      if ((unsigned long )wp == (unsigned long )((void *)0)) {
        wp = lastwin;
      }
    } else {
      wp = curwin->w_next;
      if ((unsigned long )wp == (unsigned long )((void *)0)) {
        wp = firstwin;
      }
    }
    }
    {
    win_goto(wp);
    }
  }
  goto switch_break;
  case_107: /* CIL Label */ 
  case_exp___0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  wp = curwin;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if ((unsigned long )wp->w_prev != (unsigned long )((void *)0)) {
      tmp___0 = Prenum1;
      Prenum1 --;
      if (! (tmp___0 > 0L)) {
        goto while_break___1;
      }
    } else {
      goto while_break___1;
    }
    wp = wp->w_prev;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  win_goto(wp);
  }
  goto switch_break;
  case_116: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
  wp = firstwin;
  win_goto(wp);
  }
  goto switch_break;
  case_98: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
  wp = lastwin;
  win_goto(wp);
  }
  goto switch_break;
  case_112: /* CIL Label */ 
  case_16: /* CIL Label */ 
  if ((unsigned long )prevwin == (unsigned long )((void *)0)) {
    {
    beep_flush();
    }
  } else {
    {
    wp = prevwin;
    win_goto(wp);
    }
  }
  goto switch_break;
  case_120: /* CIL Label */ 
  case_24: /* CIL Label */ 
  {
  win_exchange(Prenum);
  }
  goto switch_break;
  case_18: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
  reset_VIsual();
  win_rotate(0, (int )Prenum1);
  }
  goto switch_break;
  case_82: /* CIL Label */ 
  {
  reset_VIsual();
  win_rotate(1, (int )Prenum1);
  }
  goto switch_break;
  case_61: /* CIL Label */ 
  {
  win_equal((WIN *)((void *)0), 1);
  }
  goto switch_break;
  case_43: /* CIL Label */ 
  {
  win_setheight(curwin->w_height + (int )Prenum1);
  }
  goto switch_break;
  case_45: /* CIL Label */ 
  {
  win_setheight(curwin->w_height - (int )Prenum1);
  }
  goto switch_break;
  case_31: /* CIL Label */ 
  case_95: /* CIL Label */ 
  if (Prenum) {
    tmp___1 = (int )Prenum;
  } else {
    tmp___1 = 9999;
  }
  {
  win_setheight(tmp___1);
  }
  goto switch_break;
  case_125: /* CIL Label */ 
  if (Prenum) {
    g_do_tagpreview = (int )Prenum;
  } else {
    g_do_tagpreview = (int )p_pvh;
  }
  case_93: /* CIL Label */ 
  case_29: /* CIL Label */ 
  {
  reset_VIsual();
  }
  if (Prenum) {
    postponed_split = (int )Prenum;
  } else {
    postponed_split = -1;
  }
  {
  stuffcharReadbuff(29);
  }
  goto switch_break;
  case_102: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
  reset_VIsual();
  ptr = file_name_at_cursor(7, Prenum1);
  }
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
    setpcmark();
    tmp___2 = win_split(0, 0, 0);
    }
    if (tmp___2 == 1) {
      {
      do_ecmd(0, ptr, (char_u *)((void *)0), (char_u *)((void *)0), (linenr_t )0,
              1);
      }
    }
    {
    vim_free((void *)ptr);
    }
  }
  goto switch_break;
  case_105: /* CIL Label */ 
  case_9: /* CIL Label */ 
  type = 1;
  case_100: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
  len___0 = find_ident_under_cursor(& ptr, 1);
  }
  if (len___0 == 0) {
    goto switch_break;
  }
  if (Prenum == 0L) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  {
  find_pattern_in_path(ptr, 0, len___0, 1, tmp___3, type, Prenum1, 3, (linenr_t )1,
                       (linenr_t )2147483647);
  curwin->w_set_curswant = 1;
  }
  goto switch_break;
  case_103: /* CIL Label */ 
  case_7: /* CIL Label */ 
  {
  no_mapping ++;
  allow_keys ++;
  xchar = safe_vgetc();
  no_mapping --;
  allow_keys --;
  add_to_showcmd(xchar);
  }
  {
  if (xchar == 125) {
    goto case_125___0;
  }
  if (xchar == 93) {
    goto case_93___0;
  }
  if (xchar == 29) {
    goto case_93___0;
  }
  goto switch_default;
  case_125___0: /* CIL Label */ 
  xchar = 29;
  if (Prenum) {
    g_do_tagpreview = (int )Prenum;
  } else {
    g_do_tagpreview = (int )p_pvh;
  }
  case_93___0: /* CIL Label */ 
  case_29___0: /* CIL Label */ 
  {
  reset_VIsual();
  }
  if (Prenum) {
    postponed_split = (int )Prenum;
  } else {
    postponed_split = -1;
  }
  {
  stuffcharReadbuff('g');
  stuffcharReadbuff(xchar);
  }
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
  beep_flush();
  }
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
  beep_flush();
  }
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
static void reset_VIsual(void) 
{ 


  {
  if (VIsual_active) {
    {
    end_visual_mode();
    update_curbuf(40);
    }
  }
  VIsual_reselect = 0;
  return;
}
}
int win_split(int new_height , int redraw , int req_room ) 
{ 
  WIN *wp ;
  int i___0 ;
  int need_status ;
  int do_equal ;
  int tmp ;
  int needed ;
  int available ;
  int curwin_height ;

  {
  if (p_ea) {
    if (new_height == 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  do_equal = tmp;
  if ((unsigned long )lastwin == (unsigned long )firstwin) {
    if (p_ls == 1L) {
      if (curwin->w_status_height == 0) {
        need_status = 1;
      } else {
        need_status = 0;
      }
    } else {
      need_status = 0;
    }
  } else {
    need_status = 0;
  }
  available = curwin->w_height;
  needed = (int )((2L * p_wmh + 1L) + (long )need_status);
  if (req_room) {
    needed = (int )((long )needed + (p_wh - p_wmh));
  }
  if (p_ea) {
    wp = firstwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if ((unsigned long )wp != (unsigned long )curwin) {
        available += wp->w_height;
        needed = (int )((long )needed + p_wmh);
      }
      wp = wp->w_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  if (available < needed) {
    {
    emsg(e_noroom);
    }
    return (0);
  }
  curwin_height = curwin->w_height;
  if (need_status) {
    curwin->w_status_height = 1;
    curwin_height --;
  }
  if (new_height == 0) {
    new_height = curwin_height / 2;
  }
  if ((long )new_height > ((long )curwin_height - p_wmh) - 1L) {
    new_height = (int )(((long )curwin_height - p_wmh) - 1L);
  }
  if ((long )new_height < p_wmh) {
    new_height = (int )p_wmh;
  }
  if ((long )((curwin_height - new_height) - 1) < p_wmh) {
    do_equal = 1;
  }
  if (p_sb) {
    {
    wp = win_alloc(curwin);
    }
  } else {
    {
    wp = win_alloc(curwin->w_prev);
    }
  }
  if ((unsigned long )wp == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  win_new_height(wp, new_height);
  win_new_height(curwin, curwin_height - (new_height + 1));
  }
  if (p_sb) {
    wp->w_winpos = (curwin->w_winpos + curwin->w_height) + 1;
    wp->w_status_height = curwin->w_status_height;
    curwin->w_status_height = 1;
  } else {
    wp->w_winpos = curwin->w_winpos;
    wp->w_status_height = 1;
    curwin->w_winpos = (wp->w_winpos + wp->w_height) + 1;
  }
  wp->w_buffer = curbuf;
  (curbuf->b_nwindows) ++;
  wp->w_cursor = curwin->w_cursor;
  wp->w_valid = 0;
  wp->w_curswant = curwin->w_curswant;
  wp->w_set_curswant = curwin->w_set_curswant;
  wp->w_topline = curwin->w_topline;
  wp->w_leftcol = curwin->w_leftcol;
  wp->w_pcmark = curwin->w_pcmark;
  wp->w_prev_pcmark = curwin->w_prev_pcmark;
  wp->w_alt_fnum = curwin->w_alt_fnum;
  wp->w_fraction = curwin->w_fraction;
  wp->w_prev_fraction_row = curwin->w_prev_fraction_row;
  wp->w_arg_idx = curwin->w_arg_idx;
  i___0 = 0;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i___0 < curwin->w_tagstacklen)) {
      goto while_break___0;
    }
    wp->w_tagstack[i___0] = curwin->w_tagstack[i___0];
    if ((unsigned long )wp->w_tagstack[i___0].tagname != (unsigned long )((void *)0)) {
      {
      wp->w_tagstack[i___0].tagname = vim_strsave(wp->w_tagstack[i___0].tagname);
      }
    }
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  wp->w_tagstackidx = curwin->w_tagstackidx;
  wp->w_tagstacklen = curwin->w_tagstacklen;
  win_copy_options(curwin, wp);
  wp->w_redr_type = 40;
  wp->w_redr_status = 1;
  curwin->w_redr_type = 40;
  curwin->w_redr_status = 1;
  }
  if (need_status) {
    {
    msg_row = (int )(Rows - 1L);
    msg_col = sc_col;
    msg_clr_eos();
    comp_col();
    msg_row = (int )(Rows - 1L);
    msg_col = 0;
    }
  }
  if (do_equal) {
    {
    win_equal(wp, 0);
    }
  }
  {
  win_enter(wp, 0);
  }
  if (redraw) {
    {
    update_screen(40);
    }
  } else {
    {
    redraw_later(40);
    }
  }
  return (1);
}
}
int win_valid(WIN *win ) 
{ 
  WIN *wp ;

  {
  if ((unsigned long )win == (unsigned long )((void *)0)) {
    return (0);
  }
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )wp == (unsigned long )win) {
      return (1);
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (0);
}
}
int win_count(void) 
{ 
  WIN *wp ;
  int count___2 ;

  {
  count___2 = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    count___2 ++;
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (count___2);
}
}
int make_windows(int count___2 ) 
{ 
  int maxcount ;
  int todo ;
  int p_sb_save ;
  int tmp ;

  {
  maxcount = (int )(((long )(curwin->w_height + curwin->w_status_height) - (p_wh - p_wmh)) / (p_wmh + 1L));
  if (maxcount < 2) {
    maxcount = 2;
  }
  if (count___2 > maxcount) {
    count___2 = maxcount;
  }
  if (p_ls == 2L) {
    goto _L;
  } else { //Added block
  if (count___2 > 1) {
    if (p_ls == 1L) {
      _L: 
      if (curwin->w_status_height == 0) {
        {
        curwin->w_status_height = 1;
        win_new_height(curwin, curwin->w_height - 1);
        }
      }
    }
  }
  }
  autocmd_busy ++;
  p_sb_save = p_sb;
  p_sb = 0;
  todo = count___2 - 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (todo > 0)) {
      goto while_break;
    }
    {
    tmp = win_split((curwin->w_height - (curwin->w_height - todo) / (todo + 1)) - 1,
                    0, 0);
    }
    if (tmp == 0) {
      goto while_break;
    }
    todo --;
  }
  while_break: /* CIL Label */ ;
  }
  p_sb = p_sb_save;
  autocmd_busy --;
  return (count___2 - todo);
}
}
static void win_exchange(long Prenum ) 
{ 
  WIN *wp ;
  WIN *wp2 ;
  int temp ;

  {
  if ((unsigned long )lastwin == (unsigned long )firstwin) {
    {
    beep_flush();
    }
    return;
  }
  if (Prenum) {
    wp = firstwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if ((unsigned long )wp != (unsigned long )((void *)0)) {
        Prenum --;
        if (! (Prenum > 0L)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      wp = wp->w_next;
    }
    while_break: /* CIL Label */ ;
    }
  } else { //Added block
  if ((unsigned long )curwin->w_next != (unsigned long )((void *)0)) {
    wp = curwin->w_next;
  } else {
    wp = curwin->w_prev;
  }
  }
  if ((unsigned long )wp == (unsigned long )curwin) {
    return;
  } else { //Added block
  if ((unsigned long )wp == (unsigned long )((void *)0)) {
    return;
  }
  }
  {
  wp2 = curwin->w_prev;
  win_remove(curwin);
  win_append(wp->w_prev, curwin);
  }
  if ((unsigned long )wp != (unsigned long )wp2) {
    {
    win_remove(wp);
    win_append(wp2, wp);
    }
  }
  {
  temp = curwin->w_status_height;
  curwin->w_status_height = wp->w_status_height;
  wp->w_status_height = temp;
  win_comp_pos();
  win_enter(wp, 1);
  update_screen(50);
  }
  return;
}
}
static void win_rotate(int upwards , int count___2 ) 
{ 
  WIN *wp ;
  int height ;
  int tmp ;

  {
  if ((unsigned long )firstwin == (unsigned long )lastwin) {
    {
    beep_flush();
    }
    return;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    tmp = count___2;
    count___2 --;
    if (! tmp) {
      goto while_break;
    }
    if (upwards) {
      {
      wp = firstwin;
      win_remove(wp);
      win_append(lastwin, wp);
      wp = lastwin->w_prev;
      }
    } else {
      {
      wp = lastwin;
      win_remove(lastwin);
      win_append((WIN *)((void *)0), wp);
      wp = firstwin;
      }
    }
    {
    height = lastwin->w_status_height;
    lastwin->w_status_height = wp->w_status_height;
    wp->w_status_height = height;
    win_comp_pos();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  update_screen(50);
  }
  return;
}
}
void win_move_after(WIN *win1 , WIN *win2 ) 
{ 
  int height ;

  {
  if ((unsigned long )win1 == (unsigned long )win2) {
    return;
  }
  if ((unsigned long )win2->w_next != (unsigned long )win1) {
    if ((unsigned long )win1 == (unsigned long )lastwin) {
      height = (win1->w_prev)->w_status_height;
      (win1->w_prev)->w_status_height = win1->w_status_height;
      win1->w_status_height = height;
    } else { //Added block
    if ((unsigned long )win2 == (unsigned long )lastwin) {
      height = win1->w_status_height;
      win1->w_status_height = win2->w_status_height;
      win2->w_status_height = height;
    }
    }
    {
    win_remove(win1);
    win_append(win2, win1);
    win_comp_pos();
    redraw_later(40);
    }
  }
  {
  win_enter(win1, 0);
  }
  return;
}
}
void win_equal(WIN *next_curwin , int redraw ) 
{ 
  int total ;
  int less ;
  int wincount ;
  int winpos ;
  int temp ;
  WIN *wp ;
  int new_height ;

  {
  total = 0;
  wincount = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    total = (int )((long )total + ((long )wp->w_height - p_wmh));
    wincount ++;
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  less = 0;
  if ((unsigned long )next_curwin != (unsigned long )((void *)0)) {
    if (p_wh - p_wmh > (long )total) {
      less = total;
    } else {
      less = (int )((p_wh - p_wmh) - (long )(total / wincount));
      if (less < 0) {
        less = 0;
      }
    }
  }
  winpos = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    if ((unsigned long )wp == (unsigned long )next_curwin) {
      if (less) {
        less = 0;
        temp = (int )(p_wh - p_wmh);
        if (temp > total) {
          temp = total;
        }
      } else {
        temp = (int )(((unsigned int )(total - less) + ((unsigned int )wincount >> 1)) / (unsigned int )wincount);
      }
    } else {
      temp = (int )(((unsigned int )(total - less) + ((unsigned int )wincount >> 1)) / (unsigned int )wincount);
    }
    new_height = (int )(p_wmh + (long )temp);
    if (wp->w_winpos != winpos) {
      wp->w_redr_type = 40;
      wp->w_redr_status = 1;
    } else { //Added block
    if (wp->w_height != new_height) {
      wp->w_redr_type = 40;
      wp->w_redr_status = 1;
    }
    }
    {
    wp->w_winpos = winpos;
    win_new_height(wp, new_height);
    total -= temp;
    wincount --;
    winpos += wp->w_height + wp->w_status_height;
    wp = wp->w_next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  if (redraw) {
    must_redraw = 50;
  }
  return;
}
}
void close_windows(BUF *buf___3 ) 
{ 
  WIN *win ;

  {
  RedrawingDisabled ++;
  win = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((unsigned long )win != (unsigned long )((void *)0)) {
      if (! ((unsigned long )lastwin != (unsigned long )firstwin)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((unsigned long )win->w_buffer == (unsigned long )buf___3) {
      {
      close_window(win, 0);
      win = firstwin;
      }
    } else {
      win = win->w_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  RedrawingDisabled --;
  return;
}
}
void close_window(WIN *win , int free_buf ) 
{ 
  WIN *wp ;
  int other_buffer ;
  int close_curwin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  other_buffer = 0;
  close_curwin = 0;
  if ((unsigned long )lastwin == (unsigned long )firstwin) {
    {
    emsg((char_u *)"Cannot close last window");
    }
    return;
  }
  if ((unsigned long )win == (unsigned long )curwin) {
    if (! p_sb) {
      if ((unsigned long )win->w_next != (unsigned long )((void *)0)) {
        wp = win->w_next;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: 
    if ((unsigned long )win->w_prev == (unsigned long )((void *)0)) {
      wp = win->w_next;
    } else {
      wp = win->w_prev;
    }
    }
    if ((unsigned long )wp->w_buffer != (unsigned long )curbuf) {
      {
      other_buffer = 1;
      apply_autocmds((EVENT_T )5, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      tmp = win_valid(win);
      }
      if (tmp) {
        if ((unsigned long )firstwin == (unsigned long )lastwin) {
          return;
        }
      } else {
        return;
      }
    }
    {
    apply_autocmds((EVENT_T )37, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                   curbuf);
    tmp___0 = win_valid(win);
    }
    if (tmp___0) {
      if ((unsigned long )firstwin == (unsigned long )lastwin) {
        return;
      }
    } else {
      return;
    }
  }
  if (! p_sb) {
    if ((unsigned long )win->w_next != (unsigned long )((void *)0)) {
      wp = win->w_next;
      wp->w_winpos = win->w_winpos;
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: 
  if ((unsigned long )win->w_prev == (unsigned long )((void *)0)) {
    wp = win->w_next;
    wp->w_winpos = win->w_winpos;
  } else {
    wp = win->w_prev;
  }
  }
  {
  close_buffer(win, win->w_buffer, free_buf, 0);
  tmp___1 = win_valid(win);
  }
  if (tmp___1) {
    if ((unsigned long )firstwin == (unsigned long )lastwin) {
      return;
    }
  } else {
    return;
  }
  {
  win_new_height(wp, (wp->w_height + win->w_height) + win->w_status_height);
  win_free(win);
  }
  if ((unsigned long )win == (unsigned long )curwin) {
    curwin = wp;
    curbuf = wp->w_buffer;
    close_curwin = 1;
  }
  if (p_ea) {
    {
    win_equal(wp, 0);
    }
  }
  if (close_curwin) {
    {
    win_enter_ext(wp, 0, 1);
    }
    if (other_buffer) {
      {
      apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      }
    }
  }
  if (lastwin->w_status_height) {
    if (p_ls == 0L) {
      {
      win_new_height(lastwin, lastwin->w_height + lastwin->w_status_height);
      lastwin->w_status_height = 0;
      comp_col();
      }
    } else { //Added block
    if (p_ls == 1L) {
      if ((unsigned long )firstwin == (unsigned long )lastwin) {
        {
        win_new_height(lastwin, lastwin->w_height + lastwin->w_status_height);
        lastwin->w_status_height = 0;
        comp_col();
        }
      }
    }
    }
  }
  {
  update_screen(40);
  }
  return;
}
}
void close_others(int message , int forceit ) 
{ 
  WIN *wp ;
  WIN *nextwp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )lastwin == (unsigned long )firstwin) {
    if (message) {
      if (! autocmd_busy) {
        {
        msg((char_u *)"Already only one window");
        }
      }
    }
    return;
  }
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___4 = win_valid(wp);
    }
    if (! tmp___4) {
      goto while_break;
    }
    nextwp = wp->w_next;
    if ((unsigned long )wp == (unsigned long )curwin) {
      goto __Cont;
    }
    {
    tmp___0 = can_abandon(wp->w_buffer, forceit);
    }
    if (! tmp___0) {
      if (message) {
        if (p_confirm) {
          {
          dialog_changed(wp->w_buffer, 0);
          }
        } else { //Added block
        if (confirm) {
          {
          dialog_changed(wp->w_buffer, 0);
          }
        }
        }
      }
      {
      tmp = buf_changed(wp->w_buffer);
      }
      if (tmp) {
        goto __Cont;
      }
    }
    if (! p_hid) {
      {
      tmp___1 = buf_changed(wp->w_buffer);
      }
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
    } else {
      tmp___2 = 0;
    }
    {
    close_buffer(wp, wp->w_buffer, tmp___2, 0);
    tmp___3 = win_valid(wp);
    }
    if (! tmp___3) {
      goto __Cont;
    }
    if ((unsigned long )wp->w_prev != (unsigned long )((void *)0)) {
      {
      win_new_height(wp->w_prev, ((wp->w_prev)->w_height + wp->w_height) + wp->w_status_height);
      }
    } else {
      {
      win_new_height(wp->w_next, ((wp->w_next)->w_height + wp->w_height) + wp->w_status_height);
      (wp->w_next)->w_winpos = wp->w_winpos;
      }
    }
    {
    win_free(wp);
    }
    __Cont: 
    wp = nextwp;
  }
  while_break: /* CIL Label */ ;
  }
  if ((unsigned long )lastwin != (unsigned long )firstwin) {
    {
    emsg((char_u *)"Other window contains changes");
    }
  } else { //Added block
  if (curwin->w_status_height) {
    if (p_ls != 2L) {
      {
      win_new_height(curwin, curwin->w_height + curwin->w_status_height);
      curwin->w_status_height = 0;
      comp_col();
      }
    }
  }
  }
  if (message) {
    {
    update_screen(40);
    }
  }
  return;
}
}
void win_init(WIN *wp ) 
{ 
  colnr_t tmp ;

  {
  wp->w_redr_type = 40;
  wp->w_cursor.lnum = (linenr_t )1;
  tmp = (colnr_t )0;
  wp->w_cursor.col = tmp;
  wp->w_curswant = tmp;
  wp->w_pcmark.lnum = (linenr_t )1;
  wp->w_pcmark.col = (colnr_t )0;
  wp->w_prev_pcmark.lnum = (linenr_t )0;
  wp->w_prev_pcmark.col = (colnr_t )0;
  wp->w_topline = (linenr_t )1;
  wp->w_botline = (linenr_t )2;
  return;
}
}
static void win_goto(WIN *wp ) 
{ 


  {
  if ((unsigned long )wp->w_buffer != (unsigned long )curbuf) {
    if (VIsual_active) {
      {
      end_visual_mode();
      redraw_curbuf_later(40);
      }
    }
  }
  {
  VIsual_reselect = 0;
  win_enter(wp, 1);
  }
  return;
}
}
void win_enter(WIN *wp , int undo_sync ) 
{ 


  {
  {
  win_enter_ext(wp, undo_sync, 0);
  }
  return;
}
}
static void win_enter_ext(WIN *wp , int undo_sync , int curwin_invalid ) 
{ 
  int other_buffer ;
  int tmp ;
  int tmp___0 ;

  {
  other_buffer = 0;
  if ((unsigned long )wp == (unsigned long )curwin) {
    if (! curwin_invalid) {
      return;
    }
  }
  if (! curwin_invalid) {
    if ((unsigned long )wp->w_buffer != (unsigned long )curbuf) {
      {
      apply_autocmds((EVENT_T )5, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      other_buffer = 1;
      tmp = win_valid(wp);
      }
      if (! tmp) {
        return;
      }
    }
    {
    apply_autocmds((EVENT_T )37, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                   curbuf);
    tmp___0 = win_valid(wp);
    }
    if (! tmp___0) {
      return;
    }
  }
  if (undo_sync) {
    if ((unsigned long )curbuf != (unsigned long )wp->w_buffer) {
      {
      u_sync();
      }
    }
  }
  if ((unsigned long )wp->w_buffer != (unsigned long )curbuf) {
    {
    buf_copy_options(curbuf, wp->w_buffer, 5);
    }
  }
  if (! curwin_invalid) {
    prevwin = curwin;
    curwin->w_redr_status = 1;
  }
  {
  curwin = wp;
  curbuf = wp->w_buffer;
  adjust_cursor();
  changed_line_abv_curs();
  apply_autocmds((EVENT_T )36, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if (other_buffer) {
    {
    apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
    }
  }
  {
  maketitle();
  curwin->w_redr_status = 1;
  }
  if (restart_edit) {
    {
    redraw_later(10);
    }
  }
  if ((long )curwin->w_height < p_wh) {
    {
    win_setheight((int )p_wh);
    }
  }
  {
  setmouse();
  }
  return;
}
}
WIN *buf_jump_open_win(BUF *buf___3 ) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if ((unsigned long )wp->w_buffer == (unsigned long )buf___3) {
      goto while_break;
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  if (wp) {
    {
    win_enter(wp, 0);
    }
  }
  return (wp);
}
}
WIN *win_alloc(WIN *after ) 
{ 
  WIN *newwin ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = alloc_clear((unsigned int )sizeof(WIN ));
  newwin = (WIN *)tmp;
  }
  if ((unsigned long )newwin != (unsigned long )((void *)0)) {
    {
    tmp___0 = win_alloc_lsize(newwin);
    }
    if (tmp___0 == 0) {
      {
      vim_free((void *)newwin);
      newwin = (WIN *)((void *)0);
      }
    }
  }
  if ((unsigned long )newwin != (unsigned long )((void *)0)) {
    {
    win_append(after, newwin);
    newwin->w_topline = (linenr_t )1;
    newwin->w_botline = (linenr_t )2;
    newwin->w_cursor.lnum = (linenr_t )1;
    newwin->w_scbind_pos = 1L;
    newwin->w_fraction = 0;
    newwin->w_prev_fraction_row = -1;
    var_init(& newwin->w_vars);
    }
  }
  return (newwin);
}
}
void win_free(WIN *wp ) 
{ 
  int i___0 ;

  {
  {
  var_clear(& wp->w_vars);
  }
  if ((unsigned long )prevwin == (unsigned long )wp) {
    prevwin = (WIN *)((void *)0);
  }
  {
  win_free_lsize(wp);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i___0 < wp->w_tagstacklen)) {
      goto while_break;
    }
    {
    vim_free((void *)wp->w_tagstack[i___0].tagname);
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  win_remove(wp);
  vim_free((void *)wp);
  }
  return;
}
}
static void win_append(WIN *after , WIN *wp ) 
{ 
  WIN *before ;

  {
  if ((unsigned long )after == (unsigned long )((void *)0)) {
    before = firstwin;
  } else {
    before = after->w_next;
  }
  wp->w_next = before;
  wp->w_prev = after;
  if ((unsigned long )after == (unsigned long )((void *)0)) {
    firstwin = wp;
  } else {
    after->w_next = wp;
  }
  if ((unsigned long )before == (unsigned long )((void *)0)) {
    lastwin = wp;
  } else {
    before->w_prev = wp;
  }
  return;
}
}
static void win_remove(WIN *wp ) 
{ 


  {
  if (wp->w_prev) {
    (wp->w_prev)->w_next = wp->w_next;
  } else {
    firstwin = wp->w_next;
  }
  if (wp->w_next) {
    (wp->w_next)->w_prev = wp->w_prev;
  } else {
    lastwin = wp->w_prev;
  }
  return;
}
}
int win_alloc_lsize(WIN *wp ) 
{ 
  char_u *tmp ;

  {
  {
  wp->w_lsize_valid = 0;
  tmp = alloc((unsigned int )((unsigned long )Rows * sizeof(linenr_t )));
  wp->w_lsize_lnum = (linenr_t *)tmp;
  wp->w_lsize = alloc((unsigned int )Rows);
  }
  if ((unsigned long )wp->w_lsize_lnum == (unsigned long )((void *)0)) {
    {
    win_free_lsize(wp);
    }
    return (0);
  } else { //Added block
  if ((unsigned long )wp->w_lsize == (unsigned long )((void *)0)) {
    {
    win_free_lsize(wp);
    }
    return (0);
  }
  }
  return (1);
}
}
void win_free_lsize(WIN *wp ) 
{ 


  {
  {
  vim_free((void *)wp->w_lsize_lnum);
  vim_free((void *)wp->w_lsize);
  wp->w_lsize_lnum = (linenr_t *)((void *)0);
  wp->w_lsize = (char_u *)((void *)0);
  }
  return;
}
}
void screen_new_rows(void) 
{ 
  WIN *wp ;
  int extra_lines ;

  {
  if ((unsigned long )firstwin == (unsigned long )((void *)0)) {
    return;
  }
  extra_lines = (int )((Rows - p_ch) - (long )((lastwin->w_winpos + lastwin->w_height) + lastwin->w_status_height));
  if (extra_lines < 0) {
    wp = lastwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! wp) {
        goto while_break;
      }
      if ((long )wp->w_height - p_wmh < (long )(- extra_lines)) {
        {
        extra_lines = (int )((long )extra_lines + ((long )wp->w_height - p_wmh));
        win_new_height(wp, (int )p_wmh);
        }
      } else {
        {
        win_new_height(wp, wp->w_height + extra_lines);
        }
        goto while_break;
      }
      wp = wp->w_prev;
    }
    while_break: /* CIL Label */ ;
    }
    {
    win_comp_pos();
    }
  } else { //Added block
  if (extra_lines > 0) {
    {
    win_new_height(lastwin, lastwin->w_height + extra_lines);
    }
  }
  }
  {
  compute_cmdrow();
  }
  if (p_ea) {
    {
    win_equal(curwin, 0);
    }
  }
  return;
}
}
static int win_comp_pos(void) 
{ 
  WIN *wp ;
  int row ;

  {
  row = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (wp->w_winpos != row) {
      wp->w_winpos = row;
      wp->w_redr_type = 40;
      wp->w_redr_status = 1;
    }
    row += wp->w_height + wp->w_status_height;
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (row);
}
}
void win_setheight(int height ) 
{ 
  WIN *wp ;
  int room ;
  int take ;
  int room_cmdline ;
  int row ;
  int run ;

  {
  if (p_wmh == 0L) {
    if (height <= 0) {
      height = 1;
      room = 1;
    } else {
      room = (int )p_wmh;
    }
  } else {
    if ((long )height < p_wmh) {
      height = (int )p_wmh;
    }
    room = (int )p_wmh;
  }
  room_cmdline = (int )(Rows - p_ch);
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    room = (int )((long )room + ((long )wp->w_height - p_wmh));
    room_cmdline -= wp->w_height + wp->w_status_height;
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  if (height > room + room_cmdline) {
    height = room + room_cmdline;
  }
  take = height - curwin->w_height;
  if (take == 0) {
    return;
  }
  if (take > 0) {
    take -= room_cmdline;
    if (take < 0) {
      take = 0;
    }
  }
  {
  win_new_height(curwin, height);
  run = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (run < 2)) {
      goto while_break___0;
    }
    if (run == 0) {
      wp = curwin->w_next;
    } else {
      wp = curwin->w_prev;
    }
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if ((unsigned long )wp != (unsigned long )((void *)0)) {
        if (! (take != 0)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      if ((long )(wp->w_height - take) < p_wmh) {
        {
        take = (int )((long )take - ((long )wp->w_height - p_wmh));
        win_new_height(wp, (int )p_wmh);
        }
      } else {
        {
        win_new_height(wp, wp->w_height - take);
        take = 0;
        }
      }
      if (run == 0) {
        wp = wp->w_next;
      } else {
        wp = wp->w_prev;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    run ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  row = win_comp_pos();
  }
  if (full_screen) {
    if (msg_scrolled == 0) {
      {
      screen_fill(row, cmdline_row, 0, (int )Columns, ' ', ' ', 0);
      }
    }
  }
  {
  cmdline_row = row;
  msg_row = row;
  msg_col = 0;
  update_screen(40);
  }
  return;
}
}
void win_setminheight(void) 
{ 
  int room ;
  int first___0 ;
  WIN *wp ;

  {
  first___0 = 1;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (p_wmh > 0L)) {
      goto while_break;
    }
    room = (int )(- p_wh);
    wp = firstwin;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      room = (int )((long )room + ((long )wp->w_height - p_wmh));
      wp = wp->w_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    if (room >= 0) {
      goto while_break;
    }
    p_wmh --;
    if (first___0) {
      {
      emsg(e_noroom);
      first___0 = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void win_drag_status_line(int offset ) 
{ 
  WIN *wp ;
  int room ;
  int row ;
  int up ;

  {
  if (offset < 0) {
    up = 1;
    offset = - offset;
  } else {
    up = 0;
  }
  if (up) {
    if (p_wmh == 0L) {
      room = -1;
    } else {
      room = 0;
    }
    wp = curwin;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if ((unsigned long )wp != (unsigned long )((void *)0)) {
        if (! (room < offset)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      room = (int )((long )room + ((long )wp->w_height - p_wmh));
      wp = wp->w_prev;
    }
    while_break: /* CIL Label */ ;
    }
    wp = curwin->w_next;
  } else {
    room = (int )(Rows - (long )cmdline_row);
    if ((unsigned long )curwin->w_next == (unsigned long )((void *)0)) {
      room --;
    } else {
      room = (int )((long )room - p_ch);
    }
    wp = curwin->w_next;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if ((unsigned long )wp != (unsigned long )((void *)0)) {
        if (! (room < offset)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      room = (int )((long )room + ((long )wp->w_height - p_wmh));
      wp = wp->w_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    wp = curwin;
  }
  if (room < offset) {
    offset = room;
  }
  if (offset <= 0) {
    return;
  }
  if ((unsigned long )wp != (unsigned long )((void *)0)) {
    {
    win_new_height(wp, wp->w_height + offset);
    }
  }
  if (up) {
    wp = curwin;
  } else {
    wp = curwin->w_next;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if ((unsigned long )wp != (unsigned long )((void *)0)) {
      if (! (offset > 0)) {
        goto while_break___1;
      }
    } else {
      goto while_break___1;
    }
    if ((long )(wp->w_height - offset) <= p_wmh) {
      offset = (int )((long )offset - ((long )wp->w_height - p_wmh));
      if ((unsigned long )wp == (unsigned long )curwin) {
        if (p_wmh == 0L) {
          {
          win_new_height(wp, 1);
          offset ++;
          }
        } else {
          {
          win_new_height(wp, (int )p_wmh);
          }
        }
      } else {
        {
        win_new_height(wp, (int )p_wmh);
        }
      }
    } else {
      {
      win_new_height(wp, wp->w_height - offset);
      offset = 0;
      }
    }
    if (up) {
      wp = wp->w_prev;
    } else {
      wp = wp->w_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  row = win_comp_pos();
  screen_fill(row, cmdline_row, 0, (int )Columns, ' ', ' ', 0);
  cmdline_row = row;
  p_ch = Rows - (long )cmdline_row;
  update_screen(40);
  showmode();
  }
  return;
}
}
static void win_new_height(WIN *wp , int height ) 
{ 
  linenr_t lnum ;
  int sline ;
  int line_size ;
  int tmp ;

  {
  if (wp->w_wrow != wp->w_prev_fraction_row) {
    if (wp->w_height > 0) {
      wp->w_fraction = (int )(((long )wp->w_wrow * 16384L + 8192L) / (long )wp->w_height);
    }
  }
  wp->w_height = height;
  wp->w_skipcol = (colnr_t )0;
  lnum = wp->w_cursor.lnum;
  if (lnum < 1L) {
    lnum = (linenr_t )1;
  }
  {
  wp->w_wrow = (int )(((long )wp->w_fraction * (long )height - 1L) / 16384L);
  tmp = plines_win_col(wp, lnum, (long )wp->w_cursor.col);
  line_size = tmp - 1;
  sline = wp->w_wrow - line_size;
  }
  if (sline < 0) {
    wp->w_wrow = line_size;
  } else {
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (sline > 0) {
        if (! (lnum > 1L)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      {
      lnum --;
      line_size = plines_win(wp, lnum);
      sline -= line_size;
      }
    }
    while_break: /* CIL Label */ ;
    }
    if (sline < 0) {
      lnum ++;
      wp->w_wrow -= line_size + sline;
    } else { //Added block
    if (sline > 0) {
      lnum = (linenr_t )1;
      wp->w_wrow -= sline;
    }
    }
  }
  {
  set_topline(wp, lnum);
  }
  if ((unsigned long )wp == (unsigned long )curwin) {
    if (p_so) {
      {
      update_topline();
      }
    }
    {
    curs_columns(0);
    }
  }
  {
  wp->w_prev_fraction_row = wp->w_wrow;
  win_comp_scroll(wp);
  }
  if (wp->w_redr_type < 40) {
    wp->w_redr_type = 40;
  }
  {
  wp->w_redr_status = 1;
  invalidate_botline_win(wp);
  }
  return;
}
}
void win_comp_scroll(WIN *wp ) 
{ 


  {
  wp->w_p_scroll = (long )((unsigned int )wp->w_height >> 1);
  if (wp->w_p_scroll == 0L) {
    wp->w_p_scroll = 1L;
  }
  return;
}
}
void command_height(long old_p_ch ) 
{ 
  WIN *wp ;
  int h ;

  {
  if (starting != 2) {
    cmdline_row = (int )(Rows - p_ch);
    if (p_ch > old_p_ch) {
      wp = lastwin;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! (p_ch > old_p_ch)) {
          goto while_break;
        }
        if ((unsigned long )wp == (unsigned long )((void *)0)) {
          {
          emsg(e_noroom);
          p_ch = old_p_ch;
          }
          goto while_break;
        }
        h = (int )((long )wp->w_height - (p_ch - old_p_ch));
        if (p_wmh == 0L) {
          if ((unsigned long )wp == (unsigned long )curwin) {
            if (h < 1) {
              h = 1;
            }
          }
        } else { //Added block
        if ((long )h < p_wmh) {
          h = (int )p_wmh;
        }
        }
        {
        old_p_ch += (long )(wp->w_height - h);
        win_new_height(wp, h);
        wp = wp->w_prev;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
      win_comp_pos();
      }
      if (full_screen) {
        {
        screen_fill(cmdline_row, (int )Rows, 0, (int )Columns, ' ', ' ', 0);
        }
      }
      msg_row = cmdline_row;
      redraw_cmdline = 1;
      return;
    }
    if (msg_row < cmdline_row) {
      msg_row = cmdline_row;
    }
    redraw_cmdline = 1;
  }
  {
  win_new_height(lastwin, (int )(((long )lastwin->w_height + old_p_ch) - p_ch));
  }
  return;
}
}
void last_status(void) 
{ 
  WIN *wp ;

  {
  if (lastwin->w_status_height) {
    if (p_ls == 0L) {
      {
      win_new_height(lastwin, lastwin->w_height + 1);
      lastwin->w_status_height = 0;
      comp_col();
      }
    } else { //Added block
    if (p_ls == 1L) {
      if ((unsigned long )firstwin == (unsigned long )lastwin) {
        {
        win_new_height(lastwin, lastwin->w_height + 1);
        lastwin->w_status_height = 0;
        comp_col();
        }
      }
    }
    }
  } else { //Added block
  if (p_ls == 2L) {
    goto _L;
  } else { //Added block
  if (p_ls == 1L) {
    if ((unsigned long )firstwin != (unsigned long )lastwin) {
      _L: 
      wp = lastwin;
      {
      while (1) {
        while_continue: /* CIL Label */ ;
        if (! ((long )wp->w_height <= p_wmh)) {
          goto while_break;
        }
        if ((unsigned long )wp == (unsigned long )((void *)0)) {
          {
          emsg(e_noroom);
          }
          return;
        }
        wp = wp->w_prev;
      }
      while_break: /* CIL Label */ ;
      }
      {
      win_new_height(wp, wp->w_height - 1);
      win_comp_pos();
      lastwin->w_status_height = 1;
      comp_col();
      redraw_all_later(40);
      }
    }
  }
  }
  }
  return;
}
}
char_u *file_name_at_cursor(int options___0 , long count___2 ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  {
  tmp = ml_get_curline();
  tmp___0 = get_file_name_in_path(tmp, (int )curwin->w_cursor.col, options___0, count___2);
  }
  return (tmp___0);
}
}
char_u *get_file_name_in_path(char_u *line , int col , int options___0 , long count___2 ) 
{ 
  char_u *ptr ;
  char_u *file_name ;
  char_u *path ;
  int len___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;

  {
  ptr = line + col;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if ((int )*ptr != 0) {
      {
      tmp = vim_isfilec((int )*ptr);
      }
      if (tmp) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  if ((int )*ptr == 0) {
    if (options___0 & 1) {
      {
      emsg((char_u *)"No file name under cursor");
      }
    }
    return ((char_u *)((void *)0));
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if ((unsigned long )ptr > (unsigned long )line) {
      {
      tmp___0 = vim_isfilec((int )*(ptr + -1));
      }
      if (! tmp___0) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    ptr --;
  }
  while_break___0: /* CIL Label */ ;
  }
  if (options___0 & 4) {
    if ((unsigned long )ptr > (unsigned long )line) {
      {
      tmp___1 = path_is_url(ptr - 1);
      }
      if (tmp___1) {
        ptr --;
      }
    }
  }
  len___0 = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
    tmp___2 = vim_isfilec((int )*(ptr + len___0));
    }
    if (! tmp___2) {
      if (options___0 & 4) {
        {
        tmp___3 = path_is_url(ptr + len___0);
        }
        if (! tmp___3) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
    }
    len___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  if (options___0 & 4) {
    {
    file_name = vim_strchr(ptr, ':');
    }
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
      tmp___4 = path_is_url(file_name);
      }
      if (tmp___4 == 1) {
        {
        path = vim_strchr(file_name + 3, '/');
        }
        if ((unsigned long )path != (unsigned long )((void *)0)) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        {
        tmp___5 = path_is_url(file_name);
        }
        if (tmp___5 == 2) {
          {
          path = vim_strchr(file_name + 3, '\\');
          }
          if ((unsigned long )path != (unsigned long )((void *)0)) {
            _L: 
            if ((unsigned long )path < (unsigned long )(ptr + len___0)) {
              len___0 = (int )((long )len___0 - (path - ptr));
              ptr = path;
              if ((int )*(ptr + 1) == 126) {
                ptr ++;
                len___0 --;
              }
            }
          }
        }
      }
    }
  }
  if (! (options___0 & 2)) {
    {
    tmp___6 = vim_strnsave(ptr, len___0);
    }
    return (tmp___6);
  }
  {
  tmp___7 = find_file_in_path(ptr, len___0, options___0, count___2);
  }
  return (tmp___7);
}
}
char_u *find_file_in_path(char_u *ptr , int len___0 , int options___0 , long count___2 ) 
{ 
  char_u save_char ;
  char_u *file_name ;
  char_u *curr_path ;
  char_u *dir ;
  int curr_path_len ;
  char_u *p___0 ;
  char_u *head ;
  long tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  {
  curr_path = (char_u *)((void *)0);
  save_char = *(ptr + len___0);
  *(ptr + len___0) = (char_u )'\000';
  expand_env(ptr, NameBuff, 1024);
  *(ptr + len___0) = save_char;
  tmp___7 = mch_isFullName(NameBuff);
  }
  if (tmp___7) {
    {
    file_name = vim_strsave(NameBuff);
    }
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    {
    tmp = mch_getperm(file_name);
    }
    if (tmp >= 0L) {
      return (file_name);
    }
    if (options___0 & 1) {
      {
      emsg2((char_u *)"Can\'t find file \"%s\"", NameBuff);
      }
    }
  } else {
    if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
      {
      curr_path = curbuf->b_fname;
      ptr = gettail(curr_path);
      curr_path_len = (int )(ptr - curr_path);
      }
    } else {
      curr_path_len = 0;
    }
    {
    tmp___0 = strlen((char const   *)((char *)p_path));
    tmp___1 = strlen((char const   *)((char *)NameBuff));
    file_name = alloc((unsigned int )((int )((((size_t )curr_path_len + tmp___0) + tmp___1) + 3UL)));
    }
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
      return ((char_u *)((void *)0));
    }
    dir = p_path;
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (*dir) {
        if (! (! got_int)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      {
      len___0 = copy_option_part(& dir, file_name, 31000, (char *)" ,");
      }
      if (len___0 != 0) {
        if ((int )*(file_name + 0) == 46) {
          if (curr_path_len > 0) {
            if (len___0 == 1) {
              goto _L;
            } else {
              {
              tmp___2 = vim_ispathsep((int )*(file_name + 1));
              }
              if (tmp___2) {
                _L: 
                if (len___0 == 1) {
                  len___0 = 0;
                } else {
                  {
                  len___0 -= 2;
                  memmove((void *)((char *)(file_name + curr_path_len)), (void const   *)((char *)(file_name + 2)),
                          (size_t )len___0);
                  }
                }
                {
                strncpy((char * __restrict  )((char *)file_name), (char const   * __restrict  )((char *)curr_path),
                        (size_t )curr_path_len);
                len___0 += curr_path_len;
                }
              }
            }
          }
        }
        {
        tmp___4 = vim_ispathsep((int )*(file_name + (len___0 - 1)));
        }
        if (! tmp___4) {
          tmp___3 = len___0;
          len___0 ++;
          *(file_name + tmp___3) = (char_u )'/';
        }
        {
        *(file_name + len___0) = (char_u )'\000';
        tmp___5 = mch_has_wildcard(file_name);
        }
        if (tmp___5) {
          {
          p___0 = get_past_head(file_name);
          }
          if ((unsigned long )p___0 == (unsigned long )file_name) {
            {
            p___0 = find_file_in_wildcard_path((char_u *)"", file_name, 0, & count___2);
            }
          } else {
            {
            head = vim_strnsave(file_name, (int )((unsigned int )(p___0 - file_name)));
            }
            if ((unsigned long )head != (unsigned long )((void *)0)) {
              {
              p___0 = find_file_in_wildcard_path(head, p___0, 0, & count___2);
              vim_free((void *)head);
              }
            }
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            vim_free((void *)file_name);
            }
            return (p___0);
          }
          goto __Cont;
        }
      }
      {
      strcpy((char * __restrict  )((char *)(file_name + len___0)), (char const   * __restrict  )((char *)NameBuff));
      simplify_filename(file_name);
      tmp___6 = mch_getperm(file_name);
      }
      if (tmp___6 >= 0L) {
        count___2 --;
        if (count___2 == 0L) {
          return (file_name);
        }
      }
      __Cont: ;
    }
    while_break: /* CIL Label */ ;
    }
    if (options___0 & 1) {
      {
      emsg2((char_u *)"Can\'t find file \"%s\" in path", NameBuff);
      }
    }
  }
  {
  vim_free((void *)file_name);
  }
  return ((char_u *)((void *)0));
}
}
static char_u *find_file_in_wildcard_path(char_u *path_so_far , char_u *wildcards ,
                                          int level , long *countptr ) 
{ 
  char_u *file_name ;
  int len___0 ;
  char_u *rest_of_wildcards ;
  int nFiles ;
  char_u **ppFiles ;
  int i___0 ;
  char_u *c ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
  nFiles = 0;
  ui_breakcheck();
  }
  if (level > 100) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if (got_int) {
    return ((char_u *)((void *)0));
  }
  }
  {
  file_name = alloc(1024U);
  }
  if ((unsigned long )file_name == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  {
  strcpy((char * __restrict  )((char *)file_name), (char const   * __restrict  )((char *)path_so_far));
  tmp = strlen((char const   *)((char *)file_name));
  len___0 = (int )tmp;
  tmp___1 = vim_ispathsep((int )*(file_name + (len___0 - 1)));
  }
  if (! tmp___1) {
    tmp___0 = len___0;
    len___0 ++;
    *(file_name + tmp___0) = (char_u )'/';
    *(file_name + len___0) = (char_u )'\000';
  }
  rest_of_wildcards = wildcards;
  if (rest_of_wildcards) {
    {
    tmp___2 = strncmp((char const   *)((char *)rest_of_wildcards), (char const   *)((char *)"**"),
                      (size_t )2);
    }
    if (tmp___2 == 0) {
      rest_of_wildcards ++;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (*rest_of_wildcards) {
        {
        tmp___5 = vim_ispathsep((int )*rest_of_wildcards);
        }
        if (tmp___5) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      tmp___3 = len___0;
      len___0 ++;
      tmp___4 = rest_of_wildcards;
      rest_of_wildcards ++;
      *(file_name + tmp___3) = *tmp___4;
    }
    while_break: /* CIL Label */ ;
    }
    rest_of_wildcards ++;
    *(file_name + len___0) = (char_u )'\000';
  }
  {
  expand_wildcards(1, & file_name, & nFiles, & ppFiles, 43);
  }
  if (! *rest_of_wildcards) {
    i___0 = 0;
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      if (! (i___0 < nFiles)) {
        goto while_break___0;
      }
      {
      tmp___6 = mch_isdir(*(ppFiles + i___0));
      }
      if (! tmp___6) {
        goto __Cont;
      }
      {
      strcpy((char * __restrict  )((char *)file_name), (char const   * __restrict  )((char *)*(ppFiles + i___0)));
      add_pathsep(file_name);
      strcat((char * __restrict  )((char *)file_name), (char const   * __restrict  )((char *)NameBuff));
      tmp___7 = mch_getperm(file_name);
      }
      if (tmp___7 >= 0L) {
        (*countptr) --;
        if (*countptr == 0L) {
          {
          FreeWild(nFiles, ppFiles);
          }
          return (file_name);
        }
      }
      __Cont: 
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    i___0 = 0;
    {
    while (1) {
      while_continue___1: /* CIL Label */ ;
      if (! (i___0 < nFiles)) {
        goto while_break___1;
      }
      {
      tmp___8 = mch_isdir(*(ppFiles + i___0));
      }
      if (! tmp___8) {
        goto __Cont___0;
      }
      {
      c = find_file_in_wildcard_path(*(ppFiles + i___0), rest_of_wildcards, level + 1,
                                     countptr);
      }
      if (c) {
        {
        FreeWild(nFiles, ppFiles);
        vim_free((void *)file_name);
        }
        return (c);
      }
      __Cont___0: 
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  tmp___10 = strncmp((char const   *)((char *)wildcards), (char const   *)((char *)"**"),
                     (size_t )2);
  }
  if (tmp___10 == 0) {
    i___0 = 0;
    {
    while (1) {
      while_continue___2: /* CIL Label */ ;
      if (! (i___0 < nFiles)) {
        goto while_break___2;
      }
      {
      tmp___9 = mch_isdir(*(ppFiles + i___0));
      }
      if (! tmp___9) {
        goto __Cont___1;
      }
      {
      c = find_file_in_wildcard_path(*(ppFiles + i___0), wildcards, level + 1, countptr);
      }
      if (c) {
        {
        FreeWild(nFiles, ppFiles);
        vim_free((void *)file_name);
        }
        return (c);
      }
      __Cont___1: 
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
  FreeWild(nFiles, ppFiles);
  vim_free((void *)file_name);
  }
  return ((char_u *)((void *)0));
}
}
static int path_is_url(char_u *p___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"://"),
                    (size_t )3);
  }
  if (tmp___0 == 0) {
    return (1);
  } else {
    {
    tmp = strncmp((char const   *)((char *)p___0), (char const   *)((char *)":\\\\"),
                  (size_t )3);
    }
    if (tmp == 0) {
      return (2);
    }
  }
  return (0);
}
}
int min_rows(void) 
{ 
  WIN *wp ;
  int total ;

  {
  if ((unsigned long )firstwin == (unsigned long )((void *)0)) {
    return (2);
  }
  total = (int )p_ch;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    total = (int )((long )total + (p_wmh + (long )wp->w_status_height));
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  if (p_wmh == 0L) {
    total ++;
  }
  return (total);
}
}
int only_one_window(void) 
{ 
  int count___2 ;
  WIN *wp ;

  {
  count___2 = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (! (wp->w_buffer)->b_help) {
      count___2 ++;
    } else { //Added block
    if ((unsigned long )wp == (unsigned long )curwin) {
      count___2 ++;
    }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return (count___2 <= 1);
}
}
void check_lnums(int do_curwin ) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (do_curwin) {
      goto _L;
    } else { //Added block
    if ((unsigned long )wp != (unsigned long )curwin) {
      _L: 
      if ((unsigned long )wp->w_buffer == (unsigned long )curbuf) {
        if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
          wp->w_cursor.lnum = curbuf->b_ml.ml_line_count;
        }
        if (wp->w_topline > curbuf->b_ml.ml_line_count) {
          wp->w_topline = curbuf->b_ml.ml_line_count;
        }
      }
    }
    }
    wp = wp->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-avUm5A6g.i","-O0")
char *Version  =    (char *)"5.8";
char *mediumVersion  =    (char *)"5.8";
char *longVersion  =    (char *)"VIM - Vi IMproved 5.8 (2001 May 31, compiled Dec 18 2020 01:10:01)";
static void version_msg(char *s ) ;
static char *features[64]  = 
  {      (char *)"+autocmd",      (char *)"-browse",      (char *)"+builtin_terms",      (char *)"+byte_offset", 
        (char *)"+cindent",      (char *)"+cmdline_compl",      (char *)"+cmdline_info",      (char *)"+comments", 
        (char *)"+cryptv",      (char *)"-cscope",      (char *)"+dialog_con",      (char *)"+digraphs", 
        (char *)"-emacs_tags",      (char *)"+eval",      (char *)"+ex_extra",      (char *)"+extra_search", 
        (char *)"-farsi",      (char *)"+file_in_path",      (char *)"-osfiletype",      (char *)"+find_in_path", 
        (char *)"+fork()",      (char *)"-GUI",      (char *)"-hangul_input",      (char *)"+insert_expand", 
        (char *)"-langmap",      (char *)"+linebreak",      (char *)"+lispindent",      (char *)"+menu", 
        (char *)"+mksession",      (char *)"+modify_fname",      (char *)"+mouse",      (char *)"-mouse_dec", 
        (char *)"-mouse_gpm",      (char *)"-mouse_netterm",      (char *)"+mouse_xterm",      (char *)"-multi_byte", 
        (char *)"-perl",      (char *)"-python",      (char *)"+quickfix",      (char *)"-rightleft", 
        (char *)"+scrollbind",      (char *)"+smartindent",      (char *)"-sniff",      (char *)"+statusline", 
        (char *)"+syntax",      (char *)"+tag_binary",      (char *)"+tag_old_static",      (char *)"-tag_any_white", 
        (char *)"-tcl",      (char *)"+terminfo",      (char *)"+textobjects",      (char *)"+title", 
        (char *)"+user_commands",      (char *)"+visualextra",      (char *)"+viminfo",      (char *)"+wildignore", 
        (char *)"+wildmenu",      (char *)"+writebackup",      (char *)"+X11",      (char *)"-xfontset", 
        (char *)"-xim",      (char *)"+xterm_clipboard",      (char *)"-xterm_save",      (char *)((void *)0)};
static int included_patches[1]  = {      0};
int highest_patch(void) 
{ 
  int i___0 ;
  int h ;

  {
  h = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (included_patches[i___0] != 0)) {
      goto while_break;
    }
    if (included_patches[i___0] > h) {
      h = included_patches[i___0];
    }
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  return (h);
}
}
void do_version(char_u *arg ) 
{ 


  {
  if ((int )*arg == 0) {
    {
    msg_putchar('\n');
    list_version();
    }
  }
  return;
}
}
void list_version(void) 
{ 
  int i___0 ;
  int first___0 ;
  char *s ;

  {
  {
  s = (char *)"";
  msg((char_u *)longVersion);
  }
  if (included_patches[0] != 0) {
    {
    msg_puts((char_u *)"\nIncluded patches: ");
    first___0 = -1;
    i___0 = 0;
    }
    {
    while (1) {
      while_continue: /* CIL Label */ ;
      if (! (included_patches[i___0] != 0)) {
        goto while_break;
      }
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: /* CIL Label */ ;
      i___0 --;
      if (! (i___0 >= 0)) {
        goto while_break___0;
      }
      if (first___0 < 0) {
        first___0 = included_patches[i___0];
      }
      if (i___0 == 0) {
        goto _L;
      } else { //Added block
      if (included_patches[i___0 - 1] != included_patches[i___0] + 1) {
        _L: 
        {
        msg_puts((char_u *)s);
        s = (char *)", ";
        msg_outnum((long )first___0);
        }
        if (first___0 != included_patches[i___0]) {
          {
          msg_puts((char_u *)"-");
          msg_outnum((long )included_patches[i___0]);
          }
        }
        first___0 = -1;
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  if ((int )*compiled_user != 0) {
    {
    msg_puts((char_u *)"\nCompiled by ");
    msg_puts(compiled_user);
    }
    if ((int )*compiled_sys != 0) {
      {
      msg_puts((char_u *)"@");
      msg_puts(compiled_sys);
      }
    }
    {
    msg_puts((char_u *)", with (+) or without (-):\n");
    }
  } else {
    {
    msg_puts((char_u *)"\nCompiled with (+) or without (-):\n");
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! ((unsigned long )features[i___0] != (unsigned long )((void *)0))) {
      goto while_break___1;
    }
    {
    version_msg(features[i___0]);
    }
    if (msg_col > 0) {
      {
      msg_putchar(' ');
      }
    }
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  msg_putchar('\n');
  version_msg((char *)"   system vimrc file: \"");
  version_msg((char *)"$VIM/vimrc");
  version_msg((char *)"\"\n");
  version_msg((char *)"     user vimrc file: \"");
  version_msg((char *)"$HOME/.vimrc");
  version_msg((char *)"\"\n");
  version_msg((char *)"      user exrc file: \"");
  version_msg((char *)"$HOME/.exrc");
  version_msg((char *)"\"\n");
  }
  if ((int )*default_vim_dir != 0) {
    {
    version_msg((char *)"  fall-back for $VIM: \"");
    version_msg((char *)default_vim_dir);
    msg_puts((char_u *)"\"\n");
    }
  }
  if ((int )*default_vimruntime_dir != 0) {
    {
    version_msg((char *)" f-b for $VIMRUNTIME: \"");
    version_msg((char *)default_vimruntime_dir);
    msg_puts((char_u *)"\"\n");
    }
  }
  {
  version_msg((char *)"Compilation: ");
  version_msg((char *)all_cflags);
  msg_putchar('\n');
  version_msg((char *)"Linking: ");
  version_msg((char *)all_lflags);
  }
  return;
}
}
static void version_msg(char *s ) 
{ 
  int len___0 ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)s);
  len___0 = (int )tmp;
  }
  if (len___0 < (int )Columns) {
    if (msg_col + len___0 >= (int )Columns) {
      {
      msg_putchar('\n');
      }
    }
  }
  {
  msg_puts((char_u *)s);
  }
  return;
}
}
