 /* Generated by CIL v. 1.7.3 */
 /* print_CIL_Input is true */
 
 typedef unsigned long __uintmax_t;
 typedef long __time_t;
 typedef __time_t time_t;
 typedef unsigned long size_t;
 typedef __uintmax_t uintmax_t;
 struct floc {
    char *filenm ;
    unsigned long lineno ;
 };
 struct dep;
 struct commands;
 struct variable_set_list;
 enum __anonenum_command_state_55 {
     cs_not_started = 0,
     cs_deps_running = 1,
     cs_running = 2,
     cs_finished = 3
 } ;
 struct file {
    struct file *next ;
    char *name ;
    char *hname ;
    char *vpath ;
    struct dep *deps ;
    struct commands *cmds ;
    int command_flags ;
    char *stem ;
    struct dep *also_make ;
    uintmax_t last_mtime ;
    uintmax_t mtime_before_update ;
    struct file *prev ;
    struct file *renamed ;
    struct variable_set_list *variables ;
    struct variable_set_list *pat_variables ;
    struct file *parent ;
    struct file *double_colon ;
    short update_status ;
    enum __anonenum_command_state_55 command_state : 2 ;
    unsigned int precious : 1 ;
    unsigned int tried_implicit : 1 ;
    unsigned int updating : 1 ;
    unsigned int updated : 1 ;
    unsigned int is_target : 1 ;
    unsigned int cmd_target : 1 ;
    unsigned int phony : 1 ;
    unsigned int intermediate : 1 ;
    unsigned int secondary : 1 ;
    unsigned int dontcare : 1 ;
    unsigned int ignore_vpath : 1 ;
    unsigned int pat_searched : 1 ;
    unsigned int considered : 1 ;
 };
 struct dep {
    struct dep *next ;
    char *name ;
    struct file *file ;
    int changed ;
 };
 struct nameseq {
    struct nameseq *next ;
    char *name ;
 };
 struct ar_glob_state {
    char *arname ;
    char *pattern ;
    unsigned int size ;
    struct nameseq *chain ;
    unsigned int n ;
 };
 typedef unsigned long __dev_t;
 typedef unsigned int __uid_t;
 typedef unsigned int __gid_t;
 typedef unsigned long __ino_t;
 typedef unsigned int __mode_t;
 typedef unsigned long __nlink_t;
 typedef long __off_t;
 typedef long __blksize_t;
 typedef long __blkcnt_t;
 typedef long __ssize_t;
 typedef long __syscall_slong_t;
 typedef __ssize_t ssize_t;
 struct timespec {
    __time_t tv_sec ;
    __syscall_slong_t tv_nsec ;
 };
 struct stat {
    __dev_t st_dev ;
    __ino_t st_ino ;
    __nlink_t st_nlink ;
    __mode_t st_mode ;
    __uid_t st_uid ;
    __gid_t st_gid ;
    int __pad0 ;
    __dev_t st_rdev ;
    __off_t st_size ;
    __blksize_t st_blksize ;
    __blkcnt_t st_blocks ;
    struct timespec st_atim ;
    struct timespec st_mtim ;
    struct timespec st_ctim ;
    __syscall_slong_t __glibc_reserved[3] ;
 };
 struct ar_hdr {
    char ar_name[16] ;
    char ar_date[12] ;
    char ar_uid[6] ;
    char ar_gid[6] ;
    char ar_mode[8] ;
    char ar_size[10] ;
    char ar_fmag[2] ;
 };
 typedef long __off64_t;
 typedef int __pid_t;
 typedef __pid_t pid_t;
 typedef void (*__sighandler_t)(int  );
 struct _IO_FILE;
 typedef struct _IO_FILE FILE;
 typedef void _IO_lock_t;
 struct _IO_marker {
    struct _IO_marker *_next ;
    struct _IO_FILE *_sbuf ;
    int _pos ;
 };
 struct _IO_FILE {
    int _flags ;
    char *_IO_read_ptr ;
    char *_IO_read_end ;
    char *_IO_read_base ;
    char *_IO_write_base ;
    char *_IO_write_ptr ;
    char *_IO_write_end ;
    char *_IO_buf_base ;
    char *_IO_buf_end ;
    char *_IO_save_base ;
    char *_IO_backup_base ;
    char *_IO_save_end ;
    struct _IO_marker *_markers ;
    struct _IO_FILE *_chain ;
    int _fileno ;
    int _flags2 ;
    __off_t _old_offset ;
    unsigned short _cur_column ;
    signed char _vtable_offset ;
    char _shortbuf[1] ;
    _IO_lock_t *_lock ;
    __off64_t _offset ;
    void *__pad1 ;
    void *__pad2 ;
    void *__pad3 ;
    void *__pad4 ;
    size_t __pad5 ;
    int _mode ;
    char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
 };
 enum variable_origin {
     o_default = 0,
     o_env = 1,
     o_file = 2,
     o_env_override = 3,
     o_command = 4,
     o_override = 5,
     o_automatic = 6,
     o_invalid = 7
 } ;
 enum variable_export {
     v_export = 0,
     v_noexport = 1,
     v_ifset = 2,
     v_default = 3
 } ;
 struct variable {
    struct variable *next ;
    char *name ;
    char *value ;
    struct floc fileinfo ;
    enum variable_origin origin : 3 ;
    unsigned int recursive : 1 ;
    unsigned int expanding : 1 ;
    unsigned int per_target : 1 ;
    unsigned int append : 1 ;
    enum variable_export export : 2 ;
 };
 struct variable_set {
    struct variable **table ;
    unsigned int buckets ;
 };
 struct variable_set_list {
    struct variable_set_list *next ;
    struct variable_set *set ;
 };
 struct child {
    struct child *next ;
    struct file *file ;
    char **environment ;
    char **command_lines ;
    unsigned int command_line ;
    char *command_ptr ;
    pid_t pid ;
    char *sh_batch_file ;
    unsigned int remote : 1 ;
    unsigned int noerror : 1 ;
    unsigned int good_stdin : 1 ;
    unsigned int deleted : 1 ;
 };
 struct commands {
    struct floc fileinfo ;
    char *commands ;
    unsigned int ncommand_lines ;
    char **command_lines ;
    char *lines_flags ;
    int any_recurse ;
 };
 typedef __ino_t ino_t;
 typedef __dev_t dev_t;
 struct dirent {
    __ino_t d_ino ;
    __off_t d_off ;
    unsigned short d_reclen ;
    unsigned char d_type ;
    char d_name[256] ;
 };
 struct __dirstream;
 typedef struct __dirstream DIR;
 struct dirfile;
 struct directory_contents {
    struct directory_contents *next ;
    dev_t dev ;
    ino_t ino ;
    struct dirfile **files ;
    DIR *dirstream ;
 };
 struct directory {
    struct directory *next ;
    char *name ;
    struct directory_contents *contents ;
 };
 struct dirfile {
    struct dirfile *next ;
    char *name ;
    char impossible ;
 };
 struct __anonstruct_glob_t_56 {
    size_t gl_pathc ;
    char **gl_pathv ;
    size_t gl_offs ;
    int gl_flags ;
    void (*gl_closedir)(void * ) ;
    struct dirent *(*gl_readdir)(void * ) ;
    void *(*gl_opendir)(char const   * ) ;
    int (*gl_lstat)(char const   * , struct stat * ) ;
    int (*gl_stat)(char const   * , struct stat * ) ;
 };
 typedef struct __anonstruct_glob_t_56 glob_t;
 struct dirstream {
    struct directory_contents *contents ;
    unsigned int bucket ;
    struct dirfile *elt ;
 };
 typedef int __clockid_t;
 typedef __clockid_t clockid_t;
 struct tm {
    int tm_sec ;
    int tm_min ;
    int tm_hour ;
    int tm_mday ;
    int tm_mon ;
    int tm_year ;
    int tm_wday ;
    int tm_yday ;
    int tm_isdst ;
    long tm_gmtoff ;
    char const   *tm_zone ;
 };
 struct function_table_entry {
    char const   *name ;
    unsigned char len ;
    unsigned char minimum_args ;
    unsigned char maximum_args ;
    char expand_args ;
    char *(*func_ptr)(char *output , char **argv , char const   *fname ) ;
 };
 struct a_word {
    struct a_word *next ;
    char *str ;
    int matched ;
 };
 struct rule {
    struct rule *next ;
    char **targets ;
    unsigned int *lens ;
    char **suffixes ;
    struct dep *deps ;
    struct commands *cmds ;
    char terminal ;
    char in_use ;
 };
 struct __anonstruct___sigset_t_2 {
    unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
 };
 typedef struct __anonstruct___sigset_t_2 __sigset_t;
 typedef __sigset_t sigset_t;
 typedef unsigned int __uint32_t;
 typedef long __clock_t;
 union sigval {
    int sival_int ;
    void *sival_ptr ;
 };
 typedef union sigval __sigval_t;
 struct __anonstruct__kill_18 {
    __pid_t si_pid ;
    __uid_t si_uid ;
 };
 struct __anonstruct__timer_19 {
    int si_tid ;
    int si_overrun ;
    __sigval_t si_sigval ;
 };
 struct __anonstruct__rt_20 {
    __pid_t si_pid ;
    __uid_t si_uid ;
    __sigval_t si_sigval ;
 };
 struct __anonstruct__sigchld_21 {
    __pid_t si_pid ;
    __uid_t si_uid ;
    int si_status ;
    __clock_t si_utime ;
    __clock_t si_stime ;
 };
 struct __anonstruct__addr_bnd_24 {
    void *_lower ;
    void *_upper ;
 };
 union __anonunion__bounds_23 {
    struct __anonstruct__addr_bnd_24 _addr_bnd ;
    __uint32_t _pkey ;
 };
 struct __anonstruct__sigfault_22 {
    void *si_addr ;
    short si_addr_lsb ;
    union __anonunion__bounds_23 _bounds ;
 };
 struct __anonstruct__sigpoll_25 {
    long si_band ;
    int si_fd ;
 };
 struct __anonstruct__sigsys_26 {
    void *_call_addr ;
    int _syscall ;
    unsigned int _arch ;
 };
 union __anonunion__sifields_17 {
    int _pad[128UL / sizeof(int ) - 4UL] ;
    struct __anonstruct__kill_18 _kill ;
    struct __anonstruct__timer_19 _timer ;
    struct __anonstruct__rt_20 _rt ;
    struct __anonstruct__sigchld_21 _sigchld ;
    struct __anonstruct__sigfault_22 _sigfault ;
    struct __anonstruct__sigpoll_25 _sigpoll ;
    struct __anonstruct__sigsys_26 _sigsys ;
 };
 struct __anonstruct_siginfo_t_16 {
    int si_signo ;
    int si_errno ;
    int si_code ;
    int __pad0 ;
    union __anonunion__sifields_17 _sifields ;
 };
 typedef struct __anonstruct_siginfo_t_16 siginfo_t;
 union __anonunion___sigaction_handler_37 {
    void (*sa_handler)(int  ) ;
    void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
 };
 struct sigaction {
    union __anonunion___sigaction_handler_37 __sigaction_handler ;
    __sigset_t sa_mask ;
    int sa_flags ;
    void (*sa_restorer)(void) ;
 };
 struct option {
    char const   *name ;
    int has_arg ;
    int *flag ;
    int val ;
 };
 enum __anonenum_type_56 {
     flag = 0,
     flag_off = 1,
     string = 2,
     positive_int = 3,
     floating = 4,
     ignore = 5
 } ;
 struct command_switch {
    int c ;
    enum __anonenum_type_56 type ;
    char *value_ptr ;
    unsigned int env : 1 ;
    unsigned int toenv : 1 ;
    unsigned int no_makefile : 1 ;
    char *noarg_value ;
    char *default_value ;
    char *long_name ;
    char *argdesc ;
    char *description ;
 };
 struct stringlist {
    char **list ;
    unsigned int idx ;
    unsigned int max ;
 };
 struct command_variable {
    struct command_variable *next ;
    struct variable *variable ;
 };
 struct flag {
    struct flag *next ;
    struct command_switch  const  *cs ;
    char *arg ;
 };
 typedef __builtin_va_list __gnuc_va_list;
 typedef struct _IO_FILE _IO_FILE;
 typedef __gnuc_va_list va_list;
 enum __anonenum_current_access_55 {
     make = 0,
     user = 1
 } ;
 struct pattern_var {
    struct pattern_var *next ;
    char *target ;
    unsigned int len ;
    char *suffix ;
    struct variable_set_list *vars ;
 };
 struct passwd {
    char *pw_name ;
    char *pw_passwd ;
    __uid_t pw_uid ;
    __gid_t pw_gid ;
    char *pw_gecos ;
    char *pw_dir ;
    char *pw_shell ;
 };
 struct linebuffer {
    unsigned int size ;
    char *buffer ;
 };
 enum make_word_type {
     w_bogus = 0,
     w_eol = 1,
     w_static = 2,
     w_variable = 3,
     w_colon = 4,
     w_dcolon = 5,
     w_semicolon = 6,
     w_comment = 7,
     w_varassign = 8
 } ;
 struct conditionals {
    unsigned int if_cmds ;
    unsigned int allocated ;
    char *ignoring ;
    char *seen_else ;
 };
 struct pspec {
    char *target ;
    char *dep ;
    char *commands ;
 };
 struct __anonstruct_num_abbrev_55 {
    int number ;
    char const   *abbrev ;
 };
 typedef struct __anonstruct_num_abbrev_55 num_abbrev;
 struct variable_bucket {
    struct variable_bucket *next ;
    struct variable *variable ;
 };
 enum __anonenum_flavor_56 {
     f_bogus = 0,
     f_simple = 1,
     f_recursive = 2,
     f_append = 3,
     f_conditional = 4
 } ;
 struct vpath {
    struct vpath *next ;
    char *pattern ;
    char *percent ;
    unsigned int patlen ;
    char **searchpath ;
    unsigned int maxlen ;
 };
 struct loaded_l10nfile {
    char const   *filename ;
    int decided ;
    void const   *data ;
    struct loaded_l10nfile *next ;
    struct loaded_l10nfile *successor[1] ;
 };
 enum __anonenum_syntax_17 {
     undecided = 0,
     xpg = 1,
     cen = 2
 } ;
 typedef unsigned int nls_uint32;
 struct mo_file_header {
    nls_uint32 magic ;
    nls_uint32 revision ;
    nls_uint32 nstrings ;
    nls_uint32 orig_tab_offset ;
    nls_uint32 trans_tab_offset ;
    nls_uint32 hash_tab_size ;
    nls_uint32 hash_tab_offset ;
 };
 struct string_desc {
    nls_uint32 length ;
    nls_uint32 offset ;
 };
 struct loaded_domain {
    char const   *data ;
    int use_mmap ;
    size_t mmap_size ;
    int must_swap ;
    nls_uint32 nstrings ;
    struct string_desc *orig_tab ;
    struct string_desc *trans_tab ;
    nls_uint32 hash_size ;
    nls_uint32 *hash_tab ;
 };
 struct binding {
    struct binding *next ;
    char *domainname ;
    char *dirname ;
 };
 struct alias_map {
    char const   *alias ;
    char const   *value ;
 };
 /* compiler builtin: 
    void *__builtin_alloca(unsigned long  ) ;  */
 #pragma merger("0","/tmp/cil-S4IQuXVr.i","-g,-O0")
 char *dcgettext(char const   *domainname , char const   *msgid , int category ) ;
 extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
 extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                        size_t __size , int (*__compar)(void const   * ,
                                                                                        void const   * ) ) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                   void const   *__src ,
                                                                                                   size_t __n ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
 void ( /* format attribute */  error)(struct floc  const  *flocp , char const   *fmt 
                                       , ...) ;
  __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(struct floc  const  *flocp ,
                                                                      char const   *fmt 
                                                                      , ...) ;
 void perror_with_name(char *str , char *name ) ;
 char *savestring(char const   *str , unsigned int length___0 ) ;
 char *concat(char *s1 , char *s2 , char *s3 ) ;
 char *xmalloc(unsigned int size ) ;
 int alpha_compare(void const   *v1 , void const   *v2 ) ;
 int ar_name(char *name ) ;
 void ar_parse_name(char *name , char **arname_p , char **memname_p ) ;
 int ar_touch(char *name ) ;
 time_t ar_member_date(char *name ) ;
 int file_exists_p(char *name ) ;
 struct file *lookup_file(char *name ) ;
 struct file *enter_file(char *name ) ;
 uintmax_t f_mtime(struct file *file , int search ) ;
 struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) ;
 extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
 long ar_scan(char *archive , long (*function)() , long arg ) ;
 int ar_name_equal(char *name , char *mem , int truncated ) ;
 int ar_member_touch(char *arname , char *memname ) ;
 int ar_name(char *name ) 
 { 
//Stmt8:Leaf
char *p ;

//Stmt9:Leaf
char *tmp ;

//Stmt10:Leaf
char *end ;

//Stmt11:Leaf
size_t tmp___0 ;

//Stmt12:Leaf
char *tmp___1 ;

 
   {
//Stmt13:Leaf
tmp = strchr((char const   *)name, '(');

//Stmt14:Leaf
p = tmp;

//Stmt15:Leaf
tmp___0 = strlen((char const   *)name);

//Stmt16:Leaf
end = (name + tmp___0) - 1;

//Stmt17:Parent
if ((unsigned long )p == (unsigned long )((char *)0)) {
//Stmt3:Leaf
return (0);

   } else
   {
//Stmt4:Parent
if ((unsigned long )p == (unsigned long )name) {
//Stmt1:Leaf
return (0);

   } else
   {
//Stmt2:Parent
if ((int )*end != 41) {
//Stmt0:Leaf
return (0);

   }
}

}


//Stmt18:Parent
if ((int )*(p + 1) == 40) {
//Stmt7:Parent
if ((int )*(end + -1) == 41) {
//Stmt5:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "attempt to use unsupported feature: `%s\'",
                           5);

//Stmt6:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, name);

     }

   }

//Stmt19:Leaf
return (1);

 }
}
 void ar_parse_name(char *name , char **arname_p , char **memname_p ) 
 { 
//Stmt22:Leaf
char *p ;

//Stmt23:Leaf
char *tmp ;

//Stmt24:Leaf
char *end ;

//Stmt25:Leaf
size_t tmp___0 ;

 
   {
//Stmt26:Leaf
tmp = strchr((char const   *)name, '(');

//Stmt27:Leaf
p = tmp;

//Stmt28:Leaf
tmp___0 = strlen((char const   *)name);

//Stmt29:Leaf
end = (name + tmp___0) - 1;

//Stmt30:Parent
if ((unsigned long )arname_p != (unsigned long )((char **)0)) {
//Stmt20:Leaf
*arname_p = savestring((char const   *)name, (unsigned int )(p - name));

   }

//Stmt31:Parent
if ((unsigned long )memname_p != (unsigned long )((char **)0)) {
//Stmt21:Leaf
*memname_p = savestring((char const   *)(p + 1), (unsigned int )(end - (p + 1)));

   }

//Stmt32:Leaf
return;

 }
}
 static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                              long datapos , long size , long date , int uid , int gid ,
                              int mode , char *name ) ;
 time_t ar_member_date(char *name ) 
 { 
//Stmt41:Leaf
char *arname ;

//Stmt42:Leaf
int arname_used ;

//Stmt43:Leaf
char *memname ;

//Stmt44:Leaf
long val ;

//Stmt45:Leaf
struct file *arfile ;

//Stmt46:Leaf
int tmp ;

//Stmt47:Leaf
time_t tmp___0 ;

 
   {
//Stmt48:Leaf
arname_used = 0;

//Stmt49:Leaf
ar_parse_name(name, & arname, & memname);

//Stmt50:Leaf
arfile = lookup_file(arname);

//Stmt51:Parent
if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
//Stmt35:Leaf
tmp = file_exists_p(arname);

//Stmt36:Parent
if (tmp) {
//Stmt33:Leaf
arfile = enter_file(arname);

//Stmt34:Leaf
arname_used = 1;

     }

   }

//Stmt52:Parent
if ((unsigned long )arfile != (unsigned long )((struct file *)0)) {
//Stmt37:Leaf
f_mtime(arfile, 0);

   }

//Stmt53:Leaf
val = ar_scan(arname, (long (*)())(& ar_member_date_1), (long )memname);

//Stmt54:Parent
if (! arname_used) {
//Stmt38:Leaf
free((void *)arname);

   }

//Stmt55:Leaf
free((void *)memname);

//Stmt56:Parent
if (val <= 0L) {
//Stmt39:Leaf
tmp___0 = (time_t )-1;

   } else {
//Stmt40:Leaf
tmp___0 = val;

   }

//Stmt57:Leaf
return (tmp___0);

 }
}
 static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                              long datapos , long size , long date , int uid , int gid ,
                              int mode , char *name ) 
 { 
//Stmt60:Leaf
long tmp___0 ;

//Stmt61:Leaf
int tmp___1 ;

 
   {
//Stmt62:Leaf
tmp___1 = ar_name_equal(name, mem, truncated);

//Stmt63:Parent
if (tmp___1) {
//Stmt58:Leaf
tmp___0 = date;

   } else {
//Stmt59:Leaf
tmp___0 = 0L;

   }

//Stmt64:Leaf
return (tmp___0);

 }
}
 int ar_touch(char *name ) 
 { 
//Stmt78:Leaf
char *arname ;

//Stmt79:Leaf
char *memname ;

//Stmt80:Leaf
int arname_used ;

//Stmt81:Leaf
register int val ;

//Stmt82:Leaf
struct file *arfile ;

//Stmt83:Leaf
int tmp ;

//Stmt84:Leaf
char *tmp___0 ;

//Stmt85:Leaf
char *tmp___1 ;

//Stmt86:Leaf
char *tmp___2 ;

//Stmt87:Leaf
char *tmp___3 ;

 
   {
//Stmt88:Leaf
arname_used = 0;

//Stmt89:Leaf
ar_parse_name(name, & arname, & memname);

//Stmt90:Leaf
arfile = lookup_file(arname);

//Stmt91:Parent
if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
//Stmt65:Leaf
arfile = enter_file(arname);

//Stmt66:Leaf
arname_used = 1;

   }

//Stmt92:Leaf
f_mtime(arfile, 0);

//Stmt93:Leaf
val = 1;

//Stmt94:Leaf
tmp = ar_member_touch(arname, memname);

//Stmt95:Parent
switch (tmp) {
   case -1:; 
//Stmt67:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "touch: Archive `%s\' does not exist",
                       5);

//Stmt73:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, arname);

   break;
   case -2:; 
//Stmt68:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "touch: `%s\' is not a valid archive",
                       5);

//Stmt74:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, arname);

   break;
   case -3:; 
//Stmt69:Leaf
perror_with_name((char *)"touch: ", arname);

   break;
   case 1:; 
//Stmt70:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "touch: Member `%s\' does not exist in `%s\'",
                       5);

//Stmt75:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, memname,
         arname);

   break;
   case 0:; 
//Stmt71:Leaf
val = 0;

   break;
   default:; 
//Stmt72:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "touch: Bad return code from ar_member_touch on `%s\'",
                       5);

//Stmt76:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___3, name);

   }

//Stmt96:Parent
if (! arname_used) {
//Stmt77:Leaf
free((void *)arname);

   }

//Stmt97:Leaf
free((void *)memname);

//Stmt98:Leaf
return (val);

 }
}
 static long ar_glob_match(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                           long size , long date , int uid , int gid , int mode , struct ar_glob_state *state ) 
 { 
//Stmt105:Leaf
struct nameseq *new ;

//Stmt106:Leaf
char *tmp ;

//Stmt107:Leaf
int tmp___0 ;

 
   {
//Stmt108:Leaf
tmp___0 = fnmatch((char const   *)state->pattern, (char const   *)mem, 1 | (1 << 2));

//Stmt109:Parent
if (tmp___0 == 0) {
//Stmt99:Leaf
tmp = xmalloc(state->size);

//Stmt100:Leaf
new = (struct nameseq *)tmp;

//Stmt101:Leaf
new->name = concat(state->arname, mem, (char *)")");

//Stmt102:Leaf
new->next = state->chain;

//Stmt103:Leaf
state->chain = new;

//Stmt104:Leaf
(state->n) ++;

   }

//Stmt110:Leaf
return (0L);

 }
}
 static int glob_pattern_p(char const   *pattern , int const   quote ) 
 { 
//Stmt119:Leaf
register char const   *p ;

//Stmt120:Leaf
int open___0 ;

 
   {
//Stmt121:Leaf
open___0 = 0;

//Stmt122:Leaf
p = pattern;

//Stmt123:Parent
while ((int const   )*p != 0) {
//Stmt117:Parent
switch ((int const   )*p) {
     case 42:; 
     case 63:; 
//Stmt111:Leaf
return (1);

     case 92:; 
//Stmt113:Parent
if (quote) {
//Stmt112:Leaf
p ++;

     }

     break;
     case 91:; 
//Stmt114:Leaf
open___0 = 1;

     break;
     case 93:; 
//Stmt116:Parent
if (open___0) {
//Stmt115:Leaf
return (1);

     }

     break;
     }

//Stmt118:Leaf
p ++;

   }

//Stmt124:Leaf
return (0);

 }
}
 struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) 
 { 
//Stmt135:Leaf
struct ar_glob_state state ;

//Stmt136:Leaf
char **names ;

//Stmt137:Leaf
struct nameseq *n ;

//Stmt138:Leaf
unsigned int i ;

//Stmt139:Leaf
int tmp ;

//Stmt140:Leaf
size_t tmp___0 ;

//Stmt141:Leaf
void *tmp___1 ;

//Stmt142:Leaf
void *tmp___2 ;

//Stmt143:Leaf
unsigned int tmp___3 ;

//Stmt144:Leaf
unsigned int tmp___4 ;

 
   {
//Stmt145:Leaf
tmp = glob_pattern_p((char const   *)member_pattern, (int const   )1);

//Stmt146:Parent
if (! tmp) {
//Stmt125:Leaf
return ((struct nameseq *)0);

   }

//Stmt147:Leaf
tmp___0 = strlen((char const   *)arname);

//Stmt148:Leaf
i = (unsigned int )tmp___0;

//Stmt149:Leaf
tmp___1 = __builtin_alloca((unsigned long )(i + 2U));

//Stmt150:Leaf
state.arname = (char *)tmp___1;

//Stmt151:Leaf
memmove((void *)state.arname, (void const   *)arname, (size_t )i);

//Stmt152:Leaf
*(state.arname + i) = (char )'(';

//Stmt153:Leaf
*(state.arname + (i + 1U)) = (char )'\000';

//Stmt154:Leaf
state.pattern = member_pattern;

//Stmt155:Leaf
state.size = size;

//Stmt156:Leaf
state.chain = (struct nameseq *)0;

//Stmt157:Leaf
state.n = 0U;

//Stmt158:Leaf
ar_scan(arname, (long (*)())(& ar_glob_match), (long )(& state));

//Stmt159:Parent
if ((unsigned long )state.chain == (unsigned long )((struct nameseq *)0)) {
//Stmt126:Leaf
return ((struct nameseq *)0);

   }

//Stmt160:Leaf
tmp___2 = __builtin_alloca((unsigned long )state.n * sizeof(char *));

//Stmt161:Leaf
names = (char **)tmp___2;

//Stmt162:Leaf
i = 0U;

//Stmt163:Leaf
n = state.chain;

//Stmt164:Parent
while ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
//Stmt127:Leaf
tmp___3 = i;

//Stmt128:Leaf
i ++;

//Stmt129:Leaf
*(names + tmp___3) = n->name;

//Stmt130:Leaf
n = n->next;

   }

//Stmt165:Leaf
qsort((void *)((char *)names), (size_t )i, sizeof(*names), & alpha_compare);

//Stmt166:Leaf
i = 0U;

//Stmt167:Leaf
n = state.chain;

//Stmt168:Parent
while ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
//Stmt131:Leaf
tmp___4 = i;

//Stmt132:Leaf
i ++;

//Stmt133:Leaf
n->name = *(names + tmp___4);

//Stmt134:Leaf
n = n->next;

   }

//Stmt169:Leaf
return (state.chain);

 }
}
 #pragma merger("0","/tmp/cil-M34r4uwp.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                             struct stat *__buf ) ;
 extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                  , ...) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                              char const   * __restrict  __format 
                                                                              , ...)  __asm__("__isoc99_sscanf")  ;
 extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
 extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                 __off_t __offset ,
                                                                                 int __whence ) ;
 extern int close(int __fd ) ;
 extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
 extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                                void const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                 char const   *__s2 ,
                                                                                                 size_t __n )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                 int __c )  __attribute__((__pure__)) ;
 extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                    , ...) ;
 long ar_scan(char *archive , long (*function)() , long arg ) 
 { 
//Stmt265:Leaf
int long_name ;

//Stmt266:Leaf
char *namemap ;

//Stmt267:Leaf
register int desc ;

//Stmt268:Leaf
int tmp ;

//Stmt269:Leaf
char buf___1[8] ;

//Stmt270:Leaf
register int nread ;

//Stmt271:Leaf
ssize_t tmp___0 ;

//Stmt272:Leaf
int tmp___1 ;

//Stmt273:Leaf
register long member_offset ;

//Stmt274:Leaf
register int nread___0 ;

//Stmt275:Leaf
struct ar_hdr member_header ;

//Stmt276:Leaf
char namebuf[sizeof(member_header.ar_name) + 1UL] ;

//Stmt277:Leaf
char *name ;

//Stmt278:Leaf
int is_namemap ;

//Stmt279:Leaf
long eltsize ;

//Stmt280:Leaf
int eltmode ;

//Stmt281:Leaf
long fnval ;

//Stmt282:Leaf
__off_t tmp___2 ;

//Stmt283:Leaf
ssize_t tmp___3 ;

//Stmt284:Leaf
int tmp___4 ;

//Stmt285:Leaf
register char *p ;

//Stmt286:Leaf
int tmp___5 ;

//Stmt287:Leaf
int tmp___6 ;

//Stmt288:Leaf
int tmp___7 ;

//Stmt289:Leaf
int tmp___8 ;

//Stmt290:Leaf
int namesize ;

//Stmt291:Leaf
int tmp___9 ;

//Stmt292:Leaf
void *tmp___10 ;

//Stmt293:Leaf
ssize_t tmp___11 ;

//Stmt294:Leaf
int tmp___12 ;

//Stmt295:Leaf
int tmp___13 ;

//Stmt296:Leaf
long tmp___14 ;

//Stmt297:Leaf
char *clear ;

//Stmt298:Leaf
char *limit ;

//Stmt299:Leaf
void *tmp___15 ;

//Stmt300:Leaf
ssize_t tmp___16 ;

 
   {
//Stmt301:Leaf
long_name = 0;

//Stmt302:Leaf
namemap = (char *)0;

//Stmt303:Leaf
tmp = open((char const   *)archive, 0, 0);

//Stmt304:Leaf
desc = tmp;

//Stmt305:Parent
if (desc < 0) {
//Stmt170:Leaf
return (-1L);

   }

//Stmt306:Leaf
tmp___0 = read(desc, (void *)(buf___1), (size_t )8);

//Stmt307:Leaf
nread = (int )tmp___0;

//Stmt308:Parent
if (nread != 8) {
//Stmt173:Leaf
close(desc);

//Stmt174:Leaf
return (-2L);

   } else {
//Stmt175:Leaf
tmp___1 = memcmp((void const   *)(buf___1), (void const   *)"!<arch>\n", (size_t )8);

//Stmt176:Parent
if (tmp___1) {
//Stmt171:Leaf
close(desc);

//Stmt172:Leaf
return (-2L);

     }

   }

//Stmt309:Leaf
member_offset = 8L;

//Stmt310:Parent
while (1) {
//Stmt240:Leaf
tmp___2 = lseek(desc, member_offset, 0);

//Stmt241:Parent
if (tmp___2 < 0L) {
//Stmt177:Leaf
close(desc);

//Stmt178:Leaf
return (-2L);

     }

//Stmt242:Leaf
tmp___3 = read(desc, (void *)((char *)(& member_header)), sizeof(struct ar_hdr ));

//Stmt243:Leaf
nread___0 = (int )tmp___3;

//Stmt244:Parent
if (nread___0 == 0) {
//Stmt179:Leaf
break;

     }

//Stmt245:Parent
if ((unsigned long )nread___0 != sizeof(struct ar_hdr )) {
//Stmt182:Leaf
close(desc);

//Stmt183:Leaf
return (-2L);

     } else {
//Stmt184:Leaf
tmp___4 = memcmp((void const   *)(member_header.ar_fmag), (void const   *)"`\n",
                        (size_t )2);

//Stmt185:Parent
if (tmp___4) {
//Stmt180:Leaf
close(desc);

//Stmt181:Leaf
return (-2L);

       }

     }

//Stmt246:Leaf
name = namebuf;

//Stmt247:Leaf
memmove((void *)name, (void const   *)(member_header.ar_name), sizeof(member_header.ar_name));

//Stmt248:Leaf
p = name + sizeof(member_header.ar_name);

//Stmt249:Parent
while (1) {
//Stmt190:Leaf
*p = (char )'\000';

//Stmt191:Parent
if ((unsigned long )p > (unsigned long )name) {
//Stmt187:Leaf
p --;

//Stmt188:Parent
if (! ((int )*p == 32)) {
//Stmt186:Leaf
break;

         }

       } else {
//Stmt189:Leaf
break;

       }

     }

//Stmt250:Leaf
tmp___5 = strcmp((char const   *)name, "//");

//Stmt251:Parent
if (tmp___5) {
//Stmt194:Leaf
tmp___6 = strcmp((char const   *)name, "ARFILENAMES/");

//Stmt195:Parent
if (tmp___6) {
//Stmt192:Leaf
tmp___7 = 0;

       } else {
//Stmt193:Leaf
tmp___7 = 1;

       }

     } else {
//Stmt196:Leaf
tmp___7 = 1;

     }

//Stmt252:Leaf
is_namemap = tmp___7;

//Stmt253:Parent
if ((int )*p == 47) {
//Stmt197:Leaf
*p = (char )'\000';

     }

//Stmt254:Parent
if (! is_namemap) {
//Stmt220:Parent
if ((int )*(name + 0) == 32) {
//Stmt204:Leaf
goto _L___1;

       } else
       {
//Stmt205:Parent
if ((int )*(name + 0) == 47) {
         _L___1: /* CIL Label */ 
         {
//Stmt202:Parent
if ((unsigned long )namemap != (unsigned long )((char *)0)) {
//Stmt198:Leaf
tmp___8 = atoi((char const   *)(name + 1));

//Stmt199:Leaf
name = namemap + tmp___8;

//Stmt200:Leaf
long_name = 1;

         } else {
//Stmt201:Leaf
goto _L___0;

         }
}

       } else {
//Stmt203:Leaf
goto _L___0;

       }
}


     } else
     _L___0: /* CIL Label */ 
     {
//Stmt219:Parent
if ((int )*(name + 0) == 35) {
//Stmt218:Parent
if ((int )*(name + 1) == 49) {
//Stmt217:Parent
if ((int )*(name + 2) == 47) {
//Stmt208:Leaf
tmp___9 = atoi((char const   *)(name + 3));

//Stmt209:Leaf
namesize = tmp___9;

//Stmt210:Leaf
tmp___10 = __builtin_alloca((unsigned long )(namesize + 1));

//Stmt211:Leaf
name = (char *)tmp___10;

//Stmt212:Leaf
tmp___11 = read(desc, (void *)name, (size_t )namesize);

//Stmt213:Leaf
nread___0 = (int )tmp___11;

//Stmt214:Parent
if (nread___0 != namesize) {
//Stmt206:Leaf
close(desc);

//Stmt207:Leaf
return (-2L);

           }

//Stmt215:Leaf
*(name + namesize) = (char )'\000';

//Stmt216:Leaf
long_name = 1;

         }

       }

     }
}


//Stmt255:Leaf
sscanf((char const   * __restrict  )(member_header.ar_mode), (char const   * __restrict  )"%o",
            & eltmode);

//Stmt256:Leaf
eltsize = atol((char const   *)(member_header.ar_size));

//Stmt257:Leaf
tmp___12 = atoi((char const   *)(member_header.ar_gid));

//Stmt258:Leaf
tmp___13 = atoi((char const   *)(member_header.ar_uid));

//Stmt259:Leaf
tmp___14 = atol((char const   *)(member_header.ar_date));

//Stmt260:Leaf
fnval = (*function)(desc, name, ! long_name, member_offset, (unsigned long )member_offset + sizeof(struct ar_hdr ),
                         eltsize, tmp___14, tmp___13, tmp___12, eltmode, arg);

//Stmt261:Parent
if (fnval) {
//Stmt221:Leaf
close(desc);

//Stmt222:Leaf
return (fnval);

     }

//Stmt262:Parent
if (is_namemap) {
//Stmt230:Leaf
tmp___15 = __builtin_alloca((unsigned long )eltsize);

//Stmt231:Leaf
namemap = (char *)tmp___15;

//Stmt232:Leaf
tmp___16 = read(desc, (void *)namemap, (size_t )eltsize);

//Stmt233:Leaf
nread___0 = (int )tmp___16;

//Stmt234:Parent
if ((long )nread___0 != eltsize) {
//Stmt223:Leaf
close(desc);

//Stmt224:Leaf
return (-2L);

       }

//Stmt235:Leaf
limit = namemap + eltsize;

//Stmt236:Leaf
clear = namemap;

//Stmt237:Parent
while ((unsigned long )clear < (unsigned long )limit) {
//Stmt228:Parent
if ((int )*clear == 10) {
//Stmt226:Leaf
*clear = (char )'\000';

//Stmt227:Parent
if ((int )*(clear + -1) == 47) {
//Stmt225:Leaf
*(clear + -1) = (char )'\000';

           }

         }

//Stmt229:Leaf
clear ++;

       }

//Stmt238:Leaf
is_namemap = 0;

     }

//Stmt263:Leaf
member_offset = (long )((unsigned long )member_offset + (sizeof(struct ar_hdr ) + (unsigned long )eltsize));

//Stmt264:Parent
if (member_offset % 2L != 0L) {
//Stmt239:Leaf
member_offset ++;

     }

   }

//Stmt311:Leaf
close(desc);

//Stmt312:Leaf
return (0L);

 }
}
 int ar_name_equal(char *name , char *mem , int truncated ) 
 { 
//Stmt318:Leaf
char *p ;

//Stmt319:Leaf
struct ar_hdr hdr ;

//Stmt320:Leaf
int tmp ;

//Stmt321:Leaf
int tmp___0 ;

//Stmt322:Leaf
int tmp___1 ;

 
   {
//Stmt323:Leaf
p = strrchr((char const   *)name, '/');

//Stmt324:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt313:Leaf
name = p + 1;

   }

//Stmt325:Parent
if (truncated) {
//Stmt314:Leaf
tmp = strncmp((char const   *)name, (char const   *)mem, sizeof(hdr.ar_name) - 1UL);

//Stmt315:Leaf
return (tmp == 0);

   }

//Stmt326:Leaf
tmp___0 = strcmp((char const   *)name, (char const   *)mem);

//Stmt327:Parent
if (tmp___0) {
//Stmt316:Leaf
tmp___1 = 0;

   } else {
//Stmt317:Leaf
tmp___1 = 1;

   }

//Stmt328:Leaf
return (tmp___1);

 }
}
 static long ar_member_pos(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                           long size , long date , int uid , int gid , int mode , char *name ) 
 { 
//Stmt330:Leaf
int tmp ;

 
   {
//Stmt331:Leaf
tmp = ar_name_equal(name, mem, truncated);

//Stmt332:Parent
if (! tmp) {
//Stmt329:Leaf
return (0L);

   }

//Stmt333:Leaf
return (hdrpos);

 }
}
 int ar_member_touch(char *arname , char *memname ) 
 { 
//Stmt352:Leaf
register long pos ;

//Stmt353:Leaf
long tmp ;

//Stmt354:Leaf
register int fd ;

//Stmt355:Leaf
struct ar_hdr ar_hdr ;

//Stmt356:Leaf
register int i ;

//Stmt357:Leaf
struct stat statbuf ;

//Stmt358:Leaf
__off_t tmp___0 ;

//Stmt359:Leaf
ssize_t tmp___1 ;

//Stmt360:Leaf
__off_t tmp___2 ;

//Stmt361:Leaf
ssize_t tmp___3 ;

//Stmt362:Leaf
int tmp___4 ;

//Stmt363:Leaf
int *tmp___5 ;

//Stmt364:Leaf
__off_t tmp___6 ;

//Stmt365:Leaf
ssize_t tmp___7 ;

//Stmt366:Leaf
int *tmp___8 ;

//Stmt367:Leaf
int *tmp___9 ;

 
   {
//Stmt368:Leaf
tmp = ar_scan(arname, (long (*)())(& ar_member_pos), (long )memname);

//Stmt369:Leaf
pos = tmp;

//Stmt370:Parent
if (pos < 0L) {
//Stmt334:Leaf
return ((int )pos);

   }

//Stmt371:Parent
if (! pos) {
//Stmt335:Leaf
return (1);

   }

//Stmt372:Leaf
fd = open((char const   *)arname, 2, 438);

//Stmt373:Parent
if (fd < 0) {
//Stmt336:Leaf
return (-3);

   }

//Stmt374:Leaf
tmp___0 = lseek(fd, pos, 0);

//Stmt375:Parent
if (tmp___0 < 0L) {
//Stmt337:Leaf
goto lose;

   }

//Stmt376:Leaf
tmp___1 = read(fd, (void *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));

//Stmt377:Parent
if (sizeof(struct ar_hdr ) != (unsigned long )tmp___1) {
//Stmt338:Leaf
goto lose;

   }

//Stmt378:Leaf
tmp___2 = lseek(fd, pos, 0);

//Stmt379:Parent
if (tmp___2 < 0L) {
//Stmt339:Leaf
goto lose;

   }

//Stmt380:Leaf
tmp___3 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));

//Stmt381:Parent
if (sizeof(struct ar_hdr ) != (unsigned long )tmp___3) {
//Stmt340:Leaf
goto lose;

   }

//Stmt382:Parent
while (1) {
//Stmt345:Leaf
tmp___4 = fstat(fd, & statbuf);

//Stmt346:Parent
if (tmp___4 < 0) {
//Stmt342:Leaf
tmp___5 = __errno_location();

//Stmt343:Parent
if (! (*tmp___5 == 4)) {
//Stmt341:Leaf
break;

       }

     } else {
//Stmt344:Leaf
break;

     }

   }

//Stmt383:Leaf
i = 0;

//Stmt384:Parent
while ((unsigned long )i < sizeof(ar_hdr.ar_date)) {
//Stmt347:Leaf
ar_hdr.ar_date[i] = (char )' ';

//Stmt348:Leaf
i ++;

   }

//Stmt385:Leaf
sprintf((char * __restrict  )(ar_hdr.ar_date), (char const   * __restrict  )"%ld",
           statbuf.st_mtim.tv_sec);

//Stmt386:Leaf
tmp___6 = lseek(fd, pos, 0);

//Stmt387:Parent
if (tmp___6 < 0L) {
//Stmt349:Leaf
goto lose;

   }

//Stmt388:Leaf
tmp___7 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));

//Stmt389:Parent
if (sizeof(struct ar_hdr ) != (unsigned long )tmp___7) {
//Stmt350:Leaf
goto lose;

   }

//Stmt390:Leaf
close(fd);

//Stmt391:Leaf
return (0);

   lose: 
   {
//Stmt351:Leaf
tmp___8 = __errno_location();

}
//Stmt392:Leaf
i = *tmp___8;

//Stmt393:Leaf
close(fd);

//Stmt394:Leaf
tmp___9 = __errno_location();

//Stmt395:Leaf
*tmp___9 = i;

//Stmt396:Leaf
return (-3);

 }
}
 #pragma merger("0","/tmp/cil-0y88q6_t.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
 extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                         void (*__handler)(int  ) ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                            int __sig ) ;
 extern struct _IO_FILE *stdout ;
 extern int printf(char const   * __restrict  __format  , ...) ;
 extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
 extern int puts(char const   *__s ) ;
 extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
 extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
 extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
  __attribute__((__noreturn__)) void pfatal_with_name(char *name ) ;
 char *xrealloc(char *ptr , unsigned int size ) ;
 char *sindex(char const   *big , unsigned int blen , char const   *small , unsigned int slen ) ;
 int handling_fatal_signal ;
 void uniquize_deps(struct dep *chain ) ;
 struct file *default_file ;
 void remove_intermediates(int sig ) ;
 void set_command_state(struct file *file , int state ) ;
 void notice_finished_file(struct file *file ) ;
 void initialize_file_variables(struct file *file , int reading ) ;
 struct variable *define_variable_in_set(char *name , unsigned int length___0 , char *value ,
                                         enum variable_origin origin , int recursive ,
                                         struct variable_set *set , struct floc  const  *flocp ) ;
 struct child *children ;
 void new_job(struct file *file ) ;
 void reap_children(int block , int err ) ;
 unsigned int job_slots_used ;
 void execute_file_commands(struct file *file ) ;
 void print_commands(struct commands *cmds ) ;
 void delete_child_targets(struct child *child ) ;
 void chop_commands(struct commands *cmds ) ;
 int remote_kill(int id , int sig ) ;
 static void set_file_variables(struct file *file ) 
 { 
//Stmt504:Leaf
register char *p ;

//Stmt505:Leaf
char *at ;

//Stmt506:Leaf
char *percent ;

//Stmt507:Leaf
char *star ;

//Stmt508:Leaf
char *less ;

//Stmt509:Leaf
unsigned int len ;

//Stmt510:Leaf
void *tmp ;

//Stmt511:Leaf
size_t tmp___0 ;

//Stmt512:Leaf
void *tmp___1 ;

//Stmt513:Leaf
int tmp___2 ;

//Stmt514:Leaf
register struct dep *d ;

//Stmt515:Leaf
char *name ;

//Stmt516:Leaf
unsigned int len___0 ;

//Stmt517:Leaf
char *tmp___3 ;

//Stmt518:Leaf
size_t tmp___4 ;

//Stmt519:Leaf
size_t tmp___5 ;

//Stmt520:Leaf
int tmp___6 ;

//Stmt521:Leaf
struct file *tmp___7 ;

//Stmt522:Leaf
unsigned int slen ;

//Stmt523:Leaf
char *tmp___8 ;

//Stmt524:Leaf
size_t tmp___9 ;

//Stmt525:Leaf
char *tmp___10 ;

//Stmt526:Leaf
int tmp___11 ;

//Stmt527:Leaf
char *tmp___12 ;

//Stmt528:Leaf
register unsigned int qmark_len ;

//Stmt529:Leaf
register unsigned int plus_len ;

//Stmt530:Leaf
char *caret_value ;

//Stmt531:Leaf
char *plus_value ;

//Stmt532:Leaf
register char *cp ;

//Stmt533:Leaf
char *qmark_value ;

//Stmt534:Leaf
register char *qp ;

//Stmt535:Leaf
register struct dep *d___0 ;

//Stmt536:Leaf
unsigned int len___1 ;

//Stmt537:Leaf
char *tmp___13 ;

//Stmt538:Leaf
size_t tmp___14 ;

//Stmt539:Leaf
void *tmp___15 ;

//Stmt540:Leaf
char *c ;

//Stmt541:Leaf
char *tmp___16 ;

//Stmt542:Leaf
char *tmp___17 ;

//Stmt543:Leaf
size_t tmp___18 ;

//Stmt544:Leaf
size_t tmp___19 ;

//Stmt545:Leaf
int tmp___20 ;

//Stmt546:Leaf
char *tmp___21 ;

//Stmt547:Leaf
int tmp___22 ;

//Stmt548:Leaf
void *tmp___23 ;

//Stmt549:Leaf
char *c___0 ;

//Stmt550:Leaf
char *tmp___24 ;

//Stmt551:Leaf
char *tmp___25 ;

//Stmt552:Leaf
size_t tmp___26 ;

//Stmt553:Leaf
size_t tmp___27 ;

//Stmt554:Leaf
int tmp___28 ;

//Stmt555:Leaf
char *tmp___29 ;

//Stmt556:Leaf
char *tmp___30 ;

//Stmt557:Leaf
int tmp___31 ;

//Stmt558:Leaf
int tmp___32 ;

 
   {
//Stmt559:Leaf
tmp___2 = ar_name(file->name);

//Stmt560:Parent
if (tmp___2) {
//Stmt397:Leaf
p = strchr((char const   *)file->name, '(');

//Stmt398:Leaf
tmp = __builtin_alloca((unsigned long )((p - file->name) + 1L));

//Stmt399:Leaf
at = (char *)tmp;

//Stmt400:Leaf
memmove((void *)at, (void const   *)file->name, (size_t )(p - file->name));

//Stmt401:Leaf
*(at + (p - file->name)) = (char )'\000';

//Stmt402:Leaf
tmp___0 = strlen((char const   *)(p + 1));

//Stmt403:Leaf
len = (unsigned int )tmp___0;

//Stmt404:Leaf
tmp___1 = __builtin_alloca((unsigned long )len);

//Stmt405:Leaf
percent = (char *)tmp___1;

//Stmt406:Leaf
memmove((void *)percent, (void const   *)(p + 1), (size_t )(len - 1U));

//Stmt407:Leaf
*(percent + (len - 1U)) = (char )'\000';

   } else {
//Stmt408:Leaf
at = file->name;

//Stmt409:Leaf
percent = (char *)"";

   }

//Stmt561:Parent
if ((unsigned long )file->stem == (unsigned long )((char *)0)) {
//Stmt432:Leaf
tmp___6 = ar_name(file->name);

//Stmt433:Parent
if (tmp___6) {
//Stmt410:Leaf
tmp___3 = strchr((char const   *)file->name, '(');

//Stmt411:Leaf
name = tmp___3 + 1;

//Stmt412:Leaf
tmp___4 = strlen((char const   *)name);

//Stmt413:Leaf
len___0 = (unsigned int )(tmp___4 - 1UL);

     } else {
//Stmt414:Leaf
name = file->name;

//Stmt415:Leaf
tmp___5 = strlen((char const   *)name);

//Stmt416:Leaf
len___0 = (unsigned int )tmp___5;

     }

//Stmt434:Leaf
tmp___7 = enter_file((char *)".SUFFIXES");

//Stmt435:Leaf
d = tmp___7->deps;

//Stmt436:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt426:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt417:Leaf
tmp___8 = (d->file)->name;

       } else {
//Stmt418:Leaf
tmp___8 = d->name;

       }

//Stmt427:Leaf
tmp___9 = strlen((char const   *)tmp___8);

//Stmt428:Leaf
slen = (unsigned int )tmp___9;

//Stmt429:Parent
if (len___0 > slen) {
//Stmt423:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt419:Leaf
tmp___10 = (d->file)->name;

         } else {
//Stmt420:Leaf
tmp___10 = d->name;

         }

//Stmt424:Leaf
tmp___11 = strncmp((char const   *)tmp___10, (char const   *)(name + (len___0 - slen)),
                            (size_t )slen);

//Stmt425:Parent
if (tmp___11 == 0) {
//Stmt421:Leaf
file->stem = savestring((char const   *)name, len___0 - slen);

//Stmt422:Leaf
break;

         }

       }

//Stmt430:Leaf
d = d->next;

     }

//Stmt437:Parent
if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
//Stmt431:Leaf
file->stem = (char *)"";

     }

   }

//Stmt562:Leaf
star = file->stem;

//Stmt563:Parent
if ((unsigned long )file->deps != (unsigned long )((struct dep *)0)) {
//Stmt440:Parent
if ((unsigned long )(file->deps)->name == (unsigned long )((char *)0)) {
//Stmt438:Leaf
tmp___12 = ((file->deps)->file)->name;

     } else {
//Stmt439:Leaf
tmp___12 = (file->deps)->name;

     }

//Stmt441:Leaf
less = tmp___12;

   } else {
//Stmt442:Leaf
less = (char *)"";

   }

//Stmt564:Parent
if ((unsigned long )file->cmds == (unsigned long )default_file->cmds) {
//Stmt443:Leaf
less = at;

   }

//Stmt565:Leaf
define_variable_in_set((char *)"<", 1U, less, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));

//Stmt566:Leaf
define_variable_in_set((char *)"*", 1U, star, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));

//Stmt567:Leaf
define_variable_in_set((char *)"@", 1U, at, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));

//Stmt568:Leaf
define_variable_in_set((char *)"%", 1U, percent, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));

//Stmt569:Leaf
plus_len = 0U;

//Stmt570:Leaf
d___0 = file->deps;

//Stmt571:Parent
while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
//Stmt446:Parent
if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
//Stmt444:Leaf
tmp___13 = (d___0->file)->name;

     } else {
//Stmt445:Leaf
tmp___13 = d___0->name;

     }

//Stmt447:Leaf
tmp___14 = strlen((char const   *)tmp___13);

//Stmt448:Leaf
plus_len = (unsigned int )((size_t )plus_len + (tmp___14 + 1UL));

//Stmt449:Leaf
d___0 = d___0->next;

   }

//Stmt572:Parent
if (plus_len == 0U) {
//Stmt450:Leaf
len___1 = 1U;

   } else {
//Stmt451:Leaf
len___1 = plus_len;

   }

//Stmt573:Leaf
tmp___15 = __builtin_alloca((unsigned long )len___1);

//Stmt574:Leaf
plus_value = (char *)tmp___15;

//Stmt575:Leaf
cp = plus_value;

//Stmt576:Leaf
qmark_len = plus_len;

//Stmt577:Leaf
d___0 = file->deps;

//Stmt578:Parent
while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
//Stmt461:Parent
if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
//Stmt452:Leaf
tmp___16 = (d___0->file)->name;

     } else {
//Stmt453:Leaf
tmp___16 = d___0->name;

     }

//Stmt462:Leaf
c = tmp___16;

//Stmt463:Leaf
tmp___20 = ar_name(c);

//Stmt464:Parent
if (tmp___20) {
//Stmt454:Leaf
tmp___17 = strchr((char const   *)c, '(');

//Stmt455:Leaf
c = tmp___17 + 1;

//Stmt456:Leaf
tmp___18 = strlen((char const   *)c);

//Stmt457:Leaf
len___1 = (unsigned int )(tmp___18 - 1UL);

     } else {
//Stmt458:Leaf
tmp___19 = strlen((char const   *)c);

//Stmt459:Leaf
len___1 = (unsigned int )tmp___19;

     }

//Stmt465:Leaf
memmove((void *)cp, (void const   *)c, (size_t )len___1);

//Stmt466:Leaf
cp += len___1;

//Stmt467:Leaf
tmp___21 = cp;

//Stmt468:Leaf
cp ++;

//Stmt469:Leaf
*tmp___21 = (char )' ';

//Stmt470:Parent
if (! d___0->changed) {
//Stmt460:Leaf
qmark_len -= len___1 + 1U;

     }

//Stmt471:Leaf
d___0 = d___0->next;

   }

//Stmt579:Parent
if ((unsigned long )cp > (unsigned long )plus_value) {
//Stmt472:Leaf
tmp___22 = -1;

   } else {
//Stmt473:Leaf
tmp___22 = 0;

   }

//Stmt580:Leaf
*(cp + tmp___22) = (char )'\000';

//Stmt581:Leaf
define_variable_in_set((char *)"+", 1U, plus_value, (enum variable_origin )6, 0,
                          (file->variables)->set, (struct floc  const  *)((struct floc *)0));

//Stmt582:Leaf
uniquize_deps(file->deps);

//Stmt583:Leaf
caret_value = plus_value;

//Stmt584:Leaf
cp = caret_value;

//Stmt585:Parent
if (qmark_len == 0U) {
//Stmt474:Leaf
len___1 = 1U;

   } else {
//Stmt475:Leaf
len___1 = qmark_len;

   }

//Stmt586:Leaf
tmp___23 = __builtin_alloca((unsigned long )len___1);

//Stmt587:Leaf
qmark_value = (char *)tmp___23;

//Stmt588:Leaf
qp = qmark_value;

//Stmt589:Leaf
d___0 = file->deps;

//Stmt590:Parent
while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
//Stmt489:Parent
if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
//Stmt476:Leaf
tmp___24 = (d___0->file)->name;

     } else {
//Stmt477:Leaf
tmp___24 = d___0->name;

     }

//Stmt490:Leaf
c___0 = tmp___24;

//Stmt491:Leaf
tmp___28 = ar_name(c___0);

//Stmt492:Parent
if (tmp___28) {
//Stmt478:Leaf
tmp___25 = strchr((char const   *)c___0, '(');

//Stmt479:Leaf
c___0 = tmp___25 + 1;

//Stmt480:Leaf
tmp___26 = strlen((char const   *)c___0);

//Stmt481:Leaf
len___1 = (unsigned int )(tmp___26 - 1UL);

     } else {
//Stmt482:Leaf
tmp___27 = strlen((char const   *)c___0);

//Stmt483:Leaf
len___1 = (unsigned int )tmp___27;

     }

//Stmt493:Leaf
memmove((void *)cp, (void const   *)c___0, (size_t )len___1);

//Stmt494:Leaf
cp += len___1;

//Stmt495:Leaf
tmp___29 = cp;

//Stmt496:Leaf
cp ++;

//Stmt497:Leaf
*tmp___29 = (char )' ';

//Stmt498:Parent
if (d___0->changed) {
//Stmt484:Leaf
memmove((void *)qp, (void const   *)c___0, (size_t )len___1);

//Stmt485:Leaf
qp += len___1;

//Stmt486:Leaf
tmp___30 = qp;

//Stmt487:Leaf
qp ++;

//Stmt488:Leaf
*tmp___30 = (char )' ';

     }

//Stmt499:Leaf
d___0 = d___0->next;

   }

//Stmt591:Parent
if ((unsigned long )cp > (unsigned long )caret_value) {
//Stmt500:Leaf
tmp___31 = -1;

   } else {
//Stmt501:Leaf
tmp___31 = 0;

   }

//Stmt592:Leaf
*(cp + tmp___31) = (char )'\000';

//Stmt593:Leaf
define_variable_in_set((char *)"^", 1U, caret_value, (enum variable_origin )6, 0,
                          (file->variables)->set, (struct floc  const  *)((struct floc *)0));

//Stmt594:Parent
if ((unsigned long )qp > (unsigned long )qmark_value) {
//Stmt502:Leaf
tmp___32 = -1;

   } else {
//Stmt503:Leaf
tmp___32 = 0;

   }

//Stmt595:Leaf
*(qp + tmp___32) = (char )'\000';

//Stmt596:Leaf
define_variable_in_set((char *)"?", 1U, qmark_value, (enum variable_origin )6, 0,
                          (file->variables)->set, (struct floc  const  *)((struct floc *)0));

//Stmt597:Leaf
return;

 }
}
 void chop_commands(struct commands *cmds ) 
 { 
//Stmt659:Leaf
register char *p ;

//Stmt660:Leaf
unsigned int nlines ;

//Stmt661:Leaf
unsigned int idx ;

//Stmt662:Leaf
char **lines ;

//Stmt663:Leaf
char *tmp ;

//Stmt664:Leaf
char *end ;

//Stmt665:Leaf
size_t tmp___0 ;

//Stmt666:Leaf
int backslash ;

//Stmt667:Leaf
register char *b ;

//Stmt668:Leaf
char *tmp___1 ;

//Stmt669:Leaf
unsigned int tmp___2 ;

//Stmt670:Leaf
char *tmp___3 ;

//Stmt671:Leaf
char *tmp___4 ;

//Stmt672:Leaf
int flags ;

//Stmt673:Leaf
unsigned short const   **tmp___5 ;

//Stmt674:Leaf
unsigned int len ;

//Stmt675:Leaf
size_t tmp___6 ;

//Stmt676:Leaf
char *tmp___7 ;

//Stmt677:Leaf
char *tmp___8 ;

 
   {
//Stmt678:Parent
if (! cmds) {
//Stmt599:Leaf
return;

   } else
   {
//Stmt600:Parent
if ((unsigned long )cmds->command_lines != (unsigned long )((char **)0)) {
//Stmt598:Leaf
return;

   }
}


//Stmt679:Leaf
nlines = 5U;

//Stmt680:Leaf
tmp = xmalloc((unsigned int )(5UL * sizeof(char *)));

//Stmt681:Leaf
lines = (char **)tmp;

//Stmt682:Leaf
idx = 0U;

//Stmt683:Leaf
p = cmds->commands;

//Stmt684:Parent
while ((int )*p != 0) {
//Stmt622:Leaf
end = p;

     find_end: 
     {
//Stmt601:Leaf
end = strchr((char const   *)end, '\n');

}
//Stmt623:Parent
if ((unsigned long )end == (unsigned long )((char *)0)) {
//Stmt615:Leaf
tmp___0 = strlen((char const   *)p);

//Stmt616:Leaf
end = p + tmp___0;

     } else
     {
//Stmt617:Parent
if ((unsigned long )end > (unsigned long )p) {
//Stmt614:Parent
if ((int )*(end + -1) == 92) {
//Stmt610:Leaf
backslash = 1;

//Stmt611:Leaf
b = end - 2;

//Stmt612:Parent
while (1) {
//Stmt605:Parent
if ((unsigned long )b >= (unsigned long )p) {
//Stmt603:Parent
if (! ((int )*b == 92)) {
//Stmt602:Leaf
break;

             }

           } else {
//Stmt604:Leaf
break;

           }

//Stmt606:Leaf
backslash = ! backslash;

//Stmt607:Leaf
b --;

         }

//Stmt613:Parent
if (backslash) {
//Stmt608:Leaf
end ++;

//Stmt609:Leaf
goto find_end;

         }

       }

     }
}


//Stmt624:Parent
if (idx == nlines) {
//Stmt618:Leaf
nlines += 2U;

//Stmt619:Leaf
tmp___1 = xrealloc((char *)lines, (unsigned int )((unsigned long )nlines * sizeof(char *)));

//Stmt620:Leaf
lines = (char **)tmp___1;

     }

//Stmt625:Leaf
tmp___2 = idx;

//Stmt626:Leaf
idx ++;

//Stmt627:Leaf
*(lines + tmp___2) = savestring((char const   *)p, (unsigned int )(end - p));

//Stmt628:Leaf
p = end;

//Stmt629:Parent
if ((int )*p != 0) {
//Stmt621:Leaf
p ++;

     }

   }

//Stmt685:Parent
if (idx != nlines) {
//Stmt630:Leaf
nlines = idx;

//Stmt631:Leaf
tmp___3 = xrealloc((char *)lines, (unsigned int )((unsigned long )nlines * sizeof(char *)));

//Stmt632:Leaf
lines = (char **)tmp___3;

   }

//Stmt686:Leaf
cmds->ncommand_lines = nlines;

//Stmt687:Leaf
cmds->command_lines = lines;

//Stmt688:Leaf
cmds->any_recurse = 0;

//Stmt689:Leaf
tmp___4 = xmalloc(nlines);

//Stmt690:Leaf
cmds->lines_flags = tmp___4;

//Stmt691:Leaf
idx = 0U;

//Stmt692:Parent
while (idx < nlines) {
//Stmt652:Leaf
flags = 0;

//Stmt653:Leaf
p = *(lines + idx);

//Stmt654:Parent
while (1) {
//Stmt640:Leaf
tmp___5 = __ctype_b_loc();

//Stmt641:Parent
if (! ((int const   )*(*tmp___5 + (int )*p) & 1)) {
//Stmt636:Parent
if (! ((int )*p == 45)) {
//Stmt635:Parent
if (! ((int )*p == 64)) {
//Stmt634:Parent
if (! ((int )*p == 43)) {
//Stmt633:Leaf
break;

             }

           }

         }

       }

//Stmt642:Parent
switch ((int )*p) {
       case 43:; 
//Stmt637:Leaf
flags |= 1;

       break;
       case 64:; 
//Stmt638:Leaf
flags |= 2;

       break;
       case 45:; 
//Stmt639:Leaf
flags |= 4;

       break;
       }

//Stmt643:Leaf
p ++;

     }

//Stmt655:Parent
if (! (flags & 1)) {
//Stmt648:Leaf
tmp___6 = strlen((char const   *)p);

//Stmt649:Leaf
len = (unsigned int )tmp___6;

//Stmt650:Leaf
tmp___7 = sindex((char const   *)p, len, "$(MAKE)", 7U);

//Stmt651:Parent
if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
//Stmt645:Leaf
flags |= 1;

       } else {
//Stmt646:Leaf
tmp___8 = sindex((char const   *)p, len, "${MAKE}", 7U);

//Stmt647:Parent
if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
//Stmt644:Leaf
flags |= 1;

         }

       }

     }

//Stmt656:Leaf
*(cmds->lines_flags + idx) = (char )flags;

//Stmt657:Leaf
cmds->any_recurse |= flags & 1;

//Stmt658:Leaf
idx ++;

   }

//Stmt693:Leaf
return;

 }
}
 void execute_file_commands(struct file *file ) 
 { 
//Stmt704:Leaf
register char *p ;

//Stmt705:Leaf
unsigned short const   **tmp ;

 
   {
//Stmt706:Leaf
p = (file->cmds)->commands;

//Stmt707:Parent
while ((int )*p != 0) {
//Stmt697:Leaf
tmp = __ctype_b_loc();

//Stmt698:Parent
if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
//Stmt696:Parent
if ((int )*p != 45) {
//Stmt695:Parent
if ((int )*p != 64) {
//Stmt694:Leaf
break;

         }

       }

     }

//Stmt699:Leaf
p ++;

   }

//Stmt708:Parent
if ((int )*p == 0) {
//Stmt700:Leaf
set_command_state(file, 2);

//Stmt701:Leaf
file->update_status = (short)0;

//Stmt702:Leaf
notice_finished_file(file);

//Stmt703:Leaf
return;

   }

//Stmt709:Leaf
initialize_file_variables(file, 0);

//Stmt710:Leaf
set_file_variables(file);

//Stmt711:Leaf
new_job(file);

//Stmt712:Leaf
return;

 }
}
 int handling_fatal_signal  =    0;
 void fatal_error_signal(int sig ) 
 { 
//Stmt739:Leaf
register struct child *c ;

//Stmt740:Leaf
register struct child *c___0 ;

//Stmt741:Leaf
__pid_t tmp ;

//Stmt742:Leaf
int tmp___0 ;

 
   {
//Stmt743:Leaf
handling_fatal_signal = 1;

//Stmt744:Leaf
signal(sig, (void (*)(int  ))0);

//Stmt745:Parent
if (sig == 15) {
//Stmt716:Leaf
c = children;

//Stmt717:Parent
while ((unsigned long )c != (unsigned long )((struct child *)0)) {
//Stmt714:Parent
if (! c->remote) {
//Stmt713:Leaf
kill(c->pid, 15);

       }

//Stmt715:Leaf
c = c->next;

     }

   }

//Stmt746:Parent
if (sig == 15) {
//Stmt735:Leaf
goto _L;

   } else
   {
//Stmt736:Parent
if (sig == 2) {
//Stmt733:Leaf
goto _L;

   } else
   {
//Stmt734:Parent
if (sig == 1) {
//Stmt731:Leaf
goto _L;

   } else
   {
//Stmt732:Parent
if (sig == 3) {
     _L: /* CIL Label */ 
     {
//Stmt718:Leaf
c___0 = children;

}
//Stmt726:Parent
while ((unsigned long )c___0 != (unsigned long )((struct child *)0)) {
//Stmt720:Parent
if (c___0->remote) {
//Stmt719:Leaf
remote_kill(c___0->pid, sig);

       }

//Stmt721:Leaf
c___0 = c___0->next;

     }

//Stmt727:Leaf
c___0 = children;

//Stmt728:Parent
while ((unsigned long )c___0 != (unsigned long )((struct child *)0)) {
//Stmt722:Leaf
delete_child_targets(c___0);

//Stmt723:Leaf
c___0 = c___0->next;

     }

//Stmt729:Parent
while (job_slots_used > 0U) {
//Stmt724:Leaf
reap_children(1, 0);

     }

   } else {
//Stmt730:Parent
while (job_slots_used > 0U) {
//Stmt725:Leaf
reap_children(1, 1);

     }

   }
}

}

}


//Stmt747:Leaf
remove_intermediates(1);

//Stmt748:Parent
if (sig == 3) {
//Stmt737:Leaf
exit(1);

   }

//Stmt749:Leaf
tmp = getpid();

//Stmt750:Leaf
tmp___0 = kill(tmp, sig);

//Stmt751:Parent
if (tmp___0 < 0) {
//Stmt738:Leaf
pfatal_with_name((char *)"kill");

   }

//Stmt752:Leaf
return;

 }
}
 static void delete_target(struct file *file , char *on_behalf_of ) 
 { 
//Stmt788:Leaf
struct stat st ;

//Stmt789:Leaf
char *tmp ;

//Stmt790:Leaf
char *tmp___0 ;

//Stmt791:Leaf
time_t tmp___1 ;

//Stmt792:Leaf
uintmax_t tmp___2 ;

//Stmt793:Leaf
uintmax_t tmp___3 ;

//Stmt794:Leaf
int tmp___4 ;

//Stmt795:Leaf
char *tmp___5 ;

//Stmt796:Leaf
char *tmp___6 ;

//Stmt797:Leaf
int tmp___7 ;

//Stmt798:Leaf
int *tmp___8 ;

//Stmt799:Leaf
int tmp___9 ;

//Stmt800:Leaf
uintmax_t tmp___10 ;

//Stmt801:Leaf
uintmax_t tmp___11 ;

 
   {
//Stmt802:Parent
if (file->precious) {
//Stmt754:Leaf
return;

   } else
   {
//Stmt755:Parent
if (file->phony) {
//Stmt753:Leaf
return;

   }
}


//Stmt803:Leaf
tmp___4 = ar_name(file->name);

//Stmt804:Parent
if (tmp___4) {
//Stmt765:Leaf
tmp___1 = ar_member_date(file->name);

//Stmt766:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt756:Leaf
tmp___2 = (uintmax_t )1000000000;

     } else {
//Stmt757:Leaf
tmp___2 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

     }

//Stmt767:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt758:Leaf
tmp___3 = (uintmax_t )1000000000;

     } else {
//Stmt759:Leaf
tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

     }

//Stmt768:Parent
if ((uintmax_t )tmp___1 != file->last_mtime / tmp___2 - (uintmax_t )(file->last_mtime % tmp___3 < 0UL)) {
//Stmt764:Parent
if (on_behalf_of) {
//Stmt760:Leaf
tmp = dcgettext((char const   *)((void *)0), "*** [%s] Archive member `%s\' may be bogus; not deleted",
                         5);

//Stmt761:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp, on_behalf_of,
               file->name);

       } else {
//Stmt762:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "*** Archive member `%s\' may be bogus; not deleted",
                             5);

//Stmt763:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0,
               file->name);

       }

     }

//Stmt769:Leaf
return;

   }

//Stmt805:Leaf
tmp___9 = stat((char const   * __restrict  )file->name, (struct stat * __restrict  )(& st));

//Stmt806:Parent
if (tmp___9 == 0) {
//Stmt787:Parent
if ((st.st_mode & 61440U) == 32768U) {
//Stmt784:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt770:Leaf
tmp___10 = (uintmax_t )1000000000;

       } else {
//Stmt771:Leaf
tmp___10 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

       }

//Stmt785:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt772:Leaf
tmp___11 = (uintmax_t )1000000000;

       } else {
//Stmt773:Leaf
tmp___11 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

       }

//Stmt786:Parent
if ((uintmax_t )st.st_mtim.tv_sec * tmp___10 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___11) / 1000000000UL != file->last_mtime) {
//Stmt781:Parent
if (on_behalf_of) {
//Stmt774:Leaf
tmp___5 = dcgettext((char const   *)((void *)0), "*** [%s] Deleting file `%s\'",
                               5);

//Stmt775:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___5,
                 on_behalf_of, file->name);

         } else {
//Stmt776:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "*** Deleting file `%s\'",
                               5);

//Stmt777:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                 file->name);

         }

//Stmt782:Leaf
tmp___7 = unlink((char const   *)file->name);

//Stmt783:Parent
if (tmp___7 < 0) {
//Stmt779:Leaf
tmp___8 = __errno_location();

//Stmt780:Parent
if (*tmp___8 != 2) {
//Stmt778:Leaf
perror_with_name((char *)"unlink: ", file->name);

           }

         }

       }

     }

   }

//Stmt807:Leaf
return;

 }
}
 void delete_child_targets(struct child *child ) 
 { 
//Stmt811:Leaf
struct dep *d ;

 
   {
//Stmt812:Parent
if (child->deleted) {
//Stmt808:Leaf
return;

   }

//Stmt813:Leaf
delete_target(child->file, (char *)0);

//Stmt814:Leaf
d = (child->file)->also_make;

//Stmt815:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt809:Leaf
delete_target(d->file, (child->file)->name);

//Stmt810:Leaf
d = d->next;

   }

//Stmt816:Leaf
child->deleted = 1U;

//Stmt817:Leaf
return;

 }
}
 void print_commands(struct commands *cmds ) 
 { 
//Stmt833:Leaf
register char *s ;

//Stmt834:Leaf
char *tmp ;

//Stmt835:Leaf
char *tmp___0 ;

//Stmt836:Leaf
char *tmp___1 ;

//Stmt837:Leaf
char *end ;

//Stmt838:Leaf
unsigned short const   **tmp___2 ;

//Stmt839:Leaf
size_t tmp___3 ;

 
   {
//Stmt840:Leaf
tmp = dcgettext((char const   *)((void *)0), "#  commands to execute", 5);

//Stmt841:Leaf
fputs((char const   * __restrict  )tmp, (FILE * __restrict  )stdout);

//Stmt842:Parent
if ((unsigned long )cmds->fileinfo.filenm == (unsigned long )((char *)0)) {
//Stmt818:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), " (built-in):", 5);

//Stmt819:Leaf
puts((char const   *)tmp___0);

   } else {
//Stmt820:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), " (from `%s\', line %lu):\n",
                         5);

//Stmt821:Leaf
printf((char const   * __restrict  )tmp___1, cmds->fileinfo.filenm, cmds->fileinfo.lineno);

   }

//Stmt843:Leaf
s = cmds->commands;

//Stmt844:Parent
while ((int )*s != 0) {
//Stmt828:Parent
while (1) {
//Stmt823:Leaf
tmp___2 = __ctype_b_loc();

//Stmt824:Parent
if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192)) {
//Stmt822:Leaf
break;

       }

//Stmt825:Leaf
s ++;

     }

//Stmt829:Leaf
end = strchr((char const   *)s, '\n');

//Stmt830:Parent
if ((unsigned long )end == (unsigned long )((char *)0)) {
//Stmt826:Leaf
tmp___3 = strlen((char const   *)s);

//Stmt827:Leaf
end = s + tmp___3;

     }

//Stmt831:Leaf
printf((char const   * __restrict  )"\t%.*s\n", (int )(end - s), s);

//Stmt832:Leaf
s = end;

   }

//Stmt845:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-VKXtmFCh.i","-g,-O0")
 extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                                int __c ,
                                                                                                size_t __n ) ;
 char *xstrdup(char const   *ptr ) ;
 int dir_file_exists_p(char *dirname , char *filename ) ;
 int file_impossible_p(char *filename ) ;
 void file_impossible(char *filename ) ;
 char *dir_name(char *dir ) ;
 extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
 extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
 extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
 static struct directory_contents *directories_contents[199]  ;
 static struct directory *directories[199]  ;
 static unsigned int open_directories  =    0U;
 static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) ;
 static struct directory *find_directory(char *name ) ;
 static struct directory *find_directory(char *name ) 
 { 
//Stmt891:Leaf
register unsigned int hash ;

//Stmt892:Leaf
register char *p ;

//Stmt893:Leaf
register struct directory *dir ;

//Stmt894:Leaf
int tmp ;

//Stmt895:Leaf
struct stat st ;

//Stmt896:Leaf
char *tmp___0 ;

//Stmt897:Leaf
struct directory_contents *dc ;

//Stmt898:Leaf
char *tmp___1 ;

//Stmt899:Leaf
char *tmp___2 ;

//Stmt900:Leaf
int tmp___3 ;

 
   {
//Stmt901:Leaf
hash = 0U;

//Stmt902:Leaf
p = name;

//Stmt903:Parent
while ((int )*p != 0) {
//Stmt846:Leaf
hash += (unsigned int )*p;

//Stmt847:Leaf
hash = (hash << 7) + (hash >> 20);

//Stmt848:Leaf
p ++;

   }

//Stmt904:Leaf
hash %= 199U;

//Stmt905:Leaf
dir = directories[hash];

//Stmt906:Parent
while ((unsigned long )dir != (unsigned long )((struct directory *)0)) {
//Stmt856:Parent
if ((unsigned long )dir->name == (unsigned long )name) {
//Stmt854:Leaf
break;

     } else
     {
//Stmt855:Parent
if ((int )*(dir->name) == (int )*name) {
//Stmt853:Parent
if ((int )*(dir->name) == 0) {
//Stmt850:Leaf
break;

       } else {
//Stmt851:Leaf
tmp = strcmp((char const   *)(dir->name + 1), (char const   *)(name + 1));

//Stmt852:Parent
if (! tmp) {
//Stmt849:Leaf
break;

         }

       }

     }
}


//Stmt857:Leaf
dir = dir->next;

   }

//Stmt907:Parent
if ((unsigned long )dir == (unsigned long )((struct directory *)0)) {
//Stmt884:Leaf
tmp___0 = xmalloc((unsigned int )sizeof(struct directory ));

//Stmt885:Leaf
dir = (struct directory *)tmp___0;

//Stmt886:Leaf
dir->next = directories[hash];

//Stmt887:Leaf
directories[hash] = dir;

//Stmt888:Leaf
dir->name = savestring((char const   *)name, (unsigned int )(p - name));

//Stmt889:Leaf
tmp___3 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));

//Stmt890:Parent
if (tmp___3 < 0) {
//Stmt877:Leaf
dir->contents = (struct directory_contents *)0;

     } else {
//Stmt878:Leaf
hash = ((unsigned int )st.st_dev << 16) | (unsigned int )st.st_ino;

//Stmt879:Leaf
hash %= 199U;

//Stmt880:Leaf
dc = directories_contents[hash];

//Stmt881:Parent
while ((unsigned long )dc != (unsigned long )((struct directory_contents *)0)) {
//Stmt860:Parent
if (dc->dev == st.st_dev) {
//Stmt859:Parent
if (dc->ino == st.st_ino) {
//Stmt858:Leaf
break;

           }

         }

//Stmt861:Leaf
dc = dc->next;

       }

//Stmt882:Parent
if ((unsigned long )dc == (unsigned long )((struct directory_contents *)0)) {
//Stmt869:Leaf
tmp___1 = xmalloc((unsigned int )sizeof(struct directory_contents ));

//Stmt870:Leaf
dc = (struct directory_contents *)tmp___1;

//Stmt871:Leaf
dc->dev = st.st_dev;

//Stmt872:Leaf
dc->ino = st.st_ino;

//Stmt873:Leaf
dc->next = directories_contents[hash];

//Stmt874:Leaf
directories_contents[hash] = dc;

//Stmt875:Leaf
dc->dirstream = opendir((char const   *)name);

//Stmt876:Parent
if ((unsigned long )dc->dirstream == (unsigned long )((DIR *)0)) {
//Stmt863:Leaf
dc->files = (struct dirfile **)0;

         } else {
//Stmt864:Leaf
tmp___2 = xmalloc((unsigned int )(sizeof(struct dirfile *) * 107UL));

//Stmt865:Leaf
dc->files = (struct dirfile **)tmp___2;

//Stmt866:Leaf
memset((void *)((char *)dc->files), 0, sizeof(struct dirfile *) * 107UL);

//Stmt867:Leaf
open_directories ++;

//Stmt868:Parent
if (open_directories == 10U) {
//Stmt862:Leaf
dir_contents_file_exists_p(dc, (char *)0);

           }

         }

       }

//Stmt883:Leaf
dir->contents = dc;

     }

   }

//Stmt908:Leaf
return (dir);

 }
}
 static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) 
 { 
//Stmt965:Leaf
register unsigned int hash ;

//Stmt966:Leaf
register char *p ;

//Stmt967:Leaf
register struct dirfile *df ;

//Stmt968:Leaf
register struct dirent *d ;

//Stmt969:Leaf
int tmp ;

//Stmt970:Leaf
register unsigned int newhash ;

//Stmt971:Leaf
unsigned int len ;

//Stmt972:Leaf
register unsigned int i ;

//Stmt973:Leaf
size_t tmp___0 ;

//Stmt974:Leaf
char *tmp___1 ;

//Stmt975:Leaf
int tmp___2 ;

 
   {
//Stmt976:Parent
if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
//Stmt910:Leaf
return (0);

   } else
   {
//Stmt911:Parent
if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
//Stmt909:Leaf
return (0);

   }
}


//Stmt977:Leaf
hash = 0U;

//Stmt978:Parent
if ((unsigned long )filename != (unsigned long )((char *)0)) {
//Stmt925:Parent
if ((int )*filename == 0) {
//Stmt912:Leaf
return (1);

     }

//Stmt926:Leaf
p = filename;

//Stmt927:Parent
while ((int )*p != 0) {
//Stmt913:Leaf
hash += (unsigned int )*p;

//Stmt914:Leaf
hash = (hash << 7) + (hash >> 20);

//Stmt915:Leaf
p ++;

     }

//Stmt928:Leaf
hash %= 107U;

//Stmt929:Leaf
df = *(dir->files + hash);

//Stmt930:Parent
while ((unsigned long )df != (unsigned long )((struct dirfile *)0)) {
//Stmt923:Parent
if ((unsigned long )df->name == (unsigned long )filename) {
//Stmt921:Leaf
return (! df->impossible);

       } else
       {
//Stmt922:Parent
if ((int )*(df->name) == (int )*filename) {
//Stmt920:Parent
if ((int )*(df->name) == 0) {
//Stmt917:Leaf
return (! df->impossible);

         } else {
//Stmt918:Leaf
tmp = strcmp((char const   *)(df->name + 1), (char const   *)(filename + 1));

//Stmt919:Parent
if (! tmp) {
//Stmt916:Leaf
return (! df->impossible);

           }

         }

       }
}


//Stmt924:Leaf
df = df->next;

     }

   }

//Stmt979:Parent
if ((unsigned long )dir->dirstream == (unsigned long )((DIR *)0)) {
//Stmt931:Leaf
return (0);

   }

//Stmt980:Parent
while (1) {
//Stmt946:Leaf
d = readdir(dir->dirstream);

//Stmt947:Parent
if (! ((unsigned long )d != (unsigned long )((struct dirent *)0))) {
//Stmt932:Leaf
break;

     }

//Stmt948:Leaf
newhash = 0U;

//Stmt949:Parent
if (! (d->d_ino != 0UL)) {
//Stmt933:Leaf
continue;

     }

//Stmt950:Leaf
tmp___0 = strlen((char const   *)(d->d_name));

//Stmt951:Leaf
len = (unsigned int )tmp___0;

//Stmt952:Leaf
i = 0U;

//Stmt953:Parent
while (i < len) {
//Stmt934:Leaf
newhash += (unsigned int )d->d_name[i];

//Stmt935:Leaf
newhash = (newhash << 7) + (newhash >> 20);

//Stmt936:Leaf
i ++;

     }

//Stmt954:Leaf
newhash %= 107U;

//Stmt955:Leaf
tmp___1 = xmalloc((unsigned int )sizeof(struct dirfile ));

//Stmt956:Leaf
df = (struct dirfile *)tmp___1;

//Stmt957:Leaf
df->next = *(dir->files + newhash);

//Stmt958:Leaf
*(dir->files + newhash) = df;

//Stmt959:Leaf
df->name = savestring((char const   *)(d->d_name), len);

//Stmt960:Leaf
df->impossible = (char)0;

//Stmt961:Parent
if ((unsigned long )filename != (unsigned long )((char *)0)) {
//Stmt945:Parent
if (newhash == hash) {
//Stmt944:Parent
if ((unsigned long )(d->d_name) == (unsigned long )filename) {
//Stmt942:Leaf
return (1);

         } else
         {
//Stmt943:Parent
if ((int )d->d_name[0] == (int )*filename) {
//Stmt941:Parent
if ((int )d->d_name[0] == 0) {
//Stmt938:Leaf
return (1);

           } else {
//Stmt939:Leaf
tmp___2 = strcmp((char const   *)(d->d_name + 1), (char const   *)(filename + 1));

//Stmt940:Parent
if (! tmp___2) {
//Stmt937:Leaf
return (1);

             }

           }

         }
}


       }

     }

   }

//Stmt981:Parent
if ((unsigned long )d == (unsigned long )((struct dirent *)0)) {
//Stmt962:Leaf
open_directories --;

//Stmt963:Leaf
closedir(dir->dirstream);

//Stmt964:Leaf
dir->dirstream = (DIR *)0;

   }

//Stmt982:Leaf
return (0);

 }
}
 int dir_file_exists_p(char *dirname , char *filename ) 
 { 
//Stmt983:Leaf
struct directory *tmp ;

//Stmt984:Leaf
int tmp___0 ;

 
   {
//Stmt985:Leaf
tmp = find_directory(dirname);

//Stmt986:Leaf
tmp___0 = dir_contents_file_exists_p(tmp->contents, filename);

//Stmt987:Leaf
return (tmp___0);

 }
}
 int file_exists_p(char *name ) 
 { 
//Stmt997:Leaf
char *dirend ;

//Stmt998:Leaf
char *dirname ;

//Stmt999:Leaf
char *slash ;

//Stmt1000:Leaf
time_t tmp ;

//Stmt1001:Leaf
int tmp___0 ;

//Stmt1002:Leaf
int tmp___1 ;

//Stmt1003:Leaf
void *tmp___2 ;

//Stmt1004:Leaf
int tmp___3 ;

 
   {
//Stmt1005:Leaf
tmp___0 = ar_name(name);

//Stmt1006:Parent
if (tmp___0) {
//Stmt988:Leaf
tmp = ar_member_date(name);

//Stmt989:Leaf
return (tmp != -1L);

   }

//Stmt1007:Leaf
dirend = strrchr((char const   *)name, '/');

//Stmt1008:Parent
if ((unsigned long )dirend == (unsigned long )((char *)0)) {
//Stmt990:Leaf
tmp___1 = dir_file_exists_p((char *)".", name);

//Stmt991:Leaf
return (tmp___1);

   }

//Stmt1009:Leaf
slash = dirend;

//Stmt1010:Parent
if ((unsigned long )dirend == (unsigned long )name) {
//Stmt992:Leaf
dirname = (char *)"/";

   } else {
//Stmt993:Leaf
tmp___2 = __builtin_alloca((unsigned long )((dirend - name) + 1L));

//Stmt994:Leaf
dirname = (char *)tmp___2;

//Stmt995:Leaf
memmove((void *)dirname, (void const   *)name, (size_t )(dirend - name));

//Stmt996:Leaf
*(dirname + (dirend - name)) = (char )'\000';

   }

//Stmt1011:Leaf
tmp___3 = dir_file_exists_p(dirname, slash + 1);

//Stmt1012:Leaf
return (tmp___3);

 }
}
 void file_impossible(char *filename ) 
 { 
//Stmt1037:Leaf
char *dirend ;

//Stmt1038:Leaf
register char *p ;

//Stmt1039:Leaf
register unsigned int hash ;

//Stmt1040:Leaf
register struct directory *dir ;

//Stmt1041:Leaf
register struct dirfile *new ;

//Stmt1042:Leaf
char *dirname ;

//Stmt1043:Leaf
char *slash ;

//Stmt1044:Leaf
void *tmp ;

//Stmt1045:Leaf
char *tmp___0 ;

//Stmt1046:Leaf
ino_t tmp___1 ;

//Stmt1047:Leaf
char *tmp___2 ;

//Stmt1048:Leaf
char *tmp___3 ;

 
   {
//Stmt1049:Leaf
p = filename;

//Stmt1050:Leaf
dirend = strrchr((char const   *)p, '/');

//Stmt1051:Parent
if ((unsigned long )dirend == (unsigned long )((char *)0)) {
//Stmt1018:Leaf
dir = find_directory((char *)".");

   } else {
//Stmt1019:Leaf
slash = dirend;

//Stmt1020:Parent
if ((unsigned long )dirend == (unsigned long )p) {
//Stmt1013:Leaf
dirname = (char *)"/";

     } else {
//Stmt1014:Leaf
tmp = __builtin_alloca((unsigned long )((dirend - p) + 1L));

//Stmt1015:Leaf
dirname = (char *)tmp;

//Stmt1016:Leaf
memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));

//Stmt1017:Leaf
*(dirname + (dirend - p)) = (char )'\000';

     }

//Stmt1021:Leaf
dir = find_directory(dirname);

//Stmt1022:Leaf
p = slash + 1;

//Stmt1023:Leaf
filename = p;

   }

//Stmt1052:Leaf
hash = 0U;

//Stmt1053:Parent
while ((int )*p != 0) {
//Stmt1024:Leaf
hash += (unsigned int )*p;

//Stmt1025:Leaf
hash = (hash << 7) + (hash >> 20);

//Stmt1026:Leaf
p ++;

   }

//Stmt1054:Leaf
hash %= 107U;

//Stmt1055:Parent
if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
//Stmt1027:Leaf
tmp___0 = xmalloc((unsigned int )sizeof(struct directory_contents ));

//Stmt1028:Leaf
dir->contents = (struct directory_contents *)tmp___0;

//Stmt1029:Leaf
tmp___1 = (ino_t )0;

//Stmt1030:Leaf
(dir->contents)->ino = tmp___1;

//Stmt1031:Leaf
(dir->contents)->dev = tmp___1;

//Stmt1032:Leaf
(dir->contents)->files = (struct dirfile **)0;

//Stmt1033:Leaf
(dir->contents)->dirstream = (DIR *)0;

   }

//Stmt1056:Parent
if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
//Stmt1034:Leaf
tmp___2 = xmalloc((unsigned int )(sizeof(struct dirfile ) * 107UL));

//Stmt1035:Leaf
(dir->contents)->files = (struct dirfile **)tmp___2;

//Stmt1036:Leaf
memset((void *)((char *)(dir->contents)->files), 0, sizeof(struct dirfile ) * 107UL);

   }

//Stmt1057:Leaf
tmp___3 = xmalloc((unsigned int )sizeof(struct dirfile ));

//Stmt1058:Leaf
new = (struct dirfile *)tmp___3;

//Stmt1059:Leaf
new->next = *((dir->contents)->files + hash);

//Stmt1060:Leaf
*((dir->contents)->files + hash) = new;

//Stmt1061:Leaf
new->name = xstrdup((char const   *)filename);

//Stmt1062:Leaf
new->impossible = (char)1;

//Stmt1063:Leaf
return;

 }
}
 int file_impossible_p(char *filename ) 
 { 
//Stmt1092:Leaf
char *dirend ;

//Stmt1093:Leaf
register char *p ;

//Stmt1094:Leaf
register unsigned int hash ;

//Stmt1095:Leaf
register struct directory_contents *dir ;

//Stmt1096:Leaf
register struct dirfile *next ;

//Stmt1097:Leaf
struct directory *tmp ;

//Stmt1098:Leaf
char *dirname ;

//Stmt1099:Leaf
char *slash ;

//Stmt1100:Leaf
void *tmp___0 ;

//Stmt1101:Leaf
struct directory *tmp___1 ;

//Stmt1102:Leaf
int tmp___2 ;

 
   {
//Stmt1103:Leaf
p = filename;

//Stmt1104:Leaf
dirend = strrchr((char const   *)filename, '/');

//Stmt1105:Parent
if ((unsigned long )dirend == (unsigned long )((char *)0)) {
//Stmt1069:Leaf
tmp = find_directory((char *)".");

//Stmt1070:Leaf
dir = tmp->contents;

   } else {
//Stmt1071:Leaf
slash = dirend;

//Stmt1072:Parent
if ((unsigned long )dirend == (unsigned long )filename) {
//Stmt1064:Leaf
dirname = (char *)"/";

     } else {
//Stmt1065:Leaf
tmp___0 = __builtin_alloca((unsigned long )((dirend - filename) + 1L));

//Stmt1066:Leaf
dirname = (char *)tmp___0;

//Stmt1067:Leaf
memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));

//Stmt1068:Leaf
*(dirname + (dirend - p)) = (char )'\000';

     }

//Stmt1073:Leaf
tmp___1 = find_directory(dirname);

//Stmt1074:Leaf
dir = tmp___1->contents;

//Stmt1075:Leaf
filename = slash + 1;

//Stmt1076:Leaf
p = filename;

   }

//Stmt1106:Parent
if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
//Stmt1078:Leaf
return (0);

   } else
   {
//Stmt1079:Parent
if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
//Stmt1077:Leaf
return (0);

   }
}


//Stmt1107:Leaf
hash = 0U;

//Stmt1108:Parent
while ((int )*p != 0) {
//Stmt1080:Leaf
hash += (unsigned int )*p;

//Stmt1081:Leaf
hash = (hash << 7) + (hash >> 20);

//Stmt1082:Leaf
p ++;

   }

//Stmt1109:Leaf
hash %= 107U;

//Stmt1110:Leaf
next = *(dir->files + hash);

//Stmt1111:Parent
while ((unsigned long )next != (unsigned long )((struct dirfile *)0)) {
//Stmt1090:Parent
if ((unsigned long )filename == (unsigned long )next->name) {
//Stmt1088:Leaf
return ((int )next->impossible);

     } else
     {
//Stmt1089:Parent
if ((int )*filename == (int )*(next->name)) {
//Stmt1087:Parent
if ((int )*filename == 0) {
//Stmt1084:Leaf
return ((int )next->impossible);

       } else {
//Stmt1085:Leaf
tmp___2 = strcmp((char const   *)(filename + 1), (char const   *)(next->name + 1));

//Stmt1086:Parent
if (! tmp___2) {
//Stmt1083:Leaf
return ((int )next->impossible);

         }

       }

     }
}


//Stmt1091:Leaf
next = next->next;

   }

//Stmt1112:Leaf
return (0);

 }
}
 char *dir_name(char *dir ) 
 { 
//Stmt1113:Leaf
struct directory *tmp ;

 
   {
//Stmt1114:Leaf
tmp = find_directory(dir);

//Stmt1115:Leaf
return (tmp->name);

 }
}
 void print_dir_data_base(void) 
 { 
//Stmt1164:Leaf
register unsigned int i ;

//Stmt1165:Leaf
register unsigned int dirs___0 ;

//Stmt1166:Leaf
register unsigned int files___0 ;

//Stmt1167:Leaf
register unsigned int impossible ;

//Stmt1168:Leaf
register struct directory *dir ;

//Stmt1169:Leaf
char *tmp ;

//Stmt1170:Leaf
char *tmp___0 ;

//Stmt1171:Leaf
char *tmp___1 ;

//Stmt1172:Leaf
register unsigned int f ;

//Stmt1173:Leaf
register unsigned int im ;

//Stmt1174:Leaf
register unsigned int j ;

//Stmt1175:Leaf
register struct dirfile *df ;

//Stmt1176:Leaf
char *tmp___2 ;

//Stmt1177:Leaf
char *tmp___3 ;

//Stmt1178:Leaf
char *tmp___4 ;

//Stmt1179:Leaf
char *tmp___5 ;

//Stmt1180:Leaf
char *tmp___6 ;

//Stmt1181:Leaf
char *tmp___7 ;

//Stmt1182:Leaf
char *tmp___8 ;

//Stmt1183:Leaf
char *tmp___9 ;

//Stmt1184:Leaf
char *tmp___10 ;

//Stmt1185:Leaf
char *tmp___11 ;

 
   {
//Stmt1186:Leaf
tmp = dcgettext((char const   *)((void *)0), "\n# Directories\n", 5);

//Stmt1187:Leaf
puts((char const   *)tmp);

//Stmt1188:Leaf
impossible = 0U;

//Stmt1189:Leaf
files___0 = impossible;

//Stmt1190:Leaf
dirs___0 = files___0;

//Stmt1191:Leaf
i = 0U;

//Stmt1192:Parent
while (i < 199U) {
//Stmt1155:Leaf
dir = directories[i];

//Stmt1156:Parent
while ((unsigned long )dir != (unsigned long )((struct directory *)0)) {
//Stmt1152:Leaf
dirs___0 ++;

//Stmt1153:Parent
if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
//Stmt1149:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "# %s: could not be stat\'d.\n",
                             5);

//Stmt1150:Leaf
printf((char const   * __restrict  )tmp___0, dir->name);

       } else
       {
//Stmt1151:Parent
if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
//Stmt1132:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "# %s (device %ld, inode %ld): could not be opened.\n",
                             5);

//Stmt1133:Leaf
printf((char const   * __restrict  )tmp___1, dir->name, (long )(dir->contents)->dev,
                (long )(dir->contents)->ino);

       } else {
//Stmt1134:Leaf
f = 0U;

//Stmt1135:Leaf
im = 0U;

//Stmt1136:Leaf
j = 0U;

//Stmt1137:Parent
while (j < 107U) {
//Stmt1120:Leaf
df = *((dir->contents)->files + j);

//Stmt1121:Parent
while ((unsigned long )df != (unsigned long )((struct dirfile *)0)) {
//Stmt1118:Parent
if (df->impossible) {
//Stmt1116:Leaf
im ++;

             } else {
//Stmt1117:Leaf
f ++;

             }

//Stmt1119:Leaf
df = df->next;

           }

//Stmt1122:Leaf
j ++;

         }

//Stmt1138:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "# %s (device %ld, inode %ld): ",
                             5);

//Stmt1139:Leaf
printf((char const   * __restrict  )tmp___2, dir->name, (long )(dir->contents)->dev,
                (long )(dir->contents)->ino);

//Stmt1140:Parent
if (f == 0U) {
//Stmt1123:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "No", 5);

//Stmt1124:Leaf
fputs((char const   * __restrict  )tmp___3, (FILE * __restrict  )stdout);

         } else {
//Stmt1125:Leaf
printf((char const   * __restrict  )"%u", f);

         }

//Stmt1141:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), " files, ", 5);

//Stmt1142:Leaf
fputs((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);

//Stmt1143:Parent
if (im == 0U) {
//Stmt1126:Leaf
tmp___5 = dcgettext((char const   *)((void *)0), "no", 5);

//Stmt1127:Leaf
fputs((char const   * __restrict  )tmp___5, (FILE * __restrict  )stdout);

         } else {
//Stmt1128:Leaf
printf((char const   * __restrict  )"%u", im);

         }

//Stmt1144:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), " impossibilities", 5);

//Stmt1145:Leaf
fputs((char const   * __restrict  )tmp___6, (FILE * __restrict  )stdout);

//Stmt1146:Parent
if ((unsigned long )(dir->contents)->dirstream == (unsigned long )((DIR *)0)) {
//Stmt1129:Leaf
puts(".");

         } else {
//Stmt1130:Leaf
tmp___7 = dcgettext((char const   *)((void *)0), " so far.", 5);

//Stmt1131:Leaf
puts((char const   *)tmp___7);

         }

//Stmt1147:Leaf
files___0 += f;

//Stmt1148:Leaf
impossible += im;

       }
}


//Stmt1154:Leaf
dir = dir->next;

     }

//Stmt1157:Leaf
i ++;

   }

//Stmt1193:Leaf
fputs((char const   * __restrict  )"\n# ", (FILE * __restrict  )stdout);

//Stmt1194:Parent
if (files___0 == 0U) {
//Stmt1158:Leaf
tmp___8 = dcgettext((char const   *)((void *)0), "No", 5);

//Stmt1159:Leaf
fputs((char const   * __restrict  )tmp___8, (FILE * __restrict  )stdout);

   } else {
//Stmt1160:Leaf
printf((char const   * __restrict  )"%u", files___0);

   }

//Stmt1195:Leaf
tmp___9 = dcgettext((char const   *)((void *)0), " files, ", 5);

//Stmt1196:Leaf
fputs((char const   * __restrict  )tmp___9, (FILE * __restrict  )stdout);

//Stmt1197:Parent
if (impossible == 0U) {
//Stmt1161:Leaf
tmp___10 = dcgettext((char const   *)((void *)0), "no", 5);

//Stmt1162:Leaf
fputs((char const   * __restrict  )tmp___10, (FILE * __restrict  )stdout);

   } else {
//Stmt1163:Leaf
printf((char const   * __restrict  )"%u", impossible);

   }

//Stmt1198:Leaf
tmp___11 = dcgettext((char const   *)((void *)0), " impossibilities in %u directories.\n",
                        5);

//Stmt1199:Leaf
printf((char const   * __restrict  )tmp___11, dirs___0);

//Stmt1200:Leaf
return;

 }
}
 static void *open_dirstream(char const   *directory ) ;
 static struct dirent *read_dirstream(void *stream ) ;
 static void *open_dirstream(char const   *directory ) 
 { 
//Stmt1204:Leaf
struct dirstream *new ;

//Stmt1205:Leaf
struct directory *dir ;

//Stmt1206:Leaf
struct directory *tmp ;

//Stmt1207:Leaf
char *tmp___0 ;

 
   {
//Stmt1208:Leaf
tmp = find_directory((char *)directory);

//Stmt1209:Leaf
dir = tmp;

//Stmt1210:Parent
if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
//Stmt1202:Leaf
return ((void *)0);

   } else
   {
//Stmt1203:Parent
if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
//Stmt1201:Leaf
return ((void *)0);

   }
}


//Stmt1211:Leaf
dir_contents_file_exists_p(dir->contents, (char *)0);

//Stmt1212:Leaf
tmp___0 = xmalloc((unsigned int )sizeof(struct dirstream ));

//Stmt1213:Leaf
new = (struct dirstream *)tmp___0;

//Stmt1214:Leaf
new->contents = dir->contents;

//Stmt1215:Leaf
new->bucket = 0U;

//Stmt1216:Leaf
new->elt = *((new->contents)->files + 0);

//Stmt1217:Leaf
return ((void *)new);

 }
}
 static char *buf  ;
 static unsigned int bufsz  ;
 static struct dirent *read_dirstream(void *stream ) 
 { 
//Stmt1242:Leaf
struct dirstream *ds ;

//Stmt1243:Leaf
register struct dirfile *df ;

//Stmt1244:Leaf
struct dirent *d ;

//Stmt1245:Leaf
unsigned int len ;

//Stmt1246:Leaf
size_t tmp ;

 
   {
//Stmt1247:Leaf
ds = (struct dirstream *)stream;

//Stmt1248:Parent
while (ds->bucket < 107U) {
//Stmt1238:Parent
while (1) {
//Stmt1233:Leaf
df = ds->elt;

//Stmt1234:Parent
if (! ((unsigned long )df != (unsigned long )((struct dirfile *)0))) {
//Stmt1218:Leaf
break;

       }

//Stmt1235:Leaf
ds->elt = df->next;

//Stmt1236:Parent
if (! df->impossible) {
//Stmt1225:Leaf
tmp = strlen((char const   *)df->name);

//Stmt1226:Leaf
len = (unsigned int )(tmp + 1UL);

//Stmt1227:Parent
if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
//Stmt1221:Parent
if ((unsigned long )buf != (unsigned long )((char *)0)) {
//Stmt1219:Leaf
free((void *)buf);

           }

//Stmt1222:Leaf
bufsz *= 2U;

//Stmt1223:Parent
if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
//Stmt1220:Leaf
bufsz = (unsigned int )((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len);

           }

//Stmt1224:Leaf
buf = xmalloc(bufsz);

         }

//Stmt1228:Leaf
d = (struct dirent *)buf;

//Stmt1229:Leaf
d->d_ino = (__ino_t )1;

//Stmt1230:Leaf
d->d_type = (unsigned char)0;

//Stmt1231:Leaf
memcpy((void * __restrict  )(d->d_name), (void const   * __restrict  )df->name,
                (size_t )len);

//Stmt1232:Leaf
return (d);

       }

     }

//Stmt1239:Leaf
(ds->bucket) ++;

//Stmt1240:Parent
if (ds->bucket == 107U) {
//Stmt1237:Leaf
break;

     }

//Stmt1241:Leaf
ds->elt = *((ds->contents)->files + ds->bucket);

   }

//Stmt1249:Leaf
return ((struct dirent *)0);

 }
}
 static void ansi_free(void *p ) 
 { 
 
 
{
//Stmt1251:Parent
if (p) {
//Stmt1250:Leaf
free(p);

   }

//Stmt1252:Leaf
return;

 }
}
 void dir_setup_glob(glob_t *gl ) 
 { 
 
 
{
//Stmt1253:Leaf
gl->gl_opendir = & open_dirstream;

//Stmt1254:Leaf
gl->gl_readdir = & read_dirstream;

//Stmt1255:Leaf
gl->gl_closedir = & ansi_free;

//Stmt1256:Leaf
gl->gl_stat = (int (*)(char const   * , struct stat * ))(& stat);

//Stmt1257:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-3QgulJGN.i","-g,-O0")
 extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                    char const   *__file ,
                                                                                                    unsigned int __line ,
                                                                                                    char const   *__function ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ) ;
 char *lindex(char const   *s , char const   *limit , int c ) ;
 char *find_percent(char *pattern ) ;
 struct floc  const  *reading_file ;
 int warn_undefined_variables_flag ;
 char *variable_buffer  ;
 struct variable_set_list *current_variable_set_list ;
 char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) ;
 char *variable_expand(char *line ) ;
 char *allocated_variable_expand_for_file(char *line , struct file *file ) ;
 char *expand_argument(char *str , char *end ) ;
 char *variable_expand_string(char *line , char *string , long length___0 ) ;
 int handle_function(char **op , char **stringp ) ;
 char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                    unsigned int rlen , int by_word , int suffix_only ) ;
 char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                       char *replace_percent ) ;
 char *recursively_expand(struct variable *v ) ;
 struct variable *lookup_variable(char *name , unsigned int length___0 ) ;
 static unsigned int variable_buffer_length  ;
 char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) 
 { 
//Stmt1265:Leaf
register unsigned int newlen ;

//Stmt1266:Leaf
unsigned int offset ;

//Stmt1267:Leaf
char *tmp ;

 
   {
//Stmt1268:Leaf
newlen = (unsigned int )((long )length___0 + (ptr - variable_buffer));

//Stmt1269:Parent
if (newlen + 5U > variable_buffer_length) {
//Stmt1260:Leaf
offset = (unsigned int )(ptr - variable_buffer);

//Stmt1261:Parent
if (newlen + 100U > 2U * variable_buffer_length) {
//Stmt1258:Leaf
variable_buffer_length = newlen + 100U;

     } else {
//Stmt1259:Leaf
variable_buffer_length = 2U * variable_buffer_length;

     }

//Stmt1262:Leaf
tmp = xrealloc(variable_buffer, variable_buffer_length);

//Stmt1263:Leaf
variable_buffer = tmp;

//Stmt1264:Leaf
ptr = variable_buffer + offset;

   }

//Stmt1270:Leaf
memmove((void *)ptr, (void const   *)string, (size_t )length___0);

//Stmt1271:Leaf
return (ptr + length___0);

 }
}
 static char *initialize_variable_output(void) 
 { 
//Stmt1276:Leaf
char *tmp ;

 
   {
//Stmt1277:Parent
if ((unsigned long )variable_buffer == (unsigned long )((char *)0)) {
//Stmt1272:Leaf
variable_buffer_length = 200U;

//Stmt1273:Leaf
tmp = xmalloc(variable_buffer_length);

//Stmt1274:Leaf
variable_buffer = tmp;

//Stmt1275:Leaf
*(variable_buffer + 0) = (char )'\000';

   }

//Stmt1278:Leaf
return (variable_buffer);

 }
}
 static char *allocated_variable_append(struct variable *v ) ;
 char *recursively_expand(struct variable *v ) 
 { 
//Stmt1283:Leaf
char *value ;

//Stmt1284:Leaf
char *tmp ;

 
   {
//Stmt1285:Parent
if (v->expanding) {
//Stmt1279:Leaf
tmp = dcgettext((char const   *)((void *)0), "Recursive variable `%s\' references itself (eventually)",
                     5);

//Stmt1280:Leaf
fatal(reading_file, (char const   *)tmp, v->name);

   }

//Stmt1286:Leaf
v->expanding = 1U;

//Stmt1287:Parent
if (v->append) {
//Stmt1281:Leaf
value = allocated_variable_append(v);

   } else {
//Stmt1282:Leaf
value = allocated_variable_expand_for_file(v->value, (struct file *)0);

   }

//Stmt1288:Leaf
v->expanding = 0U;

//Stmt1289:Leaf
return (value);

 }
}
 __inline static void warn_undefined(char *name , unsigned int length___0 ) 
 { 
//Stmt1292:Leaf
char *tmp ;

 
   {
//Stmt1293:Parent
if (warn_undefined_variables_flag) {
//Stmt1290:Leaf
tmp = dcgettext((char const   *)((void *)0), "warning: undefined variable `%.*s\'",
                     5);

//Stmt1291:Leaf
error(reading_file, (char const   *)tmp, (int )length___0, name);

   }

//Stmt1294:Leaf
return;

 }
}
 __inline static char *reference_variable(char *o , char *name , unsigned int length___0 ) 
 { 
//Stmt1303:Leaf
register struct variable *v ;

//Stmt1304:Leaf
char *value ;

//Stmt1305:Leaf
char *tmp ;

//Stmt1306:Leaf
size_t tmp___0 ;

 
   {
//Stmt1307:Leaf
v = lookup_variable(name, length___0);

//Stmt1308:Parent
if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
//Stmt1295:Leaf
warn_undefined(name, length___0);

   }

//Stmt1309:Parent
if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
//Stmt1297:Leaf
return (o);

   } else
   {
//Stmt1298:Parent
if ((int )*(v->value) == 0) {
//Stmt1296:Leaf
return (o);

   }
}


//Stmt1310:Parent
if (v->recursive) {
//Stmt1299:Leaf
tmp = recursively_expand(v);

//Stmt1300:Leaf
value = tmp;

   } else {
//Stmt1301:Leaf
value = v->value;

   }

//Stmt1311:Leaf
tmp___0 = strlen((char const   *)value);

//Stmt1312:Leaf
o = variable_buffer_output(o, value, (unsigned int )tmp___0);

//Stmt1313:Parent
if (v->recursive) {
//Stmt1302:Leaf
free((void *)value);

   }

//Stmt1314:Leaf
return (o);

 }
}
 char *variable_expand_string(char *line , char *string , long length___0 ) 
 { 
//Stmt1423:Leaf
register struct variable *v ;

//Stmt1424:Leaf
register char *p ;

//Stmt1425:Leaf
register char *o ;

//Stmt1426:Leaf
register char *p1 ;

//Stmt1427:Leaf
char save_char ;

//Stmt1428:Leaf
unsigned int line_offset ;

//Stmt1429:Leaf
size_t tmp ;

//Stmt1430:Leaf
size_t tmp___0 ;

//Stmt1431:Leaf
char openparen ;

//Stmt1432:Leaf
char closeparen ;

//Stmt1433:Leaf
int tmp___1 ;

//Stmt1434:Leaf
register char *beg ;

//Stmt1435:Leaf
int free_beg ;

//Stmt1436:Leaf
char *op ;

//Stmt1437:Leaf
char *begp ;

//Stmt1438:Leaf
char *end ;

//Stmt1439:Leaf
char *colon ;

//Stmt1440:Leaf
int tmp___2 ;

//Stmt1441:Leaf
char *tmp___3 ;

//Stmt1442:Leaf
int count ;

//Stmt1443:Leaf
char *subst_beg ;

//Stmt1444:Leaf
char *subst_end ;

//Stmt1445:Leaf
char *replace_beg ;

//Stmt1446:Leaf
char *replace_end ;

//Stmt1447:Leaf
char *value ;

//Stmt1448:Leaf
char *tmp___4 ;

//Stmt1449:Leaf
char *tmp___5 ;

//Stmt1450:Leaf
char *pattern ;

//Stmt1451:Leaf
char *percent ;

//Stmt1452:Leaf
void *tmp___6 ;

//Stmt1453:Leaf
char *replace ;

//Stmt1454:Leaf
void *tmp___7 ;

//Stmt1455:Leaf
size_t tmp___8 ;

//Stmt1456:Leaf
unsigned short const   **tmp___9 ;

//Stmt1457:Leaf
char name[5] ;

//Stmt1458:Leaf
size_t tmp___10 ;

 
   {
//Stmt1459:Leaf
save_char = (char )'\000';

//Stmt1460:Parent
if (! line) {
//Stmt1315:Leaf
line = initialize_variable_output();

   }

//Stmt1461:Leaf
p = string;

//Stmt1462:Leaf
o = line;

//Stmt1463:Leaf
line_offset = (unsigned int )(line - variable_buffer);

//Stmt1464:Parent
if (length___0 >= 0L) {
//Stmt1316:Leaf
save_char = *(string + length___0);

//Stmt1317:Leaf
*(string + length___0) = (char )'\000';

   }

//Stmt1465:Parent
while (1) {
//Stmt1415:Leaf
p1 = strchr((char const   *)p, '$');

//Stmt1416:Parent
if ((unsigned long )p1 != (unsigned long )((char *)0)) {
//Stmt1318:Leaf
tmp___0 = (size_t )(p1 - p);

     } else {
//Stmt1319:Leaf
tmp = strlen((char const   *)p);

//Stmt1320:Leaf
tmp___0 = tmp + 1UL;

     }

//Stmt1417:Leaf
o = variable_buffer_output(o, p, (unsigned int )tmp___0);

//Stmt1418:Parent
if ((unsigned long )p1 == (unsigned long )((char *)0)) {
//Stmt1321:Leaf
break;

     }

//Stmt1419:Leaf
p = p1 + 1;

//Stmt1420:Parent
switch ((int )*p) {
     case 36:; 
//Stmt1322:Leaf
o = variable_buffer_output(o, p, 1U);

     break;
     case 123:; 
     case 40:; 
//Stmt1323:Leaf
openparen = *p;

//Stmt1387:Parent
if ((int )openparen == 40) {
//Stmt1324:Leaf
tmp___1 = ')';

     } else {
//Stmt1325:Leaf
tmp___1 = '}';

     }

//Stmt1388:Leaf
closeparen = (char )tmp___1;

//Stmt1389:Leaf
beg = p + 1;

//Stmt1390:Leaf
free_beg = 0;

//Stmt1391:Leaf
op = o;

//Stmt1392:Leaf
begp = p;

//Stmt1393:Leaf
tmp___2 = handle_function(& op, & begp);

//Stmt1394:Parent
if (tmp___2) {
//Stmt1326:Leaf
o = op;

//Stmt1327:Leaf
p = begp;

//Stmt1328:Leaf
break;

     }

//Stmt1395:Leaf
end = strchr((char const   *)beg, (int )closeparen);

//Stmt1396:Parent
if ((unsigned long )end == (unsigned long )((char *)0)) {
//Stmt1329:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "unterminated variable reference",
                           5);

//Stmt1330:Leaf
fatal(reading_file, (char const   *)tmp___3);

     }

//Stmt1397:Leaf
p1 = lindex((char const   *)beg, (char const   *)end, '$');

//Stmt1398:Parent
if ((unsigned long )p1 != (unsigned long )((char *)0)) {
//Stmt1341:Leaf
count = 0;

//Stmt1342:Leaf
p = beg;

//Stmt1343:Parent
while ((int )*p != 0) {
//Stmt1336:Parent
if ((int )*p == (int )openparen) {
//Stmt1334:Leaf
count ++;

         } else
         {
//Stmt1335:Parent
if ((int )*p == (int )closeparen) {
//Stmt1332:Leaf
count --;

//Stmt1333:Parent
if (count < 0) {
//Stmt1331:Leaf
break;

           }

         }
}


//Stmt1337:Leaf
p ++;

       }

//Stmt1344:Parent
if (count < 0) {
//Stmt1338:Leaf
beg = expand_argument(beg, p);

//Stmt1339:Leaf
free_beg = 1;

//Stmt1340:Leaf
end = strchr((char const   *)beg, '\000');

       }

     } else {
//Stmt1345:Leaf
p = end;

     }

//Stmt1399:Leaf
colon = lindex((char const   *)beg, (char const   *)end, ':');

//Stmt1400:Parent
if ((unsigned long )colon != (unsigned long )((char *)0)) {
//Stmt1380:Leaf
subst_beg = colon + 1;

//Stmt1381:Leaf
subst_end = strchr((char const   *)subst_beg, '=');

//Stmt1382:Parent
if ((unsigned long )subst_end == (unsigned long )((char *)0)) {
//Stmt1374:Leaf
colon = (char *)0;

       } else {
//Stmt1375:Leaf
replace_beg = subst_end + 1;

//Stmt1376:Leaf
replace_end = end;

//Stmt1377:Leaf
v = lookup_variable(beg, (unsigned int )(colon - beg));

//Stmt1378:Parent
if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
//Stmt1346:Leaf
warn_undefined(beg, (unsigned int )(colon - beg));

         }

//Stmt1379:Parent
if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt1373:Parent
if ((int )*(v->value) != 0) {
//Stmt1367:Parent
if (v->recursive) {
//Stmt1347:Leaf
tmp___4 = recursively_expand(v);

//Stmt1348:Leaf
tmp___5 = tmp___4;

             } else {
//Stmt1349:Leaf
tmp___5 = v->value;

             }

//Stmt1368:Leaf
value = tmp___5;

//Stmt1369:Parent
if (free_beg) {
//Stmt1350:Leaf
*subst_end = (char )'\000';

//Stmt1351:Leaf
pattern = subst_beg;

             } else {
//Stmt1352:Leaf
tmp___6 = __builtin_alloca((unsigned long )((subst_end - subst_beg) + 1L));

//Stmt1353:Leaf
pattern = (char *)tmp___6;

//Stmt1354:Leaf
memmove((void *)pattern, (void const   *)subst_beg, (size_t )(subst_end - subst_beg));

//Stmt1355:Leaf
*(pattern + (subst_end - subst_beg)) = (char )'\000';

             }

//Stmt1370:Leaf
percent = find_percent(pattern);

//Stmt1371:Parent
if ((unsigned long )percent != (unsigned long )((char *)0)) {
//Stmt1362:Parent
if (free_beg) {
//Stmt1356:Leaf
*replace_end = (char )'\000';

//Stmt1357:Leaf
replace = replace_beg;

               } else {
//Stmt1358:Leaf
tmp___7 = __builtin_alloca((unsigned long )((replace_end - replace_beg) + 1L));

//Stmt1359:Leaf
replace = (char *)tmp___7;

//Stmt1360:Leaf
memmove((void *)replace, (void const   *)replace_beg, (size_t )(replace_end - replace_beg));

//Stmt1361:Leaf
*(replace + (replace_end - replace_beg)) = (char )'\000';

               }

//Stmt1363:Leaf
o = patsubst_expand(o, value, pattern, replace, percent, (char *)0);

             } else {
//Stmt1364:Leaf
tmp___8 = strlen((char const   *)pattern);

//Stmt1365:Leaf
o = subst_expand(o, value, pattern, replace_beg, (unsigned int )tmp___8,
                                (unsigned int )(end - replace_beg), 0, 1);

             }

//Stmt1372:Parent
if (v->recursive) {
//Stmt1366:Leaf
free((void *)value);

             }

           }

         }

       }

     }

//Stmt1401:Parent
if ((unsigned long )colon == (unsigned long )((char *)0)) {
//Stmt1383:Leaf
o = reference_variable(o, beg, (unsigned int )(end - beg));

     }

//Stmt1402:Parent
if (free_beg) {
//Stmt1384:Leaf
free((void *)beg);

     }

     break;
     case 0:; 
     break;
     default:; 
//Stmt1385:Leaf
tmp___9 = __ctype_b_loc();

//Stmt1403:Parent
if ((int const   )*(*tmp___9 + (int )*(p + -1)) & 1) {
//Stmt1386:Leaf
break;

     }

//Stmt1404:Leaf
name[0] = (char )'$';

//Stmt1405:Leaf
name[1] = (char )'(';

//Stmt1406:Leaf
name[2] = *p;

//Stmt1407:Leaf
name[3] = (char )')';

//Stmt1408:Leaf
name[4] = (char )'\000';

//Stmt1409:Leaf
p1 = allocated_variable_expand_for_file(name, (struct file *)0);

//Stmt1410:Leaf
tmp___10 = strlen((char const   *)p1);

//Stmt1411:Leaf
o = variable_buffer_output(o, p1, (unsigned int )tmp___10);

//Stmt1412:Leaf
free((void *)p1);

     break;
     }

//Stmt1421:Parent
if ((int )*p == 0) {
//Stmt1413:Leaf
break;

     } else {
//Stmt1414:Leaf
p ++;

     }

   }

//Stmt1466:Parent
if (save_char) {
//Stmt1422:Leaf
*(string + length___0) = save_char;

   }

//Stmt1467:Leaf
variable_buffer_output(o, (char *)"", 1U);

//Stmt1468:Leaf
return (variable_buffer + line_offset);

 }
}
 char *variable_expand(char *line ) 
 { 
//Stmt1469:Leaf
char *tmp ;

 
   {
//Stmt1470:Leaf
tmp = variable_expand_string((char *)((void *)0), line, -1L);

//Stmt1471:Leaf
return (tmp);

 }
}
 char *expand_argument(char *str , char *end ) 
 { 
//Stmt1479:Leaf
char *tmp ;

//Stmt1480:Leaf
void *tmp___0 ;

//Stmt1481:Leaf
char *tmp___1 ;

 
   {
//Stmt1482:Parent
if (! end) {
//Stmt1477:Leaf
tmp = str;

   } else
   {
//Stmt1478:Parent
if ((int )*end == 0) {
//Stmt1472:Leaf
tmp = str;

   } else {
//Stmt1473:Leaf
tmp___0 = __builtin_alloca((unsigned long )((end - str) + 1L));

//Stmt1474:Leaf
tmp = (char *)tmp___0;

//Stmt1475:Leaf
memmove((void *)tmp, (void const   *)str, (size_t )(end - str));

//Stmt1476:Leaf
*(tmp + (end - str)) = (char )'\000';

   }
}


//Stmt1483:Leaf
tmp___1 = allocated_variable_expand_for_file(tmp, (struct file *)0);

//Stmt1484:Leaf
return (tmp___1);

 }
}
 static char *variable_expand_for_file(char *line , struct file *file ) 
 { 
//Stmt1491:Leaf
char *result___0 ;

//Stmt1492:Leaf
struct variable_set_list *save ;

//Stmt1493:Leaf
char *tmp ;

 
   {
//Stmt1494:Parent
if ((unsigned long )file == (unsigned long )((struct file *)0)) {
//Stmt1485:Leaf
tmp = variable_expand(line);

//Stmt1486:Leaf
return (tmp);

   }

//Stmt1495:Leaf
save = current_variable_set_list;

//Stmt1496:Leaf
current_variable_set_list = file->variables;

//Stmt1497:Parent
if (file->cmds) {
//Stmt1489:Parent
if ((file->cmds)->fileinfo.filenm) {
//Stmt1487:Leaf
reading_file = (struct floc  const  *)(& (file->cmds)->fileinfo);

     } else {
//Stmt1488:Leaf
reading_file = (struct floc  const  *)0;

     }

   } else {
//Stmt1490:Leaf
reading_file = (struct floc  const  *)0;

   }

//Stmt1498:Leaf
result___0 = variable_expand(line);

//Stmt1499:Leaf
current_variable_set_list = save;

//Stmt1500:Leaf
reading_file = (struct floc  const  *)0;

//Stmt1501:Leaf
return (result___0);

 }
}
 static char *allocated_variable_append(struct variable *v ) 
 { 
//Stmt1503:Leaf
struct variable_set_list *save ;

//Stmt1504:Leaf
int len ;

//Stmt1505:Leaf
size_t tmp ;

//Stmt1506:Leaf
char *var ;

//Stmt1507:Leaf
void *tmp___0 ;

//Stmt1508:Leaf
char *value ;

//Stmt1509:Leaf
char *obuf ;

//Stmt1510:Leaf
unsigned int olen ;

//Stmt1511:Leaf
size_t tmp___2 ;

 
   {
//Stmt1512:Leaf
tmp = strlen((char const   *)v->name);

//Stmt1513:Leaf
len = (int )tmp;

//Stmt1514:Leaf
tmp___0 = __builtin_alloca((unsigned long )(len + 4));

//Stmt1515:Leaf
var = (char *)tmp___0;

//Stmt1516:Leaf
obuf = variable_buffer;

//Stmt1517:Leaf
olen = variable_buffer_length;

//Stmt1518:Leaf
variable_buffer = (char *)0;

//Stmt1519:Parent
if (! ((unsigned long )current_variable_set_list->next != (unsigned long )((struct variable_set_list *)0))) {
//Stmt1502:Leaf
__assert_fail("current_variable_set_list->next != 0", "expand.c", 485U, "allocated_variable_append");

   }

//Stmt1520:Leaf
save = current_variable_set_list;

//Stmt1521:Leaf
current_variable_set_list = current_variable_set_list->next;

//Stmt1522:Leaf
*(var + 0) = (char )'$';

//Stmt1523:Leaf
*(var + 1) = (char )'(';

//Stmt1524:Leaf
strcpy((char * __restrict  )(var + 2), (char const   * __restrict  )v->name);

//Stmt1525:Leaf
*(var + (len + 2)) = (char )')';

//Stmt1526:Leaf
*(var + (len + 3)) = (char )'\000';

//Stmt1527:Leaf
value = variable_expand_for_file(var, (struct file *)0);

//Stmt1528:Leaf
current_variable_set_list = save;

//Stmt1529:Leaf
tmp___2 = strlen((char const   *)value);

//Stmt1530:Leaf
value += tmp___2;

//Stmt1531:Leaf
value = variable_buffer_output(value, (char *)" ", 1U);

//Stmt1532:Leaf
value = variable_expand_string(value, v->value, -1L);

//Stmt1533:Leaf
value = variable_buffer;

//Stmt1534:Leaf
variable_buffer = obuf;

//Stmt1535:Leaf
variable_buffer_length = olen;

//Stmt1536:Leaf
return (value);

 }
}
 char *allocated_variable_expand_for_file(char *line , struct file *file ) 
 { 
//Stmt1537:Leaf
char *value ;

//Stmt1538:Leaf
char *obuf ;

//Stmt1539:Leaf
unsigned int olen ;

 
   {
//Stmt1540:Leaf
obuf = variable_buffer;

//Stmt1541:Leaf
olen = variable_buffer_length;

//Stmt1542:Leaf
variable_buffer = (char *)0;

//Stmt1543:Leaf
value = variable_expand_for_file(line, file);

//Stmt1544:Leaf
variable_buffer = obuf;

//Stmt1545:Leaf
variable_buffer_length = olen;

//Stmt1546:Leaf
return (value);

 }
}
 #pragma merger("0","/tmp/cil-lFW07Sp1.i","-g,-O0")
 extern struct _IO_FILE *stderr ;
 extern int fflush(FILE *__stream ) ;
 extern int putchar(int __c ) ;
 extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
 extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                     struct timespec *__tp ) ;
 extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
 int just_print_flag ;
 int silent_flag ;
 int ignore_errors_flag ;
 int question_flag ;
 int touch_flag ;
 int posix_pedantic ;
 int not_parallel ;
 unsigned int num_intermediates ;
 unsigned int considered ;
 void snap_deps(void) ;
 void rename_file(struct file *file , char *name ) ;
 void rehash_file(struct file *file , char *name ) ;
 void file_hash_enter(struct file *file , char *name , unsigned int oldhash , char *oldname ) ;
 uintmax_t file_timestamp_now(void) ;
 void file_timestamp_sprintf(char *p , uintmax_t ts ) ;
 void print_file_variables(struct file *file ) ;
 void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) ;
 int export_all_variables ;
 static struct file *files[1007]  ;
 unsigned int num_intermediates  =    0U;
 unsigned int considered  =    0U;
 struct file *lookup_file(char *name ) 
 { 
//Stmt1570:Leaf
register struct file *f ;

//Stmt1571:Leaf
register char *n ;

//Stmt1572:Leaf
register unsigned int hashval ;

//Stmt1573:Leaf
int tmp___0 ;

 
   {
//Stmt1574:Parent
if (! ((int )*name != 0)) {
//Stmt1547:Leaf
__assert_fail("*name != \'\\0\'", "file.c", 61U, "lookup_file");

   }

//Stmt1575:Parent
while (1) {
//Stmt1554:Parent
if ((int )*(name + 0) == 46) {
//Stmt1551:Parent
if ((int )*(name + 1) == 47) {
//Stmt1549:Parent
if (! ((int )*(name + 2) != 0)) {
//Stmt1548:Leaf
break;

         }

       } else {
//Stmt1550:Leaf
break;

       }

     } else {
//Stmt1552:Leaf
break;

     }

//Stmt1555:Leaf
name += 2;

//Stmt1556:Parent
while ((int )*name == 47) {
//Stmt1553:Leaf
name ++;

     }

   }

//Stmt1576:Parent
if ((int )*name == 0) {
//Stmt1557:Leaf
name = (char *)"./";

   }

//Stmt1577:Leaf
hashval = 0U;

//Stmt1578:Leaf
n = name;

//Stmt1579:Parent
while ((int )*n != 0) {
//Stmt1558:Leaf
hashval += (unsigned int )*n;

//Stmt1559:Leaf
hashval = (hashval << 7) + (hashval >> 20);

//Stmt1560:Leaf
n ++;

   }

//Stmt1580:Leaf
hashval %= 1007U;

//Stmt1581:Leaf
f = files[hashval];

//Stmt1582:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1568:Parent
if ((unsigned long )f->hname == (unsigned long )name) {
//Stmt1566:Leaf
return (f);

     } else
     {
//Stmt1567:Parent
if ((int )*(f->hname) == (int )*name) {
//Stmt1565:Parent
if ((int )*(f->hname) == 0) {
//Stmt1562:Leaf
return (f);

       } else {
//Stmt1563:Leaf
tmp___0 = strcmp((char const   *)(f->hname + 1), (char const   *)(name + 1));

//Stmt1564:Parent
if (! tmp___0) {
//Stmt1561:Leaf
return (f);

         }

       }

     }
}


//Stmt1569:Leaf
f = f->next;

   }

//Stmt1583:Leaf
return ((struct file *)0);

 }
}
 struct file *enter_file(char *name ) 
 { 
//Stmt1605:Leaf
register struct file *f ;

//Stmt1606:Leaf
register struct file *new ;

//Stmt1607:Leaf
register char *n ;

//Stmt1608:Leaf
register unsigned int hashval ;

//Stmt1609:Leaf
int tmp___0 ;

//Stmt1610:Leaf
char *tmp___1 ;

//Stmt1611:Leaf
char *tmp___2 ;

 
   {
//Stmt1612:Parent
if (! ((int )*name != 0)) {
//Stmt1584:Leaf
__assert_fail("*name != \'\\0\'", "file.c", 130U, "enter_file");

   }

//Stmt1613:Leaf
hashval = 0U;

//Stmt1614:Leaf
n = name;

//Stmt1615:Parent
while ((int )*n != 0) {
//Stmt1585:Leaf
hashval += (unsigned int )*n;

//Stmt1586:Leaf
hashval = (hashval << 7) + (hashval >> 20);

//Stmt1587:Leaf
n ++;

   }

//Stmt1616:Leaf
hashval %= 1007U;

//Stmt1617:Leaf
f = files[hashval];

//Stmt1618:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1595:Parent
if ((unsigned long )f->hname == (unsigned long )name) {
//Stmt1593:Leaf
break;

     } else
     {
//Stmt1594:Parent
if ((int )*(f->hname) == (int )*name) {
//Stmt1592:Parent
if ((int )*(f->hname) == 0) {
//Stmt1589:Leaf
break;

       } else {
//Stmt1590:Leaf
tmp___0 = strcmp((char const   *)(f->hname + 1), (char const   *)(name + 1));

//Stmt1591:Parent
if (! tmp___0) {
//Stmt1588:Leaf
break;

         }

       }

     }
}


//Stmt1596:Leaf
f = f->next;

   }

//Stmt1619:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1598:Parent
if (! f->double_colon) {
//Stmt1597:Leaf
return (f);

     }

   }

//Stmt1620:Leaf
tmp___1 = xmalloc((unsigned int )sizeof(struct file ));

//Stmt1621:Leaf
new = (struct file *)tmp___1;

//Stmt1622:Leaf
memset((void *)((char *)new), 0, sizeof(struct file ));

//Stmt1623:Leaf
tmp___2 = name;

//Stmt1624:Leaf
new->hname = tmp___2;

//Stmt1625:Leaf
new->name = tmp___2;

//Stmt1626:Leaf
new->update_status = (short)-1;

//Stmt1627:Parent
if ((unsigned long )f == (unsigned long )((struct file *)0)) {
//Stmt1600:Leaf
new->next = files[hashval];

//Stmt1601:Leaf
files[hashval] = new;

   } else {
//Stmt1602:Leaf
new->double_colon = f;

//Stmt1603:Parent
while ((unsigned long )f->prev != (unsigned long )((struct file *)0)) {
//Stmt1599:Leaf
f = f->prev;

     }

//Stmt1604:Leaf
f->prev = new;

   }

//Stmt1628:Leaf
return (new);

 }
}
 void rehash_file(struct file *file , char *name ) 
 { 
//Stmt1633:Leaf
char *oldname ;

//Stmt1634:Leaf
register unsigned int oldhash ;

//Stmt1635:Leaf
register char *n ;

 
   {
//Stmt1636:Leaf
oldname = file->hname;

//Stmt1637:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt1629:Leaf
file = file->renamed;

   }

//Stmt1638:Leaf
oldhash = 0U;

//Stmt1639:Leaf
n = oldname;

//Stmt1640:Parent
while ((int )*n != 0) {
//Stmt1630:Leaf
oldhash += (unsigned int )*n;

//Stmt1631:Leaf
oldhash = (oldhash << 7) + (oldhash >> 20);

//Stmt1632:Leaf
n ++;

   }

//Stmt1641:Leaf
file_hash_enter(file, name, oldhash, file->name);

//Stmt1642:Leaf
return;

 }
}
 void rename_file(struct file *file , char *name ) 
 { 
 
 
{
//Stmt1645:Leaf
rehash_file(file, name);

//Stmt1646:Parent
while (file) {
//Stmt1643:Leaf
file->name = file->hname;

//Stmt1644:Leaf
file = file->prev;

   }

//Stmt1647:Leaf
return;

 }
}
 void file_hash_enter(struct file *file , char *name , unsigned int oldhash , char *oldname ) 
 { 
//Stmt1720:Leaf
unsigned int oldbucket ;

//Stmt1721:Leaf
register unsigned int newhash ;

//Stmt1722:Leaf
register unsigned int newbucket ;

//Stmt1723:Leaf
struct file *oldfile ;

//Stmt1724:Leaf
register char *n ;

//Stmt1725:Leaf
register struct file *f ;

//Stmt1726:Leaf
int tmp ;

//Stmt1727:Leaf
struct file *lastf ;

//Stmt1728:Leaf
register struct dep *d ;

//Stmt1729:Leaf
char *tmp___0 ;

//Stmt1730:Leaf
char *tmp___1 ;

//Stmt1731:Leaf
char *tmp___2 ;

//Stmt1732:Leaf
char *tmp___3 ;

//Stmt1733:Leaf
char *tmp___4 ;

//Stmt1734:Leaf
char *tmp___5 ;

 
   {
//Stmt1735:Leaf
oldbucket = oldhash % 1007U;

//Stmt1736:Leaf
newhash = 0U;

//Stmt1737:Leaf
n = name;

//Stmt1738:Parent
while ((int )*n != 0) {
//Stmt1648:Leaf
newhash += (unsigned int )*n;

//Stmt1649:Leaf
newhash = (newhash << 7) + (newhash >> 20);

//Stmt1650:Leaf
n ++;

   }

//Stmt1739:Leaf
newbucket = newhash % 1007U;

//Stmt1740:Leaf
oldfile = files[newbucket];

//Stmt1741:Parent
while ((unsigned long )oldfile != (unsigned long )((struct file *)0)) {
//Stmt1658:Parent
if ((unsigned long )oldfile->hname == (unsigned long )name) {
//Stmt1656:Leaf
break;

     } else
     {
//Stmt1657:Parent
if ((int )*(oldfile->hname) == (int )*name) {
//Stmt1655:Parent
if ((int )*(oldfile->hname) == 0) {
//Stmt1652:Leaf
break;

       } else {
//Stmt1653:Leaf
tmp = strcmp((char const   *)(oldfile->hname + 1), (char const   *)(name + 1));

//Stmt1654:Parent
if (! tmp) {
//Stmt1651:Leaf
break;

         }

       }

     }
}


//Stmt1659:Leaf
oldfile = oldfile->next;

   }

//Stmt1742:Parent
if ((unsigned long )oldfile == (unsigned long )file) {
//Stmt1660:Leaf
return;

   }

//Stmt1743:Parent
if (oldhash != 0U) {
//Stmt1671:Parent
if (newbucket != oldbucket) {
//Stmt1669:Leaf
goto _L;

     } else
     {
//Stmt1670:Parent
if ((unsigned long )oldfile != (unsigned long )((struct file *)0)) {
       _L: /* CIL Label */ 
       {
//Stmt1661:Leaf
lastf = (struct file *)0;

}
//Stmt1666:Leaf
f = files[oldbucket];

//Stmt1667:Parent
while ((unsigned long )f != (unsigned long )file) {
//Stmt1662:Leaf
lastf = f;

//Stmt1663:Leaf
f = f->next;

       }

//Stmt1668:Parent
if ((unsigned long )lastf == (unsigned long )((struct file *)0)) {
//Stmt1664:Leaf
files[oldbucket] = f->next;

       } else {
//Stmt1665:Leaf
lastf->next = f->next;

       }

     }
}


   }

//Stmt1744:Leaf
file->hname = name;

//Stmt1745:Leaf
f = file->double_colon;

//Stmt1746:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1672:Leaf
f->hname = name;

//Stmt1673:Leaf
f = f->prev;

   }

//Stmt1747:Parent
if ((unsigned long )oldfile == (unsigned long )((struct file *)0)) {
//Stmt1702:Parent
if (newbucket != oldbucket) {
//Stmt1674:Leaf
file->next = files[newbucket];

//Stmt1675:Leaf
files[newbucket] = file;

     }

   } else {
//Stmt1703:Parent
if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
//Stmt1687:Parent
if ((unsigned long )oldfile->cmds == (unsigned long )((struct commands *)0)) {
//Stmt1685:Leaf
oldfile->cmds = file->cmds;

       } else
       {
//Stmt1686:Parent
if ((unsigned long )file->cmds != (unsigned long )oldfile->cmds) {
//Stmt1680:Parent
if ((unsigned long )(oldfile->cmds)->fileinfo.filenm != (unsigned long )((char *)0)) {
//Stmt1676:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "Commands were specified for file `%s\' at %s:%lu,",
                               5);

//Stmt1677:Leaf
error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___0,
                 oldname, (oldfile->cmds)->fileinfo.filenm, (oldfile->cmds)->fileinfo.lineno);

         } else {
//Stmt1678:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "Commands for file `%s\' were found by implicit rule search,",
                               5);

//Stmt1679:Leaf
error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___1,
                 oldname);

         }

//Stmt1681:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "but `%s\' is now considered the same file as `%s\'.",
                             5);

//Stmt1682:Leaf
error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___2,
               oldname, name);

//Stmt1683:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "Commands for `%s\' will be ignored in favor of those for `%s\'.",
                             5);

//Stmt1684:Leaf
error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___3,
               name, oldname);

       }
}


     }

//Stmt1704:Leaf
d = oldfile->deps;

//Stmt1705:Parent
if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
//Stmt1689:Leaf
oldfile->deps = file->deps;

     } else {
//Stmt1690:Parent
while ((unsigned long )d->next != (unsigned long )((struct dep *)0)) {
//Stmt1688:Leaf
d = d->next;

       }

//Stmt1691:Leaf
d->next = file->deps;

     }

//Stmt1706:Leaf
merge_variable_set_lists(& oldfile->variables, file->variables);

//Stmt1707:Parent
if (oldfile->double_colon) {
//Stmt1695:Parent
if (file->is_target) {
//Stmt1694:Parent
if (! file->double_colon) {
//Stmt1692:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "can\'t rename single-colon `%s\' to double-colon `%s\'",
                               5);

//Stmt1693:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___4,
                 oldname, name);

         }

       }

     }

//Stmt1708:Parent
if (! oldfile->double_colon) {
//Stmt1700:Parent
if (file->double_colon) {
//Stmt1699:Parent
if (oldfile->is_target) {
//Stmt1696:Leaf
tmp___5 = dcgettext((char const   *)((void *)0), "can\'t rename double-colon `%s\' to single-colon `%s\'",
                               5);

//Stmt1697:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___5,
                 oldname, name);

         } else {
//Stmt1698:Leaf
oldfile->double_colon = file->double_colon;

         }

       }

     }

//Stmt1709:Parent
if (file->last_mtime > oldfile->last_mtime) {
//Stmt1701:Leaf
oldfile->last_mtime = file->last_mtime;

     }

//Stmt1710:Leaf
oldfile->mtime_before_update = file->mtime_before_update;

//Stmt1711:Leaf
oldfile->precious |= file->precious;

//Stmt1712:Leaf
oldfile->tried_implicit |= file->tried_implicit;

//Stmt1713:Leaf
oldfile->updating |= file->updating;

//Stmt1714:Leaf
oldfile->updated |= file->updated;

//Stmt1715:Leaf
oldfile->is_target |= file->is_target;

//Stmt1716:Leaf
oldfile->cmd_target |= file->cmd_target;

//Stmt1717:Leaf
oldfile->phony |= file->phony;

//Stmt1718:Leaf
oldfile->ignore_vpath |= file->ignore_vpath;

//Stmt1719:Leaf
file->renamed = oldfile;

   }

//Stmt1748:Leaf
return;

 }
}
 void remove_intermediates(int sig ) 
 { 
//Stmt1789:Leaf
register int i ;

//Stmt1790:Leaf
register struct file *f ;

//Stmt1791:Leaf
char doneany ;

//Stmt1792:Leaf
int status ;

//Stmt1793:Leaf
int *tmp ;

//Stmt1794:Leaf
char *tmp___0 ;

 
   {
//Stmt1795:Parent
if (question_flag) {
//Stmt1750:Leaf
return;

   } else
   {
//Stmt1751:Parent
if (touch_flag) {
//Stmt1749:Leaf
return;

   }
}


//Stmt1796:Parent
if (sig) {
//Stmt1753:Parent
if (just_print_flag) {
//Stmt1752:Leaf
return;

     }

   }

//Stmt1797:Leaf
doneany = (char)0;

//Stmt1798:Leaf
i = 0;

//Stmt1799:Parent
while (i < 1007) {
//Stmt1783:Leaf
f = files[i];

//Stmt1784:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1782:Parent
if (f->intermediate) {
//Stmt1780:Parent
if (f->dontcare) {
//Stmt1778:Leaf
goto _L;

         } else
         {
//Stmt1779:Parent
if (! f->precious) {
           _L: /* CIL Label */ 
           {
//Stmt1777:Parent
if (! f->secondary) {
//Stmt1776:Parent
if (! f->cmd_target) {
//Stmt1774:Parent
if ((int )f->update_status == -1) {
//Stmt1760:Leaf
goto __Cont;

               } else
               {
//Stmt1761:Parent
if (just_print_flag) {
//Stmt1757:Leaf
status = 0;

               } else {
//Stmt1758:Leaf
status = unlink((char const   *)f->name);

//Stmt1759:Parent
if (status < 0) {
//Stmt1755:Leaf
tmp = __errno_location();

//Stmt1756:Parent
if (*tmp == 2) {
//Stmt1754:Leaf
goto __Cont;

                   }

                 }

               }
}


//Stmt1775:Parent
if (! f->dontcare) {
//Stmt1772:Parent
if (sig) {
//Stmt1768:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "*** Deleting intermediate file `%s\'",
                                       5);

//Stmt1769:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0,
                         f->name);

                 } else
                 {
//Stmt1770:Parent
if (! silent_flag) {
//Stmt1765:Parent
if (! doneany) {
//Stmt1762:Leaf
fputs((char const   * __restrict  )"rm ", (FILE * __restrict  )stdout);

//Stmt1763:Leaf
doneany = (char)1;

                   } else {
//Stmt1764:Leaf
putchar(' ');

                   }

//Stmt1766:Leaf
fputs((char const   * __restrict  )f->name, (FILE * __restrict  )stdout);

//Stmt1767:Leaf
fflush(stdout);

                 }
}


//Stmt1773:Parent
if (status < 0) {
//Stmt1771:Leaf
perror_with_name((char *)"unlink: ", f->name);

                 }

               }

             }

           }
}

         }
}


       }

       __Cont: /* CIL Label */ 
       {
//Stmt1781:Leaf
f = f->next;

}
     }

//Stmt1785:Leaf
i ++;

   }

//Stmt1800:Parent
if (doneany) {
//Stmt1788:Parent
if (! sig) {
//Stmt1786:Leaf
putchar('\n');

//Stmt1787:Leaf
fflush(stdout);

     }

   }

//Stmt1801:Leaf
return;

 }
}
 void snap_deps(void) 
 { 
//Stmt1890:Leaf
register struct file *f ;

//Stmt1891:Leaf
register struct file *f2 ;

//Stmt1892:Leaf
register struct dep *d ;

//Stmt1893:Leaf
register int i ;

//Stmt1894:Leaf
unsigned int tmp ;

//Stmt1895:Leaf
int i___0 ;

//Stmt1896:Leaf
unsigned int tmp___0 ;

 
   {
//Stmt1897:Leaf
i = 0;

//Stmt1898:Parent
while (i < 1007) {
//Stmt1815:Leaf
f = files[i];

//Stmt1816:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1812:Leaf
f2 = f;

//Stmt1813:Parent
while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
//Stmt1809:Leaf
d = f2->deps;

//Stmt1810:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1807:Parent
if ((unsigned long )d->name != (unsigned long )((char *)0)) {
//Stmt1804:Leaf
d->file = lookup_file(d->name);

//Stmt1805:Parent
if ((unsigned long )d->file == (unsigned long )((struct file *)0)) {
//Stmt1802:Leaf
d->file = enter_file(d->name);

             } else {
//Stmt1803:Leaf
free((void *)d->name);

             }

//Stmt1806:Leaf
d->name = (char *)0;

           }

//Stmt1808:Leaf
d = d->next;

         }

//Stmt1811:Leaf
f2 = f2->prev;

       }

//Stmt1814:Leaf
f = f->next;

     }

//Stmt1817:Leaf
i ++;

   }

//Stmt1899:Leaf
f = lookup_file((char *)".PRECIOUS");

//Stmt1900:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1823:Leaf
d = f->deps;

//Stmt1824:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1820:Leaf
f2 = d->file;

//Stmt1821:Parent
while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
//Stmt1818:Leaf
f2->precious = 1U;

//Stmt1819:Leaf
f2 = f2->prev;

       }

//Stmt1822:Leaf
d = d->next;

     }

//Stmt1825:Leaf
f = f->prev;

   }

//Stmt1901:Leaf
f = lookup_file((char *)".PHONY");

//Stmt1902:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1833:Leaf
d = f->deps;

//Stmt1834:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1830:Leaf
f2 = d->file;

//Stmt1831:Parent
while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
//Stmt1826:Leaf
f2->phony = 1U;

//Stmt1827:Leaf
f2->last_mtime = (uintmax_t )-1;

//Stmt1828:Leaf
f2->mtime_before_update = (uintmax_t )-1;

//Stmt1829:Leaf
f2 = f2->prev;

       }

//Stmt1832:Leaf
d = d->next;

     }

//Stmt1835:Leaf
f = f->prev;

   }

//Stmt1903:Leaf
f = lookup_file((char *)".INTERMEDIATE");

//Stmt1904:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1841:Leaf
d = f->deps;

//Stmt1842:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1838:Leaf
f2 = d->file;

//Stmt1839:Parent
while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
//Stmt1836:Leaf
f2->intermediate = 1U;

//Stmt1837:Leaf
f2 = f2->prev;

       }

//Stmt1840:Leaf
d = d->next;

     }

//Stmt1843:Leaf
f = f->prev;

   }

//Stmt1905:Leaf
f = lookup_file((char *)".SECONDARY");

//Stmt1906:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1862:Parent
if (f->deps) {
//Stmt1858:Leaf
d = f->deps;

//Stmt1859:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1848:Leaf
f2 = d->file;

//Stmt1849:Parent
while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
//Stmt1844:Leaf
tmp = 1U;

//Stmt1845:Leaf
f2->secondary = tmp;

//Stmt1846:Leaf
f2->intermediate = tmp;

//Stmt1847:Leaf
f2 = f2->prev;

         }

//Stmt1850:Leaf
d = d->next;

       }

     } else {
//Stmt1860:Leaf
i___0 = 0;

//Stmt1861:Parent
while (i___0 < 1007) {
//Stmt1855:Leaf
f2 = files[i___0];

//Stmt1856:Parent
while (f2) {
//Stmt1851:Leaf
tmp___0 = 1U;

//Stmt1852:Leaf
f2->secondary = tmp___0;

//Stmt1853:Leaf
f2->intermediate = tmp___0;

//Stmt1854:Leaf
f2 = f2->next;

         }

//Stmt1857:Leaf
i___0 ++;

       }

     }

//Stmt1863:Leaf
f = f->prev;

   }

//Stmt1907:Leaf
f = lookup_file((char *)".EXPORT_ALL_VARIABLES");

//Stmt1908:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1865:Parent
if (f->is_target) {
//Stmt1864:Leaf
export_all_variables = 1;

     }

   }

//Stmt1909:Leaf
f = lookup_file((char *)".IGNORE");

//Stmt1910:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1875:Parent
if (f->is_target) {
//Stmt1874:Parent
if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
//Stmt1871:Leaf
ignore_errors_flag = 1;

       } else {
//Stmt1872:Leaf
d = f->deps;

//Stmt1873:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1868:Leaf
f2 = d->file;

//Stmt1869:Parent
while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
//Stmt1866:Leaf
f2->command_flags |= 4;

//Stmt1867:Leaf
f2 = f2->prev;

           }

//Stmt1870:Leaf
d = d->next;

         }

       }

     }

   }

//Stmt1911:Leaf
f = lookup_file((char *)".SILENT");

//Stmt1912:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1885:Parent
if (f->is_target) {
//Stmt1884:Parent
if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
//Stmt1881:Leaf
silent_flag = 1;

       } else {
//Stmt1882:Leaf
d = f->deps;

//Stmt1883:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1878:Leaf
f2 = d->file;

//Stmt1879:Parent
while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
//Stmt1876:Leaf
f2->command_flags |= 2;

//Stmt1877:Leaf
f2 = f2->prev;

           }

//Stmt1880:Leaf
d = d->next;

         }

       }

     }

   }

//Stmt1913:Leaf
f = lookup_file((char *)".POSIX");

//Stmt1914:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1887:Parent
if (f->is_target) {
//Stmt1886:Leaf
posix_pedantic = 1;

     }

   }

//Stmt1915:Leaf
f = lookup_file((char *)".NOTPARALLEL");

//Stmt1916:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt1889:Parent
if (f->is_target) {
//Stmt1888:Leaf
not_parallel = 1;

     }

   }

//Stmt1917:Leaf
return;

 }
}
 void set_command_state(struct file *file , int state ) 
 { 
//Stmt1920:Leaf
struct dep *d ;

 
   {
//Stmt1921:Leaf
file->command_state = (enum __anonenum_command_state_55 )state;

//Stmt1922:Leaf
d = file->also_make;

//Stmt1923:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt1918:Leaf
(d->file)->command_state = (enum __anonenum_command_state_55 )state;

//Stmt1919:Leaf
d = d->next;

   }

//Stmt1924:Leaf
return;

 }
}
 uintmax_t file_timestamp_now(void) 
 { 
//Stmt1936:Leaf
struct timespec timespec ;

//Stmt1937:Leaf
uintmax_t tmp ;

//Stmt1938:Leaf
uintmax_t tmp___0 ;

//Stmt1939:Leaf
int tmp___1 ;

//Stmt1940:Leaf
time_t tmp___2 ;

//Stmt1941:Leaf
uintmax_t tmp___3 ;

//Stmt1942:Leaf
uintmax_t tmp___4 ;

 
   {
//Stmt1943:Leaf
tmp___1 = clock_gettime(0, & timespec);

//Stmt1944:Parent
if (tmp___1 == 0) {
//Stmt1929:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1925:Leaf
tmp = (uintmax_t )1000000000;

     } else {
//Stmt1926:Leaf
tmp = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

     }

//Stmt1930:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1927:Leaf
tmp___0 = (uintmax_t )1000000000;

     } else {
//Stmt1928:Leaf
tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

     }

//Stmt1931:Leaf
return ((uintmax_t )timespec.tv_sec * tmp + ((uintmax_t )timespec.tv_nsec * tmp___0) / 1000000000UL);

   }

//Stmt1945:Leaf
tmp___2 = time((time_t *)0);

//Stmt1946:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1932:Leaf
tmp___3 = (uintmax_t )1000000000;

   } else {
//Stmt1933:Leaf
tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1947:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1934:Leaf
tmp___4 = (uintmax_t )1000000000;

   } else {
//Stmt1935:Leaf
tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1948:Leaf
return ((uintmax_t )tmp___2 * tmp___3);

 }
}
 void file_timestamp_sprintf(char *p , uintmax_t ts ) 
 { 
//Stmt1968:Leaf
time_t t ;

//Stmt1969:Leaf
uintmax_t tmp ;

//Stmt1970:Leaf
uintmax_t tmp___0 ;

//Stmt1971:Leaf
struct tm *tm ;

//Stmt1972:Leaf
struct tm *tmp___1 ;

//Stmt1973:Leaf
size_t tmp___2 ;

//Stmt1974:Leaf
uintmax_t tmp___3 ;

//Stmt1975:Leaf
uintmax_t tmp___4 ;

//Stmt1976:Leaf
uintmax_t tmp___5 ;

//Stmt1977:Leaf
uintmax_t tmp___6 ;

//Stmt1978:Leaf
uintmax_t tmp___7 ;

//Stmt1979:Leaf
size_t tmp___8 ;

 
   {
//Stmt1980:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1949:Leaf
tmp = (uintmax_t )1000000000;

   } else {
//Stmt1950:Leaf
tmp = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1981:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1951:Leaf
tmp___0 = (uintmax_t )1000000000;

   } else {
//Stmt1952:Leaf
tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1982:Leaf
t = (time_t )(ts / tmp - (uintmax_t )(ts % tmp___0 < 0UL));

//Stmt1983:Leaf
tmp___1 = localtime((time_t const   *)(& t));

//Stmt1984:Leaf
tm = tmp___1;

//Stmt1985:Parent
if (tm) {
//Stmt1955:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )"%04d-%02d-%02d %02d:%02d:%02d",
             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min,
             tm->tm_sec);

   } else
   {
//Stmt1956:Parent
if (t < 0L) {
//Stmt1953:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )"%ld", t);

   } else {
//Stmt1954:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )"%lu", (unsigned long )t);

   }
}


//Stmt1986:Leaf
tmp___2 = strlen((char const   *)p);

//Stmt1987:Leaf
p += tmp___2;

//Stmt1988:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1957:Leaf
tmp___3 = (uintmax_t )1000000000;

   } else {
//Stmt1958:Leaf
tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1989:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1959:Leaf
tmp___4 = (uintmax_t )1000000000;

   } else {
//Stmt1960:Leaf
tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1990:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1961:Leaf
tmp___5 = (uintmax_t )1000000000;

   } else {
//Stmt1962:Leaf
tmp___5 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1991:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1963:Leaf
tmp___6 = (uintmax_t )1000000000;

   } else {
//Stmt1964:Leaf
tmp___6 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1992:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt1965:Leaf
tmp___7 = (uintmax_t )1000000000;

   } else {
//Stmt1966:Leaf
tmp___7 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt1993:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )".%09ld", (long )(((ts % tmp___3 + (uintmax_t )(ts % tmp___4 < 0UL) * tmp___5) * 1000000000UL + (tmp___6 - 1UL)) / tmp___7));

//Stmt1994:Leaf
tmp___8 = strlen((char const   *)p);

//Stmt1995:Leaf
p += tmp___8 - 1UL;

//Stmt1996:Parent
while ((int )*p == 48) {
//Stmt1967:Leaf
p --;

   }

//Stmt1997:Leaf
p += (int )*p != 46;

//Stmt1998:Leaf
*p = (char )'\000';

//Stmt1999:Leaf
return;

 }
}
 static void print_file(struct file *f ) 
 { 
//Stmt2072:Leaf
register struct dep *d ;

//Stmt2073:Leaf
char *tmp ;

//Stmt2074:Leaf
char const   *tmp___0 ;

//Stmt2075:Leaf
char *tmp___1 ;

//Stmt2076:Leaf
char *tmp___2 ;

//Stmt2077:Leaf
char *tmp___3 ;

//Stmt2078:Leaf
char *tmp___4 ;

//Stmt2079:Leaf
char *tmp___5 ;

//Stmt2080:Leaf
char *tmp___6 ;

//Stmt2081:Leaf
char *tmp___7 ;

//Stmt2082:Leaf
char *tmp___8 ;

//Stmt2083:Leaf
char *tmp___9 ;

//Stmt2084:Leaf
char *tmp___10 ;

//Stmt2085:Leaf
char *tmp___11 ;

//Stmt2086:Leaf
char *tmp___12 ;

//Stmt2087:Leaf
char *tmp___13 ;

//Stmt2088:Leaf
char *tmp___14 ;

//Stmt2089:Leaf
char buf___1[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;

//Stmt2090:Leaf
char *tmp___15 ;

//Stmt2091:Leaf
char *tmp___16 ;

//Stmt2092:Leaf
char *tmp___17 ;

//Stmt2093:Leaf
char *tmp___18 ;

//Stmt2094:Leaf
char *tmp___19 ;

//Stmt2095:Leaf
char *tmp___20 ;

//Stmt2096:Leaf
char *tmp___21 ;

//Stmt2097:Leaf
char *tmp___23 ;

//Stmt2098:Leaf
char *tmp___24 ;

//Stmt2099:Leaf
char *tmp___25 ;

//Stmt2100:Leaf
char *tmp___26 ;

 
   {
//Stmt2101:Leaf
putchar('\n');

//Stmt2102:Parent
if (! f->is_target) {
//Stmt2000:Leaf
tmp = dcgettext((char const   *)((void *)0), "# Not a target:", 5);

//Stmt2001:Leaf
puts((char const   *)tmp);

   }

//Stmt2103:Parent
if (f->double_colon) {
//Stmt2002:Leaf
tmp___0 = ":";

   } else {
//Stmt2003:Leaf
tmp___0 = "";

   }

//Stmt2104:Leaf
printf((char const   * __restrict  )"%s:%s", f->name, tmp___0);

//Stmt2105:Leaf
d = f->deps;

//Stmt2106:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt2006:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt2004:Leaf
tmp___1 = (d->file)->name;

     } else {
//Stmt2005:Leaf
tmp___1 = d->name;

     }

//Stmt2007:Leaf
printf((char const   * __restrict  )" %s", tmp___1);

//Stmt2008:Leaf
d = d->next;

   }

//Stmt2107:Leaf
putchar('\n');

//Stmt2108:Parent
if (f->precious) {
//Stmt2009:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "#  Precious file (prerequisite of .PRECIOUS).",
                         5);

//Stmt2010:Leaf
puts((char const   *)tmp___2);

   }

//Stmt2109:Parent
if (f->phony) {
//Stmt2011:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "#  Phony target (prerequisite of .PHONY).",
                         5);

//Stmt2012:Leaf
puts((char const   *)tmp___3);

   }

//Stmt2110:Parent
if (f->cmd_target) {
//Stmt2013:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "#  Command-line target.", 5);

//Stmt2014:Leaf
puts((char const   *)tmp___4);

   }

//Stmt2111:Parent
if (f->dontcare) {
//Stmt2015:Leaf
tmp___5 = dcgettext((char const   *)((void *)0), "#  A default or MAKEFILES makefile.",
                         5);

//Stmt2016:Leaf
puts((char const   *)tmp___5);

   }

//Stmt2112:Parent
if (f->tried_implicit) {
//Stmt2017:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "#  Implicit rule search has been done.",
                         5);

//Stmt2018:Leaf
tmp___8 = tmp___6;

   } else {
//Stmt2019:Leaf
tmp___7 = dcgettext((char const   *)((void *)0), "#  Implicit rule search has not been done.",
                         5);

//Stmt2020:Leaf
tmp___8 = tmp___7;

   }

//Stmt2113:Leaf
puts((char const   *)tmp___8);

//Stmt2114:Parent
if ((unsigned long )f->stem != (unsigned long )((char *)0)) {
//Stmt2021:Leaf
tmp___9 = dcgettext((char const   *)((void *)0), "#  Implicit/static pattern stem: `%s\'\n",
                         5);

//Stmt2022:Leaf
printf((char const   * __restrict  )tmp___9, f->stem);

   }

//Stmt2115:Parent
if (f->intermediate) {
//Stmt2023:Leaf
tmp___10 = dcgettext((char const   *)((void *)0), "#  File is an intermediate prerequisite.",
                          5);

//Stmt2024:Leaf
puts((char const   *)tmp___10);

   }

//Stmt2116:Parent
if ((unsigned long )f->also_make != (unsigned long )((struct dep *)0)) {
//Stmt2030:Leaf
tmp___11 = dcgettext((char const   *)((void *)0), "#  Also makes:", 5);

//Stmt2031:Leaf
fputs((char const   * __restrict  )tmp___11, (FILE * __restrict  )stdout);

//Stmt2032:Leaf
d = f->also_make;

//Stmt2033:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt2027:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt2025:Leaf
tmp___12 = (d->file)->name;

       } else {
//Stmt2026:Leaf
tmp___12 = d->name;

       }

//Stmt2028:Leaf
printf((char const   * __restrict  )" %s", tmp___12);

//Stmt2029:Leaf
d = d->next;

     }

//Stmt2034:Leaf
putchar('\n');

   }

//Stmt2117:Parent
if (f->last_mtime == 0UL) {
//Stmt2040:Leaf
tmp___13 = dcgettext((char const   *)((void *)0), "#  Modification time never checked.",
                          5);

//Stmt2041:Leaf
puts((char const   *)tmp___13);

   } else
   {
//Stmt2042:Parent
if (f->last_mtime == 0xffffffffffffffffUL) {
//Stmt2035:Leaf
tmp___14 = dcgettext((char const   *)((void *)0), "#  File does not exist.", 5);

//Stmt2036:Leaf
puts((char const   *)tmp___14);

   } else {
//Stmt2037:Leaf
file_timestamp_sprintf(buf___1, f->last_mtime);

//Stmt2038:Leaf
tmp___15 = dcgettext((char const   *)((void *)0), "#  Last modified %s\n", 5);

//Stmt2039:Leaf
printf((char const   * __restrict  )tmp___15, buf___1);

   }
}


//Stmt2118:Parent
if (f->updated) {
//Stmt2043:Leaf
tmp___16 = dcgettext((char const   *)((void *)0), "#  File has been updated.",
                          5);

//Stmt2044:Leaf
tmp___18 = tmp___16;

   } else {
//Stmt2045:Leaf
tmp___17 = dcgettext((char const   *)((void *)0), "#  File has not been updated.",
                          5);

//Stmt2046:Leaf
tmp___18 = tmp___17;

   }

//Stmt2119:Leaf
puts((char const   *)tmp___18);

//Stmt2120:Parent
switch ((unsigned int )f->command_state) {
   case 2U:; 
//Stmt2047:Leaf
tmp___19 = dcgettext((char const   *)((void *)0), "#  Commands currently running (THIS IS A BUG).",
                        5);

//Stmt2064:Leaf
puts((char const   *)tmp___19);

   break;
   case 1U:; 
//Stmt2048:Leaf
tmp___20 = dcgettext((char const   *)((void *)0), "#  Dependencies commands running (THIS IS A BUG).",
                        5);

//Stmt2065:Leaf
puts((char const   *)tmp___20);

   break;
   case 3U:; 
   case 0U:; 
//Stmt2062:Parent
switch ((int )f->update_status) {
   case -1:; 
   break;
   case 0:; 
//Stmt2049:Leaf
tmp___21 = dcgettext((char const   *)((void *)0), "#  Successfully updated.", 5);

//Stmt2054:Leaf
puts((char const   *)tmp___21);

   break;
   case 1:; 
//Stmt2051:Parent
if (! question_flag) {
//Stmt2050:Leaf
__assert_fail("question_flag", "file.c", 681U, "print_file");

   }

//Stmt2055:Leaf
tmp___23 = dcgettext((char const   *)((void *)0), "#  Needs to be updated (-q is set).",
                        5);

//Stmt2056:Leaf
puts((char const   *)tmp___23);

   break;
   case 2:; 
//Stmt2052:Leaf
tmp___24 = dcgettext((char const   *)((void *)0), "#  Failed to be updated.", 5);

//Stmt2057:Leaf
puts((char const   *)tmp___24);

   break;
   default:; 
//Stmt2053:Leaf
tmp___25 = dcgettext((char const   *)((void *)0), "#  Invalid value in `update_status\' member!",
                        5);

//Stmt2058:Leaf
puts((char const   *)tmp___25);

//Stmt2059:Leaf
fflush(stdout);

//Stmt2060:Leaf
fflush(stderr);

//Stmt2061:Leaf
abort();

   }

   break;
   default:; 
//Stmt2063:Leaf
tmp___26 = dcgettext((char const   *)((void *)0), "#  Invalid value in `command_state\' member!",
                        5);

//Stmt2066:Leaf
puts((char const   *)tmp___26);

//Stmt2067:Leaf
fflush(stdout);

//Stmt2068:Leaf
fflush(stderr);

//Stmt2069:Leaf
abort();

   }

//Stmt2121:Parent
if ((unsigned long )f->variables != (unsigned long )((struct variable_set_list *)0)) {
//Stmt2070:Leaf
print_file_variables(f);

   }

//Stmt2122:Parent
if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
//Stmt2071:Leaf
print_commands(f->cmds);

   }

//Stmt2123:Leaf
return;

 }
}
 void print_file_data_base(void) 
 { 
//Stmt2143:Leaf
register unsigned int i ;

//Stmt2144:Leaf
register unsigned int nfiles ;

//Stmt2145:Leaf
register unsigned int per_bucket ;

//Stmt2146:Leaf
register struct file *file ;

//Stmt2147:Leaf
char *tmp ;

//Stmt2148:Leaf
register unsigned int this_bucket ;

//Stmt2149:Leaf
register struct file *f ;

//Stmt2150:Leaf
char *tmp___0 ;

//Stmt2151:Leaf
char *tmp___1 ;

//Stmt2152:Leaf
char *tmp___2 ;

 
   {
//Stmt2153:Leaf
tmp = dcgettext((char const   *)((void *)0), "\n# Files", 5);

//Stmt2154:Leaf
puts((char const   *)tmp);

//Stmt2155:Leaf
nfiles = 0U;

//Stmt2156:Leaf
per_bucket = nfiles;

//Stmt2157:Leaf
i = 0U;

//Stmt2158:Parent
while (i < 1007U) {
//Stmt2131:Leaf
this_bucket = 0U;

//Stmt2132:Leaf
file = files[i];

//Stmt2133:Parent
while ((unsigned long )file != (unsigned long )((struct file *)0)) {
//Stmt2126:Leaf
this_bucket ++;

//Stmt2127:Leaf
f = file;

//Stmt2128:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt2124:Leaf
print_file(f);

//Stmt2125:Leaf
f = f->prev;

       }

//Stmt2129:Leaf
file = file->next;

     }

//Stmt2134:Leaf
nfiles += this_bucket;

//Stmt2135:Parent
if (this_bucket > per_bucket) {
//Stmt2130:Leaf
per_bucket = this_bucket;

     }

//Stmt2136:Leaf
i ++;

   }

//Stmt2159:Parent
if (nfiles == 0U) {
//Stmt2137:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "\n# No files.", 5);

//Stmt2138:Leaf
puts((char const   *)tmp___0);

   } else {
//Stmt2139:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "\n# %u files in %u hash buckets.\n",
                         5);

//Stmt2140:Leaf
printf((char const   * __restrict  )tmp___1, nfiles, 1007);

//Stmt2141:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "# average %.3f files per bucket, max %u files in one bucket.\n",
                         5);

//Stmt2142:Leaf
printf((char const   * __restrict  )tmp___2, (double )nfiles / (double )1007,
            per_bucket);

   }

//Stmt2160:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-xaw3DgWu.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
 extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
 char *find_next_token(char **ptr , unsigned int *lengthptr ) ;
 char *next_token(char *s ) ;
 char *end_of_token(char *s ) ;
 extern char **environ ;
 int pattern_matches(char *pattern , char *percent , char *str ) ;
 struct variable_set_list *push_new_variable_scope(void) ;
 void pop_variable_scope(void) ;
 struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) ;
 struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                                int strip ) ;
 char **construct_command_argv(char *line , char **restp , struct file *file , char **batch_filename_ptr ) ;
 void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) ;
 int db_level ;
 char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                    unsigned int rlen , int by_word , int suffix_only ) 
 { 
//Stmt2204:Leaf
register char *t ;

//Stmt2205:Leaf
register char *p ;

//Stmt2206:Leaf
size_t tmp ;

//Stmt2207:Leaf
char *tmp___0 ;

//Stmt2208:Leaf
size_t tmp___1 ;

//Stmt2209:Leaf
unsigned short const   **tmp___2 ;

//Stmt2210:Leaf
unsigned short const   **tmp___3 ;

//Stmt2211:Leaf
unsigned short const   **tmp___4 ;

 
   {
//Stmt2212:Leaf
t = text;

//Stmt2213:Parent
if (slen == 0U) {
//Stmt2167:Parent
if (! by_word) {
//Stmt2166:Parent
if (! suffix_only) {
//Stmt2162:Leaf
tmp = strlen((char const   *)t);

//Stmt2163:Leaf
o = variable_buffer_output(o, t, (unsigned int )tmp);

//Stmt2164:Parent
if (rlen > 0U) {
//Stmt2161:Leaf
o = variable_buffer_output(o, replace, rlen);

         }

//Stmt2165:Leaf
return (o);

       }

     }

   }

//Stmt2214:Parent
while (1) {
//Stmt2199:Parent
if (by_word | suffix_only) {
//Stmt2175:Parent
if (slen == 0U) {
//Stmt2168:Leaf
tmp___0 = next_token(t);

//Stmt2169:Leaf
p = end_of_token(tmp___0);

       } else {
//Stmt2170:Leaf
goto _L;

       }

     } else {
       _L: /* CIL Label */ 
       {
//Stmt2171:Leaf
p = sindex((char const   *)t, 0U, (char const   *)subst, slen);

}
//Stmt2176:Parent
if ((unsigned long )p == (unsigned long )((char *)0)) {
//Stmt2172:Leaf
tmp___1 = strlen((char const   *)t);

//Stmt2173:Leaf
o = variable_buffer_output(o, t, (unsigned int )tmp___1);

//Stmt2174:Leaf
return (o);

       }

     }

//Stmt2200:Parent
if ((unsigned long )p > (unsigned long )t) {
//Stmt2177:Leaf
o = variable_buffer_output(o, t, (unsigned int )(p - t));

     }

//Stmt2201:Parent
if (by_word) {
//Stmt2197:Parent
if ((unsigned long )p > (unsigned long )t) {
//Stmt2186:Leaf
tmp___2 = __ctype_b_loc();

//Stmt2187:Parent
if ((int const   )*(*tmp___2 + (int )*(p + -1)) & 1) {
//Stmt2178:Leaf
goto _L___2;

         } else {
//Stmt2179:Leaf
o = variable_buffer_output(o, subst, slen);

         }

       } else
       _L___2: /* CIL Label */ 
       {
//Stmt2185:Parent
if ((int )*(p + slen) != 0) {
//Stmt2182:Leaf
tmp___3 = __ctype_b_loc();

//Stmt2183:Parent
if ((int const   )*(*tmp___3 + (int )*(p + slen)) & 1) {
//Stmt2180:Leaf
goto _L___1;

         } else {
//Stmt2181:Leaf
o = variable_buffer_output(o, subst, slen);

         }

       } else {
//Stmt2184:Leaf
goto _L___1;

       }
}


     } else
     _L___1: /* CIL Label */ 
     {
//Stmt2196:Parent
if (suffix_only) {
//Stmt2195:Parent
if ((int )*(p + slen) != 0) {
//Stmt2190:Leaf
tmp___4 = __ctype_b_loc();

//Stmt2191:Parent
if ((int const   )*(*tmp___4 + (int )*(p + slen)) & 1) {
//Stmt2188:Leaf
goto _L___0;

         } else {
//Stmt2189:Leaf
o = variable_buffer_output(o, subst, slen);

         }

       } else {
//Stmt2192:Leaf
goto _L___0;

       }

     } else
     _L___0: /* CIL Label */ 
     {
//Stmt2194:Parent
if (rlen > 0U) {
//Stmt2193:Leaf
o = variable_buffer_output(o, replace, rlen);

     }
}

}


//Stmt2202:Leaf
t = p + slen;

//Stmt2203:Parent
if (! ((int )*t != 0)) {
//Stmt2198:Leaf
break;

     }

   }

//Stmt2215:Leaf
return (o);

 }
}
 char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                       char *replace_percent ) 
 { 
//Stmt2268:Leaf
unsigned int pattern_prepercent_len ;

//Stmt2269:Leaf
unsigned int pattern_postpercent_len ;

//Stmt2270:Leaf
unsigned int replace_prepercent_len ;

//Stmt2271:Leaf
unsigned int replace_postpercent_len ;

//Stmt2272:Leaf
char *t ;

//Stmt2273:Leaf
int len ;

//Stmt2274:Leaf
int doneany ;

//Stmt2275:Leaf
size_t tmp ;

//Stmt2276:Leaf
size_t tmp___0 ;

//Stmt2277:Leaf
size_t tmp___1 ;

//Stmt2278:Leaf
size_t tmp___2 ;

//Stmt2279:Leaf
char *tmp___3 ;

//Stmt2280:Leaf
size_t tmp___4 ;

//Stmt2281:Leaf
int fail ;

//Stmt2282:Leaf
int tmp___5 ;

//Stmt2283:Leaf
int tmp___6 ;

 
   {
//Stmt2284:Leaf
replace_postpercent_len = 0U;

//Stmt2285:Leaf
doneany = 0;

//Stmt2286:Parent
if ((unsigned long )replace_percent == (unsigned long )((char *)0)) {
//Stmt2216:Leaf
replace_percent = find_percent(replace);

   }

//Stmt2287:Parent
if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
//Stmt2217:Leaf
replace_prepercent_len = (unsigned int )(replace_percent - replace);

//Stmt2218:Leaf
tmp = strlen((char const   *)(replace_percent + 1));

//Stmt2219:Leaf
replace_postpercent_len = (unsigned int )tmp;

   } else {
//Stmt2220:Leaf
tmp___0 = strlen((char const   *)replace);

//Stmt2221:Leaf
replace_prepercent_len = (unsigned int )tmp___0;

   }

//Stmt2288:Parent
if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
//Stmt2222:Leaf
pattern_percent = find_percent(pattern);

   }

//Stmt2289:Parent
if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
//Stmt2223:Leaf
tmp___1 = strlen((char const   *)replace);

//Stmt2224:Leaf
tmp___2 = strlen((char const   *)pattern);

//Stmt2225:Leaf
tmp___3 = subst_expand(o, text, pattern, replace, (unsigned int )tmp___2, (unsigned int )tmp___1,
                            1, 0);

//Stmt2226:Leaf
return (tmp___3);

   }

//Stmt2290:Leaf
pattern_prepercent_len = (unsigned int )(pattern_percent - pattern);

//Stmt2291:Leaf
tmp___4 = strlen((char const   *)(pattern_percent + 1));

//Stmt2292:Leaf
pattern_postpercent_len = (unsigned int )tmp___4;

//Stmt2293:Parent
while (1) {
//Stmt2259:Leaf
t = find_next_token(& text, (unsigned int *)(& len));

//Stmt2260:Parent
if (! ((unsigned long )t != (unsigned long )((char *)0))) {
//Stmt2227:Leaf
break;

     }

//Stmt2261:Leaf
fail = 0;

//Stmt2262:Parent
if ((unsigned int )len < pattern_prepercent_len + pattern_postpercent_len) {
//Stmt2228:Leaf
fail = 1;

     }

//Stmt2263:Parent
if (! fail) {
//Stmt2236:Parent
if (pattern_prepercent_len > 0U) {
//Stmt2235:Parent
if ((int )*t != (int )*pattern) {
//Stmt2233:Leaf
fail = 1;

         } else
         {
//Stmt2234:Parent
if ((int )*(t + (pattern_prepercent_len - 1U)) != (int )*(pattern_percent + -1)) {
//Stmt2230:Leaf
fail = 1;

         } else {
//Stmt2231:Leaf
tmp___5 = strncmp((char const   *)(t + 1), (char const   *)(pattern + 1),
                             (size_t )(pattern_prepercent_len - 1U));

//Stmt2232:Parent
if (! (tmp___5 == 0)) {
//Stmt2229:Leaf
fail = 1;

           }

         }
}


       }

     }

//Stmt2264:Parent
if (! fail) {
//Stmt2244:Parent
if (pattern_postpercent_len > 0U) {
//Stmt2243:Parent
if ((int )*(t + (len - 1)) != (int )*(pattern_percent + pattern_postpercent_len)) {
//Stmt2241:Leaf
fail = 1;

         } else
         {
//Stmt2242:Parent
if ((int )*(t + ((unsigned int )len - pattern_postpercent_len)) != (int )*(pattern_percent + 1)) {
//Stmt2238:Leaf
fail = 1;

         } else {
//Stmt2239:Leaf
tmp___6 = strncmp((char const   *)(t + ((unsigned int )len - pattern_postpercent_len)),
                             (char const   *)(pattern_percent + 1), (size_t )(pattern_postpercent_len - 1U));

//Stmt2240:Parent
if (! (tmp___6 == 0)) {
//Stmt2237:Leaf
fail = 1;

           }

         }
}


       }

     }

//Stmt2265:Parent
if (fail) {
//Stmt2247:Leaf
o = variable_buffer_output(o, t, (unsigned int )len);

     } else {
//Stmt2248:Leaf
o = variable_buffer_output(o, replace, replace_prepercent_len);

//Stmt2249:Parent
if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
//Stmt2245:Leaf
o = variable_buffer_output(o, t + pattern_prepercent_len, (unsigned int )len - (pattern_prepercent_len + pattern_postpercent_len));

//Stmt2246:Leaf
o = variable_buffer_output(o, replace_percent + 1, replace_postpercent_len);

       }

     }

//Stmt2266:Parent
if (fail) {
//Stmt2256:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2257:Leaf
doneany = 1;

     } else
     {
//Stmt2258:Parent
if (replace_prepercent_len > 0U) {
//Stmt2253:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2254:Leaf
doneany = 1;

     } else
     {
//Stmt2255:Parent
if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
//Stmt2252:Parent
if ((unsigned int )len + replace_postpercent_len > 0U) {
//Stmt2250:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2251:Leaf
doneany = 1;

       }

     }
}

}


   }

//Stmt2294:Parent
if (doneany) {
//Stmt2267:Leaf
o --;

   }

//Stmt2295:Leaf
return (o);

 }
}
 static struct function_table_entry  const  *lookup_function(struct function_table_entry  const  *table ,
                                                             char const   *s ) 
 { 
//Stmt2305:Leaf
int len ;

//Stmt2306:Leaf
size_t tmp ;

//Stmt2307:Leaf
unsigned short const   **tmp___0 ;

//Stmt2308:Leaf
int tmp___1 ;

 
   {
//Stmt2309:Leaf
tmp = strlen(s);

//Stmt2310:Leaf
len = (int )tmp;

//Stmt2311:Parent
while ((unsigned long )table->name != (unsigned long )((void *)0)) {
//Stmt2303:Parent
if ((int const   )table->len <= (int const   )len) {
//Stmt2301:Leaf
tmp___0 = __ctype_b_loc();

//Stmt2302:Parent
if ((int const   )*(*tmp___0 + (int )*(s + table->len)) & 1) {
//Stmt2299:Leaf
goto _L;

       } else
       {
//Stmt2300:Parent
if ((int const   )*(s + table->len) == 0) {
         _L: /* CIL Label */ 
         {
//Stmt2296:Leaf
tmp___1 = strncmp(s, (char const   *)table->name, (size_t )table->len);

}
//Stmt2298:Parent
if (tmp___1 == 0) {
//Stmt2297:Leaf
return (table);

         }

       }
}


     }

//Stmt2304:Leaf
table ++;

   }

//Stmt2312:Leaf
return ((struct function_table_entry  const  *)((void *)0));

 }
}
 int pattern_matches(char *pattern , char *percent , char *str ) 
 { 
//Stmt2338:Leaf
unsigned int sfxlen ;

//Stmt2339:Leaf
unsigned int strlength ;

//Stmt2340:Leaf
unsigned int len ;

//Stmt2341:Leaf
size_t tmp ;

//Stmt2342:Leaf
char *new_chars ;

//Stmt2343:Leaf
void *tmp___0 ;

//Stmt2344:Leaf
int tmp___1 ;

//Stmt2345:Leaf
int tmp___2 ;

//Stmt2346:Leaf
size_t tmp___3 ;

//Stmt2347:Leaf
size_t tmp___4 ;

//Stmt2348:Leaf
int tmp___5 ;

//Stmt2349:Leaf
int tmp___6 ;

//Stmt2350:Leaf
int tmp___7 ;

 
   {
//Stmt2351:Parent
if ((unsigned long )percent == (unsigned long )((char *)0)) {
//Stmt2324:Leaf
tmp = strlen((char const   *)pattern);

//Stmt2325:Leaf
len = (unsigned int )(tmp + 1UL);

//Stmt2326:Leaf
tmp___0 = __builtin_alloca((unsigned long )len);

//Stmt2327:Leaf
new_chars = (char *)tmp___0;

//Stmt2328:Leaf
memmove((void *)new_chars, (void const   *)pattern, (size_t )len);

//Stmt2329:Leaf
pattern = new_chars;

//Stmt2330:Leaf
percent = find_percent(pattern);

//Stmt2331:Parent
if ((unsigned long )percent == (unsigned long )((char *)0)) {
//Stmt2322:Parent
if ((unsigned long )pattern == (unsigned long )str) {
//Stmt2320:Leaf
tmp___2 = 1;

       } else
       {
//Stmt2321:Parent
if ((int )*pattern == (int )*str) {
//Stmt2318:Parent
if ((int )*pattern == 0) {
//Stmt2315:Leaf
tmp___2 = 1;

         } else {
//Stmt2316:Leaf
tmp___1 = strcmp((char const   *)(pattern + 1), (char const   *)(str + 1));

//Stmt2317:Parent
if (tmp___1) {
//Stmt2313:Leaf
tmp___2 = 0;

           } else {
//Stmt2314:Leaf
tmp___2 = 1;

           }

         }

       } else {
//Stmt2319:Leaf
tmp___2 = 0;

       }
}


//Stmt2323:Leaf
return (tmp___2);

     }

   }

//Stmt2352:Leaf
tmp___3 = strlen((char const   *)(percent + 1));

//Stmt2353:Leaf
sfxlen = (unsigned int )tmp___3;

//Stmt2354:Leaf
tmp___4 = strlen((char const   *)str);

//Stmt2355:Leaf
strlength = (unsigned int )tmp___4;

//Stmt2356:Parent
if ((long )strlength < (percent - pattern) + (long )sfxlen) {
//Stmt2333:Leaf
return (0);

   } else {
//Stmt2334:Leaf
tmp___5 = strncmp((char const   *)pattern, (char const   *)str, (size_t )(percent - pattern));

//Stmt2335:Parent
if (! (tmp___5 == 0)) {
//Stmt2332:Leaf
return (0);

     }

   }

//Stmt2357:Leaf
tmp___6 = strcmp((char const   *)(percent + 1), (char const   *)(str + (strlength - sfxlen)));

//Stmt2358:Parent
if (tmp___6) {
//Stmt2336:Leaf
tmp___7 = 0;

   } else {
//Stmt2337:Leaf
tmp___7 = 1;

   }

//Stmt2359:Leaf
return (tmp___7);

 }
}
 static char *find_next_argument(char startparen , char endparen , char const   *ptr ,
                                 char const   *end ) 
 { 
//Stmt2370:Leaf
int count ;

 
   {
//Stmt2371:Leaf
count = 0;

//Stmt2372:Parent
while ((unsigned long )ptr < (unsigned long )end) {
//Stmt2368:Parent
if ((int const   )*ptr == (int const   )startparen) {
//Stmt2366:Leaf
count ++;

     } else
     {
//Stmt2367:Parent
if ((int const   )*ptr == (int const   )endparen) {
//Stmt2363:Leaf
count --;

//Stmt2364:Parent
if (count < 0) {
//Stmt2360:Leaf
return ((char *)((void *)0));

       }

     } else
     {
//Stmt2365:Parent
if ((int const   )*ptr == 44) {
//Stmt2362:Parent
if (! count) {
//Stmt2361:Leaf
return ((char *)ptr);

       }

     }
}

}


//Stmt2369:Leaf
ptr ++;

   }

//Stmt2373:Leaf
return ((char *)((void *)0));

 }
}
 static char *string_glob(char *line ) ;
 static char *result  =    (char *)0;
 static unsigned int length  ;
 static char *string_glob(char *line ) 
 { 
//Stmt2397:Leaf
register struct nameseq *chain ;

//Stmt2398:Leaf
register unsigned int idx ;

//Stmt2399:Leaf
struct nameseq *tmp ;

//Stmt2400:Leaf
char *tmp___0 ;

//Stmt2401:Leaf
register char *name ;

//Stmt2402:Leaf
unsigned int len ;

//Stmt2403:Leaf
size_t tmp___1 ;

//Stmt2404:Leaf
struct nameseq *next ;

//Stmt2405:Leaf
char *tmp___2 ;

//Stmt2406:Leaf
unsigned int tmp___3 ;

//Stmt2407:Leaf
int tmp___4 ;

 
   {
//Stmt2408:Leaf
tmp = parse_file_seq(& line, '\000', (unsigned int )sizeof(struct nameseq ), 0);

//Stmt2409:Leaf
chain = multi_glob(tmp, (unsigned int )sizeof(struct nameseq ));

//Stmt2410:Parent
if ((unsigned long )result == (unsigned long )((char *)0)) {
//Stmt2374:Leaf
length = 100U;

//Stmt2375:Leaf
tmp___0 = xmalloc(100U);

//Stmt2376:Leaf
result = tmp___0;

   }

//Stmt2411:Leaf
idx = 0U;

//Stmt2412:Parent
while ((unsigned long )chain != (unsigned long )((struct nameseq *)0)) {
//Stmt2386:Leaf
name = chain->name;

//Stmt2387:Leaf
tmp___1 = strlen((char const   *)name);

//Stmt2388:Leaf
len = (unsigned int )tmp___1;

//Stmt2389:Leaf
next = chain->next;

//Stmt2390:Leaf
free((void *)((char *)chain));

//Stmt2391:Leaf
chain = next;

//Stmt2392:Leaf
tmp___4 = file_exists_p(name);

//Stmt2393:Parent
if (tmp___4) {
//Stmt2380:Parent
if ((idx + len) + 1U > length) {
//Stmt2377:Leaf
length += (len + 1U) * 2U;

//Stmt2378:Leaf
tmp___2 = xrealloc(result, length);

//Stmt2379:Leaf
result = tmp___2;

       }

//Stmt2381:Leaf
memmove((void *)(result + idx), (void const   *)name, (size_t )len);

//Stmt2382:Leaf
idx += len;

//Stmt2383:Leaf
tmp___3 = idx;

//Stmt2384:Leaf
idx ++;

//Stmt2385:Leaf
*(result + tmp___3) = (char )' ';

     }

//Stmt2394:Leaf
free((void *)name);

   }

//Stmt2413:Parent
if (idx == 0U) {
//Stmt2395:Leaf
*(result + 0) = (char )'\000';

   } else {
//Stmt2396:Leaf
*(result + (idx - 1U)) = (char )'\000';

   }

//Stmt2414:Leaf
return (result);

 }
}
 static char *func_patsubst(char *o , char **argv , char const   *funcname ) 
 { 
 
 
{
//Stmt2415:Leaf
o = patsubst_expand(o, *(argv + 2), *(argv + 0), *(argv + 1), (char *)0, (char *)0);

//Stmt2416:Leaf
return (o);

 }
}
 static char *func_join(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2433:Leaf
int doneany ;

//Stmt2434:Leaf
register char *tp ;

//Stmt2435:Leaf
register char *pp ;

//Stmt2436:Leaf
char *list1_iterator ;

//Stmt2437:Leaf
char *list2_iterator ;

//Stmt2438:Leaf
unsigned int len1 ;

//Stmt2439:Leaf
unsigned int len2 ;

 
   {
//Stmt2440:Leaf
doneany = 0;

//Stmt2441:Leaf
list1_iterator = *(argv + 0);

//Stmt2442:Leaf
list2_iterator = *(argv + 1);

//Stmt2443:Parent
while (1) {
//Stmt2426:Leaf
tp = find_next_token(& list1_iterator, & len1);

//Stmt2427:Parent
if ((unsigned long )tp != (unsigned long )((char *)0)) {
//Stmt2417:Leaf
o = variable_buffer_output(o, tp, len1);

     }

//Stmt2428:Leaf
pp = find_next_token(& list2_iterator, & len2);

//Stmt2429:Parent
if ((unsigned long )pp != (unsigned long )((char *)0)) {
//Stmt2418:Leaf
o = variable_buffer_output(o, pp, len2);

     }

//Stmt2430:Parent
if ((unsigned long )tp != (unsigned long )((char *)0)) {
//Stmt2421:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2422:Leaf
doneany = 1;

     } else
     {
//Stmt2423:Parent
if ((unsigned long )pp != (unsigned long )((char *)0)) {
//Stmt2419:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2420:Leaf
doneany = 1;

     }
}


//Stmt2431:Parent
if (! ((unsigned long )tp != (unsigned long )((char *)0))) {
//Stmt2425:Parent
if (! ((unsigned long )pp != (unsigned long )((char *)0))) {
//Stmt2424:Leaf
break;

       }

     }

   }

//Stmt2444:Parent
if (doneany) {
//Stmt2432:Leaf
o --;

   }

//Stmt2445:Leaf
return (o);

 }
}
 static char *func_origin(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2456:Leaf
register struct variable *v ;

//Stmt2457:Leaf
size_t tmp ;

//Stmt2458:Leaf
struct variable *tmp___0 ;

 
   {
//Stmt2459:Leaf
tmp = strlen((char const   *)*(argv + 0));

//Stmt2460:Leaf
tmp___0 = lookup_variable(*(argv + 0), (unsigned int )tmp);

//Stmt2461:Leaf
v = tmp___0;

//Stmt2462:Parent
if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
//Stmt2454:Leaf
o = variable_buffer_output(o, (char *)"undefined", 9U);

   } else {
//Stmt2455:Parent
switch ((unsigned int )v->origin) {
     default:; 
//Stmt2446:Leaf
abort();

     break;
     case 0U:; 
//Stmt2447:Leaf
o = variable_buffer_output(o, (char *)"default", 7U);

     break;
     case 1U:; 
//Stmt2448:Leaf
o = variable_buffer_output(o, (char *)"environment", 11U);

     break;
     case 2U:; 
//Stmt2449:Leaf
o = variable_buffer_output(o, (char *)"file", 4U);

     break;
     case 3U:; 
//Stmt2450:Leaf
o = variable_buffer_output(o, (char *)"environment override", 20U);

     break;
     case 4U:; 
//Stmt2451:Leaf
o = variable_buffer_output(o, (char *)"command line", 12U);

     break;
     case 5U:; 
//Stmt2452:Leaf
o = variable_buffer_output(o, (char *)"override", 8U);

     break;
     case 6U:; 
//Stmt2453:Leaf
o = variable_buffer_output(o, (char *)"automatic", 9U);

     break;
     }

   }

//Stmt2463:Leaf
return (o);

 }
}
 static char *func_notdir_suffix(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2501:Leaf
char *list_iterator ;

//Stmt2502:Leaf
char *p2 ;

//Stmt2503:Leaf
int doneany ;

//Stmt2504:Leaf
unsigned int len ;

//Stmt2505:Leaf
int is_suffix ;

//Stmt2506:Leaf
int tmp ;

//Stmt2507:Leaf
int tmp___0 ;

//Stmt2508:Leaf
int is_notdir ;

//Stmt2509:Leaf
char *p ;

 
   {
//Stmt2510:Leaf
list_iterator = *(argv + 0);

//Stmt2511:Leaf
p2 = (char *)0;

//Stmt2512:Leaf
doneany = 0;

//Stmt2513:Leaf
len = 0U;

//Stmt2514:Parent
if ((unsigned long )funcname == (unsigned long )"suffix") {
//Stmt2471:Leaf
tmp___0 = 1;

   } else
   {
//Stmt2472:Parent
if ((int const   )*funcname == (int const   )*"suffix") {
//Stmt2469:Parent
if ((int const   )*funcname == 0) {
//Stmt2466:Leaf
tmp___0 = 1;

     } else {
//Stmt2467:Leaf
tmp = strcmp(funcname + 1, "suffix" + 1);

//Stmt2468:Parent
if (tmp) {
//Stmt2464:Leaf
tmp___0 = 0;

       } else {
//Stmt2465:Leaf
tmp___0 = 1;

       }

     }

   } else {
//Stmt2470:Leaf
tmp___0 = 0;

   }
}


//Stmt2515:Leaf
is_suffix = tmp___0;

//Stmt2516:Leaf
is_notdir = ! is_suffix;

//Stmt2517:Parent
while (1) {
//Stmt2494:Leaf
p2 = find_next_token(& list_iterator, & len);

//Stmt2495:Parent
if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
//Stmt2473:Leaf
break;

     }

//Stmt2496:Leaf
p = p2 + len;

//Stmt2497:Parent
while (1) {
//Stmt2479:Parent
if ((unsigned long )p >= (unsigned long )p2) {
//Stmt2476:Parent
if (! (! is_suffix)) {
//Stmt2475:Parent
if (! ((int )*p != 46)) {
//Stmt2474:Leaf
break;

           }

         }

       } else {
//Stmt2477:Leaf
break;

       }

//Stmt2480:Parent
if ((int )*p == 47) {
//Stmt2478:Leaf
break;

       }

//Stmt2481:Leaf
p --;

     }

//Stmt2498:Parent
if ((unsigned long )p >= (unsigned long )p2) {
//Stmt2486:Parent
if (is_notdir) {
//Stmt2483:Leaf
p ++;

       } else
       {
//Stmt2484:Parent
if ((int )*p != 46) {
//Stmt2482:Leaf
continue;

       }
}


//Stmt2487:Leaf
o = variable_buffer_output(o, p, (unsigned int )((long )len - (p - p2)));

     } else
     {
//Stmt2488:Parent
if (is_notdir) {
//Stmt2485:Leaf
o = variable_buffer_output(o, p2, len);

     }
}


//Stmt2499:Parent
if (is_notdir) {
//Stmt2491:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2492:Leaf
doneany = 1;

     } else
     {
//Stmt2493:Parent
if ((unsigned long )p >= (unsigned long )p2) {
//Stmt2489:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2490:Leaf
doneany = 1;

     }
}


   }

//Stmt2518:Parent
if (doneany) {
//Stmt2500:Leaf
o --;

   }

//Stmt2519:Leaf
return (o);

 }
}
 static char *func_basename_dir(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2557:Leaf
char *p3 ;

//Stmt2558:Leaf
char *p2 ;

//Stmt2559:Leaf
int doneany ;

//Stmt2560:Leaf
unsigned int len ;

//Stmt2561:Leaf
char *p ;

//Stmt2562:Leaf
int is_basename ;

//Stmt2563:Leaf
int tmp ;

//Stmt2564:Leaf
int tmp___0 ;

//Stmt2565:Leaf
int is_dir ;

 
   {
//Stmt2566:Leaf
p3 = *(argv + 0);

//Stmt2567:Leaf
p2 = (char *)0;

//Stmt2568:Leaf
doneany = 0;

//Stmt2569:Leaf
len = 0U;

//Stmt2570:Leaf
p = (char *)0;

//Stmt2571:Parent
if ((unsigned long )funcname == (unsigned long )"basename") {
//Stmt2527:Leaf
tmp___0 = 1;

   } else
   {
//Stmt2528:Parent
if ((int const   )*funcname == (int const   )*"basename") {
//Stmt2525:Parent
if ((int const   )*funcname == 0) {
//Stmt2522:Leaf
tmp___0 = 1;

     } else {
//Stmt2523:Leaf
tmp = strcmp(funcname + 1, "basename" + 1);

//Stmt2524:Parent
if (tmp) {
//Stmt2520:Leaf
tmp___0 = 0;

       } else {
//Stmt2521:Leaf
tmp___0 = 1;

       }

     }

   } else {
//Stmt2526:Leaf
tmp___0 = 0;

   }
}


//Stmt2572:Leaf
is_basename = tmp___0;

//Stmt2573:Leaf
is_dir = ! is_basename;

//Stmt2574:Parent
while (1) {
//Stmt2549:Leaf
p2 = find_next_token(& p3, & len);

//Stmt2550:Parent
if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
//Stmt2529:Leaf
break;

     }

//Stmt2551:Leaf
p = p2 + len;

//Stmt2552:Parent
while (1) {
//Stmt2535:Parent
if ((unsigned long )p >= (unsigned long )p2) {
//Stmt2532:Parent
if (! (! is_basename)) {
//Stmt2531:Parent
if (! ((int )*p != 46)) {
//Stmt2530:Leaf
break;

           }

         }

       } else {
//Stmt2533:Leaf
break;

       }

//Stmt2536:Parent
if ((int )*p == 47) {
//Stmt2534:Leaf
break;

       }

//Stmt2537:Leaf
p --;

     }

//Stmt2553:Parent
if ((unsigned long )p >= (unsigned long )p2) {
//Stmt2548:Parent
if (is_dir) {
//Stmt2538:Leaf
p ++;

//Stmt2539:Leaf
o = variable_buffer_output(o, p2, (unsigned int )(p - p2));

       } else {
//Stmt2540:Leaf
goto _L___0;

       }

     } else
     _L___0: /* CIL Label */ 
     {
//Stmt2547:Parent
if ((unsigned long )p >= (unsigned long )p2) {
//Stmt2546:Parent
if ((int )*p == 46) {
//Stmt2541:Leaf
o = variable_buffer_output(o, p2, (unsigned int )(p - p2));

       } else {
//Stmt2542:Leaf
goto _L;

       }

     } else
     _L: /* CIL Label */ 
     {
//Stmt2545:Parent
if (is_dir) {
//Stmt2543:Leaf
o = variable_buffer_output(o, (char *)"./", 2U);

     } else {
//Stmt2544:Leaf
o = variable_buffer_output(o, p2, len);

     }
}

}


//Stmt2554:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2555:Leaf
doneany = 1;

   }

//Stmt2575:Parent
if (doneany) {
//Stmt2556:Leaf
o --;

   }

//Stmt2576:Leaf
return (o);

 }
}
 static char *func_addsuffix_addprefix(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2597:Leaf
int fixlen ;

//Stmt2598:Leaf
size_t tmp ;

//Stmt2599:Leaf
char *list_iterator ;

//Stmt2600:Leaf
int is_addprefix ;

//Stmt2601:Leaf
int tmp___0 ;

//Stmt2602:Leaf
int tmp___1 ;

//Stmt2603:Leaf
int is_addsuffix ;

//Stmt2604:Leaf
int doneany ;

//Stmt2605:Leaf
char *p ;

//Stmt2606:Leaf
unsigned int len ;

 
   {
//Stmt2607:Leaf
tmp = strlen((char const   *)*(argv + 0));

//Stmt2608:Leaf
fixlen = (int )tmp;

//Stmt2609:Leaf
list_iterator = *(argv + 1);

//Stmt2610:Parent
if ((unsigned long )funcname == (unsigned long )"addprefix") {
//Stmt2584:Leaf
tmp___1 = 1;

   } else
   {
//Stmt2585:Parent
if ((int const   )*funcname == (int const   )*"addprefix") {
//Stmt2582:Parent
if ((int const   )*funcname == 0) {
//Stmt2579:Leaf
tmp___1 = 1;

     } else {
//Stmt2580:Leaf
tmp___0 = strcmp(funcname + 1, "addprefix" + 1);

//Stmt2581:Parent
if (tmp___0) {
//Stmt2577:Leaf
tmp___1 = 0;

       } else {
//Stmt2578:Leaf
tmp___1 = 1;

       }

     }

   } else {
//Stmt2583:Leaf
tmp___1 = 0;

   }
}


//Stmt2611:Leaf
is_addprefix = tmp___1;

//Stmt2612:Leaf
is_addsuffix = ! is_addprefix;

//Stmt2613:Leaf
doneany = 0;

//Stmt2614:Parent
while (1) {
//Stmt2589:Leaf
p = find_next_token(& list_iterator, & len);

//Stmt2590:Parent
if (! ((unsigned long )p != (unsigned long )((char *)0))) {
//Stmt2586:Leaf
break;

     }

//Stmt2591:Parent
if (is_addprefix) {
//Stmt2587:Leaf
o = variable_buffer_output(o, *(argv + 0), (unsigned int )fixlen);

     }

//Stmt2592:Leaf
o = variable_buffer_output(o, p, len);

//Stmt2593:Parent
if (is_addsuffix) {
//Stmt2588:Leaf
o = variable_buffer_output(o, *(argv + 0), (unsigned int )fixlen);

     }

//Stmt2594:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2595:Leaf
doneany = 1;

   }

//Stmt2615:Parent
if (doneany) {
//Stmt2596:Leaf
o --;

   }

//Stmt2616:Leaf
return (o);

 }
}
 static char *func_subst(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2617:Leaf
size_t tmp ;

//Stmt2618:Leaf
size_t tmp___0 ;

 
   {
//Stmt2619:Leaf
tmp = strlen((char const   *)*(argv + 1));

//Stmt2620:Leaf
tmp___0 = strlen((char const   *)*(argv + 0));

//Stmt2621:Leaf
o = subst_expand(o, *(argv + 2), *(argv + 0), *(argv + 1), (unsigned int )tmp___0,
                    (unsigned int )tmp, 0, 0);

//Stmt2622:Leaf
return (o);

 }
}
 static char *func_firstword(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2624:Leaf
unsigned int i ;

//Stmt2625:Leaf
char *words ;

//Stmt2626:Leaf
char *p ;

//Stmt2627:Leaf
char *tmp ;

 
   {
//Stmt2628:Leaf
words = *(argv + 0);

//Stmt2629:Leaf
tmp = find_next_token(& words, & i);

//Stmt2630:Leaf
p = tmp;

//Stmt2631:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt2623:Leaf
o = variable_buffer_output(o, p, i);

   }

//Stmt2632:Leaf
return (o);

 }
}
 static char *func_words(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2637:Leaf
int i ;

//Stmt2638:Leaf
char *word_iterator ;

//Stmt2639:Leaf
char buf___1[20] ;

//Stmt2640:Leaf
char *tmp ;

//Stmt2641:Leaf
size_t tmp___0 ;

 
   {
//Stmt2642:Leaf
i = 0;

//Stmt2643:Leaf
word_iterator = *(argv + 0);

//Stmt2644:Parent
while (1) {
//Stmt2634:Leaf
tmp = find_next_token(& word_iterator, (unsigned int *)0);

//Stmt2635:Parent
if (! ((unsigned long )tmp != (unsigned long )((char *)0))) {
//Stmt2633:Leaf
break;

     }

//Stmt2636:Leaf
i ++;

   }

//Stmt2645:Leaf
sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%d", i);

//Stmt2646:Leaf
tmp___0 = strlen((char const   *)(buf___1));

//Stmt2647:Leaf
o = variable_buffer_output(o, buf___1, (unsigned int )tmp___0);

//Stmt2648:Leaf
return (o);

 }
}
 char *strip_whitespace(char **begpp , char **endpp ) 
 { 
//Stmt2661:Leaf
unsigned short const   **tmp ;

//Stmt2662:Leaf
unsigned short const   **tmp___0 ;

 
   {
//Stmt2663:Parent
while (1) {
//Stmt2652:Leaf
tmp = __ctype_b_loc();

//Stmt2653:Parent
if ((int const   )*(*tmp + (int )((unsigned char )*(*begpp))) & 8192) {
//Stmt2650:Parent
if (! ((unsigned long )*begpp <= (unsigned long )*endpp)) {
//Stmt2649:Leaf
break;

       }

     } else {
//Stmt2651:Leaf
break;

     }

//Stmt2654:Leaf
(*begpp) ++;

   }

//Stmt2664:Parent
while (1) {
//Stmt2658:Leaf
tmp___0 = __ctype_b_loc();

//Stmt2659:Parent
if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*endpp))) & 8192) {
//Stmt2656:Parent
if (! ((unsigned long )*endpp >= (unsigned long )*begpp)) {
//Stmt2655:Leaf
break;

       }

     } else {
//Stmt2657:Leaf
break;

     }

//Stmt2660:Leaf
(*endpp) --;

   }

//Stmt2665:Leaf
return (*begpp);

 }
}
 int is_numeric(char *p ) 
 { 
//Stmt2670:Leaf
char *end ;

//Stmt2671:Leaf
size_t tmp ;

//Stmt2672:Leaf
char *beg ;

//Stmt2673:Leaf
char *tmp___0 ;

 
   {
//Stmt2674:Leaf
tmp = strlen((char const   *)p);

//Stmt2675:Leaf
end = (p + tmp) - 1;

//Stmt2676:Leaf
beg = p;

//Stmt2677:Leaf
strip_whitespace(& p, & end);

//Stmt2678:Parent
while ((unsigned long )p <= (unsigned long )end) {
//Stmt2667:Leaf
tmp___0 = p;

//Stmt2668:Leaf
p ++;

//Stmt2669:Parent
if (! ((unsigned int )*tmp___0 - 48U <= 9U)) {
//Stmt2666:Leaf
return (0);

     }

   }

//Stmt2679:Leaf
return (end - beg >= 0L);

 }
}
 void check_numeric(char *s , char *message___0 ) 
 { 
//Stmt2681:Leaf
int tmp ;

 
   {
//Stmt2682:Leaf
tmp = is_numeric(s);

//Stmt2683:Parent
if (! tmp) {
//Stmt2680:Leaf
fatal(reading_file, (char const   *)message___0);

   }

//Stmt2684:Leaf
return;

 }
}
 static char *func_word(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2694:Leaf
char *end_p ;

//Stmt2695:Leaf
int i ;

//Stmt2696:Leaf
char *p ;

//Stmt2697:Leaf
char *tmp ;

//Stmt2698:Leaf
char *tmp___0 ;

 
   {
//Stmt2699:Leaf
end_p = (char *)0;

//Stmt2700:Leaf
i = 0;

//Stmt2701:Leaf
p = (char *)0;

//Stmt2702:Leaf
tmp = dcgettext((char const   *)((void *)0), "non-numeric first argument to `word\' function",
                   5);

//Stmt2703:Leaf
check_numeric(*(argv + 0), tmp);

//Stmt2704:Leaf
i = atoi((char const   *)*(argv + 0));

//Stmt2705:Parent
if (i == 0) {
//Stmt2685:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "the `word\' function takes a positive index argument",
                         5);

//Stmt2686:Leaf
fatal(reading_file, (char const   *)tmp___0);

   }

//Stmt2706:Leaf
end_p = *(argv + 1);

//Stmt2707:Parent
while (1) {
//Stmt2689:Leaf
p = find_next_token(& end_p, (unsigned int *)0);

//Stmt2690:Parent
if (! ((unsigned long )p != (unsigned long )((char *)0))) {
//Stmt2687:Leaf
break;

     }

//Stmt2691:Leaf
i --;

//Stmt2692:Parent
if (i == 0) {
//Stmt2688:Leaf
break;

     }

   }

//Stmt2708:Parent
if (i == 0) {
//Stmt2693:Leaf
o = variable_buffer_output(o, p, (unsigned int )(end_p - p));

   }

//Stmt2709:Leaf
return (o);

 }
}
 static char *func_wordlist(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2727:Leaf
int start ;

//Stmt2728:Leaf
int count ;

//Stmt2729:Leaf
char *tmp ;

//Stmt2730:Leaf
char *tmp___0 ;

//Stmt2731:Leaf
int tmp___1 ;

//Stmt2732:Leaf
char *p ;

//Stmt2733:Leaf
char *end_p ;

//Stmt2734:Leaf
char *tmp___2 ;

 
   {
//Stmt2735:Leaf
tmp = dcgettext((char const   *)((void *)0), "non-numeric first argument to `wordlist\' function",
                   5);

//Stmt2736:Leaf
check_numeric(*(argv + 0), tmp);

//Stmt2737:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "non-numeric second argument to `wordlist\' function",
                       5);

//Stmt2738:Leaf
check_numeric(*(argv + 1), tmp___0);

//Stmt2739:Leaf
start = atoi((char const   *)*(argv + 0));

//Stmt2740:Leaf
tmp___1 = atoi((char const   *)*(argv + 1));

//Stmt2741:Leaf
count = (tmp___1 - start) + 1;

//Stmt2742:Parent
if (count > 0) {
//Stmt2724:Leaf
end_p = *(argv + 2);

//Stmt2725:Parent
while (1) {
//Stmt2714:Leaf
p = find_next_token(& end_p, (unsigned int *)0);

//Stmt2715:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt2711:Leaf
start --;

//Stmt2712:Parent
if (! start) {
//Stmt2710:Leaf
break;

         }

       } else {
//Stmt2713:Leaf
break;

       }

     }

//Stmt2726:Parent
if (p) {
//Stmt2722:Parent
while (1) {
//Stmt2720:Leaf
count --;

//Stmt2721:Parent
if (count) {
//Stmt2717:Leaf
tmp___2 = find_next_token(& end_p, (unsigned int *)0);

//Stmt2718:Parent
if (! ((unsigned long )tmp___2 != (unsigned long )((char *)0))) {
//Stmt2716:Leaf
break;

           }

         } else {
//Stmt2719:Leaf
break;

         }

       }

//Stmt2723:Leaf
o = variable_buffer_output(o, p, (unsigned int )(end_p - p));

     }

   }

//Stmt2743:Leaf
return (o);

 }
}
 static char *func_findstring(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2745:Leaf
int i ;

//Stmt2746:Leaf
size_t tmp ;

//Stmt2747:Leaf
char *tmp___0 ;

 
   {
//Stmt2748:Leaf
tmp = strlen((char const   *)*(argv + 0));

//Stmt2749:Leaf
i = (int )tmp;

//Stmt2750:Leaf
tmp___0 = sindex((char const   *)*(argv + 1), 0U, (char const   *)*(argv + 0), (unsigned int )i);

//Stmt2751:Parent
if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
//Stmt2744:Leaf
o = variable_buffer_output(o, *(argv + 0), (unsigned int )i);

   }

//Stmt2752:Leaf
return (o);

 }
}
 static char *func_foreach(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2770:Leaf
char *varname ;

//Stmt2771:Leaf
char *tmp ;

//Stmt2772:Leaf
char *list ;

//Stmt2773:Leaf
char *tmp___0 ;

//Stmt2774:Leaf
char *body ;

//Stmt2775:Leaf
int doneany ;

//Stmt2776:Leaf
char *list_iterator ;

//Stmt2777:Leaf
char *p ;

//Stmt2778:Leaf
unsigned int len ;

//Stmt2779:Leaf
register struct variable *var ;

//Stmt2780:Leaf
size_t tmp___1 ;

//Stmt2781:Leaf
char *result___0 ;

//Stmt2782:Leaf
char save ;

//Stmt2783:Leaf
char *tmp___2 ;

//Stmt2784:Leaf
size_t tmp___3 ;

 
   {
//Stmt2785:Leaf
tmp = expand_argument(*(argv + 0), (char *)((void *)0));

//Stmt2786:Leaf
varname = tmp;

//Stmt2787:Leaf
tmp___0 = expand_argument(*(argv + 1), (char *)((void *)0));

//Stmt2788:Leaf
list = tmp___0;

//Stmt2789:Leaf
body = *(argv + 2);

//Stmt2790:Leaf
doneany = 0;

//Stmt2791:Leaf
list_iterator = list;

//Stmt2792:Leaf
push_new_variable_scope();

//Stmt2793:Leaf
tmp___1 = strlen((char const   *)varname);

//Stmt2794:Leaf
var = define_variable_in_set(varname, (unsigned int )tmp___1, (char *)"", (enum variable_origin )6,
                                0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt2795:Parent
while (1) {
//Stmt2754:Leaf
p = find_next_token(& list_iterator, & len);

//Stmt2755:Parent
if (! ((unsigned long )p != (unsigned long )((char *)0))) {
//Stmt2753:Leaf
break;

     }

//Stmt2756:Leaf
result___0 = (char *)0;

//Stmt2757:Leaf
save = *(p + len);

//Stmt2758:Leaf
*(p + len) = (char )'\000';

//Stmt2759:Leaf
free((void *)var->value);

//Stmt2760:Leaf
tmp___2 = xstrdup((char const   *)p);

//Stmt2761:Leaf
var->value = tmp___2;

//Stmt2762:Leaf
*(p + len) = save;

//Stmt2763:Leaf
result___0 = allocated_variable_expand_for_file(body, (struct file *)0);

//Stmt2764:Leaf
tmp___3 = strlen((char const   *)result___0);

//Stmt2765:Leaf
o = variable_buffer_output(o, result___0, (unsigned int )tmp___3);

//Stmt2766:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2767:Leaf
doneany = 1;

//Stmt2768:Leaf
free((void *)result___0);

   }

//Stmt2796:Parent
if (doneany) {
//Stmt2769:Leaf
o --;

   }

//Stmt2797:Leaf
pop_variable_scope();

//Stmt2798:Leaf
free((void *)varname);

//Stmt2799:Leaf
free((void *)list);

//Stmt2800:Leaf
return (o);

 }
}
 static char *func_filter_filterout(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2866:Leaf
struct a_word *wordhead ;

//Stmt2867:Leaf
struct a_word *wordtail ;

//Stmt2868:Leaf
int is_filter ;

//Stmt2869:Leaf
int tmp ;

//Stmt2870:Leaf
int tmp___0 ;

//Stmt2871:Leaf
char *patterns ;

//Stmt2872:Leaf
char *word_iterator ;

//Stmt2873:Leaf
char *p ;

//Stmt2874:Leaf
unsigned int len ;

//Stmt2875:Leaf
struct a_word *w ;

//Stmt2876:Leaf
void *tmp___1 ;

//Stmt2877:Leaf
char *pat_iterator ;

//Stmt2878:Leaf
int doneany ;

//Stmt2879:Leaf
struct a_word *wp ;

//Stmt2880:Leaf
char *percent ;

//Stmt2881:Leaf
char save ;

//Stmt2882:Leaf
int tmp___2 ;

//Stmt2883:Leaf
int tmp___3 ;

//Stmt2884:Leaf
int tmp___4 ;

//Stmt2885:Leaf
int tmp___5 ;

//Stmt2886:Leaf
size_t tmp___6 ;

//Stmt2887:Leaf
int tmp___7 ;

 
   {
//Stmt2888:Leaf
wordhead = (struct a_word *)0;

//Stmt2889:Leaf
wordtail = (struct a_word *)0;

//Stmt2890:Parent
if ((unsigned long )funcname == (unsigned long )"filter") {
//Stmt2808:Leaf
tmp___0 = 1;

   } else
   {
//Stmt2809:Parent
if ((int const   )*funcname == (int const   )*"filter") {
//Stmt2806:Parent
if ((int const   )*funcname == 0) {
//Stmt2803:Leaf
tmp___0 = 1;

     } else {
//Stmt2804:Leaf
tmp = strcmp(funcname + 1, "filter" + 1);

//Stmt2805:Parent
if (tmp) {
//Stmt2801:Leaf
tmp___0 = 0;

       } else {
//Stmt2802:Leaf
tmp___0 = 1;

       }

     }

   } else {
//Stmt2807:Leaf
tmp___0 = 0;

   }
}


//Stmt2891:Leaf
is_filter = tmp___0;

//Stmt2892:Leaf
patterns = *(argv + 0);

//Stmt2893:Leaf
word_iterator = *(argv + 1);

//Stmt2894:Parent
while (1) {
//Stmt2814:Leaf
p = find_next_token(& word_iterator, & len);

//Stmt2815:Parent
if (! ((unsigned long )p != (unsigned long )((char *)0))) {
//Stmt2810:Leaf
break;

     }

//Stmt2816:Leaf
tmp___1 = __builtin_alloca(sizeof(struct a_word ));

//Stmt2817:Leaf
w = (struct a_word *)tmp___1;

//Stmt2818:Parent
if ((unsigned long )wordhead == (unsigned long )((struct a_word *)0)) {
//Stmt2811:Leaf
wordhead = w;

     } else {
//Stmt2812:Leaf
wordtail->next = w;

     }

//Stmt2819:Leaf
wordtail = w;

//Stmt2820:Parent
if ((int )*word_iterator != 0) {
//Stmt2813:Leaf
word_iterator ++;

     }

//Stmt2821:Leaf
*(p + len) = (char )'\000';

//Stmt2822:Leaf
w->str = p;

//Stmt2823:Leaf
w->matched = 0;

   }

//Stmt2895:Parent
if ((unsigned long )wordhead != (unsigned long )((struct a_word *)0)) {
//Stmt2859:Leaf
pat_iterator = patterns;

//Stmt2860:Leaf
doneany = 0;

//Stmt2861:Leaf
wordtail->next = (struct a_word *)0;

//Stmt2862:Parent
while (1) {
//Stmt2841:Leaf
p = find_next_token(& pat_iterator, & len);

//Stmt2842:Parent
if (! ((unsigned long )p != (unsigned long )((char *)0))) {
//Stmt2824:Leaf
break;

       }

//Stmt2843:Leaf
save = *(p + len);

//Stmt2844:Leaf
*(p + len) = (char )'\000';

//Stmt2845:Leaf
percent = find_percent(p);

//Stmt2846:Leaf
wp = wordhead;

//Stmt2847:Parent
while ((unsigned long )wp != (unsigned long )((struct a_word *)0)) {
//Stmt2838:Parent
if ((unsigned long )percent == (unsigned long )((char *)0)) {
//Stmt2834:Parent
if ((unsigned long )p == (unsigned long )wp->str) {
//Stmt2832:Leaf
tmp___3 = 1;

           } else
           {
//Stmt2833:Parent
if ((int )*p == (int )*(wp->str)) {
//Stmt2830:Parent
if ((int )*p == 0) {
//Stmt2827:Leaf
tmp___3 = 1;

             } else {
//Stmt2828:Leaf
tmp___2 = strcmp((char const   *)(p + 1), (char const   *)(wp->str + 1));

//Stmt2829:Parent
if (tmp___2) {
//Stmt2825:Leaf
tmp___3 = 0;

               } else {
//Stmt2826:Leaf
tmp___3 = 1;

               }

             }

           } else {
//Stmt2831:Leaf
tmp___3 = 0;

           }
}


//Stmt2835:Leaf
tmp___5 = tmp___3;

         } else {
//Stmt2836:Leaf
tmp___4 = pattern_matches(p, percent, wp->str);

//Stmt2837:Leaf
tmp___5 = tmp___4;

         }

//Stmt2839:Leaf
wp->matched |= tmp___5;

//Stmt2840:Leaf
wp = wp->next;

       }

//Stmt2848:Leaf
*(p + len) = save;

     }

//Stmt2863:Leaf
wp = wordhead;

//Stmt2864:Parent
while ((unsigned long )wp != (unsigned long )((struct a_word *)0)) {
//Stmt2855:Parent
if (is_filter) {
//Stmt2849:Leaf
tmp___7 = wp->matched;

       } else {
//Stmt2850:Leaf
tmp___7 = ! wp->matched;

       }

//Stmt2856:Parent
if (tmp___7) {
//Stmt2851:Leaf
tmp___6 = strlen((char const   *)wp->str);

//Stmt2852:Leaf
o = variable_buffer_output(o, wp->str, (unsigned int )tmp___6);

//Stmt2853:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2854:Leaf
doneany = 1;

       }

//Stmt2857:Leaf
wp = wp->next;

     }

//Stmt2865:Parent
if (doneany) {
//Stmt2858:Leaf
o --;

     }

   }

//Stmt2896:Leaf
return (o);

 }
}
 static char *func_strip(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2920:Leaf
char *p ;

//Stmt2921:Leaf
int doneany ;

//Stmt2922:Leaf
int i ;

//Stmt2923:Leaf
char *word_start ;

//Stmt2924:Leaf
unsigned short const   **tmp ;

//Stmt2925:Leaf
unsigned short const   **tmp___0 ;

 
   {
//Stmt2926:Leaf
p = *(argv + 0);

//Stmt2927:Leaf
doneany = 0;

//Stmt2928:Parent
while ((int )*p != 0) {
//Stmt2909:Leaf
i = 0;

//Stmt2910:Leaf
word_start = (char *)0;

//Stmt2911:Parent
while (1) {
//Stmt2898:Leaf
tmp = __ctype_b_loc();

//Stmt2899:Parent
if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
//Stmt2897:Leaf
break;

       }

//Stmt2900:Leaf
p ++;

     }

//Stmt2912:Leaf
word_start = p;

//Stmt2913:Leaf
i = 0;

//Stmt2914:Parent
while (1) {
//Stmt2905:Parent
if ((int )*p != 0) {
//Stmt2902:Leaf
tmp___0 = __ctype_b_loc();

//Stmt2903:Parent
if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 8192) {
//Stmt2901:Leaf
break;

         }

       } else {
//Stmt2904:Leaf
break;

       }

//Stmt2906:Leaf
p ++;

//Stmt2907:Leaf
i ++;

     }

//Stmt2915:Parent
if (! i) {
//Stmt2908:Leaf
break;

     }

//Stmt2916:Leaf
o = variable_buffer_output(o, word_start, (unsigned int )i);

//Stmt2917:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

//Stmt2918:Leaf
doneany = 1;

   }

//Stmt2929:Parent
if (doneany) {
//Stmt2919:Leaf
o --;

   }

//Stmt2930:Leaf
return (o);

 }
}
 static char *func_error(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2945:Leaf
char **argvp ;

//Stmt2946:Leaf
char *msg ;

//Stmt2947:Leaf
char *p ;

//Stmt2948:Leaf
int len ;

//Stmt2949:Leaf
size_t tmp ;

//Stmt2950:Leaf
void *tmp___0 ;

//Stmt2951:Leaf
size_t tmp___1 ;

//Stmt2952:Leaf
char *tmp___2 ;

//Stmt2953:Leaf
char *tmp___3 ;

 
   {
//Stmt2954:Leaf
len = 0;

//Stmt2955:Leaf
argvp = argv;

//Stmt2956:Parent
while ((unsigned long )*argvp != (unsigned long )((char *)0)) {
//Stmt2931:Leaf
tmp = strlen((char const   *)*argvp);

//Stmt2932:Leaf
len = (int )((size_t )len + (tmp + 2UL));

//Stmt2933:Leaf
argvp ++;

   }

//Stmt2957:Leaf
tmp___0 = __builtin_alloca((unsigned long )(len + 1));

//Stmt2958:Leaf
msg = (char *)tmp___0;

//Stmt2959:Leaf
p = msg;

//Stmt2960:Leaf
argvp = argv;

//Stmt2961:Parent
while ((unsigned long )*(argvp + 1) != (unsigned long )((char *)0)) {
//Stmt2934:Leaf
strcpy((char * __restrict  )p, (char const   * __restrict  )*argvp);

//Stmt2935:Leaf
tmp___1 = strlen((char const   *)*argvp);

//Stmt2936:Leaf
p += tmp___1;

//Stmt2937:Leaf
tmp___2 = p;

//Stmt2938:Leaf
p ++;

//Stmt2939:Leaf
*tmp___2 = (char )',';

//Stmt2940:Leaf
tmp___3 = p;

//Stmt2941:Leaf
p ++;

//Stmt2942:Leaf
*tmp___3 = (char )' ';

//Stmt2943:Leaf
argvp ++;

   }

//Stmt2962:Leaf
strcpy((char * __restrict  )p, (char const   * __restrict  )*argvp);

//Stmt2963:Parent
if ((int const   )*funcname == 101) {
//Stmt2944:Leaf
fatal(reading_file, "%s", msg);

   }

//Stmt2964:Leaf
error(reading_file, "%s", msg);

//Stmt2965:Leaf
return (o);

 }
}
 static char *func_sort(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt2992:Leaf
char **words ;

//Stmt2993:Leaf
int nwords ;

//Stmt2994:Leaf
register int wordi ;

//Stmt2995:Leaf
char *t ;

//Stmt2996:Leaf
char *p ;

//Stmt2997:Leaf
unsigned int len ;

//Stmt2998:Leaf
int i ;

//Stmt2999:Leaf
char *tmp ;

//Stmt3000:Leaf
int tmp___0 ;

//Stmt3001:Leaf
size_t tmp___1 ;

//Stmt3002:Leaf
size_t tmp___2 ;

//Stmt3003:Leaf
int tmp___3 ;

 
   {
//Stmt3004:Leaf
words = (char **)0;

//Stmt3005:Leaf
nwords = 0;

//Stmt3006:Leaf
wordi = 0;

//Stmt3007:Leaf
t = *(argv + 0);

//Stmt3008:Parent
while (1) {
//Stmt2970:Leaf
p = find_next_token(& t, & len);

//Stmt2971:Parent
if (! ((unsigned long )p != (unsigned long )((char *)0))) {
//Stmt2966:Leaf
break;

     }

//Stmt2972:Parent
if (wordi >= nwords - 1) {
//Stmt2967:Leaf
nwords = 2 * nwords + 5;

//Stmt2968:Leaf
tmp = xrealloc((char *)words, (unsigned int )((unsigned long )nwords * sizeof(char *)));

//Stmt2969:Leaf
words = (char **)tmp;

     }

//Stmt2973:Leaf
tmp___0 = wordi;

//Stmt2974:Leaf
wordi ++;

//Stmt2975:Leaf
*(words + tmp___0) = savestring((char const   *)p, len);

   }

//Stmt3009:Parent
if (! wordi) {
//Stmt2976:Leaf
return (o);

   }

//Stmt3010:Leaf
qsort((void *)((char *)words), (size_t )wordi, sizeof(char *), & alpha_compare);

//Stmt3011:Leaf
i = 0;

//Stmt3012:Parent
while (i < wordi) {
//Stmt2987:Leaf
tmp___1 = strlen((char const   *)*(words + i));

//Stmt2988:Leaf
len = (unsigned int )tmp___1;

//Stmt2989:Parent
if (i == wordi - 1) {
//Stmt2983:Leaf
o = variable_buffer_output(o, *(words + i), len);

//Stmt2984:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

     } else {
//Stmt2985:Leaf
tmp___2 = strlen((char const   *)*(words + (i + 1)));

//Stmt2986:Parent
if (tmp___2 != (size_t )len) {
//Stmt2979:Leaf
o = variable_buffer_output(o, *(words + i), len);

//Stmt2980:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

       } else {
//Stmt2981:Leaf
tmp___3 = strcmp((char const   *)*(words + i), (char const   *)*(words + (i + 1)));

//Stmt2982:Parent
if (tmp___3) {
//Stmt2977:Leaf
o = variable_buffer_output(o, *(words + i), len);

//Stmt2978:Leaf
o = variable_buffer_output(o, (char *)" ", 1U);

         }

       }

     }

//Stmt2990:Leaf
free((void *)*(words + i));

//Stmt2991:Leaf
i ++;

   }

//Stmt3013:Leaf
o --;

//Stmt3014:Leaf
free((void *)words);

//Stmt3015:Leaf
return (o);

 }
}
 static char *func_if(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt3025:Leaf
char *begp ;

//Stmt3026:Leaf
char *endp ;

//Stmt3027:Leaf
size_t tmp ;

//Stmt3028:Leaf
int result___0 ;

//Stmt3029:Leaf
char *expansion ;

//Stmt3030:Leaf
char *tmp___0 ;

//Stmt3031:Leaf
size_t tmp___1 ;

//Stmt3032:Leaf
char *expansion___0 ;

//Stmt3033:Leaf
size_t tmp___2 ;

 
   {
//Stmt3034:Leaf
begp = *(argv + 0);

//Stmt3035:Leaf
tmp = strlen((char const   *)*(argv + 0));

//Stmt3036:Leaf
endp = begp + tmp;

//Stmt3037:Leaf
result___0 = 0;

//Stmt3038:Leaf
strip_whitespace(& begp, & endp);

//Stmt3039:Parent
if ((unsigned long )begp < (unsigned long )endp) {
//Stmt3016:Leaf
tmp___0 = expand_argument(begp, (char *)((void *)0));

//Stmt3017:Leaf
expansion = tmp___0;

//Stmt3018:Leaf
tmp___1 = strlen((char const   *)expansion);

//Stmt3019:Leaf
result___0 = (int )tmp___1;

//Stmt3020:Leaf
free((void *)expansion);

   }

//Stmt3040:Leaf
argv += 1 + ! result___0;

//Stmt3041:Parent
if (*(argv + 0)) {
//Stmt3021:Leaf
expansion___0 = expand_argument(*(argv + 0), (char *)((void *)0));

//Stmt3022:Leaf
tmp___2 = strlen((char const   *)expansion___0);

//Stmt3023:Leaf
o = variable_buffer_output(o, expansion___0, (unsigned int )tmp___2);

//Stmt3024:Leaf
free((void *)expansion___0);

   }

//Stmt3042:Leaf
return (o);

 }
}
 static char *func_wildcard(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt3043:Leaf
char *p ;

//Stmt3044:Leaf
char *tmp ;

//Stmt3045:Leaf
size_t tmp___0 ;

 
   {
//Stmt3046:Leaf
tmp = string_glob(*(argv + 0));

//Stmt3047:Leaf
p = tmp;

//Stmt3048:Leaf
tmp___0 = strlen((char const   *)p);

//Stmt3049:Leaf
o = variable_buffer_output(o, p, (unsigned int )tmp___0);

//Stmt3050:Leaf
return (o);

 }
}
 void fold_newlines(char *buffer , int *length___0 ) 
 { 
//Stmt3063:Leaf
char *dst ;

//Stmt3064:Leaf
char *src ;

//Stmt3065:Leaf
char *last_nonnl ;

//Stmt3066:Leaf
char *tmp ;

//Stmt3067:Leaf
char *tmp___0 ;

 
   {
//Stmt3068:Leaf
dst = buffer;

//Stmt3069:Leaf
src = buffer;

//Stmt3070:Leaf
last_nonnl = buffer - 1;

//Stmt3071:Leaf
*(src + *length___0) = (char)0;

//Stmt3072:Parent
while ((int )*src != 0) {
//Stmt3061:Parent
if ((int )*(src + 0) == 13) {
//Stmt3052:Parent
if ((int )*(src + 1) == 10) {
//Stmt3051:Leaf
goto __Cont;

       }

     }

//Stmt3062:Parent
if ((int )*src == 10) {
//Stmt3053:Leaf
tmp = dst;

//Stmt3054:Leaf
dst ++;

//Stmt3055:Leaf
*tmp = (char )' ';

     } else {
//Stmt3056:Leaf
last_nonnl = dst;

//Stmt3057:Leaf
tmp___0 = dst;

//Stmt3058:Leaf
dst ++;

//Stmt3059:Leaf
*tmp___0 = *src;

     }

     __Cont: /* CIL Label */ 
     {
//Stmt3060:Leaf
src ++;

}
   }

//Stmt3073:Leaf
last_nonnl ++;

//Stmt3074:Leaf
*last_nonnl = (char )'\000';

//Stmt3075:Leaf
*length___0 = (int )(last_nonnl - buffer);

//Stmt3076:Leaf
return;

 }
}
 int shell_function_pid  =    0;
 int shell_function_completed  ;
 static char *func_shell(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt3131:Leaf
char *batch_filename ;

//Stmt3132:Leaf
int i ;

//Stmt3133:Leaf
char **command_argv ;

//Stmt3134:Leaf
char *error_prefix ;

//Stmt3135:Leaf
char **envp ;

//Stmt3136:Leaf
int pipedes[2] ;

//Stmt3137:Leaf
int pid ;

//Stmt3138:Leaf
size_t tmp ;

//Stmt3139:Leaf
void *tmp___0 ;

//Stmt3140:Leaf
int tmp___1 ;

//Stmt3141:Leaf
char *buffer ;

//Stmt3142:Leaf
unsigned int maxlen ;

//Stmt3143:Leaf
int cc ;

//Stmt3144:Leaf
char *tmp___2 ;

//Stmt3145:Leaf
char *tmp___3 ;

//Stmt3146:Leaf
int *tmp___4 ;

//Stmt3147:Leaf
ssize_t tmp___5 ;

//Stmt3148:Leaf
int *tmp___6 ;

//Stmt3149:Leaf
char *tmp___7 ;

 
   {
//Stmt3150:Leaf
batch_filename = (char *)((void *)0);

//Stmt3151:Leaf
command_argv = construct_command_argv(*(argv + 0), (char **)((void *)0), (struct file *)0,
                                         & batch_filename);

//Stmt3152:Parent
if ((unsigned long )command_argv == (unsigned long )((char **)0)) {
//Stmt3077:Leaf
return (o);

   }

//Stmt3153:Leaf
envp = environ;

//Stmt3154:Parent
if ((unsigned long )reading_file != (unsigned long )((struct floc  const  *)0)) {
//Stmt3078:Leaf
tmp = strlen((char const   *)reading_file->filenm);

//Stmt3079:Leaf
tmp___0 = __builtin_alloca((tmp + 11UL) + 4UL);

//Stmt3080:Leaf
error_prefix = (char *)tmp___0;

//Stmt3081:Leaf
sprintf((char * __restrict  )error_prefix, (char const   * __restrict  )"%s:%lu: ",
             reading_file->filenm, reading_file->lineno);

   } else {
//Stmt3082:Leaf
error_prefix = (char *)"";

   }

//Stmt3155:Leaf
tmp___1 = pipe((int *)(pipedes));

//Stmt3156:Parent
if (tmp___1 < 0) {
//Stmt3083:Leaf
perror_with_name(error_prefix, (char *)"pipe");

//Stmt3084:Leaf
return (o);

   }

//Stmt3157:Leaf
pid = vfork();

//Stmt3158:Parent
if (pid < 0) {
//Stmt3129:Leaf
perror_with_name(error_prefix, (char *)"fork");

   } else
   {
//Stmt3130:Parent
if (pid == 0) {
//Stmt3112:Leaf
child_execute_job(0, pipedes[1], command_argv, envp);

   } else {
//Stmt3113:Leaf
shell_function_pid = pid;

//Stmt3114:Leaf
shell_function_completed = 0;

//Stmt3115:Leaf
free((void *)*(command_argv + 0));

//Stmt3116:Leaf
free((void *)((char *)command_argv));

//Stmt3117:Leaf
close(pipedes[1]);

//Stmt3118:Leaf
maxlen = 200U;

//Stmt3119:Leaf
tmp___2 = xmalloc(maxlen + 1U);

//Stmt3120:Leaf
buffer = tmp___2;

//Stmt3121:Leaf
i = 0;

//Stmt3122:Parent
while (1) {
//Stmt3092:Parent
if ((unsigned int )i == maxlen) {
//Stmt3085:Leaf
maxlen += 512U;

//Stmt3086:Leaf
tmp___3 = xrealloc(buffer, maxlen + 1U);

//Stmt3087:Leaf
buffer = tmp___3;

       }

//Stmt3093:Leaf
tmp___4 = __errno_location();

//Stmt3094:Leaf
*tmp___4 = 0;

//Stmt3095:Leaf
tmp___5 = read(pipedes[0], (void *)(buffer + i), (size_t )(maxlen - (unsigned int )i));

//Stmt3096:Leaf
cc = (int )tmp___5;

//Stmt3097:Parent
if (cc > 0) {
//Stmt3088:Leaf
i += cc;

       }

//Stmt3098:Parent
if (! (cc > 0)) {
//Stmt3090:Leaf
tmp___6 = __errno_location();

//Stmt3091:Parent
if (! (*tmp___6 == 4)) {
//Stmt3089:Leaf
break;

         }

       }

     }

//Stmt3123:Leaf
close(pipedes[0]);

//Stmt3124:Parent
while (shell_function_completed == 0) {
//Stmt3099:Leaf
reap_children(1, 0);

     }

//Stmt3125:Parent
if (batch_filename) {
//Stmt3105:Parent
while (1) {
//Stmt3103:Parent
if (2 & db_level) {
//Stmt3100:Leaf
tmp___7 = dcgettext((char const   *)((void *)0), "Cleaning up temporary batch file %s\n",
                               5);

//Stmt3101:Leaf
printf((char const   * __restrict  )tmp___7, batch_filename);

//Stmt3102:Leaf
fflush(stdout);

         }

//Stmt3104:Leaf
break;

       }

//Stmt3106:Leaf
remove((char const   *)batch_filename);

//Stmt3107:Leaf
free((void *)batch_filename);

     }

//Stmt3126:Leaf
shell_function_pid = 0;

//Stmt3127:Parent
if (shell_function_completed == -1) {
//Stmt3108:Leaf
fputs((char const   * __restrict  )buffer, (FILE * __restrict  )stderr);

//Stmt3109:Leaf
fflush(stderr);

     } else {
//Stmt3110:Leaf
fold_newlines(buffer, & i);

//Stmt3111:Leaf
o = variable_buffer_output(o, buffer, (unsigned int )i);

     }

//Stmt3128:Leaf
free((void *)buffer);

   }
}


//Stmt3159:Leaf
return (o);

 }
}
 static char *func_call(char *o , char **argv , char const   *funcname ) ;
 static struct function_table_entry function_table[27]  = 
   {      {"addprefix", (unsigned char )(sizeof("addprefix") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_addsuffix_addprefix}, 
         {"addsuffix", (unsigned char )(sizeof("addsuffix") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_addsuffix_addprefix}, 
         {"basename", (unsigned char )(sizeof("basename") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_basename_dir}, 
         {"dir", (unsigned char )(sizeof("dir") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_basename_dir}, 
         {"notdir", (unsigned char )(sizeof("notdir") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_notdir_suffix}, 
         {"subst", (unsigned char )(sizeof("subst") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)1, & func_subst}, 
         {"suffix", (unsigned char )(sizeof("suffix") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_notdir_suffix}, 
         {"filter", (unsigned char )(sizeof("filter") - 1UL), (unsigned char)2, (unsigned char)2,
       (char)1, & func_filter_filterout}, 
         {"filter-out", (unsigned char )(sizeof("filter-out") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_filter_filterout}, 
         {"findstring", (unsigned char )(sizeof("findstring") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_findstring}, 
         {"firstword", (unsigned char )(sizeof("firstword") - 1UL), (unsigned char)1,
       (unsigned char)1, (char)1, & func_firstword}, 
         {"join", (unsigned char )(sizeof("join") - 1UL), (unsigned char)2, (unsigned char)2,
       (char)1, & func_join}, 
         {"patsubst", (unsigned char )(sizeof("patsubst") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)1, & func_patsubst}, 
         {"shell", (unsigned char )(sizeof("shell") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_shell}, 
         {"sort", (unsigned char )(sizeof("sort") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_sort}, 
         {"strip", (unsigned char )(sizeof("strip") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_strip}, 
         {"wildcard", (unsigned char )(sizeof("wildcard") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_wildcard}, 
         {"word", (unsigned char )(sizeof("word") - 1UL), (unsigned char)2, (unsigned char)2,
       (char)1, & func_word}, 
         {"wordlist", (unsigned char )(sizeof("wordlist") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)1, & func_wordlist}, 
         {"words", (unsigned char )(sizeof("words") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_words}, 
         {"origin", (unsigned char )(sizeof("origin") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_origin}, 
         {"foreach", (unsigned char )(sizeof("foreach") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)0, & func_foreach}, 
         {"call", (unsigned char )(sizeof("call") - 1UL), (unsigned char)1, (unsigned char)0,
       (char)1, & func_call}, 
         {"error", (unsigned char )(sizeof("error") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_error}, 
         {"warning", (unsigned char )(sizeof("warning") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_error}, 
         {"if", (unsigned char )(sizeof("if") - 1UL), (unsigned char)2, (unsigned char)3,
       (char)0, & func_if}, 
         {(char const   *)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (char)0,
       (char *(*)(char *output , char **argv , char const   *fname ))0}};
 static char *expand_builtin_function(char *o , int argc , char **argv , struct function_table_entry *entry_p ) 
 { 
//Stmt3164:Leaf
char *tmp ;

//Stmt3165:Leaf
char *tmp___0 ;

//Stmt3166:Leaf
char *tmp___1 ;

 
   {
//Stmt3167:Parent
if (argc < (int )entry_p->minimum_args) {
//Stmt3160:Leaf
tmp = dcgettext((char const   *)((void *)0), "Insufficient number of arguments (%d) to function `%s\'",
                     5);

//Stmt3161:Leaf
fatal(reading_file, (char const   *)tmp, argc, entry_p->name);

   }

//Stmt3168:Parent
if (! entry_p->func_ptr) {
//Stmt3162:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "Unimplemented on this platform: function `%s\'",
                         5);

//Stmt3163:Leaf
fatal(reading_file, (char const   *)tmp___0, entry_p->name);

   }

//Stmt3169:Leaf
tmp___1 = (*(entry_p->func_ptr))(o, argv, entry_p->name);

//Stmt3170:Leaf
return (tmp___1);

 }
}
 int handle_function(char **op , char **stringp ) 
 { 
//Stmt3208:Leaf
struct function_table_entry  const  *entry_p ;

//Stmt3209:Leaf
char openparen ;

//Stmt3210:Leaf
char closeparen ;

//Stmt3211:Leaf
int tmp ;

//Stmt3212:Leaf
char *beg ;

//Stmt3213:Leaf
char *end ;

//Stmt3214:Leaf
int count ;

//Stmt3215:Leaf
register char *p ;

//Stmt3216:Leaf
char **argv ;

//Stmt3217:Leaf
char **argvp ;

//Stmt3218:Leaf
int nargs ;

//Stmt3219:Leaf
char *tmp___0 ;

//Stmt3220:Leaf
void *tmp___1 ;

//Stmt3221:Leaf
int len ;

//Stmt3222:Leaf
char *next ;

 
   {
//Stmt3223:Leaf
openparen = *(*stringp + 0);

//Stmt3224:Parent
if ((int )openparen == 40) {
//Stmt3171:Leaf
tmp = ')';

   } else {
//Stmt3172:Leaf
tmp = '}';

   }

//Stmt3225:Leaf
closeparen = (char )tmp;

//Stmt3226:Leaf
count = 0;

//Stmt3227:Leaf
beg = *stringp + 1;

//Stmt3228:Leaf
entry_p = lookup_function((struct function_table_entry  const  *)(function_table),
                             (char const   *)beg);

//Stmt3229:Parent
if (! entry_p) {
//Stmt3173:Leaf
return (0);

   }

//Stmt3230:Leaf
beg = next_token(beg + (int const   )entry_p->len);

//Stmt3231:Leaf
nargs = 1;

//Stmt3232:Leaf
end = beg;

//Stmt3233:Parent
while ((int )*end != 0) {
//Stmt3181:Parent
if ((int )*end == 44) {
//Stmt3179:Leaf
nargs ++;

     } else
     {
//Stmt3180:Parent
if ((int )*end == (int )openparen) {
//Stmt3177:Leaf
count ++;

     } else
     {
//Stmt3178:Parent
if ((int )*end == (int )closeparen) {
//Stmt3175:Leaf
count --;

//Stmt3176:Parent
if (count < 0) {
//Stmt3174:Leaf
break;

       }

     }
}

}


//Stmt3182:Leaf
end ++;

   }

//Stmt3234:Parent
if (count >= 0) {
//Stmt3183:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "unterminated call to function `%s\': missing `%c\'",
                         5);

//Stmt3184:Leaf
fatal(reading_file, (char const   *)tmp___0, entry_p->name, (int )closeparen);

   }

//Stmt3235:Leaf
*stringp = end;

//Stmt3236:Leaf
tmp___1 = __builtin_alloca(sizeof(char *) * (unsigned long )(nargs + 2));

//Stmt3237:Leaf
argv = (char **)tmp___1;

//Stmt3238:Leaf
argvp = argv;

//Stmt3239:Parent
if (! entry_p->expand_args) {
//Stmt3185:Leaf
len = (int )(end - beg);

//Stmt3186:Leaf
p = xmalloc((unsigned int )(len + 1));

//Stmt3187:Leaf
memcpy((void * __restrict  )p, (void const   * __restrict  )beg, (size_t )len);

//Stmt3188:Leaf
*(p + len) = (char )'\000';

//Stmt3189:Leaf
beg = p;

//Stmt3190:Leaf
end = beg + len;

   }

//Stmt3240:Leaf
p = beg;

//Stmt3241:Leaf
nargs = 0;

//Stmt3242:Leaf
p = beg;

//Stmt3243:Leaf
nargs = 0;

//Stmt3244:Parent
while ((unsigned long )p < (unsigned long )end) {
//Stmt3198:Leaf
nargs ++;

//Stmt3199:Parent
if (nargs == (int )entry_p->maximum_args) {
//Stmt3192:Leaf
next = end;

     } else {
//Stmt3193:Leaf
next = find_next_argument(openparen, closeparen, (char const   *)p, (char const   *)end);

//Stmt3194:Parent
if (! next) {
//Stmt3191:Leaf
next = end;

       }

     }

//Stmt3200:Parent
if (entry_p->expand_args) {
//Stmt3195:Leaf
*argvp = expand_argument(p, next);

     } else {
//Stmt3196:Leaf
*argvp = p;

//Stmt3197:Leaf
*next = (char )'\000';

     }

//Stmt3201:Leaf
p = next + 1;

//Stmt3202:Leaf
argvp ++;

   }

//Stmt3245:Leaf
*argvp = (char *)((void *)0);

//Stmt3246:Leaf
*op = expand_builtin_function(*op, nargs, argv, (struct function_table_entry *)entry_p);

//Stmt3247:Parent
if (entry_p->expand_args) {
//Stmt3205:Leaf
argvp = argv;

//Stmt3206:Parent
while ((unsigned long )*argvp != (unsigned long )((char *)0)) {
//Stmt3203:Leaf
free((void *)*argvp);

//Stmt3204:Leaf
argvp ++;

     }

   } else {
//Stmt3207:Leaf
free((void *)beg);

   }

//Stmt3248:Leaf
return (1);

 }
}
 static char *func_call(char *o , char **argv , char const   *funcname ) 
 { 
//Stmt3272:Leaf
char *fname ;

//Stmt3273:Leaf
char *cp ;

//Stmt3274:Leaf
int flen ;

//Stmt3275:Leaf
char *body ;

//Stmt3276:Leaf
int i ;

//Stmt3277:Leaf
struct function_table_entry  const  *entry_p ;

//Stmt3278:Leaf
unsigned short const   **tmp ;

//Stmt3279:Leaf
size_t tmp___0 ;

//Stmt3280:Leaf
unsigned short const   **tmp___1 ;

//Stmt3281:Leaf
char *tmp___2 ;

//Stmt3282:Leaf
size_t tmp___3 ;

//Stmt3283:Leaf
void *tmp___4 ;

//Stmt3284:Leaf
char num[11] ;

//Stmt3285:Leaf
size_t tmp___5 ;

//Stmt3286:Leaf
size_t tmp___6 ;

 
   {
//Stmt3287:Leaf
fname = *(argv + 0);

//Stmt3288:Parent
while (1) {
//Stmt3253:Parent
if ((int )*fname != 0) {
//Stmt3250:Leaf
tmp = __ctype_b_loc();

//Stmt3251:Parent
if (! ((int const   )*(*tmp + (int )((unsigned char )*fname)) & 8192)) {
//Stmt3249:Leaf
break;

       }

     } else {
//Stmt3252:Leaf
break;

     }

//Stmt3254:Leaf
fname ++;

   }

//Stmt3289:Leaf
tmp___0 = strlen((char const   *)fname);

//Stmt3290:Leaf
cp = (fname + tmp___0) - 1;

//Stmt3291:Parent
while (1) {
//Stmt3259:Parent
if ((unsigned long )cp > (unsigned long )fname) {
//Stmt3256:Leaf
tmp___1 = __ctype_b_loc();

//Stmt3257:Parent
if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*cp)) & 8192)) {
//Stmt3255:Leaf
break;

       }

     } else {
//Stmt3258:Leaf
break;

     }

//Stmt3260:Leaf
cp --;

   }

//Stmt3292:Leaf
*(cp + 1) = (char )'\000';

//Stmt3293:Parent
if ((int )*fname == 0) {
//Stmt3261:Leaf
return (o);

   }

//Stmt3294:Leaf
entry_p = lookup_function((struct function_table_entry  const  *)(function_table),
                             (char const   *)fname);

//Stmt3295:Parent
if (entry_p) {
//Stmt3263:Leaf
i = 0;

//Stmt3264:Parent
while (*(argv + (i + 1))) {
//Stmt3262:Leaf
i ++;

     }

//Stmt3265:Leaf
tmp___2 = expand_builtin_function(o, i, argv + 1, (struct function_table_entry *)entry_p);

//Stmt3266:Leaf
return (tmp___2);

   }

//Stmt3296:Leaf
tmp___3 = strlen((char const   *)fname);

//Stmt3297:Leaf
flen = (int )tmp___3;

//Stmt3298:Leaf
tmp___4 = __builtin_alloca((unsigned long )(flen + 4));

//Stmt3299:Leaf
body = (char *)tmp___4;

//Stmt3300:Leaf
*(body + 0) = (char )'$';

//Stmt3301:Leaf
*(body + 1) = (char )'(';

//Stmt3302:Leaf
memcpy((void * __restrict  )(body + 2), (void const   * __restrict  )fname, (size_t )flen);

//Stmt3303:Leaf
*(body + (flen + 2)) = (char )')';

//Stmt3304:Leaf
*(body + (flen + 3)) = (char )'\000';

//Stmt3305:Leaf
push_new_variable_scope();

//Stmt3306:Leaf
i = 0;

//Stmt3307:Parent
while (*argv) {
//Stmt3267:Leaf
sprintf((char * __restrict  )(num), (char const   * __restrict  )"%d", i);

//Stmt3268:Leaf
tmp___5 = strlen((char const   *)(num));

//Stmt3269:Leaf
define_variable_in_set(num, (unsigned int )tmp___5, *argv, (enum variable_origin )6,
                            1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt3270:Leaf
i ++;

//Stmt3271:Leaf
argv ++;

   }

//Stmt3308:Leaf
o = variable_expand_string(o, body, (long )(flen + 3));

//Stmt3309:Leaf
pop_variable_scope();

//Stmt3310:Leaf
tmp___6 = strlen((char const   *)o);

//Stmt3311:Leaf
return (o + tmp___6);

 }
}
 #pragma merger("0","/tmp/cil-DQjlIciI.i","-g,-O0")
 #pragma merger("0","/tmp/cil-ElSTEfZg.i","-g,-O0")
 void print_spaces(unsigned int n ) ;
 int vpath_search(char **file , uintmax_t *mtime_ptr ) ;
 struct rule *pattern_rules ;
 unsigned int num_pattern_rules ;
 unsigned int max_pattern_deps ;
 unsigned int max_pattern_targets ;
 unsigned int max_pattern_dep_length ;
 static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) ;
 int try_implicit_rule(struct file *file , unsigned int depth ) 
 { 
//Stmt3329:Leaf
char *tmp ;

//Stmt3330:Leaf
int tmp___0 ;

//Stmt3331:Leaf
char *tmp___1 ;

//Stmt3332:Leaf
int tmp___2 ;

//Stmt3333:Leaf
int tmp___3 ;

 
   {
//Stmt3334:Parent
while (1) {
//Stmt3316:Parent
if (8 & db_level) {
//Stmt3312:Leaf
print_spaces(depth);

//Stmt3313:Leaf
tmp = dcgettext((char const   *)((void *)0), "Looking for an implicit rule for `%s\'.\n",
                       5);

//Stmt3314:Leaf
printf((char const   * __restrict  )tmp, file->name);

//Stmt3315:Leaf
fflush(stdout);

     }

//Stmt3317:Leaf
break;

   }

//Stmt3335:Leaf
tmp___0 = pattern_search(file, 0, depth, 0U);

//Stmt3336:Parent
if (tmp___0) {
//Stmt3318:Leaf
return (1);

   }

//Stmt3337:Leaf
tmp___3 = ar_name(file->name);

//Stmt3338:Parent
if (tmp___3) {
//Stmt3326:Parent
while (1) {
//Stmt3323:Parent
if (8 & db_level) {
//Stmt3319:Leaf
print_spaces(depth);

//Stmt3320:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "Looking for archive-member implicit rule for `%s\'.\n",
                             5);

//Stmt3321:Leaf
printf((char const   * __restrict  )tmp___1, file->name);

//Stmt3322:Leaf
fflush(stdout);

       }

//Stmt3324:Leaf
break;

     }

//Stmt3327:Leaf
tmp___2 = pattern_search(file, 1, depth, 0U);

//Stmt3328:Parent
if (tmp___2) {
//Stmt3325:Leaf
return (1);

     }

   }

//Stmt3339:Leaf
return (0);

 }
}
 static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) 
 { 
//Stmt3656:Leaf
char *filename ;

//Stmt3657:Leaf
char *tmp ;

//Stmt3658:Leaf
char *tmp___0 ;

//Stmt3659:Leaf
unsigned int namelen ;

//Stmt3660:Leaf
size_t tmp___1 ;

//Stmt3661:Leaf
char *lastslash ;

//Stmt3662:Leaf
struct file *intermediate_file ;

//Stmt3663:Leaf
struct file **intermediate_files ;

//Stmt3664:Leaf
void *tmp___2 ;

//Stmt3665:Leaf
char **intermediate_patterns ;

//Stmt3666:Leaf
void *tmp___3 ;

//Stmt3667:Leaf
char **found_files ;

//Stmt3668:Leaf
void *tmp___4 ;

//Stmt3669:Leaf
unsigned int deps_found ;

//Stmt3670:Leaf
register char *depname ;

//Stmt3671:Leaf
void *tmp___5 ;

//Stmt3672:Leaf
register char *stem ;

//Stmt3673:Leaf
register unsigned int stemlen ;

//Stmt3674:Leaf
struct rule **tryrules ;

//Stmt3675:Leaf
void *tmp___6 ;

//Stmt3676:Leaf
unsigned int nrules ;

//Stmt3677:Leaf
unsigned int *matches ;

//Stmt3678:Leaf
void *tmp___7 ;

//Stmt3679:Leaf
char *checked_lastslash ;

//Stmt3680:Leaf
void *tmp___8 ;

//Stmt3681:Leaf
unsigned int foundrule ;

//Stmt3682:Leaf
int intermed_ok ;

//Stmt3683:Leaf
int specific_rule_matched ;

//Stmt3684:Leaf
register unsigned int i ;

//Stmt3685:Leaf
register struct rule *rule ;

//Stmt3686:Leaf
register struct dep *dep ;

//Stmt3687:Leaf
char *p ;

//Stmt3688:Leaf
char *vp ;

//Stmt3689:Leaf
int tmp___9 ;

//Stmt3690:Leaf
char *tmp___10 ;

//Stmt3691:Leaf
char *target ;

//Stmt3692:Leaf
char *suffix ;

//Stmt3693:Leaf
int check_lastslash ;

//Stmt3694:Leaf
char *tmp___11 ;

//Stmt3695:Leaf
int tmp___12 ;

//Stmt3696:Leaf
unsigned int difference ;

//Stmt3697:Leaf
int tmp___13 ;

//Stmt3698:Leaf
int tmp___14 ;

//Stmt3699:Leaf
int tmp___15 ;

//Stmt3700:Leaf
register unsigned int j ;

//Stmt3701:Leaf
int check_lastslash___0 ;

//Stmt3702:Leaf
char *tmp___16 ;

//Stmt3703:Leaf
char *tmp___17 ;

//Stmt3704:Leaf
register unsigned int i___0 ;

//Stmt3705:Leaf
char *tmp___18 ;

//Stmt3706:Leaf
char *tmp___19 ;

//Stmt3707:Leaf
char *tmp___20 ;

//Stmt3708:Leaf
char *tmp___21 ;

//Stmt3709:Leaf
char *tmp___22 ;

//Stmt3710:Leaf
char *tmp___23 ;

//Stmt3711:Leaf
int tmp___24 ;

//Stmt3712:Leaf
char *tmp___25 ;

//Stmt3713:Leaf
char *tmp___26 ;

//Stmt3714:Leaf
char *tmp___27 ;

//Stmt3715:Leaf
unsigned int tmp___28 ;

//Stmt3716:Leaf
struct file *tmp___29 ;

//Stmt3717:Leaf
int tmp___30 ;

//Stmt3718:Leaf
char *tmp___31 ;

//Stmt3719:Leaf
unsigned int tmp___32 ;

//Stmt3720:Leaf
int tmp___33 ;

//Stmt3721:Leaf
void *tmp___34 ;

//Stmt3722:Leaf
char *tmp___35 ;

//Stmt3723:Leaf
int tmp___36 ;

//Stmt3724:Leaf
register struct file *f ;

//Stmt3725:Leaf
size_t tmp___37 ;

//Stmt3726:Leaf
unsigned int tmp___38 ;

//Stmt3727:Leaf
register char *s ;

//Stmt3728:Leaf
struct file *imf ;

//Stmt3729:Leaf
register struct file *f___0 ;

//Stmt3730:Leaf
struct file *tmp___39 ;

//Stmt3731:Leaf
char *tmp___40 ;

//Stmt3732:Leaf
unsigned int tmp___41 ;

//Stmt3733:Leaf
char *tmp___42 ;

//Stmt3734:Leaf
struct dep *new ;

//Stmt3735:Leaf
char *tmp___43 ;

//Stmt3736:Leaf
char *tmp___44 ;

 
   {
//Stmt3737:Parent
if (archive) {
//Stmt3340:Leaf
tmp = strchr((char const   *)file->name, '(');

//Stmt3341:Leaf
tmp___0 = tmp;

   } else {
//Stmt3342:Leaf
tmp___0 = file->name;

   }

//Stmt3738:Leaf
filename = tmp___0;

//Stmt3739:Leaf
tmp___1 = strlen((char const   *)filename);

//Stmt3740:Leaf
namelen = (unsigned int )tmp___1;

//Stmt3741:Leaf
intermediate_file = (struct file *)0;

//Stmt3742:Leaf
tmp___2 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(struct file *));

//Stmt3743:Leaf
intermediate_files = (struct file **)tmp___2;

//Stmt3744:Leaf
tmp___3 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));

//Stmt3745:Leaf
intermediate_patterns = (char **)tmp___3;

//Stmt3746:Leaf
tmp___4 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));

//Stmt3747:Leaf
found_files = (char **)tmp___4;

//Stmt3748:Leaf
deps_found = 0U;

//Stmt3749:Leaf
tmp___5 = __builtin_alloca((unsigned long )(namelen + max_pattern_dep_length));

//Stmt3750:Leaf
depname = (char *)tmp___5;

//Stmt3751:Leaf
stem = (char *)0;

//Stmt3752:Leaf
stemlen = 0U;

//Stmt3753:Leaf
tmp___6 = __builtin_alloca((unsigned long )(num_pattern_rules * max_pattern_targets) * sizeof(struct rule *));

//Stmt3754:Leaf
tryrules = (struct rule **)tmp___6;

//Stmt3755:Leaf
tmp___7 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(unsigned int ));

//Stmt3756:Leaf
matches = (unsigned int *)tmp___7;

//Stmt3757:Leaf
tmp___8 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(char ));

//Stmt3758:Leaf
checked_lastslash = (char *)tmp___8;

//Stmt3759:Leaf
specific_rule_matched = 0;

//Stmt3760:Leaf
i = 0U;

//Stmt3761:Parent
if (archive) {
//Stmt3348:Leaf
lastslash = (char *)0;

   } else {
//Stmt3349:Leaf
tmp___9 = ar_name(filename);

//Stmt3350:Parent
if (tmp___9) {
//Stmt3345:Leaf
lastslash = (char *)0;

     } else {
//Stmt3346:Leaf
lastslash = strrchr((char const   *)filename, '/');

//Stmt3347:Parent
if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
//Stmt3344:Parent
if ((int )*(lastslash + 1) == 0) {
//Stmt3343:Leaf
lastslash = (char *)0;

         }

       }

     }

   }

//Stmt3762:Leaf
nrules = 0U;

//Stmt3763:Leaf
rule = pattern_rules;

//Stmt3764:Parent
while ((unsigned long )rule != (unsigned long )((struct rule *)0)) {
//Stmt3414:Parent
if ((unsigned long )rule->deps != (unsigned long )((struct dep *)0)) {
//Stmt3352:Parent
if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
//Stmt3351:Leaf
goto __Cont;

       }

     }

//Stmt3415:Parent
if (rule->in_use) {
//Stmt3359:Parent
while (1) {
//Stmt3357:Parent
if (8 & db_level) {
//Stmt3353:Leaf
print_spaces(depth);

//Stmt3354:Leaf
tmp___10 = dcgettext((char const   *)((void *)0), "Avoiding implicit rule recursion.\n",
                                5);

//Stmt3355:Leaf
printf((char const   * __restrict  )tmp___10);

//Stmt3356:Leaf
fflush(stdout);

         }

//Stmt3358:Leaf
break;

       }

//Stmt3360:Leaf
goto __Cont;

     }

//Stmt3416:Leaf
i = 0U;

//Stmt3417:Parent
while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
//Stmt3396:Leaf
target = *(rule->targets + i);

//Stmt3397:Leaf
suffix = *(rule->suffixes + i);

//Stmt3398:Parent
if (recursions > 0U) {
//Stmt3363:Parent
if ((int )*(target + 1) == 0) {
//Stmt3362:Parent
if (! rule->terminal) {
//Stmt3361:Leaf
goto __Cont___0;

           }

         }

       }

//Stmt3399:Parent
if (*(rule->lens + i) > namelen) {
//Stmt3364:Leaf
goto __Cont___0;

       }

//Stmt3400:Leaf
stem = filename + ((suffix - target) - 1L);

//Stmt3401:Leaf
stemlen = (namelen - *(rule->lens + i)) + 1U;

//Stmt3402:Parent
if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
//Stmt3367:Leaf
tmp___11 = strchr((char const   *)target, '/');

//Stmt3368:Parent
if ((unsigned long )tmp___11 == (unsigned long )((char *)0)) {
//Stmt3365:Leaf
tmp___12 = 1;

         } else {
//Stmt3366:Leaf
tmp___12 = 0;

         }

       } else {
//Stmt3369:Leaf
tmp___12 = 0;

       }

//Stmt3403:Leaf
check_lastslash = tmp___12;

//Stmt3404:Parent
if (check_lastslash) {
//Stmt3371:Leaf
difference = (unsigned int )((lastslash - filename) + 1L);

//Stmt3372:Parent
if (difference > stemlen) {
//Stmt3370:Leaf
goto __Cont___0;

         }

//Stmt3373:Leaf
stemlen -= difference;

//Stmt3374:Leaf
stem += difference;

       }

//Stmt3405:Parent
if (check_lastslash) {
//Stmt3381:Parent
if ((unsigned long )stem > (unsigned long )(lastslash + 1)) {
//Stmt3376:Leaf
tmp___13 = strncmp((char const   *)target, (char const   *)(lastslash + 1),
                              (size_t )((stem - lastslash) - 1L));

//Stmt3377:Parent
if (! (tmp___13 == 0)) {
//Stmt3375:Leaf
goto __Cont___0;

           }

         }

       } else
       {
//Stmt3382:Parent
if ((unsigned long )stem > (unsigned long )filename) {
//Stmt3379:Leaf
tmp___14 = strncmp((char const   *)target, (char const   *)filename, (size_t )(stem - filename));

//Stmt3380:Parent
if (! (tmp___14 == 0)) {
//Stmt3378:Leaf
goto __Cont___0;

         }

       }
}


//Stmt3406:Parent
if ((int )*suffix != (int )*(stem + stemlen)) {
//Stmt3390:Leaf
goto __Cont___0;

       } else
       {
//Stmt3391:Parent
if ((int )*suffix != 0) {
//Stmt3389:Parent
if (! ((unsigned long )(suffix + 1) == (unsigned long )(stem + (stemlen + 1U)))) {
//Stmt3388:Parent
if ((int )*(suffix + 1) == (int )*(stem + (stemlen + 1U))) {
//Stmt3386:Parent
if (! ((int )*(suffix + 1) == 0)) {
//Stmt3384:Leaf
tmp___15 = strcmp((char const   *)((suffix + 1) + 1), (char const   *)((stem + (stemlen + 1U)) + 1));

//Stmt3385:Parent
if (tmp___15) {
//Stmt3383:Leaf
goto __Cont___0;

               }

             }

           } else {
//Stmt3387:Leaf
goto __Cont___0;

           }

         }

       }
}


//Stmt3407:Parent
if ((int )*(target + 1) != 0) {
//Stmt3392:Leaf
specific_rule_matched = 1;

       }

//Stmt3408:Parent
if ((unsigned long )rule->deps == (unsigned long )((struct dep *)0)) {
//Stmt3394:Parent
if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
//Stmt3393:Leaf
goto __Cont___0;

         }

       }

//Stmt3409:Leaf
*(tryrules + nrules) = rule;

//Stmt3410:Leaf
*(matches + nrules) = i;

//Stmt3411:Leaf
*(checked_lastslash + nrules) = (char )check_lastslash;

//Stmt3412:Leaf
nrules ++;

       __Cont___0: /* CIL Label */ 
       {
//Stmt3395:Leaf
i ++;

}
     }

     __Cont: /* CIL Label */ 
     {
//Stmt3413:Leaf
rule = rule->next;

}
   }

//Stmt3765:Parent
if (specific_rule_matched) {
//Stmt3427:Leaf
i = 0U;

//Stmt3428:Parent
while (i < nrules) {
//Stmt3425:Parent
if (! (*(tryrules + i))->terminal) {
//Stmt3422:Leaf
j = 0U;

//Stmt3423:Parent
while ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0)) {
//Stmt3419:Parent
if ((int )*(*((*(tryrules + i))->targets + j) + 1) == 0) {
//Stmt3418:Leaf
break;

           }

//Stmt3420:Leaf
j ++;

         }

//Stmt3424:Parent
if ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0)) {
//Stmt3421:Leaf
*(tryrules + i) = (struct rule *)0;

         }

       }

//Stmt3426:Leaf
i ++;

     }

   }

//Stmt3766:Leaf
intermed_ok = 0;

//Stmt3767:Parent
while (intermed_ok == ! (! intermed_ok)) {
//Stmt3580:Leaf
i = 0U;

//Stmt3581:Parent
while (i < nrules) {
//Stmt3565:Leaf
rule = *(tryrules + i);

//Stmt3566:Parent
if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
//Stmt3429:Leaf
goto __Cont___1;

       }

//Stmt3567:Parent
if (intermed_ok) {
//Stmt3431:Parent
if (rule->terminal) {
//Stmt3430:Leaf
goto __Cont___1;

         }

       }

//Stmt3568:Leaf
rule->in_use = (char)1;

//Stmt3569:Leaf
stem = (filename + (*(rule->suffixes + *(matches + i)) - *(rule->targets + *(matches + i)))) - 1;

//Stmt3570:Leaf
stemlen = (namelen - *(rule->lens + *(matches + i))) + 1U;

//Stmt3571:Leaf
check_lastslash___0 = (int )*(checked_lastslash + i);

//Stmt3572:Parent
if (check_lastslash___0) {
//Stmt3432:Leaf
stem += (lastslash - filename) + 1L;

//Stmt3433:Leaf
stemlen = (unsigned int )((long )stemlen - ((lastslash - filename) + 1L));

       }

//Stmt3573:Parent
while (1) {
//Stmt3438:Parent
if (8 & db_level) {
//Stmt3434:Leaf
print_spaces(depth);

//Stmt3435:Leaf
tmp___16 = dcgettext((char const   *)((void *)0), "Trying pattern rule with stem `%.*s\'.\n",
                                5);

//Stmt3436:Leaf
printf((char const   * __restrict  )tmp___16, (int )stemlen, stem);

//Stmt3437:Leaf
fflush(stdout);

         }

//Stmt3439:Leaf
break;

       }

//Stmt3574:Leaf
deps_found = 0U;

//Stmt3575:Leaf
dep = rule->deps;

//Stmt3576:Parent
while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
//Stmt3537:Parent
if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
//Stmt3440:Leaf
tmp___17 = (dep->file)->name;

         } else {
//Stmt3441:Leaf
tmp___17 = dep->name;

         }

//Stmt3538:Leaf
p = strchr((char const   *)tmp___17, '%');

//Stmt3539:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt3453:Parent
if (check_lastslash___0) {
//Stmt3442:Leaf
i___0 = (unsigned int )((lastslash - filename) + 1L);

//Stmt3443:Leaf
memmove((void *)depname, (void const   *)filename, (size_t )i___0);

           } else {
//Stmt3444:Leaf
i___0 = 0U;

           }

//Stmt3454:Parent
if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
//Stmt3445:Leaf
tmp___18 = (dep->file)->name;

           } else {
//Stmt3446:Leaf
tmp___18 = dep->name;

           }

//Stmt3455:Parent
if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
//Stmt3447:Leaf
tmp___19 = (dep->file)->name;

           } else {
//Stmt3448:Leaf
tmp___19 = dep->name;

           }

//Stmt3456:Leaf
memmove((void *)(depname + i___0), (void const   *)tmp___19, (size_t )(p - tmp___18));

//Stmt3457:Parent
if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
//Stmt3449:Leaf
tmp___20 = (dep->file)->name;

           } else {
//Stmt3450:Leaf
tmp___20 = dep->name;

           }

//Stmt3458:Leaf
i___0 = (unsigned int )((long )i___0 + (p - tmp___20));

//Stmt3459:Leaf
memmove((void *)(depname + i___0), (void const   *)stem, (size_t )stemlen);

//Stmt3460:Leaf
i___0 += stemlen;

//Stmt3461:Leaf
strcpy((char * __restrict  )(depname + i___0), (char const   * __restrict  )(p + 1));

//Stmt3462:Leaf
p = depname;

         } else
         {
//Stmt3463:Parent
if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
//Stmt3451:Leaf
p = (dep->file)->name;

         } else {
//Stmt3452:Leaf
p = dep->name;

         }
}


//Stmt3540:Leaf
tmp___24 = file_impossible_p(p);

//Stmt3541:Parent
if (tmp___24) {
//Stmt3474:Parent
while (1) {
//Stmt3472:Parent
if (8 & db_level) {
//Stmt3468:Leaf
print_spaces(depth);

//Stmt3469:Parent
if ((unsigned long )p == (unsigned long )depname) {
//Stmt3464:Leaf
tmp___21 = dcgettext((char const   *)((void *)0), "Rejecting impossible implicit prerequisite `%s\'.\n",
                                      5);

//Stmt3465:Leaf
tmp___23 = tmp___21;

               } else {
//Stmt3466:Leaf
tmp___22 = dcgettext((char const   *)((void *)0), "Rejecting impossible rule prerequisite `%s\'.\n",
                                      5);

//Stmt3467:Leaf
tmp___23 = tmp___22;

               }

//Stmt3470:Leaf
printf((char const   * __restrict  )tmp___23, p);

//Stmt3471:Leaf
fflush(stdout);

             }

//Stmt3473:Leaf
break;

           }

//Stmt3475:Leaf
*(tryrules + i) = (struct rule *)0;

//Stmt3476:Leaf
break;

         }

//Stmt3542:Leaf
*(intermediate_files + deps_found) = (struct file *)0;

//Stmt3543:Parent
while (1) {
//Stmt3485:Parent
if (8 & db_level) {
//Stmt3481:Leaf
print_spaces(depth);

//Stmt3482:Parent
if ((unsigned long )p == (unsigned long )depname) {
//Stmt3477:Leaf
tmp___25 = dcgettext((char const   *)((void *)0), "Trying implicit prerequisite `%s\'.\n",
                                    5);

//Stmt3478:Leaf
tmp___27 = tmp___25;

             } else {
//Stmt3479:Leaf
tmp___26 = dcgettext((char const   *)((void *)0), "Trying rule prerequisite `%s\'.\n",
                                    5);

//Stmt3480:Leaf
tmp___27 = tmp___26;

             }

//Stmt3483:Leaf
printf((char const   * __restrict  )tmp___27, p);

//Stmt3484:Leaf
fflush(stdout);

           }

//Stmt3486:Leaf
break;

         }

//Stmt3544:Parent
if (! dep->changed) {
//Stmt3499:Leaf
goto _L;

         } else
         {
//Stmt3500:Parent
if (check_lastslash___0) {
           _L: /* CIL Label */ 
           {
//Stmt3487:Leaf
tmp___29 = lookup_file(p);

}
//Stmt3498:Parent
if ((unsigned long )tmp___29 != (unsigned long )((struct file *)0)) {
//Stmt3492:Leaf
tmp___28 = deps_found;

//Stmt3493:Leaf
deps_found ++;

//Stmt3494:Leaf
*(found_files + tmp___28) = xstrdup((char const   *)p);

//Stmt3495:Leaf
goto __Cont___2;

           } else {
//Stmt3496:Leaf
tmp___30 = file_exists_p(p);

//Stmt3497:Parent
if (tmp___30) {
//Stmt3488:Leaf
tmp___28 = deps_found;

//Stmt3489:Leaf
deps_found ++;

//Stmt3490:Leaf
*(found_files + tmp___28) = xstrdup((char const   *)p);

//Stmt3491:Leaf
goto __Cont___2;

             }

           }

         }
}


//Stmt3545:Leaf
vp = p;

//Stmt3546:Leaf
tmp___33 = vpath_search(& vp, (uintmax_t *)0);

//Stmt3547:Parent
if (tmp___33) {
//Stmt3507:Parent
while (1) {
//Stmt3505:Parent
if (8 & db_level) {
//Stmt3501:Leaf
print_spaces(depth);

//Stmt3502:Leaf
tmp___31 = dcgettext((char const   *)((void *)0), "Found prerequisite `%s\' as VPATH `%s\'\n",
                                    5);

//Stmt3503:Leaf
printf((char const   * __restrict  )tmp___31, p, vp);

//Stmt3504:Leaf
fflush(stdout);

             }

//Stmt3506:Leaf
break;

           }

//Stmt3508:Leaf
strcpy((char * __restrict  )vp, (char const   * __restrict  )p);

//Stmt3509:Leaf
tmp___32 = deps_found;

//Stmt3510:Leaf
deps_found ++;

//Stmt3511:Leaf
*(found_files + tmp___32) = vp;

//Stmt3512:Leaf
goto __Cont___2;

         }

//Stmt3548:Parent
if (intermed_ok) {
//Stmt3529:Parent
if ((unsigned long )intermediate_file == (unsigned long )((struct file *)0)) {
//Stmt3513:Leaf
tmp___34 = __builtin_alloca(sizeof(struct file ));

//Stmt3514:Leaf
intermediate_file = (struct file *)tmp___34;

           }

//Stmt3530:Parent
while (1) {
//Stmt3519:Parent
if (8 & db_level) {
//Stmt3515:Leaf
print_spaces(depth);

//Stmt3516:Leaf
tmp___35 = dcgettext((char const   *)((void *)0), "Looking for a rule with intermediate file `%s\'.\n",
                                    5);

//Stmt3517:Leaf
printf((char const   * __restrict  )tmp___35, p);

//Stmt3518:Leaf
fflush(stdout);

             }

//Stmt3520:Leaf
break;

           }

//Stmt3531:Leaf
memset((void *)((char *)intermediate_file), 0, sizeof(struct file ));

//Stmt3532:Leaf
intermediate_file->name = p;

//Stmt3533:Leaf
tmp___36 = pattern_search(intermediate_file, 0, depth + 1U, recursions + 1U);

//Stmt3534:Parent
if (tmp___36) {
//Stmt3521:Leaf
p = xstrdup((char const   *)p);

//Stmt3522:Leaf
*(intermediate_patterns + deps_found) = intermediate_file->name;

//Stmt3523:Leaf
intermediate_file->name = p;

//Stmt3524:Leaf
*(intermediate_files + deps_found) = intermediate_file;

//Stmt3525:Leaf
intermediate_file = (struct file *)0;

//Stmt3526:Leaf
*(found_files + deps_found) = xstrdup((char const   *)p);

//Stmt3527:Leaf
deps_found ++;

//Stmt3528:Leaf
goto __Cont___2;

           }

//Stmt3535:Leaf
file_impossible(p);

         }

//Stmt3549:Leaf
break;

         __Cont___2: /* CIL Label */ 
         {
//Stmt3536:Leaf
dep = dep->next;

}
       }

//Stmt3577:Leaf
rule->in_use = (char)0;

//Stmt3578:Parent
if ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
//Stmt3562:Parent
while (1) {
//Stmt3556:Leaf
tmp___38 = deps_found;

//Stmt3557:Leaf
deps_found --;

//Stmt3558:Parent
if (! (tmp___38 > 0U)) {
//Stmt3550:Leaf
break;

           }

//Stmt3559:Leaf
f = *(intermediate_files + deps_found);

//Stmt3560:Leaf
free((void *)*(found_files + deps_found));

//Stmt3561:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt3555:Parent
if ((unsigned long )f->stem < (unsigned long )f->name) {
//Stmt3552:Leaf
free((void *)f->stem);

             } else {
//Stmt3553:Leaf
tmp___37 = strlen((char const   *)f->name);

//Stmt3554:Parent
if ((unsigned long )f->stem > (unsigned long )(f->name + tmp___37)) {
//Stmt3551:Leaf
free((void *)f->stem);

               }

             }

           }

         }

       } else {
//Stmt3563:Leaf
break;

       }

       __Cont___1: /* CIL Label */ 
       {
//Stmt3564:Leaf
i ++;

}
     }

//Stmt3582:Parent
if (i < nrules) {
//Stmt3579:Leaf
break;

     }

//Stmt3583:Leaf
rule = (struct rule *)0;

//Stmt3584:Leaf
intermed_ok ++;

   }

//Stmt3768:Parent
if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
//Stmt3585:Leaf
return (0);

   }

//Stmt3769:Leaf
foundrule = i;

//Stmt3770:Parent
if (recursions > 0U) {
//Stmt3586:Leaf
file->name = *(rule->targets + *(matches + foundrule));

   }

//Stmt3771:Parent
while (1) {
//Stmt3622:Leaf
tmp___41 = deps_found;

//Stmt3623:Leaf
deps_found --;

//Stmt3624:Parent
if (! (tmp___41 > 0U)) {
//Stmt3587:Leaf
break;

     }

//Stmt3625:Parent
if ((unsigned long )*(intermediate_files + deps_found) != (unsigned long )((struct file *)0)) {
//Stmt3596:Leaf
imf = *(intermediate_files + deps_found);

//Stmt3597:Leaf
tmp___39 = enter_file(imf->name);

//Stmt3598:Leaf
f___0 = tmp___39;

//Stmt3599:Leaf
f___0->deps = imf->deps;

//Stmt3600:Leaf
f___0->cmds = imf->cmds;

//Stmt3601:Leaf
f___0->stem = imf->stem;

//Stmt3602:Leaf
f___0->also_make = imf->also_make;

//Stmt3603:Leaf
imf = lookup_file(*(intermediate_patterns + deps_found));

//Stmt3604:Parent
if ((unsigned long )imf != (unsigned long )((struct file *)0)) {
//Stmt3589:Parent
if (imf->precious) {
//Stmt3588:Leaf
f___0->precious = 1U;

         }

       }

//Stmt3605:Leaf
f___0->intermediate = 1U;

//Stmt3606:Leaf
f___0->tried_implicit = 1U;

//Stmt3607:Leaf
dep = f___0->deps;

//Stmt3608:Parent
while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
//Stmt3591:Leaf
dep->file = enter_file(dep->name);

//Stmt3592:Parent
if ((unsigned long )dep->name != (unsigned long )(dep->file)->name) {
//Stmt3590:Leaf
free((void *)dep->name);

         }

//Stmt3593:Leaf
dep->name = (char *)0;

//Stmt3594:Leaf
(dep->file)->tried_implicit |= (unsigned int )dep->changed;

//Stmt3595:Leaf
dep = dep->next;

       }

//Stmt3609:Leaf
num_intermediates ++;

     }

//Stmt3626:Leaf
tmp___40 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt3627:Leaf
dep = (struct dep *)tmp___40;

//Stmt3628:Leaf
s = *(found_files + deps_found);

//Stmt3629:Parent
if (recursions == 0U) {
//Stmt3612:Leaf
dep->name = (char *)0;

//Stmt3613:Leaf
dep->file = lookup_file(s);

//Stmt3614:Parent
if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
//Stmt3610:Leaf
dep->file = enter_file(s);

       } else {
//Stmt3611:Leaf
free((void *)s);

       }

     } else {
//Stmt3615:Leaf
dep->name = s;

//Stmt3616:Leaf
dep->file = (struct file *)0;

//Stmt3617:Leaf
dep->changed = 0;

     }

//Stmt3630:Parent
if ((unsigned long )*(intermediate_files + deps_found) == (unsigned long )((struct file *)0)) {
//Stmt3621:Parent
if ((*(tryrules + foundrule))->terminal) {
//Stmt3620:Parent
if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
//Stmt3618:Leaf
dep->changed = 1;

         } else {
//Stmt3619:Leaf
(dep->file)->tried_implicit = 1U;

         }

       }

     }

//Stmt3631:Leaf
dep->next = file->deps;

//Stmt3632:Leaf
file->deps = dep;

   }

//Stmt3772:Parent
if (! *(checked_lastslash + foundrule)) {
//Stmt3633:Leaf
file->stem = savestring((char const   *)stem, stemlen);

   } else {
//Stmt3634:Leaf
tmp___42 = xmalloc((unsigned int )((((lastslash + 1) - filename) + (long )stemlen) + 1L));

//Stmt3635:Leaf
file->stem = tmp___42;

//Stmt3636:Leaf
memmove((void *)file->stem, (void const   *)filename, (size_t )((lastslash + 1) - filename));

//Stmt3637:Leaf
memmove((void *)(file->stem + ((lastslash + 1) - filename)), (void const   *)stem,
             (size_t )stemlen);

//Stmt3638:Leaf
*(file->stem + (((lastslash + 1) - filename) + (long )stemlen)) = (char )'\000';

   }

//Stmt3773:Leaf
file->cmds = rule->cmds;

//Stmt3774:Parent
if ((unsigned long )*(rule->targets + 1) != (unsigned long )((char *)0)) {
//Stmt3654:Leaf
i = 0U;

//Stmt3655:Parent
while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
//Stmt3652:Parent
if (i != *(matches + foundrule)) {
//Stmt3639:Leaf
tmp___43 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt3640:Leaf
new = (struct dep *)tmp___43;

//Stmt3641:Leaf
tmp___44 = xmalloc((*(rule->lens + i) + stemlen) + 1U);

//Stmt3642:Leaf
p = tmp___44;

//Stmt3643:Leaf
new->name = p;

//Stmt3644:Leaf
memmove((void *)p, (void const   *)*(rule->targets + i), (size_t )((*(rule->suffixes + i) - *(rule->targets + i)) - 1L));

//Stmt3645:Leaf
p += (*(rule->suffixes + i) - *(rule->targets + i)) - 1L;

//Stmt3646:Leaf
memmove((void *)p, (void const   *)stem, (size_t )stemlen);

//Stmt3647:Leaf
p += stemlen;

//Stmt3648:Leaf
memmove((void *)p, (void const   *)*(rule->suffixes + i), (size_t )(((long )*(rule->lens + i) - (*(rule->suffixes + i) - *(rule->targets + i))) + 1L));

//Stmt3649:Leaf
new->file = enter_file(new->name);

//Stmt3650:Leaf
new->next = file->also_make;

//Stmt3651:Leaf
file->also_make = new;

       }

//Stmt3653:Leaf
i ++;

     }

   }

//Stmt3775:Leaf
return (1);

 }
}
 #pragma merger("0","/tmp/cil-2QdUWNY1.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                   sigset_t const   * __restrict  __set ,
                                                                                   sigset_t * __restrict  __oset ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                            int __fd2 ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                                char * const  *__argv ) ;
 extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *loadavg ,
                                                                                                  int nelem ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
 void ( /* format attribute */  message)(int prefix , char const   *fmt  , ...) ;
  __attribute__((__noreturn__)) void die(int status ) ;
 void user_access(void) ;
 void make_access(void) ;
 void child_access(void) ;
 int keep_going_flag ;
 int batch_mode_shell ;
 unsigned int job_slots ;
 int job_fds[2] ;
 int job_rfd ;
 double max_load_average ;
 unsigned int commands_started ;
 void start_waiting_jobs(void) ;
 void exec_command(char **argv , char **envp ) ;
 void block_sigs(void) ;
 void unblock_sigs(void) ;
 char **target_environment(struct file *file ) ;
 char default_shell[8]  = 
   {      (char )'/',      (char )'b',      (char )'i',      (char )'n', 
         (char )'/',      (char )'s',      (char )'h',      (char )'\000'};
 int batch_mode_shell  =    0;
 extern int fcntl(int __fd , int __cmd  , ...) ;
 extern __pid_t wait(int *__stat_loc ) ;
 extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
 int start_remote_job(char **argv , char **envp , int stdin_fd , int *is_remote , int *id_ptr ,
                      int *used_stdin ) ;
 int start_remote_job_p(int first_p ) ;
 int remote_status(int *exit_code_ptr , int *signal_ptr , int *coredump_ptr , int block ) ;
 void child_handler(int sig ) ;
 static void free_child(struct child *child ) ;
 static void start_job_command(struct child *child ) ;
 static int load_too_high(void) ;
 static int job_next_command(struct child *child ) ;
 static int start_waiting_job(struct child *c ) ;
 struct child *children  =    (struct child *)0;
 unsigned int job_slots_used  =    0U;
 static int good_stdin_used  =    0;
 static struct child *waiting_jobs  =    (struct child *)0;
 int unixy_shell  =    1;
 static void child_error(char *target_name , int exit_code , int exit_sig , int coredump ,
                         int ignored ) 
 { 
//Stmt3790:Leaf
char *tmp ;

//Stmt3791:Leaf
char *tmp___0 ;

//Stmt3792:Leaf
char *tmp___1 ;

//Stmt3793:Leaf
char *tmp___2 ;

//Stmt3794:Leaf
char const   *tmp___3 ;

//Stmt3795:Leaf
char *tmp___4 ;

 
   {
//Stmt3796:Parent
if (ignored) {
//Stmt3777:Parent
if (silent_flag) {
//Stmt3776:Leaf
return;

     }

   }

//Stmt3797:Parent
if (exit_sig == 0) {
//Stmt3785:Parent
if (ignored) {
//Stmt3778:Leaf
tmp = dcgettext((char const   *)((void *)0), "[%s] Error %d (ignored)", 5);

//Stmt3779:Leaf
tmp___1 = tmp;

     } else {
//Stmt3780:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "*** [%s] Error %d", 5);

//Stmt3781:Leaf
tmp___1 = tmp___0;

     }

//Stmt3786:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, target_name,
           exit_code);

   } else {
//Stmt3787:Parent
if (coredump) {
//Stmt3782:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), " (core dumped)", 5);

//Stmt3783:Leaf
tmp___3 = (char const   *)tmp___2;

     } else {
//Stmt3784:Leaf
tmp___3 = "";

     }

//Stmt3788:Leaf
tmp___4 = strsignal(exit_sig);

//Stmt3789:Leaf
error((struct floc  const  *)((struct floc *)0), "*** [%s] %s%s", target_name,
           tmp___4, tmp___3);

   }

//Stmt3798:Leaf
return;

 }
}
 static unsigned int dead_children  =    0U;
 void child_handler(int sig ) 
 { 
//Stmt3806:Leaf
char *tmp ;

 
   {
//Stmt3807:Leaf
dead_children ++;

//Stmt3808:Parent
if (job_rfd >= 0) {
//Stmt3799:Leaf
close(job_rfd);

//Stmt3800:Leaf
job_rfd = -1;

   }

//Stmt3809:Parent
while (1) {
//Stmt3804:Parent
if (4 & db_level) {
//Stmt3801:Leaf
tmp = dcgettext((char const   *)((void *)0), "Got a SIGCHLD; %u unreaped children.\n",
                       5);

//Stmt3802:Leaf
printf((char const   * __restrict  )tmp, dead_children);

//Stmt3803:Leaf
fflush(stdout);

     }

//Stmt3805:Leaf
break;

   }

//Stmt3810:Leaf
return;

 }
}
 static int delete_on_error  =    -1;
 void reap_children(int block , int err ) 
 { 
//Stmt3992:Leaf
int status ;

//Stmt3993:Leaf
int reap_more ;

//Stmt3994:Leaf
int remote ;

//Stmt3995:Leaf
register int pid ;

//Stmt3996:Leaf
int exit_code ;

//Stmt3997:Leaf
int exit_sig ;

//Stmt3998:Leaf
int coredump ;

//Stmt3999:Leaf
register struct child *lastc ;

//Stmt4000:Leaf
register struct child *c ;

//Stmt4001:Leaf
int child_failed ;

//Stmt4002:Leaf
int any_remote ;

//Stmt4003:Leaf
int any_local ;

//Stmt4004:Leaf
char *tmp ;

//Stmt4005:Leaf
char *tmp___0 ;

//Stmt4006:Leaf
char const   *tmp___1 ;

//Stmt4007:Leaf
char *tmp___2 ;

//Stmt4008:Leaf
int *tmp___3 ;

//Stmt4009:Leaf
int *tmp___4 ;

//Stmt4010:Leaf
int tmp___5 ;

//Stmt4011:Leaf
char *tmp___6 ;

//Stmt4012:Leaf
char const   *tmp___7 ;

//Stmt4013:Leaf
char *tmp___8 ;

//Stmt4014:Leaf
char *tmp___9 ;

//Stmt4015:Leaf
char *tmp___10 ;

//Stmt4016:Leaf
char *tmp___11 ;

//Stmt4017:Leaf
struct file *f ;

//Stmt4018:Leaf
struct file *tmp___12 ;

//Stmt4019:Leaf
int tmp___13 ;

//Stmt4020:Leaf
int tmp___14 ;

//Stmt4021:Leaf
int tmp___15 ;

//Stmt4022:Leaf
char *tmp___16 ;

//Stmt4023:Leaf
char const   *tmp___17 ;

//Stmt4024:Leaf
char *tmp___18 ;

 
   {
//Stmt4025:Leaf
reap_more = 1;

//Stmt4026:Parent
while (1) {
//Stmt3962:Parent
if ((unsigned long )children != (unsigned long )((struct child *)0)) {
//Stmt3815:Leaf
goto _L___1;

     } else
     {
//Stmt3816:Parent
if (shell_function_pid != 0) {
       _L___1: /* CIL Label */ 
       {
//Stmt3813:Parent
if (! block) {
//Stmt3812:Parent
if (! reap_more) {
//Stmt3811:Leaf
break;

         }

       }
}

     } else {
//Stmt3814:Leaf
break;

     }
}


//Stmt3963:Leaf
remote = 0;

//Stmt3964:Parent
if (err) {
//Stmt3820:Parent
if (block) {
//Stmt3817:Leaf
fflush(stdout);

//Stmt3818:Leaf
tmp = dcgettext((char const   *)((void *)0), "*** Waiting for unfinished jobs....",
                         5);

//Stmt3819:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp);

       }

     }

//Stmt3965:Parent
if (dead_children > 0U) {
//Stmt3821:Leaf
dead_children --;

     }

//Stmt3966:Leaf
any_remote = 0;

//Stmt3967:Leaf
any_local = shell_function_pid != 0;

//Stmt3968:Leaf
c = children;

//Stmt3969:Parent
while ((unsigned long )c != (unsigned long )((struct child *)0)) {
//Stmt3831:Leaf
any_remote = (int )((unsigned int )any_remote | c->remote);

//Stmt3832:Leaf
any_local |= ! c->remote;

//Stmt3833:Parent
while (1) {
//Stmt3829:Parent
if (4 & db_level) {
//Stmt3825:Parent
if (c->remote) {
//Stmt3822:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), " (remote)", 5);

//Stmt3823:Leaf
tmp___1 = (char const   *)tmp___0;

           } else {
//Stmt3824:Leaf
tmp___1 = "";

           }

//Stmt3826:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "Live child 0x%08lx (%s) PID %ld %s\n",
                               5);

//Stmt3827:Leaf
printf((char const   * __restrict  )tmp___2, (unsigned long )c, (c->file)->name,
                  (long )c->pid, tmp___1);

//Stmt3828:Leaf
fflush(stdout);

         }

//Stmt3830:Leaf
break;

       }

//Stmt3834:Leaf
c = c->next;

     }

//Stmt3970:Parent
if (any_remote) {
//Stmt3835:Leaf
pid = remote_status(& exit_code, & exit_sig, & coredump, 0);

     } else {
//Stmt3836:Leaf
pid = 0;

     }

//Stmt3971:Parent
if (pid > 0) {
//Stmt3868:Leaf
remote = 1;

     } else
     {
//Stmt3869:Parent
if (pid < 0) {
       remote_status_lose: 
       {
//Stmt3837:Leaf
tmp___3 = __errno_location();

}
//Stmt3864:Parent
if (*tmp___3 == 4) {
//Stmt3838:Leaf
continue;

       }

//Stmt3865:Leaf
pfatal_with_name((char *)"remote_status");

     } else {
//Stmt3866:Parent
if (any_local) {
         local_wait: 
         {
//Stmt3841:Parent
if (! block) {
//Stmt3839:Leaf
pid = waitpid(-1, & status, 1);

         } else {
//Stmt3840:Leaf
pid = wait(& status);

         }
}

       } else {
//Stmt3842:Leaf
pid = 0;

       }

//Stmt3867:Parent
if (pid < 0) {
//Stmt3860:Leaf
tmp___4 = __errno_location();

//Stmt3861:Parent
if (*tmp___4 == 4) {
//Stmt3843:Leaf
goto local_wait;

         }

//Stmt3862:Leaf
pfatal_with_name((char *)"wait");

       } else
       {
//Stmt3863:Parent
if (pid > 0) {
//Stmt3852:Leaf
exit_code = (status & 65280) >> 8;

//Stmt3853:Parent
if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
//Stmt3844:Leaf
exit_sig = status & 127;

         } else {
//Stmt3845:Leaf
exit_sig = 0;

         }

//Stmt3854:Leaf
coredump = status & 128;

       } else {
//Stmt3855:Leaf
reap_more = 0;

//Stmt3856:Parent
if (! block) {
//Stmt3847:Leaf
break;

         } else
         {
//Stmt3848:Parent
if (! any_remote) {
//Stmt3846:Leaf
break;

         }
}


//Stmt3857:Leaf
pid = remote_status(& exit_code, & exit_sig, & coredump, 1);

//Stmt3858:Parent
if (pid < 0) {
//Stmt3850:Leaf
goto remote_status_lose;

         } else
         {
//Stmt3851:Parent
if (pid == 0) {
//Stmt3849:Leaf
break;

         }
}


//Stmt3859:Leaf
remote = 1;

       }
}


     }
}


//Stmt3972:Parent
if (! remote) {
//Stmt3876:Parent
if (pid == shell_function_pid) {
//Stmt3874:Parent
if (exit_sig == 0) {
//Stmt3872:Parent
if (exit_code == 127) {
//Stmt3870:Leaf
shell_function_completed = -1;

           } else {
//Stmt3871:Leaf
shell_function_completed = 1;

           }

         } else {
//Stmt3873:Leaf
shell_function_completed = 1;

         }

//Stmt3875:Leaf
break;

       }

     }

//Stmt3973:Parent
if (exit_sig != 0) {
//Stmt3879:Leaf
tmp___5 = 1;

     } else
     {
//Stmt3880:Parent
if (exit_code != 0) {
//Stmt3877:Leaf
tmp___5 = 1;

     } else {
//Stmt3878:Leaf
tmp___5 = 0;

     }
}


//Stmt3974:Leaf
child_failed = tmp___5;

//Stmt3975:Leaf
lastc = (struct child *)0;

//Stmt3976:Leaf
c = children;

//Stmt3977:Parent
while ((unsigned long )c != (unsigned long )((struct child *)0)) {
//Stmt3883:Parent
if (c->remote == (unsigned int )remote) {
//Stmt3882:Parent
if (c->pid == pid) {
//Stmt3881:Leaf
break;

         }

       }

//Stmt3884:Leaf
lastc = c;

//Stmt3885:Leaf
c = c->next;

     }

//Stmt3978:Parent
if ((unsigned long )c == (unsigned long )((struct child *)0)) {
//Stmt3886:Leaf
continue;

     }

//Stmt3979:Parent
while (1) {
//Stmt3898:Parent
if (4 & db_level) {
//Stmt3894:Parent
if (c->remote) {
//Stmt3887:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), " (remote)", 5);

//Stmt3888:Leaf
tmp___7 = (char const   *)tmp___6;

         } else {
//Stmt3889:Leaf
tmp___7 = "";

         }

//Stmt3895:Parent
if (child_failed) {
//Stmt3890:Leaf
tmp___8 = dcgettext((char const   *)((void *)0), "Reaping losing child 0x%08lx PID %ld %s\n",
                               5);

//Stmt3891:Leaf
tmp___10 = tmp___8;

         } else {
//Stmt3892:Leaf
tmp___9 = dcgettext((char const   *)((void *)0), "Reaping winning child 0x%08lx PID %ld %s\n",
                               5);

//Stmt3893:Leaf
tmp___10 = tmp___9;

         }

//Stmt3896:Leaf
printf((char const   * __restrict  )tmp___10, (unsigned long )c, (long )c->pid,
                tmp___7);

//Stmt3897:Leaf
fflush(stdout);

       }

//Stmt3899:Leaf
break;

     }

//Stmt3980:Parent
if (c->sh_batch_file) {
//Stmt3905:Parent
while (1) {
//Stmt3903:Parent
if (4 & db_level) {
//Stmt3900:Leaf
tmp___11 = dcgettext((char const   *)((void *)0), "Cleaning up temp batch file %s\n",
                                5);

//Stmt3901:Leaf
printf((char const   * __restrict  )tmp___11, c->sh_batch_file);

//Stmt3902:Leaf
fflush(stdout);

         }

//Stmt3904:Leaf
break;

       }

//Stmt3906:Leaf
remove((char const   *)c->sh_batch_file);

//Stmt3907:Leaf
free((void *)c->sh_batch_file);

//Stmt3908:Leaf
c->sh_batch_file = (char *)((void *)0);

     }

//Stmt3981:Parent
if (c->good_stdin) {
//Stmt3909:Leaf
good_stdin_used = 0;

     }

//Stmt3982:Parent
if (child_failed) {
//Stmt3942:Parent
if (! c->noerror) {
//Stmt3926:Parent
if (! ignore_errors_flag) {
//Stmt3921:Leaf
child_error((c->file)->name, exit_code, exit_sig, coredump, 0);

//Stmt3922:Leaf
(c->file)->update_status = (short)2;

//Stmt3923:Parent
if (delete_on_error == -1) {
//Stmt3914:Leaf
tmp___12 = lookup_file((char *)".DELETE_ON_ERROR");

//Stmt3915:Leaf
f = tmp___12;

//Stmt3916:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt3912:Parent
if (f->is_target) {
//Stmt3910:Leaf
tmp___13 = 1;

               } else {
//Stmt3911:Leaf
tmp___13 = 0;

               }

             } else {
//Stmt3913:Leaf
tmp___13 = 0;

             }

//Stmt3917:Leaf
delete_on_error = tmp___13;

           }

//Stmt3924:Parent
if (exit_sig != 0) {
//Stmt3919:Leaf
delete_child_targets(c);

           } else
           {
//Stmt3920:Parent
if (delete_on_error) {
//Stmt3918:Leaf
delete_child_targets(c);

           }
}


         } else {
//Stmt3925:Leaf
goto _L___0;

         }

       } else {
//Stmt3927:Leaf
goto _L___0;

       }

     } else {
       _L___0: /* CIL Label */ 
       {
//Stmt3930:Parent
if (child_failed) {
//Stmt3928:Leaf
child_error((c->file)->name, exit_code, exit_sig, coredump, 1);

//Stmt3929:Leaf
child_failed = 0;

       }
}

//Stmt3943:Leaf
tmp___15 = job_next_command(c);

//Stmt3944:Parent
if (tmp___15) {
//Stmt3939:Parent
if (handling_fatal_signal) {
//Stmt3932:Leaf
(c->file)->update_status = (short)2;

         } else {
//Stmt3933:Leaf
tmp___14 = start_remote_job_p(0);

//Stmt3934:Leaf
c->remote = (unsigned int )tmp___14;

//Stmt3935:Leaf
start_job_command(c);

//Stmt3936:Leaf
unblock_sigs();

//Stmt3937:Parent
if ((unsigned int )(c->file)->command_state == 2U) {
//Stmt3931:Leaf
continue;

           }

         }

//Stmt3940:Parent
if ((int )(c->file)->update_status != 0) {
//Stmt3938:Leaf
delete_child_targets(c);

         }

       } else {
//Stmt3941:Leaf
(c->file)->update_status = (short)0;

       }

     }

//Stmt3983:Parent
if (! handling_fatal_signal) {
//Stmt3945:Leaf
notice_finished_file(c->file);

     }

//Stmt3984:Parent
while (1) {
//Stmt3953:Parent
if (4 & db_level) {
//Stmt3949:Parent
if (c->remote) {
//Stmt3946:Leaf
tmp___16 = dcgettext((char const   *)((void *)0), " (remote)", 5);

//Stmt3947:Leaf
tmp___17 = (char const   *)tmp___16;

         } else {
//Stmt3948:Leaf
tmp___17 = "";

         }

//Stmt3950:Leaf
tmp___18 = dcgettext((char const   *)((void *)0), "Removing child 0x%08lx PID %ld %s from chain.\n",
                              5);

//Stmt3951:Leaf
printf((char const   * __restrict  )tmp___18, (unsigned long )c, (long )c->pid,
                tmp___17);

//Stmt3952:Leaf
fflush(stdout);

       }

//Stmt3954:Leaf
break;

     }

//Stmt3985:Leaf
block_sigs();

//Stmt3986:Parent
if (job_slots_used > 0U) {
//Stmt3955:Leaf
job_slots_used --;

     }

//Stmt3987:Parent
if ((unsigned long )lastc == (unsigned long )((struct child *)0)) {
//Stmt3956:Leaf
children = c->next;

     } else {
//Stmt3957:Leaf
lastc->next = c->next;

     }

//Stmt3988:Leaf
free_child(c);

//Stmt3989:Leaf
unblock_sigs();

//Stmt3990:Parent
if (! err) {
//Stmt3961:Parent
if (child_failed) {
//Stmt3960:Parent
if (! keep_going_flag) {
//Stmt3959:Parent
if (! handling_fatal_signal) {
//Stmt3958:Leaf
die(2);

           }

         }

       }

     }

//Stmt3991:Leaf
block = 0;

   }

//Stmt4027:Leaf
return;

 }
}
 static void free_child(struct child *child ) 
 { 
//Stmt4056:Leaf
char token ;

//Stmt4057:Leaf
char *tmp ;

//Stmt4058:Leaf
int *tmp___0 ;

//Stmt4059:Leaf
ssize_t tmp___1 ;

//Stmt4060:Leaf
char *tmp___2 ;

//Stmt4061:Leaf
register unsigned int i ;

//Stmt4062:Leaf
register char **ep ;

//Stmt4063:Leaf
char **tmp___3 ;

 
   {
//Stmt4064:Parent
if (job_fds[1] >= 0) {
//Stmt4043:Parent
if (children) {
//Stmt4040:Leaf
token = (char )'+';

//Stmt4041:Parent
while (1) {
//Stmt4031:Leaf
tmp___1 = write(job_fds[1], (void const   *)(& token), (size_t )1);

//Stmt4032:Parent
if (! (tmp___1 != 1L)) {
//Stmt4028:Leaf
break;

         }

//Stmt4033:Leaf
tmp___0 = __errno_location();

//Stmt4034:Parent
if (! (*tmp___0 == 4)) {
//Stmt4029:Leaf
tmp = dcgettext((char const   *)((void *)0), "write jobserver", 5);

//Stmt4030:Leaf
pfatal_with_name(tmp);

         }

       }

//Stmt4042:Parent
while (1) {
//Stmt4038:Parent
if (4 & db_level) {
//Stmt4035:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "Released token for child 0x%08lx (%s).\n",
                               5);

//Stmt4036:Leaf
printf((char const   * __restrict  )tmp___2, (unsigned long )child, (child->file)->name);

//Stmt4037:Leaf
fflush(stdout);

         }

//Stmt4039:Leaf
break;

       }

     }

   }

//Stmt4065:Parent
if (handling_fatal_signal) {
//Stmt4044:Leaf
return;

   }

//Stmt4066:Parent
if ((unsigned long )child->command_lines != (unsigned long )((char **)0)) {
//Stmt4047:Leaf
i = 0U;

//Stmt4048:Parent
while (i < ((child->file)->cmds)->ncommand_lines) {
//Stmt4045:Leaf
free((void *)*(child->command_lines + i));

//Stmt4046:Leaf
i ++;

     }

//Stmt4049:Leaf
free((void *)((char *)child->command_lines));

   }

//Stmt4067:Parent
if ((unsigned long )child->environment != (unsigned long )((char **)0)) {
//Stmt4053:Leaf
ep = child->environment;

//Stmt4054:Parent
while ((unsigned long )*ep != (unsigned long )((char *)0)) {
//Stmt4050:Leaf
tmp___3 = ep;

//Stmt4051:Leaf
ep ++;

//Stmt4052:Leaf
free((void *)*tmp___3);

     }

//Stmt4055:Leaf
free((void *)((char *)child->environment));

   }

//Stmt4068:Leaf
free((void *)((char *)child));

//Stmt4069:Leaf
return;

 }
}
 sigset_t fatal_signal_set ;
 void block_sigs(void) 
 { 
 
 
{
//Stmt4070:Leaf
sigprocmask(0, (sigset_t const   * __restrict  )(& fatal_signal_set), (sigset_t * __restrict  )((sigset_t *)0));

//Stmt4071:Leaf
return;

 }
}
 void unblock_sigs(void) 
 { 
//Stmt4072:Leaf
sigset_t empty ;

 
   {
//Stmt4073:Leaf
sigemptyset(& empty);

//Stmt4074:Leaf
sigprocmask(2, (sigset_t const   * __restrict  )(& empty), (sigset_t * __restrict  )((sigset_t *)0));

//Stmt4075:Leaf
return;

 }
}
 static int bad_stdin  =    -1;
 static void start_job_command(struct child *child ) 
 { 
//Stmt4171:Leaf
register char *p ;

//Stmt4172:Leaf
int flags ;

//Stmt4173:Leaf
char **argv ;

//Stmt4174:Leaf
unsigned short const   **tmp ;

//Stmt4175:Leaf
char *end ;

//Stmt4176:Leaf
char *tmp___0 ;

//Stmt4177:Leaf
int tmp___1 ;

//Stmt4178:Leaf
char const   *tmp___2 ;

//Stmt4179:Leaf
int tmp___3 ;

//Stmt4180:Leaf
int pd[2] ;

//Stmt4181:Leaf
int tmp___4 ;

//Stmt4182:Leaf
int is_remote ;

//Stmt4183:Leaf
int id ;

//Stmt4184:Leaf
int used_stdin ;

//Stmt4185:Leaf
int tmp___5 ;

//Stmt4186:Leaf
int tmp___6 ;

//Stmt4187:Leaf
char **parent_environ ;

//Stmt4188:Leaf
int tmp___7 ;

 
   {
//Stmt4189:Parent
if (! child->command_ptr) {
//Stmt4076:Leaf
goto next_command;

   }

//Stmt4190:Leaf
flags = (child->file)->command_flags | (int )*(((child->file)->cmds)->lines_flags + (child->command_line - 1U));

//Stmt4191:Leaf
p = child->command_ptr;

//Stmt4192:Leaf
child->noerror = (unsigned int )(flags & 4);

//Stmt4193:Parent
while ((int )*p != 0) {
//Stmt4085:Parent
if ((int )*p == 64) {
//Stmt4083:Leaf
flags |= 2;

     } else
     {
//Stmt4084:Parent
if ((int )*p == 43) {
//Stmt4081:Leaf
flags |= 1;

     } else
     {
//Stmt4082:Parent
if ((int )*p == 45) {
//Stmt4078:Leaf
child->noerror = 1U;

     } else {
//Stmt4079:Leaf
tmp = __ctype_b_loc();

//Stmt4080:Parent
if (! ((int const   )*(*tmp + (int )*p) & 1)) {
//Stmt4077:Leaf
break;

       }

     }
}

}


//Stmt4086:Leaf
p ++;

   }

//Stmt4194:Leaf
*(((child->file)->cmds)->lines_flags + (child->command_line - 1U)) = (char )((int )*(((child->file)->cmds)->lines_flags + (child->command_line - 1U)) | flags);

//Stmt4195:Parent
if (question_flag) {
//Stmt4090:Parent
if (! (flags & 1)) {
//Stmt4087:Leaf
(child->file)->update_status = (short)1;

//Stmt4088:Leaf
notice_finished_file(child->file);

//Stmt4089:Leaf
return;

     }

   }

//Stmt4196:Leaf
p = next_token(p);

//Stmt4197:Leaf
end = (char *)0;

//Stmt4198:Leaf
argv = construct_command_argv(p, & end, child->file, & child->sh_batch_file);

//Stmt4199:Parent
if ((unsigned long )end == (unsigned long )((void *)0)) {
//Stmt4091:Leaf
child->command_ptr = (char *)((void *)0);

   } else {
//Stmt4092:Leaf
tmp___0 = end;

//Stmt4093:Leaf
end ++;

//Stmt4094:Leaf
*tmp___0 = (char )'\000';

//Stmt4095:Leaf
child->command_ptr = end;

   }

//Stmt4200:Parent
if (touch_flag) {
//Stmt4099:Parent
if (! (flags & 1)) {
//Stmt4096:Leaf
free((void *)*(argv + 0));

//Stmt4097:Leaf
free((void *)((char *)argv));

//Stmt4098:Leaf
argv = (char **)0;

     }

   }

//Stmt4201:Parent
if ((unsigned long )argv == (unsigned long )((char **)0)) {
     next_command: 
     {
//Stmt4100:Leaf
tmp___1 = job_next_command(child);

}
//Stmt4105:Parent
if (tmp___1) {
//Stmt4101:Leaf
start_job_command(child);

     } else {
//Stmt4102:Leaf
set_command_state(child->file, 2);

//Stmt4103:Leaf
(child->file)->update_status = (short)0;

//Stmt4104:Leaf
notice_finished_file(child->file);

     }

//Stmt4106:Leaf
return;

   }

//Stmt4202:Parent
if (just_print_flag) {
//Stmt4111:Leaf
tmp___2 = "%s";

   } else
   {
//Stmt4112:Parent
if (! (flags & 2)) {
//Stmt4109:Parent
if (! silent_flag) {
//Stmt4107:Leaf
tmp___2 = "%s";

     } else {
//Stmt4108:Leaf
tmp___2 = (char const   *)((char *)0);

     }

   } else {
//Stmt4110:Leaf
tmp___2 = (char const   *)((char *)0);

   }
}


//Stmt4203:Leaf
message(0, tmp___2, p);

//Stmt4204:Parent
if (*(argv + 0)) {
//Stmt4124:Leaf
tmp___3 = strcmp((char const   *)*(argv + 0), "/bin/sh");

//Stmt4125:Parent
if (! tmp___3) {
//Stmt4123:Parent
if (*(argv + 1)) {
//Stmt4122:Parent
if ((int )*(*(argv + 1) + 0) == 45) {
//Stmt4121:Parent
if ((int )*(*(argv + 1) + 1) == 99) {
//Stmt4120:Parent
if ((int )*(*(argv + 1) + 2) == 0) {
//Stmt4119:Parent
if (*(argv + 2)) {
//Stmt4118:Parent
if ((int )*(*(argv + 2) + 0) == 58) {
//Stmt4117:Parent
if ((int )*(*(argv + 2) + 1) == 0) {
//Stmt4116:Parent
if ((unsigned long )*(argv + 3) == (unsigned long )((void *)0)) {
//Stmt4113:Leaf
free((void *)*(argv + 0));

//Stmt4114:Leaf
free((void *)((char *)argv));

//Stmt4115:Leaf
goto next_command;

                     }

                   }

                 }

               }

             }

           }

         }

       }

     }

   }

//Stmt4205:Leaf
commands_started ++;

//Stmt4206:Parent
if (just_print_flag) {
//Stmt4129:Parent
if (! (flags & 1)) {
//Stmt4126:Leaf
free((void *)*(argv + 0));

//Stmt4127:Leaf
free((void *)((char *)argv));

//Stmt4128:Leaf
goto next_command;

     }

   }

//Stmt4207:Leaf
fflush(stdout);

//Stmt4208:Leaf
fflush(stderr);

//Stmt4209:Parent
if (bad_stdin == -1) {
//Stmt4133:Leaf
tmp___4 = pipe((int *)(pd));

//Stmt4134:Parent
if (tmp___4 == 0) {
//Stmt4130:Leaf
close(pd[1]);

//Stmt4131:Leaf
bad_stdin = pd[0];

//Stmt4132:Leaf
fcntl(bad_stdin, 2, 1);

     }

   }

//Stmt4210:Leaf
child->good_stdin = (unsigned int )(! good_stdin_used);

//Stmt4211:Parent
if (child->good_stdin) {
//Stmt4135:Leaf
good_stdin_used = 1;

   }

//Stmt4212:Leaf
child->deleted = 0U;

//Stmt4213:Parent
if ((unsigned long )child->environment == (unsigned long )((char **)0)) {
//Stmt4136:Leaf
child->environment = target_environment(child->file);

   }

//Stmt4214:Parent
if (child->remote) {
//Stmt4162:Parent
if (child->good_stdin) {
//Stmt4137:Leaf
tmp___5 = 0;

     } else {
//Stmt4138:Leaf
tmp___5 = bad_stdin;

     }

//Stmt4163:Leaf
tmp___6 = start_remote_job(argv, child->environment, tmp___5, & is_remote, & id,
                                & used_stdin);

//Stmt4164:Parent
if (tmp___6) {
//Stmt4142:Leaf
goto run_local;

     } else {
//Stmt4143:Parent
if (child->good_stdin) {
//Stmt4141:Parent
if (! used_stdin) {
//Stmt4139:Leaf
child->good_stdin = 0U;

//Stmt4140:Leaf
good_stdin_used = 0;

         }

       }

//Stmt4144:Leaf
child->remote = (unsigned int )is_remote;

//Stmt4145:Leaf
child->pid = id;

     }

   } else {
     run_local: 
     {
//Stmt4146:Leaf
block_sigs();

}
//Stmt4165:Leaf
child->remote = 0U;

//Stmt4166:Leaf
parent_environ = environ;

//Stmt4167:Leaf
child->pid = vfork();

//Stmt4168:Leaf
environ = parent_environ;

//Stmt4169:Parent
if (child->pid == 0) {
//Stmt4156:Leaf
unblock_sigs();

//Stmt4157:Parent
if (! (flags & 1)) {
//Stmt4149:Parent
if (job_fds[0] >= 0) {
//Stmt4147:Leaf
close(job_fds[0]);

//Stmt4148:Leaf
close(job_fds[1]);

         }

       }

//Stmt4158:Parent
if (job_rfd >= 0) {
//Stmt4150:Leaf
close(job_rfd);

       }

//Stmt4159:Parent
if (child->good_stdin) {
//Stmt4151:Leaf
tmp___7 = 0;

       } else {
//Stmt4152:Leaf
tmp___7 = bad_stdin;

       }

//Stmt4160:Leaf
child_execute_job(tmp___7, 1, argv, child->environment);

     } else
     {
//Stmt4161:Parent
if (child->pid < 0) {
//Stmt4153:Leaf
unblock_sigs();

//Stmt4154:Leaf
perror_with_name((char *)"vfork", (char *)"");

//Stmt4155:Leaf
goto error;

     }
}


   }

//Stmt4215:Leaf
set_command_state(child->file, 2);

//Stmt4216:Leaf
free((void *)*(argv + 0));

//Stmt4217:Leaf
free((void *)((char *)argv));

//Stmt4218:Leaf
return;

   error: 
   {
//Stmt4170:Leaf
(child->file)->update_status = (short)2;

}
//Stmt4219:Leaf
notice_finished_file(child->file);

//Stmt4220:Leaf
return;

 }
}
 static int start_waiting_job(struct child *c ) 
 { 
//Stmt4247:Leaf
struct file *f ;

//Stmt4248:Leaf
int tmp ;

//Stmt4249:Leaf
int tmp___0 ;

//Stmt4250:Leaf
char *tmp___1 ;

//Stmt4251:Leaf
char const   *tmp___2 ;

//Stmt4252:Leaf
char *tmp___3 ;

 
   {
//Stmt4253:Leaf
f = c->file;

//Stmt4254:Leaf
tmp = start_remote_job_p(1);

//Stmt4255:Leaf
c->remote = (unsigned int )tmp;

//Stmt4256:Parent
if (! c->remote) {
//Stmt4227:Parent
if (job_slots_used > 0U) {
//Stmt4225:Leaf
tmp___0 = load_too_high();

//Stmt4226:Parent
if (tmp___0) {
//Stmt4221:Leaf
set_command_state(f, 2);

//Stmt4222:Leaf
c->next = waiting_jobs;

//Stmt4223:Leaf
waiting_jobs = c;

//Stmt4224:Leaf
return (0);

       }

     }

   }

//Stmt4257:Leaf
start_job_command(c);

//Stmt4258:Parent
switch ((unsigned int )f->command_state) {
   case 2U:; 
//Stmt4228:Leaf
c->next = children;

//Stmt4242:Parent
while (1) {
//Stmt4236:Parent
if (4 & db_level) {
//Stmt4232:Parent
if (c->remote) {
//Stmt4229:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), " (remote)", 5);

//Stmt4230:Leaf
tmp___2 = (char const   *)tmp___1;

       } else {
//Stmt4231:Leaf
tmp___2 = "";

       }

//Stmt4233:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "Putting child 0x%08lx (%s) PID %ld%s on the chain.\n",
                           5);

//Stmt4234:Leaf
printf((char const   * __restrict  )tmp___3, (unsigned long )c, (c->file)->name,
              (long )c->pid, tmp___2);

//Stmt4235:Leaf
fflush(stdout);

     }

//Stmt4237:Leaf
break;

   }

//Stmt4243:Leaf
children = c;

//Stmt4244:Leaf
job_slots_used ++;

//Stmt4245:Leaf
unblock_sigs();

   break;
   case 0U:; 
//Stmt4238:Leaf
f->update_status = (short)0;

   case 3U:; 
//Stmt4239:Leaf
notice_finished_file(f);

//Stmt4246:Leaf
free_child(c);

   break;
   default:; 
//Stmt4241:Parent
if (! ((unsigned int )f->command_state == 3U)) {
//Stmt4240:Leaf
__assert_fail("f->command_state == cs_finished", "job.c", 1313U, "start_waiting_job");

   }

   break;
   }

//Stmt4259:Leaf
return (1);

 }
}
 void new_job(struct file *file ) 
 { 
//Stmt4357:Leaf
register struct commands *cmds ;

//Stmt4358:Leaf
register struct child *c ;

//Stmt4359:Leaf
char **lines ;

//Stmt4360:Leaf
register unsigned int i ;

//Stmt4361:Leaf
char *tmp ;

//Stmt4362:Leaf
char *in ;

//Stmt4363:Leaf
char *out ;

//Stmt4364:Leaf
char *ref___0 ;

//Stmt4365:Leaf
char openparen ;

//Stmt4366:Leaf
char closeparen ;

//Stmt4367:Leaf
int tmp___0 ;

//Stmt4368:Leaf
int count ;

//Stmt4369:Leaf
char *p ;

//Stmt4370:Leaf
char *tmp___1 ;

//Stmt4371:Leaf
char *tmp___2 ;

//Stmt4372:Leaf
int quoted ;

//Stmt4373:Leaf
char *tmp___3 ;

//Stmt4374:Leaf
char *tmp___4 ;

//Stmt4375:Leaf
unsigned short const   **tmp___5 ;

//Stmt4376:Leaf
char *tmp___6 ;

//Stmt4377:Leaf
char *tmp___7 ;

//Stmt4378:Leaf
char *tmp___8 ;

//Stmt4379:Leaf
char *tmp___9 ;

//Stmt4380:Leaf
char token ;

//Stmt4381:Leaf
char *tmp___10 ;

//Stmt4382:Leaf
ssize_t tmp___11 ;

//Stmt4383:Leaf
char *tmp___12 ;

//Stmt4384:Leaf
int *tmp___13 ;

//Stmt4385:Leaf
int *tmp___14 ;

 
   {
//Stmt4386:Leaf
cmds = file->cmds;

//Stmt4387:Leaf
start_waiting_jobs();

//Stmt4388:Leaf
reap_children(0, 0);

//Stmt4389:Leaf
chop_commands(cmds);

//Stmt4390:Leaf
tmp = xmalloc((unsigned int )((unsigned long )cmds->ncommand_lines * sizeof(char *)));

//Stmt4391:Leaf
lines = (char **)tmp;

//Stmt4392:Leaf
i = 0U;

//Stmt4393:Parent
while (i < cmds->ncommand_lines) {
//Stmt4325:Leaf
out = *(cmds->command_lines + i);

//Stmt4326:Leaf
in = out;

//Stmt4327:Parent
while (1) {
//Stmt4317:Leaf
ref___0 = strchr((char const   *)in, '$');

//Stmt4318:Parent
if (! ((unsigned long )ref___0 != (unsigned long )((char *)0))) {
//Stmt4260:Leaf
break;

       }

//Stmt4319:Leaf
ref___0 ++;

//Stmt4320:Parent
if ((unsigned long )out != (unsigned long )in) {
//Stmt4261:Leaf
memmove((void *)out, (void const   *)in, (size_t )(ref___0 - in));

       }

//Stmt4321:Leaf
out += ref___0 - in;

//Stmt4322:Leaf
in = ref___0;

//Stmt4323:Parent
if ((int )*ref___0 == 40) {
//Stmt4315:Leaf
goto _L___1;

       } else
       {
//Stmt4316:Parent
if ((int )*ref___0 == 123) {
         _L___1: /* CIL Label */ 
         {
//Stmt4262:Leaf
openparen = *ref___0;

}
//Stmt4306:Parent
if ((int )openparen == 40) {
//Stmt4263:Leaf
tmp___0 = ')';

         } else {
//Stmt4264:Leaf
tmp___0 = '}';

         }

//Stmt4307:Leaf
closeparen = (char )tmp___0;

//Stmt4308:Leaf
tmp___1 = out;

//Stmt4309:Leaf
out ++;

//Stmt4310:Leaf
tmp___2 = in;

//Stmt4311:Leaf
in ++;

//Stmt4312:Leaf
*tmp___1 = *tmp___2;

//Stmt4313:Leaf
count = 0;

//Stmt4314:Parent
while ((int )*in != 0) {
//Stmt4305:Parent
if ((int )*in == (int )closeparen) {
//Stmt4303:Leaf
count --;

//Stmt4304:Parent
if (count < 0) {
//Stmt4265:Leaf
break;

             } else {
//Stmt4266:Leaf
goto _L___0;

             }

           } else
           _L___0: /* CIL Label */ 
           {
//Stmt4302:Parent
if ((int )*in == 92) {
//Stmt4296:Parent
if ((int )*(in + 1) == 10) {
//Stmt4289:Leaf
quoted = 0;

//Stmt4290:Leaf
p = in - 1;

//Stmt4291:Parent
while (1) {
//Stmt4270:Parent
if ((unsigned long )p > (unsigned long )ref___0) {
//Stmt4268:Parent
if (! ((int )*p == 92)) {
//Stmt4267:Leaf
break;

                   }

                 } else {
//Stmt4269:Leaf
break;

                 }

//Stmt4271:Leaf
quoted = ! quoted;

//Stmt4272:Leaf
p --;

               }

//Stmt4292:Parent
if (quoted) {
//Stmt4279:Leaf
tmp___3 = out;

//Stmt4280:Leaf
out ++;

//Stmt4281:Leaf
tmp___4 = in;

//Stmt4282:Leaf
in ++;

//Stmt4283:Leaf
*tmp___3 = *tmp___4;

               } else {
//Stmt4284:Leaf
in = next_token(in + 2);

//Stmt4285:Parent
while (1) {
//Stmt4277:Parent
if ((unsigned long )out > (unsigned long )ref___0) {
//Stmt4274:Leaf
tmp___5 = __ctype_b_loc();

//Stmt4275:Parent
if (! ((int const   )*(*tmp___5 + (int )*(out + -1)) & 1)) {
//Stmt4273:Leaf
break;

                     }

                   } else {
//Stmt4276:Leaf
break;

                   }

//Stmt4278:Leaf
out --;

                 }

//Stmt4286:Leaf
tmp___6 = out;

//Stmt4287:Leaf
out ++;

//Stmt4288:Leaf
*tmp___6 = (char )' ';

               }

             } else {
//Stmt4293:Leaf
goto _L;

             }

           } else {
             _L: /* CIL Label */ 
             {
//Stmt4295:Parent
if ((int )*in == (int )openparen) {
//Stmt4294:Leaf
count ++;

             }
}

//Stmt4297:Leaf
tmp___7 = out;

//Stmt4298:Leaf
out ++;

//Stmt4299:Leaf
tmp___8 = in;

//Stmt4300:Leaf
in ++;

//Stmt4301:Leaf
*tmp___7 = *tmp___8;

           }
}


         }

       }
}


     }

//Stmt4328:Parent
if ((unsigned long )out != (unsigned long )in) {
//Stmt4324:Leaf
strcpy((char * __restrict  )out, (char const   * __restrict  )in);

     }

//Stmt4329:Leaf
*(lines + i) = allocated_variable_expand_for_file(*(cmds->command_lines + i),
                                                       file);

//Stmt4330:Leaf
i ++;

   }

//Stmt4394:Leaf
tmp___9 = xmalloc((unsigned int )sizeof(struct child ));

//Stmt4395:Leaf
c = (struct child *)tmp___9;

//Stmt4396:Leaf
memset((void *)((char *)c), 0, sizeof(struct child ));

//Stmt4397:Leaf
c->file = file;

//Stmt4398:Leaf
c->command_lines = lines;

//Stmt4399:Leaf
c->sh_batch_file = (char *)((void *)0);

//Stmt4400:Leaf
job_next_command(c);

//Stmt4401:Parent
if (job_slots != 0U) {
//Stmt4351:Parent
while (job_slots_used == job_slots) {
//Stmt4331:Leaf
reap_children(1, 0);

     }

   } else
   {
//Stmt4352:Parent
if (job_fds[0] >= 0) {
//Stmt4350:Parent
while (! (! children)) {
//Stmt4344:Leaf
tmp___11 = read(job_rfd, (void *)(& token), (size_t )1);

//Stmt4345:Parent
if (tmp___11 == 1L) {
//Stmt4337:Parent
while (1) {
//Stmt4335:Parent
if (4 & db_level) {
//Stmt4332:Leaf
tmp___10 = dcgettext((char const   *)((void *)0), "Obtained token for child 0x%08lx (%s).\n",
                                  5);

//Stmt4333:Leaf
printf((char const   * __restrict  )tmp___10, (unsigned long )c, (c->file)->name);

//Stmt4334:Leaf
fflush(stdout);

           }

//Stmt4336:Leaf
break;

         }

//Stmt4338:Leaf
break;

       }

//Stmt4346:Leaf
tmp___13 = __errno_location();

//Stmt4347:Parent
if (*tmp___13 != 4) {
//Stmt4341:Leaf
tmp___14 = __errno_location();

//Stmt4342:Parent
if (*tmp___14 != 9) {
//Stmt4339:Leaf
tmp___12 = dcgettext((char const   *)((void *)0), "read jobs pipe", 5);

//Stmt4340:Leaf
pfatal_with_name(tmp___12);

         }

       }

//Stmt4348:Parent
if (job_rfd < 0) {
//Stmt4343:Leaf
job_rfd = dup(job_fds[0]);

       }

//Stmt4349:Leaf
reap_children(0, 0);

     }

   }
}


//Stmt4402:Leaf
start_waiting_job(c);

//Stmt4403:Parent
if (job_slots == 1U) {
//Stmt4355:Leaf
goto _L___2;

   } else
   {
//Stmt4356:Parent
if (not_parallel) {
     _L___2: /* CIL Label */ 
     {
//Stmt4354:Parent
while ((unsigned int )file->command_state == 2U) {
//Stmt4353:Leaf
reap_children(1, 0);

     }
}

   }
}


//Stmt4404:Leaf
return;

 }
}
 static int job_next_command(struct child *child ) 
 { 
//Stmt4414:Leaf
unsigned int tmp ;

 
   {
//Stmt4415:Parent
while (1) {
//Stmt4412:Parent
if (! ((unsigned long )child->command_ptr == (unsigned long )((char *)0))) {
//Stmt4406:Parent
if (! ((int )*(child->command_ptr) == 0)) {
//Stmt4405:Leaf
break;

       }

     }

//Stmt4413:Parent
if (child->command_line == ((child->file)->cmds)->ncommand_lines) {
//Stmt4407:Leaf
child->command_ptr = (char *)0;

//Stmt4408:Leaf
return (0);

     } else {
//Stmt4409:Leaf
tmp = child->command_line;

//Stmt4410:Leaf
(child->command_line) ++;

//Stmt4411:Leaf
child->command_ptr = *(child->command_lines + tmp);

     }

   }

//Stmt4416:Leaf
return (1);

 }
}
 static int lossage  =    -1;
 static int load_too_high(void) 
 { 
//Stmt4431:Leaf
double load ;

//Stmt4432:Leaf
char *tmp ;

//Stmt4433:Leaf
char *tmp___0 ;

//Stmt4434:Leaf
int *tmp___1 ;

//Stmt4435:Leaf
int *tmp___2 ;

//Stmt4436:Leaf
int *tmp___3 ;

//Stmt4437:Leaf
int tmp___4 ;

 
   {
//Stmt4438:Parent
if (max_load_average < (double )0) {
//Stmt4417:Leaf
return (0);

   }

//Stmt4439:Leaf
make_access();

//Stmt4440:Leaf
tmp___4 = getloadavg(& load, 1);

//Stmt4441:Parent
if (tmp___4 != 1) {
//Stmt4427:Parent
if (lossage == -1) {
//Stmt4424:Leaf
goto _L;

     } else {
//Stmt4425:Leaf
tmp___2 = __errno_location();

//Stmt4426:Parent
if (*tmp___2 != lossage) {
         _L: /* CIL Label */ 
         {
//Stmt4418:Leaf
tmp___1 = __errno_location();

}
//Stmt4423:Parent
if (*tmp___1 == 0) {
//Stmt4419:Leaf
tmp = dcgettext((char const   *)((void *)0), "cannot enforce load limits on this operating system",
                           5);

//Stmt4420:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp);

         } else {
//Stmt4421:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "cannot enforce load limit: ",
                               5);

//Stmt4422:Leaf
perror_with_name(tmp___0, (char *)"getloadavg");

         }

       }

     }

//Stmt4428:Leaf
tmp___3 = __errno_location();

//Stmt4429:Leaf
lossage = *tmp___3;

//Stmt4430:Leaf
load = (double )0;

   }

//Stmt4442:Leaf
user_access();

//Stmt4443:Leaf
return (load >= max_load_average);

 }
}
 void start_waiting_jobs(void) 
 { 
//Stmt4453:Leaf
struct child *job ;

//Stmt4454:Leaf
int tmp ;

 
   {
//Stmt4455:Parent
if ((unsigned long )waiting_jobs == (unsigned long )((struct child *)0)) {
//Stmt4444:Leaf
return;

   }

//Stmt4456:Parent
while (1) {
//Stmt4448:Leaf
reap_children(0, 0);

//Stmt4449:Leaf
job = waiting_jobs;

//Stmt4450:Leaf
waiting_jobs = job->next;

//Stmt4451:Leaf
tmp = start_waiting_job(job);

//Stmt4452:Parent
if (tmp) {
//Stmt4446:Parent
if (! ((unsigned long )waiting_jobs != (unsigned long )((struct child *)0))) {
//Stmt4445:Leaf
break;

       }

     } else {
//Stmt4447:Leaf
break;

     }

   }

//Stmt4457:Leaf
return;

 }
}
 void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) 
 { 
 
 
{
//Stmt4462:Parent
if (stdin_fd != 0) {
//Stmt4458:Leaf
dup2(stdin_fd, 0);

   }

//Stmt4463:Parent
if (stdout_fd != 1) {
//Stmt4459:Leaf
dup2(stdout_fd, 1);

   }

//Stmt4464:Parent
if (stdin_fd != 0) {
//Stmt4460:Leaf
close(stdin_fd);

   }

//Stmt4465:Parent
if (stdout_fd != 1) {
//Stmt4461:Leaf
close(stdout_fd);

   }

//Stmt4466:Leaf
exec_command(argv, envp);

//Stmt4467:Leaf
return;

 }
}
 void exec_command(char **argv , char **envp ) 
 { 
//Stmt4490:Leaf
int *tmp ;

//Stmt4491:Leaf
char *tmp___0 ;

//Stmt4492:Leaf
char *shell ;

//Stmt4493:Leaf
char **new_argv ;

//Stmt4494:Leaf
int argc ;

//Stmt4495:Leaf
void *tmp___1 ;

//Stmt4496:Leaf
char *tmp___2 ;

//Stmt4497:Leaf
int *tmp___3 ;

 
   {
//Stmt4498:Leaf
child_access();

//Stmt4499:Leaf
environ = envp;

//Stmt4500:Leaf
execvp((char const   *)*(argv + 0), (char * const  *)argv);

//Stmt4501:Leaf
tmp = __errno_location();

//Stmt4502:Parent
switch (*tmp) {
   case 2:; 
//Stmt4468:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "%s: Command not found", 5);

//Stmt4478:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, *(argv + 0));

   break;
   case 8:; 
//Stmt4469:Leaf
shell = getenv("SHELL");

//Stmt4479:Parent
if ((unsigned long )shell == (unsigned long )((char *)0)) {
//Stmt4470:Leaf
shell = default_shell;

   }

//Stmt4480:Leaf
argc = 1;

//Stmt4481:Parent
while ((unsigned long )*(argv + argc) != (unsigned long )((char *)0)) {
//Stmt4471:Leaf
argc ++;

   }

//Stmt4482:Leaf
tmp___1 = __builtin_alloca((unsigned long )((1 + argc) + 1) * sizeof(char *));

//Stmt4483:Leaf
new_argv = (char **)tmp___1;

//Stmt4484:Leaf
*(new_argv + 0) = shell;

//Stmt4485:Leaf
*(new_argv + 1) = *(argv + 0);

//Stmt4486:Parent
while (argc > 0) {
//Stmt4472:Leaf
*(new_argv + (1 + argc)) = *(argv + argc);

//Stmt4473:Leaf
argc --;

   }

//Stmt4487:Leaf
execvp((char const   *)shell, (char * const  *)new_argv);

//Stmt4488:Leaf
tmp___3 = __errno_location();

//Stmt4489:Parent
if (*tmp___3 == 2) {
//Stmt4474:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "%s: Shell program not found",
                         5);

//Stmt4475:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, shell);

   } else {
//Stmt4476:Leaf
perror_with_name((char *)"execvp: ", shell);

   }

   break;
   default:; 
//Stmt4477:Leaf
perror_with_name((char *)"execvp: ", *(argv + 0));

   break;
   }

//Stmt4503:Leaf
_exit(127);

 }
}
 static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                               char *ifs , char **batch_filename_ptr ) ;
 static char sh_chars[19]  = 
   {      (char )'#',      (char )';',      (char )'\"',      (char )'*', 
         (char )'?',      (char )'[',      (char )']',      (char )'&', 
         (char )'|',      (char )'<',      (char )'>',      (char )'(', 
         (char )')',      (char )'{',      (char )'}',      (char )'$', 
         (char )'`',      (char )'^',      (char )'\000'};
 static char *sh_cmds[25]  = 
   {      (char *)"cd",      (char *)"eval",      (char *)"exec",      (char *)"exit", 
         (char *)"login",      (char *)"logout",      (char *)"set",      (char *)"umask", 
         (char *)"wait",      (char *)"while",      (char *)"for",      (char *)"case", 
         (char *)"if",      (char *)":",      (char *)".",      (char *)"break", 
         (char *)"continue",      (char *)"export",      (char *)"read",      (char *)"readonly", 
         (char *)"shift",      (char *)"times",      (char *)"trap",      (char *)"switch", 
         (char *)0};
 static char minus_c[5]  = {      (char )' ',      (char )'-',      (char )'c',      (char )' ', 
         (char )'\000'};
 static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                               char *ifs , char **batch_filename_ptr ) 
 { 
//Stmt4690:Leaf
register int i ;

//Stmt4691:Leaf
register char *p ;

//Stmt4692:Leaf
register char *ap ;

//Stmt4693:Leaf
char *end ;

//Stmt4694:Leaf
int instring ;

//Stmt4695:Leaf
int word_has_equals ;

//Stmt4696:Leaf
int seen_nonequals ;

//Stmt4697:Leaf
int last_argument_was_empty ;

//Stmt4698:Leaf
char **new_argv ;

//Stmt4699:Leaf
unsigned short const   **tmp ;

//Stmt4700:Leaf
int tmp___0 ;

//Stmt4701:Leaf
size_t tmp___1 ;

//Stmt4702:Leaf
char *tmp___2 ;

//Stmt4703:Leaf
char *tmp___3 ;

//Stmt4704:Leaf
char *tmp___4 ;

//Stmt4705:Leaf
char *tmp___5 ;

//Stmt4706:Leaf
char *tmp___6 ;

//Stmt4707:Leaf
char *tmp___7 ;

//Stmt4708:Leaf
size_t tmp___8 ;

//Stmt4709:Leaf
char *tmp___9 ;

//Stmt4710:Leaf
char *tmp___10 ;

//Stmt4711:Leaf
char *tmp___11 ;

//Stmt4712:Leaf
char *tmp___12 ;

//Stmt4713:Leaf
register int j ;

//Stmt4714:Leaf
int tmp___13 ;

//Stmt4715:Leaf
char *tmp___14 ;

//Stmt4716:Leaf
char *tmp___15 ;

//Stmt4717:Leaf
register int j___0 ;

//Stmt4718:Leaf
int tmp___16 ;

//Stmt4719:Leaf
unsigned int shell_len ;

//Stmt4720:Leaf
size_t tmp___17 ;

//Stmt4721:Leaf
unsigned int line_len ;

//Stmt4722:Leaf
size_t tmp___18 ;

//Stmt4723:Leaf
char *new_line ;

//Stmt4724:Leaf
void *tmp___19 ;

//Stmt4725:Leaf
char *command_ptr ;

//Stmt4726:Leaf
size_t tmp___20 ;

//Stmt4727:Leaf
char *tmp___21 ;

//Stmt4728:Leaf
char *tmp___22 ;

//Stmt4729:Leaf
char *tmp___23 ;

//Stmt4730:Leaf
unsigned short const   **tmp___24 ;

//Stmt4731:Leaf
char *tmp___25 ;

//Stmt4732:Leaf
char *tmp___26 ;

//Stmt4733:Leaf
char *tmp___27 ;

 
   {
//Stmt4734:Leaf
new_argv = (char **)0;

//Stmt4735:Parent
if ((unsigned long )restp != (unsigned long )((void *)0)) {
//Stmt4504:Leaf
*restp = (char *)((void *)0);

   }

//Stmt4736:Parent
while (1) {
//Stmt4506:Leaf
tmp = __ctype_b_loc();

//Stmt4507:Parent
if (! ((int const   )*(*tmp + (int )*line) & 1)) {
//Stmt4505:Leaf
break;

     }

//Stmt4508:Leaf
line ++;

   }

//Stmt4737:Parent
if ((int )*line == 0) {
//Stmt4509:Leaf
return ((char **)0);

   }

//Stmt4738:Parent
if ((unsigned long )shell == (unsigned long )((char *)0)) {
//Stmt4511:Leaf
shell = default_shell;

   } else {
//Stmt4512:Leaf
tmp___0 = strcmp((char const   *)shell, (char const   *)(default_shell));

//Stmt4513:Parent
if (tmp___0) {
//Stmt4510:Leaf
goto slow;

     }

   }

//Stmt4739:Parent
if ((unsigned long )ifs != (unsigned long )((char *)0)) {
//Stmt4519:Leaf
ap = ifs;

//Stmt4520:Parent
while ((int )*ap != 0) {
//Stmt4517:Parent
if ((int )*ap != 32) {
//Stmt4516:Parent
if ((int )*ap != 9) {
//Stmt4515:Parent
if ((int )*ap != 10) {
//Stmt4514:Leaf
goto slow;

           }

         }

       }

//Stmt4518:Leaf
ap ++;

     }

   }

//Stmt4740:Leaf
tmp___1 = strlen((char const   *)line);

//Stmt4741:Leaf
i = (int )(tmp___1 + 1UL);

//Stmt4742:Leaf
tmp___2 = xmalloc((unsigned int )((unsigned long )i * sizeof(char *)));

//Stmt4743:Leaf
new_argv = (char **)tmp___2;

//Stmt4744:Leaf
tmp___4 = xmalloc((unsigned int )i);

//Stmt4745:Leaf
tmp___3 = tmp___4;

//Stmt4746:Leaf
*(new_argv + 0) = tmp___3;

//Stmt4747:Leaf
ap = tmp___3;

//Stmt4748:Leaf
end = ap + i;

//Stmt4749:Leaf
i = 0;

//Stmt4750:Leaf
last_argument_was_empty = 0;

//Stmt4751:Leaf
seen_nonequals = last_argument_was_empty;

//Stmt4752:Leaf
word_has_equals = seen_nonequals;

//Stmt4753:Leaf
instring = word_has_equals;

//Stmt4754:Leaf
p = line;

//Stmt4755:Parent
while ((int )*p != 0) {
//Stmt4613:Parent
if ((unsigned long )ap > (unsigned long )end) {
//Stmt4521:Leaf
abort();

     }

//Stmt4614:Parent
if (instring) {
       string_char: 
       {
//Stmt4550:Parent
if ((int )*p == instring) {
//Stmt4547:Leaf
instring = 0;

//Stmt4548:Parent
if ((unsigned long )ap == (unsigned long )*(new_argv + 0)) {
//Stmt4523:Leaf
last_argument_was_empty = 1;

         } else
         {
//Stmt4524:Parent
if ((int )*(ap - 1) == 0) {
//Stmt4522:Leaf
last_argument_was_empty = 1;

         }
}


       } else
       {
//Stmt4549:Parent
if ((int )*p == 92) {
//Stmt4546:Parent
if ((int )*(p + 1) == 10) {
//Stmt4525:Leaf
goto swallow_escaped_newline;

         } else {
//Stmt4526:Leaf
goto _L___0;

         }

       } else
       _L___0: /* CIL Label */ 
       {
//Stmt4545:Parent
if ((int )*p == 10) {
//Stmt4544:Parent
if ((unsigned long )restp != (unsigned long )((void *)0)) {
//Stmt4527:Leaf
*restp = p;

//Stmt4528:Leaf
goto end_of_line;

         } else {
//Stmt4529:Leaf
goto _L;

         }

       } else
       _L: /* CIL Label */ 
       {
//Stmt4543:Parent
if (instring == 34) {
//Stmt4538:Leaf
tmp___6 = strchr("\\$`", (int )*p);

//Stmt4539:Parent
if ((unsigned long )tmp___6 != (unsigned long )((char *)0)) {
//Stmt4534:Parent
if (unixy_shell) {
//Stmt4530:Leaf
goto slow;

           } else {
//Stmt4531:Leaf
tmp___5 = ap;

//Stmt4532:Leaf
ap ++;

//Stmt4533:Leaf
*tmp___5 = *p;

           }

         } else {
//Stmt4535:Leaf
tmp___5 = ap;

//Stmt4536:Leaf
ap ++;

//Stmt4537:Leaf
*tmp___5 = *p;

         }

       } else {
//Stmt4540:Leaf
tmp___5 = ap;

//Stmt4541:Leaf
ap ++;

//Stmt4542:Leaf
*tmp___5 = *p;

       }
}

}

}

}

     } else {
//Stmt4611:Leaf
tmp___15 = strchr((char const   *)(sh_chars), (int )*p);

//Stmt4612:Parent
if ((unsigned long )tmp___15 != (unsigned long )((char *)0)) {
//Stmt4609:Leaf
goto slow;

       } else {
//Stmt4610:Parent
switch ((int )*p) {
         case 61:; 
//Stmt4553:Parent
if (! seen_nonequals) {
//Stmt4552:Parent
if (unixy_shell) {
//Stmt4551:Leaf
goto slow;

           }

         }

//Stmt4592:Leaf
word_has_equals = 1;

//Stmt4593:Leaf
tmp___7 = ap;

//Stmt4594:Leaf
ap ++;

//Stmt4595:Leaf
*tmp___7 = (char )'=';

         break;
         case 92:; 
//Stmt4569:Parent
if ((int )*(p + 1) == 10) {
           swallow_escaped_newline: 
           {
//Stmt4554:Leaf
p += 2;

}
//Stmt4566:Parent
if ((int )*p == 9) {
//Stmt4555:Leaf
tmp___8 = strlen((char const   *)p);

//Stmt4556:Leaf
memmove((void *)p, (void const   *)(p + 1), tmp___8);

           }

//Stmt4567:Parent
if (instring) {
//Stmt4560:Leaf
goto string_char;

           } else
           {
//Stmt4561:Parent
if ((unsigned long )ap != (unsigned long )*(new_argv + i)) {
//Stmt4557:Leaf
goto end_of_arg;

           } else {
//Stmt4558:Leaf
tmp___9 = next_token(p);

//Stmt4559:Leaf
p = tmp___9 - 1;

           }
}


         } else
         {
//Stmt4568:Parent
if ((int )*(p + 1) != 0) {
//Stmt4562:Leaf
tmp___10 = ap;

//Stmt4563:Leaf
ap ++;

//Stmt4564:Leaf
p ++;

//Stmt4565:Leaf
*tmp___10 = *p;

         }
}


         break;
         case 34:; 
         case 39:; 
//Stmt4570:Leaf
instring = (int )*p;

         break;
         case 10:; 
//Stmt4576:Parent
if ((unsigned long )restp != (unsigned long )((void *)0)) {
//Stmt4571:Leaf
*restp = p;

//Stmt4572:Leaf
goto end_of_line;

         } else {
//Stmt4573:Leaf
tmp___11 = ap;

//Stmt4574:Leaf
ap ++;

//Stmt4575:Leaf
*tmp___11 = (char )'\n';

         }

         break;
         end_of_arg: 
         case 9:; 
         case 32:; 
//Stmt4577:Leaf
tmp___12 = ap;

//Stmt4596:Leaf
ap ++;

//Stmt4597:Leaf
*tmp___12 = (char )'\000';

//Stmt4598:Leaf
i ++;

//Stmt4599:Leaf
*(new_argv + i) = ap;

//Stmt4600:Leaf
last_argument_was_empty = 0;

//Stmt4601:Leaf
seen_nonequals |= ! word_has_equals;

//Stmt4602:Parent
if (word_has_equals) {
//Stmt4579:Parent
if (! seen_nonequals) {
//Stmt4578:Leaf
goto slow;

           }

         }

//Stmt4603:Leaf
word_has_equals = 0;

//Stmt4604:Parent
if (i == 1) {
//Stmt4589:Leaf
j = 0;

//Stmt4590:Parent
while ((unsigned long )sh_cmds[j] != (unsigned long )((char *)0)) {
//Stmt4587:Parent
if ((unsigned long )sh_cmds[j] == (unsigned long )*(new_argv + 0)) {
//Stmt4585:Leaf
goto slow;

             } else
             {
//Stmt4586:Parent
if ((int )*(sh_cmds[j]) == (int )*(*(new_argv + 0))) {
//Stmt4584:Parent
if ((int )*(sh_cmds[j]) == 0) {
//Stmt4581:Leaf
goto slow;

               } else {
//Stmt4582:Leaf
tmp___13 = strcmp((char const   *)(sh_cmds[j] + 1), (char const   *)(*(new_argv + 0) + 1));

//Stmt4583:Parent
if (! tmp___13) {
//Stmt4580:Leaf
goto slow;

                 }

               }

             }
}


//Stmt4588:Leaf
j ++;

           }

         }

//Stmt4605:Leaf
p = next_token(p);

//Stmt4606:Leaf
p --;

         break;
         default:; 
//Stmt4591:Leaf
tmp___14 = ap;

//Stmt4607:Leaf
ap ++;

//Stmt4608:Leaf
*tmp___14 = *p;

         break;
         }

       }

     }

//Stmt4615:Leaf
p ++;

   }

   end_of_line: 
   {
//Stmt4617:Parent
if (instring) {
//Stmt4616:Leaf
goto slow;

   }
}

//Stmt4756:Leaf
*ap = (char )'\000';

//Stmt4757:Parent
if ((int )*(*(new_argv + i) + 0) != 0) {
//Stmt4619:Leaf
i ++;

   } else
   {
//Stmt4620:Parent
if (last_argument_was_empty) {
//Stmt4618:Leaf
i ++;

   }
}


//Stmt4758:Leaf
*(new_argv + i) = (char *)0;

//Stmt4759:Parent
if (i == 1) {
//Stmt4630:Leaf
j___0 = 0;

//Stmt4631:Parent
while ((unsigned long )sh_cmds[j___0] != (unsigned long )((char *)0)) {
//Stmt4628:Parent
if ((unsigned long )sh_cmds[j___0] == (unsigned long )*(new_argv + 0)) {
//Stmt4626:Leaf
goto slow;

       } else
       {
//Stmt4627:Parent
if ((int )*(sh_cmds[j___0]) == (int )*(*(new_argv + 0))) {
//Stmt4625:Parent
if ((int )*(sh_cmds[j___0]) == 0) {
//Stmt4622:Leaf
goto slow;

         } else {
//Stmt4623:Leaf
tmp___16 = strcmp((char const   *)(sh_cmds[j___0] + 1), (char const   *)(*(new_argv + 0) + 1));

//Stmt4624:Parent
if (! tmp___16) {
//Stmt4621:Leaf
goto slow;

           }

         }

       }
}


//Stmt4629:Leaf
j___0 ++;

     }

   }

//Stmt4760:Parent
if ((unsigned long )*(new_argv + 0) == (unsigned long )((char *)0)) {
//Stmt4632:Leaf
return ((char **)0);

   } else {
//Stmt4633:Leaf
return (new_argv);

   }

   slow: ;
//Stmt4761:Parent
if ((unsigned long )new_argv != (unsigned long )((char **)0)) {
//Stmt4634:Leaf
free((void *)*(new_argv + 0));

//Stmt4635:Leaf
free((void *)new_argv);

   }

//Stmt4762:Leaf
tmp___17 = strlen((char const   *)shell);

//Stmt4763:Leaf
shell_len = (unsigned int )tmp___17;

//Stmt4764:Leaf
tmp___18 = strlen((char const   *)line);

//Stmt4765:Leaf
line_len = (unsigned int )tmp___18;

//Stmt4766:Leaf
tmp___19 = __builtin_alloca((((unsigned long )shell_len + (sizeof(minus_c) - 1UL)) + (unsigned long )(line_len * 2U)) + 1UL);

//Stmt4767:Leaf
new_line = (char *)tmp___19;

//Stmt4768:Leaf
command_ptr = (char *)((void *)0);

//Stmt4769:Leaf
ap = new_line;

//Stmt4770:Leaf
memmove((void *)ap, (void const   *)shell, (size_t )shell_len);

//Stmt4771:Leaf
ap += shell_len;

//Stmt4772:Leaf
memmove((void *)ap, (void const   *)(minus_c), sizeof(minus_c) - 1UL);

//Stmt4773:Leaf
ap += sizeof(minus_c) - 1UL;

//Stmt4774:Leaf
command_ptr = ap;

//Stmt4775:Leaf
p = line;

//Stmt4776:Parent
while ((int )*p != 0) {
//Stmt4681:Parent
if ((unsigned long )restp != (unsigned long )((void *)0)) {
//Stmt4656:Parent
if ((int )*p == 10) {
//Stmt4636:Leaf
*restp = p;

//Stmt4637:Leaf
break;

       } else {
//Stmt4638:Leaf
goto _L___1;

       }

     } else
     _L___1: /* CIL Label */ 
     {
//Stmt4655:Parent
if ((int )*p == 92) {
//Stmt4654:Parent
if ((int )*(p + 1) == 10) {
//Stmt4645:Leaf
p += 2;

//Stmt4646:Parent
if ((int )*p == 9) {
//Stmt4639:Leaf
tmp___20 = strlen((char const   *)p);

//Stmt4640:Leaf
memmove((void *)p, (void const   *)(p + 1), tmp___20);

         }

//Stmt4647:Leaf
p = next_token(p);

//Stmt4648:Leaf
p --;

//Stmt4649:Parent
if (unixy_shell) {
//Stmt4644:Parent
if (! batch_mode_shell) {
//Stmt4641:Leaf
tmp___21 = ap;

//Stmt4642:Leaf
ap ++;

//Stmt4643:Leaf
*tmp___21 = (char )'\\';

           }

         }

//Stmt4650:Leaf
tmp___22 = ap;

//Stmt4651:Leaf
ap ++;

//Stmt4652:Leaf
*tmp___22 = (char )' ';

//Stmt4653:Leaf
goto __Cont;

       }

     }
}


//Stmt4682:Parent
if (unixy_shell) {
//Stmt4679:Parent
if (! batch_mode_shell) {
//Stmt4678:Parent
if ((int )*p == 92) {
//Stmt4674:Leaf
tmp___23 = ap;

//Stmt4675:Leaf
ap ++;

//Stmt4676:Leaf
*tmp___23 = (char )'\\';

         } else
         {
//Stmt4677:Parent
if ((int )*p == 39) {
//Stmt4670:Leaf
tmp___23 = ap;

//Stmt4671:Leaf
ap ++;

//Stmt4672:Leaf
*tmp___23 = (char )'\\';

         } else
         {
//Stmt4673:Parent
if ((int )*p == 34) {
//Stmt4665:Leaf
tmp___23 = ap;

//Stmt4666:Leaf
ap ++;

//Stmt4667:Leaf
*tmp___23 = (char )'\\';

         } else {
//Stmt4668:Leaf
tmp___24 = __ctype_b_loc();

//Stmt4669:Parent
if ((int const   )*(*tmp___24 + (int )((unsigned char )*p)) & 8192) {
//Stmt4660:Leaf
tmp___23 = ap;

//Stmt4661:Leaf
ap ++;

//Stmt4662:Leaf
*tmp___23 = (char )'\\';

           } else {
//Stmt4663:Leaf
tmp___25 = strchr((char const   *)(sh_chars), (int )*p);

//Stmt4664:Parent
if ((unsigned long )tmp___25 != (unsigned long )((char *)0)) {
//Stmt4657:Leaf
tmp___23 = ap;

//Stmt4658:Leaf
ap ++;

//Stmt4659:Leaf
*tmp___23 = (char )'\\';

             }

           }

         }
}

}


       }

     }

//Stmt4683:Leaf
tmp___26 = ap;

//Stmt4684:Leaf
ap ++;

//Stmt4685:Leaf
*tmp___26 = *p;

     __Cont: /* CIL Label */ 
     {
//Stmt4680:Leaf
p ++;

}
   }

//Stmt4777:Parent
if ((unsigned long )ap == (unsigned long )(((new_line + shell_len) + sizeof(minus_c)) - 1)) {
//Stmt4686:Leaf
return ((char **)0);

   }

//Stmt4778:Leaf
*ap = (char )'\000';

//Stmt4779:Parent
if (unixy_shell) {
//Stmt4687:Leaf
new_argv = construct_command_argv_internal(new_line, (char **)((void *)0), (char *)0,
                                                (char *)0, (char **)0);

   } else {
//Stmt4688:Leaf
tmp___27 = dcgettext((char const   *)((void *)0), "%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n",
                          5);

//Stmt4689:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27, "job.c",
           2925);

   }

//Stmt4780:Leaf
return (new_argv);

 }
}
 char **construct_command_argv(char *line , char **restp , struct file *file , char **batch_filename_ptr ) 
 { 
//Stmt4781:Leaf
char *shell ;

//Stmt4782:Leaf
char *ifs ;

//Stmt4783:Leaf
char **argv ;

//Stmt4784:Leaf
int save ;

 
   {
//Stmt4785:Leaf
save = warn_undefined_variables_flag;

//Stmt4786:Leaf
warn_undefined_variables_flag = 0;

//Stmt4787:Leaf
shell = allocated_variable_expand_for_file((char *)"$(SHELL)", file);

//Stmt4788:Leaf
ifs = allocated_variable_expand_for_file((char *)"$(IFS)", file);

//Stmt4789:Leaf
warn_undefined_variables_flag = save;

//Stmt4790:Leaf
argv = construct_command_argv_internal(line, restp, shell, ifs, batch_filename_ptr);

//Stmt4791:Leaf
free((void *)shell);

//Stmt4792:Leaf
free((void *)ifs);

//Stmt4793:Leaf
return (argv);

 }
}
 #pragma merger("0","/tmp/cil-QjP850rb.i","-g,-O0")
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                   char const   *__locale ) ;
 char *textdomain(char const   *domainname ) ;
 char *bindtextdomain(char const   *domainname , char const   *dirname ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                 int __signo ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                 struct sigaction  const  * __restrict  __act ,
                                                                                 struct sigaction * __restrict  __oact ) ;
 extern struct _IO_FILE *stdin ;
 extern int fclose(FILE *__stream ) ;
 extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                                char const   *__modes ) ;
 extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
 extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                    , ...) ;
 extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
 extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                      FILE * __restrict  __s ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                                size_t __size ) ;
 extern char *optarg ;
 extern int optind ;
 extern int opterr ;
 extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
 extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
 void log_working_directory(int entering ) ;
 FILE *open_tmpfile(char **name , char const   *template ) ;
 void define_default_variables(void) ;
 void set_default_suffixes(void) ;
 void install_default_suffix_rules(void) ;
 void install_default_implicit_rules(void) ;
 void build_vpath_lists(void) ;
 void construct_include_path(char **arg_dirs ) ;
 int just_print_flag  ;
 int silent_flag  ;
 int keep_going_flag  ;
 int print_data_base_flag ;
 int touch_flag  ;
 int env_overrides ;
 int no_builtin_rules_flag ;
 int no_builtin_variables_flag ;
 int print_version_flag ;
 int print_directory_flag ;
 int warn_undefined_variables_flag  ;
 int posix_pedantic  ;
 int not_parallel  ;
 int clock_skew_detected  ;
 char *program  ;
 char *starting_directory  ;
 unsigned int makelevel  ;
 char *version_string ;
 char *remote_description ;
 char *tilde_expand(char *name ) ;
 struct dep *read_all_makefiles(char **makefiles___0 ) ;
 int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) ;
 struct file *default_goal_file  ;
 struct file *default_file  ;
 void define_automatic_variables(void) ;
 struct variable *try_variable_definition(struct floc  const  *flocp , char *line ,
                                          enum variable_origin origin , int target_var ) ;
 void count_implicit_rule_limits(void) ;
 void convert_to_pattern(void) ;
 extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                        struct option  const  *longopts , int *longind ) ;
 void remote_setup(void) ;
 void remote_cleanup(void) ;
 void print_variable_data_base(void) ;
 void print_rule_data_base(void) ;
 void print_vpath_data_base(void) ;
 static void print_data_base(void) ;
 static void print_version(void) ;
 static void decode_switches(int argc , char **argv , int env ) ;
 static void decode_env_switches(char *envar , unsigned int len ) ;
 static void define_makeflags(int all , int makefile ) ;
 static char *quote_for_env(char *out , char *in ) ;
 static struct stringlist *db_flags  ;
 static int debug_flag  =    0;
 int db_level  =    0;
 int env_overrides  =    0;
 int ignore_errors_flag  =    0;
 int print_data_base_flag  =    0;
 int question_flag  =    0;
 int no_builtin_rules_flag  =    0;
 int no_builtin_variables_flag  =    0;
 int default_keep_going_flag  =    0;
 int print_directory_flag  =    0;
 int inhibit_print_directory_flag  =    0;
 int print_version_flag  =    0;
 static struct stringlist *makefiles  =    (struct stringlist *)0;
 unsigned int job_slots  =    1U;
 unsigned int default_job_slots  =    1U;
 static unsigned int inf_jobs  =    0U;
 static struct stringlist *jobserver_fds  =    (struct stringlist *)0;
 int job_fds[2]  = {      -1,      -1};
 int job_rfd  =    -1;
 double max_load_average  =    - 1.0;
 double default_load_average  =    - 1.0;
 static struct stringlist *directories___0  =    (struct stringlist *)0;
 static struct stringlist *include_directories  =    (struct stringlist *)0;
 static struct stringlist *old_files  =    (struct stringlist *)0;
 static struct stringlist *new_files  =    (struct stringlist *)0;
 static int print_usage_flag  =    0;
 static struct command_switch  const  switches[29]  = 
   {      {'b', (enum __anonenum_type_56 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)0, (char *)0, (char *)"Ignored for compatibility"}, 
         {'C', (enum __anonenum_type_56 )2, (char *)(& directories___0), 0U, 0U, 0U, (char *)0,
       (char *)0, (char *)"directory", (char *)"DIRECTORY", (char *)"Change to DIRECTORY before doing anything"}, 
         {'d',
       (enum __anonenum_type_56 )0, (char *)(& debug_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)0, (char *)0, (char *)"Print lots of debugging information"}, 
         {128,
       (enum __anonenum_type_56 )2, (char *)(& db_flags), 1U, 1U, 0U, (char *)"basic",
       (char *)0, (char *)"debug", (char *)"FLAGS", (char *)"Print various types of debugging information"}, 
         {'e',
       (enum __anonenum_type_56 )0, (char *)(& env_overrides), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"environment-overrides", (char *)0, (char *)"Environment variables override makefiles"}, 
         {'f',
       (enum __anonenum_type_56 )2, (char *)(& makefiles), 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)"file", (char *)"FILE", (char *)"Read FILE as a makefile"}, 
         {'h', (enum __anonenum_type_56 )0, (char *)(& print_usage_flag), 0U, 0U, 0U,
       (char *)0, (char *)0, (char *)"help", (char *)0, (char *)"Print this message and exit"}, 
         {'i',
       (enum __anonenum_type_56 )0, (char *)(& ignore_errors_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"ignore-errors", (char *)0, (char *)"Ignore errors from commands"}, 
         {'I',
       (enum __anonenum_type_56 )2, (char *)(& include_directories), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"include-dir", (char *)"DIRECTORY", (char *)"Search DIRECTORY for included makefiles"}, 
         {'j',
       (enum __anonenum_type_56 )3, (char *)(& job_slots), 1U, 1U, 0U, (char *)(& inf_jobs),
       (char *)(& default_job_slots), (char *)"jobs", (char *)"N", (char *)"Allow N jobs at once; infinite jobs with no arg"}, 
         {129,
       (enum __anonenum_type_56 )2, (char *)(& jobserver_fds), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"jobserver-fds", (char *)0, (char *)0}, 
         {'k', (enum __anonenum_type_56 )0, (char *)(& keep_going_flag), 1U, 1U, 0U, (char *)0,
       (char *)(& default_keep_going_flag), (char *)"keep-going", (char *)0, (char *)"Keep going when some targets can\'t be made"}, 
         {'l',
       (enum __anonenum_type_56 )4, (char *)(& max_load_average), 1U, 1U, 0U, (char *)(& default_load_average),
       (char *)(& default_load_average), (char *)"load-average", (char *)"N", (char *)"Don\'t start multiple jobs unless load is below N"}, 
         {'m',
       (enum __anonenum_type_56 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0,
       (char *)0, (char *)"-b"}, 
         {'n', (enum __anonenum_type_56 )0, (char *)(& just_print_flag), 1U, 1U, 1U, (char *)0,
       (char *)0, (char *)"just-print", (char *)0, (char *)"Don\'t actually run any commands; just print them"}, 
         {'o',
       (enum __anonenum_type_56 )2, (char *)(& old_files), 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)"old-file", (char *)"FILE", (char *)"Consider FILE to be very old and don\'t remake it"}, 
         {'p',
       (enum __anonenum_type_56 )0, (char *)(& print_data_base_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"print-data-base", (char *)0, (char *)"Print make\'s internal database"}, 
         {'q',
       (enum __anonenum_type_56 )0, (char *)(& question_flag), 1U, 1U, 1U, (char *)0,
       (char *)0, (char *)"question", (char *)0, (char *)"Run no commands; exit status says if up to date"}, 
         {'r',
       (enum __anonenum_type_56 )0, (char *)(& no_builtin_rules_flag), 1U, 1U, 0U,
       (char *)0, (char *)0, (char *)"no-builtin-rules", (char *)0, (char *)"Disable the built-in implicit rules"}, 
         {'R',
       (enum __anonenum_type_56 )0, (char *)(& no_builtin_variables_flag), 1U, 1U,
       0U, (char *)0, (char *)0, (char *)"no-builtin-variables", (char *)0, (char *)"Disable the built-in variable settings"}, 
         {'s',
       (enum __anonenum_type_56 )0, (char *)(& silent_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"silent", (char *)0, (char *)"Don\'t echo commands"}, 
         {'S', (enum __anonenum_type_56 )1, (char *)(& keep_going_flag), 1U, 1U, 0U, (char *)0,
       (char *)(& default_keep_going_flag), (char *)"no-keep-going", (char *)0, (char *)"Turns off -k"}, 
         {'t',
       (enum __anonenum_type_56 )0, (char *)(& touch_flag), 1U, 1U, 1U, (char *)0,
       (char *)0, (char *)"touch", (char *)0, (char *)"Touch targets instead of remaking them"}, 
         {'v',
       (enum __anonenum_type_56 )0, (char *)(& print_version_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"version", (char *)0, (char *)"Print the version number of make and exit"}, 
         {'w',
       (enum __anonenum_type_56 )0, (char *)(& print_directory_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"print-directory", (char *)0, (char *)"Print the current directory"}, 
         {130,
       (enum __anonenum_type_56 )0, (char *)(& inhibit_print_directory_flag), 1U, 1U,
       0U, (char *)0, (char *)0, (char *)"no-print-directory", (char *)0, (char *)"Turn off -w, even if it was turned on implicitly"}, 
         {'W',
       (enum __anonenum_type_56 )2, (char *)(& new_files), 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)"what-if", (char *)"FILE", (char *)"Consider FILE to be infinitely new"}, 
         {131,
       (enum __anonenum_type_56 )0, (char *)(& warn_undefined_variables_flag), 1U,
       1U, 0U, (char *)0, (char *)0, (char *)"warn-undefined-variables", (char *)0,
       (char *)"Warn when an undefined variable is referenced"}, 
         {'\000', 0U, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0, (char *)0,
       (char *)0}};
 static struct option long_option_aliases[9]  = 
   {      {"quiet", 0, (int *)0, 's'}, 
         {"stop", 0, (int *)0, 'S'}, 
         {"new-file", 1, (int *)0, 'W'}, 
         {"assume-new", 1, (int *)0, 'W'}, 
         {"assume-old", 1, (int *)0, 'o'}, 
         {"max-load", 2, (int *)0, 'l'}, 
         {"dry-run", 0, (int *)0, 'n'}, 
         {"recon", 0, (int *)0, 'n'}, 
         {"makefile", 1, (int *)0, 'f'}};
 static struct dep *goals  ;
 static struct dep *lastgoal  ;
 static struct command_variable *command_variables  ;
 char *directory_before_chdir  ;
 sigset_t fatal_signal_set  ;
 static struct file *enter_command_line_file(char *name ) 
 { 
//Stmt4814:Leaf
char *tmp ;

//Stmt4815:Leaf
char *expanded ;

//Stmt4816:Leaf
char *tmp___0 ;

//Stmt4817:Leaf
char *tmp___1 ;

//Stmt4818:Leaf
struct file *tmp___2 ;

 
   {
//Stmt4819:Parent
if ((int )*(name + 0) == 0) {
//Stmt4794:Leaf
tmp = dcgettext((char const   *)((void *)0), "empty string invalid as file name",
                     5);

//Stmt4795:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp);

   }

//Stmt4820:Parent
if ((int )*(name + 0) == 126) {
//Stmt4797:Leaf
tmp___0 = tilde_expand(name);

//Stmt4798:Leaf
expanded = tmp___0;

//Stmt4799:Parent
if ((unsigned long )expanded != (unsigned long )((char *)0)) {
//Stmt4796:Leaf
name = expanded;

     }

   }

//Stmt4821:Parent
while (1) {
//Stmt4806:Parent
if ((int )*(name + 0) == 46) {
//Stmt4803:Parent
if ((int )*(name + 1) == 47) {
//Stmt4801:Parent
if (! ((int )*(name + 2) != 0)) {
//Stmt4800:Leaf
break;

         }

       } else {
//Stmt4802:Leaf
break;

       }

     } else {
//Stmt4804:Leaf
break;

     }

//Stmt4807:Leaf
name += 2;

//Stmt4808:Parent
while ((int )*name == 47) {
//Stmt4805:Leaf
name ++;

     }

   }

//Stmt4822:Parent
if ((int )*name == 0) {
//Stmt4812:Parent
while (1) {
//Stmt4810:Leaf
name --;

//Stmt4811:Parent
if (! ((int )*(name + 0) != 46)) {
//Stmt4809:Leaf
break;

       }

     }

//Stmt4813:Leaf
*(name + 2) = (char )'\000';

   }

//Stmt4823:Leaf
tmp___1 = xstrdup((char const   *)name);

//Stmt4824:Leaf
tmp___2 = enter_file(tmp___1);

//Stmt4825:Leaf
return (tmp___2);

 }
}
 static void debug_signal_handler(int sig ) 
 { 
 
 
{
//Stmt4828:Parent
if (db_level) {
//Stmt4826:Leaf
db_level = 0;

   } else {
//Stmt4827:Leaf
db_level = 1;

   }

//Stmt4829:Leaf
return;

 }
}
 static void decode_debug_flags(void) 
 { 
//Stmt4856:Leaf
char **pp ;

//Stmt4857:Leaf
char const   *p ;

//Stmt4858:Leaf
int tmp ;

//Stmt4859:Leaf
char *tmp___0 ;

 
   {
//Stmt4860:Parent
if (debug_flag) {
//Stmt4830:Leaf
db_level = 4095;

   }

//Stmt4861:Parent
if (! db_flags) {
//Stmt4831:Leaf
return;

   }

//Stmt4862:Leaf
pp = db_flags->list;

//Stmt4863:Parent
while (*pp) {
//Stmt4853:Leaf
p = (char const   *)*pp;

//Stmt4854:Parent
while (1) {
//Stmt4848:Leaf
tmp = tolower((int )*(p + 0));

//Stmt4849:Parent
switch (tmp) {
       case 97:; 
//Stmt4832:Leaf
db_level |= 4095;

       break;
       case 98:; 
//Stmt4833:Leaf
db_level |= 1;

       break;
       case 105:; 
//Stmt4834:Leaf
db_level |= 9;

       break;
       case 106:; 
//Stmt4835:Leaf
db_level |= 4;

       break;
       case 109:; 
//Stmt4836:Leaf
db_level |= 257;

       break;
       case 118:; 
//Stmt4837:Leaf
db_level |= 3;

       break;
       default:; 
//Stmt4838:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "unknown debug level specification `%s\'",
                           5);

//Stmt4839:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, p);

       }

//Stmt4850:Parent
while (1) {
//Stmt4844:Leaf
p ++;

//Stmt4845:Parent
if (! ((int const   )*p != 0)) {
//Stmt4840:Leaf
break;

         }

//Stmt4846:Parent
if ((int const   )*p == 44) {
//Stmt4842:Leaf
break;

         } else
         {
//Stmt4843:Parent
if ((int const   )*p == 32) {
//Stmt4841:Leaf
break;

         }
}


       }

//Stmt4851:Parent
if ((int const   )*p == 0) {
//Stmt4847:Leaf
break;

       }

//Stmt4852:Leaf
p ++;

     }

//Stmt4855:Leaf
pp ++;

   }

//Stmt4864:Leaf
return;

 }
}
 FILE *open_tmpfile(char **name , char const   *template ) 
 { 
//Stmt4866:Leaf
int fd ;

//Stmt4867:Leaf
size_t tmp ;

//Stmt4868:Leaf
FILE *tmp___0 ;

 
   {
//Stmt4869:Leaf
tmp = strlen(template);

//Stmt4870:Leaf
*name = xmalloc((unsigned int )(tmp + 1UL));

//Stmt4871:Leaf
strcpy((char * __restrict  )*name, (char const   * __restrict  )template);

//Stmt4872:Leaf
fd = mkstemp(*name);

//Stmt4873:Parent
if (fd == -1) {
//Stmt4865:Leaf
return ((FILE *)0);

   }

//Stmt4874:Leaf
tmp___0 = fdopen(fd, "w");

//Stmt4875:Leaf
return (tmp___0);

 }
}
 int main(int argc , char **argv , char **envp ) ;
 static char *stdin_nm  =    (char *)0;
 int main(int argc , char **argv , char **envp ) 
 { 
//Stmt5293:Leaf
register struct file *f ;

//Stmt5294:Leaf
register unsigned int i ;

//Stmt5295:Leaf
char **p ;

//Stmt5296:Leaf
struct dep *read_makefiles___0 ;

//Stmt5297:Leaf
char current_directory[4096] ;

//Stmt5298:Leaf
__sighandler_t tmp ;

//Stmt5299:Leaf
__sighandler_t tmp___0 ;

//Stmt5300:Leaf
__sighandler_t tmp___1 ;

//Stmt5301:Leaf
__sighandler_t tmp___2 ;

//Stmt5302:Leaf
__sighandler_t tmp___3 ;

//Stmt5303:Leaf
__sighandler_t tmp___4 ;

//Stmt5304:Leaf
char *tmp___5 ;

//Stmt5305:Leaf
int do_not_define ;

//Stmt5306:Leaf
register char *ep ;

//Stmt5307:Leaf
struct variable *tmp___6 ;

//Stmt5308:Leaf
char *tmp___7 ;

//Stmt5309:Leaf
struct command_variable *cv ;

//Stmt5310:Leaf
struct variable *v ;

//Stmt5311:Leaf
unsigned int len ;

//Stmt5312:Leaf
char *value ;

//Stmt5313:Leaf
char *p___0 ;

//Stmt5314:Leaf
size_t tmp___8 ;

//Stmt5315:Leaf
size_t tmp___9 ;

//Stmt5316:Leaf
void *tmp___10 ;

//Stmt5317:Leaf
char *tmp___11 ;

//Stmt5318:Leaf
char *tmp___12 ;

//Stmt5319:Leaf
char *tmp___13 ;

//Stmt5320:Leaf
char *dir ;

//Stmt5321:Leaf
char *expanded ;

//Stmt5322:Leaf
char *tmp___14 ;

//Stmt5323:Leaf
int tmp___15 ;

//Stmt5324:Leaf
struct variable *v___0 ;

//Stmt5325:Leaf
struct variable *tmp___16 ;

//Stmt5326:Leaf
int tmp___17 ;

//Stmt5327:Leaf
char **tmp___18 ;

//Stmt5328:Leaf
char *tmp___19 ;

//Stmt5329:Leaf
register unsigned int i___0 ;

//Stmt5330:Leaf
FILE *outfile ;

//Stmt5331:Leaf
char *tmp___20 ;

//Stmt5332:Leaf
char *tmp___21 ;

//Stmt5333:Leaf
char buf___1[2048] ;

//Stmt5334:Leaf
unsigned int n ;

//Stmt5335:Leaf
size_t tmp___22 ;

//Stmt5336:Leaf
char *tmp___23 ;

//Stmt5337:Leaf
size_t tmp___24 ;

//Stmt5338:Leaf
int tmp___25 ;

//Stmt5339:Leaf
struct sigaction sa ;

//Stmt5340:Leaf
char **tmp___26 ;

//Stmt5341:Leaf
char *cp ;

//Stmt5342:Leaf
char *tmp___27 ;

//Stmt5343:Leaf
int tmp___28 ;

//Stmt5344:Leaf
char *tmp___29 ;

//Stmt5345:Leaf
int tmp___30 ;

//Stmt5346:Leaf
char *tmp___31 ;

//Stmt5347:Leaf
char *tmp___32 ;

//Stmt5348:Leaf
int *tmp___33 ;

//Stmt5349:Leaf
char *tmp___34 ;

//Stmt5350:Leaf
char c ;

//Stmt5351:Leaf
char *tmp___35 ;

//Stmt5352:Leaf
int tmp___36 ;

//Stmt5353:Leaf
char *tmp___37 ;

//Stmt5354:Leaf
int *tmp___38 ;

//Stmt5355:Leaf
ssize_t tmp___39 ;

//Stmt5356:Leaf
char *tmp___40 ;

//Stmt5357:Leaf
char *tmp___41 ;

//Stmt5358:Leaf
uintmax_t tmp___42 ;

//Stmt5359:Leaf
uintmax_t tmp___43 ;

//Stmt5360:Leaf
uintmax_t *makefile_mtimes ;

//Stmt5361:Leaf
unsigned int mm_idx ;

//Stmt5362:Leaf
char **nargv ;

//Stmt5363:Leaf
int nargc ;

//Stmt5364:Leaf
int orig_db_level ;

//Stmt5365:Leaf
char *tmp___44 ;

//Stmt5366:Leaf
register struct dep *d ;

//Stmt5367:Leaf
register struct dep *last ;

//Stmt5368:Leaf
register struct file *f___0 ;

//Stmt5369:Leaf
char *tmp___45 ;

//Stmt5370:Leaf
char *tmp___46 ;

//Stmt5371:Leaf
unsigned int tmp___47 ;

//Stmt5372:Leaf
uintmax_t tmp___48 ;

//Stmt5373:Leaf
int tmp___49 ;

//Stmt5374:Leaf
int any_remade ;

//Stmt5375:Leaf
int any_failed ;

//Stmt5376:Leaf
register unsigned int i___1 ;

//Stmt5377:Leaf
struct dep *d___0 ;

//Stmt5378:Leaf
uintmax_t tmp___50 ;

//Stmt5379:Leaf
uintmax_t tmp___51 ;

//Stmt5380:Leaf
uintmax_t mtime ;

//Stmt5381:Leaf
char *tmp___52 ;

//Stmt5382:Leaf
uintmax_t tmp___53 ;

//Stmt5383:Leaf
int tmp___54 ;

//Stmt5384:Leaf
char *tmp___55 ;

//Stmt5385:Leaf
char *tmp___56 ;

//Stmt5386:Leaf
char *tmp___57 ;

//Stmt5387:Leaf
char *tmp___58 ;

//Stmt5388:Leaf
register unsigned int i___2 ;

//Stmt5389:Leaf
register unsigned int j ;

//Stmt5390:Leaf
char *p___1 ;

//Stmt5391:Leaf
int tmp___59 ;

//Stmt5392:Leaf
char *tmp___60 ;

//Stmt5393:Leaf
int tmp___61 ;

//Stmt5394:Leaf
char bad ;

//Stmt5395:Leaf
int tmp___62 ;

//Stmt5396:Leaf
char *tmp___63 ;

//Stmt5397:Leaf
char *sgi_loses ;

//Stmt5398:Leaf
void *tmp___64 ;

//Stmt5399:Leaf
int tmp___65 ;

//Stmt5400:Leaf
char **p___2 ;

//Stmt5401:Leaf
char *tmp___66 ;

//Stmt5402:Leaf
char *tmp___67 ;

//Stmt5403:Leaf
int tmp___68 ;

//Stmt5404:Leaf
int *tmp___69 ;

//Stmt5405:Leaf
int status ;

//Stmt5406:Leaf
char *tmp___70 ;

//Stmt5407:Leaf
char *tmp___71 ;

//Stmt5408:Leaf
char *tmp___72 ;

//Stmt5409:Leaf
char *tmp___73 ;

//Stmt5410:Leaf
int tmp___74 ;

//Stmt5411:Leaf
char *tmp___75 ;

 
   {
//Stmt5412:Leaf
default_goal_file = (struct file *)0;

//Stmt5413:Leaf
reading_file = (struct floc  const  *)0;

//Stmt5414:Leaf
setlocale(6, "");

//Stmt5415:Leaf
bindtextdomain("make", "/usr/local/share/locale");

//Stmt5416:Leaf
textdomain("make");

//Stmt5417:Leaf
sigemptyset(& fatal_signal_set);

//Stmt5418:Leaf
tmp = signal(1, & fatal_error_signal);

//Stmt5419:Parent
if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))1)) {
//Stmt4876:Leaf
signal(1, (void (*)(int  ))1);

   } else {
//Stmt4877:Leaf
sigaddset(& fatal_signal_set, 1);

   }

//Stmt5420:Leaf
tmp___0 = signal(3, & fatal_error_signal);

//Stmt5421:Parent
if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
//Stmt4878:Leaf
signal(3, (void (*)(int  ))1);

   } else {
//Stmt4879:Leaf
sigaddset(& fatal_signal_set, 3);

   }

//Stmt5422:Leaf
tmp___1 = signal(2, & fatal_error_signal);

//Stmt5423:Parent
if ((unsigned long )tmp___1 == (unsigned long )((void (*)(int  ))1)) {
//Stmt4880:Leaf
signal(2, (void (*)(int  ))1);

   } else {
//Stmt4881:Leaf
sigaddset(& fatal_signal_set, 2);

   }

//Stmt5424:Leaf
tmp___2 = signal(15, & fatal_error_signal);

//Stmt5425:Parent
if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))1)) {
//Stmt4882:Leaf
signal(15, (void (*)(int  ))1);

   } else {
//Stmt4883:Leaf
sigaddset(& fatal_signal_set, 15);

   }

//Stmt5426:Leaf
tmp___3 = signal(24, & fatal_error_signal);

//Stmt5427:Parent
if ((unsigned long )tmp___3 == (unsigned long )((void (*)(int  ))1)) {
//Stmt4884:Leaf
signal(24, (void (*)(int  ))1);

   } else {
//Stmt4885:Leaf
sigaddset(& fatal_signal_set, 24);

   }

//Stmt5428:Leaf
tmp___4 = signal(25, & fatal_error_signal);

//Stmt5429:Parent
if ((unsigned long )tmp___4 == (unsigned long )((void (*)(int  ))1)) {
//Stmt4886:Leaf
signal(25, (void (*)(int  ))1);

   } else {
//Stmt4887:Leaf
sigaddset(& fatal_signal_set, 25);

   }

//Stmt5430:Leaf
signal(17, (void (*)(int  ))0);

//Stmt5431:Leaf
setlinebuf(stdout);

//Stmt5432:Parent
if ((unsigned long )*(argv + 0) == (unsigned long )((char *)0)) {
//Stmt4888:Leaf
*(argv + 0) = (char *)"";

   }

//Stmt5433:Parent
if ((int )*(*(argv + 0) + 0) == 0) {
//Stmt4891:Leaf
program = (char *)"make";

   } else {
//Stmt4892:Leaf
program = strrchr((char const   *)*(argv + 0), '/');

//Stmt4893:Parent
if ((unsigned long )program == (unsigned long )((char *)0)) {
//Stmt4889:Leaf
program = *(argv + 0);

     } else {
//Stmt4890:Leaf
program ++;

     }

   }

//Stmt5434:Leaf
user_access();

//Stmt5435:Leaf
tmp___5 = getcwd(current_directory, (size_t )4096);

//Stmt5436:Parent
if ((unsigned long )tmp___5 == (unsigned long )((char *)0)) {
//Stmt4894:Leaf
perror_with_name((char *)"getcwd: ", (char *)"");

//Stmt4895:Leaf
current_directory[0] = (char )'\000';

//Stmt4896:Leaf
directory_before_chdir = (char *)0;

   } else {
//Stmt4897:Leaf
directory_before_chdir = xstrdup((char const   *)(current_directory));

   }

//Stmt5437:Leaf
i = 0U;

//Stmt5438:Parent
while ((unsigned long )*(envp + i) != (unsigned long )((char *)0)) {
//Stmt4901:Leaf
ep = *(envp + i);

//Stmt4902:Leaf
do_not_define = 0;

//Stmt4903:Parent
while ((int )*ep != 61) {
//Stmt4898:Leaf
ep ++;

     }

//Stmt4904:Parent
if (! do_not_define) {
//Stmt4899:Leaf
tmp___6 = define_variable_in_set(*(envp + i), (unsigned int )(ep - *(envp + i)),
                                        ep + 1, (enum variable_origin )1, 1, current_variable_set_list->set,
                                        (struct floc  const  *)((struct floc *)0));

//Stmt4900:Leaf
tmp___6->export = (enum variable_export )0;

     }

//Stmt4905:Leaf
i ++;

   }

//Stmt5439:Leaf
decode_env_switches((char *)"MAKEFLAGS", 9U);

//Stmt5440:Leaf
decode_switches(argc, argv, 0);

//Stmt5441:Leaf
decode_debug_flags();

//Stmt5442:Parent
if (print_version_flag) {
//Stmt4909:Leaf
print_version();

   } else
   {
//Stmt4910:Parent
if (print_data_base_flag) {
//Stmt4907:Leaf
print_version();

   } else
   {
//Stmt4908:Parent
if (db_level) {
//Stmt4906:Leaf
print_version();

   }
}

}


//Stmt5443:Parent
if (print_version_flag) {
//Stmt4911:Leaf
die(0);

   }

//Stmt5444:Parent
if ((int )current_directory[0] != 0) {
//Stmt4916:Parent
if ((unsigned long )*(argv + 0) != (unsigned long )((char *)0)) {
//Stmt4915:Parent
if ((int )*(*(argv + 0) + 0) != 47) {
//Stmt4913:Leaf
tmp___7 = strchr((char const   *)*(argv + 0), '/');

//Stmt4914:Parent
if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
//Stmt4912:Leaf
*(argv + 0) = concat(current_directory, (char *)"/", *(argv + 0));

         }

       }

     }

   }

//Stmt5445:Leaf
define_variable_in_set((char *)"MAKE_COMMAND", 12U, *(argv + 0), (enum variable_origin )0,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt5446:Leaf
define_variable_in_set((char *)"MAKE", 4U, (char *)"$(MAKE_COMMAND)", (enum variable_origin )0,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt5447:Parent
if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
//Stmt4941:Leaf
len = 0U;

//Stmt4942:Leaf
cv = command_variables;

//Stmt4943:Parent
while ((unsigned long )cv != (unsigned long )((struct command_variable *)0)) {
//Stmt4918:Leaf
v = cv->variable;

//Stmt4919:Leaf
tmp___8 = strlen((char const   *)v->name);

//Stmt4920:Leaf
len = (unsigned int )((size_t )len + 2UL * tmp___8);

//Stmt4921:Parent
if (! v->recursive) {
//Stmt4917:Leaf
len ++;

       }

//Stmt4922:Leaf
len ++;

//Stmt4923:Leaf
tmp___9 = strlen((char const   *)v->value);

//Stmt4924:Leaf
len = (unsigned int )((size_t )len + 2UL * tmp___9);

//Stmt4925:Leaf
len ++;

//Stmt4926:Leaf
cv = cv->next;

     }

//Stmt4944:Leaf
tmp___10 = __builtin_alloca((unsigned long )len);

//Stmt4945:Leaf
value = (char *)tmp___10;

//Stmt4946:Leaf
p___0 = value;

//Stmt4947:Leaf
cv = command_variables;

//Stmt4948:Parent
while ((unsigned long )cv != (unsigned long )((struct command_variable *)0)) {
//Stmt4930:Leaf
v = cv->variable;

//Stmt4931:Leaf
p___0 = quote_for_env(p___0, v->name);

//Stmt4932:Parent
if (! v->recursive) {
//Stmt4927:Leaf
tmp___11 = p___0;

//Stmt4928:Leaf
p___0 ++;

//Stmt4929:Leaf
*tmp___11 = (char )':';

       }

//Stmt4933:Leaf
tmp___12 = p___0;

//Stmt4934:Leaf
p___0 ++;

//Stmt4935:Leaf
*tmp___12 = (char )'=';

//Stmt4936:Leaf
p___0 = quote_for_env(p___0, v->value);

//Stmt4937:Leaf
tmp___13 = p___0;

//Stmt4938:Leaf
p___0 ++;

//Stmt4939:Leaf
*tmp___13 = (char )' ';

//Stmt4940:Leaf
cv = cv->next;

     }

//Stmt4949:Leaf
*(p___0 + -1) = (char )'\000';

//Stmt4950:Leaf
define_variable_in_set((char *)"-*-command-variables-*-", 23U, value, (enum variable_origin )6,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt4951:Leaf
define_variable_in_set((char *)"MAKEOVERRIDES", 13U, (char *)"${-*-command-variables-*-}",
                            (enum variable_origin )1, 1, current_variable_set_list->set,
                            (struct floc  const  *)((struct floc *)0));

   }

//Stmt5448:Parent
if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
//Stmt4964:Leaf
i = 0U;

//Stmt4965:Parent
while ((unsigned long )*(directories___0->list + i) != (unsigned long )((char *)0)) {
//Stmt4958:Leaf
dir = *(directories___0->list + i);

//Stmt4959:Parent
if ((int )*(dir + 0) == 126) {
//Stmt4953:Leaf
tmp___14 = tilde_expand(dir);

//Stmt4954:Leaf
expanded = tmp___14;

//Stmt4955:Parent
if ((unsigned long )expanded != (unsigned long )((char *)0)) {
//Stmt4952:Leaf
dir = expanded;

         }

       }

//Stmt4960:Leaf
tmp___15 = chdir((char const   *)dir);

//Stmt4961:Parent
if (tmp___15 < 0) {
//Stmt4956:Leaf
pfatal_with_name(dir);

       }

//Stmt4962:Parent
if ((unsigned long )dir != (unsigned long )*(directories___0->list + i)) {
//Stmt4957:Leaf
free((void *)dir);

       }

//Stmt4963:Leaf
i ++;

     }

   }

//Stmt5449:Leaf
tmp___16 = lookup_variable((char *)"MAKELEVEL", 9U);

//Stmt5450:Leaf
v___0 = tmp___16;

//Stmt5451:Parent
if ((unsigned long )v___0 != (unsigned long )((struct variable *)0)) {
//Stmt4971:Parent
if ((int )*(v___0->value) != 0) {
//Stmt4969:Parent
if ((int )*(v___0->value) != 45) {
//Stmt4966:Leaf
tmp___17 = atoi((char const   *)v___0->value);

//Stmt4967:Leaf
makelevel = (unsigned int )tmp___17;

       } else {
//Stmt4968:Leaf
makelevel = 0U;

       }

     } else {
//Stmt4970:Leaf
makelevel = 0U;

     }

   } else {
//Stmt4972:Leaf
makelevel = 0U;

   }

//Stmt5452:Parent
if (! silent_flag) {
//Stmt4976:Parent
if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
//Stmt4974:Leaf
print_directory_flag = 1;

     } else
     {
//Stmt4975:Parent
if (makelevel > 0U) {
//Stmt4973:Leaf
print_directory_flag = 1;

     }
}


   }

//Stmt5453:Parent
if (inhibit_print_directory_flag) {
//Stmt4977:Leaf
print_directory_flag = 0;

   }

//Stmt5454:Parent
if (no_builtin_variables_flag) {
//Stmt4978:Leaf
no_builtin_rules_flag = 1;

   }

//Stmt5455:Parent
if ((unsigned long )include_directories == (unsigned long )((struct stringlist *)0)) {
//Stmt4979:Leaf
tmp___18 = (char **)0;

   } else {
//Stmt4980:Leaf
tmp___18 = include_directories->list;

   }

//Stmt5456:Leaf
construct_include_path(tmp___18);

//Stmt5457:Parent
if ((unsigned long )directories___0 == (unsigned long )((struct stringlist *)0)) {
//Stmt4984:Leaf
starting_directory = current_directory;

   } else {
//Stmt4985:Leaf
tmp___19 = getcwd(current_directory, (size_t )4096);

//Stmt4986:Parent
if ((unsigned long )tmp___19 == (unsigned long )((char *)0)) {
//Stmt4981:Leaf
perror_with_name((char *)"getcwd: ", (char *)"");

//Stmt4982:Leaf
starting_directory = (char *)0;

     } else {
//Stmt4983:Leaf
starting_directory = current_directory;

     }

   }

//Stmt5458:Leaf
define_variable_in_set((char *)"CURDIR", 6U, current_directory, (enum variable_origin )0,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt5459:Parent
if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
//Stmt5016:Leaf
i___0 = 0U;

//Stmt5017:Parent
while (i___0 < makefiles->idx) {
//Stmt5014:Parent
if ((int )*(*(makefiles->list + i___0) + 0) == 45) {
//Stmt5013:Parent
if ((int )*(*(makefiles->list + i___0) + 1) == 0) {
//Stmt5001:Parent
if (stdin_nm) {
//Stmt4987:Leaf
tmp___20 = dcgettext((char const   *)((void *)0), "Makefile from standard input specified twice.",
                                  5);

//Stmt4988:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___20);

           }

//Stmt5002:Leaf
outfile = open_tmpfile(& stdin_nm, "/tmp/GmXXXXXX");

//Stmt5003:Parent
if ((unsigned long )outfile == (unsigned long )((FILE *)0)) {
//Stmt4989:Leaf
tmp___21 = dcgettext((char const   *)((void *)0), "fopen (temporary file)",
                                  5);

//Stmt4990:Leaf
pfatal_with_name(tmp___21);

           }

//Stmt5004:Parent
while (1) {
//Stmt4996:Leaf
tmp___25 = feof(stdin);

//Stmt4997:Parent
if (tmp___25) {
//Stmt4991:Leaf
break;

             }

//Stmt4998:Leaf
tmp___22 = fread((void * __restrict  )(buf___1), (size_t )1, sizeof(buf___1),
                              (FILE * __restrict  )stdin);

//Stmt4999:Leaf
n = (unsigned int )tmp___22;

//Stmt5000:Parent
if (n > 0U) {
//Stmt4994:Leaf
tmp___24 = fwrite((void const   * __restrict  )(buf___1), (size_t )1,
                                 (size_t )n, (FILE * __restrict  )outfile);

//Stmt4995:Parent
if (tmp___24 != (size_t )n) {
//Stmt4992:Leaf
tmp___23 = dcgettext((char const   *)((void *)0), "fwrite (temporary file)",
                                      5);

//Stmt4993:Leaf
pfatal_with_name(tmp___23);

               }

             }

           }

//Stmt5005:Leaf
fclose(outfile);

//Stmt5006:Leaf
*(makefiles->list + i___0) = xstrdup((char const   *)stdin_nm);

//Stmt5007:Leaf
f = enter_file(stdin_nm);

//Stmt5008:Leaf
f->updated = 1U;

//Stmt5009:Leaf
f->update_status = (short)0;

//Stmt5010:Leaf
f->command_state = (enum __anonenum_command_state_55 )3;

//Stmt5011:Leaf
f->intermediate = 0U;

//Stmt5012:Leaf
f->dontcare = 0U;

         }

       }

//Stmt5015:Leaf
i___0 ++;

     }

   }

//Stmt5460:Leaf
memset((void *)((char *)(& sa)), 0, sizeof(struct sigaction ));

//Stmt5461:Leaf
sa.__sigaction_handler.sa_handler = & child_handler;

//Stmt5462:Leaf
sa.sa_flags = 536870912;

//Stmt5463:Leaf
sigaction(17, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));

//Stmt5464:Leaf
signal(10, & debug_signal_handler);

//Stmt5465:Leaf
set_default_suffixes();

//Stmt5466:Leaf
install_default_suffix_rules();

//Stmt5467:Leaf
define_automatic_variables();

//Stmt5468:Leaf
define_makeflags(0, 0);

//Stmt5469:Leaf
define_default_variables();

//Stmt5470:Leaf
default_file = enter_file((char *)".DEFAULT");

//Stmt5471:Parent
if ((unsigned long )makefiles == (unsigned long )((struct stringlist *)0)) {
//Stmt5018:Leaf
tmp___26 = (char **)0;

   } else {
//Stmt5019:Leaf
tmp___26 = makefiles->list;

   }

//Stmt5472:Leaf
read_makefiles___0 = read_all_makefiles(tmp___26);

//Stmt5473:Leaf
decode_env_switches((char *)"MAKEFLAGS", 9U);

//Stmt5474:Parent
if (jobserver_fds) {
//Stmt5050:Leaf
i = 1U;

//Stmt5051:Parent
while (i < jobserver_fds->idx) {
//Stmt5028:Parent
if (! ((unsigned long )*(jobserver_fds->list + 0) == (unsigned long )*(jobserver_fds->list + i))) {
//Stmt5027:Parent
if ((int )*(*(jobserver_fds->list + 0)) == (int )*(*(jobserver_fds->list + i))) {
//Stmt5024:Parent
if (! ((int )*(*(jobserver_fds->list + 0)) == 0)) {
//Stmt5022:Leaf
tmp___28 = strcmp((char const   *)(*(jobserver_fds->list + 0) + 1), (char const   *)(*(jobserver_fds->list + i) + 1));

//Stmt5023:Parent
if (tmp___28) {
//Stmt5020:Leaf
tmp___27 = dcgettext((char const   *)((void *)0), "internal error: multiple --jobserver-fds options",
                                    5);

//Stmt5021:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27);

             }

           }

         } else {
//Stmt5025:Leaf
tmp___27 = dcgettext((char const   *)((void *)0), "internal error: multiple --jobserver-fds options",
                                5);

//Stmt5026:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27);

         }

       }

//Stmt5029:Leaf
i ++;

     }

//Stmt5052:Leaf
cp = *(jobserver_fds->list + 0);

//Stmt5053:Leaf
tmp___30 = sscanf((char const   * __restrict  )cp, (char const   * __restrict  )"%d,%d",
                       & job_fds[0], & job_fds[1]);

//Stmt5054:Parent
if (tmp___30 != 2) {
//Stmt5030:Leaf
tmp___29 = dcgettext((char const   *)((void *)0), "internal error: invalid --jobserver-fds string `%s\'",
                            5);

//Stmt5031:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___29, cp);

     }

//Stmt5055:Parent
if (job_slots > 0U) {
//Stmt5039:Leaf
tmp___31 = dcgettext((char const   *)((void *)0), "warning: -jN forced in submake: disabling jobserver mode.",
                            5);

//Stmt5040:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___31);

     } else {
//Stmt5041:Leaf
job_rfd = dup(job_fds[0]);

//Stmt5042:Parent
if (job_rfd < 0) {
//Stmt5034:Leaf
tmp___33 = __errno_location();

//Stmt5035:Parent
if (*tmp___33 != 9) {
//Stmt5032:Leaf
tmp___32 = dcgettext((char const   *)((void *)0), "dup jobserver", 5);

//Stmt5033:Leaf
pfatal_with_name(tmp___32);

         }

//Stmt5036:Leaf
tmp___34 = dcgettext((char const   *)((void *)0), "warning: jobserver unavailable: using -j1.  Add `+\' to parent make rule.",
                              5);

//Stmt5037:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___34);

//Stmt5038:Leaf
job_slots = 1U;

       }

     }

//Stmt5056:Parent
if (job_slots > 0U) {
//Stmt5043:Leaf
close(job_fds[0]);

//Stmt5044:Leaf
close(job_fds[1]);

//Stmt5045:Leaf
job_fds[1] = -1;

//Stmt5046:Leaf
job_fds[0] = job_fds[1];

//Stmt5047:Leaf
free((void *)jobserver_fds->list);

//Stmt5048:Leaf
free((void *)jobserver_fds);

//Stmt5049:Leaf
jobserver_fds = (struct stringlist *)0;

     }

   }

//Stmt5475:Parent
if (job_slots > 1U) {
//Stmt5074:Leaf
c = (char )'+';

//Stmt5075:Leaf
tmp___36 = pipe((int *)(job_fds));

//Stmt5076:Parent
if (tmp___36 < 0) {
//Stmt5059:Leaf
tmp___35 = dcgettext((char const   *)((void *)0), "creating jobs pipe", 5);

//Stmt5060:Leaf
pfatal_with_name(tmp___35);

     } else {
//Stmt5061:Leaf
job_rfd = dup(job_fds[0]);

//Stmt5062:Parent
if (job_rfd < 0) {
//Stmt5057:Leaf
tmp___35 = dcgettext((char const   *)((void *)0), "creating jobs pipe", 5);

//Stmt5058:Leaf
pfatal_with_name(tmp___35);

       }

     }

//Stmt5077:Parent
while (1) {
//Stmt5071:Leaf
job_slots --;

//Stmt5072:Parent
if (! job_slots) {
//Stmt5063:Leaf
break;

       }

//Stmt5073:Parent
while (1) {
//Stmt5067:Leaf
tmp___39 = write(job_fds[1], (void const   *)(& c), (size_t )1);

//Stmt5068:Parent
if (! (tmp___39 != 1L)) {
//Stmt5064:Leaf
break;

         }

//Stmt5069:Leaf
tmp___38 = __errno_location();

//Stmt5070:Parent
if (! (*tmp___38 == 4)) {
//Stmt5065:Leaf
tmp___37 = dcgettext((char const   *)((void *)0), "init jobserver pipe",
                                5);

//Stmt5066:Leaf
pfatal_with_name(tmp___37);

         }

       }

     }

//Stmt5078:Leaf
tmp___40 = xmalloc((unsigned int )sizeof(struct stringlist ));

//Stmt5079:Leaf
jobserver_fds = (struct stringlist *)tmp___40;

//Stmt5080:Leaf
tmp___41 = xmalloc((unsigned int )sizeof(char *));

//Stmt5081:Leaf
jobserver_fds->list = (char **)tmp___41;

//Stmt5082:Leaf
*(jobserver_fds->list + 0) = xmalloc((unsigned int )(sizeof("1024") * 2UL + 1UL));

//Stmt5083:Leaf
sprintf((char * __restrict  )*(jobserver_fds->list + 0), (char const   * __restrict  )"%d,%d",
             job_fds[0], job_fds[1]);

//Stmt5084:Leaf
jobserver_fds->idx = 1U;

//Stmt5085:Leaf
jobserver_fds->max = 1U;

   }

//Stmt5476:Leaf
define_makeflags(1, 0);

//Stmt5477:Leaf
snap_deps();

//Stmt5478:Leaf
convert_to_pattern();

//Stmt5479:Leaf
install_default_implicit_rules();

//Stmt5480:Leaf
count_implicit_rule_limits();

//Stmt5481:Leaf
build_vpath_lists();

//Stmt5482:Parent
if ((unsigned long )old_files != (unsigned long )((struct stringlist *)0)) {
//Stmt5094:Leaf
p = old_files->list;

//Stmt5095:Parent
while ((unsigned long )*p != (unsigned long )((char *)0)) {
//Stmt5086:Leaf
f = enter_command_line_file(*p);

//Stmt5087:Leaf
tmp___42 = (uintmax_t )1;

//Stmt5088:Leaf
f->mtime_before_update = tmp___42;

//Stmt5089:Leaf
f->last_mtime = tmp___42;

//Stmt5090:Leaf
f->updated = 1U;

//Stmt5091:Leaf
f->update_status = (short)0;

//Stmt5092:Leaf
f->command_state = (enum __anonenum_command_state_55 )3;

//Stmt5093:Leaf
p ++;

     }

   }

//Stmt5483:Parent
if ((unsigned long )new_files != (unsigned long )((struct stringlist *)0)) {
//Stmt5101:Leaf
p = new_files->list;

//Stmt5102:Parent
while ((unsigned long )*p != (unsigned long )((char *)0)) {
//Stmt5096:Leaf
f = enter_command_line_file(*p);

//Stmt5097:Leaf
tmp___43 = 0xfffffffffffffffeUL;

//Stmt5098:Leaf
f->mtime_before_update = tmp___43;

//Stmt5099:Leaf
f->last_mtime = tmp___43;

//Stmt5100:Leaf
p ++;

     }

   }

//Stmt5484:Leaf
remote_setup();

//Stmt5485:Parent
if ((unsigned long )read_makefiles___0 != (unsigned long )((struct dep *)0)) {
//Stmt5250:Leaf
makefile_mtimes = (uintmax_t *)0;

//Stmt5251:Leaf
mm_idx = 0U;

//Stmt5252:Leaf
nargv = argv;

//Stmt5253:Leaf
nargc = argc;

//Stmt5254:Leaf
orig_db_level = db_level;

//Stmt5255:Parent
if (! (256 & db_level)) {
//Stmt5103:Leaf
db_level = 0;

     }

//Stmt5256:Parent
while (1) {
//Stmt5107:Parent
if (1 & db_level) {
//Stmt5104:Leaf
tmp___44 = dcgettext((char const   *)((void *)0), "Updating makefiles....\n",
                              5);

//Stmt5105:Leaf
printf((char const   * __restrict  )tmp___44);

//Stmt5106:Leaf
fflush(stdout);

       }

//Stmt5108:Leaf
break;

     }

//Stmt5257:Leaf
last = (struct dep *)0;

//Stmt5258:Leaf
d = read_makefiles___0;

//Stmt5259:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt5140:Leaf
f___0 = d->file;

//Stmt5141:Parent
if (f___0->double_colon) {
//Stmt5126:Leaf
f___0 = f___0->double_colon;

//Stmt5127:Parent
while ((unsigned long )f___0 != (unsigned long )((void *)0)) {
//Stmt5124:Parent
if ((unsigned long )f___0->deps == (unsigned long )((struct dep *)0)) {
//Stmt5123:Parent
if ((unsigned long )f___0->cmds != (unsigned long )((struct commands *)0)) {
//Stmt5118:Parent
while (1) {
//Stmt5112:Parent
if (2 & db_level) {
//Stmt5109:Leaf
tmp___45 = dcgettext((char const   *)((void *)0), "Makefile `%s\' might loop; not remaking it.\n",
                                        5);

//Stmt5110:Leaf
printf((char const   * __restrict  )tmp___45, f___0->name);

//Stmt5111:Leaf
fflush(stdout);

                 }

//Stmt5113:Leaf
break;

               }

//Stmt5119:Parent
if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
//Stmt5114:Leaf
read_makefiles___0 = d->next;

               } else {
//Stmt5115:Leaf
last->next = d->next;

               }

//Stmt5120:Leaf
free((void *)((char *)d));

//Stmt5121:Parent
if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
//Stmt5116:Leaf
d = read_makefiles___0;

               } else {
//Stmt5117:Leaf
d = last->next;

               }

//Stmt5122:Leaf
break;

             }

           }

//Stmt5125:Leaf
f___0 = f___0->prev;

         }

       }

//Stmt5142:Parent
if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
//Stmt5138:Leaf
goto _L;

       } else
       {
//Stmt5139:Parent
if (! f___0->double_colon) {
         _L: /* CIL Label */ 
         {
//Stmt5128:Leaf
tmp___46 = xrealloc((char *)makefile_mtimes, (unsigned int )((unsigned long )(mm_idx + 1U) * sizeof(uintmax_t )));

}
//Stmt5132:Leaf
makefile_mtimes = (uintmax_t *)tmp___46;

//Stmt5133:Leaf
tmp___47 = mm_idx;

//Stmt5134:Leaf
mm_idx ++;

//Stmt5135:Parent
if ((d->file)->last_mtime) {
//Stmt5129:Leaf
*(makefile_mtimes + tmp___47) = (d->file)->last_mtime;

         } else {
//Stmt5130:Leaf
tmp___48 = f_mtime(d->file, 0);

//Stmt5131:Leaf
*(makefile_mtimes + tmp___47) = tmp___48;

         }

//Stmt5136:Leaf
last = d;

//Stmt5137:Leaf
d = d->next;

       }
}


     }

//Stmt5260:Leaf
define_makeflags(1, 1);

//Stmt5261:Leaf
tmp___49 = update_goal_chain(read_makefiles___0, 1);

//Stmt5262:Parent
switch (tmp___49) {
     default:; 
//Stmt5143:Leaf
__assert_fail("BOGUS_UPDATE_STATUS", "main.c", 1641U, "main");

     break;
     case -1:; 
     break;
     case 2:; 
//Stmt5144:Leaf
any_remade = 0;

//Stmt5231:Leaf
any_failed = 0;

//Stmt5232:Leaf
i___1 = 0U;

//Stmt5233:Leaf
d___0 = read_makefiles___0;

//Stmt5234:Parent
while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
//Stmt5177:Leaf
(d___0->file)->considered = 0U;

//Stmt5178:Parent
if ((d___0->file)->updated) {
//Stmt5175:Parent
if ((int )(d___0->file)->update_status == 0) {
//Stmt5160:Parent
if ((d___0->file)->last_mtime) {
//Stmt5145:Leaf
tmp___51 = (d___0->file)->last_mtime;

           } else {
//Stmt5146:Leaf
tmp___50 = f_mtime(d___0->file, 0);

//Stmt5147:Leaf
tmp___51 = tmp___50;

           }

//Stmt5161:Leaf
any_remade |= tmp___51 != *(makefile_mtimes + i___1);

         } else
         {
//Stmt5162:Parent
if (! (d___0->changed & (1 << 2))) {
//Stmt5155:Leaf
tmp___52 = dcgettext((char const   *)((void *)0), "Failed to remake makefile `%s\'.",
                                5);

//Stmt5156:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___52,
                 (d___0->file)->name);

//Stmt5157:Parent
if ((d___0->file)->last_mtime) {
//Stmt5148:Leaf
mtime = (d___0->file)->last_mtime;

           } else {
//Stmt5149:Leaf
tmp___53 = f_mtime(d___0->file, 0);

//Stmt5150:Leaf
mtime = tmp___53;

           }

//Stmt5158:Parent
if (mtime != 0xffffffffffffffffUL) {
//Stmt5153:Parent
if (mtime != *(makefile_mtimes + i___1)) {
//Stmt5151:Leaf
tmp___54 = 1;

             } else {
//Stmt5152:Leaf
tmp___54 = 0;

             }

           } else {
//Stmt5154:Leaf
tmp___54 = 0;

           }

//Stmt5159:Leaf
any_remade |= tmp___54;

         }
}


       } else
       {
//Stmt5176:Parent
if (! (d___0->changed & (1 << 2))) {
//Stmt5174:Parent
if (d___0->changed & (1 << 1)) {
//Stmt5167:Parent
if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
//Stmt5163:Leaf
tmp___55 = (d___0->file)->name;

           } else {
//Stmt5164:Leaf
tmp___55 = d___0->name;

           }

//Stmt5168:Leaf
tmp___56 = dcgettext((char const   *)((void *)0), "Included makefile `%s\' was not found.",
                                5);

//Stmt5169:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___56,
                 tmp___55);

         } else {
//Stmt5170:Parent
if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
//Stmt5165:Leaf
tmp___57 = (d___0->file)->name;

           } else {
//Stmt5166:Leaf
tmp___57 = d___0->name;

           }

//Stmt5171:Leaf
tmp___58 = dcgettext((char const   *)((void *)0), "Makefile `%s\' was not found",
                                5);

//Stmt5172:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___58,
                 tmp___57);

//Stmt5173:Leaf
any_failed = 1;

         }

       }
}


//Stmt5179:Leaf
i___1 ++;

//Stmt5180:Leaf
d___0 = d___0->next;

     }

//Stmt5235:Leaf
read_makefiles___0 = (struct dep *)0;

//Stmt5236:Parent
if (any_remade) {
//Stmt5181:Leaf
goto re_exec;

     }

//Stmt5237:Parent
if (any_failed) {
//Stmt5182:Leaf
die(2);

     }

     break;
     re_exec: 
     case 0:; 
//Stmt5183:Leaf
remove_intermediates(0);

//Stmt5238:Parent
if (print_data_base_flag) {
//Stmt5184:Leaf
print_data_base();

     }

//Stmt5239:Leaf
log_working_directory(0);

//Stmt5240:Parent
if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
//Stmt5194:Leaf
j = 0U;

//Stmt5195:Leaf
i___2 = 1U;

//Stmt5196:Parent
while (i___2 < (unsigned int )argc) {
//Stmt5191:Leaf
tmp___59 = strncmp((char const   *)*(argv + i___2), "-f", (size_t )2);

//Stmt5192:Parent
if (tmp___59 == 0) {
//Stmt5188:Leaf
p___1 = *(argv + i___2) + 2;

//Stmt5189:Parent
if ((int )*p___1 == 0) {
//Stmt5185:Leaf
i___2 ++;

//Stmt5186:Leaf
*(argv + i___2) = *(makefiles->list + j);

           } else {
//Stmt5187:Leaf
*(argv + i___2) = concat((char *)"-f", *(makefiles->list + j), (char *)"");

           }

//Stmt5190:Leaf
j ++;

         }

//Stmt5193:Leaf
i___2 ++;

       }

     }

//Stmt5241:Parent
if (stdin_nm) {
//Stmt5197:Leaf
tmp___60 = xmalloc((unsigned int )((unsigned long )(nargc + 2) * sizeof(char *)));

//Stmt5198:Leaf
nargv = (char **)tmp___60;

//Stmt5199:Leaf
memmove((void *)((char *)nargv), (void const   *)((char *)argv), (unsigned long )argc * sizeof(char *));

//Stmt5200:Leaf
tmp___61 = nargc;

//Stmt5201:Leaf
nargc ++;

//Stmt5202:Leaf
*(nargv + tmp___61) = concat((char *)"-o", stdin_nm, (char *)"");

//Stmt5203:Leaf
*(nargv + nargc) = (char *)0;

     }

//Stmt5242:Parent
if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
//Stmt5214:Parent
if (directories___0->idx > 0U) {
//Stmt5212:Parent
if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
//Stmt5207:Leaf
tmp___62 = chdir((char const   *)directory_before_chdir);

//Stmt5208:Parent
if (tmp___62 < 0) {
//Stmt5204:Leaf
perror_with_name((char *)"chdir", (char *)"");

//Stmt5205:Leaf
bad = (char)1;

           } else {
//Stmt5206:Leaf
bad = (char)0;

           }

         } else {
//Stmt5209:Leaf
bad = (char)1;

         }

//Stmt5213:Parent
if (bad) {
//Stmt5210:Leaf
tmp___63 = dcgettext((char const   *)((void *)0), "Couldn\'t change back to original directory.",
                                5);

//Stmt5211:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___63);

         }

       }

     }

//Stmt5243:Leaf
p = environ;

//Stmt5244:Parent
while ((unsigned long )*p != (unsigned long )((char *)0)) {
//Stmt5220:Leaf
tmp___65 = strncmp((char const   *)*p, "MAKELEVEL=", (size_t )10);

//Stmt5221:Parent
if (tmp___65 == 0) {
//Stmt5215:Leaf
tmp___64 = __builtin_alloca(40UL);

//Stmt5216:Leaf
sgi_loses = (char *)tmp___64;

//Stmt5217:Leaf
*p = sgi_loses;

//Stmt5218:Leaf
sprintf((char * __restrict  )*p, (char const   * __restrict  )"MAKELEVEL=%u",
                 makelevel);

//Stmt5219:Leaf
break;

       }

//Stmt5222:Leaf
p ++;

     }

//Stmt5245:Parent
if (1 & db_level) {
//Stmt5225:Leaf
tmp___66 = dcgettext((char const   *)((void *)0), "Re-executing:", 5);

//Stmt5226:Leaf
fputs((char const   * __restrict  )tmp___66, (FILE * __restrict  )stdout);

//Stmt5227:Leaf
p___2 = nargv;

//Stmt5228:Parent
while ((unsigned long )*p___2 != (unsigned long )((char *)0)) {
//Stmt5223:Leaf
printf((char const   * __restrict  )" %s", *p___2);

//Stmt5224:Leaf
p___2 ++;

       }

//Stmt5229:Leaf
putchar('\n');

     }

//Stmt5246:Leaf
fflush(stdout);

//Stmt5247:Leaf
fflush(stderr);

//Stmt5248:Parent
if (job_rfd >= 0) {
//Stmt5230:Leaf
close(job_rfd);

     }

//Stmt5249:Leaf
exec_command(nargv, environ);

     }

//Stmt5263:Leaf
db_level = orig_db_level;

   }

//Stmt5486:Leaf
define_makeflags(1, 0);

//Stmt5487:Parent
if (stdin_nm) {
//Stmt5268:Leaf
tmp___68 = unlink((char const   *)stdin_nm);

//Stmt5269:Parent
if (tmp___68 < 0) {
//Stmt5266:Leaf
tmp___69 = __errno_location();

//Stmt5267:Parent
if (*tmp___69 != 2) {
//Stmt5264:Leaf
tmp___67 = dcgettext((char const   *)((void *)0), "unlink (temporary file): ",
                              5);

//Stmt5265:Leaf
perror_with_name(tmp___67, stdin_nm);

       }

     }

   }

//Stmt5488:Parent
if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
//Stmt5275:Parent
if ((unsigned long )default_goal_file != (unsigned long )((struct file *)0)) {
//Stmt5270:Leaf
tmp___70 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt5271:Leaf
goals = (struct dep *)tmp___70;

//Stmt5272:Leaf
goals->next = (struct dep *)0;

//Stmt5273:Leaf
goals->name = (char *)0;

//Stmt5274:Leaf
goals->file = default_goal_file;

     }

   } else {
//Stmt5276:Leaf
lastgoal->next = (struct dep *)0;

   }

//Stmt5489:Parent
if (! goals) {
//Stmt5279:Parent
if ((unsigned long )read_makefiles___0 == (unsigned long )((struct dep *)0)) {
//Stmt5277:Leaf
tmp___71 = dcgettext((char const   *)((void *)0), "No targets specified and no makefile found",
                            5);

//Stmt5278:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___71);

     }

//Stmt5280:Leaf
tmp___72 = dcgettext((char const   *)((void *)0), "No targets", 5);

//Stmt5281:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___72);

   }

//Stmt5490:Parent
while (1) {
//Stmt5285:Parent
if (1 & db_level) {
//Stmt5282:Leaf
tmp___73 = dcgettext((char const   *)((void *)0), "Updating goal targets....\n",
                            5);

//Stmt5283:Leaf
printf((char const   * __restrict  )tmp___73);

//Stmt5284:Leaf
fflush(stdout);

     }

//Stmt5286:Leaf
break;

   }

//Stmt5491:Leaf
tmp___74 = update_goal_chain(goals, 0);

//Stmt5492:Parent
switch (tmp___74) {
   case 0:; 
   case -1:; 
//Stmt5287:Leaf
status = 0;

   break;
   case 2:; 
//Stmt5288:Leaf
status = 2;

   break;
   case 1:; 
//Stmt5289:Leaf
status = 1;

   break;
   default:; 
//Stmt5290:Leaf
abort();

   }

//Stmt5493:Parent
if (clock_skew_detected) {
//Stmt5291:Leaf
tmp___75 = dcgettext((char const   *)((void *)0), "warning:  Clock skew detected.  Your build may be incomplete.",
                          5);

//Stmt5292:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___75);

   }

//Stmt5494:Leaf
die(status);

//Stmt5495:Leaf
return (0);

 }
}
 static char options[1UL + (sizeof(switches) / sizeof(switches[0])) * 3UL]  ;
 static struct option long_options[sizeof(switches) / sizeof(switches[0]) + sizeof(long_option_aliases) / sizeof(long_option_aliases[0])]  ;
 static void init_switches(void) 
 { 
//Stmt5524:Leaf
register char *p ;

//Stmt5525:Leaf
register int c ;

//Stmt5526:Leaf
register unsigned int i ;

//Stmt5527:Leaf
char *tmp ;

//Stmt5528:Leaf
char *tmp___0 ;

//Stmt5529:Leaf
char *tmp___1 ;

//Stmt5530:Leaf
char *tmp___2 ;

//Stmt5531:Leaf
unsigned int tmp___3 ;

 
   {
//Stmt5532:Parent
if ((int )options[0] != 0) {
//Stmt5496:Leaf
return;

   }

//Stmt5533:Leaf
p = options;

//Stmt5534:Leaf
tmp = p;

//Stmt5535:Leaf
p ++;

//Stmt5536:Leaf
*tmp = (char )'-';

//Stmt5537:Leaf
i = 0U;

//Stmt5538:Parent
while (switches[i].c != 0) {
//Stmt5514:Parent
if ((unsigned long )switches[i].long_name == (unsigned long )((char * const  )0)) {
//Stmt5497:Leaf
long_options[i].name = "";

     } else {
//Stmt5498:Leaf
long_options[i].name = (char const   *)switches[i].long_name;

     }

//Stmt5515:Leaf
long_options[i].flag = (int *)0;

//Stmt5516:Leaf
long_options[i].val = (int )switches[i].c;

//Stmt5517:Parent
if (switches[i].c <= 127) {
//Stmt5499:Leaf
tmp___0 = p;

//Stmt5500:Leaf
p ++;

//Stmt5501:Leaf
*tmp___0 = (char )switches[i].c;

     }

//Stmt5518:Parent
switch ((unsigned int const   )switches[i].type) {
     case 5U:; 
     case 1U:; 
     case 0U:; 
//Stmt5502:Leaf
long_options[i].has_arg = 0;

     break;
     case 4U:; 
     case 3U:; 
     case 2U:; 
//Stmt5506:Parent
if (switches[i].c <= 127) {
//Stmt5503:Leaf
tmp___1 = p;

//Stmt5504:Leaf
p ++;

//Stmt5505:Leaf
*tmp___1 = (char )':';

     }

//Stmt5513:Parent
if ((unsigned long )switches[i].noarg_value != (unsigned long )((char * const  )0)) {
//Stmt5510:Parent
if (switches[i].c <= 127) {
//Stmt5507:Leaf
tmp___2 = p;

//Stmt5508:Leaf
p ++;

//Stmt5509:Leaf
*tmp___2 = (char )':';

       }

//Stmt5511:Leaf
long_options[i].has_arg = 2;

     } else {
//Stmt5512:Leaf
long_options[i].has_arg = 1;

     }

     break;
     }

//Stmt5519:Leaf
i ++;

   }

//Stmt5539:Leaf
*p = (char )'\000';

//Stmt5540:Leaf
c = 0;

//Stmt5541:Parent
while ((unsigned long )c < sizeof(long_option_aliases) / sizeof(long_option_aliases[0])) {
//Stmt5520:Leaf
tmp___3 = i;

//Stmt5521:Leaf
i ++;

//Stmt5522:Leaf
long_options[tmp___3] = long_option_aliases[c];

//Stmt5523:Leaf
c ++;

   }

//Stmt5542:Leaf
long_options[i].name = (char const   *)0;

//Stmt5543:Leaf
return;

 }
}
 static void handle_non_switch_argument(char *arg , int env ) 
 { 
//Stmt5577:Leaf
struct variable *v ;

//Stmt5578:Leaf
struct command_variable *cv ;

//Stmt5579:Leaf
char *tmp ;

//Stmt5580:Leaf
struct file *f ;

//Stmt5581:Leaf
struct file *tmp___0 ;

//Stmt5582:Leaf
char *tmp___1 ;

//Stmt5583:Leaf
char *tmp___2 ;

//Stmt5584:Leaf
struct variable *v___0 ;

//Stmt5585:Leaf
char *value ;

//Stmt5586:Leaf
unsigned int oldlen ;

//Stmt5587:Leaf
unsigned int newlen ;

//Stmt5588:Leaf
size_t tmp___3 ;

//Stmt5589:Leaf
size_t tmp___4 ;

//Stmt5590:Leaf
void *tmp___5 ;

 
   {
//Stmt5591:Parent
if ((int )*(arg + 0) == 45) {
//Stmt5545:Parent
if ((int )*(arg + 1) == 0) {
//Stmt5544:Leaf
return;

     }

   }

//Stmt5592:Leaf
v = try_variable_definition((struct floc  const  *)0, arg, (enum variable_origin )4,
                               0);

//Stmt5593:Parent
if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt5571:Leaf
tmp = xmalloc((unsigned int )sizeof(*cv));

//Stmt5572:Leaf
cv = (struct command_variable *)tmp;

//Stmt5573:Leaf
cv->variable = v;

//Stmt5574:Leaf
cv->next = command_variables;

//Stmt5575:Leaf
command_variables = cv;

   } else
   {
//Stmt5576:Parent
if (! env) {
//Stmt5562:Leaf
tmp___0 = enter_command_line_file(arg);

//Stmt5563:Leaf
f = tmp___0;

//Stmt5564:Leaf
f->cmd_target = 1U;

//Stmt5565:Parent
if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
//Stmt5546:Leaf
tmp___1 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt5547:Leaf
goals = (struct dep *)tmp___1;

//Stmt5548:Leaf
lastgoal = goals;

     } else {
//Stmt5549:Leaf
tmp___2 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt5550:Leaf
lastgoal->next = (struct dep *)tmp___2;

//Stmt5551:Leaf
lastgoal = lastgoal->next;

     }

//Stmt5566:Leaf
lastgoal->name = (char *)0;

//Stmt5567:Leaf
lastgoal->file = f;

//Stmt5568:Leaf
v___0 = lookup_variable((char *)"MAKECMDGOALS", 12U);

//Stmt5569:Parent
if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
//Stmt5552:Leaf
value = f->name;

     } else {
//Stmt5553:Leaf
tmp___3 = strlen((char const   *)v___0->value);

//Stmt5554:Leaf
oldlen = (unsigned int )tmp___3;

//Stmt5555:Leaf
tmp___4 = strlen((char const   *)f->name);

//Stmt5556:Leaf
newlen = (unsigned int )tmp___4;

//Stmt5557:Leaf
tmp___5 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));

//Stmt5558:Leaf
value = (char *)tmp___5;

//Stmt5559:Leaf
memmove((void *)value, (void const   *)v___0->value, (size_t )oldlen);

//Stmt5560:Leaf
*(value + oldlen) = (char )' ';

//Stmt5561:Leaf
memmove((void *)(value + (oldlen + 1U)), (void const   *)f->name, (size_t )(newlen + 1U));

     }

//Stmt5570:Leaf
define_variable_in_set((char *)"MAKECMDGOALS", 12U, value, (enum variable_origin )0,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

   }
}


//Stmt5594:Leaf
return;

 }
}
 static void print_usage(int bad ) 
 { 
//Stmt5653:Leaf
register struct command_switch  const  *cs ;

//Stmt5654:Leaf
FILE *usageto ;

//Stmt5655:Leaf
char *tmp ;

//Stmt5656:Leaf
char *tmp___0 ;

//Stmt5657:Leaf
char buf___1[1024] ;

//Stmt5658:Leaf
char shortarg[50] ;

//Stmt5659:Leaf
char longarg[50] ;

//Stmt5660:Leaf
char *p ;

//Stmt5661:Leaf
char *tmp___1 ;

//Stmt5662:Leaf
char *tmp___2 ;

//Stmt5663:Leaf
char *tmp___3 ;

//Stmt5664:Leaf
char *tmp___4 ;

//Stmt5665:Leaf
size_t tmp___5 ;

//Stmt5666:Leaf
unsigned int i ;

//Stmt5667:Leaf
char const   *tmp___6 ;

//Stmt5668:Leaf
size_t tmp___7 ;

//Stmt5669:Leaf
size_t tmp___8 ;

//Stmt5670:Leaf
struct command_switch  const  *ncs ;

//Stmt5671:Leaf
size_t tmp___9 ;

//Stmt5672:Leaf
size_t tmp___10 ;

//Stmt5673:Leaf
char *tmp___11 ;

//Stmt5674:Leaf
char *tmp___12 ;

 
   {
//Stmt5675:Parent
if (print_version_flag) {
//Stmt5595:Leaf
print_version();

   }

//Stmt5676:Parent
if (bad) {
//Stmt5596:Leaf
usageto = stderr;

   } else {
//Stmt5597:Leaf
usageto = stdout;

   }

//Stmt5677:Leaf
tmp = dcgettext((char const   *)((void *)0), "Usage: %s [options] [target] ...\n",
                   5);

//Stmt5678:Leaf
fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )tmp, program);

//Stmt5679:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "Options:\n", 5);

//Stmt5680:Leaf
fputs((char const   * __restrict  )tmp___0, (FILE * __restrict  )usageto);

//Stmt5681:Leaf
cs = switches;

//Stmt5682:Parent
while (cs->c != 0) {
//Stmt5643:Parent
if (! cs->description) {
//Stmt5599:Leaf
goto __Cont;

     } else
     {
//Stmt5600:Parent
if ((int )*(cs->description + 0) == 45) {
//Stmt5598:Leaf
goto __Cont;

     }
}


//Stmt5644:Parent
switch (long_options[cs - switches].has_arg) {
     case 0:; 
//Stmt5601:Leaf
longarg[0] = (char )'\000';

//Stmt5604:Leaf
shortarg[0] = longarg[0];

     break;
     case 1:; 
//Stmt5602:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);

//Stmt5605:Leaf
sprintf((char * __restrict  )(longarg), (char const   * __restrict  )"=%s", tmp___1);

//Stmt5606:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);

//Stmt5607:Leaf
sprintf((char * __restrict  )(shortarg), (char const   * __restrict  )" %s", tmp___2);

     break;
     case 2:; 
//Stmt5603:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);

//Stmt5608:Leaf
sprintf((char * __restrict  )(longarg), (char const   * __restrict  )"[=%s]",
             tmp___3);

//Stmt5609:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);

//Stmt5610:Leaf
sprintf((char * __restrict  )(shortarg), (char const   * __restrict  )" [%s]",
             tmp___4);

     break;
     }

//Stmt5645:Leaf
p = buf___1;

//Stmt5646:Parent
if (cs->c <= 127) {
//Stmt5611:Leaf
sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"  -%c%s",
               cs->c, shortarg);

//Stmt5612:Leaf
tmp___5 = strlen((char const   *)p);

//Stmt5613:Leaf
p += tmp___5;

     }

//Stmt5647:Parent
if ((unsigned long )cs->long_name != (unsigned long )((char * const  )0)) {
//Stmt5621:Parent
if (! (cs->c <= 127)) {
//Stmt5614:Leaf
tmp___6 = "  ";

       } else {
//Stmt5615:Leaf
tmp___6 = ", ";

       }

//Stmt5622:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )"%s--%s%s", tmp___6,
               cs->long_name, longarg);

//Stmt5623:Leaf
tmp___7 = strlen((char const   *)p);

//Stmt5624:Leaf
p += tmp___7;

//Stmt5625:Leaf
i = 0U;

//Stmt5626:Parent
while ((unsigned long )i < sizeof(long_option_aliases) / sizeof(long_option_aliases[0])) {
//Stmt5619:Parent
if (long_option_aliases[i].val == (int )cs->c) {
//Stmt5616:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )", --%s%s",
                   long_option_aliases[i].name, longarg);

//Stmt5617:Leaf
tmp___8 = strlen((char const   *)p);

//Stmt5618:Leaf
p += tmp___8;

         }

//Stmt5620:Leaf
i ++;

       }

     }

//Stmt5648:Leaf
ncs = cs;

//Stmt5649:Parent
while (1) {
//Stmt5637:Leaf
ncs ++;

//Stmt5638:Parent
if (! (ncs->c != 0)) {
//Stmt5627:Leaf
break;

       }

//Stmt5639:Parent
if (ncs->description) {
//Stmt5636:Parent
if ((int )*(ncs->description + 0) == 45) {
//Stmt5635:Parent
if ((int )*(ncs->description + 1) == (int )cs->c) {
//Stmt5631:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )", -%c%s",
                     ncs->c, shortarg);

//Stmt5632:Leaf
tmp___9 = strlen((char const   *)p);

//Stmt5633:Leaf
p += tmp___9;

//Stmt5634:Parent
if ((unsigned long )ncs->long_name != (unsigned long )((char * const  )0)) {
//Stmt5628:Leaf
sprintf((char * __restrict  )p, (char const   * __restrict  )", --%s%s",
                       ncs->long_name, longarg);

//Stmt5629:Leaf
tmp___10 = strlen((char const   *)p);

//Stmt5630:Leaf
p += tmp___10;

             }

           }

         }

       }

     }

//Stmt5650:Parent
if (p - buf___1 > 28L) {
//Stmt5640:Leaf
fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )"%s\n", buf___1);

//Stmt5641:Leaf
buf___1[0] = (char )'\000';

     }

//Stmt5651:Leaf
tmp___11 = dcgettext((char const   *)((void *)0), (char const   *)cs->description,
                          5);

//Stmt5652:Leaf
fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )"%*s%s.\n",
             -30, buf___1, tmp___11);

     __Cont: /* CIL Label */ 
     {
//Stmt5642:Leaf
cs ++;

}
   }

//Stmt5683:Leaf
tmp___12 = dcgettext((char const   *)((void *)0), "\nReport bugs to <bug-make@gnu.org>.\n",
                        5);

//Stmt5684:Leaf
fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )tmp___12);

//Stmt5685:Leaf
return;

 }
}
 static void decode_switches(int argc , char **argv , int env ) 
 { 
//Stmt5773:Leaf
int bad ;

//Stmt5774:Leaf
register struct command_switch  const  *cs ;

//Stmt5775:Leaf
register struct stringlist *sl ;

//Stmt5776:Leaf
register int c ;

//Stmt5777:Leaf
int doit ;

//Stmt5778:Leaf
int tmp ;

//Stmt5779:Leaf
char *tmp___0 ;

//Stmt5780:Leaf
char *tmp___1 ;

//Stmt5781:Leaf
char *tmp___2 ;

//Stmt5782:Leaf
unsigned int tmp___3 ;

//Stmt5783:Leaf
int tmp___4 ;

//Stmt5784:Leaf
int i ;

//Stmt5785:Leaf
int tmp___5 ;

//Stmt5786:Leaf
char *tmp___6 ;

//Stmt5787:Leaf
int tmp___7 ;

//Stmt5788:Leaf
double tmp___8 ;

//Stmt5789:Leaf
int tmp___9 ;

//Stmt5790:Leaf
int tmp___10 ;

 
   {
//Stmt5791:Leaf
bad = 0;

//Stmt5792:Leaf
init_switches();

//Stmt5793:Leaf
opterr = ! env;

//Stmt5794:Leaf
optind = 0;

//Stmt5795:Parent
while (optind < argc) {
//Stmt5760:Leaf
c = getopt_long(argc, (char * const  *)argv, (char const   *)(options), (struct option  const  *)(long_options),
                     (int *)0);

//Stmt5761:Parent
if (c == -1) {
//Stmt5758:Leaf
break;

     } else
     {
//Stmt5759:Parent
if (c == 1) {
//Stmt5756:Leaf
handle_non_switch_argument(optarg, env);

     } else
     {
//Stmt5757:Parent
if (c == 63) {
//Stmt5753:Leaf
bad = 1;

     } else {
//Stmt5754:Leaf
cs = switches;

//Stmt5755:Parent
while (cs->c != 0) {
//Stmt5751:Parent
if (cs->c == (int const   )c) {
//Stmt5747:Parent
if (! env) {
//Stmt5688:Leaf
tmp = 1;

           } else
           {
//Stmt5689:Parent
if (cs->env) {
//Stmt5686:Leaf
tmp = 1;

           } else {
//Stmt5687:Leaf
tmp = 0;

           }
}


//Stmt5748:Leaf
doit = tmp;

//Stmt5749:Parent
switch ((unsigned int const   )cs->type) {
           default:; 
//Stmt5690:Leaf
abort();

           case 5U:; 
           break;
           case 1U:; 
           case 0U:; 
//Stmt5692:Parent
if (doit) {
//Stmt5691:Leaf
*((int *)cs->value_ptr) = (unsigned int const   )cs->type == 0U;

           }

           break;
           case 2U:; 
//Stmt5694:Parent
if (! doit) {
//Stmt5693:Leaf
break;

           }

//Stmt5737:Parent
if ((unsigned long )optarg == (unsigned long )((char *)0)) {
//Stmt5695:Leaf
optarg = (char *)cs->noarg_value;

           }

//Stmt5738:Leaf
sl = *((struct stringlist **)cs->value_ptr);

//Stmt5739:Parent
if ((unsigned long )sl == (unsigned long )((struct stringlist *)0)) {
//Stmt5699:Leaf
tmp___0 = xmalloc((unsigned int )sizeof(struct stringlist ));

//Stmt5700:Leaf
sl = (struct stringlist *)tmp___0;

//Stmt5701:Leaf
sl->max = 5U;

//Stmt5702:Leaf
sl->idx = 0U;

//Stmt5703:Leaf
tmp___1 = xmalloc((unsigned int )(5UL * sizeof(char *)));

//Stmt5704:Leaf
sl->list = (char **)tmp___1;

//Stmt5705:Leaf
*((struct stringlist **)cs->value_ptr) = sl;

           } else
           {
//Stmt5706:Parent
if (sl->idx == sl->max - 1U) {
//Stmt5696:Leaf
sl->max += 5U;

//Stmt5697:Leaf
tmp___2 = xrealloc((char *)sl->list, (unsigned int )((unsigned long )sl->max * sizeof(char *)));

//Stmt5698:Leaf
sl->list = (char **)tmp___2;

           }
}


//Stmt5740:Leaf
tmp___3 = sl->idx;

//Stmt5741:Leaf
(sl->idx) ++;

//Stmt5742:Leaf
*(sl->list + tmp___3) = optarg;

//Stmt5743:Leaf
*(sl->list + sl->idx) = (char *)0;

           break;
           case 3U:; 
//Stmt5712:Parent
if ((unsigned long )optarg == (unsigned long )((char *)0)) {
//Stmt5711:Parent
if (argc > optind) {
//Stmt5710:Parent
if ((unsigned int )*(*(argv + optind) + 0) - 48U <= 9U) {
//Stmt5707:Leaf
tmp___4 = optind;

//Stmt5708:Leaf
optind ++;

//Stmt5709:Leaf
optarg = *(argv + tmp___4);

               }

             }

           }

//Stmt5744:Parent
if (! doit) {
//Stmt5713:Leaf
break;

           }

//Stmt5745:Parent
if ((unsigned long )optarg != (unsigned long )((char *)0)) {
//Stmt5719:Leaf
tmp___5 = atoi((char const   *)optarg);

//Stmt5720:Leaf
i = tmp___5;

//Stmt5721:Parent
if (i < 1) {
//Stmt5716:Parent
if (doit) {
//Stmt5714:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "the `-%c\' option requires a positive integral argument",
                                     5);

//Stmt5715:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                       cs->c);

               }

//Stmt5717:Leaf
bad = 1;

             } else {
//Stmt5718:Leaf
*((unsigned int *)cs->value_ptr) = (unsigned int )i;

             }

           } else {
//Stmt5722:Leaf
*((unsigned int *)cs->value_ptr) = *((unsigned int *)cs->noarg_value);

           }

           break;
           case 4U:; 
//Stmt5732:Parent
if ((unsigned long )optarg == (unsigned long )((char *)0)) {
//Stmt5731:Parent
if (optind < argc) {
//Stmt5730:Parent
if ((unsigned int )*(*(argv + optind) + 0) - 48U <= 9U) {
//Stmt5726:Leaf
tmp___7 = optind;

//Stmt5727:Leaf
optind ++;

//Stmt5728:Leaf
optarg = *(argv + tmp___7);

               } else
               {
//Stmt5729:Parent
if ((int )*(*(argv + optind) + 0) == 46) {
//Stmt5723:Leaf
tmp___7 = optind;

//Stmt5724:Leaf
optind ++;

//Stmt5725:Leaf
optarg = *(argv + tmp___7);

               }
}


             }

           }

//Stmt5746:Parent
if (doit) {
//Stmt5736:Parent
if ((unsigned long )optarg != (unsigned long )((char *)0)) {
//Stmt5733:Leaf
tmp___8 = atof((char const   *)optarg);

//Stmt5734:Leaf
*((double *)cs->value_ptr) = tmp___8;

             } else {
//Stmt5735:Leaf
*((double *)cs->value_ptr) = *((double *)cs->noarg_value);

             }

           }

           break;
           }

//Stmt5750:Leaf
break;

         }

//Stmt5752:Leaf
cs ++;

       }

     }
}

}


   }

//Stmt5796:Parent
while (optind < argc) {
//Stmt5762:Leaf
tmp___9 = optind;

//Stmt5763:Leaf
optind ++;

//Stmt5764:Leaf
handle_non_switch_argument(*(argv + tmp___9), env);

   }

//Stmt5797:Parent
if (! env) {
//Stmt5772:Parent
if (bad) {
//Stmt5770:Leaf
goto _L;

     } else
     {
//Stmt5771:Parent
if (print_usage_flag) {
       _L: /* CIL Label */ 
       {
//Stmt5765:Leaf
print_usage(bad);

}
//Stmt5768:Parent
if (bad) {
//Stmt5766:Leaf
tmp___10 = 2;

       } else {
//Stmt5767:Leaf
tmp___10 = 0;

       }

//Stmt5769:Leaf
die(tmp___10);

     }
}


   }

//Stmt5798:Leaf
return;

 }
}
 static void decode_env_switches(char *envar , unsigned int len ) 
 { 
//Stmt5825:Leaf
char *varref ;

//Stmt5826:Leaf
void *tmp ;

//Stmt5827:Leaf
char *value ;

//Stmt5828:Leaf
char *p ;

//Stmt5829:Leaf
int argc ;

//Stmt5830:Leaf
char **argv ;

//Stmt5831:Leaf
size_t tmp___0 ;

//Stmt5832:Leaf
void *tmp___1 ;

//Stmt5833:Leaf
char *tmp___2 ;

//Stmt5834:Leaf
char *tmp___3 ;

//Stmt5835:Leaf
unsigned short const   **tmp___4 ;

//Stmt5836:Leaf
unsigned short const   **tmp___5 ;

//Stmt5837:Leaf
char *tmp___6 ;

//Stmt5838:Leaf
char *tmp___7 ;

//Stmt5839:Leaf
char *tmp___8 ;

 
   {
//Stmt5840:Leaf
tmp = __builtin_alloca((unsigned long )((2U + len) + 2U));

//Stmt5841:Leaf
varref = (char *)tmp;

//Stmt5842:Leaf
*(varref + 0) = (char )'$';

//Stmt5843:Leaf
*(varref + 1) = (char )'(';

//Stmt5844:Leaf
memmove((void *)(varref + 2), (void const   *)envar, (size_t )len);

//Stmt5845:Leaf
*(varref + (2U + len)) = (char )')';

//Stmt5846:Leaf
*(varref + ((2U + len) + 1U)) = (char )'\000';

//Stmt5847:Leaf
value = variable_expand(varref);

//Stmt5848:Leaf
value = next_token(value);

//Stmt5849:Leaf
tmp___0 = strlen((char const   *)value);

//Stmt5850:Leaf
len = (unsigned int )tmp___0;

//Stmt5851:Parent
if (len == 0U) {
//Stmt5799:Leaf
return;

   }

//Stmt5852:Leaf
tmp___1 = __builtin_alloca((unsigned long )((1U + len) + 1U) * sizeof(char *));

//Stmt5853:Leaf
argv = (char **)tmp___1;

//Stmt5854:Leaf
tmp___2 = xmalloc(2U * len);

//Stmt5855:Leaf
p = tmp___2;

//Stmt5856:Leaf
*(argv + 0) = (char *)0;

//Stmt5857:Leaf
argc = 1;

//Stmt5858:Leaf
*(argv + argc) = p;

//Stmt5859:Parent
while ((int )*value != 0) {
//Stmt5816:Parent
if ((int )*value == 92) {
//Stmt5814:Parent
if ((int )*(value + 1) != 0) {
//Stmt5800:Leaf
value ++;

       } else {
//Stmt5801:Leaf
goto _L;

       }

     } else {
       _L: /* CIL Label */ 
       {
//Stmt5802:Leaf
tmp___5 = __ctype_b_loc();

}
//Stmt5815:Parent
if ((int const   )*(*tmp___5 + (int )*value) & 1) {
//Stmt5807:Leaf
tmp___3 = p;

//Stmt5808:Leaf
p ++;

//Stmt5809:Leaf
*tmp___3 = (char )'\000';

//Stmt5810:Leaf
argc ++;

//Stmt5811:Leaf
*(argv + argc) = p;

//Stmt5812:Parent
while (1) {
//Stmt5804:Leaf
value ++;

//Stmt5805:Leaf
tmp___4 = __ctype_b_loc();

//Stmt5806:Parent
if (! ((int const   )*(*tmp___4 + (int )*value) & 1)) {
//Stmt5803:Leaf
break;

           }

         }

//Stmt5813:Leaf
continue;

       }

     }

//Stmt5817:Leaf
tmp___6 = p;

//Stmt5818:Leaf
p ++;

//Stmt5819:Leaf
tmp___7 = value;

//Stmt5820:Leaf
value ++;

//Stmt5821:Leaf
*tmp___6 = *tmp___7;

   }

//Stmt5860:Leaf
*p = (char )'\000';

//Stmt5861:Leaf
argc ++;

//Stmt5862:Leaf
*(argv + argc) = (char *)0;

//Stmt5863:Parent
if ((int )*(*(argv + 1) + 0) != 45) {
//Stmt5823:Leaf
tmp___8 = strchr((char const   *)*(argv + 1), '=');

//Stmt5824:Parent
if ((unsigned long )tmp___8 == (unsigned long )((char *)0)) {
//Stmt5822:Leaf
*(argv + 1) = concat((char *)"-", *(argv + 1), (char *)"");

     }

   }

//Stmt5864:Leaf
decode_switches(argc, argv, 1);

//Stmt5865:Leaf
return;

 }
}
 static char *quote_for_env(char *out , char *in ) 
 { 
//Stmt5884:Leaf
char *tmp ;

//Stmt5885:Leaf
char *tmp___0 ;

//Stmt5886:Leaf
unsigned short const   **tmp___1 ;

//Stmt5887:Leaf
char *tmp___2 ;

//Stmt5888:Leaf
char *tmp___3 ;

 
   {
//Stmt5889:Parent
while ((int )*in != 0) {
//Stmt5878:Parent
if ((int )*in == 36) {
//Stmt5873:Leaf
tmp = out;

//Stmt5874:Leaf
out ++;

//Stmt5875:Leaf
*tmp = (char )'$';

     } else {
//Stmt5876:Leaf
tmp___1 = __ctype_b_loc();

//Stmt5877:Parent
if ((int const   )*(*tmp___1 + (int )*in) & 1) {
//Stmt5869:Leaf
tmp___0 = out;

//Stmt5870:Leaf
out ++;

//Stmt5871:Leaf
*tmp___0 = (char )'\\';

       } else
       {
//Stmt5872:Parent
if ((int )*in == 92) {
//Stmt5866:Leaf
tmp___0 = out;

//Stmt5867:Leaf
out ++;

//Stmt5868:Leaf
*tmp___0 = (char )'\\';

       }
}


     }

//Stmt5879:Leaf
tmp___2 = out;

//Stmt5880:Leaf
out ++;

//Stmt5881:Leaf
tmp___3 = in;

//Stmt5882:Leaf
in ++;

//Stmt5883:Leaf
*tmp___2 = *tmp___3;

   }

//Stmt5890:Leaf
return (out);

 }
}
 static char const   ref[17]  = 
   {      (char const   )'$',      (char const   )'(',      (char const   )'M',      (char const   )'A', 
         (char const   )'K',      (char const   )'E',      (char const   )'O',      (char const   )'V', 
         (char const   )'E',      (char const   )'R',      (char const   )'R',      (char const   )'I', 
         (char const   )'D',      (char const   )'E',      (char const   )'S',      (char const   )')', 
         (char const   )'\000'};
 static char const   posixref[27]  = 
   {      (char const   )'$',      (char const   )'(',      (char const   )'-',      (char const   )'*', 
         (char const   )'-',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
         (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
         (char const   )'-',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
         (char const   )'i',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
         (char const   )'e',      (char const   )'s',      (char const   )'-',      (char const   )'*', 
         (char const   )'-',      (char const   )')',      (char const   )'\000'};
 static void define_makeflags(int all , int makefile ) 
 { 
//Stmt6113:Leaf
register struct command_switch  const  *cs ;

//Stmt6114:Leaf
char *flagstring ;

//Stmt6115:Leaf
register char *p ;

//Stmt6116:Leaf
unsigned int words ;

//Stmt6117:Leaf
struct variable *v ;

//Stmt6118:Leaf
struct flag *flags ;

//Stmt6119:Leaf
unsigned int flagslen ;

//Stmt6120:Leaf
struct flag *new ;

//Stmt6121:Leaf
void *tmp ;

//Stmt6122:Leaf
size_t tmp___0 ;

//Stmt6123:Leaf
struct flag *new___0 ;

//Stmt6124:Leaf
void *tmp___1 ;

//Stmt6125:Leaf
size_t tmp___2 ;

//Stmt6126:Leaf
struct flag *new___1 ;

//Stmt6127:Leaf
void *tmp___3 ;

//Stmt6128:Leaf
size_t tmp___4 ;

//Stmt6129:Leaf
char *buf___1 ;

//Stmt6130:Leaf
void *tmp___5 ;

//Stmt6131:Leaf
struct flag *new___2 ;

//Stmt6132:Leaf
void *tmp___6 ;

//Stmt6133:Leaf
size_t tmp___7 ;

//Stmt6134:Leaf
size_t tmp___8 ;

//Stmt6135:Leaf
struct flag *new___3 ;

//Stmt6136:Leaf
void *tmp___9 ;

//Stmt6137:Leaf
size_t tmp___10 ;

//Stmt6138:Leaf
char *buf___2 ;

//Stmt6139:Leaf
void *tmp___11 ;

//Stmt6140:Leaf
struct flag *new___4 ;

//Stmt6141:Leaf
void *tmp___12 ;

//Stmt6142:Leaf
size_t tmp___13 ;

//Stmt6143:Leaf
size_t tmp___14 ;

//Stmt6144:Leaf
struct stringlist *sl ;

//Stmt6145:Leaf
register unsigned int i ;

//Stmt6146:Leaf
struct flag *new___5 ;

//Stmt6147:Leaf
void *tmp___15 ;

//Stmt6148:Leaf
size_t tmp___16 ;

//Stmt6149:Leaf
size_t tmp___17 ;

//Stmt6150:Leaf
unsigned int tmp___18 ;

//Stmt6151:Leaf
void *tmp___19 ;

//Stmt6152:Leaf
char *tmp___20 ;

//Stmt6153:Leaf
char *tmp___21 ;

//Stmt6154:Leaf
char *tmp___22 ;

//Stmt6155:Leaf
char *tmp___23 ;

//Stmt6156:Leaf
char *tmp___24 ;

//Stmt6157:Leaf
size_t tmp___25 ;

//Stmt6158:Leaf
char *tmp___26 ;

//Stmt6159:Leaf
char *tmp___27 ;

//Stmt6160:Leaf
char *tmp___28 ;

//Stmt6161:Leaf
char *tmp___29 ;

//Stmt6162:Leaf
char *tmp___30 ;

//Stmt6163:Leaf
char *tmp___31 ;

//Stmt6164:Leaf
char *tmp___32 ;

//Stmt6165:Leaf
char *tmp___33 ;

//Stmt6166:Leaf
char *tmp___34 ;

//Stmt6167:Leaf
int tmp___35 ;

 
   {
//Stmt6168:Leaf
flags = (struct flag *)0;

//Stmt6169:Leaf
flagslen = 0U;

//Stmt6170:Leaf
cs = switches;

//Stmt6171:Parent
while (cs->c != 0) {
//Stmt6033:Parent
if (cs->toenv) {
//Stmt6032:Parent
if (! makefile) {
//Stmt6030:Leaf
goto _L___4;

       } else
       {
//Stmt6031:Parent
if (! cs->no_makefile) {
         _L___4: /* CIL Label */ 
         {
//Stmt6029:Parent
switch ((unsigned int const   )cs->type) {
         default:; 
//Stmt5891:Leaf
abort();

         case 5U:; 
         break;
         case 1U:; 
         case 0U:; 
//Stmt5909:Parent
if (! *((int *)cs->value_ptr) == ((unsigned int const   )cs->type == 1U)) {
//Stmt5908:Parent
if ((unsigned long )cs->default_value == (unsigned long )((char * const  )0)) {
//Stmt5906:Leaf
goto _L;

           } else
           {
//Stmt5907:Parent
if (*((int *)cs->value_ptr) != *((int *)cs->default_value)) {
             _L: /* CIL Label */ 
             {
//Stmt5905:Parent
while (1) {
//Stmt5896:Leaf
tmp = __builtin_alloca(sizeof(struct flag ));

//Stmt5897:Leaf
new = (struct flag *)tmp;

//Stmt5898:Leaf
new->cs = cs;

//Stmt5899:Leaf
new->arg = (char *)0;

//Stmt5900:Leaf
new->next = flags;

//Stmt5901:Leaf
flags = new;

//Stmt5902:Parent
if ((unsigned long )new->arg == (unsigned long )((char *)0)) {
//Stmt5892:Leaf
flagslen ++;

               } else {
//Stmt5893:Leaf
flagslen += 4U;

               }

//Stmt5903:Parent
if (! (cs->c <= 127)) {
//Stmt5894:Leaf
tmp___0 = strlen((char const   *)cs->long_name);

//Stmt5895:Leaf
flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___0));

               }

//Stmt5904:Leaf
break;

             }
}

           }
}


         }

         break;
         case 3U:; 
//Stmt5964:Parent
if (all) {
//Stmt5963:Parent
if ((unsigned long )cs->default_value != (unsigned long )((char * const  )0)) {
//Stmt5962:Parent
if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->default_value)) {
//Stmt5910:Leaf
break;

             } else {
//Stmt5911:Leaf
goto _L___1;

             }

           } else
           _L___1: /* CIL Label */ 
           {
//Stmt5961:Parent
if ((unsigned long )cs->noarg_value != (unsigned long )((char * const  )0)) {
//Stmt5960:Parent
if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->noarg_value)) {
//Stmt5925:Parent
while (1) {
//Stmt5916:Leaf
tmp___1 = __builtin_alloca(sizeof(struct flag ));

//Stmt5917:Leaf
new___0 = (struct flag *)tmp___1;

//Stmt5918:Leaf
new___0->cs = cs;

//Stmt5919:Leaf
new___0->arg = (char *)"";

//Stmt5920:Leaf
new___0->next = flags;

//Stmt5921:Leaf
flags = new___0;

//Stmt5922:Parent
if ((unsigned long )new___0->arg == (unsigned long )((char *)0)) {
//Stmt5912:Leaf
flagslen ++;

                 } else {
//Stmt5913:Leaf
flagslen += 4U;

                 }

//Stmt5923:Parent
if (! (cs->c <= 127)) {
//Stmt5914:Leaf
tmp___2 = strlen((char const   *)cs->long_name);

//Stmt5915:Leaf
flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___2));

                 }

//Stmt5924:Leaf
break;

               }

             } else {
//Stmt5926:Leaf
goto _L___0;

             }

           } else
           _L___0: /* CIL Label */ 
           {
//Stmt5959:Parent
if (cs->c == 106) {
//Stmt5954:Parent
while (1) {
//Stmt5931:Leaf
tmp___3 = __builtin_alloca(sizeof(struct flag ));

//Stmt5932:Leaf
new___1 = (struct flag *)tmp___3;

//Stmt5933:Leaf
new___1->cs = cs;

//Stmt5934:Leaf
new___1->arg = (char *)"1";

//Stmt5935:Leaf
new___1->next = flags;

//Stmt5936:Leaf
flags = new___1;

//Stmt5937:Parent
if ((unsigned long )new___1->arg == (unsigned long )((char *)0)) {
//Stmt5927:Leaf
flagslen ++;

               } else {
//Stmt5928:Leaf
flagslen += 7U;

               }

//Stmt5938:Parent
if (! (cs->c <= 127)) {
//Stmt5929:Leaf
tmp___4 = strlen((char const   *)cs->long_name);

//Stmt5930:Leaf
flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___4));

               }

//Stmt5939:Leaf
break;

             }

           } else {
//Stmt5955:Leaf
tmp___5 = __builtin_alloca(30UL);

//Stmt5956:Leaf
buf___1 = (char *)tmp___5;

//Stmt5957:Leaf
sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%u",
                     *((unsigned int *)cs->value_ptr));

//Stmt5958:Parent
while (1) {
//Stmt5945:Leaf
tmp___6 = __builtin_alloca(sizeof(struct flag ));

//Stmt5946:Leaf
new___2 = (struct flag *)tmp___6;

//Stmt5947:Leaf
new___2->cs = cs;

//Stmt5948:Leaf
new___2->arg = buf___1;

//Stmt5949:Leaf
new___2->next = flags;

//Stmt5950:Leaf
flags = new___2;

//Stmt5951:Parent
if ((unsigned long )new___2->arg == (unsigned long )((char *)0)) {
//Stmt5940:Leaf
flagslen ++;

               } else {
//Stmt5941:Leaf
tmp___7 = strlen((char const   *)buf___1);

//Stmt5942:Leaf
flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___7));

               }

//Stmt5952:Parent
if (! (cs->c <= 127)) {
//Stmt5943:Leaf
tmp___8 = strlen((char const   *)cs->long_name);

//Stmt5944:Leaf
flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___8));

               }

//Stmt5953:Leaf
break;

             }

           }
}

}


         }

         break;
         case 4U:; 
//Stmt6004:Parent
if (all) {
//Stmt6003:Parent
if ((unsigned long )cs->default_value != (unsigned long )((char * const  )0)) {
//Stmt6002:Parent
if (*((double *)cs->value_ptr) == *((double *)cs->default_value)) {
//Stmt5965:Leaf
break;

             } else {
//Stmt5966:Leaf
goto _L___3;

             }

           } else
           _L___3: /* CIL Label */ 
           {
//Stmt6001:Parent
if ((unsigned long )cs->noarg_value != (unsigned long )((char * const  )0)) {
//Stmt5997:Parent
if (*((double *)cs->value_ptr) == *((double *)cs->noarg_value)) {
//Stmt5980:Parent
while (1) {
//Stmt5971:Leaf
tmp___9 = __builtin_alloca(sizeof(struct flag ));

//Stmt5972:Leaf
new___3 = (struct flag *)tmp___9;

//Stmt5973:Leaf
new___3->cs = cs;

//Stmt5974:Leaf
new___3->arg = (char *)"";

//Stmt5975:Leaf
new___3->next = flags;

//Stmt5976:Leaf
flags = new___3;

//Stmt5977:Parent
if ((unsigned long )new___3->arg == (unsigned long )((char *)0)) {
//Stmt5967:Leaf
flagslen ++;

                 } else {
//Stmt5968:Leaf
flagslen += 4U;

                 }

//Stmt5978:Parent
if (! (cs->c <= 127)) {
//Stmt5969:Leaf
tmp___10 = strlen((char const   *)cs->long_name);

//Stmt5970:Leaf
flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___10));

                 }

//Stmt5979:Leaf
break;

               }

             } else {
//Stmt5981:Leaf
goto _L___2;

             }

           } else {
             _L___2: /* CIL Label */ 
             {
//Stmt5982:Leaf
tmp___11 = __builtin_alloca(100UL);

}
//Stmt5998:Leaf
buf___2 = (char *)tmp___11;

//Stmt5999:Leaf
sprintf((char * __restrict  )buf___2, (char const   * __restrict  )"%g",
                     *((double *)cs->value_ptr));

//Stmt6000:Parent
while (1) {
//Stmt5988:Leaf
tmp___12 = __builtin_alloca(sizeof(struct flag ));

//Stmt5989:Leaf
new___4 = (struct flag *)tmp___12;

//Stmt5990:Leaf
new___4->cs = cs;

//Stmt5991:Leaf
new___4->arg = buf___2;

//Stmt5992:Leaf
new___4->next = flags;

//Stmt5993:Leaf
flags = new___4;

//Stmt5994:Parent
if ((unsigned long )new___4->arg == (unsigned long )((char *)0)) {
//Stmt5983:Leaf
flagslen ++;

               } else {
//Stmt5984:Leaf
tmp___13 = strlen((char const   *)buf___2);

//Stmt5985:Leaf
flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___13));

               }

//Stmt5995:Parent
if (! (cs->c <= 127)) {
//Stmt5986:Leaf
tmp___14 = strlen((char const   *)cs->long_name);

//Stmt5987:Leaf
flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___14));

               }

//Stmt5996:Leaf
break;

             }

           }
}


         }

         break;
         case 2U:; 
//Stmt6028:Parent
if (all) {
//Stmt6026:Leaf
sl = *((struct stringlist **)cs->value_ptr);

//Stmt6027:Parent
if ((unsigned long )sl != (unsigned long )((struct stringlist *)0)) {
//Stmt6024:Leaf
i = sl->idx;

//Stmt6025:Parent
while (1) {
//Stmt6020:Leaf
tmp___18 = i;

//Stmt6021:Leaf
i --;

//Stmt6022:Parent
if (! (tmp___18 > 0U)) {
//Stmt6005:Leaf
break;

               }

//Stmt6023:Parent
while (1) {
//Stmt6011:Leaf
tmp___15 = __builtin_alloca(sizeof(struct flag ));

//Stmt6012:Leaf
new___5 = (struct flag *)tmp___15;

//Stmt6013:Leaf
new___5->cs = cs;

//Stmt6014:Leaf
new___5->arg = *(sl->list + i);

//Stmt6015:Leaf
new___5->next = flags;

//Stmt6016:Leaf
flags = new___5;

//Stmt6017:Parent
if ((unsigned long )new___5->arg == (unsigned long )((char *)0)) {
//Stmt6006:Leaf
flagslen ++;

                 } else {
//Stmt6007:Leaf
tmp___16 = strlen((char const   *)*(sl->list + i));

//Stmt6008:Leaf
flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___16));

                 }

//Stmt6018:Parent
if (! (cs->c <= 127)) {
//Stmt6009:Leaf
tmp___17 = strlen((char const   *)cs->long_name);

//Stmt6010:Leaf
flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___17));

                 }

//Stmt6019:Leaf
break;

               }

             }

           }

         }

         break;
         }
}

       }
}


     }

//Stmt6034:Leaf
cs ++;

   }

//Stmt6172:Leaf
flagslen = (unsigned int )((unsigned long )flagslen + (4UL + sizeof(posixref)));

//Stmt6173:Leaf
tmp___19 = __builtin_alloca((unsigned long )((1U + flagslen) + 1U));

//Stmt6174:Leaf
flagstring = (char *)tmp___19;

//Stmt6175:Leaf
memset((void *)flagstring, 0, (size_t )((1U + flagslen) + 1U));

//Stmt6176:Leaf
p = flagstring;

//Stmt6177:Leaf
words = 1U;

//Stmt6178:Leaf
tmp___20 = p;

//Stmt6179:Leaf
p ++;

//Stmt6180:Leaf
*tmp___20 = (char )'-';

//Stmt6181:Parent
while ((unsigned long )flags != (unsigned long )((struct flag *)0)) {
//Stmt6073:Parent
if ((flags->cs)->c <= 127) {
//Stmt6041:Leaf
tmp___21 = p;

//Stmt6042:Leaf
p ++;

//Stmt6043:Leaf
*tmp___21 = (char )(flags->cs)->c;

     } else {
//Stmt6044:Parent
if ((int )*p != 45) {
//Stmt6035:Leaf
tmp___22 = p;

//Stmt6036:Leaf
p ++;

//Stmt6037:Leaf
*tmp___22 = (char )' ';

//Stmt6038:Leaf
tmp___23 = p;

//Stmt6039:Leaf
p ++;

//Stmt6040:Leaf
*tmp___23 = (char )'-';

       }

//Stmt6045:Leaf
tmp___24 = p;

//Stmt6046:Leaf
p ++;

//Stmt6047:Leaf
*tmp___24 = (char )'-';

//Stmt6048:Leaf
strcpy((char * __restrict  )p, (char const   * __restrict  )(flags->cs)->long_name);

//Stmt6049:Leaf
tmp___25 = strlen((char const   *)p);

//Stmt6050:Leaf
p += tmp___25;

     }

//Stmt6074:Parent
if ((unsigned long )flags->arg != (unsigned long )((char *)0)) {
//Stmt6064:Parent
if ((int )*(flags->arg + 0) != 0) {
//Stmt6053:Leaf
tmp___26 = p;

//Stmt6054:Leaf
p ++;

//Stmt6055:Parent
if (! ((flags->cs)->c <= 127)) {
//Stmt6051:Leaf
*tmp___26 = (char )'=';

         } else {
//Stmt6052:Leaf
*tmp___26 = (char )' ';

         }

//Stmt6056:Leaf
p = quote_for_env(p, flags->arg);

       }

//Stmt6065:Leaf
words ++;

//Stmt6066:Leaf
tmp___27 = p;

//Stmt6067:Leaf
p ++;

//Stmt6068:Leaf
*tmp___27 = (char )' ';

//Stmt6069:Leaf
tmp___28 = p;

//Stmt6070:Leaf
p ++;

//Stmt6071:Leaf
*tmp___28 = (char )'-';

     } else
     {
//Stmt6072:Parent
if (! ((flags->cs)->c <= 127)) {
//Stmt6057:Leaf
words ++;

//Stmt6058:Leaf
tmp___29 = p;

//Stmt6059:Leaf
p ++;

//Stmt6060:Leaf
*tmp___29 = (char )' ';

//Stmt6061:Leaf
tmp___30 = p;

//Stmt6062:Leaf
p ++;

//Stmt6063:Leaf
*tmp___30 = (char )'-';

     }
}


//Stmt6075:Leaf
flags = flags->next;

   }

//Stmt6182:Parent
if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
//Stmt6079:Leaf
*(flagstring + 0) = (char )'\000';

   } else
   {
//Stmt6080:Parent
if ((int )*(p + -1) == 45) {
//Stmt6076:Leaf
p -= 2;

//Stmt6077:Leaf
*p = (char )'\000';

   } else {
//Stmt6078:Leaf
*p = (char )'\000';

   }
}


//Stmt6183:Leaf
define_variable_in_set((char *)"MFLAGS", 6U, flagstring, (enum variable_origin )1,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt6184:Parent
if (all) {
//Stmt6107:Parent
if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
//Stmt6099:Parent
if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
//Stmt6087:Leaf
p = flagstring;

       } else {
//Stmt6088:Parent
if ((int )*(p + -1) != 45) {
//Stmt6081:Leaf
tmp___31 = p;

//Stmt6082:Leaf
p ++;

//Stmt6083:Leaf
*tmp___31 = (char )' ';

//Stmt6084:Leaf
tmp___32 = p;

//Stmt6085:Leaf
p ++;

//Stmt6086:Leaf
*tmp___32 = (char )'-';

         }

//Stmt6089:Leaf
tmp___33 = p;

//Stmt6090:Leaf
p ++;

//Stmt6091:Leaf
*tmp___33 = (char )'-';

//Stmt6092:Leaf
tmp___34 = p;

//Stmt6093:Leaf
p ++;

//Stmt6094:Leaf
*tmp___34 = (char )' ';

       }

//Stmt6100:Parent
if (posix_pedantic) {
//Stmt6095:Leaf
memmove((void *)p, (void const   *)(posixref), sizeof(posixref) - 1UL);

//Stmt6096:Leaf
p += sizeof(posixref) - 1UL;

       } else {
//Stmt6097:Leaf
memmove((void *)p, (void const   *)(ref), sizeof(ref) - 1UL);

//Stmt6098:Leaf
p += sizeof(ref) - 1UL;

       }

     } else {
//Stmt6101:Leaf
goto _L___5;

     }

   } else
   _L___5: /* CIL Label */ 
   {
//Stmt6106:Parent
if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
//Stmt6103:Leaf
words = 0U;

//Stmt6104:Leaf
p --;

   } else
   {
//Stmt6105:Parent
if ((int )*(p + -1) == 45) {
//Stmt6102:Leaf
p -= 2;

   }
}

}


//Stmt6185:Leaf
*p = (char )'\000';

//Stmt6186:Parent
if ((int )*(flagstring + 0) == 45) {
//Stmt6110:Parent
if ((int )*(flagstring + 1) != 45) {
//Stmt6108:Leaf
tmp___35 = 1;

     } else {
//Stmt6109:Leaf
tmp___35 = 0;

     }

   } else {
//Stmt6111:Leaf
tmp___35 = 0;

   }

//Stmt6187:Leaf
v = define_variable_in_set((char *)"MAKEFLAGS", 9U, flagstring + tmp___35, (enum variable_origin )2,
                              1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt6188:Parent
if (! all) {
//Stmt6112:Leaf
v->export = (enum variable_export )0;

   }

//Stmt6189:Leaf
return;

 }
}
 char *make_host ;
 static int printed_version  =    0;
 static void print_version(void) 
 { 
//Stmt6195:Leaf
char *precede ;

//Stmt6196:Leaf
char const   *tmp ;

//Stmt6197:Leaf
char *tmp___0 ;

 
   {
//Stmt6198:Parent
if (print_data_base_flag) {
//Stmt6190:Leaf
tmp = "# ";

   } else {
//Stmt6191:Leaf
tmp = "";

   }

//Stmt6199:Leaf
precede = (char *)tmp;

//Stmt6200:Parent
if (printed_version) {
//Stmt6192:Leaf
return;

   }

//Stmt6201:Leaf
printf((char const   * __restrict  )"%sGNU Make version %s", precede, version_string);

//Stmt6202:Parent
if ((unsigned long )remote_description != (unsigned long )((char *)0)) {
//Stmt6194:Parent
if ((int )*remote_description != 0) {
//Stmt6193:Leaf
printf((char const   * __restrict  )"-%s", remote_description);

     }

   }

//Stmt6203:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), ", by Richard Stallman and Roland McGrath.\n%sBuilt for %s\n%sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n%s\tFree Software Foundation, Inc.\n%sThis is free software; see the source for copying conditions.\n%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n%sPARTICULAR PURPOSE.\n\n%sReport bugs to <bug-make@gnu.org>.\n\n",
                       5);

//Stmt6204:Leaf
printf((char const   * __restrict  )tmp___0, precede, make_host, precede, precede,
          precede, precede, precede, precede);

//Stmt6205:Leaf
printed_version = 1;

//Stmt6206:Leaf
fflush(stdout);

//Stmt6207:Leaf
return;

 }
}
 static void print_data_base(void) 
 { 
//Stmt6208:Leaf
time_t when ;

//Stmt6209:Leaf
char *tmp ;

//Stmt6210:Leaf
char *tmp___0 ;

//Stmt6211:Leaf
char *tmp___1 ;

//Stmt6212:Leaf
char *tmp___2 ;

 
   {
//Stmt6213:Leaf
when = time((time_t *)0);

//Stmt6214:Leaf
tmp = ctime((time_t const   *)(& when));

//Stmt6215:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "\n# Make data base, printed on %s",
                       5);

//Stmt6216:Leaf
printf((char const   * __restrict  )tmp___0, tmp);

//Stmt6217:Leaf
print_variable_data_base();

//Stmt6218:Leaf
print_dir_data_base();

//Stmt6219:Leaf
print_rule_data_base();

//Stmt6220:Leaf
print_file_data_base();

//Stmt6221:Leaf
print_vpath_data_base();

//Stmt6222:Leaf
when = time((time_t *)0);

//Stmt6223:Leaf
tmp___1 = ctime((time_t const   *)(& when));

//Stmt6224:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "\n# Finished Make data base on %s\n",
                       5);

//Stmt6225:Leaf
printf((char const   * __restrict  )tmp___2, tmp___1);

//Stmt6226:Leaf
return;

 }
}
 static char dying  =    (char)0;
  __attribute__((__noreturn__)) void die(int status ) ;
 void die(int status ) 
 { 
//Stmt6241:Leaf
int err ;

 
   {
//Stmt6242:Parent
if (! dying) {
//Stmt6232:Leaf
dying = (char)1;

//Stmt6233:Parent
if (print_version_flag) {
//Stmt6227:Leaf
print_version();

     }

//Stmt6234:Leaf
err = status != 0;

//Stmt6235:Parent
while (job_slots_used > 0U) {
//Stmt6228:Leaf
reap_children(1, err);

//Stmt6229:Leaf
err = 0;

     }

//Stmt6236:Leaf
remote_cleanup();

//Stmt6237:Leaf
remove_intermediates(0);

//Stmt6238:Parent
if (print_data_base_flag) {
//Stmt6230:Leaf
print_data_base();

     }

//Stmt6239:Parent
if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
//Stmt6231:Leaf
chdir((char const   *)directory_before_chdir);

     }

//Stmt6240:Leaf
log_working_directory(0);

   }

//Stmt6243:Leaf
exit(status);

 }
}
 static int entered  =    0;
 void log_working_directory(int entering ) 
 { 
//Stmt6258:Leaf
char *msg ;

//Stmt6259:Leaf
char *tmp ;

//Stmt6260:Leaf
char *tmp___0 ;

//Stmt6261:Leaf
char *tmp___1 ;

//Stmt6262:Leaf
char *tmp___2 ;

//Stmt6263:Leaf
char *tmp___3 ;

 
   {
//Stmt6264:Parent
if (entering) {
//Stmt6244:Leaf
tmp = dcgettext((char const   *)((void *)0), "Entering", 5);

//Stmt6245:Leaf
tmp___1 = tmp;

   } else {
//Stmt6246:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "Leaving", 5);

//Stmt6247:Leaf
tmp___1 = tmp___0;

   }

//Stmt6265:Leaf
msg = tmp___1;

//Stmt6266:Parent
if (! print_directory_flag) {
//Stmt6249:Leaf
return;

   } else
   {
//Stmt6250:Parent
if (entering == entered) {
//Stmt6248:Leaf
return;

   }
}


//Stmt6267:Leaf
entered = entering;

//Stmt6268:Parent
if (print_data_base_flag) {
//Stmt6251:Leaf
fputs((char const   * __restrict  )"# ", (FILE * __restrict  )stdout);

   }

//Stmt6269:Parent
if (makelevel == 0U) {
//Stmt6252:Leaf
printf((char const   * __restrict  )"%s: %s ", program, msg);

   } else {
//Stmt6253:Leaf
printf((char const   * __restrict  )"%s[%u]: %s ", program, makelevel, msg);

   }

//Stmt6270:Parent
if ((unsigned long )starting_directory == (unsigned long )((char *)0)) {
//Stmt6254:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "an unknown directory", 5);

//Stmt6255:Leaf
puts((char const   *)tmp___2);

   } else {
//Stmt6256:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "directory `%s\'\n", 5);

//Stmt6257:Leaf
printf((char const   * __restrict  )tmp___3, starting_directory);

   }

//Stmt6271:Leaf
return;

 }
}
 /* compiler builtin: 
    void __builtin_va_start(__builtin_va_list  ) ;  */
 /* compiler builtin: 
    void __builtin_va_end(__builtin_va_list  ) ;  */
 #pragma merger("0","/tmp/cil-jXxeXTt3.i","-g,-O0")
 extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
 extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                     __gnuc_va_list __arg ) ;
 extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
 extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
 extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
 extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
 __leaf__)) realloc)(void *__ptr , size_t __size ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int errnum ) ;
 void collapse_continuations(char *line ) ;
 void remove_comments(char *line ) ;
 char *find_char_unquote(char *string , char *stopchars , int blank ) ;
 struct dep *copy_dep_chain(struct dep *d ) ;
 int alpha_compare(void const   *v1 , void const   *v2 ) 
 { 
//Stmt6273:Leaf
char const   *s1 ;

//Stmt6274:Leaf
char const   *s2 ;

//Stmt6275:Leaf
int tmp ;

 
   {
//Stmt6276:Leaf
s1 = (char const   *)*((char **)v1);

//Stmt6277:Leaf
s2 = (char const   *)*((char **)v2);

//Stmt6278:Parent
if ((int const   )*s1 != (int const   )*s2) {
//Stmt6272:Leaf
return ((int )((int const   )*s1 - (int const   )*s2));

   }

//Stmt6279:Leaf
tmp = strcmp(s1, s2);

//Stmt6280:Leaf
return (tmp);

 }
}
 void collapse_continuations(char *line ) 
 { 
//Stmt6344:Leaf
register char *in ;

//Stmt6345:Leaf
register char *out ;

//Stmt6346:Leaf
register char *p ;

//Stmt6347:Leaf
register int backslash ;

//Stmt6348:Leaf
register unsigned int bs_write ;

//Stmt6349:Leaf
char *tmp ;

//Stmt6350:Leaf
unsigned int tmp___0 ;

//Stmt6351:Leaf
unsigned short const   **tmp___1 ;

//Stmt6352:Leaf
char *tmp___2 ;

//Stmt6353:Leaf
char *tmp___3 ;

//Stmt6354:Leaf
char *tmp___4 ;

//Stmt6355:Leaf
char *tmp___5 ;

//Stmt6356:Leaf
char *tmp___6 ;

//Stmt6357:Leaf
char *tmp___7 ;

 
   {
//Stmt6358:Leaf
in = strchr((char const   *)line, '\n');

//Stmt6359:Parent
if ((unsigned long )in == (unsigned long )((char *)0)) {
//Stmt6281:Leaf
return;

   }

//Stmt6360:Leaf
out = in;

//Stmt6361:Parent
while (1) {
//Stmt6285:Parent
if ((unsigned long )out > (unsigned long )line) {
//Stmt6283:Parent
if (! ((int )*(out + -1) == 92)) {
//Stmt6282:Leaf
break;

       }

     } else {
//Stmt6284:Leaf
break;

     }

//Stmt6286:Leaf
out --;

   }

//Stmt6362:Parent
while ((int )*in != 0) {
//Stmt6336:Leaf
backslash = 0;

//Stmt6337:Leaf
bs_write = 0U;

//Stmt6338:Leaf
p = in - 1;

//Stmt6339:Parent
while (1) {
//Stmt6292:Parent
if ((unsigned long )p >= (unsigned long )line) {
//Stmt6288:Parent
if (! ((int )*p == 92)) {
//Stmt6287:Leaf
break;

         }

       } else {
//Stmt6289:Leaf
break;

       }

//Stmt6293:Parent
if (backslash) {
//Stmt6290:Leaf
bs_write ++;

       }

//Stmt6294:Leaf
backslash = ! backslash;

//Stmt6295:Parent
if ((unsigned long )in == (unsigned long )(out - 1)) {
//Stmt6291:Leaf
abort();

       }

//Stmt6296:Leaf
p --;

     }

//Stmt6340:Parent
while (1) {
//Stmt6298:Leaf
tmp___0 = bs_write;

//Stmt6299:Leaf
bs_write --;

//Stmt6300:Parent
if (! (tmp___0 > 0U)) {
//Stmt6297:Leaf
break;

       }

//Stmt6301:Leaf
tmp = out;

//Stmt6302:Leaf
out ++;

//Stmt6303:Leaf
*tmp = (char )'\\';

     }

//Stmt6341:Leaf
in ++;

//Stmt6342:Parent
if (backslash) {
//Stmt6310:Leaf
in = next_token(in);

//Stmt6311:Parent
while (1) {
//Stmt6308:Parent
if ((unsigned long )out > (unsigned long )line) {
//Stmt6305:Leaf
tmp___1 = __ctype_b_loc();

//Stmt6306:Parent
if (! ((int const   )*(*tmp___1 + (int )*(out + -1)) & 1)) {
//Stmt6304:Leaf
break;

           }

         } else {
//Stmt6307:Leaf
break;

         }

//Stmt6309:Leaf
out --;

       }

//Stmt6312:Leaf
tmp___2 = out;

//Stmt6313:Leaf
out ++;

//Stmt6314:Leaf
*tmp___2 = (char )' ';

     } else {
//Stmt6315:Leaf
tmp___3 = out;

//Stmt6316:Leaf
out ++;

//Stmt6317:Leaf
*tmp___3 = (char )'\n';

     }

//Stmt6343:Parent
while ((int )*in != 0) {
//Stmt6335:Parent
if ((int )*in == 92) {
//Stmt6326:Leaf
p = in + 1;

//Stmt6327:Parent
while ((int )*p == 92) {
//Stmt6318:Leaf
p ++;

         }

//Stmt6328:Parent
if ((int )*p == 10) {
//Stmt6319:Leaf
in = p;

//Stmt6320:Leaf
break;

         }

//Stmt6329:Parent
while ((unsigned long )in < (unsigned long )p) {
//Stmt6321:Leaf
tmp___4 = out;

//Stmt6322:Leaf
out ++;

//Stmt6323:Leaf
tmp___5 = in;

//Stmt6324:Leaf
in ++;

//Stmt6325:Leaf
*tmp___4 = *tmp___5;

         }

       } else {
//Stmt6330:Leaf
tmp___6 = out;

//Stmt6331:Leaf
out ++;

//Stmt6332:Leaf
tmp___7 = in;

//Stmt6333:Leaf
in ++;

//Stmt6334:Leaf
*tmp___6 = *tmp___7;

       }

     }

   }

//Stmt6363:Leaf
*out = (char )'\000';

//Stmt6364:Leaf
return;

 }
}
 void remove_comments(char *line ) 
 { 
//Stmt6366:Leaf
char *comment ;

 
   {
//Stmt6367:Leaf
comment = find_char_unquote(line, (char *)"#", 0);

//Stmt6368:Parent
if ((unsigned long )comment != (unsigned long )((char *)0)) {
//Stmt6365:Leaf
*comment = (char )'\000';

   }

//Stmt6369:Leaf
return;

 }
}
 void print_spaces(unsigned int n ) 
 { 
//Stmt6375:Leaf
unsigned int tmp ;

 
   {
//Stmt6376:Parent
while (1) {
//Stmt6371:Leaf
tmp = n;

//Stmt6372:Leaf
n --;

//Stmt6373:Parent
if (! (tmp > 0U)) {
//Stmt6370:Leaf
break;

     }

//Stmt6374:Leaf
putchar(' ');

   }

//Stmt6377:Leaf
return;

 }
}
 char *concat(char *s1 , char *s2 , char *s3 ) 
 { 
//Stmt6390:Leaf
register unsigned int len1 ;

//Stmt6391:Leaf
register unsigned int len2 ;

//Stmt6392:Leaf
register unsigned int len3 ;

//Stmt6393:Leaf
register char *result___0 ;

//Stmt6394:Leaf
size_t tmp ;

//Stmt6395:Leaf
size_t tmp___0 ;

//Stmt6396:Leaf
size_t tmp___1 ;

//Stmt6397:Leaf
char *tmp___2 ;

 
   {
//Stmt6398:Parent
if ((int )*s1 != 0) {
//Stmt6378:Leaf
tmp = strlen((char const   *)s1);

//Stmt6379:Leaf
len1 = (unsigned int )tmp;

   } else {
//Stmt6380:Leaf
len1 = 0U;

   }

//Stmt6399:Parent
if ((int )*s2 != 0) {
//Stmt6381:Leaf
tmp___0 = strlen((char const   *)s2);

//Stmt6382:Leaf
len2 = (unsigned int )tmp___0;

   } else {
//Stmt6383:Leaf
len2 = 0U;

   }

//Stmt6400:Parent
if ((int )*s3 != 0) {
//Stmt6384:Leaf
tmp___1 = strlen((char const   *)s3);

//Stmt6385:Leaf
len3 = (unsigned int )tmp___1;

   } else {
//Stmt6386:Leaf
len3 = 0U;

   }

//Stmt6401:Leaf
tmp___2 = xmalloc(((len1 + len2) + len3) + 1U);

//Stmt6402:Leaf
result___0 = tmp___2;

//Stmt6403:Parent
if ((int )*s1 != 0) {
//Stmt6387:Leaf
memmove((void *)result___0, (void const   *)s1, (size_t )len1);

   }

//Stmt6404:Parent
if ((int )*s2 != 0) {
//Stmt6388:Leaf
memmove((void *)(result___0 + len1), (void const   *)s2, (size_t )len2);

   }

//Stmt6405:Parent
if ((int )*s3 != 0) {
//Stmt6389:Leaf
memmove((void *)((result___0 + len1) + len2), (void const   *)s3, (size_t )len3);

   }

//Stmt6406:Leaf
*(((result___0 + len1) + len2) + len3) = (char )'\000';

//Stmt6407:Leaf
return (result___0);

 }
}
 void ( /* format attribute */  message)(int prefix , char const   *fmt  , ...) 
 { 
//Stmt6416:Leaf
va_list args ;

 
   {
//Stmt6417:Leaf
log_working_directory(1);

//Stmt6418:Parent
if ((unsigned long )fmt != (unsigned long )((char const   *)0)) {
//Stmt6411:Parent
if (prefix) {
//Stmt6410:Parent
if (makelevel == 0U) {
//Stmt6408:Leaf
printf((char const   * __restrict  )"%s: ", program);

       } else {
//Stmt6409:Leaf
printf((char const   * __restrict  )"%s[%u]: ", program, makelevel);

       }

     }

//Stmt6412:Leaf
__builtin_va_start(args, fmt);

//Stmt6413:Leaf
vfprintf((FILE * __restrict  )stdout, (char const   * __restrict  )fmt, args);

//Stmt6414:Leaf
__builtin_va_end(args);

//Stmt6415:Leaf
putchar('\n');

   }

//Stmt6419:Leaf
fflush(stdout);

//Stmt6420:Leaf
return;

 }
}
 void ( /* format attribute */  error)(struct floc  const  *flocp , char const   *fmt 
                                       , ...) 
 { 
//Stmt6427:Leaf
va_list args ;

 
   {
//Stmt6428:Leaf
log_working_directory(1);

//Stmt6429:Parent
if (flocp) {
//Stmt6426:Parent
if (flocp->filenm) {
//Stmt6421:Leaf
fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%lu: ",
               flocp->filenm, flocp->lineno);

     } else {
//Stmt6422:Leaf
goto _L;

     }

   } else
   _L: /* CIL Label */ 
   {
//Stmt6425:Parent
if (makelevel == 0U) {
//Stmt6423:Leaf
fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", program);

   } else {
//Stmt6424:Leaf
fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s[%u]: ",
             program, makelevel);

   }
}


//Stmt6430:Leaf
__builtin_va_start(args, fmt);

//Stmt6431:Leaf
vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);

//Stmt6432:Leaf
__builtin_va_end(args);

//Stmt6433:Leaf
_IO_putc('\n', stderr);

//Stmt6434:Leaf
fflush(stderr);

//Stmt6435:Leaf
return;

 }
}
  __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(struct floc  const  *flocp ,
                                                                      char const   *fmt 
                                                                      , ...) ;
 void ( /* format attribute */  fatal)(struct floc  const  *flocp , char const   *fmt 
                                       , ...) 
 { 
//Stmt6442:Leaf
va_list args ;

//Stmt6443:Leaf
char *tmp ;

 
   {
//Stmt6444:Leaf
log_working_directory(1);

//Stmt6445:Parent
if (flocp) {
//Stmt6441:Parent
if (flocp->filenm) {
//Stmt6436:Leaf
fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%lu: *** ",
               flocp->filenm, flocp->lineno);

     } else {
//Stmt6437:Leaf
goto _L;

     }

   } else
   _L: /* CIL Label */ 
   {
//Stmt6440:Parent
if (makelevel == 0U) {
//Stmt6438:Leaf
fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: *** ",
             program);

   } else {
//Stmt6439:Leaf
fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s[%u]: *** ",
             program, makelevel);

   }
}


//Stmt6446:Leaf
__builtin_va_start(args, fmt);

//Stmt6447:Leaf
vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);

//Stmt6448:Leaf
__builtin_va_end(args);

//Stmt6449:Leaf
tmp = dcgettext((char const   *)((void *)0), ".  Stop.\n", 5);

//Stmt6450:Leaf
fputs((char const   * __restrict  )tmp, (FILE * __restrict  )stderr);

//Stmt6451:Leaf
die(2);

 }
}
 void perror_with_name(char *str , char *name ) 
 { 
//Stmt6452:Leaf
int *tmp ;

//Stmt6453:Leaf
char *tmp___0 ;

 
   {
//Stmt6454:Leaf
tmp = __errno_location();

//Stmt6455:Leaf
tmp___0 = strerror(*tmp);

//Stmt6456:Leaf
error((struct floc  const  *)((struct floc *)0), "%s%s: %s", str, name, tmp___0);

//Stmt6457:Leaf
return;

 }
}
  __attribute__((__noreturn__)) void pfatal_with_name(char *name ) ;
 void pfatal_with_name(char *name ) 
 { 
//Stmt6458:Leaf
int *tmp ;

//Stmt6459:Leaf
char *tmp___0 ;

 
   {
//Stmt6460:Leaf
tmp = __errno_location();

//Stmt6461:Leaf
tmp___0 = strerror(*tmp);

//Stmt6462:Leaf
fatal((struct floc  const  *)((struct floc *)0), "%s: %s", name, tmp___0);

 }
}
 char *xmalloc(unsigned int size ) 
 { 
//Stmt6465:Leaf
char *result___0 ;

//Stmt6466:Leaf
void *tmp ;

//Stmt6467:Leaf
char *tmp___0 ;

 
   {
//Stmt6468:Leaf
tmp = malloc((size_t )size);

//Stmt6469:Leaf
result___0 = (char *)tmp;

//Stmt6470:Parent
if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
//Stmt6463:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);

//Stmt6464:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0);

   }

//Stmt6471:Leaf
return (result___0);

 }
}
 char *xrealloc(char *ptr , unsigned int size ) 
 { 
//Stmt6478:Leaf
char *result___0 ;

//Stmt6479:Leaf
void *tmp ;

//Stmt6480:Leaf
void *tmp___0 ;

//Stmt6481:Leaf
char *tmp___1 ;

 
   {
//Stmt6482:Parent
if (ptr) {
//Stmt6472:Leaf
tmp = realloc((void *)ptr, (size_t )size);

//Stmt6473:Leaf
result___0 = (char *)tmp;

   } else {
//Stmt6474:Leaf
tmp___0 = malloc((size_t )size);

//Stmt6475:Leaf
result___0 = (char *)tmp___0;

   }

//Stmt6483:Parent
if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
//Stmt6476:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);

//Stmt6477:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1);

   }

//Stmt6484:Leaf
return (result___0);

 }
}
 char *xstrdup(char const   *ptr ) 
 { 
//Stmt6487:Leaf
char *result___0 ;

//Stmt6488:Leaf
char *tmp ;

 
   {
//Stmt6489:Leaf
result___0 = strdup(ptr);

//Stmt6490:Parent
if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
//Stmt6485:Leaf
tmp = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);

//Stmt6486:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp);

   }

//Stmt6491:Leaf
return (result___0);

 }
}
 char *savestring(char const   *str , unsigned int length___0 ) 
 { 
//Stmt6493:Leaf
register char *out ;

//Stmt6494:Leaf
char *tmp ;

 
   {
//Stmt6495:Leaf
tmp = xmalloc(length___0 + 1U);

//Stmt6496:Leaf
out = tmp;

//Stmt6497:Parent
if (length___0 > 0U) {
//Stmt6492:Leaf
memmove((void *)out, (void const   *)str, (size_t )length___0);

   }

//Stmt6498:Leaf
*(out + length___0) = (char )'\000';

//Stmt6499:Leaf
return (out);

 }
}
 char *sindex(char const   *big , unsigned int blen , char const   *small , unsigned int slen ) 
 { 
//Stmt6515:Leaf
size_t tmp ;

//Stmt6516:Leaf
size_t tmp___0 ;

//Stmt6517:Leaf
register unsigned int b ;

//Stmt6518:Leaf
int tmp___1 ;

 
   {
//Stmt6519:Parent
if (! blen) {
//Stmt6500:Leaf
tmp = strlen(big);

//Stmt6501:Leaf
blen = (unsigned int )tmp;

   }

//Stmt6520:Parent
if (! slen) {
//Stmt6502:Leaf
tmp___0 = strlen(small);

//Stmt6503:Leaf
slen = (unsigned int )tmp___0;

   }

//Stmt6521:Parent
if (slen) {
//Stmt6514:Parent
if (blen >= slen) {
//Stmt6510:Leaf
slen --;

//Stmt6511:Leaf
blen -= slen;

//Stmt6512:Leaf
b = 0U;

//Stmt6513:Parent
while (b < blen) {
//Stmt6507:Parent
if ((int const   )*big == (int const   )*small) {
//Stmt6505:Leaf
tmp___1 = strncmp(big + 1, small + 1, (size_t )slen);

//Stmt6506:Parent
if (tmp___1 == 0) {
//Stmt6504:Leaf
return ((char *)big);

           }

         }

//Stmt6508:Leaf
b ++;

//Stmt6509:Leaf
big ++;

       }

     }

   }

//Stmt6522:Leaf
return ((char *)0);

 }
}
 char *lindex(char const   *s , char const   *limit , int c ) 
 { 
//Stmt6527:Leaf
char const   *tmp ;

 
   {
//Stmt6528:Parent
while ((unsigned long )s < (unsigned long )limit) {
//Stmt6524:Leaf
tmp = s;

//Stmt6525:Leaf
s ++;

//Stmt6526:Parent
if ((int const   )*tmp == (int const   )c) {
//Stmt6523:Leaf
return ((char *)(s - 1));

     }

   }

//Stmt6529:Leaf
return ((char *)0);

 }
}
 char *end_of_token(char *s ) 
 { 
//Stmt6536:Leaf
unsigned short const   **tmp ;

 
   {
//Stmt6537:Parent
while (1) {
//Stmt6534:Parent
if ((int )*s != 0) {
//Stmt6531:Leaf
tmp = __ctype_b_loc();

//Stmt6532:Parent
if ((int const   )*(*tmp + (int )*s) & 1) {
//Stmt6530:Leaf
break;

       }

     } else {
//Stmt6533:Leaf
break;

     }

//Stmt6535:Leaf
s ++;

   }

//Stmt6538:Leaf
return (s);

 }
}
 char *next_token(char *s ) 
 { 
//Stmt6543:Leaf
register char *p ;

//Stmt6544:Leaf
unsigned short const   **tmp ;

 
   {
//Stmt6545:Leaf
p = s;

//Stmt6546:Parent
while (1) {
//Stmt6540:Leaf
tmp = __ctype_b_loc();

//Stmt6541:Parent
if (! ((int const   )*(*tmp + (int )*p) & 1)) {
//Stmt6539:Leaf
break;

     }

//Stmt6542:Leaf
p ++;

   }

//Stmt6547:Leaf
return (p);

 }
}
 char *find_next_token(char **ptr , unsigned int *lengthptr ) 
 { 
//Stmt6550:Leaf
char *p ;

//Stmt6551:Leaf
char *tmp ;

//Stmt6552:Leaf
char *end ;

 
   {
//Stmt6553:Leaf
tmp = next_token(*ptr);

//Stmt6554:Leaf
p = tmp;

//Stmt6555:Parent
if ((int )*p == 0) {
//Stmt6548:Leaf
return ((char *)0);

   }

//Stmt6556:Leaf
end = end_of_token(p);

//Stmt6557:Leaf
*ptr = end;

//Stmt6558:Parent
if ((unsigned long )lengthptr != (unsigned long )((unsigned int *)0)) {
//Stmt6549:Leaf
*lengthptr = (unsigned int )(end - p);

   }

//Stmt6559:Leaf
return (p);

 }
}
 struct dep *copy_dep_chain(struct dep *d ) 
 { 
//Stmt6573:Leaf
register struct dep *c ;

//Stmt6574:Leaf
struct dep *firstnew ;

//Stmt6575:Leaf
struct dep *lastnew ;

//Stmt6576:Leaf
char *tmp ;

//Stmt6577:Leaf
struct dep *tmp___0 ;

 
   {
//Stmt6578:Leaf
firstnew = (struct dep *)0;

//Stmt6579:Leaf
lastnew = (struct dep *)0;

//Stmt6580:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt6566:Leaf
tmp = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt6567:Leaf
c = (struct dep *)tmp;

//Stmt6568:Leaf
memmove((void *)((char *)c), (void const   *)((char *)d), sizeof(struct dep ));

//Stmt6569:Parent
if ((unsigned long )c->name != (unsigned long )((char *)0)) {
//Stmt6560:Leaf
c->name = xstrdup((char const   *)c->name);

     }

//Stmt6570:Leaf
c->next = (struct dep *)0;

//Stmt6571:Parent
if ((unsigned long )firstnew == (unsigned long )((struct dep *)0)) {
//Stmt6561:Leaf
lastnew = c;

//Stmt6562:Leaf
firstnew = lastnew;

     } else {
//Stmt6563:Leaf
tmp___0 = c;

//Stmt6564:Leaf
lastnew->next = tmp___0;

//Stmt6565:Leaf
lastnew = tmp___0;

     }

//Stmt6572:Leaf
d = d->next;

   }

//Stmt6581:Leaf
return (firstnew);

 }
}
 static int user_uid  =    -1;
 static int user_gid  =    -1;
 static int make_uid  =    -1;
 static int make_gid  =    -1;
 static enum __anonenum_current_access_55 current_access  ;
 static void log_access(char *flavor ) 
 { 
//Stmt6583:Leaf
__gid_t tmp ;

//Stmt6584:Leaf
__gid_t tmp___0 ;

//Stmt6585:Leaf
__uid_t tmp___1 ;

//Stmt6586:Leaf
__uid_t tmp___2 ;

//Stmt6587:Leaf
char *tmp___3 ;

 
   {
//Stmt6588:Parent
if (! (4 & db_level)) {
//Stmt6582:Leaf
return;

   }

//Stmt6589:Leaf
tmp = getgid();

//Stmt6590:Leaf
tmp___0 = getegid();

//Stmt6591:Leaf
tmp___1 = getuid();

//Stmt6592:Leaf
tmp___2 = geteuid();

//Stmt6593:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "%s access: user %lu (real %lu), group %lu (real %lu)\n",
                       5);

//Stmt6594:Leaf
fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___3, flavor,
           (unsigned long )tmp___2, (unsigned long )tmp___1, (unsigned long )tmp___0,
           (unsigned long )tmp);

//Stmt6595:Leaf
fflush(stderr);

//Stmt6596:Leaf
return;

 }
}
 static void init_access(void) 
 { 
//Stmt6604:Leaf
__uid_t tmp ;

//Stmt6605:Leaf
__gid_t tmp___0 ;

//Stmt6606:Leaf
__uid_t tmp___1 ;

//Stmt6607:Leaf
__gid_t tmp___2 ;

//Stmt6608:Leaf
char *tmp___3 ;

 
   {
//Stmt6609:Leaf
tmp = getuid();

//Stmt6610:Leaf
user_uid = (int )tmp;

//Stmt6611:Leaf
tmp___0 = getgid();

//Stmt6612:Leaf
user_gid = (int )tmp___0;

//Stmt6613:Leaf
tmp___1 = geteuid();

//Stmt6614:Leaf
make_uid = (int )tmp___1;

//Stmt6615:Leaf
tmp___2 = getegid();

//Stmt6616:Leaf
make_gid = (int )tmp___2;

//Stmt6617:Parent
if (user_uid == -1) {
//Stmt6602:Leaf
pfatal_with_name((char *)"get{e}[gu]id");

   } else
   {
//Stmt6603:Parent
if (user_gid == -1) {
//Stmt6600:Leaf
pfatal_with_name((char *)"get{e}[gu]id");

   } else
   {
//Stmt6601:Parent
if (make_uid == -1) {
//Stmt6598:Leaf
pfatal_with_name((char *)"get{e}[gu]id");

   } else
   {
//Stmt6599:Parent
if (make_gid == -1) {
//Stmt6597:Leaf
pfatal_with_name((char *)"get{e}[gu]id");

   }
}

}

}


//Stmt6618:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "Initialized", 5);

//Stmt6619:Leaf
log_access(tmp___3);

//Stmt6620:Leaf
current_access = (enum __anonenum_current_access_55 )0;

//Stmt6621:Leaf
return;

 }
}
 void user_access(void) 
 { 
//Stmt6626:Leaf
int tmp ;

//Stmt6627:Leaf
int tmp___0 ;

 
   {
//Stmt6628:Parent
if (! (user_uid != -1)) {
//Stmt6622:Leaf
init_access();

   }

//Stmt6629:Parent
if ((unsigned int )current_access == 1U) {
//Stmt6623:Leaf
return;

   }

//Stmt6630:Leaf
tmp = seteuid((__uid_t )user_uid);

//Stmt6631:Parent
if (tmp < 0) {
//Stmt6624:Leaf
pfatal_with_name((char *)"user_access: seteuid");

   }

//Stmt6632:Leaf
tmp___0 = setegid((__gid_t )user_gid);

//Stmt6633:Parent
if (tmp___0 < 0) {
//Stmt6625:Leaf
pfatal_with_name((char *)"user_access: setegid");

   }

//Stmt6634:Leaf
current_access = (enum __anonenum_current_access_55 )1;

//Stmt6635:Leaf
log_access((char *)"User");

//Stmt6636:Leaf
return;

 }
}
 void make_access(void) 
 { 
//Stmt6641:Leaf
int tmp ;

//Stmt6642:Leaf
int tmp___0 ;

 
   {
//Stmt6643:Parent
if (! (user_uid != -1)) {
//Stmt6637:Leaf
init_access();

   }

//Stmt6644:Parent
if ((unsigned int )current_access == 0U) {
//Stmt6638:Leaf
return;

   }

//Stmt6645:Leaf
tmp = seteuid((__uid_t )make_uid);

//Stmt6646:Parent
if (tmp < 0) {
//Stmt6639:Leaf
pfatal_with_name((char *)"make_access: seteuid");

   }

//Stmt6647:Leaf
tmp___0 = setegid((__gid_t )make_gid);

//Stmt6648:Parent
if (tmp___0 < 0) {
//Stmt6640:Leaf
pfatal_with_name((char *)"make_access: setegid");

   }

//Stmt6649:Leaf
current_access = (enum __anonenum_current_access_55 )0;

//Stmt6650:Leaf
log_access((char *)"Make");

//Stmt6651:Leaf
return;

 }
}
 void child_access(void) 
 { 
//Stmt6655:Leaf
int tmp ;

//Stmt6656:Leaf
int tmp___0 ;

 
   {
//Stmt6657:Parent
if (! (user_uid != -1)) {
//Stmt6652:Leaf
abort();

   }

//Stmt6658:Leaf
tmp = setuid((__uid_t )user_uid);

//Stmt6659:Parent
if (tmp < 0) {
//Stmt6653:Leaf
pfatal_with_name((char *)"child_access: setuid");

   }

//Stmt6660:Leaf
tmp___0 = setgid((__gid_t )user_gid);

//Stmt6661:Parent
if (tmp___0 < 0) {
//Stmt6654:Leaf
pfatal_with_name((char *)"child_access: setgid");

   }

//Stmt6662:Leaf
log_access((char *)"Child");

//Stmt6663:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-EmMgOVB_.i","-g,-O0")
 extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
 extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
 extern char *getlogin(void) ;
 void construct_vpath_list(char *pattern , char *dirpath ) ;
 struct floc  const  *reading_file  ;
 extern int glob(char const   *__pattern , int __flags , int (*__errfunc)(char const   * ,
                                                                          int  ) ,
                 glob_t *__pglob ) ;
 extern void globfree(glob_t *__pglob ) ;
 struct file *suffix_file ;
 struct pattern_var *create_pattern_var(char *target , char *suffix ) ;
 void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                          struct dep *deps , struct commands *commands , int override ) ;
 extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
 static struct conditionals toplevel_conditionals  ;
 static struct conditionals *conditionals  =    & toplevel_conditionals;
 static char *default_include_directories[5]  = {      (char *)"/usr/local/include",      (char *)"/usr/gnu/include",      (char *)"/usr/local/include",      (char *)"/usr/include", 
         (char *)0};
 static char **include_directories___0  ;
 static unsigned int max_incl_len  ;
 static struct dep *read_makefiles  =    (struct dep *)0;
 static int read_makefile(char *filename , int flags ) ;
 static unsigned long readline(struct linebuffer *linebuffer , FILE *stream , struct floc  const  *flocp ) ;
 static void do_define(char *name , unsigned int namelen , enum variable_origin origin ,
                       FILE *infile , struct floc *flocp ) ;
 static int conditional_line(char *line , struct floc  const  *flocp ) ;
 static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                          struct dep *deps , unsigned int cmds_started , char *commands ,
                          unsigned int commands_idx , int two_colon , struct floc  const  *flocp ,
                          int set_default ) ;
 static void record_target_var(struct nameseq *filenames , char *defn , int two_colon ,
                               enum variable_origin origin , struct floc  const  *flocp ) ;
 static enum make_word_type get_next_mword(char *buffer , char *delim , char **startp ,
                                           unsigned int *length___0 ) ;
 static char *default_makefiles[4]  = {      (char *)"GNUmakefile",      (char *)"makefile",      (char *)"Makefile",      (char *)0};
 struct dep *read_all_makefiles(char **makefiles___0 ) 
 { 
//Stmt6727:Leaf
unsigned int num_makefiles ;

//Stmt6728:Leaf
char *tmp ;

//Stmt6729:Leaf
char *value ;

//Stmt6730:Leaf
char *name ;

//Stmt6731:Leaf
char *p ;

//Stmt6732:Leaf
unsigned int length___0 ;

//Stmt6733:Leaf
int save ;

//Stmt6734:Leaf
char *tmp___0 ;

//Stmt6735:Leaf
int tmp___1 ;

//Stmt6736:Leaf
struct dep *tail ;

//Stmt6737:Leaf
register struct dep *d ;

//Stmt6738:Leaf
int tmp___2 ;

//Stmt6739:Leaf
register char **p___0 ;

//Stmt6740:Leaf
int tmp___3 ;

//Stmt6741:Leaf
int tmp___4 ;

//Stmt6742:Leaf
struct dep *tail___0 ;

//Stmt6743:Leaf
struct dep *d___0 ;

//Stmt6744:Leaf
char *tmp___5 ;

 
   {
//Stmt6745:Leaf
num_makefiles = 0U;

//Stmt6746:Parent
while (1) {
//Stmt6667:Parent
if (1 & db_level) {
//Stmt6664:Leaf
tmp = dcgettext((char const   *)((void *)0), "Reading makefiles...\n", 5);

//Stmt6665:Leaf
printf((char const   * __restrict  )tmp);

//Stmt6666:Leaf
fflush(stdout);

     }

//Stmt6668:Leaf
break;

   }

//Stmt6747:Leaf
save = warn_undefined_variables_flag;

//Stmt6748:Leaf
warn_undefined_variables_flag = 0;

//Stmt6749:Leaf
value = allocated_variable_expand_for_file((char *)"$(MAKEFILES)", (struct file *)0);

//Stmt6750:Leaf
warn_undefined_variables_flag = save;

//Stmt6751:Leaf
p = value;

//Stmt6752:Parent
while (1) {
//Stmt6674:Leaf
name = find_next_token(& p, & length___0);

//Stmt6675:Parent
if (! ((unsigned long )name != (unsigned long )((char *)0))) {
//Stmt6669:Leaf
break;

     }

//Stmt6676:Parent
if ((int )*p != 0) {
//Stmt6670:Leaf
tmp___0 = p;

//Stmt6671:Leaf
p ++;

//Stmt6672:Leaf
*tmp___0 = (char )'\000';

     }

//Stmt6677:Leaf
name = xstrdup((char const   *)name);

//Stmt6678:Leaf
tmp___1 = read_makefile(name, (1 | (1 << 1)) | (1 << 2));

//Stmt6679:Parent
if (tmp___1 < 2) {
//Stmt6673:Leaf
free((void *)name);

     }

   }

//Stmt6753:Leaf
free((void *)value);

//Stmt6754:Parent
if ((unsigned long )makefiles___0 != (unsigned long )((char **)0)) {
//Stmt6692:Parent
while ((unsigned long )*makefiles___0 != (unsigned long )((char *)0)) {
//Stmt6684:Leaf
tail = read_makefiles;

//Stmt6685:Leaf
tmp___2 = read_makefile(*makefiles___0, 0);

//Stmt6686:Parent
if (! tmp___2) {
//Stmt6680:Leaf
perror_with_name((char *)"", *makefiles___0);

       }

//Stmt6687:Leaf
d = read_makefiles;

//Stmt6688:Parent
while ((unsigned long )d->next != (unsigned long )tail) {
//Stmt6681:Leaf
d = d->next;

       }

//Stmt6689:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt6682:Leaf
*makefiles___0 = (d->file)->name;

       } else {
//Stmt6683:Leaf
*makefiles___0 = d->name;

       }

//Stmt6690:Leaf
num_makefiles ++;

//Stmt6691:Leaf
makefiles___0 ++;

     }

   }

//Stmt6755:Parent
if (num_makefiles == 0U) {
//Stmt6724:Leaf
p___0 = default_makefiles;

//Stmt6725:Parent
while (1) {
//Stmt6697:Parent
if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
//Stmt6694:Leaf
tmp___3 = file_exists_p(*p___0);

//Stmt6695:Parent
if (tmp___3) {
//Stmt6693:Leaf
break;

         }

       } else {
//Stmt6696:Leaf
break;

       }

//Stmt6698:Leaf
p___0 ++;

     }

//Stmt6726:Parent
if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
//Stmt6717:Leaf
tmp___4 = read_makefile(*p___0, 0);

//Stmt6718:Parent
if (! tmp___4) {
//Stmt6699:Leaf
perror_with_name((char *)"", *p___0);

       }

     } else {
//Stmt6719:Leaf
tail___0 = read_makefiles;

//Stmt6720:Parent
while (1) {
//Stmt6703:Parent
if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
//Stmt6701:Parent
if (! ((unsigned long )tail___0->next != (unsigned long )((struct dep *)0))) {
//Stmt6700:Leaf
break;

           }

         } else {
//Stmt6702:Leaf
break;

         }

//Stmt6704:Leaf
tail___0 = tail___0->next;

       }

//Stmt6721:Leaf
p___0 = default_makefiles;

//Stmt6722:Parent
while ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
//Stmt6707:Leaf
tmp___5 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt6708:Leaf
d___0 = (struct dep *)tmp___5;

//Stmt6709:Leaf
d___0->name = (char *)0;

//Stmt6710:Leaf
d___0->file = enter_file(*p___0);

//Stmt6711:Leaf
(d___0->file)->dontcare = 1U;

//Stmt6712:Leaf
d___0->changed = 1 << 2;

//Stmt6713:Parent
if ((unsigned long )tail___0 == (unsigned long )((struct dep *)0)) {
//Stmt6705:Leaf
read_makefiles = d___0;

         } else {
//Stmt6706:Leaf
tail___0->next = d___0;

         }

//Stmt6714:Leaf
tail___0 = d___0;

//Stmt6715:Leaf
p___0 ++;

       }

//Stmt6723:Parent
if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
//Stmt6716:Leaf
tail___0->next = (struct dep *)0;

       }

     }

   }

//Stmt6756:Leaf
return (read_makefiles);

 }
}
 static char *collapsed  =    (char *)0;
 static unsigned int collapsed_length  =    0U;
 static int read_makefile(char *filename , int flags ) 
 { 
//Stmt7282:Leaf
register FILE *infile ;

//Stmt7283:Leaf
struct linebuffer lb ;

//Stmt7284:Leaf
unsigned int commands_len ;

//Stmt7285:Leaf
char *commands ;

//Stmt7286:Leaf
unsigned int commands_idx ;

//Stmt7287:Leaf
unsigned int cmds_started ;

//Stmt7288:Leaf
unsigned int tgts_started ;

//Stmt7289:Leaf
char *p ;

//Stmt7290:Leaf
char *p2 ;

//Stmt7291:Leaf
int len ;

//Stmt7292:Leaf
int reading_target ;

//Stmt7293:Leaf
int ignoring ;

//Stmt7294:Leaf
int in_ignored_define ;

//Stmt7295:Leaf
int no_targets ;

//Stmt7296:Leaf
int using_filename ;

//Stmt7297:Leaf
struct floc fileinfo ;

//Stmt7298:Leaf
char *passed_filename ;

//Stmt7299:Leaf
struct nameseq *filenames ;

//Stmt7300:Leaf
struct dep *deps ;

//Stmt7301:Leaf
unsigned int nlines ;

//Stmt7302:Leaf
int two_colon ;

//Stmt7303:Leaf
char *pattern ;

//Stmt7304:Leaf
char *pattern_percent ;

//Stmt7305:Leaf
int makefile_errno ;

//Stmt7306:Leaf
char *tmp ;

//Stmt7307:Leaf
char *tmp___0 ;

//Stmt7308:Leaf
char *tmp___1 ;

//Stmt7309:Leaf
char *tmp___2 ;

//Stmt7310:Leaf
char *tmp___3 ;

//Stmt7311:Leaf
char *expanded ;

//Stmt7312:Leaf
char *tmp___4 ;

//Stmt7313:Leaf
int *tmp___5 ;

//Stmt7314:Leaf
register unsigned int i ;

//Stmt7315:Leaf
char *name ;

//Stmt7316:Leaf
char *tmp___6 ;

//Stmt7317:Leaf
char *tmp___7 ;

//Stmt7318:Leaf
char *tmp___8 ;

//Stmt7319:Leaf
int *tmp___9 ;

//Stmt7320:Leaf
char *tmp___10 ;

//Stmt7321:Leaf
unsigned long tmp___11 ;

//Stmt7322:Leaf
unsigned int len___0 ;

//Stmt7323:Leaf
size_t tmp___12 ;

//Stmt7324:Leaf
char *tmp___13 ;

//Stmt7325:Leaf
unsigned int tmp___14 ;

//Stmt7326:Leaf
char *tmp___15 ;

//Stmt7327:Leaf
unsigned short const   **tmp___16 ;

//Stmt7328:Leaf
unsigned short const   **tmp___17 ;

//Stmt7329:Leaf
unsigned short const   **tmp___18 ;

//Stmt7330:Leaf
int i___0 ;

//Stmt7331:Leaf
int tmp___19 ;

//Stmt7332:Leaf
char *tmp___20 ;

//Stmt7333:Leaf
int tmp___21 ;

//Stmt7334:Leaf
int tmp___22 ;

//Stmt7335:Leaf
int tmp___23 ;

//Stmt7336:Leaf
int tmp___24 ;

//Stmt7337:Leaf
int tmp___25 ;

//Stmt7338:Leaf
int tmp___26 ;

//Stmt7339:Leaf
char *tmp___27 ;

//Stmt7340:Leaf
int tmp___28 ;

//Stmt7341:Leaf
char *tmp___29 ;

//Stmt7342:Leaf
unsigned short const   **tmp___30 ;

//Stmt7343:Leaf
int tmp___31 ;

//Stmt7344:Leaf
char *tmp___32 ;

//Stmt7345:Leaf
char *tmp___33 ;

//Stmt7346:Leaf
unsigned short const   **tmp___34 ;

//Stmt7347:Leaf
char *tmp___35 ;

//Stmt7348:Leaf
struct variable *tmp___36 ;

//Stmt7349:Leaf
int tmp___37 ;

//Stmt7350:Leaf
unsigned short const   **tmp___38 ;

//Stmt7351:Leaf
int tmp___39 ;

//Stmt7352:Leaf
struct variable *v ;

//Stmt7353:Leaf
unsigned int len___1 ;

//Stmt7354:Leaf
unsigned int len___2 ;

//Stmt7355:Leaf
struct variable *v___0 ;

//Stmt7356:Leaf
char *pattern___0 ;

//Stmt7357:Leaf
unsigned int len___3 ;

//Stmt7358:Leaf
struct conditionals *save ;

//Stmt7359:Leaf
struct conditionals new_conditionals ;

//Stmt7360:Leaf
struct nameseq *files___0 ;

//Stmt7361:Leaf
int noerror ;

//Stmt7362:Leaf
int tmp___40 ;

//Stmt7363:Leaf
char *tmp___41 ;

//Stmt7364:Leaf
char const   *tmp___42 ;

//Stmt7365:Leaf
char *tmp___43 ;

//Stmt7366:Leaf
struct nameseq *tmp___44 ;

//Stmt7367:Leaf
struct floc fi ;

//Stmt7368:Leaf
struct nameseq *next ;

//Stmt7369:Leaf
char *name___0 ;

//Stmt7370:Leaf
int r ;

//Stmt7371:Leaf
int tmp___45 ;

//Stmt7372:Leaf
int *tmp___46 ;

//Stmt7373:Leaf
char *tmp___47 ;

//Stmt7374:Leaf
unsigned short const   **tmp___48 ;

//Stmt7375:Leaf
char *tmp___49 ;

//Stmt7376:Leaf
enum make_word_type wtype ;

//Stmt7377:Leaf
enum variable_origin v_origin ;

//Stmt7378:Leaf
char *cmdleft ;

//Stmt7379:Leaf
char *lb_next ;

//Stmt7380:Leaf
unsigned int len___4 ;

//Stmt7381:Leaf
unsigned int plen ;

//Stmt7382:Leaf
char *colonp ;

//Stmt7383:Leaf
struct floc fi___0 ;

//Stmt7384:Leaf
char *tmp___50 ;

//Stmt7385:Leaf
char *tmp___51 ;

//Stmt7386:Leaf
unsigned long p2_off ;

//Stmt7387:Leaf
unsigned long cmd_off ;

//Stmt7388:Leaf
char *pend ;

//Stmt7389:Leaf
size_t tmp___52 ;

//Stmt7390:Leaf
size_t tmp___53 ;

//Stmt7391:Leaf
size_t tmp___54 ;

//Stmt7392:Leaf
char *tmp___55 ;

//Stmt7393:Leaf
char *tmp___57 ;

//Stmt7394:Leaf
char const   *tmp___58 ;

//Stmt7395:Leaf
int tmp___59 ;

//Stmt7396:Leaf
char *tmp___60 ;

//Stmt7397:Leaf
struct nameseq *tmp___61 ;

//Stmt7398:Leaf
unsigned int l ;

//Stmt7399:Leaf
size_t tmp___63 ;

//Stmt7400:Leaf
size_t tmp___64 ;

//Stmt7401:Leaf
int tmp___65 ;

//Stmt7402:Leaf
unsigned int l___0 ;

//Stmt7403:Leaf
char *tmp___66 ;

//Stmt7404:Leaf
register char *q ;

//Stmt7405:Leaf
register int backslash ;

//Stmt7406:Leaf
char *tmp___67 ;

//Stmt7407:Leaf
struct nameseq *target ;

//Stmt7408:Leaf
char *tmp___68 ;

//Stmt7409:Leaf
char *tmp___69 ;

//Stmt7410:Leaf
char *tmp___70 ;

//Stmt7411:Leaf
struct nameseq *tmp___71 ;

//Stmt7412:Leaf
struct nameseq *tmp___72 ;

//Stmt7413:Leaf
unsigned int len___5 ;

//Stmt7414:Leaf
size_t tmp___73 ;

//Stmt7415:Leaf
char *tmp___74 ;

//Stmt7416:Leaf
unsigned int tmp___75 ;

//Stmt7417:Leaf
struct variable *tmp___76 ;

//Stmt7418:Leaf
int tmp___77 ;

//Stmt7419:Leaf
int tmp___78 ;

//Stmt7420:Leaf
int tmp___79 ;

//Stmt7421:Leaf
int tmp___80 ;

//Stmt7422:Leaf
int tmp___81 ;

//Stmt7423:Leaf
int tmp___82 ;

//Stmt7424:Leaf
struct floc fi___1 ;

//Stmt7425:Leaf
int tmp___83 ;

//Stmt7426:Leaf
char *tmp___84 ;

//Stmt7427:Leaf
struct floc fi___2 ;

 
   {
//Stmt7428:Leaf
commands_len = 200U;

//Stmt7429:Leaf
commands_idx = 0U;

//Stmt7430:Leaf
ignoring = 0;

//Stmt7431:Leaf
in_ignored_define = 0;

//Stmt7432:Leaf
no_targets = 0;

//Stmt7433:Leaf
using_filename = 0;

//Stmt7434:Leaf
passed_filename = filename;

//Stmt7435:Leaf
filenames = (struct nameseq *)0;

//Stmt7436:Leaf
nlines = 0U;

//Stmt7437:Leaf
two_colon = 0;

//Stmt7438:Leaf
pattern = (char *)0;

//Stmt7439:Leaf
fileinfo.filenm = filename;

//Stmt7440:Leaf
fileinfo.lineno = 1UL;

//Stmt7441:Leaf
pattern_percent = (char *)0;

//Stmt7442:Leaf
tgts_started = (unsigned int )fileinfo.lineno;

//Stmt7443:Leaf
cmds_started = tgts_started;

//Stmt7444:Parent
if (2 & db_level) {
//Stmt6765:Leaf
tmp = dcgettext((char const   *)((void *)0), "Reading makefile `%s\'", 5);

//Stmt6766:Leaf
printf((char const   * __restrict  )tmp, fileinfo.filenm);

//Stmt6767:Parent
if (flags & 1) {
//Stmt6757:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), " (no default goal)", 5);

//Stmt6758:Leaf
printf((char const   * __restrict  )tmp___0);

     }

//Stmt6768:Parent
if (flags & (1 << 1)) {
//Stmt6759:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), " (search path)", 5);

//Stmt6760:Leaf
printf((char const   * __restrict  )tmp___1);

     }

//Stmt6769:Parent
if (flags & (1 << 2)) {
//Stmt6761:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), " (don\'t care)", 5);

//Stmt6762:Leaf
printf((char const   * __restrict  )tmp___2);

     }

//Stmt6770:Parent
if (flags & (1 << 3)) {
//Stmt6763:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), " (no ~ expansion)", 5);

//Stmt6764:Leaf
printf((char const   * __restrict  )tmp___3);

     }

//Stmt6771:Leaf
puts("...");

   }

//Stmt7445:Parent
if (! (flags & (1 << 3))) {
//Stmt6776:Parent
if ((int )*(filename + 0) == 126) {
//Stmt6773:Leaf
tmp___4 = tilde_expand(filename);

//Stmt6774:Leaf
expanded = tmp___4;

//Stmt6775:Parent
if ((unsigned long )expanded != (unsigned long )((char *)0)) {
//Stmt6772:Leaf
filename = expanded;

       }

     }

   }

//Stmt7446:Leaf
infile = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");

//Stmt7447:Leaf
tmp___5 = __errno_location();

//Stmt7448:Leaf
makefile_errno = *tmp___5;

//Stmt7449:Parent
if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
//Stmt6788:Parent
if (flags & (1 << 1)) {
//Stmt6787:Parent
if ((int )*filename != 47) {
//Stmt6785:Leaf
i = 0U;

//Stmt6786:Parent
while ((unsigned long )*(include_directories___0 + i) != (unsigned long )((char *)0)) {
//Stmt6780:Leaf
tmp___6 = concat(*(include_directories___0 + i), (char *)"/", filename);

//Stmt6781:Leaf
name = tmp___6;

//Stmt6782:Leaf
infile = fopen((char const   * __restrict  )name, (char const   * __restrict  )"r");

//Stmt6783:Parent
if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
//Stmt6777:Leaf
free((void *)name);

           } else {
//Stmt6778:Leaf
filename = name;

//Stmt6779:Leaf
break;

           }

//Stmt6784:Leaf
i ++;

         }

       }

     }

   }

//Stmt7450:Leaf
tmp___7 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt7451:Leaf
deps = (struct dep *)tmp___7;

//Stmt7452:Leaf
deps->next = read_makefiles;

//Stmt7453:Leaf
read_makefiles = deps;

//Stmt7454:Leaf
deps->name = (char *)0;

//Stmt7455:Leaf
deps->file = lookup_file(filename);

//Stmt7456:Parent
if ((unsigned long )deps->file == (unsigned long )((struct file *)0)) {
//Stmt6790:Leaf
tmp___8 = xstrdup((char const   *)filename);

//Stmt6791:Leaf
deps->file = enter_file(tmp___8);

//Stmt6792:Parent
if (flags & (1 << 2)) {
//Stmt6789:Leaf
(deps->file)->dontcare = 1U;

     }

   }

//Stmt7457:Parent
if ((unsigned long )filename != (unsigned long )passed_filename) {
//Stmt6793:Leaf
free((void *)filename);

   }

//Stmt7458:Leaf
filename = (deps->file)->name;

//Stmt7459:Leaf
deps->changed = flags;

//Stmt7460:Leaf
deps = (struct dep *)0;

//Stmt7461:Parent
if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
//Stmt6794:Leaf
tmp___9 = __errno_location();

//Stmt6795:Leaf
*tmp___9 = makefile_errno;

//Stmt6796:Leaf
return (0);

   }

//Stmt7462:Leaf
reading_file = (struct floc  const  *)(& fileinfo);

//Stmt7463:Leaf
lb.size = 200U;

//Stmt7464:Leaf
tmp___10 = xmalloc(lb.size);

//Stmt7465:Leaf
lb.buffer = tmp___10;

//Stmt7466:Leaf
commands = xmalloc(200U);

//Stmt7467:Parent
while (1) {
//Stmt7243:Leaf
tmp___83 = feof(infile);

//Stmt7244:Parent
if (tmp___83) {
//Stmt6797:Leaf
break;

     }

//Stmt7245:Leaf
fileinfo.lineno += (unsigned long )nlines;

//Stmt7246:Leaf
tmp___11 = readline(& lb, infile, (struct floc  const  *)(& fileinfo));

//Stmt7247:Leaf
nlines = (unsigned int )tmp___11;

//Stmt7248:Parent
if ((int )*(lb.buffer + 0) == 9) {
//Stmt6816:Parent
if (no_targets) {
//Stmt6798:Leaf
continue;

       }

//Stmt6817:Parent
if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
//Stmt6804:Parent
if (ignoring) {
//Stmt6799:Leaf
continue;

         }

//Stmt6805:Leaf
p = lb.buffer;

//Stmt6806:Parent
if (commands_idx == 0U) {
//Stmt6800:Leaf
cmds_started = (unsigned int )fileinfo.lineno;

         }

//Stmt6807:Leaf
tmp___12 = strlen((char const   *)p);

//Stmt6808:Leaf
len___0 = (unsigned int )tmp___12;

//Stmt6809:Parent
if ((len___0 + 1U) + commands_idx > commands_len) {
//Stmt6801:Leaf
commands_len = ((len___0 + 1U) + commands_idx) * 2U;

//Stmt6802:Leaf
tmp___13 = xrealloc(commands, commands_len);

//Stmt6803:Leaf
commands = tmp___13;

         }

//Stmt6810:Leaf
memmove((void *)(commands + commands_idx), (void const   *)p, (size_t )len___0);

//Stmt6811:Leaf
commands_idx += len___0;

//Stmt6812:Leaf
tmp___14 = commands_idx;

//Stmt6813:Leaf
commands_idx ++;

//Stmt6814:Leaf
*(commands + tmp___14) = (char )'\n';

//Stmt6815:Leaf
continue;

       }

     }

//Stmt7249:Parent
if (collapsed_length < lb.size) {
//Stmt6819:Leaf
collapsed_length = lb.size;

//Stmt6820:Parent
if ((unsigned long )collapsed != (unsigned long )((char *)0)) {
//Stmt6818:Leaf
free((void *)collapsed);

       }

//Stmt6821:Leaf
tmp___15 = xmalloc(collapsed_length);

//Stmt6822:Leaf
collapsed = tmp___15;

     }

//Stmt7250:Leaf
strcpy((char * __restrict  )collapsed, (char const   * __restrict  )lb.buffer);

//Stmt7251:Leaf
collapse_continuations(collapsed);

//Stmt7252:Leaf
remove_comments(collapsed);

//Stmt7253:Leaf
p = collapsed;

//Stmt7254:Parent
while (1) {
//Stmt6824:Leaf
tmp___16 = __ctype_b_loc();

//Stmt6825:Parent
if (! ((int const   )*(*tmp___16 + (int )((unsigned char )*p)) & 8192)) {
//Stmt6823:Leaf
break;

       }

//Stmt6826:Leaf
p ++;

     }

//Stmt7255:Parent
if ((int )*p == 0) {
//Stmt6827:Leaf
continue;

     }

//Stmt7256:Leaf
p2 = p + 1;

//Stmt7257:Parent
while (1) {
//Stmt6832:Parent
if ((int )*p2 != 0) {
//Stmt6829:Leaf
tmp___17 = __ctype_b_loc();

//Stmt6830:Parent
if ((int const   )*(*tmp___17 + (int )((unsigned char )*p2)) & 8192) {
//Stmt6828:Leaf
break;

         }

       } else {
//Stmt6831:Leaf
break;

       }

//Stmt6833:Leaf
p2 ++;

     }

//Stmt7258:Leaf
len = (int )(p2 - p);

//Stmt7259:Leaf
reading_target = 0;

//Stmt7260:Parent
while (1) {
//Stmt6835:Leaf
tmp___18 = __ctype_b_loc();

//Stmt6836:Parent
if (! ((int const   )*(*tmp___18 + (int )((unsigned char )*p2)) & 8192)) {
//Stmt6834:Leaf
break;

       }

//Stmt6837:Leaf
p2 ++;

     }

//Stmt7261:Parent
if ((int )*p2 == 0) {
//Stmt6841:Leaf
p2 = (char *)((void *)0);

     } else
     {
//Stmt6842:Parent
if ((int )*(p2 + 0) == 58) {
//Stmt6840:Parent
if ((int )*(p2 + 1) == 0) {
//Stmt6838:Leaf
reading_target = 1;

//Stmt6839:Leaf
goto skip_conditionals;

       }

     }
}


//Stmt7262:Parent
if (! in_ignored_define) {
//Stmt6877:Parent
if (len == 5) {
//Stmt6875:Leaf
tmp___21 = strncmp("ifdef", (char const   *)p, (size_t )5);

//Stmt6876:Parent
if (tmp___21 == 0) {
//Stmt6843:Leaf
goto _L;

         } else {
//Stmt6844:Leaf
goto _L___4;

         }

       } else
       _L___4: /* CIL Label */ 
       {
//Stmt6874:Parent
if (len == 6) {
//Stmt6872:Leaf
tmp___22 = strncmp("ifndef", (char const   *)p, (size_t )6);

//Stmt6873:Parent
if (tmp___22 == 0) {
//Stmt6845:Leaf
goto _L;

         } else {
//Stmt6846:Leaf
goto _L___3;

         }

       } else
       _L___3: /* CIL Label */ 
       {
//Stmt6871:Parent
if (len == 4) {
//Stmt6869:Leaf
tmp___23 = strncmp("ifeq", (char const   *)p, (size_t )4);

//Stmt6870:Parent
if (tmp___23 == 0) {
//Stmt6847:Leaf
goto _L;

         } else {
//Stmt6848:Leaf
goto _L___2;

         }

       } else
       _L___2: /* CIL Label */ 
       {
//Stmt6868:Parent
if (len == 5) {
//Stmt6866:Leaf
tmp___24 = strncmp("ifneq", (char const   *)p, (size_t )5);

//Stmt6867:Parent
if (tmp___24 == 0) {
//Stmt6849:Leaf
goto _L;

         } else {
//Stmt6850:Leaf
goto _L___1;

         }

       } else
       _L___1: /* CIL Label */ 
       {
//Stmt6865:Parent
if (len == 4) {
//Stmt6863:Leaf
tmp___25 = strncmp("else", (char const   *)p, (size_t )4);

//Stmt6864:Parent
if (tmp___25 == 0) {
//Stmt6851:Leaf
goto _L;

         } else {
//Stmt6852:Leaf
goto _L___0;

         }

       } else
       _L___0: /* CIL Label */ 
       {
//Stmt6862:Parent
if (len == 5) {
//Stmt6860:Leaf
tmp___26 = strncmp("endif", (char const   *)p, (size_t )5);

//Stmt6861:Parent
if (tmp___26 == 0) {
           _L: /* CIL Label */ 
           {
//Stmt6853:Leaf
tmp___19 = conditional_line(p, (struct floc  const  *)(& fileinfo));

}
//Stmt6857:Leaf
i___0 = tmp___19;

//Stmt6858:Parent
if (i___0 >= 0) {
//Stmt6854:Leaf
ignoring = i___0;

           } else {
//Stmt6855:Leaf
tmp___20 = dcgettext((char const   *)((void *)0), "invalid syntax in conditional",
                                  5);

//Stmt6856:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___20);

           }

//Stmt6859:Leaf
continue;

         }

       }
}

}

}

}

}


     }

//Stmt7263:Parent
if (len == 5) {
//Stmt6883:Leaf
tmp___28 = strncmp("endef", (char const   *)p, (size_t )5);

//Stmt6884:Parent
if (tmp___28 == 0) {
//Stmt6881:Parent
if (in_ignored_define) {
//Stmt6878:Leaf
in_ignored_define = 0;

         } else {
//Stmt6879:Leaf
tmp___27 = dcgettext((char const   *)((void *)0), "extraneous `endef\'",
                                5);

//Stmt6880:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___27);

         }

//Stmt6882:Leaf
continue;

       }

     }

//Stmt7264:Parent
if (len == 6) {
//Stmt6899:Leaf
tmp___31 = strncmp("define", (char const   *)p, (size_t )6);

//Stmt6900:Parent
if (tmp___31 == 0) {
//Stmt6897:Parent
if (ignoring) {
//Stmt6891:Leaf
in_ignored_define = 1;

         } else {
//Stmt6892:Leaf
p2 = next_token(p + 6);

//Stmt6893:Parent
if ((int )*p2 == 0) {
//Stmt6885:Leaf
tmp___29 = dcgettext((char const   *)((void *)0), "empty variable name",
                                  5);

//Stmt6886:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___29);

           }

//Stmt6894:Leaf
p = strchr((char const   *)p2, '\000');

//Stmt6895:Parent
while (1) {
//Stmt6888:Leaf
tmp___30 = __ctype_b_loc();

//Stmt6889:Parent
if (! ((int const   )*(*tmp___30 + (int )*(p + -1)) & 1)) {
//Stmt6887:Leaf
break;

             }

//Stmt6890:Leaf
p --;

           }

//Stmt6896:Leaf
do_define(p2, (unsigned int )(p - p2), (enum variable_origin )2, infile,
                     & fileinfo);

         }

//Stmt6898:Leaf
continue;

       }

     }

//Stmt7265:Parent
if (len == 8) {
//Stmt6931:Leaf
tmp___39 = strncmp("override", (char const   *)p, (size_t )8);

//Stmt6932:Parent
if (tmp___39 == 0) {
//Stmt6926:Leaf
p2 = next_token(p + 8);

//Stmt6927:Parent
if ((int )*p2 == 0) {
//Stmt6901:Leaf
tmp___32 = dcgettext((char const   *)((void *)0), "empty `override\' directive",
                                5);

//Stmt6902:Leaf
error((struct floc  const  *)(& fileinfo), (char const   *)tmp___32);

         }

//Stmt6928:Leaf
tmp___37 = strncmp((char const   *)p2, "define", (size_t )6);

//Stmt6929:Parent
if (tmp___37 == 0) {
//Stmt6924:Leaf
tmp___38 = __ctype_b_loc();

//Stmt6925:Parent
if ((int const   )*(*tmp___38 + (int )*(p2 + 6)) & 1) {
//Stmt6917:Leaf
goto _L___6;

           } else
           {
//Stmt6918:Parent
if ((int )*(p2 + 6) == 0) {
             _L___6: /* CIL Label */ 
             {
//Stmt6915:Parent
if (ignoring) {
//Stmt6909:Leaf
in_ignored_define = 1;

             } else {
//Stmt6910:Leaf
p2 = next_token(p2 + 6);

//Stmt6911:Parent
if ((int )*p2 == 0) {
//Stmt6903:Leaf
tmp___33 = dcgettext((char const   *)((void *)0), "empty variable name",
                                      5);

//Stmt6904:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___33);

               }

//Stmt6912:Leaf
p = strchr((char const   *)p2, '\000');

//Stmt6913:Parent
while (1) {
//Stmt6906:Leaf
tmp___34 = __ctype_b_loc();

//Stmt6907:Parent
if (! ((int const   )*(*tmp___34 + (int )*(p + -1)) & 1)) {
//Stmt6905:Leaf
break;

                 }

//Stmt6908:Leaf
p --;

               }

//Stmt6914:Leaf
do_define(p2, (unsigned int )(p - p2), (enum variable_origin )5, infile,
                         & fileinfo);

             }
}

           } else {
//Stmt6916:Leaf
goto _L___5;

           }
}


         } else
         _L___5: /* CIL Label */ 
         {
//Stmt6923:Parent
if (! ignoring) {
//Stmt6921:Leaf
tmp___36 = try_variable_definition((struct floc  const  *)(& fileinfo),
                                              p2, (enum variable_origin )5, 0);

//Stmt6922:Parent
if (! tmp___36) {
//Stmt6919:Leaf
tmp___35 = dcgettext((char const   *)((void *)0), "invalid `override\' directive",
                                  5);

//Stmt6920:Leaf
error((struct floc  const  *)(& fileinfo), (char const   *)tmp___35);

           }

         }
}


//Stmt6930:Leaf
continue;

       }

     }

     skip_conditionals: 
     {
//Stmt6934:Parent
if (ignoring) {
//Stmt6933:Leaf
continue;

     }
}

//Stmt7266:Parent
if (! reading_target) {
//Stmt7231:Parent
if (len == 6) {
//Stmt6949:Leaf
tmp___82 = strncmp("export", (char const   *)p, (size_t )6);

//Stmt6950:Parent
if (tmp___82 == 0) {
//Stmt6944:Leaf
p2 = next_token(p + 6);

//Stmt6945:Parent
if ((int )*p2 == 0) {
//Stmt6935:Leaf
export_all_variables = 1;

           }

//Stmt6946:Leaf
v = try_variable_definition((struct floc  const  *)(& fileinfo), p2, (enum variable_origin )2,
                                       0);

//Stmt6947:Parent
if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt6941:Leaf
v->export = (enum variable_export )0;

           } else {
//Stmt6942:Leaf
p = find_next_token(& p2, & len___1);

//Stmt6943:Parent
while ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt6937:Leaf
v = lookup_variable(p, len___1);

//Stmt6938:Parent
if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
//Stmt6936:Leaf
v = define_variable_in_set(p, len___1, (char *)"", (enum variable_origin )2,
                                            0, current_variable_set_list->set, (struct floc  const  *)(& fileinfo));

               }

//Stmt6939:Leaf
v->export = (enum variable_export )0;

//Stmt6940:Leaf
p = find_next_token(& p2, & len___1);

             }

           }

         } else {
//Stmt6948:Leaf
goto _L___14;

         }

       } else {
//Stmt6951:Leaf
goto _L___14;

       }

     } else
     _L___14: /* CIL Label */ 
     {
//Stmt7230:Parent
if (! reading_target) {
//Stmt7229:Parent
if (len == 8) {
//Stmt6963:Leaf
tmp___81 = strncmp("unexport", (char const   *)p, (size_t )8);

//Stmt6964:Parent
if (tmp___81 == 0) {
//Stmt6958:Leaf
p2 = next_token(p + 8);

//Stmt6959:Parent
if ((int )*p2 == 0) {
//Stmt6952:Leaf
export_all_variables = 0;

           }

//Stmt6960:Leaf
p = find_next_token(& p2, & len___2);

//Stmt6961:Parent
while ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt6954:Leaf
v___0 = lookup_variable(p, len___2);

//Stmt6955:Parent
if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
//Stmt6953:Leaf
v___0 = define_variable_in_set(p, len___2, (char *)"", (enum variable_origin )2,
                                              0, current_variable_set_list->set, (struct floc  const  *)(& fileinfo));

             }

//Stmt6956:Leaf
v___0->export = (enum variable_export )1;

//Stmt6957:Leaf
p = find_next_token(& p2, & len___2);

           }

         } else {
//Stmt6962:Leaf
goto _L___13;

         }

       } else {
//Stmt6965:Leaf
goto _L___13;

       }

     } else
     _L___13: /* CIL Label */ 
     {
//Stmt7228:Parent
if (len == 5) {
//Stmt7226:Leaf
tmp___80 = strncmp("vpath", (char const   *)p, (size_t )5);

//Stmt7227:Parent
if (tmp___80 == 0) {
//Stmt6970:Leaf
p2 = variable_expand(p + 5);

//Stmt6971:Leaf
p = find_next_token(& p2, & len___3);

//Stmt6972:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt6966:Leaf
pattern___0 = savestring((char const   *)p, len___3);

//Stmt6967:Leaf
p = find_next_token(& p2, & len___3);

         } else {
//Stmt6968:Leaf
pattern___0 = (char *)0;

         }

//Stmt6973:Leaf
construct_vpath_list(pattern___0, p);

//Stmt6974:Parent
if ((unsigned long )pattern___0 != (unsigned long )((char *)0)) {
//Stmt6969:Leaf
free((void *)pattern___0);

         }

       } else {
//Stmt6975:Leaf
goto _L___12;

       }

     } else
     _L___12: /* CIL Label */ 
     {
//Stmt7225:Parent
if (len == 7) {
//Stmt7223:Leaf
tmp___77 = strncmp("include", (char const   *)p, (size_t )7);

//Stmt7224:Parent
if (tmp___77 == 0) {
//Stmt6976:Leaf
goto _L___8;

       } else {
//Stmt6977:Leaf
goto _L___11;

       }

     } else
     _L___11: /* CIL Label */ 
     {
//Stmt7222:Parent
if (len == 8) {
//Stmt7220:Leaf
tmp___78 = strncmp("-include", (char const   *)p, (size_t )8);

//Stmt7221:Parent
if (tmp___78 == 0) {
//Stmt6978:Leaf
goto _L___8;

       } else {
//Stmt6979:Leaf
goto _L___10;

       }

     } else
     _L___10: /* CIL Label */ 
     {
//Stmt7219:Parent
if (len == 8) {
//Stmt7216:Leaf
tmp___79 = strncmp("sinclude", (char const   *)p, (size_t )8);

//Stmt7217:Parent
if (tmp___79 == 0) {
         _L___8: /* CIL Label */ 
         {
//Stmt6980:Leaf
noerror = (int )*(p + 0) != 105;

}
//Stmt7017:Parent
if (noerror) {
//Stmt6981:Leaf
tmp___40 = 8;

         } else {
//Stmt6982:Leaf
tmp___40 = 7;

         }

//Stmt7018:Leaf
tmp___41 = next_token(p + tmp___40);

//Stmt7019:Leaf
p = allocated_variable_expand_for_file(tmp___41, (struct file *)0);

//Stmt7020:Parent
if ((int )*p == 0) {
//Stmt6985:Parent
if (noerror) {
//Stmt6983:Leaf
tmp___42 = "-";

           } else {
//Stmt6984:Leaf
tmp___42 = "";

           }

//Stmt6986:Leaf
tmp___43 = dcgettext((char const   *)((void *)0), "no file name for `%sinclude\'",
                                5);

//Stmt6987:Leaf
error((struct floc  const  *)(& fileinfo), (char const   *)tmp___43, tmp___42);

//Stmt6988:Leaf
continue;

         }

//Stmt7021:Leaf
p2 = p;

//Stmt7022:Leaf
tmp___44 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct nameseq ),
                                   1);

//Stmt7023:Leaf
files___0 = multi_glob(tmp___44, (unsigned int )sizeof(struct nameseq ));

//Stmt7024:Leaf
free((void *)p);

//Stmt7025:Leaf
save = conditionals;

//Stmt7026:Leaf
memset((void *)((char *)(& new_conditionals)), 0, sizeof(new_conditionals));

//Stmt7027:Leaf
conditionals = & new_conditionals;

//Stmt7028:Parent
while (1) {
//Stmt6995:Parent
if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
//Stmt6989:Leaf
fi.filenm = fileinfo.filenm;

//Stmt6990:Leaf
fi.lineno = (unsigned long )tgts_started;

//Stmt6991:Leaf
record_files(filenames, pattern, pattern_percent, deps, cmds_started,
                          commands, commands_idx, two_colon, (struct floc  const  *)(& fi),
                          ! (flags & 1));

//Stmt6992:Leaf
using_filename |= commands_idx > 0U;

           }

//Stmt6996:Leaf
filenames = (struct nameseq *)0;

//Stmt6997:Leaf
commands_idx = 0U;

//Stmt6998:Parent
if (pattern) {
//Stmt6993:Leaf
free((void *)pattern);

//Stmt6994:Leaf
pattern = (char *)0;

           }

//Stmt6999:Leaf
break;

         }

//Stmt7029:Parent
while ((unsigned long )files___0 != (unsigned long )((struct nameseq *)0)) {
//Stmt7007:Leaf
next = files___0->next;

//Stmt7008:Leaf
name___0 = files___0->name;

//Stmt7009:Leaf
free((void *)((char *)files___0));

//Stmt7010:Leaf
files___0 = next;

//Stmt7011:Parent
if (noerror) {
//Stmt7000:Leaf
tmp___45 = 1 << 2;

           } else {
//Stmt7001:Leaf
tmp___45 = 0;

           }

//Stmt7012:Leaf
r = read_makefile(name___0, ((1 << 1) | (1 << 3)) | tmp___45);

//Stmt7013:Parent
if (! r) {
//Stmt7005:Parent
if (! noerror) {
//Stmt7002:Leaf
tmp___46 = __errno_location();

//Stmt7003:Leaf
tmp___47 = strerror(*tmp___46);

//Stmt7004:Leaf
error((struct floc  const  *)(& fileinfo), "%s: %s", name___0, tmp___47);

             }

           }

//Stmt7014:Parent
if (r < 2) {
//Stmt7006:Leaf
free((void *)name___0);

           }

         }

//Stmt7030:Parent
if (conditionals->ignoring) {
//Stmt7015:Leaf
free((void *)conditionals->ignoring);

         }

//Stmt7031:Parent
if (conditionals->seen_else) {
//Stmt7016:Leaf
free((void *)conditionals->seen_else);

         }

//Stmt7032:Leaf
conditionals = save;

//Stmt7033:Leaf
reading_file = (struct floc  const  *)(& fileinfo);

       } else {
//Stmt7034:Leaf
goto _L___9;

       }

     } else {
       _L___9: /* CIL Label */ 
       {
//Stmt7035:Leaf
tmp___76 = try_variable_definition((struct floc  const  *)(& fileinfo), p, (enum variable_origin )2,
                                          0);

}
//Stmt7218:Parent
if (! tmp___76) {
//Stmt7215:Parent
if ((int )*(lb.buffer + 0) == 9) {
//Stmt7171:Leaf
p = collapsed;

//Stmt7172:Parent
while (1) {
//Stmt7037:Leaf
tmp___48 = __ctype_b_loc();

//Stmt7038:Parent
if (! ((int const   )*(*tmp___48 + (int )*p) & 1)) {
//Stmt7036:Leaf
break;

             }

//Stmt7039:Leaf
p ++;

           }

//Stmt7173:Parent
if ((int )*p == 0) {
//Stmt7040:Leaf
continue;

           }

//Stmt7174:Leaf
tmp___49 = dcgettext((char const   *)((void *)0), "commands commence before first target",
                                5);

//Stmt7175:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___49);

         } else {
//Stmt7176:Leaf
plen = 0U;

//Stmt7177:Parent
while (1) {
//Stmt7047:Parent
if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
//Stmt7041:Leaf
fi___0.filenm = fileinfo.filenm;

//Stmt7042:Leaf
fi___0.lineno = (unsigned long )tgts_started;

//Stmt7043:Leaf
record_files(filenames, pattern, pattern_percent, deps, cmds_started,
                            commands, commands_idx, two_colon, (struct floc  const  *)(& fi___0),
                            ! (flags & 1));

//Stmt7044:Leaf
using_filename |= commands_idx > 0U;

             }

//Stmt7048:Leaf
filenames = (struct nameseq *)0;

//Stmt7049:Leaf
commands_idx = 0U;

//Stmt7050:Parent
if (pattern) {
//Stmt7045:Leaf
free((void *)pattern);

//Stmt7046:Leaf
pattern = (char *)0;

             }

//Stmt7051:Leaf
break;

           }

//Stmt7178:Leaf
tgts_started = (unsigned int )fileinfo.lineno;

//Stmt7179:Leaf
cmdleft = find_char_unquote(lb.buffer, (char *)";#", 0);

//Stmt7180:Parent
if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
//Stmt7059:Parent
if ((int )*cmdleft == 35) {
//Stmt7052:Leaf
*cmdleft = (char )'\000';

//Stmt7053:Leaf
cmdleft = (char *)0;

             } else {
//Stmt7054:Leaf
goto _L___7;

             }

           } else
           _L___7: /* CIL Label */ 
           {
//Stmt7058:Parent
if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
//Stmt7055:Leaf
tmp___50 = cmdleft;

//Stmt7056:Leaf
cmdleft ++;

//Stmt7057:Leaf
*tmp___50 = (char )'\000';

           }
}


//Stmt7181:Leaf
collapse_continuations(lb.buffer);

//Stmt7182:Leaf
wtype = get_next_mword(lb.buffer, (char *)((void *)0), & lb_next, & len___4);

//Stmt7183:Parent
switch ((unsigned int )wtype) {
           case 1U:; 
//Stmt7062:Parent
if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
//Stmt7060:Leaf
tmp___51 = dcgettext((char const   *)((void *)0), "missing rule before commands",
                                  5);

//Stmt7061:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___51);

           }

//Stmt7064:Leaf
continue;

           case 5U:; 
           case 4U:; 
//Stmt7063:Leaf
no_targets = 1;

//Stmt7065:Leaf
continue;

           default:; 
           break;
           }

//Stmt7184:Leaf
p2 = variable_expand_string((char *)((void *)0), lb_next, (long )len___4);

//Stmt7185:Parent
while (1) {
//Stmt7080:Leaf
lb_next += len___4;

//Stmt7081:Parent
if ((unsigned long )cmdleft == (unsigned long )((char *)0)) {
//Stmt7076:Leaf
cmdleft = find_char_unquote(p2, (char *)";", 0);

//Stmt7077:Parent
if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
//Stmt7066:Leaf
p2_off = (unsigned long )(p2 - variable_buffer);

//Stmt7067:Leaf
cmd_off = (unsigned long )(cmdleft - variable_buffer);

//Stmt7068:Leaf
tmp___52 = strlen((char const   *)p2);

//Stmt7069:Leaf
pend = p2 + tmp___52;

//Stmt7070:Leaf
*cmdleft = (char )'\000';

//Stmt7071:Leaf
variable_expand_string(pend, lb_next, -1L);

//Stmt7072:Leaf
tmp___53 = strlen((char const   *)lb_next);

//Stmt7073:Leaf
lb_next += tmp___53;

//Stmt7074:Leaf
p2 = variable_buffer + p2_off;

//Stmt7075:Leaf
cmdleft = (variable_buffer + cmd_off) + 1;

               }

             }

//Stmt7082:Leaf
colonp = find_char_unquote(p2, (char *)":", 0);

//Stmt7083:Parent
if ((unsigned long )colonp != (unsigned long )((char *)0)) {
//Stmt7078:Leaf
break;

             }

//Stmt7084:Leaf
wtype = get_next_mword(lb_next, (char *)((void *)0), & lb_next, & len___4);

//Stmt7085:Parent
if ((unsigned int )wtype == 1U) {
//Stmt7079:Leaf
break;

             }

//Stmt7086:Leaf
tmp___54 = strlen((char const   *)p2);

//Stmt7087:Leaf
p2 += tmp___54;

//Stmt7088:Leaf
tmp___55 = p2;

//Stmt7089:Leaf
p2 ++;

//Stmt7090:Leaf
*tmp___55 = (char )' ';

//Stmt7091:Leaf
p2 = variable_expand_string(p2, lb_next, (long )len___4);

           }

//Stmt7186:Leaf
p2 = next_token(variable_buffer);

//Stmt7187:Parent
if ((unsigned int )wtype == 1U) {
//Stmt7099:Parent
if ((int )*p2 != 0) {
//Stmt7095:Leaf
tmp___59 = strncmp((char const   *)lb.buffer, "        ", (size_t )8);

//Stmt7096:Parent
if (tmp___59 == 0) {
//Stmt7092:Leaf
tmp___57 = dcgettext((char const   *)((void *)0), " (did you mean TAB instead of 8 spaces?)",
                                      5);

//Stmt7093:Leaf
tmp___58 = (char const   *)tmp___57;

               } else {
//Stmt7094:Leaf
tmp___58 = "";

               }

//Stmt7097:Leaf
tmp___60 = dcgettext((char const   *)((void *)0), "missing separator%s",
                                    5);

//Stmt7098:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___60,
                     tmp___58);

             }

//Stmt7100:Leaf
continue;

           }

//Stmt7188:Leaf
*colonp = (char )'\000';

//Stmt7189:Leaf
tmp___61 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct nameseq ),
                                     1);

//Stmt7190:Leaf
filenames = multi_glob(tmp___61, (unsigned int )sizeof(struct nameseq ));

//Stmt7191:Leaf
*p2 = (char )':';

//Stmt7192:Parent
if (! filenames) {
//Stmt7101:Leaf
no_targets = 1;

//Stmt7102:Leaf
continue;

           }

//Stmt7193:Parent
if (! ((int )*p2 != 0)) {
//Stmt7103:Leaf
__assert_fail("*p2 != \'\\0\'", "read.c", 896U, "read_makefile");

           }

//Stmt7194:Leaf
p2 ++;

//Stmt7195:Leaf
two_colon = (int )*p2 == 58;

//Stmt7196:Parent
if (two_colon) {
//Stmt7104:Leaf
p2 ++;

           }

//Stmt7197:Parent
if ((int )*lb_next != 0) {
//Stmt7105:Leaf
l = (unsigned int )(p2 - variable_buffer);

//Stmt7106:Leaf
tmp___63 = strlen((char const   *)p2);

//Stmt7107:Leaf
plen = (unsigned int )tmp___63;

//Stmt7108:Leaf
tmp___64 = strlen((char const   *)lb_next);

//Stmt7109:Leaf
variable_buffer_output(p2 + plen, lb_next, (unsigned int )(tmp___64 + 1UL));

//Stmt7110:Leaf
p2 = variable_buffer + l;

           }

//Stmt7198:Leaf
wtype = get_next_mword(p2, (char *)((void *)0), & p, & len___4);

//Stmt7199:Leaf
v_origin = (enum variable_origin )2;

//Stmt7200:Parent
if ((unsigned int )wtype == 2U) {
//Stmt7115:Parent
if ((unsigned long )len___4 == sizeof("override") - 1UL) {
//Stmt7113:Leaf
tmp___65 = strncmp((char const   *)p, "override", (size_t )len___4);

//Stmt7114:Parent
if (tmp___65 == 0) {
//Stmt7111:Leaf
v_origin = (enum variable_origin )5;

//Stmt7112:Leaf
wtype = get_next_mword(p + len___4, (char *)((void *)0), & p, & len___4);

               }

             }

           }

//Stmt7201:Parent
if ((unsigned int )wtype != 1U) {
//Stmt7116:Leaf
wtype = get_next_mword(p + len___4, (char *)((void *)0), (char **)((void *)0),
                                    (unsigned int *)((void *)0));

           }

//Stmt7202:Parent
if ((unsigned int )wtype == 8U) {
//Stmt7117:Leaf
record_target_var(filenames, p, two_colon, v_origin, (struct floc  const  *)(& fileinfo));

//Stmt7118:Leaf
filenames = (struct nameseq *)0;

//Stmt7119:Leaf
continue;

           }

//Stmt7203:Leaf
find_char_unquote(lb_next, (char *)"=", 0);

//Stmt7204:Leaf
no_targets = 0;

//Stmt7205:Parent
if ((int )*lb_next != 0) {
//Stmt7125:Leaf
l___0 = (unsigned int )(p2 - variable_buffer);

//Stmt7126:Leaf
variable_expand_string(p2 + plen, lb_next, -1L);

//Stmt7127:Leaf
p2 = variable_buffer + l___0;

//Stmt7128:Parent
if ((unsigned long )cmdleft == (unsigned long )((char *)0)) {
//Stmt7123:Leaf
cmdleft = find_char_unquote(p2, (char *)";", 0);

//Stmt7124:Parent
if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
//Stmt7120:Leaf
tmp___66 = cmdleft;

//Stmt7121:Leaf
cmdleft ++;

//Stmt7122:Leaf
*tmp___66 = (char )'\000';

               }

             }

           }

//Stmt7206:Leaf
p = strchr((char const   *)p2, ':');

//Stmt7207:Parent
while (1) {
//Stmt7139:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt7130:Parent
if (! ((int )*(p + -1) == 92)) {
//Stmt7129:Leaf
break;

               }

             } else {
//Stmt7131:Leaf
break;

             }

//Stmt7140:Leaf
q = p + -1;

//Stmt7141:Leaf
backslash = 0;

//Stmt7142:Parent
while (1) {
//Stmt7133:Leaf
tmp___67 = q;

//Stmt7134:Leaf
q --;

//Stmt7135:Parent
if (! ((int )*tmp___67 == 92)) {
//Stmt7132:Leaf
break;

               }

//Stmt7136:Leaf
backslash = ! backslash;

             }

//Stmt7143:Parent
if (backslash) {
//Stmt7137:Leaf
p = strchr((char const   *)(p + 1), ':');

             } else {
//Stmt7138:Leaf
break;

             }

           }

//Stmt7208:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt7151:Leaf
target = parse_file_seq(& p2, ':', (unsigned int )sizeof(struct nameseq ),
                                     1);

//Stmt7152:Leaf
p2 ++;

//Stmt7153:Parent
if ((unsigned long )target == (unsigned long )((struct nameseq *)0)) {
//Stmt7146:Leaf
tmp___68 = dcgettext((char const   *)((void *)0), "missing target pattern",
                                    5);

//Stmt7147:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___68);

             } else
             {
//Stmt7148:Parent
if ((unsigned long )target->next != (unsigned long )((struct nameseq *)0)) {
//Stmt7144:Leaf
tmp___69 = dcgettext((char const   *)((void *)0), "multiple target patterns",
                                    5);

//Stmt7145:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___69);

             }
}


//Stmt7154:Leaf
pattern = target->name;

//Stmt7155:Leaf
pattern_percent = find_percent(pattern);

//Stmt7156:Parent
if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
//Stmt7149:Leaf
tmp___70 = dcgettext((char const   *)((void *)0), "target pattern contains no `%%\'",
                                    5);

//Stmt7150:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___70);

             }

//Stmt7157:Leaf
free((void *)((char *)target));

           } else {
//Stmt7158:Leaf
pattern = (char *)0;

           }

//Stmt7209:Leaf
tmp___71 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct dep ),
                                     1);

//Stmt7210:Leaf
tmp___72 = multi_glob(tmp___71, (unsigned int )sizeof(struct dep ));

//Stmt7211:Leaf
deps = (struct dep *)tmp___72;

//Stmt7212:Leaf
commands_idx = 0U;

//Stmt7213:Parent
if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
//Stmt7162:Leaf
tmp___73 = strlen((char const   *)cmdleft);

//Stmt7163:Leaf
len___5 = (unsigned int )tmp___73;

//Stmt7164:Leaf
cmds_started = (unsigned int )fileinfo.lineno;

//Stmt7165:Parent
if (len___5 + 2U > commands_len) {
//Stmt7159:Leaf
commands_len = (len___5 + 2U) * 2U;

//Stmt7160:Leaf
tmp___74 = xrealloc(commands, commands_len);

//Stmt7161:Leaf
commands = tmp___74;

             }

//Stmt7166:Leaf
memmove((void *)commands, (void const   *)cmdleft, (size_t )len___5);

//Stmt7167:Leaf
commands_idx += len___5;

//Stmt7168:Leaf
tmp___75 = commands_idx;

//Stmt7169:Leaf
commands_idx ++;

//Stmt7170:Leaf
*(commands + tmp___75) = (char )'\n';

           }

//Stmt7214:Leaf
continue;

         }

       }

     }
}

}

}

}

}


//Stmt7267:Parent
while (1) {
//Stmt7238:Parent
if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
//Stmt7232:Leaf
fi___1.filenm = fileinfo.filenm;

//Stmt7233:Leaf
fi___1.lineno = (unsigned long )tgts_started;

//Stmt7234:Leaf
record_files(filenames, pattern, pattern_percent, deps, cmds_started, commands,
                      commands_idx, two_colon, (struct floc  const  *)(& fi___1), ! (flags & 1));

//Stmt7235:Leaf
using_filename |= commands_idx > 0U;

       }

//Stmt7239:Leaf
filenames = (struct nameseq *)0;

//Stmt7240:Leaf
commands_idx = 0U;

//Stmt7241:Parent
if (pattern) {
//Stmt7236:Leaf
free((void *)pattern);

//Stmt7237:Leaf
pattern = (char *)0;

       }

//Stmt7242:Leaf
break;

     }

//Stmt7268:Leaf
no_targets = 0;

   }

//Stmt7468:Parent
if (conditionals->if_cmds) {
//Stmt7269:Leaf
tmp___84 = dcgettext((char const   *)((void *)0), "missing `endif\'", 5);

//Stmt7270:Leaf
fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___84);

   }

//Stmt7469:Parent
while (1) {
//Stmt7277:Parent
if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
//Stmt7271:Leaf
fi___2.filenm = fileinfo.filenm;

//Stmt7272:Leaf
fi___2.lineno = (unsigned long )tgts_started;

//Stmt7273:Leaf
record_files(filenames, pattern, pattern_percent, deps, cmds_started, commands,
                    commands_idx, two_colon, (struct floc  const  *)(& fi___2), ! (flags & 1));

//Stmt7274:Leaf
using_filename |= commands_idx > 0U;

     }

//Stmt7278:Leaf
filenames = (struct nameseq *)0;

//Stmt7279:Leaf
commands_idx = 0U;

//Stmt7280:Parent
if (pattern) {
//Stmt7275:Leaf
free((void *)pattern);

//Stmt7276:Leaf
pattern = (char *)0;

     }

//Stmt7281:Leaf
break;

   }

//Stmt7470:Leaf
free((void *)lb.buffer);

//Stmt7471:Leaf
free((void *)commands);

//Stmt7472:Leaf
fclose(infile);

//Stmt7473:Leaf
reading_file = (struct floc  const  *)0;

//Stmt7474:Leaf
return (1 + using_filename);

 }
}
 static void do_define(char *name , unsigned int namelen , enum variable_origin origin ,
                       FILE *infile , struct floc *flocp ) 
 { 
//Stmt7519:Leaf
struct linebuffer lb ;

//Stmt7520:Leaf
unsigned int nlines ;

//Stmt7521:Leaf
unsigned int length___0 ;

//Stmt7522:Leaf
char *definition ;

//Stmt7523:Leaf
char *tmp ;

//Stmt7524:Leaf
register unsigned int idx ;

//Stmt7525:Leaf
register char *p ;

//Stmt7526:Leaf
char *var ;

//Stmt7527:Leaf
void *tmp___0 ;

//Stmt7528:Leaf
char *tmp___1 ;

//Stmt7529:Leaf
unsigned int len ;

//Stmt7530:Leaf
unsigned long tmp___2 ;

//Stmt7531:Leaf
size_t tmp___3 ;

//Stmt7532:Leaf
char *tmp___4 ;

//Stmt7533:Leaf
char *tmp___5 ;

//Stmt7534:Leaf
size_t tmp___6 ;

//Stmt7535:Leaf
size_t tmp___7 ;

//Stmt7536:Leaf
char *tmp___8 ;

//Stmt7537:Leaf
unsigned int tmp___9 ;

//Stmt7538:Leaf
unsigned short const   **tmp___10 ;

//Stmt7539:Leaf
int tmp___11 ;

//Stmt7540:Leaf
int tmp___12 ;

//Stmt7541:Leaf
char *tmp___13 ;

 
   {
//Stmt7542:Leaf
nlines = 0U;

//Stmt7543:Leaf
length___0 = 100U;

//Stmt7544:Leaf
tmp = xmalloc(100U);

//Stmt7545:Leaf
definition = tmp;

//Stmt7546:Leaf
idx = 0U;

//Stmt7547:Leaf
tmp___0 = __builtin_alloca((unsigned long )(namelen + 1U));

//Stmt7548:Leaf
var = (char *)tmp___0;

//Stmt7549:Leaf
memmove((void *)var, (void const   *)name, (size_t )namelen);

//Stmt7550:Leaf
*(var + namelen) = (char )'\000';

//Stmt7551:Leaf
var = variable_expand(var);

//Stmt7552:Leaf
lb.size = 200U;

//Stmt7553:Leaf
tmp___1 = xmalloc(lb.size);

//Stmt7554:Leaf
lb.buffer = tmp___1;

//Stmt7555:Parent
while (1) {
//Stmt7509:Leaf
tmp___12 = feof(infile);

//Stmt7510:Parent
if (tmp___12) {
//Stmt7475:Leaf
break;

     }

//Stmt7511:Leaf
flocp->lineno += (unsigned long )nlines;

//Stmt7512:Leaf
tmp___2 = readline(& lb, infile, (struct floc  const  *)flocp);

//Stmt7513:Leaf
nlines = (unsigned int )tmp___2;

//Stmt7514:Leaf
collapse_continuations(lb.buffer);

//Stmt7515:Leaf
p = next_token(lb.buffer);

//Stmt7516:Leaf
tmp___3 = strlen((char const   *)p);

//Stmt7517:Leaf
len = (unsigned int )tmp___3;

//Stmt7518:Parent
if (len == 5U) {
//Stmt7507:Leaf
goto _L___0;

     } else
     {
//Stmt7508:Parent
if (len > 5U) {
//Stmt7498:Leaf
tmp___10 = __ctype_b_loc();

//Stmt7499:Parent
if ((int const   )*(*tmp___10 + (int )*(p + 5)) & 1) {
         _L___0: /* CIL Label */ 
         {
//Stmt7476:Leaf
tmp___11 = strncmp((char const   *)p, "endef", (size_t )5);

}
//Stmt7492:Parent
if (tmp___11 == 0) {
//Stmt7481:Leaf
p += 5;

//Stmt7482:Leaf
remove_comments(p);

//Stmt7483:Leaf
tmp___5 = next_token(p);

//Stmt7484:Parent
if ((int )*tmp___5 != 0) {
//Stmt7477:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "Extraneous text after `endef\' directive",
                                 5);

//Stmt7478:Leaf
error((struct floc  const  *)flocp, (char const   *)tmp___4);

           }

//Stmt7485:Parent
if (idx == 0U) {
//Stmt7479:Leaf
*(definition + 0) = (char )'\000';

           } else {
//Stmt7480:Leaf
*(definition + (idx - 1U)) = (char )'\000';

           }

//Stmt7486:Leaf
tmp___6 = strlen((char const   *)var);

//Stmt7487:Leaf
define_variable_in_set(var, (unsigned int )tmp___6, definition, origin,
                                  1, current_variable_set_list->set, (struct floc  const  *)flocp);

//Stmt7488:Leaf
free((void *)definition);

//Stmt7489:Leaf
free((void *)lb.buffer);

//Stmt7490:Leaf
return;

         } else {
//Stmt7491:Leaf
goto _L___1;

         }

       } else {
//Stmt7493:Leaf
goto _L___1;

       }

     } else {
       _L___1: /* CIL Label */ 
       {
//Stmt7494:Leaf
tmp___7 = strlen((char const   *)lb.buffer);

}
//Stmt7500:Leaf
len = (unsigned int )tmp___7;

//Stmt7501:Parent
if ((idx + len) + 1U > length___0) {
//Stmt7495:Leaf
length___0 = (idx + len) * 2U;

//Stmt7496:Leaf
tmp___8 = xrealloc(definition, length___0 + 1U);

//Stmt7497:Leaf
definition = tmp___8;

       }

//Stmt7502:Leaf
memmove((void *)(definition + idx), (void const   *)lb.buffer, (size_t )len);

//Stmt7503:Leaf
idx += len;

//Stmt7504:Leaf
tmp___9 = idx;

//Stmt7505:Leaf
idx ++;

//Stmt7506:Leaf
*(definition + tmp___9) = (char )'\n';

     }
}


   }

//Stmt7556:Leaf
tmp___13 = dcgettext((char const   *)((void *)0), "missing `endef\', unterminated `define\'",
                        5);

//Stmt7557:Leaf
fatal((struct floc  const  *)flocp, (char const   *)tmp___13);

//Stmt7558:Leaf
return;

 }
}
 static int conditional_line(char *line , struct floc  const  *flocp ) 
 { 
//Stmt7731:Leaf
int notdef ;

//Stmt7732:Leaf
char *cmdname ;

//Stmt7733:Leaf
register unsigned int i ;

//Stmt7734:Leaf
int tmp ;

//Stmt7735:Leaf
int tmp___0 ;

//Stmt7736:Leaf
int tmp___1 ;

//Stmt7737:Leaf
char *tmp___2 ;

//Stmt7738:Leaf
char *tmp___3 ;

//Stmt7739:Leaf
char *tmp___4 ;

//Stmt7740:Leaf
char *tmp___5 ;

//Stmt7741:Leaf
char *tmp___6 ;

//Stmt7742:Leaf
char *tmp___7 ;

//Stmt7743:Leaf
char *tmp___8 ;

//Stmt7744:Leaf
struct variable *v ;

//Stmt7745:Leaf
register char *p ;

//Stmt7746:Leaf
char *tmp___9 ;

//Stmt7747:Leaf
int tmp___10 ;

//Stmt7748:Leaf
char *s1 ;

//Stmt7749:Leaf
char *s2 ;

//Stmt7750:Leaf
unsigned int len ;

//Stmt7751:Leaf
char termin ;

//Stmt7752:Leaf
int tmp___11 ;

//Stmt7753:Leaf
register int count ;

//Stmt7754:Leaf
char *p___0 ;

//Stmt7755:Leaf
char *tmp___12 ;

//Stmt7756:Leaf
unsigned short const   **tmp___13 ;

//Stmt7757:Leaf
char *tmp___14 ;

//Stmt7758:Leaf
size_t tmp___15 ;

//Stmt7759:Leaf
void *tmp___16 ;

//Stmt7760:Leaf
register int count___0 ;

//Stmt7761:Leaf
char *tmp___17 ;

//Stmt7762:Leaf
int tmp___18 ;

//Stmt7763:Leaf
int tmp___19 ;

//Stmt7764:Leaf
int tmp___20 ;

 
   {
//Stmt7765:Parent
if ((int )*line == 105) {
//Stmt7577:Leaf
notdef = (int )*(line + 2) == 110;

//Stmt7578:Parent
if (notdef) {
//Stmt7567:Parent
if ((int )*(line + 3) == 100) {
//Stmt7559:Leaf
cmdname = (char *)"ifndef";

       } else {
//Stmt7560:Leaf
cmdname = (char *)"ifneq";

       }

//Stmt7568:Parent
if ((int )*(cmdname + 3) == 100) {
//Stmt7561:Leaf
tmp = 7;

       } else {
//Stmt7562:Leaf
tmp = 6;

       }

//Stmt7569:Leaf
line += tmp;

     } else {
//Stmt7570:Parent
if ((int )*(line + 2) == 100) {
//Stmt7563:Leaf
cmdname = (char *)"ifdef";

       } else {
//Stmt7564:Leaf
cmdname = (char *)"ifeq";

       }

//Stmt7571:Parent
if ((int )*(cmdname + 2) == 100) {
//Stmt7565:Leaf
tmp___0 = 6;

       } else {
//Stmt7566:Leaf
tmp___0 = 5;

       }

//Stmt7572:Leaf
line += tmp___0;

     }

   } else {
//Stmt7579:Leaf
notdef = (int )*(line + 1) == 110;

//Stmt7580:Parent
if (notdef) {
//Stmt7573:Leaf
cmdname = (char *)"endif";

     } else {
//Stmt7574:Leaf
cmdname = (char *)"else";

     }

//Stmt7581:Parent
if (notdef) {
//Stmt7575:Leaf
tmp___1 = 5;

     } else {
//Stmt7576:Leaf
tmp___1 = 4;

     }

//Stmt7582:Leaf
line += tmp___1;

   }

//Stmt7766:Leaf
line = next_token(line);

//Stmt7767:Parent
if ((int )*cmdname == 101) {
//Stmt7596:Parent
if ((int )*line != 0) {
//Stmt7583:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "Extraneous text after `%s\' directive",
                           5);

//Stmt7584:Leaf
error(flocp, (char const   *)tmp___2, cmdname);

     }

//Stmt7597:Parent
if (conditionals->if_cmds == 0U) {
//Stmt7585:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "extraneous `%s\'", 5);

//Stmt7586:Leaf
fatal(flocp, (char const   *)tmp___3, cmdname);

     }

//Stmt7598:Parent
if (notdef) {
//Stmt7591:Leaf
(conditionals->if_cmds) --;

     } else
     {
//Stmt7592:Parent
if (*(conditionals->seen_else + (conditionals->if_cmds - 1U))) {
//Stmt7587:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "only one `else\' per conditional",
                           5);

//Stmt7588:Leaf
fatal(flocp, (char const   *)tmp___4);

     } else {
//Stmt7589:Leaf
*(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(! *(conditionals->ignoring + (conditionals->if_cmds - 1U)));

//Stmt7590:Leaf
*(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)1;

     }
}


//Stmt7599:Leaf
i = 0U;

//Stmt7600:Parent
while (i < conditionals->if_cmds) {
//Stmt7594:Parent
if (*(conditionals->ignoring + i)) {
//Stmt7593:Leaf
return (1);

       }

//Stmt7595:Leaf
i ++;

     }

//Stmt7601:Leaf
return (0);

   }

//Stmt7768:Parent
if (conditionals->allocated == 0U) {
//Stmt7602:Leaf
conditionals->allocated = 5U;

//Stmt7603:Leaf
tmp___5 = xmalloc(conditionals->allocated);

//Stmt7604:Leaf
conditionals->ignoring = tmp___5;

//Stmt7605:Leaf
tmp___6 = xmalloc(conditionals->allocated);

//Stmt7606:Leaf
conditionals->seen_else = tmp___6;

   }

//Stmt7769:Leaf
(conditionals->if_cmds) ++;

//Stmt7770:Parent
if (conditionals->if_cmds > conditionals->allocated) {
//Stmt7607:Leaf
conditionals->allocated += 5U;

//Stmt7608:Leaf
tmp___7 = xrealloc(conditionals->ignoring, conditionals->allocated);

//Stmt7609:Leaf
conditionals->ignoring = tmp___7;

//Stmt7610:Leaf
tmp___8 = xrealloc(conditionals->seen_else, conditionals->allocated);

//Stmt7611:Leaf
conditionals->seen_else = tmp___8;

   }

//Stmt7771:Leaf
*(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)0;

//Stmt7772:Leaf
i = 0U;

//Stmt7773:Parent
while (i < conditionals->if_cmds - 1U) {
//Stmt7614:Parent
if (*(conditionals->ignoring + i)) {
//Stmt7612:Leaf
*(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char)1;

//Stmt7613:Leaf
return (1);

     }

//Stmt7615:Leaf
i ++;

   }

//Stmt7774:Parent
if (notdef) {
//Stmt7616:Leaf
tmp___20 = 3;

   } else {
//Stmt7617:Leaf
tmp___20 = 2;

   }

//Stmt7775:Parent
if ((int )*(cmdname + tmp___20) == 100) {
//Stmt7694:Leaf
tmp___9 = end_of_token(line);

//Stmt7695:Leaf
p = tmp___9;

//Stmt7696:Leaf
i = (unsigned int )(p - line);

//Stmt7697:Leaf
p = next_token(p);

//Stmt7698:Parent
if ((int )*p != 0) {
//Stmt7618:Leaf
return (-1);

     }

//Stmt7699:Leaf
v = lookup_variable(line, i);

//Stmt7700:Parent
if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt7621:Parent
if ((int )*(v->value) != 0) {
//Stmt7619:Leaf
tmp___10 = 1;

       } else {
//Stmt7620:Leaf
tmp___10 = 0;

       }

     } else {
//Stmt7622:Leaf
tmp___10 = 0;

     }

//Stmt7701:Leaf
*(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___10 == notdef);

   } else {
//Stmt7702:Parent
if ((int )*line == 40) {
//Stmt7623:Leaf
tmp___11 = ',';

     } else {
//Stmt7624:Leaf
tmp___11 = (int )*line;

     }

//Stmt7703:Leaf
termin = (char )tmp___11;

//Stmt7704:Parent
if ((int )termin != 44) {
//Stmt7627:Parent
if ((int )termin != 34) {
//Stmt7626:Parent
if ((int )termin != 39) {
//Stmt7625:Leaf
return (-1);

         }

       }

     }

//Stmt7705:Leaf
line ++;

//Stmt7706:Leaf
s1 = line;

//Stmt7707:Parent
if ((int )termin == 44) {
//Stmt7641:Leaf
count = 0;

//Stmt7642:Parent
while ((int )*line != 0) {
//Stmt7634:Parent
if ((int )*line == 40) {
//Stmt7632:Leaf
count ++;

         } else
         {
//Stmt7633:Parent
if ((int )*line == 41) {
//Stmt7630:Leaf
count --;

         } else
         {
//Stmt7631:Parent
if ((int )*line == 44) {
//Stmt7629:Parent
if (count <= 0) {
//Stmt7628:Leaf
break;

           }

         }
}

}


//Stmt7635:Leaf
line ++;

       }

     } else {
//Stmt7643:Parent
while (1) {
//Stmt7639:Parent
if ((int )*line != 0) {
//Stmt7637:Parent
if (! ((int )*line != (int )termin)) {
//Stmt7636:Leaf
break;

           }

         } else {
//Stmt7638:Leaf
break;

         }

//Stmt7640:Leaf
line ++;

       }

     }

//Stmt7708:Parent
if ((int )*line == 0) {
//Stmt7644:Leaf
return (-1);

     }

//Stmt7709:Parent
if ((int )termin == 44) {
//Stmt7649:Leaf
tmp___12 = line;

//Stmt7650:Leaf
line ++;

//Stmt7651:Leaf
p___0 = tmp___12;

//Stmt7652:Parent
while (1) {
//Stmt7646:Leaf
tmp___13 = __ctype_b_loc();

//Stmt7647:Parent
if (! ((int const   )*(*tmp___13 + (int )*(p___0 + -1)) & 1)) {
//Stmt7645:Leaf
break;

         }

//Stmt7648:Leaf
p___0 --;

       }

//Stmt7653:Leaf
*p___0 = (char )'\000';

     } else {
//Stmt7654:Leaf
tmp___14 = line;

//Stmt7655:Leaf
line ++;

//Stmt7656:Leaf
*tmp___14 = (char )'\000';

     }

//Stmt7710:Leaf
s2 = variable_expand(s1);

//Stmt7711:Leaf
tmp___15 = strlen((char const   *)s2);

//Stmt7712:Leaf
len = (unsigned int )tmp___15;

//Stmt7713:Leaf
tmp___16 = __builtin_alloca((unsigned long )(len + 1U));

//Stmt7714:Leaf
s1 = (char *)tmp___16;

//Stmt7715:Leaf
memmove((void *)s1, (void const   *)s2, (size_t )(len + 1U));

//Stmt7716:Parent
if ((int )termin != 44) {
//Stmt7657:Leaf
line = next_token(line);

     }

//Stmt7717:Parent
if ((int )termin == 44) {
//Stmt7658:Leaf
termin = (char )')';

     } else {
//Stmt7659:Leaf
termin = *line;

     }

//Stmt7718:Parent
if ((int )termin != 41) {
//Stmt7662:Parent
if ((int )termin != 34) {
//Stmt7661:Parent
if ((int )termin != 39) {
//Stmt7660:Leaf
return (-1);

         }

       }

     }

//Stmt7719:Parent
if ((int )termin == 41) {
//Stmt7675:Leaf
count___0 = 0;

//Stmt7676:Leaf
s2 = next_token(line);

//Stmt7677:Leaf
line = s2;

//Stmt7678:Parent
while ((int )*line != 0) {
//Stmt7668:Parent
if ((int )*line == 40) {
//Stmt7666:Leaf
count___0 ++;

         } else
         {
//Stmt7667:Parent
if ((int )*line == 41) {
//Stmt7665:Parent
if (count___0 <= 0) {
//Stmt7663:Leaf
break;

           } else {
//Stmt7664:Leaf
count___0 --;

           }

         }
}


//Stmt7669:Leaf
line ++;

       }

     } else {
//Stmt7679:Leaf
line ++;

//Stmt7680:Leaf
s2 = line;

//Stmt7681:Parent
while (1) {
//Stmt7673:Parent
if ((int )*line != 0) {
//Stmt7671:Parent
if (! ((int )*line != (int )termin)) {
//Stmt7670:Leaf
break;

           }

         } else {
//Stmt7672:Leaf
break;

         }

//Stmt7674:Leaf
line ++;

       }

     }

//Stmt7720:Parent
if ((int )*line == 0) {
//Stmt7682:Leaf
return (-1);

     }

//Stmt7721:Leaf
*line = (char )'\000';

//Stmt7722:Leaf
line ++;

//Stmt7723:Leaf
line = next_token(line);

//Stmt7724:Parent
if ((int )*line != 0) {
//Stmt7683:Leaf
tmp___17 = dcgettext((char const   *)((void *)0), "Extraneous text after `%s\' directive",
                            5);

//Stmt7684:Leaf
error(flocp, (char const   *)tmp___17, cmdname);

     }

//Stmt7725:Leaf
s2 = variable_expand(s2);

//Stmt7726:Parent
if ((unsigned long )s1 == (unsigned long )s2) {
//Stmt7692:Leaf
tmp___19 = 1;

     } else
     {
//Stmt7693:Parent
if ((int )*s1 == (int )*s2) {
//Stmt7690:Parent
if ((int )*s1 == 0) {
//Stmt7687:Leaf
tmp___19 = 1;

       } else {
//Stmt7688:Leaf
tmp___18 = strcmp((char const   *)(s1 + 1), (char const   *)(s2 + 1));

//Stmt7689:Parent
if (tmp___18) {
//Stmt7685:Leaf
tmp___19 = 0;

         } else {
//Stmt7686:Leaf
tmp___19 = 1;

         }

       }

     } else {
//Stmt7691:Leaf
tmp___19 = 0;

     }
}


//Stmt7727:Leaf
*(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___19 == notdef);

   }

//Stmt7776:Leaf
i = 0U;

//Stmt7777:Parent
while (i < conditionals->if_cmds) {
//Stmt7729:Parent
if (*(conditionals->ignoring + i)) {
//Stmt7728:Leaf
return (1);

     }

//Stmt7730:Leaf
i ++;

   }

//Stmt7778:Leaf
return (0);

 }
}
 void uniquize_deps(struct dep *chain ) 
 { 
//Stmt7823:Leaf
register struct dep *d ;

//Stmt7824:Leaf
struct dep *last ;

//Stmt7825:Leaf
struct dep *next ;

//Stmt7826:Leaf
struct dep *n ;

//Stmt7827:Leaf
char *tmp ;

//Stmt7828:Leaf
char *tmp___0 ;

//Stmt7829:Leaf
char *tmp___1 ;

//Stmt7830:Leaf
char *tmp___2 ;

//Stmt7831:Leaf
char *tmp___3 ;

//Stmt7832:Leaf
char *tmp___4 ;

//Stmt7833:Leaf
char *tmp___5 ;

//Stmt7834:Leaf
int tmp___6 ;

 
   {
//Stmt7835:Leaf
d = chain;

//Stmt7836:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt7819:Leaf
last = d;

//Stmt7820:Leaf
next = d->next;

//Stmt7821:Parent
while ((unsigned long )next != (unsigned long )((struct dep *)0)) {
//Stmt7816:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt7779:Leaf
tmp = (d->file)->name;

       } else {
//Stmt7780:Leaf
tmp = d->name;

       }

//Stmt7817:Parent
if ((unsigned long )next->name == (unsigned long )((char *)0)) {
//Stmt7781:Leaf
tmp___0 = (next->file)->name;

       } else {
//Stmt7782:Leaf
tmp___0 = next->name;

       }

//Stmt7818:Parent
if ((unsigned long )tmp == (unsigned long )tmp___0) {
//Stmt7812:Leaf
goto _L___0;

       } else {
//Stmt7813:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt7783:Leaf
tmp___1 = (d->file)->name;

         } else {
//Stmt7784:Leaf
tmp___1 = d->name;

         }

//Stmt7814:Parent
if ((unsigned long )next->name == (unsigned long )((char *)0)) {
//Stmt7785:Leaf
tmp___2 = (next->file)->name;

         } else {
//Stmt7786:Leaf
tmp___2 = next->name;

         }

//Stmt7815:Parent
if ((int )*tmp___1 == (int )*tmp___2) {
//Stmt7808:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt7787:Leaf
tmp___3 = (d->file)->name;

           } else {
//Stmt7788:Leaf
tmp___3 = d->name;

           }

//Stmt7809:Parent
if ((int )*tmp___3 == 0) {
//Stmt7803:Leaf
goto _L___0;

           } else {
//Stmt7804:Parent
if ((unsigned long )next->name == (unsigned long )((char *)0)) {
//Stmt7789:Leaf
tmp___4 = (next->file)->name;

             } else {
//Stmt7790:Leaf
tmp___4 = next->name;

             }

//Stmt7805:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt7791:Leaf
tmp___5 = (d->file)->name;

             } else {
//Stmt7792:Leaf
tmp___5 = d->name;

             }

//Stmt7806:Leaf
tmp___6 = strcmp((char const   *)(tmp___5 + 1), (char const   *)(tmp___4 + 1));

//Stmt7807:Parent
if (tmp___6) {
//Stmt7797:Leaf
last = next;

//Stmt7798:Leaf
next = next->next;

             } else {
               _L___0: /* CIL Label */ 
               {
//Stmt7793:Leaf
n = next->next;

}
//Stmt7799:Leaf
last->next = n;

//Stmt7800:Parent
if ((unsigned long )next->name != (unsigned long )((char *)0)) {
//Stmt7795:Parent
if ((unsigned long )next->name != (unsigned long )d->name) {
//Stmt7794:Leaf
free((void *)next->name);

                 }

               }

//Stmt7801:Parent
if ((unsigned long )next != (unsigned long )d) {
//Stmt7796:Leaf
free((void *)((char *)next));

               }

//Stmt7802:Leaf
next = n;

             }

           }

         } else {
//Stmt7810:Leaf
last = next;

//Stmt7811:Leaf
next = next->next;

         }

       }

     }

//Stmt7822:Leaf
d = d->next;

   }

//Stmt7837:Leaf
return;

 }
}
 static void record_target_var(struct nameseq *filenames , char *defn , int two_colon ,
                               enum variable_origin origin , struct floc  const  *flocp ) 
 { 
//Stmt7873:Leaf
struct nameseq *nextf ;

//Stmt7874:Leaf
struct variable_set_list *global ;

//Stmt7875:Leaf
struct variable *v ;

//Stmt7876:Leaf
register char *name ;

//Stmt7877:Leaf
struct variable_set_list *vlist ;

//Stmt7878:Leaf
char *fname ;

//Stmt7879:Leaf
char *percent ;

//Stmt7880:Leaf
struct pattern_var *p ;

//Stmt7881:Leaf
struct file *f ;

//Stmt7882:Leaf
char *tmp ;

//Stmt7883:Leaf
struct variable *gv ;

//Stmt7884:Leaf
int len ;

//Stmt7885:Leaf
size_t tmp___0 ;

//Stmt7886:Leaf
size_t tmp___1 ;

 
   {
//Stmt7887:Leaf
global = current_variable_set_list;

//Stmt7888:Parent
while ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
//Stmt7861:Leaf
name = filenames->name;

//Stmt7862:Leaf
nextf = filenames->next;

//Stmt7863:Leaf
free((void *)((char *)filenames));

//Stmt7864:Leaf
percent = find_percent(name);

//Stmt7865:Parent
if (percent) {
//Stmt7838:Leaf
p = create_pattern_var(name, percent);

//Stmt7839:Leaf
vlist = p->vars;

//Stmt7840:Leaf
fname = p->target;

     } else {
//Stmt7841:Leaf
f = enter_file(name);

//Stmt7842:Leaf
initialize_file_variables(f, 1);

//Stmt7843:Leaf
vlist = f->variables;

//Stmt7844:Leaf
fname = f->name;

     }

//Stmt7866:Leaf
current_variable_set_list = vlist;

//Stmt7867:Leaf
v = try_variable_definition(flocp, defn, origin, 1);

//Stmt7868:Parent
if (! v) {
//Stmt7845:Leaf
tmp = dcgettext((char const   *)((void *)0), "Malformed per-target variable definition",
                       5);

//Stmt7846:Leaf
error(flocp, (char const   *)tmp);

     }

//Stmt7869:Leaf
v->per_target = 1U;

//Stmt7870:Parent
if ((unsigned int )origin != 5U) {
//Stmt7851:Leaf
tmp___0 = strlen((char const   *)v->name);

//Stmt7852:Leaf
len = (int )tmp___0;

//Stmt7853:Leaf
current_variable_set_list = global;

//Stmt7854:Leaf
gv = lookup_variable(v->name, (unsigned int )len);

//Stmt7855:Parent
if (gv) {
//Stmt7850:Parent
if ((unsigned int )gv->origin == 3U) {
//Stmt7848:Leaf
define_variable_in_set(v->name, (unsigned int )len, gv->value, gv->origin,
                                  (int )gv->recursive, vlist->set, flocp);

         } else
         {
//Stmt7849:Parent
if ((unsigned int )gv->origin == 4U) {
//Stmt7847:Leaf
define_variable_in_set(v->name, (unsigned int )len, gv->value, gv->origin,
                                  (int )gv->recursive, vlist->set, flocp);

         }
}


       }

     }

//Stmt7871:Parent
if ((unsigned long )name != (unsigned long )fname) {
//Stmt7860:Parent
if ((unsigned long )name < (unsigned long )fname) {
//Stmt7857:Leaf
free((void *)name);

       } else {
//Stmt7858:Leaf
tmp___1 = strlen((char const   *)fname);

//Stmt7859:Parent
if ((unsigned long )name > (unsigned long )(fname + tmp___1)) {
//Stmt7856:Leaf
free((void *)name);

         }

       }

     }

//Stmt7872:Leaf
filenames = nextf;

   }

//Stmt7889:Leaf
current_variable_set_list = global;

//Stmt7890:Leaf
return;

 }
}
 static char *percent___0  =    (char *)"%";
 static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                          struct dep *deps , unsigned int cmds_started , char *commands ,
                          unsigned int commands_idx , int two_colon , struct floc  const  *flocp ,
                          int set_default ) 
 { 
//Stmt8106:Leaf
struct nameseq *nextf ;

//Stmt8107:Leaf
int implicit ;

//Stmt8108:Leaf
unsigned int max_targets ;

//Stmt8109:Leaf
unsigned int target_idx ;

//Stmt8110:Leaf
char **targets ;

//Stmt8111:Leaf
char **target_percents ;

//Stmt8112:Leaf
struct commands *cmds ;

//Stmt8113:Leaf
char *tmp ;

//Stmt8114:Leaf
register char *name ;

//Stmt8115:Leaf
register struct file *f ;

//Stmt8116:Leaf
register struct dep *d ;

//Stmt8117:Leaf
struct dep *this ;

//Stmt8118:Leaf
char *implicit_percent ;

//Stmt8119:Leaf
char *tmp___0 ;

//Stmt8120:Leaf
char *tmp___1 ;

//Stmt8121:Leaf
char *tmp___2 ;

//Stmt8122:Leaf
char *tmp___3 ;

//Stmt8123:Leaf
char *tmp___4 ;

//Stmt8124:Leaf
char *tmp___5 ;

//Stmt8125:Leaf
struct dep *tmp___6 ;

//Stmt8126:Leaf
char *tmp___7 ;

//Stmt8127:Leaf
char *buffer ;

//Stmt8128:Leaf
char *tmp___8 ;

//Stmt8129:Leaf
char *o ;

//Stmt8130:Leaf
char *percent ;

//Stmt8131:Leaf
char *tmp___9 ;

//Stmt8132:Leaf
char *tmp___10 ;

//Stmt8133:Leaf
int tmp___11 ;

//Stmt8134:Leaf
char *tmp___12 ;

//Stmt8135:Leaf
char *tmp___13 ;

//Stmt8136:Leaf
char *tmp___14 ;

//Stmt8137:Leaf
char *tmp___15 ;

//Stmt8138:Leaf
struct dep *nextd ;

//Stmt8139:Leaf
struct dep *firstdeps ;

//Stmt8140:Leaf
struct dep *moredeps ;

//Stmt8141:Leaf
char *buffer___0 ;

//Stmt8142:Leaf
char *tmp___16 ;

//Stmt8143:Leaf
char *o___0 ;

//Stmt8144:Leaf
char *tmp___17 ;

//Stmt8145:Leaf
char *tmp___18 ;

//Stmt8146:Leaf
size_t tmp___19 ;

//Stmt8147:Leaf
int reject ;

//Stmt8148:Leaf
register struct dep *d2 ;

//Stmt8149:Leaf
char *tmp___20 ;

//Stmt8150:Leaf
char *tmp___21 ;

//Stmt8151:Leaf
char *tmp___22 ;

//Stmt8152:Leaf
char *tmp___23 ;

//Stmt8153:Leaf
int tmp___24 ;

//Stmt8154:Leaf
register unsigned int len ;

//Stmt8155:Leaf
char *tmp___25 ;

//Stmt8156:Leaf
size_t tmp___26 ;

//Stmt8157:Leaf
char *tmp___27 ;

//Stmt8158:Leaf
int tmp___28 ;

//Stmt8159:Leaf
char *tmp___29 ;

//Stmt8160:Leaf
char *tmp___30 ;

//Stmt8161:Leaf
char *tmp___31 ;

//Stmt8162:Leaf
int tmp___32 ;

//Stmt8163:Leaf
char *tmp___33 ;

 
   {
//Stmt8164:Leaf
implicit = 0;

//Stmt8165:Leaf
max_targets = 0U;

//Stmt8166:Leaf
target_idx = 0U;

//Stmt8167:Leaf
targets = (char **)0;

//Stmt8168:Leaf
target_percents = (char **)0;

//Stmt8169:Parent
if (commands_idx > 0U) {
//Stmt7891:Leaf
tmp = xmalloc((unsigned int )sizeof(struct commands ));

//Stmt7892:Leaf
cmds = (struct commands *)tmp;

//Stmt7893:Leaf
cmds->fileinfo.filenm = (char *)flocp->filenm;

//Stmt7894:Leaf
cmds->fileinfo.lineno = (unsigned long )cmds_started;

//Stmt7895:Leaf
cmds->commands = savestring((char const   *)commands, commands_idx);

//Stmt7896:Leaf
cmds->command_lines = (char **)0;

   } else {
//Stmt7897:Leaf
cmds = (struct commands *)0;

   }

//Stmt8170:Parent
while ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
//Stmt8089:Leaf
name = filenames->name;

//Stmt8090:Leaf
nextf = filenames->next;

//Stmt8091:Leaf
free((void *)filenames);

//Stmt8092:Leaf
implicit_percent = find_percent(name);

//Stmt8093:Leaf
implicit |= (unsigned long )implicit_percent != (unsigned long )((char *)0);

//Stmt8094:Parent
if (implicit) {
//Stmt7900:Parent
if ((unsigned long )pattern != (unsigned long )((char *)0)) {
//Stmt7898:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "mixed implicit and static pattern rules",
                             5);

//Stmt7899:Leaf
fatal(flocp, (char const   *)tmp___0);

       }

     }

//Stmt8095:Parent
if (implicit) {
//Stmt7903:Parent
if ((unsigned long )implicit_percent == (unsigned long )((char *)0)) {
//Stmt7901:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "mixed implicit and normal rules",
                             5);

//Stmt7902:Leaf
fatal(flocp, (char const   *)tmp___1);

       }

     }

//Stmt8096:Parent
if (implicit) {
//Stmt7916:Parent
if ((unsigned long )targets == (unsigned long )((char **)0)) {
//Stmt7909:Leaf
max_targets = 5U;

//Stmt7910:Leaf
tmp___2 = xmalloc((unsigned int )(5UL * sizeof(char *)));

//Stmt7911:Leaf
targets = (char **)tmp___2;

//Stmt7912:Leaf
tmp___3 = xmalloc((unsigned int )(5UL * sizeof(char *)));

//Stmt7913:Leaf
target_percents = (char **)tmp___3;

//Stmt7914:Leaf
target_idx = 0U;

       } else
       {
//Stmt7915:Parent
if (target_idx == max_targets - 1U) {
//Stmt7904:Leaf
max_targets += 5U;

//Stmt7905:Leaf
tmp___4 = xrealloc((char *)targets, (unsigned int )((unsigned long )max_targets * sizeof(char *)));

//Stmt7906:Leaf
targets = (char **)tmp___4;

//Stmt7907:Leaf
tmp___5 = xrealloc((char *)target_percents, (unsigned int )((unsigned long )max_targets * sizeof(char *)));

//Stmt7908:Leaf
target_percents = (char **)tmp___5;

       }
}


//Stmt7917:Leaf
*(targets + target_idx) = name;

//Stmt7918:Leaf
*(target_percents + target_idx) = implicit_percent;

//Stmt7919:Leaf
target_idx ++;

//Stmt7920:Leaf
goto __Cont;

     }

//Stmt8097:Parent
if ((unsigned long )nextf != (unsigned long )((struct nameseq *)0)) {
//Stmt7921:Leaf
tmp___6 = copy_dep_chain(deps);

//Stmt7922:Leaf
this = tmp___6;

     } else {
//Stmt7923:Leaf
this = deps;

     }

//Stmt8098:Parent
if ((unsigned long )pattern != (unsigned long )((char *)0)) {
//Stmt7942:Leaf
tmp___11 = pattern_matches(pattern, pattern_percent, name);

//Stmt7943:Parent
if (tmp___11) {
//Stmt7935:Leaf
tmp___8 = variable_expand((char *)"");

//Stmt7936:Leaf
buffer = tmp___8;

//Stmt7937:Leaf
d = this;

//Stmt7938:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt7928:Leaf
tmp___9 = find_percent(d->name);

//Stmt7929:Leaf
percent = tmp___9;

//Stmt7930:Parent
if ((unsigned long )percent == (unsigned long )((char *)0)) {
//Stmt7924:Leaf
goto __Cont___0;

           }

//Stmt7931:Leaf
o = patsubst_expand(buffer, name, pattern, d->name, pattern_percent, percent);

//Stmt7932:Parent
if ((unsigned long )o == (unsigned long )buffer) {
//Stmt7925:Leaf
tmp___10 = dcgettext((char const   *)((void *)0), "target `%s\' leaves prerequisite pattern empty",
                                  5);

//Stmt7926:Leaf
fatal(flocp, (char const   *)tmp___10, name);

           }

//Stmt7933:Leaf
free((void *)d->name);

//Stmt7934:Leaf
d->name = savestring((char const   *)buffer, (unsigned int )(o - buffer));

           __Cont___0: /* CIL Label */ 
           {
//Stmt7927:Leaf
d = d->next;

}
         }

       } else {
//Stmt7939:Leaf
tmp___7 = dcgettext((char const   *)((void *)0), "target `%s\' doesn\'t match the target pattern",
                             5);

//Stmt7940:Leaf
error(flocp, (char const   *)tmp___7, name);

//Stmt7941:Leaf
this = (struct dep *)0;

       }

     }

//Stmt8099:Parent
if (! two_colon) {
//Stmt7994:Leaf
f = enter_file(name);

//Stmt7995:Parent
if (f->double_colon) {
//Stmt7944:Leaf
tmp___12 = dcgettext((char const   *)((void *)0), "target file `%s\' has both : and :: entries",
                              5);

//Stmt7945:Leaf
fatal(flocp, (char const   *)tmp___12, f->name);

       }

//Stmt7996:Parent
if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
//Stmt7956:Parent
if ((unsigned long )cmds == (unsigned long )f->cmds) {
//Stmt7946:Leaf
tmp___13 = dcgettext((char const   *)((void *)0), "target `%s\' given more than once in the same rule.",
                                5);

//Stmt7947:Leaf
error(flocp, (char const   *)tmp___13, f->name);

         } else {
//Stmt7948:Leaf
goto _L;

         }

       } else
       _L: /* CIL Label */ 
       {
//Stmt7955:Parent
if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
//Stmt7954:Parent
if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
//Stmt7953:Parent
if (f->is_target) {
//Stmt7949:Leaf
tmp___14 = dcgettext((char const   *)((void *)0), "warning: overriding commands for target `%s\'",
                                  5);

//Stmt7950:Leaf
error((struct floc  const  *)(& cmds->fileinfo), (char const   *)tmp___14,
                   f->name);

//Stmt7951:Leaf
tmp___15 = dcgettext((char const   *)((void *)0), "warning: ignoring old commands for target `%s\'",
                                  5);

//Stmt7952:Leaf
error((struct floc  const  *)(& (f->cmds)->fileinfo), (char const   *)tmp___15,
                   f->name);

           }

         }

       }
}


//Stmt7997:Leaf
f->is_target = 1U;

//Stmt7998:Parent
if ((unsigned long )f == (unsigned long )default_file) {
//Stmt7959:Parent
if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
//Stmt7958:Parent
if ((unsigned long )cmds == (unsigned long )((struct commands *)0)) {
//Stmt7957:Leaf
f->cmds = (struct commands *)0;

           }

         }

       }

//Stmt7999:Parent
if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
//Stmt7960:Leaf
f->cmds = cmds;

       }

//Stmt8000:Parent
if ((unsigned long )f == (unsigned long )suffix_file) {
//Stmt7983:Parent
if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
//Stmt7965:Leaf
d = f->deps;

//Stmt7966:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt7961:Leaf
nextd = d->next;

//Stmt7962:Leaf
free((void *)d->name);

//Stmt7963:Leaf
free((void *)((char *)d));

//Stmt7964:Leaf
d = nextd;

           }

//Stmt7967:Leaf
f->deps = (struct dep *)0;

         } else {
//Stmt7968:Leaf
goto _L___0;

         }

       } else
       _L___0: /* CIL Label */ 
       {
//Stmt7982:Parent
if ((unsigned long )f->deps != (unsigned long )((struct dep *)0)) {
//Stmt7978:Parent
if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
//Stmt7969:Leaf
firstdeps = this;

//Stmt7970:Leaf
moredeps = f->deps;

         } else {
//Stmt7971:Leaf
firstdeps = f->deps;

//Stmt7972:Leaf
moredeps = this;

         }

//Stmt7979:Parent
if ((unsigned long )firstdeps == (unsigned long )((struct dep *)0)) {
//Stmt7974:Leaf
firstdeps = moredeps;

         } else {
//Stmt7975:Leaf
d = firstdeps;

//Stmt7976:Parent
while ((unsigned long )d->next != (unsigned long )((struct dep *)0)) {
//Stmt7973:Leaf
d = d->next;

           }

//Stmt7977:Leaf
d->next = moredeps;

         }

//Stmt7980:Leaf
f->deps = firstdeps;

       } else {
//Stmt7981:Leaf
f->deps = this;

       }
}


//Stmt8001:Parent
if ((unsigned long )pattern != (unsigned long )((char *)0)) {
//Stmt7984:Leaf
tmp___16 = variable_expand((char *)"");

//Stmt7985:Leaf
buffer___0 = tmp___16;

//Stmt7986:Leaf
tmp___17 = patsubst_expand(buffer___0, name, pattern, percent___0, pattern_percent,
                                    percent___0);

//Stmt7987:Leaf
o___0 = tmp___17;

//Stmt7988:Leaf
f->stem = savestring((char const   *)buffer___0, (unsigned int )(o___0 - buffer___0));

       }

     } else {
//Stmt8002:Leaf
f = lookup_file(name);

//Stmt8003:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt7992:Parent
if (f->is_target) {
//Stmt7991:Parent
if (! f->double_colon) {
//Stmt7989:Leaf
tmp___18 = dcgettext((char const   *)((void *)0), "target file `%s\' has both : and :: entries",
                                  5);

//Stmt7990:Leaf
fatal(flocp, (char const   *)tmp___18, f->name);

           }

         }

       }

//Stmt8004:Leaf
f = enter_file(name);

//Stmt8005:Parent
if ((unsigned long )f->double_colon == (unsigned long )((struct file *)0)) {
//Stmt7993:Leaf
f->double_colon = f;

       }

//Stmt8006:Leaf
f->is_target = 1U;

//Stmt8007:Leaf
f->deps = this;

//Stmt8008:Leaf
f->cmds = cmds;

     }

//Stmt8100:Parent
if ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt8016:Parent
if ((unsigned long )name != (unsigned long )f->name) {
//Stmt8015:Parent
if ((unsigned long )name < (unsigned long )f->name) {
//Stmt8011:Leaf
free((void *)name);

//Stmt8012:Leaf
name = f->name;

         } else {
//Stmt8013:Leaf
tmp___19 = strlen((char const   *)f->name);

//Stmt8014:Parent
if ((unsigned long )name > (unsigned long )(f->name + tmp___19)) {
//Stmt8009:Leaf
free((void *)name);

//Stmt8010:Leaf
name = f->name;

           }

         }

       }

     }

//Stmt8101:Parent
if ((unsigned long )default_goal_file == (unsigned long )((struct file *)0)) {
//Stmt8087:Parent
if (set_default) {
//Stmt8086:Parent
if ((int )*name != 46) {
//Stmt8083:Leaf
goto _L___1;

         } else {
//Stmt8084:Leaf
tmp___33 = strchr((char const   *)name, '/');

//Stmt8085:Parent
if ((unsigned long )tmp___33 != (unsigned long )((char *)0)) {
             _L___1: /* CIL Label */ 
             {
//Stmt8017:Leaf
reject = 0;

}
//Stmt8080:Leaf
d = suffix_file->deps;

//Stmt8081:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt8073:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt8018:Leaf
tmp___20 = (d->file)->name;

               } else {
//Stmt8019:Leaf
tmp___20 = d->name;

               }

//Stmt8074:Parent
if ((int )*tmp___20 != 46) {
//Stmt8038:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt8020:Leaf
tmp___21 = (d->file)->name;

                 } else {
//Stmt8021:Leaf
tmp___21 = d->name;

                 }

//Stmt8039:Parent
if ((unsigned long )name == (unsigned long )tmp___21) {
//Stmt8034:Leaf
reject = 1;

//Stmt8035:Leaf
break;

                 } else {
//Stmt8036:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt8022:Leaf
tmp___22 = (d->file)->name;

                   } else {
//Stmt8023:Leaf
tmp___22 = d->name;

                   }

//Stmt8037:Parent
if ((int )*name == (int )*tmp___22) {
//Stmt8033:Parent
if ((int )*name == 0) {
//Stmt8028:Leaf
reject = 1;

//Stmt8029:Leaf
break;

                     } else {
//Stmt8030:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt8024:Leaf
tmp___23 = (d->file)->name;

                       } else {
//Stmt8025:Leaf
tmp___23 = d->name;

                       }

//Stmt8031:Leaf
tmp___24 = strcmp((char const   *)(name + 1), (char const   *)(tmp___23 + 1));

//Stmt8032:Parent
if (! tmp___24) {
//Stmt8026:Leaf
reject = 1;

//Stmt8027:Leaf
break;

                       }

                     }

                   }

                 }

               }

//Stmt8075:Leaf
d2 = suffix_file->deps;

//Stmt8076:Parent
while ((unsigned long )d2 != (unsigned long )((struct dep *)0)) {
//Stmt8064:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt8040:Leaf
tmp___25 = (d2->file)->name;

                 } else {
//Stmt8041:Leaf
tmp___25 = d2->name;

                 }

//Stmt8065:Leaf
tmp___26 = strlen((char const   *)tmp___25);

//Stmt8066:Leaf
len = (unsigned int )tmp___26;

//Stmt8067:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt8042:Leaf
tmp___27 = (d2->file)->name;

                 } else {
//Stmt8043:Leaf
tmp___27 = d2->name;

                 }

//Stmt8068:Leaf
tmp___28 = strncmp((char const   *)name, (char const   *)tmp___27,
                                    (size_t )len);

//Stmt8069:Parent
if (! (tmp___28 == 0)) {
//Stmt8044:Leaf
goto __Cont___1;

                 }

//Stmt8070:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt8045:Leaf
tmp___29 = (d->file)->name;

                 } else {
//Stmt8046:Leaf
tmp___29 = d->name;

                 }

//Stmt8071:Parent
if ((unsigned long )(name + len) == (unsigned long )tmp___29) {
//Stmt8059:Leaf
reject = 1;

//Stmt8060:Leaf
break;

                 } else {
//Stmt8061:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt8047:Leaf
tmp___30 = (d->file)->name;

                   } else {
//Stmt8048:Leaf
tmp___30 = d->name;

                   }

//Stmt8062:Parent
if ((int )*(name + len) == (int )*tmp___30) {
//Stmt8058:Parent
if ((int )*(name + len) == 0) {
//Stmt8053:Leaf
reject = 1;

//Stmt8054:Leaf
break;

                     } else {
//Stmt8055:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt8049:Leaf
tmp___31 = (d->file)->name;

                       } else {
//Stmt8050:Leaf
tmp___31 = d->name;

                       }

//Stmt8056:Leaf
tmp___32 = strcmp((char const   *)((name + len) + 1), (char const   *)(tmp___31 + 1));

//Stmt8057:Parent
if (! tmp___32) {
//Stmt8051:Leaf
reject = 1;

//Stmt8052:Leaf
break;

                       }

                     }

                   }

                 }

                 __Cont___1: /* CIL Label */ 
                 {
//Stmt8063:Leaf
d2 = d2->next;

}
               }

//Stmt8077:Parent
if (reject) {
//Stmt8072:Leaf
break;

               }

//Stmt8078:Leaf
d = d->next;

             }

//Stmt8082:Parent
if (! reject) {
//Stmt8079:Leaf
default_goal_file = f;

             }

           }

         }

       }

     }

     __Cont: /* CIL Label */ 
     {
//Stmt8088:Leaf
filenames = nextf;

}
   }

//Stmt8171:Parent
if (implicit) {
//Stmt8102:Leaf
*(targets + target_idx) = (char *)0;

//Stmt8103:Leaf
*(target_percents + target_idx) = (char *)0;

//Stmt8104:Leaf
create_pattern_rule(targets, target_percents, two_colon, deps, cmds, 1);

//Stmt8105:Leaf
free((void *)((char *)target_percents));

   }

//Stmt8172:Leaf
return;

 }
}
 char *find_char_unquote(char *string , char *stopchars , int blank ) 
 { 
//Stmt8205:Leaf
unsigned int string_len ;

//Stmt8206:Leaf
register char *p ;

//Stmt8207:Leaf
char *tmp ;

//Stmt8208:Leaf
unsigned short const   **tmp___0 ;

//Stmt8209:Leaf
register int i ;

//Stmt8210:Leaf
size_t tmp___1 ;

 
   {
//Stmt8211:Leaf
string_len = 0U;

//Stmt8212:Leaf
p = string;

//Stmt8213:Parent
while (1) {
//Stmt8202:Parent
while (1) {
//Stmt8181:Parent
if ((int )*p != 0) {
//Stmt8178:Leaf
tmp = strchr((char const   *)stopchars, (int )*p);

//Stmt8179:Parent
if ((unsigned long )tmp == (unsigned long )((char *)0)) {
//Stmt8176:Parent
if (! (! blank)) {
//Stmt8174:Leaf
tmp___0 = __ctype_b_loc();

//Stmt8175:Parent
if ((int const   )*(*tmp___0 + (int )*p) & 1) {
//Stmt8173:Leaf
break;

             }

           }

         } else {
//Stmt8177:Leaf
break;

         }

       } else {
//Stmt8180:Leaf
break;

       }

//Stmt8182:Leaf
p ++;

     }

//Stmt8203:Parent
if ((int )*p == 0) {
//Stmt8183:Leaf
break;

     }

//Stmt8204:Parent
if ((unsigned long )p > (unsigned long )string) {
//Stmt8200:Parent
if ((int )*(p + -1) == 92) {
//Stmt8192:Leaf
i = -2;

//Stmt8193:Parent
while (1) {
//Stmt8187:Parent
if ((unsigned long )(p + i) >= (unsigned long )string) {
//Stmt8185:Parent
if (! ((int )*(p + i) == 92)) {
//Stmt8184:Leaf
break;

             }

           } else {
//Stmt8186:Leaf
break;

           }

//Stmt8188:Leaf
i --;

         }

//Stmt8194:Leaf
i ++;

//Stmt8195:Parent
if (string_len == 0U) {
//Stmt8189:Leaf
tmp___1 = strlen((char const   *)string);

//Stmt8190:Leaf
string_len = (unsigned int )tmp___1;

         }

//Stmt8196:Leaf
memmove((void *)(p + i), (void const   *)(p + i / 2), (size_t )((((long )string_len - (p - string)) - (long )(i / 2)) + 1L));

//Stmt8197:Leaf
p += i / 2;

//Stmt8198:Parent
if (i % 2 == 0) {
//Stmt8191:Leaf
return (p);

         }

       } else {
//Stmt8199:Leaf
return (p);

       }

     } else {
//Stmt8201:Leaf
return (p);

     }

   }

//Stmt8214:Leaf
return ((char *)0);

 }
}
 char *find_percent(char *pattern ) 
 { 
//Stmt8215:Leaf
char *tmp ;

 
   {
//Stmt8216:Leaf
tmp = find_char_unquote(pattern, (char *)"%", 0);

//Stmt8217:Leaf
return (tmp);

 }
}
 struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                                int strip ) 
 { 
//Stmt8310:Leaf
register struct nameseq *new ;

//Stmt8311:Leaf
register struct nameseq *new1 ;

//Stmt8312:Leaf
register struct nameseq *lastnew1 ;

//Stmt8313:Leaf
register char *p ;

//Stmt8314:Leaf
char *q ;

//Stmt8315:Leaf
char *name ;

//Stmt8316:Leaf
char stopchars[3] ;

//Stmt8317:Leaf
size_t tmp ;

//Stmt8318:Leaf
char *tmp___0 ;

//Stmt8319:Leaf
struct nameseq *n ;

//Stmt8320:Leaf
struct nameseq *lastn ;

//Stmt8321:Leaf
char *paren ;

//Stmt8322:Leaf
char *libname ;

//Stmt8323:Leaf
void *tmp___1 ;

//Stmt8324:Leaf
size_t tmp___2 ;

//Stmt8325:Leaf
char *tmp___3 ;

 
   {
//Stmt8326:Leaf
new = (struct nameseq *)0;

//Stmt8327:Leaf
p = *stringp;

//Stmt8328:Leaf
stopchars[0] = (char )stopchar;

//Stmt8329:Leaf
stopchars[1] = (char )'\000';

//Stmt8330:Parent
while (1) {
//Stmt8238:Leaf
p = next_token(p);

//Stmt8239:Parent
if ((int )*p == 0) {
//Stmt8218:Leaf
break;

     }

//Stmt8240:Parent
if ((int )*p == stopchar) {
//Stmt8219:Leaf
break;

     }

//Stmt8241:Leaf
q = p;

//Stmt8242:Leaf
p = find_char_unquote(q, stopchars, 1);

//Stmt8243:Parent
if ((unsigned long )p == (unsigned long )((char *)0)) {
//Stmt8220:Leaf
tmp = strlen((char const   *)q);

//Stmt8221:Leaf
p = q + tmp;

     }

//Stmt8244:Parent
if (strip) {
//Stmt8235:Parent
while (1) {
//Stmt8232:Parent
if (p - q > 2L) {
//Stmt8225:Parent
if ((int )*(q + 0) == 46) {
//Stmt8223:Parent
if (! ((int )*(q + 1) == 47)) {
//Stmt8222:Leaf
break;

             }

           } else {
//Stmt8224:Leaf
break;

           }

         } else {
//Stmt8226:Leaf
break;

         }

//Stmt8233:Leaf
q += 2;

//Stmt8234:Parent
while (1) {
//Stmt8230:Parent
if ((unsigned long )q < (unsigned long )p) {
//Stmt8228:Parent
if (! ((int )*q == 47)) {
//Stmt8227:Leaf
break;

             }

           } else {
//Stmt8229:Leaf
break;

           }

//Stmt8231:Leaf
q ++;

         }

       }

     }

//Stmt8245:Parent
if ((unsigned long )q == (unsigned long )p) {
//Stmt8236:Leaf
name = savestring("./", 2U);

     } else {
//Stmt8237:Leaf
name = savestring((char const   *)q, (unsigned int )(p - q));

     }

//Stmt8246:Leaf
tmp___0 = xmalloc(size);

//Stmt8247:Leaf
new1 = (struct nameseq *)tmp___0;

//Stmt8248:Leaf
new1->name = name;

//Stmt8249:Leaf
new1->next = new;

//Stmt8250:Leaf
new = new1;

   }

//Stmt8331:Leaf
new1 = new;

//Stmt8332:Leaf
lastnew1 = (struct nameseq *)0;

//Stmt8333:Parent
while ((unsigned long )new1 != (unsigned long )((struct nameseq *)0)) {
//Stmt8309:Parent
if ((int )*(new1->name + 0) != 40) {
//Stmt8305:Leaf
tmp___2 = strlen((char const   *)new1->name);

//Stmt8306:Parent
if ((int )*(new1->name + (tmp___2 - 1UL)) == 41) {
//Stmt8301:Leaf
tmp___3 = strchr((char const   *)new1->name, '(');

//Stmt8302:Parent
if ((unsigned long )tmp___3 == (unsigned long )((char *)0)) {
//Stmt8294:Leaf
n = new1->next;

//Stmt8295:Leaf
lastn = new1;

//Stmt8296:Leaf
paren = (char *)0;

//Stmt8297:Parent
while (1) {
//Stmt8255:Parent
if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
//Stmt8252:Leaf
paren = strchr((char const   *)n->name, '(');

//Stmt8253:Parent
if (! ((unsigned long )paren == (unsigned long )((char *)0))) {
//Stmt8251:Leaf
break;

               }

             } else {
//Stmt8254:Leaf
break;

             }

//Stmt8256:Leaf
lastn = n;

//Stmt8257:Leaf
n = n->next;

           }

//Stmt8298:Parent
if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
//Stmt8291:Parent
if ((int )*(n->name + 0) != 40) {
//Stmt8281:Leaf
paren ++;

//Stmt8282:Leaf
tmp___1 = __builtin_alloca((unsigned long )((paren - n->name) + 1L));

//Stmt8283:Leaf
libname = (char *)tmp___1;

//Stmt8284:Leaf
memmove((void *)libname, (void const   *)n->name, (size_t )(paren - n->name));

//Stmt8285:Leaf
*(libname + (paren - n->name)) = (char )'\000';

//Stmt8286:Parent
if ((int )*paren == 0) {
//Stmt8258:Leaf
lastn->next = n->next;

//Stmt8259:Leaf
free((void *)n->name);

//Stmt8260:Leaf
free((void *)((char *)n));

//Stmt8261:Leaf
n = lastn->next;

               } else {
//Stmt8262:Leaf
name = concat(libname, paren, (char *)")");

//Stmt8263:Leaf
free((void *)n->name);

//Stmt8264:Leaf
n->name = name;

               }

//Stmt8287:Parent
if ((int )*(new1->name + 1) == 0) {
//Stmt8267:Parent
if ((unsigned long )lastnew1 == (unsigned long )((struct nameseq *)0)) {
//Stmt8265:Leaf
new = new1->next;

                 } else {
//Stmt8266:Leaf
lastnew1->next = new1->next;

                 }

//Stmt8268:Leaf
lastn = new1;

//Stmt8269:Leaf
new1 = new1->next;

//Stmt8270:Leaf
free((void *)lastn->name);

//Stmt8271:Leaf
free((void *)((char *)lastn));

               } else {
//Stmt8272:Leaf
name = concat(libname, new1->name, (char *)"");

//Stmt8273:Leaf
free((void *)new1->name);

//Stmt8274:Leaf
new1->name = name;

//Stmt8275:Leaf
new1 = new1->next;

               }

//Stmt8288:Parent
while ((unsigned long )new1 != (unsigned long )n) {
//Stmt8276:Leaf
name = concat(libname, new1->name, (char *)")");

//Stmt8277:Leaf
free((void *)new1->name);

//Stmt8278:Leaf
new1->name = name;

//Stmt8279:Leaf
lastnew1 = new1;

//Stmt8280:Leaf
new1 = new1->next;

               }

             } else {
//Stmt8289:Leaf
lastnew1 = new1;

//Stmt8290:Leaf
new1 = new1->next;

             }

           } else {
//Stmt8292:Leaf
lastnew1 = new1;

//Stmt8293:Leaf
new1 = new1->next;

           }

         } else {
//Stmt8299:Leaf
lastnew1 = new1;

//Stmt8300:Leaf
new1 = new1->next;

         }

       } else {
//Stmt8303:Leaf
lastnew1 = new1;

//Stmt8304:Leaf
new1 = new1->next;

       }

     } else {
//Stmt8307:Leaf
lastnew1 = new1;

//Stmt8308:Leaf
new1 = new1->next;

     }

   }

//Stmt8334:Leaf
*stringp = p;

//Stmt8335:Leaf
return (new);

 }
}
 static unsigned long readline(struct linebuffer *linebuffer , FILE *stream , struct floc  const  *flocp ) 
 { 
//Stmt8390:Leaf
char *buffer ;

//Stmt8391:Leaf
register char *p ;

//Stmt8392:Leaf
register char *end ;

//Stmt8393:Leaf
register int len ;

//Stmt8394:Leaf
register int lastlen ;

//Stmt8395:Leaf
register char *p2 ;

//Stmt8396:Leaf
register unsigned int nlines ;

//Stmt8397:Leaf
register int backslash ;

//Stmt8398:Leaf
size_t tmp ;

//Stmt8399:Leaf
char *tmp___0 ;

//Stmt8400:Leaf
register unsigned int p_off ;

//Stmt8401:Leaf
char *tmp___1 ;

//Stmt8402:Leaf
register unsigned int p_off___0 ;

//Stmt8403:Leaf
char *tmp___2 ;

//Stmt8404:Leaf
char *tmp___3 ;

//Stmt8405:Leaf
int tmp___4 ;

 
   {
//Stmt8406:Leaf
buffer = linebuffer->buffer;

//Stmt8407:Leaf
p = linebuffer->buffer;

//Stmt8408:Leaf
end = p + linebuffer->size;

//Stmt8409:Leaf
lastlen = 0;

//Stmt8410:Leaf
nlines = 0U;

//Stmt8411:Leaf
*p = (char )'\000';

//Stmt8412:Parent
while (1) {
//Stmt8373:Leaf
tmp___3 = fgets((char * __restrict  )p, (int )(end - p), (FILE * __restrict  )stream);

//Stmt8374:Parent
if (! ((unsigned long )tmp___3 != (unsigned long )((char *)0))) {
//Stmt8336:Leaf
break;

     }

//Stmt8375:Leaf
tmp = strlen((char const   *)p);

//Stmt8376:Leaf
len = (int )tmp;

//Stmt8377:Parent
if (len == 0) {
//Stmt8337:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "warning: NUL character seen; rest of line ignored",
                           5);

//Stmt8338:Leaf
error(flocp, (char const   *)tmp___0);

//Stmt8339:Leaf
*(p + 0) = (char )'\n';

//Stmt8340:Leaf
len = 1;

     }

//Stmt8378:Leaf
p += len;

//Stmt8379:Parent
if ((int )*(p + -1) != 10) {
//Stmt8341:Leaf
p_off = (unsigned int )(p - buffer);

//Stmt8342:Leaf
linebuffer->size *= 2U;

//Stmt8343:Leaf
tmp___1 = xrealloc(buffer, linebuffer->size);

//Stmt8344:Leaf
buffer = tmp___1;

//Stmt8345:Leaf
p = buffer + p_off;

//Stmt8346:Leaf
end = buffer + linebuffer->size;

//Stmt8347:Leaf
linebuffer->buffer = buffer;

//Stmt8348:Leaf
*p = (char )'\000';

//Stmt8349:Leaf
lastlen = len;

//Stmt8350:Leaf
continue;

     }

//Stmt8380:Leaf
nlines ++;

//Stmt8381:Parent
if (len > 1) {
//Stmt8354:Parent
if ((int )*(p + -2) == 13) {
//Stmt8351:Leaf
len --;

//Stmt8352:Leaf
p --;

//Stmt8353:Leaf
*(p + -1) = (char )'\n';

       }

     }

//Stmt8382:Parent
if (len == 1) {
//Stmt8356:Parent
if ((unsigned long )p > (unsigned long )buffer) {
//Stmt8355:Leaf
len += lastlen;

       }

     }

//Stmt8383:Leaf
lastlen = len;

//Stmt8384:Leaf
backslash = 0;

//Stmt8385:Leaf
p2 = p - 2;

//Stmt8386:Parent
while (1) {
//Stmt8360:Leaf
len --;

//Stmt8361:Parent
if (! (len > 0)) {
//Stmt8357:Leaf
break;

       }

//Stmt8362:Parent
if ((int )*p2 == 92) {
//Stmt8358:Leaf
backslash = ! backslash;

       } else {
//Stmt8359:Leaf
break;

       }

//Stmt8363:Leaf
p2 --;

     }

//Stmt8387:Parent
if (! backslash) {
//Stmt8364:Leaf
*(p + -1) = (char )'\000';

//Stmt8365:Leaf
break;

     }

//Stmt8388:Parent
if (end - p <= 1L) {
//Stmt8366:Leaf
p_off___0 = (unsigned int )(p - buffer);

//Stmt8367:Leaf
linebuffer->size *= 2U;

//Stmt8368:Leaf
tmp___2 = xrealloc(buffer, linebuffer->size);

//Stmt8369:Leaf
buffer = tmp___2;

//Stmt8370:Leaf
p = buffer + p_off___0;

//Stmt8371:Leaf
end = buffer + linebuffer->size;

//Stmt8372:Leaf
linebuffer->buffer = buffer;

     }

   }

//Stmt8413:Leaf
tmp___4 = ferror(stream);

//Stmt8414:Parent
if (tmp___4) {
//Stmt8389:Leaf
pfatal_with_name((char *)flocp->filenm);

   }

//Stmt8415:Leaf
return ((unsigned long )nlines);

 }
}
 static enum make_word_type get_next_mword(char *buffer , char *delim , char **startp ,
                                           unsigned int *length___0 ) 
 { 
//Stmt8478:Leaf
enum make_word_type wtype ;

//Stmt8479:Leaf
char *p ;

//Stmt8480:Leaf
char *beg ;

//Stmt8481:Leaf
char c ;

//Stmt8482:Leaf
unsigned short const   **tmp ;

//Stmt8483:Leaf
char *tmp___0 ;

//Stmt8484:Leaf
char *tmp___1 ;

//Stmt8485:Leaf
char closeparen ;

//Stmt8486:Leaf
int count ;

//Stmt8487:Leaf
char *tmp___2 ;

//Stmt8488:Leaf
char *tmp___3 ;

//Stmt8489:Leaf
char *tmp___4 ;

 
   {
//Stmt8490:Leaf
wtype = (enum make_word_type )0;

//Stmt8491:Leaf
p = buffer;

//Stmt8492:Parent
while (1) {
//Stmt8417:Leaf
tmp = __ctype_b_loc();

//Stmt8418:Parent
if (! ((int const   )*(*tmp + (int )*p) & 1)) {
//Stmt8416:Leaf
break;

     }

//Stmt8419:Leaf
p ++;

   }

//Stmt8493:Leaf
beg = p;

//Stmt8494:Leaf
tmp___0 = p;

//Stmt8495:Leaf
p ++;

//Stmt8496:Leaf
c = *tmp___0;

//Stmt8497:Parent
switch ((int )c) {
   case 0:; 
//Stmt8420:Leaf
wtype = (enum make_word_type )1;

   break;
   case 35:; 
//Stmt8421:Leaf
wtype = (enum make_word_type )7;

   break;
   case 59:; 
//Stmt8422:Leaf
wtype = (enum make_word_type )6;

   break;
   case 61:; 
//Stmt8423:Leaf
wtype = (enum make_word_type )8;

   break;
   case 58:; 
//Stmt8424:Leaf
wtype = (enum make_word_type )4;

//Stmt8437:Parent
switch ((int )*p) {
   case 58:; 
//Stmt8425:Leaf
p ++;

//Stmt8427:Leaf
wtype = (enum make_word_type )5;

   break;
   case 61:; 
//Stmt8426:Leaf
p ++;

//Stmt8428:Leaf
wtype = (enum make_word_type )8;

   break;
   }

   break;
   case 63:; 
   case 43:; 
//Stmt8432:Parent
if ((int )*p == 61) {
//Stmt8429:Leaf
p ++;

//Stmt8430:Leaf
wtype = (enum make_word_type )8;

//Stmt8431:Leaf
break;

   }

   default:; 
//Stmt8436:Parent
if (delim) {
//Stmt8434:Leaf
tmp___1 = strchr((char const   *)delim, (int )c);

//Stmt8435:Parent
if (tmp___1) {
//Stmt8433:Leaf
wtype = (enum make_word_type )2;

     }

   }

   break;
   }

//Stmt8498:Parent
if ((unsigned int )wtype != 0U) {
//Stmt8438:Leaf
goto done;

   }

//Stmt8499:Leaf
wtype = (enum make_word_type )2;

//Stmt8500:Parent
while (1) {
//Stmt8470:Parent
switch ((int )c) {
     case 35:; 
     case 61:; 
     case 9:; 
     case 32:; 
     case 0:; 
//Stmt8439:Leaf
goto done_word;

     case 58:; 
//Stmt8440:Leaf
goto done_word;

     case 36:; 
//Stmt8441:Leaf
tmp___2 = p;

//Stmt8463:Leaf
p ++;

//Stmt8464:Leaf
c = *tmp___2;

//Stmt8465:Parent
if ((int )c == 36) {
//Stmt8442:Leaf
break;

     }

//Stmt8466:Leaf
wtype = (enum make_word_type )3;

//Stmt8467:Parent
if ((int )c == 40) {
//Stmt8445:Leaf
closeparen = (char )')';

     } else
     {
//Stmt8446:Parent
if ((int )c == 123) {
//Stmt8443:Leaf
closeparen = (char )'}';

     } else {
//Stmt8444:Leaf
break;

     }
}


//Stmt8468:Leaf
count = 0;

//Stmt8469:Parent
while ((int )*p != 0) {
//Stmt8453:Parent
if ((int )*p == (int )c) {
//Stmt8451:Leaf
count ++;

       } else
       {
//Stmt8452:Parent
if ((int )*p == (int )closeparen) {
//Stmt8449:Leaf
count --;

//Stmt8450:Parent
if (count < 0) {
//Stmt8447:Leaf
p ++;

//Stmt8448:Leaf
break;

         }

       }
}


//Stmt8454:Leaf
p ++;

     }

     break;
     case 43:; 
     case 63:; 
//Stmt8456:Parent
if ((int )*p == 61) {
//Stmt8455:Leaf
goto done_word;

     }

     break;
     case 92:; 
//Stmt8458:Parent
switch ((int )*p) {
     case 92:; 
     case 61:; 
     case 59:; 
     case 58:; 
//Stmt8457:Leaf
p ++;

     break;
     }

     break;
     default:; 
//Stmt8462:Parent
if (delim) {
//Stmt8460:Leaf
tmp___3 = strchr((char const   *)delim, (int )c);

//Stmt8461:Parent
if (tmp___3) {
//Stmt8459:Leaf
goto done_word;

       }

     }

     break;
     }

//Stmt8471:Leaf
tmp___4 = p;

//Stmt8472:Leaf
p ++;

//Stmt8473:Leaf
c = *tmp___4;

   }

   done_word: 
   {
//Stmt8474:Leaf
p --;

}
   done: 
   {
//Stmt8476:Parent
if (startp) {
//Stmt8475:Leaf
*startp = beg;

   }
}

//Stmt8501:Parent
if (length___0) {
//Stmt8477:Leaf
*length___0 = (unsigned int )(p - beg);

   }

//Stmt8502:Leaf
return (wtype);

 }
}
 void construct_include_path(char **arg_dirs ) 
 { 
//Stmt8539:Leaf
register unsigned int i ;

//Stmt8540:Leaf
struct stat stbuf ;

//Stmt8541:Leaf
register unsigned int defsize ;

//Stmt8542:Leaf
register unsigned int max ;

//Stmt8543:Leaf
register char **dirs___0 ;

//Stmt8544:Leaf
char *tmp ;

//Stmt8545:Leaf
register unsigned int idx ;

//Stmt8546:Leaf
char *dir ;

//Stmt8547:Leaf
char **tmp___0 ;

//Stmt8548:Leaf
char *expanded ;

//Stmt8549:Leaf
char *tmp___1 ;

//Stmt8550:Leaf
char *tmp___2 ;

//Stmt8551:Leaf
unsigned int tmp___3 ;

//Stmt8552:Leaf
int tmp___4 ;

//Stmt8553:Leaf
unsigned int tmp___5 ;

//Stmt8554:Leaf
int tmp___6 ;

//Stmt8555:Leaf
unsigned int len ;

//Stmt8556:Leaf
size_t tmp___7 ;

 
   {
//Stmt8557:Leaf
defsize = (unsigned int )(sizeof(default_include_directories) / sizeof(default_include_directories[0]));

//Stmt8558:Leaf
max = 5U;

//Stmt8559:Leaf
tmp = xmalloc((unsigned int )((unsigned long )(5U + defsize) * sizeof(char *)));

//Stmt8560:Leaf
dirs___0 = (char **)tmp;

//Stmt8561:Leaf
idx = 0U;

//Stmt8562:Parent
if ((unsigned long )arg_dirs != (unsigned long )((char **)0)) {
//Stmt8524:Parent
while ((unsigned long )*arg_dirs != (unsigned long )((char *)0)) {
//Stmt8518:Leaf
tmp___0 = arg_dirs;

//Stmt8519:Leaf
arg_dirs ++;

//Stmt8520:Leaf
dir = *tmp___0;

//Stmt8521:Parent
if ((int )*(dir + 0) == 126) {
//Stmt8504:Leaf
tmp___1 = tilde_expand(dir);

//Stmt8505:Leaf
expanded = tmp___1;

//Stmt8506:Parent
if ((unsigned long )expanded != (unsigned long )((char *)0)) {
//Stmt8503:Leaf
dir = expanded;

         }

       }

//Stmt8522:Leaf
tmp___4 = stat((char const   * __restrict  )dir, (struct stat * __restrict  )(& stbuf));

//Stmt8523:Parent
if (tmp___4 == 0) {
//Stmt8517:Parent
if ((stbuf.st_mode & 61440U) == 16384U) {
//Stmt8510:Parent
if (idx == max - 1U) {
//Stmt8507:Leaf
max += 5U;

//Stmt8508:Leaf
tmp___2 = xrealloc((char *)dirs___0, (unsigned int )((unsigned long )(max + defsize) * sizeof(char *)));

//Stmt8509:Leaf
dirs___0 = (char **)tmp___2;

           }

//Stmt8511:Leaf
tmp___3 = idx;

//Stmt8512:Leaf
idx ++;

//Stmt8513:Leaf
*(dirs___0 + tmp___3) = dir;

         } else {
//Stmt8514:Leaf
goto _L;

         }

       } else
       _L: /* CIL Label */ 
       {
//Stmt8516:Parent
if ((unsigned long )dir != (unsigned long )*(arg_dirs + -1)) {
//Stmt8515:Leaf
free((void *)dir);

       }
}


     }

   }

//Stmt8563:Leaf
i = 0U;

//Stmt8564:Parent
while ((unsigned long )default_include_directories[i] != (unsigned long )((char *)0)) {
//Stmt8529:Leaf
tmp___6 = stat((char const   * __restrict  )default_include_directories[i], (struct stat * __restrict  )(& stbuf));

//Stmt8530:Parent
if (tmp___6 == 0) {
//Stmt8528:Parent
if ((stbuf.st_mode & 61440U) == 16384U) {
//Stmt8525:Leaf
tmp___5 = idx;

//Stmt8526:Leaf
idx ++;

//Stmt8527:Leaf
*(dirs___0 + tmp___5) = default_include_directories[i];

       }

     }

//Stmt8531:Leaf
i ++;

   }

//Stmt8565:Leaf
*(dirs___0 + idx) = (char *)0;

//Stmt8566:Leaf
max_incl_len = 0U;

//Stmt8567:Leaf
i = 0U;

//Stmt8568:Parent
while (i < idx) {
//Stmt8534:Leaf
tmp___7 = strlen((char const   *)*(dirs___0 + i));

//Stmt8535:Leaf
len = (unsigned int )tmp___7;

//Stmt8536:Parent
if ((int )*(*(dirs___0 + i) + (len - 1U)) == 47) {
//Stmt8532:Leaf
*(dirs___0 + i) = savestring((char const   *)*(dirs___0 + i), len - 1U);

     }

//Stmt8537:Parent
if (len > max_incl_len) {
//Stmt8533:Leaf
max_incl_len = len;

     }

//Stmt8538:Leaf
i ++;

   }

//Stmt8569:Leaf
include_directories___0 = dirs___0;

//Stmt8570:Leaf
return;

 }
}
 char *tilde_expand(char *name ) 
 { 
//Stmt8611:Leaf
char *home_dir ;

//Stmt8612:Leaf
int is_variable ;

//Stmt8613:Leaf
int save ;

//Stmt8614:Leaf
char *logname ;

//Stmt8615:Leaf
char *tmp ;

//Stmt8616:Leaf
struct passwd *p ;

//Stmt8617:Leaf
struct passwd *tmp___0 ;

//Stmt8618:Leaf
char *new ;

//Stmt8619:Leaf
char *tmp___1 ;

//Stmt8620:Leaf
struct passwd *pwent ;

//Stmt8621:Leaf
char *userend ;

//Stmt8622:Leaf
char *tmp___2 ;

//Stmt8623:Leaf
char *tmp___3 ;

//Stmt8624:Leaf
char *tmp___4 ;

 
   {
//Stmt8625:Parent
if ((int )*(name + 1) == 47) {
//Stmt8609:Leaf
goto _L___0;

   } else
   {
//Stmt8610:Parent
if ((int )*(name + 1) == 0) {
     _L___0: /* CIL Label */ 
     {
//Stmt8571:Leaf
save = warn_undefined_variables_flag;

}
//Stmt8597:Leaf
warn_undefined_variables_flag = 0;

//Stmt8598:Leaf
home_dir = allocated_variable_expand_for_file((char *)"$(HOME)", (struct file *)0);

//Stmt8599:Leaf
warn_undefined_variables_flag = save;

//Stmt8600:Leaf
is_variable = (int )*(home_dir + 0) != 0;

//Stmt8601:Parent
if (! is_variable) {
//Stmt8572:Leaf
free((void *)home_dir);

//Stmt8573:Leaf
home_dir = getenv("HOME");

     }

//Stmt8602:Parent
if ((unsigned long )home_dir == (unsigned long )((char *)0)) {
//Stmt8582:Leaf
goto _L;

     } else
     {
//Stmt8583:Parent
if ((int )*(home_dir + 0) == 0) {
       _L: /* CIL Label */ 
       {
//Stmt8574:Leaf
tmp = getlogin();

}
//Stmt8579:Leaf
logname = tmp;

//Stmt8580:Leaf
home_dir = (char *)0;

//Stmt8581:Parent
if ((unsigned long )logname != (unsigned long )((char *)0)) {
//Stmt8576:Leaf
tmp___0 = getpwnam((char const   *)logname);

//Stmt8577:Leaf
p = tmp___0;

//Stmt8578:Parent
if ((unsigned long )p != (unsigned long )((struct passwd *)0)) {
//Stmt8575:Leaf
home_dir = p->pw_dir;

         }

       }

     }
}


//Stmt8603:Parent
if ((unsigned long )home_dir != (unsigned long )((char *)0)) {
//Stmt8585:Leaf
tmp___1 = concat(home_dir, (char *)"", name + 1);

//Stmt8586:Leaf
new = tmp___1;

//Stmt8587:Parent
if (is_variable) {
//Stmt8584:Leaf
free((void *)home_dir);

       }

//Stmt8588:Leaf
return (new);

     }

   } else {
//Stmt8604:Leaf
tmp___2 = strchr((char const   *)(name + 1), '/');

//Stmt8605:Leaf
userend = tmp___2;

//Stmt8606:Parent
if ((unsigned long )userend != (unsigned long )((char *)0)) {
//Stmt8589:Leaf
*userend = (char )'\000';

     }

//Stmt8607:Leaf
pwent = getpwnam((char const   *)(name + 1));

//Stmt8608:Parent
if ((unsigned long )pwent != (unsigned long )((struct passwd *)0)) {
//Stmt8595:Parent
if ((unsigned long )userend == (unsigned long )((char *)0)) {
//Stmt8590:Leaf
tmp___3 = xstrdup((char const   *)pwent->pw_dir);

//Stmt8591:Leaf
return (tmp___3);

       } else {
//Stmt8592:Leaf
tmp___4 = concat(pwent->pw_dir, (char *)"/", userend + 1);

//Stmt8593:Leaf
return (tmp___4);

       }

     } else
     {
//Stmt8596:Parent
if ((unsigned long )userend != (unsigned long )((char *)0)) {
//Stmt8594:Leaf
*userend = (char )'/';

     }
}


   }
}


//Stmt8626:Leaf
return ((char *)0);

 }
}
 struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) 
 { 
//Stmt8686:Leaf
register struct nameseq *new ;

//Stmt8687:Leaf
register struct nameseq *old ;

//Stmt8688:Leaf
struct nameseq *nexto ;

//Stmt8689:Leaf
glob_t gl ;

//Stmt8690:Leaf
char *memname ;

//Stmt8691:Leaf
char *newname ;

//Stmt8692:Leaf
char *tmp ;

//Stmt8693:Leaf
char *arname ;

//Stmt8694:Leaf
int tmp___0 ;

//Stmt8695:Leaf
int tmp___1 ;

//Stmt8696:Leaf
register int i ;

//Stmt8697:Leaf
struct nameseq *found ;

//Stmt8698:Leaf
struct nameseq *tmp___2 ;

//Stmt8699:Leaf
struct nameseq *elt ;

//Stmt8700:Leaf
char *tmp___3 ;

//Stmt8701:Leaf
unsigned int alen ;

//Stmt8702:Leaf
size_t tmp___4 ;

//Stmt8703:Leaf
unsigned int mlen ;

//Stmt8704:Leaf
size_t tmp___5 ;

//Stmt8705:Leaf
char *tmp___6 ;

//Stmt8706:Leaf
struct nameseq *f ;

//Stmt8707:Leaf
struct nameseq *elt___0 ;

//Stmt8708:Leaf
char *tmp___7 ;

//Stmt8709:Leaf
int tmp___8 ;

//Stmt8710:Leaf
char *tmp___9 ;

 
   {
//Stmt8711:Leaf
new = (struct nameseq *)0;

//Stmt8712:Leaf
dir_setup_glob(& gl);

//Stmt8713:Leaf
old = chain;

//Stmt8714:Parent
while ((unsigned long )old != (unsigned long )((struct nameseq *)0)) {
//Stmt8679:Leaf
nexto = old->next;

//Stmt8680:Parent
if ((int )*(old->name + 0) == 126) {
//Stmt8629:Leaf
tmp = tilde_expand(old->name);

//Stmt8630:Leaf
newname = tmp;

//Stmt8631:Parent
if ((unsigned long )newname != (unsigned long )((char *)0)) {
//Stmt8627:Leaf
free((void *)old->name);

//Stmt8628:Leaf
old->name = newname;

       }

     }

//Stmt8681:Leaf
tmp___0 = ar_name(old->name);

//Stmt8682:Parent
if (tmp___0) {
//Stmt8632:Leaf
ar_parse_name(old->name, & arname, & memname);

//Stmt8633:Leaf
free((void *)old->name);

//Stmt8634:Leaf
old->name = arname;

     } else {
//Stmt8635:Leaf
memname = (char *)0;

     }

//Stmt8683:Leaf
tmp___1 = glob((char const   *)old->name, (1 << 4) | (1 << 9), (int (*)(char const   * ,
                                                                             int  ))((void *)0),
                    & gl);

//Stmt8684:Parent
switch (tmp___1) {
     case 0:; 
//Stmt8636:Leaf
i = (int )gl.gl_pathc;

//Stmt8673:Parent
while (1) {
//Stmt8667:Leaf
tmp___8 = i;

//Stmt8668:Leaf
i --;

//Stmt8669:Parent
if (! (tmp___8 > 0)) {
//Stmt8637:Leaf
break;

       }

//Stmt8670:Parent
if ((unsigned long )memname != (unsigned long )((char *)0)) {
//Stmt8658:Leaf
tmp___2 = ar_glob(*(gl.gl_pathv + i), memname, size);

//Stmt8659:Leaf
found = tmp___2;

//Stmt8660:Parent
if ((unsigned long )found == (unsigned long )((struct nameseq *)0)) {
//Stmt8639:Leaf
tmp___3 = xmalloc(size);

//Stmt8640:Leaf
elt = (struct nameseq *)tmp___3;

//Stmt8641:Leaf
tmp___4 = strlen((char const   *)*(gl.gl_pathv + i));

//Stmt8642:Leaf
alen = (unsigned int )tmp___4;

//Stmt8643:Leaf
tmp___5 = strlen((char const   *)memname);

//Stmt8644:Leaf
mlen = (unsigned int )tmp___5;

//Stmt8645:Leaf
tmp___6 = xmalloc(((alen + 1U) + mlen) + 2U);

//Stmt8646:Leaf
elt->name = tmp___6;

//Stmt8647:Leaf
memmove((void *)elt->name, (void const   *)*(gl.gl_pathv + i), (size_t )alen);

//Stmt8648:Leaf
*(elt->name + alen) = (char )'(';

//Stmt8649:Leaf
memmove((void *)(elt->name + (alen + 1U)), (void const   *)memname, (size_t )mlen);

//Stmt8650:Leaf
*(elt->name + ((alen + 1U) + mlen)) = (char )')';

//Stmt8651:Leaf
*(elt->name + (((alen + 1U) + mlen) + 1U)) = (char )'\000';

//Stmt8652:Leaf
elt->next = new;

//Stmt8653:Leaf
new = elt;

         } else {
//Stmt8654:Leaf
f = found;

//Stmt8655:Parent
while ((unsigned long )f->next != (unsigned long )((struct nameseq *)0)) {
//Stmt8638:Leaf
f = f->next;

           }

//Stmt8656:Leaf
f->next = new;

//Stmt8657:Leaf
new = found;

         }

//Stmt8661:Leaf
free((void *)memname);

       } else {
//Stmt8662:Leaf
tmp___7 = xmalloc(size);

//Stmt8663:Leaf
elt___0 = (struct nameseq *)tmp___7;

//Stmt8664:Leaf
elt___0->name = xstrdup((char const   *)*(gl.gl_pathv + i));

//Stmt8665:Leaf
elt___0->next = new;

//Stmt8666:Leaf
new = elt___0;

       }

     }

//Stmt8674:Leaf
globfree(& gl);

//Stmt8675:Leaf
free((void *)old->name);

//Stmt8676:Leaf
free((void *)((char *)old));

     break;
     case 1:; 
//Stmt8671:Leaf
tmp___9 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);

//Stmt8677:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___9);

     break;
     default:; 
//Stmt8672:Leaf
old->next = new;

//Stmt8678:Leaf
new = old;

     break;
     }

//Stmt8685:Leaf
old = nexto;

   }

//Stmt8715:Leaf
return (new);

 }
}
 #pragma merger("0","/tmp/cil-iRzmYf7g.i","-g,-O0")
 int gpath_search(char *file , int len ) ;
 unsigned int commands_started  =    0U;
 static int update_file(struct file *file , unsigned int depth ) ;
 static int update_file_1(struct file *file , unsigned int depth ) ;
 static int check_dep(struct file *file , unsigned int depth , uintmax_t this_mtime ,
                      int *must_make_ptr ) ;
 static int touch_file(struct file *file ) ;
 static void remake_file(struct file *file ) ;
 static uintmax_t name_mtime(char *name ) ;
 static int library_search(char **lib , uintmax_t *mtime_ptr ) ;
 int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) 
 { 
//Stmt8826:Leaf
int t ;

//Stmt8827:Leaf
int q ;

//Stmt8828:Leaf
int n ;

//Stmt8829:Leaf
unsigned int j ;

//Stmt8830:Leaf
int status ;

//Stmt8831:Leaf
struct dep *g ;

//Stmt8832:Leaf
register struct dep *g___0 ;

//Stmt8833:Leaf
register struct dep *lastgoal___0 ;

//Stmt8834:Leaf
struct file *file ;

//Stmt8835:Leaf
int stop ;

//Stmt8836:Leaf
int any_not_updated ;

//Stmt8837:Leaf
unsigned int ocommands_started ;

//Stmt8838:Leaf
int x ;

//Stmt8839:Leaf
int tmp ;

//Stmt8840:Leaf
int tmp___0 ;

//Stmt8841:Leaf
uintmax_t mtime ;

//Stmt8842:Leaf
uintmax_t tmp___1 ;

//Stmt8843:Leaf
uintmax_t tmp___2 ;

//Stmt8844:Leaf
uintmax_t tmp___3 ;

//Stmt8845:Leaf
uintmax_t tmp___4 ;

//Stmt8846:Leaf
uintmax_t tmp___5 ;

//Stmt8847:Leaf
char *tmp___6 ;

//Stmt8848:Leaf
char *tmp___7 ;

//Stmt8849:Leaf
char *tmp___8 ;

 
   {
//Stmt8850:Leaf
t = touch_flag;

//Stmt8851:Leaf
q = question_flag;

//Stmt8852:Leaf
n = just_print_flag;

//Stmt8853:Leaf
j = job_slots;

//Stmt8854:Leaf
status = -1;

//Stmt8855:Leaf
goals___0 = copy_dep_chain(goals___0);

//Stmt8856:Leaf
g = goals___0;

//Stmt8857:Parent
while ((unsigned long )g != (unsigned long )((struct dep *)0)) {
//Stmt8716:Leaf
g->changed = 0;

//Stmt8717:Leaf
g = g->next;

   }

//Stmt8858:Leaf
considered = 1U;

//Stmt8859:Parent
while ((unsigned long )goals___0 != (unsigned long )((struct dep *)0)) {
//Stmt8816:Leaf
start_waiting_jobs();

//Stmt8817:Leaf
reap_children(1, 0);

//Stmt8818:Leaf
lastgoal___0 = (struct dep *)0;

//Stmt8819:Leaf
g___0 = goals___0;

//Stmt8820:Parent
while ((unsigned long )g___0 != (unsigned long )((struct dep *)0)) {
//Stmt8809:Leaf
stop = 0;

//Stmt8810:Leaf
any_not_updated = 0;

//Stmt8811:Parent
if ((g___0->file)->double_colon) {
//Stmt8718:Leaf
file = (g___0->file)->double_colon;

       } else {
//Stmt8719:Leaf
file = g___0->file;

       }

//Stmt8812:Parent
while ((unsigned long )file != (unsigned long )((void *)0)) {
//Stmt8770:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt8720:Leaf
file = file->renamed;

         }

//Stmt8771:Parent
if (makefiles___0) {
//Stmt8727:Parent
if (file->cmd_target) {
//Stmt8721:Leaf
touch_flag = t;

//Stmt8722:Leaf
question_flag = q;

//Stmt8723:Leaf
just_print_flag = n;

           } else {
//Stmt8724:Leaf
just_print_flag = 0;

//Stmt8725:Leaf
question_flag = just_print_flag;

//Stmt8726:Leaf
touch_flag = question_flag;

           }

         }

//Stmt8772:Leaf
ocommands_started = commands_started;

//Stmt8773:Parent
if (makefiles___0) {
//Stmt8728:Leaf
tmp = 1;

         } else {
//Stmt8729:Leaf
tmp = 0;

         }

//Stmt8774:Leaf
x = update_file(file, (unsigned int )tmp);

//Stmt8775:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt8730:Leaf
file = file->renamed;

         }

//Stmt8776:Leaf
g___0->changed = (int )((unsigned int )g___0->changed + (commands_started - ocommands_started));

//Stmt8777:Leaf
stop = 0;

//Stmt8778:Parent
if (x != 0) {
//Stmt8767:Leaf
goto _L;

         } else
         {
//Stmt8768:Parent
if (file->updated) {
           _L: /* CIL Label */ 
           {
//Stmt8766:Parent
if (status < 1) {
//Stmt8765:Parent
if ((int )file->update_status != 0) {
//Stmt8758:Leaf
status = (int )file->update_status;

//Stmt8759:Parent
if (! keep_going_flag) {
//Stmt8735:Parent
if (! question_flag) {
//Stmt8733:Parent
if (! makefiles___0) {
//Stmt8731:Leaf
tmp___0 = 1;

                   } else {
//Stmt8732:Leaf
tmp___0 = 0;

                   }

                 } else {
//Stmt8734:Leaf
tmp___0 = 0;

                 }

               } else {
//Stmt8736:Leaf
tmp___0 = 0;

               }

//Stmt8760:Leaf
stop = tmp___0;

             } else {
//Stmt8761:Parent
if (makefiles___0) {
//Stmt8743:Parent
if (file->last_mtime) {
//Stmt8737:Leaf
tmp___2 = file->last_mtime;

                 } else {
//Stmt8738:Leaf
tmp___1 = f_mtime(file, 0);

//Stmt8739:Leaf
tmp___2 = tmp___1;

                 }

//Stmt8744:Leaf
tmp___5 = tmp___2;

               } else {
//Stmt8745:Parent
if (file->last_mtime) {
//Stmt8740:Leaf
tmp___4 = file->last_mtime;

                 } else {
//Stmt8741:Leaf
tmp___3 = f_mtime(file, 1);

//Stmt8742:Leaf
tmp___4 = tmp___3;

                 }

//Stmt8746:Leaf
tmp___5 = tmp___4;

               }

//Stmt8762:Leaf
mtime = tmp___5;

//Stmt8763:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt8747:Leaf
file = file->renamed;

               }

//Stmt8764:Parent
if (file->updated) {
//Stmt8757:Parent
if (g___0->changed) {
//Stmt8756:Parent
if (mtime != file->mtime_before_update) {
//Stmt8754:Parent
if (! makefiles___0) {
//Stmt8750:Leaf
status = 0;

                     } else
                     {
//Stmt8751:Parent
if (! just_print_flag) {
//Stmt8749:Parent
if (! question_flag) {
//Stmt8748:Leaf
status = 0;

                       }

                     }
}


//Stmt8755:Parent
if (makefiles___0) {
//Stmt8753:Parent
if (file->dontcare) {
//Stmt8752:Leaf
stop = 1;

                       }

                     }

                   }

                 }

               }

             }

           }
}

         }
}


//Stmt8779:Leaf
any_not_updated |= ! file->updated;

//Stmt8780:Parent
if (stop) {
//Stmt8769:Leaf
break;

         }

//Stmt8781:Leaf
file = file->prev;

       }

//Stmt8813:Leaf
file = g___0->file;

//Stmt8814:Parent
if (stop) {
//Stmt8807:Leaf
goto _L___0;

       } else
       {
//Stmt8808:Parent
if (! any_not_updated) {
         _L___0: /* CIL Label */ 
         {
//Stmt8795:Parent
if (! makefiles___0) {
//Stmt8794:Parent
if ((int )file->update_status == 0) {
//Stmt8793:Parent
if (! g___0->changed) {
//Stmt8792:Parent
if (! silent_flag) {
//Stmt8791:Parent
if (! question_flag) {
//Stmt8789:Parent
if (file->phony) {
//Stmt8786:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "Nothing to be done for `%s\'.",
                                         5);

//Stmt8787:Leaf
tmp___8 = tmp___6;

                   } else
                   {
//Stmt8788:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt8782:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "Nothing to be done for `%s\'.",
                                         5);

//Stmt8783:Leaf
tmp___8 = tmp___6;

                   } else {
//Stmt8784:Leaf
tmp___7 = dcgettext((char const   *)((void *)0), "`%s\' is up to date.",
                                         5);

//Stmt8785:Leaf
tmp___8 = tmp___7;

                   }
}


//Stmt8790:Leaf
message(1, (char const   *)tmp___8, file->name);

                 }

               }

             }

           }

         }
}

//Stmt8801:Parent
if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
//Stmt8796:Leaf
goals___0 = g___0->next;

         } else {
//Stmt8797:Leaf
lastgoal___0->next = g___0->next;

         }

//Stmt8802:Leaf
free((void *)((char *)g___0));

//Stmt8803:Parent
if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
//Stmt8798:Leaf
g___0 = goals___0;

         } else {
//Stmt8799:Leaf
g___0 = lastgoal___0->next;

         }

//Stmt8804:Parent
if (stop) {
//Stmt8800:Leaf
break;

         }

       } else {
//Stmt8805:Leaf
lastgoal___0 = g___0;

//Stmt8806:Leaf
g___0 = g___0->next;

       }
}


     }

//Stmt8821:Parent
if ((unsigned long )g___0 == (unsigned long )((struct dep *)0)) {
//Stmt8815:Leaf
considered = (unsigned int )(! considered);

     }

   }

//Stmt8860:Parent
if (makefiles___0) {
//Stmt8822:Leaf
touch_flag = t;

//Stmt8823:Leaf
question_flag = q;

//Stmt8824:Leaf
just_print_flag = n;

//Stmt8825:Leaf
job_slots = j;

   }

//Stmt8861:Leaf
return (status);

 }
}
 static int update_file(struct file *file , unsigned int depth ) 
 { 
//Stmt8897:Leaf
register int status ;

//Stmt8898:Leaf
register struct file *f ;

//Stmt8899:Leaf
char *tmp ;

//Stmt8900:Leaf
int tmp___0 ;

//Stmt8901:Leaf
int tmp___1 ;

//Stmt8902:Leaf
struct dep *d ;

//Stmt8903:Leaf
int tmp___2 ;

 
   {
//Stmt8904:Leaf
status = 0;

//Stmt8905:Parent
if (file->double_colon) {
//Stmt8862:Leaf
f = file->double_colon;

   } else {
//Stmt8863:Leaf
f = file;

   }

//Stmt8906:Parent
if (f->considered == considered) {
//Stmt8872:Parent
while (1) {
//Stmt8868:Parent
if (2 & db_level) {
//Stmt8864:Leaf
print_spaces(depth);

//Stmt8865:Leaf
tmp = dcgettext((char const   *)((void *)0), "Pruning file `%s\'.\n", 5);

//Stmt8866:Leaf
printf((char const   * __restrict  )tmp, file->name);

//Stmt8867:Leaf
fflush(stdout);

       }

//Stmt8869:Leaf
break;

     }

//Stmt8873:Parent
if ((unsigned int )f->command_state == 3U) {
//Stmt8870:Leaf
tmp___0 = (int )f->update_status;

     } else {
//Stmt8871:Leaf
tmp___0 = 0;

     }

//Stmt8874:Leaf
return (tmp___0);

   }

//Stmt8907:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt8883:Leaf
f->considered = considered;

//Stmt8884:Leaf
tmp___1 = update_file_1(f, depth);

//Stmt8885:Leaf
status |= tmp___1;

//Stmt8886:Parent
while ((unsigned long )f->renamed != (unsigned long )((struct file *)0)) {
//Stmt8875:Leaf
f = f->renamed;

     }

//Stmt8887:Parent
if (status != 0) {
//Stmt8877:Parent
if (! keep_going_flag) {
//Stmt8876:Leaf
break;

       }

     }

//Stmt8888:Parent
if ((unsigned int )f->command_state == 2U) {
//Stmt8880:Leaf
status = 0;

//Stmt8881:Leaf
break;

     } else
     {
//Stmt8882:Parent
if ((unsigned int )f->command_state == 1U) {
//Stmt8878:Leaf
status = 0;

//Stmt8879:Leaf
break;

     }
}


//Stmt8889:Leaf
f = f->prev;

   }

//Stmt8908:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt8893:Leaf
f->considered = considered;

//Stmt8894:Leaf
d = f->deps;

//Stmt8895:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt8890:Leaf
tmp___2 = update_file(d->file, depth + 1U);

//Stmt8891:Leaf
status |= tmp___2;

//Stmt8892:Leaf
d = d->next;

     }

//Stmt8896:Leaf
f = f->prev;

   }

//Stmt8909:Leaf
return (status);

 }
}
 static int update_file_1(struct file *file , unsigned int depth ) 
 { 
//Stmt9254:Leaf
register uintmax_t this_mtime ;

//Stmt9255:Leaf
int noexist ;

//Stmt9256:Leaf
int must_make ;

//Stmt9257:Leaf
int deps_changed ;

//Stmt9258:Leaf
int dep_status ;

//Stmt9259:Leaf
register struct dep *d ;

//Stmt9260:Leaf
register struct dep *lastd ;

//Stmt9261:Leaf
int running ;

//Stmt9262:Leaf
char *tmp ;

//Stmt9263:Leaf
char *tmp___0 ;

//Stmt9264:Leaf
char *tmp___1 ;

//Stmt9265:Leaf
char *tmp___2 ;

//Stmt9266:Leaf
char *tmp___3 ;

//Stmt9267:Leaf
struct file *tmp___4 ;

//Stmt9268:Leaf
uintmax_t tmp___5 ;

//Stmt9269:Leaf
char *tmp___6 ;

//Stmt9270:Leaf
char *tmp___7 ;

//Stmt9271:Leaf
char *tmp___8 ;

//Stmt9272:Leaf
int tmp___9 ;

//Stmt9273:Leaf
char *tmp___10 ;

//Stmt9274:Leaf
uintmax_t mtime ;

//Stmt9275:Leaf
uintmax_t tmp___11 ;

//Stmt9276:Leaf
char *tmp___12 ;

//Stmt9277:Leaf
struct file *tmp___13 ;

//Stmt9278:Leaf
int tmp___14 ;

//Stmt9279:Leaf
register struct file *f ;

//Stmt9280:Leaf
int tmp___15 ;

//Stmt9281:Leaf
uintmax_t tmp___16 ;

//Stmt9282:Leaf
uintmax_t tmp___17 ;

//Stmt9283:Leaf
uintmax_t mtime___0 ;

//Stmt9284:Leaf
uintmax_t tmp___18 ;

//Stmt9285:Leaf
uintmax_t tmp___19 ;

//Stmt9286:Leaf
int tmp___20 ;

//Stmt9287:Leaf
register struct file *f___0 ;

//Stmt9288:Leaf
int tmp___21 ;

//Stmt9289:Leaf
uintmax_t tmp___22 ;

//Stmt9290:Leaf
uintmax_t tmp___23 ;

//Stmt9291:Leaf
int tmp___24 ;

//Stmt9292:Leaf
struct file *tmp___25 ;

//Stmt9293:Leaf
char *tmp___26 ;

//Stmt9294:Leaf
char *tmp___27 ;

//Stmt9295:Leaf
char *tmp___28 ;

//Stmt9296:Leaf
char *tmp___29 ;

//Stmt9297:Leaf
uintmax_t d_mtime ;

//Stmt9298:Leaf
uintmax_t tmp___30 ;

//Stmt9299:Leaf
uintmax_t tmp___31 ;

//Stmt9300:Leaf
int tmp___32 ;

//Stmt9301:Leaf
char const   *fmt ;

//Stmt9302:Leaf
char *tmp___33 ;

//Stmt9303:Leaf
char *tmp___34 ;

//Stmt9304:Leaf
char *tmp___35 ;

//Stmt9305:Leaf
char *tmp___36 ;

//Stmt9306:Leaf
char *tmp___37 ;

//Stmt9307:Leaf
char *tmp___38 ;

//Stmt9308:Leaf
char *tmp___39 ;

//Stmt9309:Leaf
char *tmp___40 ;

//Stmt9310:Leaf
int tmp___41 ;

//Stmt9311:Leaf
char *tmp___42 ;

//Stmt9312:Leaf
char *tmp___43 ;

//Stmt9313:Leaf
int tmp___44 ;

//Stmt9314:Leaf
char *tmp___45 ;

//Stmt9315:Leaf
char *tmp___46 ;

//Stmt9316:Leaf
char *tmp___47 ;

//Stmt9317:Leaf
char *tmp___48 ;

 
   {
//Stmt9318:Leaf
dep_status = 0;

//Stmt9319:Leaf
running = 0;

//Stmt9320:Parent
while (1) {
//Stmt8914:Parent
if (2 & db_level) {
//Stmt8910:Leaf
print_spaces(depth);

//Stmt8911:Leaf
tmp = dcgettext((char const   *)((void *)0), "Considering target file `%s\'.\n",
                       5);

//Stmt8912:Leaf
printf((char const   * __restrict  )tmp, file->name);

//Stmt8913:Leaf
fflush(stdout);

     }

//Stmt8915:Leaf
break;

   }

//Stmt9321:Parent
if (file->updated) {
//Stmt8930:Parent
if ((int )file->update_status > 0) {
//Stmt8922:Parent
while (1) {
//Stmt8920:Parent
if (2 & db_level) {
//Stmt8916:Leaf
print_spaces(depth);

//Stmt8917:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "Recently tried and failed to update file `%s\'.\n",
                               5);

//Stmt8918:Leaf
printf((char const   * __restrict  )tmp___0, file->name);

//Stmt8919:Leaf
fflush(stdout);

         }

//Stmt8921:Leaf
break;

       }

//Stmt8923:Leaf
return ((int )file->update_status);

     }

//Stmt8931:Parent
while (1) {
//Stmt8928:Parent
if (2 & db_level) {
//Stmt8924:Leaf
print_spaces(depth);

//Stmt8925:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "File `%s\' was considered already.\n",
                             5);

//Stmt8926:Leaf
printf((char const   * __restrict  )tmp___1, file->name);

//Stmt8927:Leaf
fflush(stdout);

       }

//Stmt8929:Leaf
break;

     }

//Stmt8932:Leaf
return (0);

   }

//Stmt9322:Parent
switch ((unsigned int )file->command_state) {
   case 1U:; 
   case 0U:; 
   break;
   case 2U:; 
//Stmt8939:Parent
while (1) {
//Stmt8937:Parent
if (2 & db_level) {
//Stmt8933:Leaf
print_spaces(depth);

//Stmt8934:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "Still updating file `%s\'.\n",
                           5);

//Stmt8935:Leaf
printf((char const   * __restrict  )tmp___2, file->name);

//Stmt8936:Leaf
fflush(stdout);

     }

//Stmt8938:Leaf
break;

   }

//Stmt8948:Leaf
return (0);

   case 3U:; 
//Stmt8946:Parent
while (1) {
//Stmt8944:Parent
if (2 & db_level) {
//Stmt8940:Leaf
print_spaces(depth);

//Stmt8941:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "Finished updating file `%s\'.\n",
                           5);

//Stmt8942:Leaf
printf((char const   * __restrict  )tmp___3, file->name);

//Stmt8943:Leaf
fflush(stdout);

     }

//Stmt8945:Leaf
break;

   }

//Stmt8949:Leaf
return ((int )file->update_status);

   default:; 
//Stmt8947:Leaf
abort();

   }

//Stmt9323:Leaf
depth ++;

//Stmt9324:Parent
if (file->double_colon) {
//Stmt8950:Leaf
tmp___4 = file->double_colon;

   } else {
//Stmt8951:Leaf
tmp___4 = file;

   }

//Stmt9325:Leaf
tmp___4->updating = 1U;

//Stmt9326:Parent
if (file->last_mtime) {
//Stmt8952:Leaf
this_mtime = file->last_mtime;

   } else {
//Stmt8953:Leaf
tmp___5 = f_mtime(file, 1);

//Stmt8954:Leaf
this_mtime = tmp___5;

   }

//Stmt9327:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt8955:Leaf
file = file->renamed;

   }

//Stmt9328:Leaf
noexist = this_mtime == 0xffffffffffffffffUL;

//Stmt9329:Parent
if (noexist) {
//Stmt8962:Parent
while (1) {
//Stmt8960:Parent
if (1 & db_level) {
//Stmt8956:Leaf
print_spaces(depth);

//Stmt8957:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "File `%s\' does not exist.\n",
                             5);

//Stmt8958:Leaf
printf((char const   * __restrict  )tmp___6, file->name);

//Stmt8959:Leaf
fflush(stdout);

       }

//Stmt8961:Leaf
break;

     }

   }

//Stmt9330:Leaf
must_make = noexist;

//Stmt9331:Parent
if (! file->phony) {
//Stmt8981:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt8980:Parent
if (! file->tried_implicit) {
//Stmt8977:Leaf
tmp___9 = try_implicit_rule(file, depth);

//Stmt8978:Parent
if (tmp___9) {
//Stmt8975:Parent
while (1) {
//Stmt8967:Parent
if (8 & db_level) {
//Stmt8963:Leaf
print_spaces(depth);

//Stmt8964:Leaf
tmp___7 = dcgettext((char const   *)((void *)0), "Found an implicit rule for `%s\'.\n",
                                   5);

//Stmt8965:Leaf
printf((char const   * __restrict  )tmp___7, file->name);

//Stmt8966:Leaf
fflush(stdout);

             }

//Stmt8968:Leaf
break;

           }

         } else {
//Stmt8976:Parent
while (1) {
//Stmt8973:Parent
if (8 & db_level) {
//Stmt8969:Leaf
print_spaces(depth);

//Stmt8970:Leaf
tmp___8 = dcgettext((char const   *)((void *)0), "No implicit rule found for `%s\'.\n",
                                   5);

//Stmt8971:Leaf
printf((char const   * __restrict  )tmp___8, file->name);

//Stmt8972:Leaf
fflush(stdout);

             }

//Stmt8974:Leaf
break;

           }

         }

//Stmt8979:Leaf
file->tried_implicit = 1U;

       }

     }

   }

//Stmt9332:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt8992:Parent
if (! file->is_target) {
//Stmt8991:Parent
if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
//Stmt8990:Parent
if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
//Stmt8988:Parent
while (1) {
//Stmt8986:Parent
if (8 & db_level) {
//Stmt8982:Leaf
print_spaces(depth);

//Stmt8983:Leaf
tmp___10 = dcgettext((char const   *)((void *)0), "Using default commands for `%s\'.\n",
                                    5);

//Stmt8984:Leaf
printf((char const   * __restrict  )tmp___10, file->name);

//Stmt8985:Leaf
fflush(stdout);

             }

//Stmt8987:Leaf
break;

           }

//Stmt8989:Leaf
file->cmds = default_file->cmds;

         }

       }

     }

   }

//Stmt9333:Leaf
lastd = (struct dep *)0;

//Stmt9334:Leaf
d = file->deps;

//Stmt9335:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt9025:Parent
while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
//Stmt8993:Leaf
d->file = (d->file)->renamed;

     }

//Stmt9026:Parent
if ((d->file)->last_mtime) {
//Stmt8994:Leaf
mtime = (d->file)->last_mtime;

     } else {
//Stmt8995:Leaf
tmp___11 = f_mtime(d->file, 1);

//Stmt8996:Leaf
mtime = tmp___11;

     }

//Stmt9027:Parent
while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
//Stmt8997:Leaf
d->file = (d->file)->renamed;

     }

//Stmt9028:Parent
if ((d->file)->double_colon) {
//Stmt8998:Leaf
tmp___13 = (d->file)->double_colon;

     } else {
//Stmt8999:Leaf
tmp___13 = d->file;

     }

//Stmt9029:Parent
if (tmp___13->updating) {
//Stmt9002:Leaf
tmp___12 = dcgettext((char const   *)((void *)0), "Circular %s <- %s dependency dropped.",
                            5);

//Stmt9003:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___12, file->name,
             (d->file)->name);

//Stmt9004:Parent
if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
//Stmt9000:Leaf
file->deps = d->next;

       } else {
//Stmt9001:Leaf
lastd->next = d->next;

       }

//Stmt9005:Leaf
d = d->next;

//Stmt9006:Leaf
continue;

     }

//Stmt9030:Leaf
(d->file)->parent = file;

//Stmt9031:Leaf
tmp___14 = check_dep(d->file, depth, this_mtime, & must_make);

//Stmt9032:Leaf
dep_status |= tmp___14;

//Stmt9033:Parent
while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
//Stmt9007:Leaf
d->file = (d->file)->renamed;

     }

//Stmt9034:Leaf
f = d->file;

//Stmt9035:Parent
if (f->double_colon) {
//Stmt9008:Leaf
f = f->double_colon;

     }

//Stmt9036:Parent
while (1) {
//Stmt9014:Parent
if ((unsigned int )f->command_state == 2U) {
//Stmt9011:Leaf
tmp___15 = 1;

       } else
       {
//Stmt9012:Parent
if ((unsigned int )f->command_state == 1U) {
//Stmt9009:Leaf
tmp___15 = 1;

       } else {
//Stmt9010:Leaf
tmp___15 = 0;

       }
}


//Stmt9015:Leaf
running |= tmp___15;

//Stmt9016:Leaf
f = f->prev;

//Stmt9017:Parent
if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
//Stmt9013:Leaf
break;

       }

     }

//Stmt9037:Parent
if (dep_status != 0) {
//Stmt9019:Parent
if (! keep_going_flag) {
//Stmt9018:Leaf
break;

       }

     }

//Stmt9038:Parent
if (! running) {
//Stmt9023:Parent
if ((d->file)->last_mtime) {
//Stmt9020:Leaf
tmp___17 = (d->file)->last_mtime;

       } else {
//Stmt9021:Leaf
tmp___16 = f_mtime(d->file, 1);

//Stmt9022:Leaf
tmp___17 = tmp___16;

       }

//Stmt9024:Leaf
d->changed = tmp___17 != mtime;

     }

//Stmt9039:Leaf
lastd = d;

//Stmt9040:Leaf
d = d->next;

   }

//Stmt9336:Parent
if (must_make) {
//Stmt9084:Leaf
d = file->deps;

//Stmt9085:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt9082:Parent
if ((d->file)->intermediate) {
//Stmt9070:Parent
if ((d->file)->last_mtime) {
//Stmt9041:Leaf
tmp___19 = (d->file)->last_mtime;

         } else {
//Stmt9042:Leaf
tmp___18 = f_mtime(d->file, 1);

//Stmt9043:Leaf
tmp___19 = tmp___18;

         }

//Stmt9071:Leaf
mtime___0 = tmp___19;

//Stmt9072:Parent
while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
//Stmt9044:Leaf
d->file = (d->file)->renamed;

         }

//Stmt9073:Leaf
(d->file)->parent = file;

//Stmt9074:Leaf
tmp___20 = update_file(d->file, depth);

//Stmt9075:Leaf
dep_status |= tmp___20;

//Stmt9076:Parent
while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
//Stmt9045:Leaf
d->file = (d->file)->renamed;

         }

//Stmt9077:Leaf
f___0 = d->file;

//Stmt9078:Parent
if (f___0->double_colon) {
//Stmt9046:Leaf
f___0 = f___0->double_colon;

         }

//Stmt9079:Parent
while (1) {
//Stmt9052:Parent
if ((unsigned int )f___0->command_state == 2U) {
//Stmt9049:Leaf
tmp___21 = 1;

           } else
           {
//Stmt9050:Parent
if ((unsigned int )f___0->command_state == 1U) {
//Stmt9047:Leaf
tmp___21 = 1;

           } else {
//Stmt9048:Leaf
tmp___21 = 0;

           }
}


//Stmt9053:Leaf
running |= tmp___21;

//Stmt9054:Leaf
f___0 = f___0->prev;

//Stmt9055:Parent
if (! ((unsigned long )f___0 != (unsigned long )((struct file *)0))) {
//Stmt9051:Leaf
break;

           }

         }

//Stmt9080:Parent
if (dep_status != 0) {
//Stmt9057:Parent
if (! keep_going_flag) {
//Stmt9056:Leaf
break;

           }

         }

//Stmt9081:Parent
if (! running) {
//Stmt9068:Parent
if (file->phony) {
//Stmt9066:Parent
if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
//Stmt9058:Leaf
tmp___24 = 1;

             } else {
//Stmt9059:Leaf
goto _L;

             }

           } else {
             _L: /* CIL Label */ 
             {
//Stmt9063:Parent
if ((d->file)->last_mtime) {
//Stmt9060:Leaf
tmp___23 = (d->file)->last_mtime;

             } else {
//Stmt9061:Leaf
tmp___22 = f_mtime(d->file, 1);

//Stmt9062:Leaf
tmp___23 = tmp___22;

             }
}

//Stmt9067:Parent
if (tmp___23 != mtime___0) {
//Stmt9064:Leaf
tmp___24 = 1;

             } else {
//Stmt9065:Leaf
tmp___24 = 0;

             }

           }

//Stmt9069:Leaf
d->changed = tmp___24;

         }

       }

//Stmt9083:Leaf
d = d->next;

     }

   }

//Stmt9337:Parent
if (file->double_colon) {
//Stmt9086:Leaf
tmp___25 = file->double_colon;

   } else {
//Stmt9087:Leaf
tmp___25 = file;

   }

//Stmt9338:Leaf
tmp___25->updating = 0U;

//Stmt9339:Parent
while (1) {
//Stmt9092:Parent
if (2 & db_level) {
//Stmt9088:Leaf
print_spaces(depth);

//Stmt9089:Leaf
tmp___26 = dcgettext((char const   *)((void *)0), "Finished prerequisites of target file `%s\'.\n",
                            5);

//Stmt9090:Leaf
printf((char const   * __restrict  )tmp___26, file->name);

//Stmt9091:Leaf
fflush(stdout);

     }

//Stmt9093:Leaf
break;

   }

//Stmt9340:Parent
if (running) {
//Stmt9100:Leaf
set_command_state(file, 1);

//Stmt9101:Leaf
depth --;

//Stmt9102:Parent
while (1) {
//Stmt9098:Parent
if (2 & db_level) {
//Stmt9094:Leaf
print_spaces(depth);

//Stmt9095:Leaf
tmp___27 = dcgettext((char const   *)((void *)0), "The prerequisites of `%s\' are being made.\n",
                              5);

//Stmt9096:Leaf
printf((char const   * __restrict  )tmp___27, file->name);

//Stmt9097:Leaf
fflush(stdout);

       }

//Stmt9099:Leaf
break;

     }

//Stmt9103:Leaf
return (0);

   }

//Stmt9341:Parent
if (dep_status != 0) {
//Stmt9115:Leaf
file->update_status = (short )dep_status;

//Stmt9116:Leaf
notice_finished_file(file);

//Stmt9117:Leaf
depth --;

//Stmt9118:Parent
while (1) {
//Stmt9108:Parent
if (2 & db_level) {
//Stmt9104:Leaf
print_spaces(depth);

//Stmt9105:Leaf
tmp___28 = dcgettext((char const   *)((void *)0), "Giving up on target file `%s\'.\n",
                              5);

//Stmt9106:Leaf
printf((char const   * __restrict  )tmp___28, file->name);

//Stmt9107:Leaf
fflush(stdout);

       }

//Stmt9109:Leaf
break;

     }

//Stmt9119:Parent
if (depth == 0U) {
//Stmt9114:Parent
if (keep_going_flag) {
//Stmt9113:Parent
if (! just_print_flag) {
//Stmt9112:Parent
if (! question_flag) {
//Stmt9110:Leaf
tmp___29 = dcgettext((char const   *)((void *)0), "Target `%s\' not remade because of errors.",
                                  5);

//Stmt9111:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___29,
                   file->name);

           }

         }

       }

     }

//Stmt9120:Leaf
return (dep_status);

   }

//Stmt9342:Parent
if ((unsigned int )file->command_state == 1U) {
//Stmt9121:Leaf
set_command_state(file, 0);

   }

//Stmt9343:Leaf
deps_changed = 0;

//Stmt9344:Leaf
d = file->deps;

//Stmt9345:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt9152:Parent
if ((d->file)->last_mtime) {
//Stmt9122:Leaf
tmp___31 = (d->file)->last_mtime;

     } else {
//Stmt9123:Leaf
tmp___30 = f_mtime(d->file, 1);

//Stmt9124:Leaf
tmp___31 = tmp___30;

     }

//Stmt9153:Leaf
d_mtime = tmp___31;

//Stmt9154:Parent
while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
//Stmt9125:Leaf
d->file = (d->file)->renamed;

     }

//Stmt9155:Parent
if (d_mtime == 0xffffffffffffffffUL) {
//Stmt9127:Parent
if (! (d->file)->intermediate) {
//Stmt9126:Leaf
must_make = 1;

       }

     }

//Stmt9156:Leaf
deps_changed |= d->changed;

//Stmt9157:Parent
if (noexist) {
//Stmt9130:Leaf
tmp___32 = 1;

     } else
     {
//Stmt9131:Parent
if (d_mtime > this_mtime) {
//Stmt9128:Leaf
tmp___32 = 1;

     } else {
//Stmt9129:Leaf
tmp___32 = 0;

     }
}


//Stmt9158:Leaf
d->changed |= tmp___32;

//Stmt9159:Parent
if (! noexist) {
//Stmt9151:Parent
if (3 & db_level) {
//Stmt9148:Leaf
fmt = (char const   *)0;

//Stmt9149:Parent
if (d_mtime == 0xffffffffffffffffUL) {
//Stmt9140:Parent
if (1 & db_level) {
//Stmt9132:Leaf
tmp___33 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' of target `%s\' does not exist.\n",
                                  5);

//Stmt9133:Leaf
fmt = (char const   *)tmp___33;

           }

         } else
         {
//Stmt9141:Parent
if (d->changed) {
//Stmt9138:Parent
if (1 & db_level) {
//Stmt9134:Leaf
tmp___34 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' is newer than target `%s\'.\n",
                                  5);

//Stmt9135:Leaf
fmt = (char const   *)tmp___34;

           }

         } else
         {
//Stmt9139:Parent
if (2 & db_level) {
//Stmt9136:Leaf
tmp___35 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' is older than target `%s\'.\n",
                                5);

//Stmt9137:Leaf
fmt = (char const   *)tmp___35;

         }
}

}


//Stmt9150:Parent
if (fmt) {
//Stmt9144:Leaf
print_spaces(depth);

//Stmt9145:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt9142:Leaf
tmp___36 = (d->file)->name;

           } else {
//Stmt9143:Leaf
tmp___36 = d->name;

           }

//Stmt9146:Leaf
printf((char const   * __restrict  )fmt, tmp___36, file->name);

//Stmt9147:Leaf
fflush(stdout);

         }

       }

     }

//Stmt9160:Leaf
d = d->next;

   }

//Stmt9346:Leaf
depth --;

//Stmt9347:Parent
if (file->double_colon) {
//Stmt9182:Parent
if ((unsigned long )file->deps == (unsigned long )((struct dep *)0)) {
//Stmt9167:Leaf
must_make = 1;

//Stmt9168:Parent
while (1) {
//Stmt9165:Parent
if (1 & db_level) {
//Stmt9161:Leaf
print_spaces(depth);

//Stmt9162:Leaf
tmp___37 = dcgettext((char const   *)((void *)0), "Target `%s\' is double-colon and has no prerequisites.\n",
                                5);

//Stmt9163:Leaf
printf((char const   * __restrict  )tmp___37, file->name);

//Stmt9164:Leaf
fflush(stdout);

         }

//Stmt9166:Leaf
break;

       }

     } else {
//Stmt9169:Leaf
goto _L___0;

     }

   } else
   _L___0: /* CIL Label */ 
   {
//Stmt9181:Parent
if (! noexist) {
//Stmt9180:Parent
if (file->is_target) {
//Stmt9179:Parent
if (! deps_changed) {
//Stmt9178:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt9176:Leaf
must_make = 0;

//Stmt9177:Parent
while (1) {
//Stmt9174:Parent
if (2 & db_level) {
//Stmt9170:Leaf
print_spaces(depth);

//Stmt9171:Leaf
tmp___38 = dcgettext((char const   *)((void *)0), "No commands for `%s\' and no prerequisites actually changed.\n",
                                    5);

//Stmt9172:Leaf
printf((char const   * __restrict  )tmp___38, file->name);

//Stmt9173:Leaf
fflush(stdout);

             }

//Stmt9175:Leaf
break;

           }

         }

       }

     }

   }
}


//Stmt9348:Parent
if (! must_make) {
//Stmt9199:Parent
if (2 & db_level) {
//Stmt9191:Leaf
print_spaces(depth);

//Stmt9192:Leaf
tmp___39 = dcgettext((char const   *)((void *)0), "No need to remake target `%s\'",
                            5);

//Stmt9193:Leaf
printf((char const   * __restrict  )tmp___39, file->name);

//Stmt9194:Parent
if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
//Stmt9190:Parent
if ((int )*(file->name) == (int )*(file->hname)) {
//Stmt9187:Parent
if (! ((int )*(file->name) == 0)) {
//Stmt9185:Leaf
tmp___41 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));

//Stmt9186:Parent
if (tmp___41) {
//Stmt9183:Leaf
tmp___40 = dcgettext((char const   *)((void *)0), "; using VPATH name `%s\'",
                                    5);

//Stmt9184:Leaf
printf((char const   * __restrict  )tmp___40, file->hname);

             }

           }

         } else {
//Stmt9188:Leaf
tmp___40 = dcgettext((char const   *)((void *)0), "; using VPATH name `%s\'",
                                5);

//Stmt9189:Leaf
printf((char const   * __restrict  )tmp___40, file->hname);

         }

       }

//Stmt9195:Leaf
puts(".");

//Stmt9196:Leaf
fflush(stdout);

     }

//Stmt9200:Leaf
notice_finished_file(file);

//Stmt9201:Parent
while (file) {
//Stmt9197:Leaf
file->name = file->hname;

//Stmt9198:Leaf
file = file->prev;

     }

//Stmt9202:Leaf
return (0);

   }

//Stmt9349:Parent
while (1) {
//Stmt9207:Parent
if (1 & db_level) {
//Stmt9203:Leaf
print_spaces(depth);

//Stmt9204:Leaf
tmp___42 = dcgettext((char const   *)((void *)0), "Must remake target `%s\'.\n",
                            5);

//Stmt9205:Leaf
printf((char const   * __restrict  )tmp___42, file->name);

//Stmt9206:Leaf
fflush(stdout);

     }

//Stmt9208:Leaf
break;

   }

//Stmt9350:Parent
if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
//Stmt9220:Parent
if ((int )*(file->name) == (int )*(file->hname)) {
//Stmt9218:Parent
if (! ((int )*(file->name) == 0)) {
//Stmt9210:Leaf
tmp___44 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));

//Stmt9211:Parent
if (tmp___44) {
//Stmt9209:Leaf
goto _L___1;

         }

       }

     } else {
       _L___1: /* CIL Label */ 
       {
//Stmt9217:Parent
while (1) {
//Stmt9215:Parent
if (1 & db_level) {
//Stmt9212:Leaf
tmp___43 = dcgettext((char const   *)((void *)0), "  Ignoring VPATH name `%s\'.\n",
                                5);

//Stmt9213:Leaf
printf((char const   * __restrict  )tmp___43, file->hname);

//Stmt9214:Leaf
fflush(stdout);

         }

//Stmt9216:Leaf
break;

       }
}

//Stmt9219:Leaf
file->ignore_vpath = 1U;

     }

   }

//Stmt9351:Leaf
remake_file(file);

//Stmt9352:Parent
if ((unsigned int )file->command_state != 3U) {
//Stmt9227:Parent
while (1) {
//Stmt9225:Parent
if (2 & db_level) {
//Stmt9221:Leaf
print_spaces(depth);

//Stmt9222:Leaf
tmp___45 = dcgettext((char const   *)((void *)0), "Commands of `%s\' are being run.\n",
                              5);

//Stmt9223:Leaf
printf((char const   * __restrict  )tmp___45, file->name);

//Stmt9224:Leaf
fflush(stdout);

       }

//Stmt9226:Leaf
break;

     }

//Stmt9228:Leaf
return (0);

   }

//Stmt9353:Parent
switch ((int )file->update_status) {
   case 2:; 
//Stmt9235:Parent
while (1) {
//Stmt9233:Parent
if (1 & db_level) {
//Stmt9229:Leaf
print_spaces(depth);

//Stmt9230:Leaf
tmp___46 = dcgettext((char const   *)((void *)0), "Failed to remake target file `%s\'.\n",
                            5);

//Stmt9231:Leaf
printf((char const   * __restrict  )tmp___46, file->name);

//Stmt9232:Leaf
fflush(stdout);

     }

//Stmt9234:Leaf
break;

   }

   break;
   case 0:; 
//Stmt9242:Parent
while (1) {
//Stmt9240:Parent
if (1 & db_level) {
//Stmt9236:Leaf
print_spaces(depth);

//Stmt9237:Leaf
tmp___47 = dcgettext((char const   *)((void *)0), "Successfully remade target file `%s\'.\n",
                            5);

//Stmt9238:Leaf
printf((char const   * __restrict  )tmp___47, file->name);

//Stmt9239:Leaf
fflush(stdout);

     }

//Stmt9241:Leaf
break;

   }

   break;
   case 1:; 
//Stmt9249:Parent
while (1) {
//Stmt9247:Parent
if (1 & db_level) {
//Stmt9243:Leaf
print_spaces(depth);

//Stmt9244:Leaf
tmp___48 = dcgettext((char const   *)((void *)0), "Target file `%s\' needs remade under -q.\n",
                            5);

//Stmt9245:Leaf
printf((char const   * __restrict  )tmp___48, file->name);

//Stmt9246:Leaf
fflush(stdout);

     }

//Stmt9248:Leaf
break;

   }

   break;
   default:; 
//Stmt9253:Parent
if ((int )file->update_status >= 0) {
//Stmt9251:Parent
if (! ((int )file->update_status <= 2)) {
//Stmt9250:Leaf
__assert_fail("file->update_status >= 0 && file->update_status <= 2", "remake.c",
                     676U, "update_file_1");

     }

   } else {
//Stmt9252:Leaf
__assert_fail("file->update_status >= 0 && file->update_status <= 2", "remake.c",
                   676U, "update_file_1");

   }

   break;
   }

//Stmt9354:Leaf
file->updated = 1U;

//Stmt9355:Leaf
return ((int )file->update_status);

 }
}
 void notice_finished_file(struct file *file ) 
 { 
//Stmt9403:Leaf
struct dep *d ;

//Stmt9404:Leaf
int ran ;

//Stmt9405:Leaf
unsigned int i ;

//Stmt9406:Leaf
int tmp ;

//Stmt9407:Leaf
struct file *f ;

//Stmt9408:Leaf
int i___0 ;

 
   {
//Stmt9409:Leaf
ran = (unsigned int )file->command_state == 2U;

//Stmt9410:Leaf
file->command_state = (enum __anonenum_command_state_55 )3;

//Stmt9411:Leaf
file->updated = 1U;

//Stmt9412:Parent
if (touch_flag) {
//Stmt9368:Parent
if ((int )file->update_status == 0) {
//Stmt9367:Parent
if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
//Stmt9366:Parent
if ((file->cmds)->any_recurse) {
//Stmt9359:Leaf
i = 0U;

//Stmt9360:Parent
while (i < (file->cmds)->ncommand_lines) {
//Stmt9357:Parent
if (! ((int )*((file->cmds)->lines_flags + i) & 1)) {
//Stmt9356:Leaf
goto have_nonrecursing;

             }

//Stmt9358:Leaf
i ++;

           }

         } else {
//Stmt9361:Leaf
goto have_nonrecursing;

         }

       } else
       have_nonrecursing: 
       {
//Stmt9365:Parent
if (file->phony) {
//Stmt9362:Leaf
file->update_status = (short)0;

       } else {
//Stmt9363:Leaf
tmp = touch_file(file);

//Stmt9364:Leaf
file->update_status = (short )tmp;

       }
}


     }

   }

//Stmt9413:Parent
if (file->mtime_before_update == 0UL) {
//Stmt9369:Leaf
file->mtime_before_update = file->last_mtime;

   }

//Stmt9414:Parent
if (ran) {
//Stmt9389:Parent
if (! file->phony) {
//Stmt9384:Leaf
i___0 = 0;

//Stmt9385:Parent
if (question_flag) {
//Stmt9378:Leaf
goto _L___0;

       } else
       {
//Stmt9379:Parent
if (just_print_flag) {
         _L___0: /* CIL Label */ 
         {
//Stmt9370:Leaf
i___0 = (int )(file->cmds)->ncommand_lines;

}
//Stmt9376:Parent
while (i___0 > 0) {
//Stmt9372:Parent
if (! ((int )*((file->cmds)->lines_flags + (i___0 - 1)) & 1)) {
//Stmt9371:Leaf
break;

           }

//Stmt9373:Leaf
i___0 --;

         }

       } else
       {
//Stmt9377:Parent
if (file->is_target) {
//Stmt9375:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt9374:Leaf
i___0 = 1;

         }

       }
}

}


//Stmt9386:Parent
if (i___0 == 0) {
//Stmt9380:Leaf
file->last_mtime = (uintmax_t )0;

       } else {
//Stmt9381:Leaf
file->last_mtime = 0xfffffffffffffffeUL;

       }

//Stmt9387:Leaf
f = file->double_colon;

//Stmt9388:Parent
while ((unsigned long )f != (unsigned long )((struct file *)0)) {
//Stmt9382:Leaf
f->last_mtime = file->last_mtime;

//Stmt9383:Leaf
f = f->next;

       }

     }

   }

//Stmt9415:Parent
if (ran) {
//Stmt9402:Parent
if ((int )file->update_status != -1) {
//Stmt9397:Leaf
d = file->also_make;

//Stmt9398:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt9392:Leaf
(d->file)->command_state = (enum __anonenum_command_state_55 )3;

//Stmt9393:Leaf
(d->file)->updated = 1U;

//Stmt9394:Leaf
(d->file)->update_status = file->update_status;

//Stmt9395:Parent
if (ran) {
//Stmt9391:Parent
if (! (d->file)->phony) {
//Stmt9390:Leaf
f_mtime(d->file, 0);

           }

         }

//Stmt9396:Leaf
d = d->next;

       }

     } else {
//Stmt9399:Leaf
goto _L___1;

     }

   } else
   _L___1: /* CIL Label */ 
   {
//Stmt9401:Parent
if ((int )file->update_status == -1) {
//Stmt9400:Leaf
file->update_status = (short)0;

   }
}


//Stmt9416:Leaf
return;

 }
}
 static int check_dep(struct file *file , unsigned int depth , uintmax_t this_mtime ,
                      int *must_make_ptr ) 
 { 
//Stmt9509:Leaf
register struct dep *d ;

//Stmt9510:Leaf
int dep_status ;

//Stmt9511:Leaf
struct file *tmp ;

//Stmt9512:Leaf
uintmax_t mtime ;

//Stmt9513:Leaf
uintmax_t tmp___0 ;

//Stmt9514:Leaf
uintmax_t mtime___0 ;

//Stmt9515:Leaf
char *tmp___1 ;

//Stmt9516:Leaf
char *tmp___2 ;

//Stmt9517:Leaf
int tmp___3 ;

//Stmt9518:Leaf
char *tmp___4 ;

//Stmt9519:Leaf
uintmax_t tmp___5 ;

//Stmt9520:Leaf
register struct dep *lastd ;

//Stmt9521:Leaf
char *tmp___6 ;

//Stmt9522:Leaf
struct file *tmp___7 ;

//Stmt9523:Leaf
int tmp___8 ;

//Stmt9524:Leaf
struct file *tmp___9 ;

 
   {
//Stmt9525:Leaf
dep_status = 0;

//Stmt9526:Leaf
depth ++;

//Stmt9527:Parent
if (file->double_colon) {
//Stmt9417:Leaf
tmp = file->double_colon;

   } else {
//Stmt9418:Leaf
tmp = file;

   }

//Stmt9528:Leaf
tmp->updating = 1U;

//Stmt9529:Parent
if (! file->intermediate) {
//Stmt9496:Leaf
dep_status = update_file(file, depth);

//Stmt9497:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt9419:Leaf
file = file->renamed;

     }

//Stmt9498:Parent
if (file->last_mtime) {
//Stmt9420:Leaf
mtime = file->last_mtime;

     } else {
//Stmt9421:Leaf
tmp___0 = f_mtime(file, 1);

//Stmt9422:Leaf
mtime = tmp___0;

     }

//Stmt9499:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt9423:Leaf
file = file->renamed;

     }

//Stmt9500:Parent
if (mtime == 0xffffffffffffffffUL) {
//Stmt9425:Leaf
*must_make_ptr = 1;

     } else
     {
//Stmt9426:Parent
if (mtime > this_mtime) {
//Stmt9424:Leaf
*must_make_ptr = 1;

     }
}


   } else {
//Stmt9501:Parent
if (! file->phony) {
//Stmt9445:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt9444:Parent
if (! file->tried_implicit) {
//Stmt9441:Leaf
tmp___3 = try_implicit_rule(file, depth);

//Stmt9442:Parent
if (tmp___3) {
//Stmt9439:Parent
while (1) {
//Stmt9431:Parent
if (8 & db_level) {
//Stmt9427:Leaf
print_spaces(depth);

//Stmt9428:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "Found an implicit rule for `%s\'.\n",
                                     5);

//Stmt9429:Leaf
printf((char const   * __restrict  )tmp___1, file->name);

//Stmt9430:Leaf
fflush(stdout);

               }

//Stmt9432:Leaf
break;

             }

           } else {
//Stmt9440:Parent
while (1) {
//Stmt9437:Parent
if (8 & db_level) {
//Stmt9433:Leaf
print_spaces(depth);

//Stmt9434:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "No implicit rule found for `%s\'.\n",
                                     5);

//Stmt9435:Leaf
printf((char const   * __restrict  )tmp___2, file->name);

//Stmt9436:Leaf
fflush(stdout);

               }

//Stmt9438:Leaf
break;

             }

           }

//Stmt9443:Leaf
file->tried_implicit = 1U;

         }

       }

     }

//Stmt9502:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt9456:Parent
if (! file->is_target) {
//Stmt9455:Parent
if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
//Stmt9454:Parent
if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
//Stmt9452:Parent
while (1) {
//Stmt9450:Parent
if (8 & db_level) {
//Stmt9446:Leaf
print_spaces(depth);

//Stmt9447:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "Using default commands for `%s\'.\n",
                                     5);

//Stmt9448:Leaf
printf((char const   * __restrict  )tmp___4, file->name);

//Stmt9449:Leaf
fflush(stdout);

               }

//Stmt9451:Leaf
break;

             }

//Stmt9453:Leaf
file->cmds = default_file->cmds;

           }

         }

       }

     }

//Stmt9503:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt9457:Leaf
file = file->renamed;

     }

//Stmt9504:Parent
if (file->last_mtime) {
//Stmt9458:Leaf
mtime___0 = file->last_mtime;

     } else {
//Stmt9459:Leaf
tmp___5 = f_mtime(file, 1);

//Stmt9460:Leaf
mtime___0 = tmp___5;

     }

//Stmt9505:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt9461:Leaf
file = file->renamed;

     }

//Stmt9506:Parent
if (mtime___0 != 0xffffffffffffffffUL) {
//Stmt9493:Parent
if (mtime___0 > this_mtime) {
//Stmt9462:Leaf
*must_make_ptr = 1;

       } else {
//Stmt9463:Leaf
goto _L;

       }

     } else {
       _L: /* CIL Label */ 
       {
//Stmt9464:Leaf
lastd = (struct dep *)0;

}
//Stmt9494:Leaf
d = file->deps;

//Stmt9495:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt9483:Parent
if ((d->file)->double_colon) {
//Stmt9465:Leaf
tmp___7 = (d->file)->double_colon;

         } else {
//Stmt9466:Leaf
tmp___7 = d->file;

         }

//Stmt9484:Parent
if (tmp___7->updating) {
//Stmt9473:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "Circular %s <- %s dependency dropped.",
                               5);

//Stmt9474:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                 file->name, (d->file)->name);

//Stmt9475:Parent
if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
//Stmt9467:Leaf
file->deps = d->next;

//Stmt9468:Leaf
free((void *)((char *)d));

//Stmt9469:Leaf
d = file->deps;

           } else {
//Stmt9470:Leaf
lastd->next = d->next;

//Stmt9471:Leaf
free((void *)((char *)d));

//Stmt9472:Leaf
d = lastd->next;

           }

//Stmt9476:Leaf
continue;

         }

//Stmt9485:Leaf
(d->file)->parent = file;

//Stmt9486:Leaf
tmp___8 = check_dep(d->file, depth, this_mtime, must_make_ptr);

//Stmt9487:Leaf
dep_status |= tmp___8;

//Stmt9488:Parent
while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
//Stmt9477:Leaf
d->file = (d->file)->renamed;

         }

//Stmt9489:Parent
if (dep_status != 0) {
//Stmt9479:Parent
if (! keep_going_flag) {
//Stmt9478:Leaf
break;

           }

         }

//Stmt9490:Parent
if ((unsigned int )(d->file)->command_state == 2U) {
//Stmt9481:Leaf
set_command_state(file, 1);

         } else
         {
//Stmt9482:Parent
if ((unsigned int )(d->file)->command_state == 1U) {
//Stmt9480:Leaf
set_command_state(file, 1);

         }
}


//Stmt9491:Leaf
lastd = d;

//Stmt9492:Leaf
d = d->next;

       }

     }

   }

//Stmt9530:Parent
if (file->double_colon) {
//Stmt9507:Leaf
tmp___9 = file->double_colon;

   } else {
//Stmt9508:Leaf
tmp___9 = file;

   }

//Stmt9531:Leaf
tmp___9->updating = 0U;

//Stmt9532:Leaf
return (dep_status);

 }
}
 static int touch_file(struct file *file ) 
 { 
//Stmt9570:Leaf
int tmp ;

//Stmt9571:Leaf
int fd ;

//Stmt9572:Leaf
int tmp___0 ;

//Stmt9573:Leaf
struct stat statbuf ;

//Stmt9574:Leaf
char buf___1 ;

//Stmt9575:Leaf
int status ;

//Stmt9576:Leaf
int *tmp___1 ;

//Stmt9577:Leaf
ssize_t tmp___2 ;

//Stmt9578:Leaf
__off_t tmp___3 ;

//Stmt9579:Leaf
ssize_t tmp___4 ;

//Stmt9580:Leaf
int tmp___5 ;

 
   {
//Stmt9581:Parent
if (! silent_flag) {
//Stmt9533:Leaf
message(0, "touch %s", file->name);

   }

//Stmt9582:Leaf
tmp___5 = ar_name(file->name);

//Stmt9583:Parent
if (tmp___5) {
//Stmt9565:Leaf
tmp = ar_touch(file->name);

//Stmt9566:Leaf
return (tmp);

   } else {
//Stmt9567:Leaf
tmp___0 = open((char const   *)file->name, 66, 438);

//Stmt9568:Leaf
fd = tmp___0;

//Stmt9569:Parent
if (fd < 0) {
//Stmt9553:Leaf
perror_with_name((char *)"touch: open: ", file->name);

//Stmt9554:Leaf
return (1);

     } else {
//Stmt9555:Parent
while (1) {
//Stmt9538:Leaf
status = fstat(fd, & statbuf);

//Stmt9539:Parent
if (status < 0) {
//Stmt9535:Leaf
tmp___1 = __errno_location();

//Stmt9536:Parent
if (! (*tmp___1 == 4)) {
//Stmt9534:Leaf
break;

           }

         } else {
//Stmt9537:Leaf
break;

         }

       }

//Stmt9556:Parent
if (status < 0) {
//Stmt9540:Leaf
perror_with_name((char *)"touch: fstat: ", file->name);

//Stmt9541:Leaf
return (1);

       }

//Stmt9557:Leaf
tmp___2 = read(fd, (void *)(& buf___1), (size_t )1);

//Stmt9558:Parent
if (tmp___2 < 0L) {
//Stmt9542:Leaf
perror_with_name((char *)"touch: read: ", file->name);

//Stmt9543:Leaf
return (1);

       }

//Stmt9559:Leaf
tmp___3 = lseek(fd, 0L, 0);

//Stmt9560:Parent
if (tmp___3 < 0L) {
//Stmt9544:Leaf
perror_with_name((char *)"touch: lseek: ", file->name);

//Stmt9545:Leaf
return (1);

       }

//Stmt9561:Leaf
tmp___4 = write(fd, (void const   *)(& buf___1), (size_t )1);

//Stmt9562:Parent
if (tmp___4 < 0L) {
//Stmt9546:Leaf
perror_with_name((char *)"touch: write: ", file->name);

//Stmt9547:Leaf
return (1);

       }

//Stmt9563:Parent
if (statbuf.st_size == 0L) {
//Stmt9550:Leaf
close(fd);

//Stmt9551:Leaf
fd = open((char const   *)file->name, 514, 438);

//Stmt9552:Parent
if (fd < 0) {
//Stmt9548:Leaf
perror_with_name((char *)"touch: open: ", file->name);

//Stmt9549:Leaf
return (1);

         }

       }

//Stmt9564:Leaf
close(fd);

     }

   }

//Stmt9584:Leaf
return (0);

 }
}
 static void remake_file(struct file *file ) 
 { 
//Stmt9611:Leaf
char const   *msg_noparent ;

//Stmt9612:Leaf
char *tmp ;

//Stmt9613:Leaf
char const   *msg_parent ;

//Stmt9614:Leaf
char *tmp___0 ;

 
   {
//Stmt9615:Parent
if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
//Stmt9607:Parent
if (file->phony) {
//Stmt9600:Leaf
file->update_status = (short)0;

     } else
     {
//Stmt9601:Parent
if (file->is_target) {
//Stmt9592:Leaf
file->update_status = (short)0;

     } else {
//Stmt9593:Leaf
tmp = dcgettext((char const   *)((void *)0), "%sNo rule to make target `%s\'%s",
                       5);

//Stmt9594:Leaf
msg_noparent = (char const   *)tmp;

//Stmt9595:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "%sNo rule to make target `%s\', needed by `%s\'%s",
                           5);

//Stmt9596:Leaf
msg_parent = (char const   *)tmp___0;

//Stmt9597:Parent
if (! keep_going_flag) {
//Stmt9588:Parent
if (! file->dontcare) {
//Stmt9586:Parent
if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
//Stmt9585:Leaf
fatal((struct floc  const  *)((struct floc *)0), msg_noparent, "", file->name,
                   "");

           }

//Stmt9587:Leaf
fatal((struct floc  const  *)((struct floc *)0), msg_parent, "", file->name,
                 (file->parent)->name, "");

         }

       }

//Stmt9598:Parent
if (! file->dontcare) {
//Stmt9591:Parent
if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
//Stmt9589:Leaf
error((struct floc  const  *)((struct floc *)0), msg_noparent, "*** ", file->name,
                 ".");

         } else {
//Stmt9590:Leaf
error((struct floc  const  *)((struct floc *)0), msg_parent, "*** ", file->name,
                 (file->parent)->name, ".");

         }

       }

//Stmt9599:Leaf
file->update_status = (short)2;

     }
}


   } else {
//Stmt9608:Leaf
chop_commands(file->cmds);

//Stmt9609:Parent
if (! touch_flag) {
//Stmt9604:Leaf
execute_file_commands(file);

//Stmt9605:Leaf
return;

     } else
     {
//Stmt9606:Parent
if ((file->cmds)->any_recurse) {
//Stmt9602:Leaf
execute_file_commands(file);

//Stmt9603:Leaf
return;

     }
}


//Stmt9610:Leaf
file->update_status = (short)0;

   }

//Stmt9616:Leaf
notice_finished_file(file);

//Stmt9617:Leaf
return;

 }
}
 static uintmax_t now  =    (uintmax_t )0;
 uintmax_t f_mtime(struct file *file , int search ) 
 { 
//Stmt9713:Leaf
uintmax_t mtime ;

//Stmt9714:Leaf
char *arname ;

//Stmt9715:Leaf
char *memname ;

//Stmt9716:Leaf
struct file *arfile ;

//Stmt9717:Leaf
int arname_used ;

//Stmt9718:Leaf
char *name ;

//Stmt9719:Leaf
unsigned int arlen ;

//Stmt9720:Leaf
unsigned int memlen ;

//Stmt9721:Leaf
size_t tmp ;

//Stmt9722:Leaf
size_t tmp___0 ;

//Stmt9723:Leaf
char *tmp___1 ;

//Stmt9724:Leaf
int tmp___2 ;

//Stmt9725:Leaf
time_t tmp___3 ;

//Stmt9726:Leaf
uintmax_t tmp___4 ;

//Stmt9727:Leaf
uintmax_t tmp___5 ;

//Stmt9728:Leaf
char *name___0 ;

//Stmt9729:Leaf
uintmax_t tmp___6 ;

//Stmt9730:Leaf
uintmax_t tmp___7 ;

//Stmt9731:Leaf
size_t tmp___8 ;

//Stmt9732:Leaf
size_t tmp___9 ;

//Stmt9733:Leaf
int tmp___10 ;

//Stmt9734:Leaf
int tmp___11 ;

//Stmt9735:Leaf
int tmp___12 ;

//Stmt9736:Leaf
int tmp___13 ;

//Stmt9737:Leaf
char mtimebuf[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;

//Stmt9738:Leaf
char nowbuf[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;

//Stmt9739:Leaf
char *tmp___14 ;

 
   {
//Stmt9740:Leaf
tmp___13 = ar_name(file->name);

//Stmt9741:Parent
if (tmp___13) {
//Stmt9677:Leaf
arname_used = 0;

//Stmt9678:Leaf
ar_parse_name(file->name, & arname, & memname);

//Stmt9679:Leaf
arfile = lookup_file(arname);

//Stmt9680:Parent
if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
//Stmt9618:Leaf
arfile = enter_file(arname);

//Stmt9619:Leaf
arname_used = 1;

     }

//Stmt9681:Leaf
mtime = f_mtime(arfile, search);

//Stmt9682:Parent
while ((unsigned long )arfile->renamed != (unsigned long )((struct file *)0)) {
//Stmt9620:Leaf
arfile = arfile->renamed;

     }

//Stmt9683:Parent
if (search) {
//Stmt9641:Leaf
tmp___2 = strcmp((char const   *)arfile->hname, (char const   *)arname);

//Stmt9642:Parent
if (tmp___2) {
//Stmt9626:Parent
if (! arname_used) {
//Stmt9621:Leaf
free((void *)arname);

//Stmt9622:Leaf
arname_used = 1;

         }

//Stmt9627:Leaf
arname = arfile->hname;

//Stmt9628:Leaf
tmp = strlen((char const   *)arname);

//Stmt9629:Leaf
arlen = (unsigned int )tmp;

//Stmt9630:Leaf
tmp___0 = strlen((char const   *)memname);

//Stmt9631:Leaf
memlen = (unsigned int )tmp___0;

//Stmt9632:Leaf
tmp___1 = xmalloc(((arlen + 1U) + memlen) + 2U);

//Stmt9633:Leaf
name = tmp___1;

//Stmt9634:Leaf
memmove((void *)name, (void const   *)arname, (size_t )arlen);

//Stmt9635:Leaf
*(name + arlen) = (char )'(';

//Stmt9636:Leaf
memmove((void *)((name + arlen) + 1), (void const   *)memname, (size_t )memlen);

//Stmt9637:Leaf
*(name + ((arlen + 1U) + memlen)) = (char )')';

//Stmt9638:Leaf
*(name + (((arlen + 1U) + memlen) + 1U)) = (char )'\000';

//Stmt9639:Parent
if ((unsigned long )arfile->name == (unsigned long )arfile->hname) {
//Stmt9623:Leaf
rename_file(file, name);

         } else {
//Stmt9624:Leaf
rehash_file(file, name);

         }

//Stmt9640:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt9625:Leaf
file = file->renamed;

         }

       }

     }

//Stmt9684:Parent
if (! arname_used) {
//Stmt9643:Leaf
free((void *)arname);

     }

//Stmt9685:Leaf
free((void *)memname);

//Stmt9686:Parent
if (mtime == 0xffffffffffffffffUL) {
//Stmt9644:Leaf
return ((uintmax_t )-1);

     }

//Stmt9687:Leaf
tmp___3 = ar_member_date(file->hname);

//Stmt9688:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt9645:Leaf
tmp___4 = (uintmax_t )1000000000;

     } else {
//Stmt9646:Leaf
tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

     }

//Stmt9689:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt9647:Leaf
tmp___5 = (uintmax_t )1000000000;

     } else {
//Stmt9648:Leaf
tmp___5 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

     }

//Stmt9690:Leaf
mtime = (uintmax_t )tmp___3 * tmp___4;

   } else {
//Stmt9691:Leaf
mtime = name_mtime(file->name);

//Stmt9692:Parent
if (mtime == 0xffffffffffffffffUL) {
//Stmt9676:Parent
if (search) {
//Stmt9675:Parent
if (! file->ignore_vpath) {
//Stmt9672:Leaf
name___0 = file->name;

//Stmt9673:Leaf
tmp___11 = vpath_search(& name___0, & mtime);

//Stmt9674:Parent
if (tmp___11) {
//Stmt9670:Leaf
goto _L;

           } else
           {
//Stmt9671:Parent
if ((int )*(name___0 + 0) == 45) {
//Stmt9669:Parent
if ((int )*(name___0 + 1) == 108) {
//Stmt9667:Leaf
tmp___12 = library_search(& name___0, & mtime);

//Stmt9668:Parent
if (tmp___12) {
                 _L: /* CIL Label */ 
                 {
//Stmt9650:Parent
if (mtime != 0UL) {
//Stmt9649:Leaf
file->last_mtime = mtime;

                 }
}

//Stmt9660:Leaf
tmp___8 = strlen((char const   *)name___0);

//Stmt9661:Leaf
tmp___9 = strlen((char const   *)file->name);

//Stmt9662:Leaf
tmp___10 = gpath_search(name___0, (int )((tmp___8 - tmp___9) - 1UL));

//Stmt9663:Parent
if (tmp___10) {
//Stmt9655:Leaf
rename_file(file, name___0);

//Stmt9656:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt9651:Leaf
file = file->renamed;

                   }

//Stmt9657:Parent
if (file->last_mtime) {
//Stmt9652:Leaf
tmp___7 = file->last_mtime;

                   } else {
//Stmt9653:Leaf
tmp___6 = f_mtime(file, 1);

//Stmt9654:Leaf
tmp___7 = tmp___6;

                   }

//Stmt9658:Leaf
return (tmp___7);

                 }

//Stmt9664:Leaf
rehash_file(file, name___0);

//Stmt9665:Parent
while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
//Stmt9659:Leaf
file = file->renamed;

                 }

//Stmt9666:Leaf
mtime = name_mtime(name___0);

               }

             }

           }
}


         }

       }

     }

   }

//Stmt9742:Parent
if (! clock_skew_detected) {
//Stmt9702:Parent
if (mtime != 0xffffffffffffffffUL) {
//Stmt9701:Parent
if (mtime > now) {
//Stmt9700:Parent
if (! file->updated) {
//Stmt9698:Leaf
now = file_timestamp_now();

//Stmt9699:Parent
if (mtime > now) {
//Stmt9693:Leaf
file_timestamp_sprintf(mtimebuf, mtime);

//Stmt9694:Leaf
file_timestamp_sprintf(nowbuf, now);

//Stmt9695:Leaf
tmp___14 = dcgettext((char const   *)((void *)0), "*** Warning: File `%s\' has modification time in the future (%s > %s)",
                                  5);

//Stmt9696:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___14,
                   file->name, mtimebuf, nowbuf);

//Stmt9697:Leaf
clock_skew_detected = 1;

           }

         }

       }

     }

   }

//Stmt9743:Parent
if (file->double_colon) {
//Stmt9703:Leaf
file = file->double_colon;

   }

//Stmt9744:Parent
while (1) {
//Stmt9709:Parent
if (mtime != 0xffffffffffffffffUL) {
//Stmt9707:Parent
if ((unsigned int )file->command_state == 0U) {
//Stmt9706:Parent
if (! file->tried_implicit) {
//Stmt9705:Parent
if (file->intermediate) {
//Stmt9704:Leaf
file->intermediate = 0U;

           }

         }

       }

     }

//Stmt9710:Leaf
file->last_mtime = mtime;

//Stmt9711:Leaf
file = file->prev;

//Stmt9712:Parent
if (! ((unsigned long )file != (unsigned long )((struct file *)0))) {
//Stmt9708:Leaf
break;

     }

   }

//Stmt9745:Leaf
return (mtime);

 }
}
 static uintmax_t name_mtime(char *name ) 
 { 
//Stmt9751:Leaf
struct stat st ;

//Stmt9752:Leaf
int tmp ;

//Stmt9753:Leaf
uintmax_t tmp___0 ;

//Stmt9754:Leaf
uintmax_t tmp___1 ;

 
   {
//Stmt9755:Leaf
tmp = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));

//Stmt9756:Parent
if (tmp < 0) {
//Stmt9746:Leaf
return ((uintmax_t )-1);

   }

//Stmt9757:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt9747:Leaf
tmp___0 = (uintmax_t )1000000000;

   } else {
//Stmt9748:Leaf
tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt9758:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt9749:Leaf
tmp___1 = (uintmax_t )1000000000;

   } else {
//Stmt9750:Leaf
tmp___1 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

   }

//Stmt9759:Leaf
return ((uintmax_t )st.st_mtim.tv_sec * tmp___0 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___1) / 1000000000UL);

 }
}
 static char *dirs[4]  = {      (char *)"/lib",      (char *)"/usr/lib",      (char *)"/usr/local/lib",      (char *)0};
 static char *libpatterns  =    (char *)((void *)0);
 static char *buf___0  =    (char *)((void *)0);
 static int buflen  =    0;
 static int libdir_maxlen  =    -1;
 static int library_search(char **lib , uintmax_t *mtime_ptr ) 
 { 
//Stmt9824:Leaf
char *libname ;

//Stmt9825:Leaf
uintmax_t mtime ;

//Stmt9826:Leaf
char *p ;

//Stmt9827:Leaf
char *p2 ;

//Stmt9828:Leaf
unsigned int len ;

//Stmt9829:Leaf
char *file ;

//Stmt9830:Leaf
char **dp ;

//Stmt9831:Leaf
int save ;

//Stmt9832:Leaf
char *tmp ;

//Stmt9833:Leaf
char *libbuf ;

//Stmt9834:Leaf
char *tmp___0 ;

//Stmt9835:Leaf
char c ;

//Stmt9836:Leaf
char *p3 ;

//Stmt9837:Leaf
char *p4 ;

//Stmt9838:Leaf
char *tmp___1 ;

//Stmt9839:Leaf
size_t tmp___2 ;

//Stmt9840:Leaf
int tmp___3 ;

//Stmt9841:Leaf
int l ;

//Stmt9842:Leaf
size_t tmp___4 ;

//Stmt9843:Leaf
size_t tmp___5 ;

//Stmt9844:Leaf
size_t tmp___6 ;

//Stmt9845:Leaf
size_t tmp___7 ;

 
   {
//Stmt9846:Leaf
libname = *lib + 2;

//Stmt9847:Parent
if (! libpatterns) {
//Stmt9760:Leaf
save = warn_undefined_variables_flag;

//Stmt9761:Leaf
warn_undefined_variables_flag = 0;

//Stmt9762:Leaf
tmp = variable_expand((char *)"$(strip $(.LIBPATTERNS))");

//Stmt9763:Leaf
libpatterns = xstrdup((char const   *)tmp);

//Stmt9764:Leaf
warn_undefined_variables_flag = save;

   }

//Stmt9848:Leaf
p2 = libpatterns;

//Stmt9849:Parent
while (1) {
//Stmt9803:Leaf
p = find_next_token(& p2, & len);

//Stmt9804:Parent
if (! ((unsigned long )p != (unsigned long )((char *)0))) {
//Stmt9765:Leaf
break;

     }

//Stmt9805:Leaf
tmp___0 = variable_expand((char *)"");

//Stmt9806:Leaf
libbuf = tmp___0;

//Stmt9807:Leaf
c = *(p + len);

//Stmt9808:Leaf
*(p + len) = (char )'\000';

//Stmt9809:Leaf
p3 = find_percent(p);

//Stmt9810:Parent
if (! p3) {
//Stmt9769:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), ".LIBPATTERNS element `%s\' is not a pattern",
                           5);

//Stmt9770:Leaf
error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, p);

//Stmt9771:Parent
while (len) {
//Stmt9766:Leaf
*p = (char )' ';

//Stmt9767:Leaf
len --;

//Stmt9768:Leaf
p ++;

       }

//Stmt9772:Leaf
*p = c;

//Stmt9773:Leaf
continue;

     }

//Stmt9811:Leaf
p4 = variable_buffer_output(libbuf, p, (unsigned int )(p3 - p));

//Stmt9812:Leaf
tmp___2 = strlen((char const   *)libname);

//Stmt9813:Leaf
p4 = variable_buffer_output(p4, libname, (unsigned int )tmp___2);

//Stmt9814:Leaf
p4 = variable_buffer_output(p4, p3 + 1, (unsigned int )((long )len - (p3 - p)));

//Stmt9815:Leaf
*(p + len) = c;

//Stmt9816:Leaf
mtime = name_mtime(libbuf);

//Stmt9817:Parent
if (mtime != 0xffffffffffffffffUL) {
//Stmt9775:Leaf
*lib = xstrdup((char const   *)libbuf);

//Stmt9776:Parent
if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
//Stmt9774:Leaf
*mtime_ptr = mtime;

       }

//Stmt9777:Leaf
return (1);

     }

//Stmt9818:Leaf
file = libbuf;

//Stmt9819:Leaf
tmp___3 = vpath_search(& file, mtime_ptr);

//Stmt9820:Parent
if (tmp___3) {
//Stmt9778:Leaf
*lib = file;

//Stmt9779:Leaf
return (1);

     }

//Stmt9821:Parent
if (! buflen) {
//Stmt9788:Leaf
dp = dirs;

//Stmt9789:Parent
while ((unsigned long )*dp != (unsigned long )((char *)0)) {
//Stmt9781:Leaf
tmp___4 = strlen((char const   *)*dp);

//Stmt9782:Leaf
l = (int )tmp___4;

//Stmt9783:Parent
if (l > libdir_maxlen) {
//Stmt9780:Leaf
libdir_maxlen = l;

         }

//Stmt9784:Leaf
dp ++;

       }

//Stmt9790:Leaf
tmp___5 = strlen((char const   *)libbuf);

//Stmt9791:Leaf
buflen = (int )tmp___5;

//Stmt9792:Leaf
buf___0 = xmalloc((unsigned int )((libdir_maxlen + buflen) + 2));

     } else {
//Stmt9793:Leaf
tmp___7 = strlen((char const   *)libbuf);

//Stmt9794:Parent
if ((size_t )buflen < tmp___7) {
//Stmt9785:Leaf
tmp___6 = strlen((char const   *)libbuf);

//Stmt9786:Leaf
buflen = (int )tmp___6;

//Stmt9787:Leaf
buf___0 = xrealloc(buf___0, (unsigned int )((libdir_maxlen + buflen) + 2));

       }

     }

//Stmt9822:Leaf
dp = dirs;

//Stmt9823:Parent
while ((unsigned long )*dp != (unsigned long )((char *)0)) {
//Stmt9799:Leaf
sprintf((char * __restrict  )buf___0, (char const   * __restrict  )"%s/%s",
               *dp, libbuf);

//Stmt9800:Leaf
mtime = name_mtime(buf___0);

//Stmt9801:Parent
if (mtime != 0xffffffffffffffffUL) {
//Stmt9796:Leaf
*lib = xstrdup((char const   *)buf___0);

//Stmt9797:Parent
if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
//Stmt9795:Leaf
*mtime_ptr = mtime;

         }

//Stmt9798:Leaf
return (1);

       }

//Stmt9802:Leaf
dp ++;

     }

   }

//Stmt9850:Leaf
return (0);

 }
}
 #pragma merger("0","/tmp/cil-ku_yXt8Q.i","-g,-O0")
 struct file *suffix_file  ;
 struct variable_set_list *create_new_variable_set(void) ;
 void print_variable_set(struct variable_set *set , char *prefix ) ;
 struct rule *pattern_rules  ;
 struct rule *last_pattern_rule  ;
 unsigned int num_pattern_rules  ;
 unsigned int max_pattern_deps  ;
 unsigned int max_pattern_targets  ;
 unsigned int max_pattern_dep_length  ;
 unsigned int maxsuffix  ;
 void install_pattern_rule(struct pspec *p , int terminal ) ;
 int new_pattern_rule(struct rule *rule , int override ) ;
 struct pattern_var *lookup_pattern_var(char *target ) ;
 static void freerule(struct rule *rule , struct rule *lastrule ) ;
 static struct pattern_var *pattern_vars  ;
 static struct pattern_var *last_pattern_var  ;
 void count_implicit_rule_limits(void) 
 { 
//Stmt9903:Leaf
char *name ;

//Stmt9904:Leaf
unsigned int namelen ;

//Stmt9905:Leaf
register struct rule *rule ;

//Stmt9906:Leaf
register struct rule *lastrule ;

//Stmt9907:Leaf
unsigned int ndeps ;

//Stmt9908:Leaf
register struct dep *dep ;

//Stmt9909:Leaf
struct rule *next ;

//Stmt9910:Leaf
unsigned int ntargets ;

//Stmt9911:Leaf
unsigned int len ;

//Stmt9912:Leaf
size_t tmp ;

//Stmt9913:Leaf
char *p ;

//Stmt9914:Leaf
char *tmp___0 ;

//Stmt9915:Leaf
char *p2 ;

//Stmt9916:Leaf
char *tmp___1 ;

//Stmt9917:Leaf
char *tmp___2 ;

//Stmt9918:Leaf
char *tmp___3 ;

//Stmt9919:Leaf
int tmp___4 ;

//Stmt9920:Leaf
int tmp___5 ;

 
   {
//Stmt9921:Leaf
max_pattern_deps = 0U;

//Stmt9922:Leaf
max_pattern_targets = max_pattern_deps;

//Stmt9923:Leaf
num_pattern_rules = max_pattern_targets;

//Stmt9924:Leaf
max_pattern_dep_length = 0U;

//Stmt9925:Leaf
name = (char *)0;

//Stmt9926:Leaf
namelen = 0U;

//Stmt9927:Leaf
rule = pattern_rules;

//Stmt9928:Leaf
lastrule = (struct rule *)0;

//Stmt9929:Parent
while ((unsigned long )rule != (unsigned long )((struct rule *)0)) {
//Stmt9892:Leaf
ndeps = 0U;

//Stmt9893:Leaf
next = rule->next;

//Stmt9894:Leaf
num_pattern_rules ++;

//Stmt9895:Leaf
ntargets = 0U;

//Stmt9896:Parent
while ((unsigned long )*(rule->targets + ntargets) != (unsigned long )((char *)0)) {
//Stmt9851:Leaf
ntargets ++;

     }

//Stmt9897:Parent
if (ntargets > max_pattern_targets) {
//Stmt9852:Leaf
max_pattern_targets = ntargets;

     }

//Stmt9898:Leaf
dep = rule->deps;

//Stmt9899:Parent
while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
//Stmt9880:Leaf
tmp = strlen((char const   *)dep->name);

//Stmt9881:Leaf
len = (unsigned int )tmp;

//Stmt9882:Leaf
tmp___0 = strrchr((char const   *)dep->name, '/');

//Stmt9883:Leaf
p = tmp___0;

//Stmt9884:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt9853:Leaf
tmp___1 = strchr((char const   *)dep->name, '%');

//Stmt9854:Leaf
tmp___2 = tmp___1;

       } else {
//Stmt9855:Leaf
tmp___2 = (char *)0;

       }

//Stmt9885:Leaf
p2 = tmp___2;

//Stmt9886:Leaf
ndeps ++;

//Stmt9887:Parent
if (len > max_pattern_dep_length) {
//Stmt9856:Leaf
max_pattern_dep_length = len;

       }

//Stmt9888:Parent
if ((unsigned long )p != (unsigned long )((char *)0)) {
//Stmt9878:Parent
if ((unsigned long )p2 > (unsigned long )p) {
//Stmt9869:Parent
if ((unsigned long )p == (unsigned long )dep->name) {
//Stmt9857:Leaf
p ++;

           }

//Stmt9870:Parent
if (p - dep->name > (long )namelen) {
//Stmt9859:Parent
if ((unsigned long )name != (unsigned long )((char *)0)) {
//Stmt9858:Leaf
free((void *)name);

             }

//Stmt9860:Leaf
namelen = (unsigned int )(p - dep->name);

//Stmt9861:Leaf
tmp___3 = xmalloc(namelen + 1U);

//Stmt9862:Leaf
name = tmp___3;

           }

//Stmt9871:Leaf
memmove((void *)name, (void const   *)dep->name, (size_t )(p - dep->name));

//Stmt9872:Leaf
*(name + (p - dep->name)) = (char )'\000';

//Stmt9873:Leaf
tmp___4 = dir_file_exists_p(name, (char *)"");

//Stmt9874:Parent
if (tmp___4) {
//Stmt9863:Leaf
tmp___5 = 0;

           } else {
//Stmt9864:Leaf
tmp___5 = 1;

           }

//Stmt9875:Leaf
dep->changed = tmp___5;

//Stmt9876:Parent
if (dep->changed) {
//Stmt9868:Parent
if ((int )*name == 47) {
//Stmt9865:Leaf
freerule(rule, lastrule);

//Stmt9866:Leaf
num_pattern_rules --;

//Stmt9867:Leaf
goto end_main_loop;

             }

           }

         } else {
//Stmt9877:Leaf
dep->changed = 0;

         }

       } else {
//Stmt9879:Leaf
dep->changed = 0;

       }

//Stmt9889:Leaf
dep = dep->next;

     }

//Stmt9900:Parent
if (ndeps > max_pattern_deps) {
//Stmt9890:Leaf
max_pattern_deps = ndeps;

     }

//Stmt9901:Leaf
lastrule = rule;

     end_main_loop: 
     {
//Stmt9891:Leaf
rule = next;

}
   }

//Stmt9930:Parent
if ((unsigned long )name != (unsigned long )((char *)0)) {
//Stmt9902:Leaf
free((void *)name);

   }

//Stmt9931:Leaf
return;

 }
}
 static void convert_suffix_rule(char *target , char *source , struct commands *cmds ) 
 { 
//Stmt9950:Leaf
char *targname ;

//Stmt9951:Leaf
char *targpercent ;

//Stmt9952:Leaf
char *depname ;

//Stmt9953:Leaf
char **names ;

//Stmt9954:Leaf
char **percents ;

//Stmt9955:Leaf
struct dep *deps ;

//Stmt9956:Leaf
unsigned int len ;

//Stmt9957:Leaf
size_t tmp ;

//Stmt9958:Leaf
char *tmp___0 ;

//Stmt9959:Leaf
void *tmp___1 ;

//Stmt9960:Leaf
char *tmp___2 ;

//Stmt9961:Leaf
size_t tmp___3 ;

//Stmt9962:Leaf
char *tmp___4 ;

 
   {
//Stmt9963:Parent
if ((unsigned long )target == (unsigned long )((char *)0)) {
//Stmt9932:Leaf
targname = savestring("(%.o)", 5U);

//Stmt9933:Leaf
targpercent = targname + 1;

   } else {
//Stmt9934:Leaf
tmp = strlen((char const   *)target);

//Stmt9935:Leaf
len = (unsigned int )tmp;

//Stmt9936:Leaf
targname = xmalloc((1U + len) + 1U);

//Stmt9937:Leaf
*(targname + 0) = (char )'%';

//Stmt9938:Leaf
memmove((void *)(targname + 1), (void const   *)target, (size_t )(len + 1U));

//Stmt9939:Leaf
targpercent = targname;

   }

//Stmt9964:Leaf
tmp___0 = xmalloc((unsigned int )(2UL * sizeof(char *)));

//Stmt9965:Leaf
names = (char **)tmp___0;

//Stmt9966:Leaf
tmp___1 = __builtin_alloca(2UL * sizeof(char *));

//Stmt9967:Leaf
percents = (char **)tmp___1;

//Stmt9968:Leaf
*(names + 0) = targname;

//Stmt9969:Leaf
*(percents + 0) = targpercent;

//Stmt9970:Leaf
tmp___2 = (char *)0;

//Stmt9971:Leaf
*(percents + 1) = tmp___2;

//Stmt9972:Leaf
*(names + 1) = tmp___2;

//Stmt9973:Parent
if ((unsigned long )source == (unsigned long )((char *)0)) {
//Stmt9940:Leaf
deps = (struct dep *)0;

   } else {
//Stmt9941:Leaf
tmp___3 = strlen((char const   *)source);

//Stmt9942:Leaf
len = (unsigned int )tmp___3;

//Stmt9943:Leaf
depname = xmalloc((1U + len) + 1U);

//Stmt9944:Leaf
*(depname + 0) = (char )'%';

//Stmt9945:Leaf
memmove((void *)(depname + 1), (void const   *)source, (size_t )(len + 1U));

//Stmt9946:Leaf
tmp___4 = xmalloc((unsigned int )sizeof(struct dep ));

//Stmt9947:Leaf
deps = (struct dep *)tmp___4;

//Stmt9948:Leaf
deps->next = (struct dep *)0;

//Stmt9949:Leaf
deps->name = depname;

   }

//Stmt9974:Leaf
create_pattern_rule(names, percents, 0, deps, cmds, 0);

//Stmt9975:Leaf
return;

 }
}
 void convert_to_pattern(void) 
 { 
//Stmt10065:Leaf
register struct dep *d ;

//Stmt10066:Leaf
register struct dep *d2 ;

//Stmt10067:Leaf
register struct file *f ;

//Stmt10068:Leaf
register char *rulename ;

//Stmt10069:Leaf
register unsigned int slen ;

//Stmt10070:Leaf
register unsigned int s2len ;

//Stmt10071:Leaf
register unsigned int namelen ;

//Stmt10072:Leaf
char *tmp ;

//Stmt10073:Leaf
size_t tmp___0 ;

//Stmt10074:Leaf
void *tmp___1 ;

//Stmt10075:Leaf
char *tmp___2 ;

//Stmt10076:Leaf
char *tmp___3 ;

//Stmt10077:Leaf
char *tmp___4 ;

//Stmt10078:Leaf
size_t tmp___5 ;

//Stmt10079:Leaf
char *tmp___6 ;

//Stmt10080:Leaf
char *tmp___7 ;

//Stmt10081:Leaf
size_t tmp___8 ;

//Stmt10082:Leaf
char *tmp___9 ;

//Stmt10083:Leaf
char *tmp___10 ;

//Stmt10084:Leaf
char *tmp___11 ;

//Stmt10085:Leaf
char *tmp___12 ;

//Stmt10086:Leaf
char *tmp___13 ;

//Stmt10087:Leaf
char *tmp___14 ;

//Stmt10088:Leaf
char *tmp___15 ;

//Stmt10089:Leaf
int tmp___16 ;

//Stmt10090:Leaf
char *tmp___17 ;

//Stmt10091:Leaf
char *tmp___18 ;

//Stmt10092:Leaf
char *tmp___19 ;

//Stmt10093:Leaf
char *tmp___20 ;

 
   {
//Stmt10094:Leaf
maxsuffix = 0U;

//Stmt10095:Leaf
d = suffix_file->deps;

//Stmt10096:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt9979:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt9976:Leaf
tmp = (d->file)->name;

     } else {
//Stmt9977:Leaf
tmp = d->name;

     }

//Stmt9980:Leaf
tmp___0 = strlen((char const   *)tmp);

//Stmt9981:Leaf
namelen = (unsigned int )tmp___0;

//Stmt9982:Parent
if (namelen > maxsuffix) {
//Stmt9978:Leaf
maxsuffix = namelen;

     }

//Stmt9983:Leaf
d = d->next;

   }

//Stmt10097:Leaf
tmp___1 = __builtin_alloca((unsigned long )(maxsuffix * 2U + 1U));

//Stmt10098:Leaf
rulename = (char *)tmp___1;

//Stmt10099:Leaf
d = suffix_file->deps;

//Stmt10100:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt10053:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt9984:Leaf
tmp___2 = (d->file)->name;

     } else {
//Stmt9985:Leaf
tmp___2 = d->name;

     }

//Stmt10054:Leaf
convert_suffix_rule(tmp___2, (char *)0, (struct commands *)0);

//Stmt10055:Leaf
f = d->file;

//Stmt10056:Parent
if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
//Stmt9988:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt9986:Leaf
tmp___3 = (d->file)->name;

       } else {
//Stmt9987:Leaf
tmp___3 = d->name;

       }

//Stmt9989:Leaf
convert_suffix_rule((char *)"", tmp___3, f->cmds);

     }

//Stmt10057:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt9990:Leaf
tmp___4 = (d->file)->name;

     } else {
//Stmt9991:Leaf
tmp___4 = d->name;

     }

//Stmt10058:Leaf
tmp___5 = strlen((char const   *)tmp___4);

//Stmt10059:Leaf
slen = (unsigned int )tmp___5;

//Stmt10060:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt9992:Leaf
tmp___6 = (d->file)->name;

     } else {
//Stmt9993:Leaf
tmp___6 = d->name;

     }

//Stmt10061:Leaf
memmove((void *)rulename, (void const   *)tmp___6, (size_t )slen);

//Stmt10062:Leaf
d2 = suffix_file->deps;

//Stmt10063:Parent
while ((unsigned long )d2 != (unsigned long )((struct dep *)0)) {
//Stmt10041:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt9994:Leaf
tmp___7 = (d2->file)->name;

       } else {
//Stmt9995:Leaf
tmp___7 = d2->name;

       }

//Stmt10042:Leaf
tmp___8 = strlen((char const   *)tmp___7);

//Stmt10043:Leaf
s2len = (unsigned int )tmp___8;

//Stmt10044:Parent
if (slen == s2len) {
//Stmt10022:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt9996:Leaf
tmp___9 = (d->file)->name;

         } else {
//Stmt9997:Leaf
tmp___9 = d->name;

         }

//Stmt10023:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt9998:Leaf
tmp___10 = (d2->file)->name;

         } else {
//Stmt9999:Leaf
tmp___10 = d2->name;

         }

//Stmt10024:Parent
if ((unsigned long )tmp___9 == (unsigned long )tmp___10) {
//Stmt10018:Leaf
goto __Cont;

         } else {
//Stmt10019:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10000:Leaf
tmp___11 = (d->file)->name;

           } else {
//Stmt10001:Leaf
tmp___11 = d->name;

           }

//Stmt10020:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt10002:Leaf
tmp___12 = (d2->file)->name;

           } else {
//Stmt10003:Leaf
tmp___12 = d2->name;

           }

//Stmt10021:Parent
if ((int )*tmp___11 == (int )*tmp___12) {
//Stmt10016:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10004:Leaf
tmp___13 = (d->file)->name;

             } else {
//Stmt10005:Leaf
tmp___13 = d->name;

             }

//Stmt10017:Parent
if ((int )*tmp___13 == 0) {
//Stmt10011:Leaf
goto __Cont;

             } else {
//Stmt10012:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt10006:Leaf
tmp___14 = (d2->file)->name;

               } else {
//Stmt10007:Leaf
tmp___14 = d2->name;

               }

//Stmt10013:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10008:Leaf
tmp___15 = (d->file)->name;

               } else {
//Stmt10009:Leaf
tmp___15 = d->name;

               }

//Stmt10014:Leaf
tmp___16 = strcmp((char const   *)(tmp___15 + 1), (char const   *)(tmp___14 + 1));

//Stmt10015:Parent
if (! tmp___16) {
//Stmt10010:Leaf
goto __Cont;

               }

             }

           }

         }

       }

//Stmt10045:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt10025:Leaf
tmp___17 = (d2->file)->name;

       } else {
//Stmt10026:Leaf
tmp___17 = d2->name;

       }

//Stmt10046:Leaf
memmove((void *)(rulename + slen), (void const   *)tmp___17, (size_t )(s2len + 1U));

//Stmt10047:Leaf
f = lookup_file(rulename);

//Stmt10048:Parent
if ((unsigned long )f == (unsigned long )((struct file *)0)) {
//Stmt10028:Leaf
goto __Cont;

       } else
       {
//Stmt10029:Parent
if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
//Stmt10027:Leaf
goto __Cont;

       }
}


//Stmt10049:Parent
if (s2len == 2U) {
//Stmt10035:Parent
if ((int )*(rulename + slen) == 46) {
//Stmt10034:Parent
if ((int )*(rulename + (slen + 1U)) == 97) {
//Stmt10032:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10030:Leaf
tmp___18 = (d->file)->name;

             } else {
//Stmt10031:Leaf
tmp___18 = d->name;

             }

//Stmt10033:Leaf
convert_suffix_rule((char *)0, tmp___18, f->cmds);

           }

         }

       }

//Stmt10050:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10036:Leaf
tmp___19 = (d->file)->name;

       } else {
//Stmt10037:Leaf
tmp___19 = d->name;

       }

//Stmt10051:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt10038:Leaf
tmp___20 = (d2->file)->name;

       } else {
//Stmt10039:Leaf
tmp___20 = d2->name;

       }

//Stmt10052:Leaf
convert_suffix_rule(tmp___20, tmp___19, f->cmds);

       __Cont: /* CIL Label */ 
       {
//Stmt10040:Leaf
d2 = d2->next;

}
     }

//Stmt10064:Leaf
d = d->next;

   }

//Stmt10101:Leaf
return;

 }
}
 int new_pattern_rule(struct rule *rule , int override ) 
 { 
//Stmt10170:Leaf
register struct rule *r ;

//Stmt10171:Leaf
register struct rule *lastrule ;

//Stmt10172:Leaf
register unsigned int i ;

//Stmt10173:Leaf
register unsigned int j ;

//Stmt10174:Leaf
int tmp ;

//Stmt10175:Leaf
register struct dep *d ;

//Stmt10176:Leaf
register struct dep *d2 ;

//Stmt10177:Leaf
char *tmp___0 ;

//Stmt10178:Leaf
char *tmp___1 ;

//Stmt10179:Leaf
char *tmp___2 ;

//Stmt10180:Leaf
char *tmp___3 ;

//Stmt10181:Leaf
char *tmp___4 ;

//Stmt10182:Leaf
char *tmp___5 ;

//Stmt10183:Leaf
char *tmp___6 ;

//Stmt10184:Leaf
int tmp___7 ;

 
   {
//Stmt10185:Leaf
rule->in_use = (char)0;

//Stmt10186:Leaf
rule->terminal = (char)0;

//Stmt10187:Leaf
rule->next = (struct rule *)0;

//Stmt10188:Leaf
lastrule = (struct rule *)0;

//Stmt10189:Leaf
r = pattern_rules;

//Stmt10190:Parent
while ((unsigned long )r != (unsigned long )((struct rule *)0)) {
//Stmt10162:Leaf
i = 0U;

//Stmt10163:Parent
while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
//Stmt10158:Leaf
j = 0U;

//Stmt10159:Parent
while ((unsigned long )*(r->targets + j) != (unsigned long )((char *)0)) {
//Stmt10108:Parent
if (! ((unsigned long )*(rule->targets + i) == (unsigned long )*(r->targets + j))) {
//Stmt10107:Parent
if ((int )*(*(rule->targets + i)) == (int )*(*(r->targets + j))) {
//Stmt10105:Parent
if (! ((int )*(*(rule->targets + i)) == 0)) {
//Stmt10103:Leaf
tmp = strcmp((char const   *)(*(rule->targets + i) + 1), (char const   *)(*(r->targets + j) + 1));

//Stmt10104:Parent
if (tmp) {
//Stmt10102:Leaf
break;

               }

             }

           } else {
//Stmt10106:Leaf
break;

           }

         }

//Stmt10109:Leaf
j ++;

       }

//Stmt10160:Parent
if ((unsigned long )*(r->targets + j) == (unsigned long )((char *)0)) {
//Stmt10154:Leaf
d = rule->deps;

//Stmt10155:Leaf
d2 = r->deps;

//Stmt10156:Parent
while (1) {
//Stmt10138:Parent
if ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt10111:Parent
if (! ((unsigned long )d2 != (unsigned long )((struct dep *)0))) {
//Stmt10110:Leaf
break;

             }

           } else {
//Stmt10112:Leaf
break;

           }

//Stmt10139:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10113:Leaf
tmp___0 = (d->file)->name;

           } else {
//Stmt10114:Leaf
tmp___0 = d->name;

           }

//Stmt10140:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt10115:Leaf
tmp___1 = (d2->file)->name;

           } else {
//Stmt10116:Leaf
tmp___1 = d2->name;

           }

//Stmt10141:Parent
if (! ((unsigned long )tmp___0 == (unsigned long )tmp___1)) {
//Stmt10135:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10117:Leaf
tmp___2 = (d->file)->name;

             } else {
//Stmt10118:Leaf
tmp___2 = d->name;

             }

//Stmt10136:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt10119:Leaf
tmp___3 = (d2->file)->name;

             } else {
//Stmt10120:Leaf
tmp___3 = d2->name;

             }

//Stmt10137:Parent
if ((int )*tmp___2 == (int )*tmp___3) {
//Stmt10132:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10121:Leaf
tmp___4 = (d->file)->name;

               } else {
//Stmt10122:Leaf
tmp___4 = d->name;

               }

//Stmt10133:Parent
if (! ((int )*tmp___4 == 0)) {
//Stmt10128:Parent
if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
//Stmt10123:Leaf
tmp___5 = (d2->file)->name;

                 } else {
//Stmt10124:Leaf
tmp___5 = d2->name;

                 }

//Stmt10129:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10125:Leaf
tmp___6 = (d->file)->name;

                 } else {
//Stmt10126:Leaf
tmp___6 = d->name;

                 }

//Stmt10130:Leaf
tmp___7 = strcmp((char const   *)(tmp___6 + 1), (char const   *)(tmp___5 + 1));

//Stmt10131:Parent
if (tmp___7) {
//Stmt10127:Leaf
break;

                 }

               }

             } else {
//Stmt10134:Leaf
break;

             }

           }

//Stmt10142:Leaf
d = d->next;

//Stmt10143:Leaf
d2 = d2->next;

         }

//Stmt10157:Parent
if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
//Stmt10153:Parent
if ((unsigned long )d2 == (unsigned long )((struct dep *)0)) {
//Stmt10152:Parent
if (override) {
//Stmt10146:Leaf
freerule(r, lastrule);

//Stmt10147:Parent
if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
//Stmt10144:Leaf
pattern_rules = rule;

               } else {
//Stmt10145:Leaf
last_pattern_rule->next = rule;

               }

//Stmt10148:Leaf
last_pattern_rule = rule;

//Stmt10149:Leaf
goto matched;

             } else {
//Stmt10150:Leaf
freerule(rule, (struct rule *)0);

//Stmt10151:Leaf
return (0);

             }

           }

         }

       }

//Stmt10161:Leaf
i ++;

     }

//Stmt10164:Leaf
lastrule = r;

//Stmt10165:Leaf
r = r->next;

   }

   matched: ;
//Stmt10191:Parent
if ((unsigned long )r == (unsigned long )((struct rule *)0)) {
//Stmt10168:Parent
if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
//Stmt10166:Leaf
pattern_rules = rule;

     } else {
//Stmt10167:Leaf
last_pattern_rule->next = rule;

     }

//Stmt10169:Leaf
last_pattern_rule = rule;

   }

//Stmt10192:Leaf
return (1);

 }
}
 void install_pattern_rule(struct pspec *p , int terminal ) 
 { 
//Stmt10202:Leaf
register struct rule *r ;

//Stmt10203:Leaf
char *ptr ;

//Stmt10204:Leaf
char *tmp ;

//Stmt10205:Leaf
char *tmp___0 ;

//Stmt10206:Leaf
char *tmp___1 ;

//Stmt10207:Leaf
char *tmp___2 ;

//Stmt10208:Leaf
size_t tmp___3 ;

//Stmt10209:Leaf
struct nameseq *tmp___4 ;

//Stmt10210:Leaf
struct nameseq *tmp___5 ;

//Stmt10211:Leaf
char *tmp___6 ;

//Stmt10212:Leaf
int tmp___7 ;

 
   {
//Stmt10213:Leaf
tmp = xmalloc((unsigned int )sizeof(struct rule ));

//Stmt10214:Leaf
r = (struct rule *)tmp;

//Stmt10215:Leaf
tmp___0 = xmalloc((unsigned int )(2UL * sizeof(char *)));

//Stmt10216:Leaf
r->targets = (char **)tmp___0;

//Stmt10217:Leaf
tmp___1 = xmalloc((unsigned int )(2UL * sizeof(char *)));

//Stmt10218:Leaf
r->suffixes = (char **)tmp___1;

//Stmt10219:Leaf
tmp___2 = xmalloc((unsigned int )(2UL * sizeof(unsigned int )));

//Stmt10220:Leaf
r->lens = (unsigned int *)tmp___2;

//Stmt10221:Leaf
*(r->targets + 1) = (char *)0;

//Stmt10222:Leaf
*(r->suffixes + 1) = (char *)0;

//Stmt10223:Leaf
*(r->lens + 1) = 0U;

//Stmt10224:Leaf
tmp___3 = strlen((char const   *)p->target);

//Stmt10225:Leaf
*(r->lens + 0) = (unsigned int )tmp___3;

//Stmt10226:Leaf
*(r->targets + 0) = savestring((char const   *)p->target, *(r->lens + 0));

//Stmt10227:Leaf
*(r->suffixes + 0) = find_percent(*(r->targets + 0));

//Stmt10228:Parent
if ((unsigned long )*(r->suffixes + 0) == (unsigned long )((char *)0)) {
//Stmt10193:Leaf
abort();

   } else {
//Stmt10194:Leaf
(*(r->suffixes + 0)) ++;

   }

//Stmt10229:Leaf
ptr = p->dep;

//Stmt10230:Leaf
tmp___4 = parse_file_seq(& ptr, '\000', (unsigned int )sizeof(struct dep ), 1);

//Stmt10231:Leaf
tmp___5 = multi_glob(tmp___4, (unsigned int )sizeof(struct dep ));

//Stmt10232:Leaf
r->deps = (struct dep *)tmp___5;

//Stmt10233:Leaf
tmp___7 = new_pattern_rule(r, 0);

//Stmt10234:Parent
if (tmp___7) {
//Stmt10195:Leaf
r->terminal = (char )terminal;

//Stmt10196:Leaf
tmp___6 = xmalloc((unsigned int )sizeof(struct commands ));

//Stmt10197:Leaf
r->cmds = (struct commands *)tmp___6;

//Stmt10198:Leaf
(r->cmds)->fileinfo.filenm = (char *)0;

//Stmt10199:Leaf
(r->cmds)->fileinfo.lineno = 0UL;

//Stmt10200:Leaf
(r->cmds)->commands = xstrdup((char const   *)p->commands);

//Stmt10201:Leaf
(r->cmds)->command_lines = (char **)0;

   }

//Stmt10235:Leaf
return;

 }
}
 static void freerule(struct rule *rule , struct rule *lastrule ) 
 { 
//Stmt10247:Leaf
struct rule *next ;

//Stmt10248:Leaf
register unsigned int i ;

//Stmt10249:Leaf
register struct dep *dep ;

//Stmt10250:Leaf
struct dep *t ;

 
   {
//Stmt10251:Leaf
next = rule->next;

//Stmt10252:Leaf
i = 0U;

//Stmt10253:Parent
while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
//Stmt10236:Leaf
free((void *)*(rule->targets + i));

//Stmt10237:Leaf
i ++;

   }

//Stmt10254:Leaf
dep = rule->deps;

//Stmt10255:Parent
while (dep) {
//Stmt10238:Leaf
t = dep->next;

//Stmt10239:Leaf
free((void *)((char *)dep));

//Stmt10240:Leaf
dep = t;

   }

//Stmt10256:Leaf
free((void *)((char *)rule->targets));

//Stmt10257:Leaf
free((void *)((char *)rule->suffixes));

//Stmt10258:Leaf
free((void *)((char *)rule->lens));

//Stmt10259:Leaf
free((void *)((char *)rule));

//Stmt10260:Parent
if ((unsigned long )pattern_rules == (unsigned long )rule) {
//Stmt10244:Parent
if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
//Stmt10241:Leaf
abort();

     } else {
//Stmt10242:Leaf
pattern_rules = next;

     }

   } else
   {
//Stmt10245:Parent
if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
//Stmt10243:Leaf
lastrule->next = next;

   }
}


//Stmt10261:Parent
if ((unsigned long )last_pattern_rule == (unsigned long )rule) {
//Stmt10246:Leaf
last_pattern_rule = lastrule;

   }

//Stmt10262:Leaf
return;

 }
}
 void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                          struct dep *deps , struct commands *commands , int override ) 
 { 
//Stmt10284:Leaf
register struct rule *r ;

//Stmt10285:Leaf
char *tmp ;

//Stmt10286:Leaf
register unsigned int max_targets ;

//Stmt10287:Leaf
register unsigned int i ;

//Stmt10288:Leaf
char *tmp___0 ;

//Stmt10289:Leaf
char *tmp___1 ;

//Stmt10290:Leaf
char *tmp___2 ;

//Stmt10291:Leaf
char *tmp___3 ;

//Stmt10292:Leaf
size_t tmp___4 ;

//Stmt10293:Leaf
char *tmp___5 ;

//Stmt10294:Leaf
char *tmp___6 ;

//Stmt10295:Leaf
char *tmp___7 ;

//Stmt10296:Leaf
char *tmp___8 ;

//Stmt10297:Leaf
int tmp___9 ;

 
   {
//Stmt10298:Leaf
tmp = xmalloc((unsigned int )sizeof(struct rule ));

//Stmt10299:Leaf
r = (struct rule *)tmp;

//Stmt10300:Leaf
r->cmds = commands;

//Stmt10301:Leaf
r->deps = deps;

//Stmt10302:Leaf
r->targets = targets;

//Stmt10303:Leaf
max_targets = 2U;

//Stmt10304:Leaf
tmp___0 = xmalloc((unsigned int )(2UL * sizeof(unsigned int )));

//Stmt10305:Leaf
r->lens = (unsigned int *)tmp___0;

//Stmt10306:Leaf
tmp___1 = xmalloc((unsigned int )(2UL * sizeof(char *)));

//Stmt10307:Leaf
r->suffixes = (char **)tmp___1;

//Stmt10308:Leaf
i = 0U;

//Stmt10309:Parent
while ((unsigned long )*(targets + i) != (unsigned long )((char *)0)) {
//Stmt10272:Parent
if (i == max_targets - 1U) {
//Stmt10263:Leaf
max_targets += 5U;

//Stmt10264:Leaf
tmp___2 = xrealloc((char *)r->lens, (unsigned int )((unsigned long )max_targets * sizeof(unsigned int )));

//Stmt10265:Leaf
r->lens = (unsigned int *)tmp___2;

//Stmt10266:Leaf
tmp___3 = xrealloc((char *)r->suffixes, (unsigned int )((unsigned long )max_targets * sizeof(char *)));

//Stmt10267:Leaf
r->suffixes = (char **)tmp___3;

     }

//Stmt10273:Leaf
tmp___4 = strlen((char const   *)*(targets + i));

//Stmt10274:Leaf
*(r->lens + i) = (unsigned int )tmp___4;

//Stmt10275:Parent
if ((unsigned long )target_percents == (unsigned long )((char **)0)) {
//Stmt10268:Leaf
tmp___5 = find_percent(*(targets + i));

//Stmt10269:Leaf
tmp___6 = tmp___5;

     } else {
//Stmt10270:Leaf
tmp___6 = *(target_percents + i);

     }

//Stmt10276:Leaf
*(r->suffixes + i) = tmp___6 + 1;

//Stmt10277:Parent
if ((unsigned long )*(r->suffixes + i) == (unsigned long )((char *)0)) {
//Stmt10271:Leaf
abort();

     }

//Stmt10278:Leaf
i ++;

   }

//Stmt10310:Parent
if (i < max_targets - 1U) {
//Stmt10279:Leaf
tmp___7 = xrealloc((char *)r->lens, (unsigned int )((unsigned long )(i + 1U) * sizeof(unsigned int )));

//Stmt10280:Leaf
r->lens = (unsigned int *)tmp___7;

//Stmt10281:Leaf
tmp___8 = xrealloc((char *)r->suffixes, (unsigned int )((unsigned long )(i + 1U) * sizeof(char *)));

//Stmt10282:Leaf
r->suffixes = (char **)tmp___8;

   }

//Stmt10311:Leaf
tmp___9 = new_pattern_rule(r, override);

//Stmt10312:Parent
if (tmp___9) {
//Stmt10283:Leaf
r->terminal = (char )terminal;

   }

//Stmt10313:Leaf
return;

 }
}
 struct pattern_var *create_pattern_var(char *target , char *suffix ) 
 { 
//Stmt10330:Leaf
register struct pattern_var *p ;

//Stmt10331:Leaf
unsigned int len ;

//Stmt10332:Leaf
size_t tmp ;

//Stmt10333:Leaf
int tmp___0 ;

//Stmt10334:Leaf
char *tmp___1 ;

 
   {
//Stmt10335:Leaf
p = (struct pattern_var *)0;

//Stmt10336:Leaf
tmp = strlen((char const   *)target);

//Stmt10337:Leaf
len = (unsigned int )tmp;

//Stmt10338:Leaf
p = pattern_vars;

//Stmt10339:Parent
while ((unsigned long )p != (unsigned long )((void *)0)) {
//Stmt10317:Parent
if (p->len == len) {
//Stmt10315:Leaf
tmp___0 = strcmp((char const   *)p->target, (char const   *)target);

//Stmt10316:Parent
if (! tmp___0) {
//Stmt10314:Leaf
break;

       }

     }

//Stmt10318:Leaf
p = p->next;

   }

//Stmt10340:Parent
if ((unsigned long )p == (unsigned long )((struct pattern_var *)0)) {
//Stmt10321:Leaf
tmp___1 = xmalloc((unsigned int )sizeof(struct pattern_var ));

//Stmt10322:Leaf
p = (struct pattern_var *)tmp___1;

//Stmt10323:Parent
if ((unsigned long )last_pattern_var != (unsigned long )((struct pattern_var *)0)) {
//Stmt10319:Leaf
last_pattern_var->next = p;

     } else {
//Stmt10320:Leaf
pattern_vars = p;

     }

//Stmt10324:Leaf
last_pattern_var = p;

//Stmt10325:Leaf
p->next = (struct pattern_var *)0;

//Stmt10326:Leaf
p->target = target;

//Stmt10327:Leaf
p->len = len;

//Stmt10328:Leaf
p->suffix = suffix + 1;

//Stmt10329:Leaf
p->vars = create_new_variable_set();

   }

//Stmt10341:Leaf
return (p);

 }
}
 struct pattern_var *lookup_pattern_var(char *target ) 
 { 
//Stmt10362:Leaf
struct pattern_var *p ;

//Stmt10363:Leaf
unsigned int targlen ;

//Stmt10364:Leaf
size_t tmp ;

//Stmt10365:Leaf
char *stem ;

//Stmt10366:Leaf
unsigned int stemlen ;

//Stmt10367:Leaf
int tmp___0 ;

//Stmt10368:Leaf
int tmp___1 ;

 
   {
//Stmt10369:Leaf
tmp = strlen((char const   *)target);

//Stmt10370:Leaf
targlen = (unsigned int )tmp;

//Stmt10371:Leaf
p = pattern_vars;

//Stmt10372:Parent
while ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
//Stmt10357:Parent
if (p->len > targlen) {
//Stmt10342:Leaf
goto __Cont;

     }

//Stmt10358:Leaf
stem = target + ((p->suffix - p->target) - 1L);

//Stmt10359:Leaf
stemlen = (targlen - p->len) + 1U;

//Stmt10360:Parent
if ((unsigned long )stem > (unsigned long )target) {
//Stmt10344:Leaf
tmp___0 = strncmp((char const   *)p->target, (char const   *)target, (size_t )(stem - target));

//Stmt10345:Parent
if (! (tmp___0 == 0)) {
//Stmt10343:Leaf
goto __Cont;

       }

     }

//Stmt10361:Parent
if ((int )*(p->suffix) == (int )*(stem + stemlen)) {
//Stmt10355:Parent
if ((int )*(p->suffix) == 0) {
//Stmt10353:Leaf
break;

       } else
       {
//Stmt10354:Parent
if ((unsigned long )(p->suffix + 1) == (unsigned long )(stem + (stemlen + 1U))) {
//Stmt10351:Leaf
break;

       } else
       {
//Stmt10352:Parent
if ((int )*(p->suffix + 1) == (int )*(stem + (stemlen + 1U))) {
//Stmt10350:Parent
if ((int )*(p->suffix + 1) == 0) {
//Stmt10347:Leaf
break;

         } else {
//Stmt10348:Leaf
tmp___1 = strcmp((char const   *)((p->suffix + 1) + 1), (char const   *)((stem + (stemlen + 1U)) + 1));

//Stmt10349:Parent
if (! tmp___1) {
//Stmt10346:Leaf
break;

           }

         }

       }
}

}


     }

     __Cont: /* CIL Label */ 
     {
//Stmt10356:Leaf
p = p->next;

}
   }

//Stmt10373:Leaf
return (p);

 }
}
 static void print_rule(struct rule *r ) 
 { 
//Stmt10386:Leaf
register unsigned int i ;

//Stmt10387:Leaf
register struct dep *d ;

//Stmt10388:Leaf
char *tmp ;

 
   {
//Stmt10389:Leaf
i = 0U;

//Stmt10390:Parent
while ((unsigned long )*(r->targets + i) != (unsigned long )((char *)0)) {
//Stmt10376:Leaf
fputs((char const   * __restrict  )*(r->targets + i), (FILE * __restrict  )stdout);

//Stmt10377:Parent
if ((unsigned long )*(r->targets + (i + 1U)) != (unsigned long )((char *)0)) {
//Stmt10374:Leaf
putchar(' ');

     } else {
//Stmt10375:Leaf
putchar(':');

     }

//Stmt10378:Leaf
i ++;

   }

//Stmt10391:Parent
if (r->terminal) {
//Stmt10379:Leaf
putchar(':');

   }

//Stmt10392:Leaf
d = r->deps;

//Stmt10393:Parent
while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
//Stmt10382:Parent
if ((unsigned long )d->name == (unsigned long )((char *)0)) {
//Stmt10380:Leaf
tmp = (d->file)->name;

     } else {
//Stmt10381:Leaf
tmp = d->name;

     }

//Stmt10383:Leaf
printf((char const   * __restrict  )" %s", tmp);

//Stmt10384:Leaf
d = d->next;

   }

//Stmt10394:Leaf
putchar('\n');

//Stmt10395:Parent
if ((unsigned long )r->cmds != (unsigned long )((struct commands *)0)) {
//Stmt10385:Leaf
print_commands(r->cmds);

   }

//Stmt10396:Leaf
return;

 }
}
 void print_rule_data_base(void) 
 { 
//Stmt10421:Leaf
register unsigned int rules ;

//Stmt10422:Leaf
register unsigned int terminal ;

//Stmt10423:Leaf
register struct rule *r ;

//Stmt10424:Leaf
char *tmp ;

//Stmt10425:Leaf
char *tmp___0 ;

//Stmt10426:Leaf
char *tmp___1 ;

//Stmt10427:Leaf
char *tmp___2 ;

//Stmt10428:Leaf
char *tmp___3 ;

//Stmt10429:Leaf
struct pattern_var *p ;

//Stmt10430:Leaf
char *tmp___4 ;

//Stmt10431:Leaf
char *tmp___5 ;

 
   {
//Stmt10432:Leaf
puts("\n# Implicit Rules");

//Stmt10433:Leaf
terminal = 0U;

//Stmt10434:Leaf
rules = terminal;

//Stmt10435:Leaf
r = pattern_rules;

//Stmt10436:Parent
while ((unsigned long )r != (unsigned long )((struct rule *)0)) {
//Stmt10398:Leaf
rules ++;

//Stmt10399:Leaf
putchar('\n');

//Stmt10400:Leaf
print_rule(r);

//Stmt10401:Parent
if (r->terminal) {
//Stmt10397:Leaf
terminal ++;

     }

//Stmt10402:Leaf
r = r->next;

   }

//Stmt10437:Parent
if (rules == 0U) {
//Stmt10403:Leaf
tmp = dcgettext((char const   *)((void *)0), "\n# No implicit rules.", 5);

//Stmt10404:Leaf
puts((char const   *)tmp);

   } else {
//Stmt10405:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "\n# %u implicit rules, %u",
                         5);

//Stmt10406:Leaf
printf((char const   * __restrict  )tmp___0, rules, terminal);

//Stmt10407:Leaf
printf((char const   * __restrict  )" (%.1f%%)", ((double )terminal / (double )rules) * 100.0);

//Stmt10408:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), " terminal.", 5);

//Stmt10409:Leaf
puts((char const   *)tmp___1);

   }

//Stmt10438:Parent
if (num_pattern_rules != rules) {
//Stmt10412:Parent
if (num_pattern_rules != 0U) {
//Stmt10410:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "BUG: num_pattern_rules wrong!  %u != %u",
                           5);

//Stmt10411:Leaf
fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, num_pattern_rules,
             rules);

     }

   }

//Stmt10439:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "\n# Pattern-specific variable values",
                       5);

//Stmt10440:Leaf
puts((char const   *)tmp___3);

//Stmt10441:Leaf
rules = 0U;

//Stmt10442:Leaf
p = pattern_vars;

//Stmt10443:Parent
while ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
//Stmt10413:Leaf
rules ++;

//Stmt10414:Leaf
printf((char const   * __restrict  )"\n%s :\n", p->target);

//Stmt10415:Leaf
print_variable_set((p->vars)->set, (char *)"# ");

//Stmt10416:Leaf
p = p->next;

   }

//Stmt10444:Parent
if (rules == 0U) {
//Stmt10417:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "\n# No pattern-specific variable values.",
                         5);

//Stmt10418:Leaf
puts((char const   *)tmp___4);

   } else {
//Stmt10419:Leaf
tmp___5 = dcgettext((char const   *)((void *)0), "\n# %u pattern-specific variable values",
                         5);

//Stmt10420:Leaf
printf((char const   * __restrict  )tmp___5, rules);

   }

//Stmt10445:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-aO4sE5WY.i","-g,-O0")
 void signame_init(void) ;
 char *sig_abbrev(int number ) ;
 int sig_number(char const   *abbrev ) ;
 static num_abbrev sig_table[130]  ;
 static int sig_table_nelts  =    0;
 static void init_sig(int number , char const   *abbrev , char const   *name ) 
 { 
//Stmt10450:Leaf
int tmp ;

 
   {
//Stmt10451:Parent
if (sig_table_nelts < 130) {
//Stmt10446:Leaf
sig_table[sig_table_nelts].number = number;

//Stmt10447:Leaf
tmp = sig_table_nelts;

//Stmt10448:Leaf
sig_table_nelts ++;

//Stmt10449:Leaf
sig_table[tmp].abbrev = abbrev;

   }

//Stmt10452:Leaf
return;

 }
}
 void signame_init(void) 
 { 
//Stmt10453:Leaf
char *tmp ;

//Stmt10454:Leaf
char *tmp___0 ;

//Stmt10455:Leaf
char *tmp___1 ;

//Stmt10456:Leaf
char *tmp___2 ;

//Stmt10457:Leaf
char *tmp___3 ;

//Stmt10458:Leaf
char *tmp___4 ;

//Stmt10459:Leaf
char *tmp___5 ;

//Stmt10460:Leaf
char *tmp___6 ;

//Stmt10461:Leaf
char *tmp___7 ;

//Stmt10462:Leaf
char *tmp___8 ;

//Stmt10463:Leaf
char *tmp___9 ;

//Stmt10464:Leaf
char *tmp___10 ;

//Stmt10465:Leaf
char *tmp___11 ;

//Stmt10466:Leaf
char *tmp___12 ;

//Stmt10467:Leaf
char *tmp___13 ;

//Stmt10468:Leaf
char *tmp___14 ;

//Stmt10469:Leaf
char *tmp___15 ;

//Stmt10470:Leaf
char *tmp___16 ;

//Stmt10471:Leaf
char *tmp___17 ;

//Stmt10472:Leaf
char *tmp___18 ;

//Stmt10473:Leaf
char *tmp___19 ;

//Stmt10474:Leaf
char *tmp___20 ;

//Stmt10475:Leaf
char *tmp___21 ;

//Stmt10476:Leaf
char *tmp___22 ;

//Stmt10477:Leaf
char *tmp___23 ;

//Stmt10478:Leaf
char *tmp___24 ;

//Stmt10479:Leaf
char *tmp___25 ;

//Stmt10480:Leaf
char *tmp___26 ;

//Stmt10481:Leaf
char *tmp___27 ;

//Stmt10482:Leaf
char *tmp___28 ;

//Stmt10483:Leaf
char *tmp___29 ;

//Stmt10484:Leaf
char *tmp___30 ;

//Stmt10485:Leaf
char *tmp___31 ;

 
   {
//Stmt10486:Leaf
tmp = dcgettext((char const   *)((void *)0), "Hangup", 5);

//Stmt10487:Leaf
init_sig(1, "HUP", (char const   *)tmp);

//Stmt10488:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "Interrupt", 5);

//Stmt10489:Leaf
init_sig(2, "INT", (char const   *)tmp___0);

//Stmt10490:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "Quit", 5);

//Stmt10491:Leaf
init_sig(3, "QUIT", (char const   *)tmp___1);

//Stmt10492:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "Illegal Instruction", 5);

//Stmt10493:Leaf
init_sig(4, "ILL", (char const   *)tmp___2);

//Stmt10494:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "Trace/breakpoint trap", 5);

//Stmt10495:Leaf
init_sig(5, "TRAP", (char const   *)tmp___3);

//Stmt10496:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "Aborted", 5);

//Stmt10497:Leaf
init_sig(6, "ABRT", (char const   *)tmp___4);

//Stmt10498:Leaf
tmp___5 = dcgettext((char const   *)((void *)0), "IOT trap", 5);

//Stmt10499:Leaf
init_sig(6, "IOT", (char const   *)tmp___5);

//Stmt10500:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "Floating point exception", 5);

//Stmt10501:Leaf
init_sig(8, "FPE", (char const   *)tmp___6);

//Stmt10502:Leaf
tmp___7 = dcgettext((char const   *)((void *)0), "Killed", 5);

//Stmt10503:Leaf
init_sig(9, "KILL", (char const   *)tmp___7);

//Stmt10504:Leaf
tmp___8 = dcgettext((char const   *)((void *)0), "Bus error", 5);

//Stmt10505:Leaf
init_sig(7, "BUS", (char const   *)tmp___8);

//Stmt10506:Leaf
tmp___9 = dcgettext((char const   *)((void *)0), "Segmentation fault", 5);

//Stmt10507:Leaf
init_sig(11, "SEGV", (char const   *)tmp___9);

//Stmt10508:Leaf
tmp___10 = dcgettext((char const   *)((void *)0), "Bad system call", 5);

//Stmt10509:Leaf
init_sig(31, "SYS", (char const   *)tmp___10);

//Stmt10510:Leaf
tmp___11 = dcgettext((char const   *)((void *)0), "Broken pipe", 5);

//Stmt10511:Leaf
init_sig(13, "PIPE", (char const   *)tmp___11);

//Stmt10512:Leaf
tmp___12 = dcgettext((char const   *)((void *)0), "Alarm clock", 5);

//Stmt10513:Leaf
init_sig(14, "ALRM", (char const   *)tmp___12);

//Stmt10514:Leaf
tmp___13 = dcgettext((char const   *)((void *)0), "Terminated", 5);

//Stmt10515:Leaf
init_sig(15, "TERM", (char const   *)tmp___13);

//Stmt10516:Leaf
tmp___14 = dcgettext((char const   *)((void *)0), "User defined signal 1", 5);

//Stmt10517:Leaf
init_sig(10, "USR1", (char const   *)tmp___14);

//Stmt10518:Leaf
tmp___15 = dcgettext((char const   *)((void *)0), "User defined signal 2", 5);

//Stmt10519:Leaf
init_sig(12, "USR2", (char const   *)tmp___15);

//Stmt10520:Leaf
tmp___16 = dcgettext((char const   *)((void *)0), "Child exited", 5);

//Stmt10521:Leaf
init_sig(17, "CHLD", (char const   *)tmp___16);

//Stmt10522:Leaf
tmp___17 = dcgettext((char const   *)((void *)0), "Child exited", 5);

//Stmt10523:Leaf
init_sig(17, "CLD", (char const   *)tmp___17);

//Stmt10524:Leaf
tmp___18 = dcgettext((char const   *)((void *)0), "Power failure", 5);

//Stmt10525:Leaf
init_sig(30, "PWR", (char const   *)tmp___18);

//Stmt10526:Leaf
tmp___19 = dcgettext((char const   *)((void *)0), "Stopped", 5);

//Stmt10527:Leaf
init_sig(20, "TSTP", (char const   *)tmp___19);

//Stmt10528:Leaf
tmp___20 = dcgettext((char const   *)((void *)0), "Stopped (tty input)", 5);

//Stmt10529:Leaf
init_sig(21, "TTIN", (char const   *)tmp___20);

//Stmt10530:Leaf
tmp___21 = dcgettext((char const   *)((void *)0), "Stopped (tty output)", 5);

//Stmt10531:Leaf
init_sig(22, "TTOU", (char const   *)tmp___21);

//Stmt10532:Leaf
tmp___22 = dcgettext((char const   *)((void *)0), "Stopped (signal)", 5);

//Stmt10533:Leaf
init_sig(19, "STOP", (char const   *)tmp___22);

//Stmt10534:Leaf
tmp___23 = dcgettext((char const   *)((void *)0), "CPU time limit exceeded", 5);

//Stmt10535:Leaf
init_sig(24, "XCPU", (char const   *)tmp___23);

//Stmt10536:Leaf
tmp___24 = dcgettext((char const   *)((void *)0), "File size limit exceeded", 5);

//Stmt10537:Leaf
init_sig(25, "XFSZ", (char const   *)tmp___24);

//Stmt10538:Leaf
tmp___25 = dcgettext((char const   *)((void *)0), "Virtual timer expired", 5);

//Stmt10539:Leaf
init_sig(26, "VTALRM", (char const   *)tmp___25);

//Stmt10540:Leaf
tmp___26 = dcgettext((char const   *)((void *)0), "Profiling timer expired", 5);

//Stmt10541:Leaf
init_sig(27, "PROF", (char const   *)tmp___26);

//Stmt10542:Leaf
tmp___27 = dcgettext((char const   *)((void *)0), "Window changed", 5);

//Stmt10543:Leaf
init_sig(28, "WINCH", (char const   *)tmp___27);

//Stmt10544:Leaf
tmp___28 = dcgettext((char const   *)((void *)0), "Continued", 5);

//Stmt10545:Leaf
init_sig(18, "CONT", (char const   *)tmp___28);

//Stmt10546:Leaf
tmp___29 = dcgettext((char const   *)((void *)0), "Urgent I/O condition", 5);

//Stmt10547:Leaf
init_sig(23, "URG", (char const   *)tmp___29);

//Stmt10548:Leaf
tmp___30 = dcgettext((char const   *)((void *)0), "I/O possible", 5);

//Stmt10549:Leaf
init_sig(29, "IO", (char const   *)tmp___30);

//Stmt10550:Leaf
tmp___31 = dcgettext((char const   *)((void *)0), "I/O possible", 5);

//Stmt10551:Leaf
init_sig(29, "POLL", (char const   *)tmp___31);

//Stmt10552:Leaf
return;

 }
}
 char *sig_abbrev(int number ) 
 { 
//Stmt10557:Leaf
int i ;

 
   {
//Stmt10558:Parent
if (sig_table_nelts == 0) {
//Stmt10553:Leaf
signame_init();

   }

//Stmt10559:Leaf
i = 0;

//Stmt10560:Parent
while (i < sig_table_nelts) {
//Stmt10555:Parent
if (sig_table[i].number == number) {
//Stmt10554:Leaf
return ((char *)sig_table[i].abbrev);

     }

//Stmt10556:Leaf
i ++;

   }

//Stmt10561:Leaf
return ((char *)((void *)0));

 }
}
 int sig_number(char const   *abbrev ) 
 { 
//Stmt10571:Leaf
int i ;

//Stmt10572:Leaf
int tmp ;

 
   {
//Stmt10573:Parent
if (sig_table_nelts == 0) {
//Stmt10562:Leaf
signame_init();

   }

//Stmt10574:Parent
if ((int const   )*(abbrev + 0) == 83) {
//Stmt10565:Parent
if ((int const   )*(abbrev + 1) == 73) {
//Stmt10564:Parent
if ((int const   )*(abbrev + 2) == 71) {
//Stmt10563:Leaf
abbrev += 3;

       }

     }

   }

//Stmt10575:Leaf
i = 0;

//Stmt10576:Parent
while (i < sig_table_nelts) {
//Stmt10569:Parent
if ((int const   )*(abbrev + 0) == (int const   )*(sig_table[i].abbrev + 0)) {
//Stmt10567:Leaf
tmp = strcmp(abbrev, sig_table[i].abbrev);

//Stmt10568:Parent
if (tmp == 0) {
//Stmt10566:Leaf
return (sig_table[i].number);

       }

     }

//Stmt10570:Leaf
i ++;

   }

//Stmt10577:Leaf
return (-1);

 }
}
 #pragma merger("0","/tmp/cil-3nJ90Uj5.i","-g,-O0")
 int export_all_variables  ;
 static struct variable *variable_table[523]  ;
 static struct variable_set global_variable_set  =    {variable_table, 523U};
 static struct variable_set_list global_setlist  =    {(struct variable_set_list *)0, & global_variable_set};
 struct variable_set_list *current_variable_set_list  =    & global_setlist;
 static struct variable *lookup_variable_in_set(char *name , unsigned int length___0 ,
                                                struct variable_set *set ) ;
 struct variable *define_variable_in_set(char *name , unsigned int length___0 , char *value ,
                                         enum variable_origin origin , int recursive ,
                                         struct variable_set *set , struct floc  const  *flocp ) 
 { 
//Stmt10604:Leaf
register unsigned int i ;

//Stmt10605:Leaf
register unsigned int hashval ;

//Stmt10606:Leaf
register struct variable *v ;

//Stmt10607:Leaf
int tmp ;

//Stmt10608:Leaf
char *tmp___0 ;

 
   {
//Stmt10609:Leaf
hashval = 0U;

//Stmt10610:Leaf
i = 0U;

//Stmt10611:Parent
while (i < length___0) {
//Stmt10578:Leaf
hashval += (unsigned int )*(name + i);

//Stmt10579:Leaf
hashval = (hashval << 7) + (hashval >> 20);

//Stmt10580:Leaf
i ++;

   }

//Stmt10612:Leaf
hashval %= set->buckets;

//Stmt10613:Leaf
v = *(set->table + hashval);

//Stmt10614:Parent
while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt10585:Parent
if ((int )*(v->name) == (int )*name) {
//Stmt10583:Leaf
tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));

//Stmt10584:Parent
if (tmp == 0) {
//Stmt10582:Parent
if ((int )*(v->name + length___0) == 0) {
//Stmt10581:Leaf
break;

         }

       }

     }

//Stmt10586:Leaf
v = v->next;

   }

//Stmt10615:Parent
if (env_overrides) {
//Stmt10588:Parent
if ((unsigned int )origin == 1U) {
//Stmt10587:Leaf
origin = (enum variable_origin )3;

     }

   }

//Stmt10616:Parent
if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt10599:Parent
if (env_overrides) {
//Stmt10590:Parent
if ((unsigned int )v->origin == 1U) {
//Stmt10589:Leaf
v->origin = (enum variable_origin )3;

       }

     }

//Stmt10600:Parent
if ((int )origin >= (int )v->origin) {
//Stmt10594:Parent
if ((unsigned long )v->value != (unsigned long )((char *)0)) {
//Stmt10591:Leaf
free((void *)v->value);

       }

//Stmt10595:Leaf
v->value = xstrdup((char const   *)value);

//Stmt10596:Parent
if ((unsigned long )flocp != (unsigned long )((struct floc  const  *)0)) {
//Stmt10592:Leaf
v->fileinfo = (struct floc )*flocp;

       } else {
//Stmt10593:Leaf
v->fileinfo.filenm = (char *)0;

       }

//Stmt10597:Leaf
v->origin = origin;

//Stmt10598:Leaf
v->recursive = (unsigned int )recursive;

     }

//Stmt10601:Leaf
return (v);

   }

//Stmt10617:Leaf
tmp___0 = xmalloc((unsigned int )sizeof(struct variable ));

//Stmt10618:Leaf
v = (struct variable *)tmp___0;

//Stmt10619:Leaf
v->name = savestring((char const   *)name, length___0);

//Stmt10620:Leaf
v->value = xstrdup((char const   *)value);

//Stmt10621:Parent
if ((unsigned long )flocp != (unsigned long )((struct floc  const  *)0)) {
//Stmt10602:Leaf
v->fileinfo = (struct floc )*flocp;

   } else {
//Stmt10603:Leaf
v->fileinfo.filenm = (char *)0;

   }

//Stmt10622:Leaf
v->origin = origin;

//Stmt10623:Leaf
v->recursive = (unsigned int )recursive;

//Stmt10624:Leaf
v->expanding = 0U;

//Stmt10625:Leaf
v->per_target = 0U;

//Stmt10626:Leaf
v->append = 0U;

//Stmt10627:Leaf
v->export = (enum variable_export )3;

//Stmt10628:Leaf
v->next = *(set->table + hashval);

//Stmt10629:Leaf
*(set->table + hashval) = v;

//Stmt10630:Leaf
return (v);

 }
}
 struct variable *lookup_variable(char *name , unsigned int length___0 ) 
 { 
//Stmt10651:Leaf
register struct variable_set_list *setlist ;

//Stmt10652:Leaf
struct variable *firstv ;

//Stmt10653:Leaf
register unsigned int i ;

//Stmt10654:Leaf
register unsigned int rawhash ;

//Stmt10655:Leaf
register struct variable_set *set ;

//Stmt10656:Leaf
register unsigned int hashval ;

//Stmt10657:Leaf
register struct variable *v ;

//Stmt10658:Leaf
int tmp ;

 
   {
//Stmt10659:Leaf
firstv = (struct variable *)0;

//Stmt10660:Leaf
rawhash = 0U;

//Stmt10661:Leaf
i = 0U;

//Stmt10662:Parent
while (i < length___0) {
//Stmt10631:Leaf
rawhash += (unsigned int )*(name + i);

//Stmt10632:Leaf
rawhash = (rawhash << 7) + (rawhash >> 20);

//Stmt10633:Leaf
i ++;

   }

//Stmt10663:Leaf
setlist = current_variable_set_list;

//Stmt10664:Parent
while ((unsigned long )setlist != (unsigned long )((struct variable_set_list *)0)) {
//Stmt10644:Leaf
set = setlist->set;

//Stmt10645:Leaf
hashval = rawhash % set->buckets;

//Stmt10646:Leaf
v = *(set->table + hashval);

//Stmt10647:Parent
while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt10638:Parent
if ((int )*(v->name) == (int )*name) {
//Stmt10636:Leaf
tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));

//Stmt10637:Parent
if (tmp == 0) {
//Stmt10635:Parent
if ((int )*(v->name + length___0) == 0) {
//Stmt10634:Leaf
break;

           }

         }

       }

//Stmt10639:Leaf
v = v->next;

     }

//Stmt10648:Parent
if (! v) {
//Stmt10640:Leaf
goto __Cont;

     }

//Stmt10649:Parent
if (! v->expanding) {
//Stmt10641:Leaf
return (v);

     }

//Stmt10650:Parent
if (! firstv) {
//Stmt10642:Leaf
firstv = v;

     }

     __Cont: /* CIL Label */ 
     {
//Stmt10643:Leaf
setlist = setlist->next;

}
   }

//Stmt10665:Leaf
return (firstv);

 }
}
 static struct variable *lookup_variable_in_set(char *name , unsigned int length___0 ,
                                                struct variable_set *set ) 
 { 
//Stmt10675:Leaf
register unsigned int i ;

//Stmt10676:Leaf
register unsigned int hash ;

//Stmt10677:Leaf
register struct variable *v ;

//Stmt10678:Leaf
int tmp ;

 
   {
//Stmt10679:Leaf
hash = 0U;

//Stmt10680:Leaf
i = 0U;

//Stmt10681:Parent
while (i < length___0) {
//Stmt10666:Leaf
hash += (unsigned int )*(name + i);

//Stmt10667:Leaf
hash = (hash << 7) + (hash >> 20);

//Stmt10668:Leaf
i ++;

   }

//Stmt10682:Leaf
hash %= set->buckets;

//Stmt10683:Leaf
v = *(set->table + hash);

//Stmt10684:Parent
while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt10673:Parent
if ((int )*(v->name) == (int )*name) {
//Stmt10671:Leaf
tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));

//Stmt10672:Parent
if (tmp == 0) {
//Stmt10670:Parent
if ((int )*(v->name + length___0) == 0) {
//Stmt10669:Leaf
return (v);

         }

       }

     }

//Stmt10674:Leaf
v = v->next;

   }

//Stmt10685:Leaf
return ((struct variable *)0);

 }
}
 void initialize_file_variables(struct file *file , int reading ) 
 { 
//Stmt10708:Leaf
register struct variable_set_list *l ;

//Stmt10709:Leaf
char *tmp ;

//Stmt10710:Leaf
char *tmp___0 ;

//Stmt10711:Leaf
char *tmp___1 ;

//Stmt10712:Leaf
struct pattern_var *p ;

//Stmt10713:Leaf
struct pattern_var *tmp___2 ;

//Stmt10714:Leaf
char *tmp___3 ;

 
   {
//Stmt10715:Leaf
l = file->variables;

//Stmt10716:Parent
if ((unsigned long )l == (unsigned long )((struct variable_set_list *)0)) {
//Stmt10686:Leaf
tmp = xmalloc((unsigned int )sizeof(struct variable_set_list ));

//Stmt10687:Leaf
l = (struct variable_set_list *)tmp;

//Stmt10688:Leaf
tmp___0 = xmalloc((unsigned int )sizeof(struct variable_set ));

//Stmt10689:Leaf
l->set = (struct variable_set *)tmp___0;

//Stmt10690:Leaf
(l->set)->buckets = 23U;

//Stmt10691:Leaf
tmp___1 = xmalloc((unsigned int )((unsigned long )(l->set)->buckets * sizeof(struct variable *)));

//Stmt10692:Leaf
(l->set)->table = (struct variable **)tmp___1;

//Stmt10693:Leaf
memset((void *)((char *)(l->set)->table), 0, (unsigned long )(l->set)->buckets * sizeof(struct variable *));

//Stmt10694:Leaf
file->variables = l;

   }

//Stmt10717:Parent
if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
//Stmt10695:Leaf
l->next = & global_setlist;

   } else {
//Stmt10696:Leaf
initialize_file_variables(file->parent, reading);

//Stmt10697:Leaf
l->next = (file->parent)->variables;

   }

//Stmt10718:Parent
if (! reading) {
//Stmt10705:Parent
if (! file->pat_searched) {
//Stmt10701:Leaf
tmp___2 = lookup_pattern_var(file->name);

//Stmt10702:Leaf
p = tmp___2;

//Stmt10703:Leaf
file->pat_searched = 1U;

//Stmt10704:Parent
if ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
//Stmt10698:Leaf
tmp___3 = xmalloc((unsigned int )sizeof(struct variable_set_list ));

//Stmt10699:Leaf
file->pat_variables = (struct variable_set_list *)tmp___3;

//Stmt10700:Leaf
(file->pat_variables)->set = (p->vars)->set;

       }

     }

   }

//Stmt10719:Parent
if ((unsigned long )file->pat_variables != (unsigned long )((struct variable_set_list *)0)) {
//Stmt10706:Leaf
(file->pat_variables)->next = l->next;

//Stmt10707:Leaf
l->next = file->pat_variables;

   }

//Stmt10720:Leaf
return;

 }
}
 void pop_variable_scope(void) 
 { 
//Stmt10730:Leaf
register struct variable_set_list *setlist ;

//Stmt10731:Leaf
register struct variable_set *set ;

//Stmt10732:Leaf
register unsigned int i ;

//Stmt10733:Leaf
register struct variable *next ;

//Stmt10734:Leaf
register struct variable *v ;

 
   {
//Stmt10735:Leaf
setlist = current_variable_set_list;

//Stmt10736:Leaf
set = setlist->set;

//Stmt10737:Leaf
current_variable_set_list = setlist->next;

//Stmt10738:Leaf
free((void *)((char *)setlist));

//Stmt10739:Leaf
i = 0U;

//Stmt10740:Parent
while (i < set->buckets) {
//Stmt10727:Leaf
next = *(set->table + i);

//Stmt10728:Parent
while ((unsigned long )next != (unsigned long )((struct variable *)0)) {
//Stmt10722:Leaf
v = next;

//Stmt10723:Leaf
next = v->next;

//Stmt10724:Leaf
free((void *)v->name);

//Stmt10725:Parent
if (v->value) {
//Stmt10721:Leaf
free((void *)v->value);

       }

//Stmt10726:Leaf
free((void *)((char *)v));

     }

//Stmt10729:Leaf
i ++;

   }

//Stmt10741:Leaf
free((void *)((char *)set->table));

//Stmt10742:Leaf
free((void *)((char *)set));

//Stmt10743:Leaf
return;

 }
}
 struct variable_set_list *create_new_variable_set(void) 
 { 
//Stmt10744:Leaf
register struct variable_set_list *setlist ;

//Stmt10745:Leaf
register struct variable_set *set ;

//Stmt10746:Leaf
char *tmp ;

//Stmt10747:Leaf
char *tmp___0 ;

//Stmt10748:Leaf
char *tmp___1 ;

 
   {
//Stmt10749:Leaf
tmp = xmalloc((unsigned int )sizeof(struct variable_set ));

//Stmt10750:Leaf
set = (struct variable_set *)tmp;

//Stmt10751:Leaf
set->buckets = 13U;

//Stmt10752:Leaf
tmp___0 = xmalloc((unsigned int )((unsigned long )set->buckets * sizeof(struct variable *)));

//Stmt10753:Leaf
set->table = (struct variable **)tmp___0;

//Stmt10754:Leaf
memset((void *)((char *)set->table), 0, (unsigned long )set->buckets * sizeof(struct variable *));

//Stmt10755:Leaf
tmp___1 = xmalloc((unsigned int )sizeof(struct variable_set_list ));

//Stmt10756:Leaf
setlist = (struct variable_set_list *)tmp___1;

//Stmt10757:Leaf
setlist->set = set;

//Stmt10758:Leaf
setlist->next = current_variable_set_list;

//Stmt10759:Leaf
return (setlist);

 }
}
 struct variable_set_list *push_new_variable_scope(void) 
 { 
 
 
{
//Stmt10760:Leaf
current_variable_set_list = create_new_variable_set();

//Stmt10761:Leaf
return (current_variable_set_list);

 }
}
 static void merge_variable_sets(struct variable_set *set0 , struct variable_set *set1 ) 
 { 
//Stmt10792:Leaf
register unsigned int bucket1 ;

//Stmt10793:Leaf
register struct variable *v1 ;

//Stmt10794:Leaf
struct variable *next ;

//Stmt10795:Leaf
unsigned int bucket0 ;

//Stmt10796:Leaf
register struct variable *v0 ;

//Stmt10797:Leaf
register char *n ;

//Stmt10798:Leaf
int tmp ;

 
   {
//Stmt10799:Leaf
bucket1 = 0U;

//Stmt10800:Parent
while (bucket1 < set1->buckets) {
//Stmt10789:Leaf
v1 = *(set1->table + bucket1);

//Stmt10790:Parent
while ((unsigned long )v1 != (unsigned long )((struct variable *)0)) {
//Stmt10782:Leaf
next = v1->next;

//Stmt10783:Parent
if (set1->buckets >= set0->buckets) {
//Stmt10765:Leaf
bucket0 = bucket1;

       } else {
//Stmt10766:Leaf
bucket0 = 0U;

//Stmt10767:Leaf
n = v1->name;

//Stmt10768:Parent
while ((int )*n != 0) {
//Stmt10762:Leaf
bucket0 += (unsigned int )*n;

//Stmt10763:Leaf
bucket0 = (bucket0 << 7) + (bucket0 >> 20);

//Stmt10764:Leaf
n ++;

         }

       }

//Stmt10784:Leaf
bucket0 %= set0->buckets;

//Stmt10785:Leaf
v0 = *(set0->table + bucket0);

//Stmt10786:Parent
while ((unsigned long )v0 != (unsigned long )((struct variable *)0)) {
//Stmt10776:Parent
if ((unsigned long )v0->name == (unsigned long )v1->name) {
//Stmt10774:Leaf
break;

         } else
         {
//Stmt10775:Parent
if ((int )*(v0->name) == (int )*(v1->name)) {
//Stmt10773:Parent
if ((int )*(v0->name) == 0) {
//Stmt10770:Leaf
break;

           } else {
//Stmt10771:Leaf
tmp = strcmp((char const   *)(v0->name + 1), (char const   *)(v1->name + 1));

//Stmt10772:Parent
if (! tmp) {
//Stmt10769:Leaf
break;

             }

           }

         }
}


//Stmt10777:Leaf
v0 = v0->next;

       }

//Stmt10787:Parent
if ((unsigned long )v0 == (unsigned long )((struct variable *)0)) {
//Stmt10778:Leaf
v1->next = *(set0->table + bucket0);

//Stmt10779:Leaf
*(set0->table + bucket0) = v1;

       } else {
//Stmt10780:Leaf
free((void *)v1->value);

//Stmt10781:Leaf
free((void *)((char *)v1));

       }

//Stmt10788:Leaf
v1 = next;

     }

//Stmt10791:Leaf
bucket1 ++;

   }

//Stmt10801:Leaf
return;

 }
}
 void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) 
 { 
//Stmt10814:Leaf
register struct variable_set_list *list0 ;

//Stmt10815:Leaf
struct variable_set_list *last0 ;

//Stmt10816:Leaf
struct variable_set_list *next ;

 
   {
//Stmt10817:Leaf
list0 = *setlist0;

//Stmt10818:Leaf
last0 = (struct variable_set_list *)0;

//Stmt10819:Parent
while (1) {
//Stmt10805:Parent
if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
//Stmt10803:Parent
if (! ((unsigned long )list0 != (unsigned long )((struct variable_set_list *)0))) {
//Stmt10802:Leaf
break;

       }

     } else {
//Stmt10804:Leaf
break;

     }

//Stmt10806:Leaf
next = setlist1;

//Stmt10807:Leaf
setlist1 = setlist1->next;

//Stmt10808:Leaf
merge_variable_sets(list0->set, next->set);

//Stmt10809:Leaf
last0 = list0;

//Stmt10810:Leaf
list0 = list0->next;

   }

//Stmt10820:Parent
if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
//Stmt10813:Parent
if ((unsigned long )last0 == (unsigned long )((struct variable_set_list *)0)) {
//Stmt10811:Leaf
*setlist0 = setlist1;

     } else {
//Stmt10812:Leaf
last0->next = setlist1;

     }

   }

//Stmt10821:Leaf
return;

 }
}
 void define_automatic_variables(void) 
 { 
//Stmt10841:Leaf
register struct variable *v ;

//Stmt10842:Leaf
char buf___1[200] ;

//Stmt10843:Leaf
char const   *tmp ;

//Stmt10844:Leaf
char const   *tmp___0 ;

 
   {
//Stmt10845:Leaf
sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%u", makelevel);

//Stmt10846:Leaf
define_variable_in_set((char *)"MAKELEVEL", 9U, buf___1, (enum variable_origin )1,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10847:Parent
if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
//Stmt10824:Leaf
tmp = "";

   } else
   {
//Stmt10825:Parent
if ((int )*(remote_description + 0) == 0) {
//Stmt10822:Leaf
tmp = "";

   } else {
//Stmt10823:Leaf
tmp = (char const   *)remote_description;

   }
}


//Stmt10848:Parent
if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
//Stmt10828:Leaf
tmp___0 = "";

   } else
   {
//Stmt10829:Parent
if ((int )*(remote_description + 0) == 0) {
//Stmt10826:Leaf
tmp___0 = "";

   } else {
//Stmt10827:Leaf
tmp___0 = "-";

   }
}


//Stmt10849:Leaf
sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%s%s%s", version_string,
           tmp___0, tmp);

//Stmt10850:Leaf
define_variable_in_set((char *)"MAKE_VERSION", 12U, buf___1, (enum variable_origin )0,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10851:Leaf
v = define_variable_in_set((char *)"SHELL", 5U, default_shell, (enum variable_origin )0,
                              0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10852:Leaf
v->export = (enum variable_export )0;

//Stmt10853:Parent
if ((int )*(v->value) == 0) {
//Stmt10837:Leaf
free((void *)v->value);

//Stmt10838:Leaf
v->origin = (enum variable_origin )2;

//Stmt10839:Leaf
v->value = xstrdup((char const   *)(default_shell));

   } else
   {
//Stmt10840:Parent
if ((unsigned int )v->origin == 1U) {
//Stmt10833:Leaf
free((void *)v->value);

//Stmt10834:Leaf
v->origin = (enum variable_origin )2;

//Stmt10835:Leaf
v->value = xstrdup((char const   *)(default_shell));

   } else
   {
//Stmt10836:Parent
if ((unsigned int )v->origin == 3U) {
//Stmt10830:Leaf
free((void *)v->value);

//Stmt10831:Leaf
v->origin = (enum variable_origin )2;

//Stmt10832:Leaf
v->value = xstrdup((char const   *)(default_shell));

   }
}

}


//Stmt10854:Leaf
v = define_variable_in_set((char *)"MAKEFILES", 9U, (char *)"", (enum variable_origin )0,
                              0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10855:Leaf
v->export = (enum variable_export )2;

//Stmt10856:Leaf
define_variable_in_set((char *)"@D", 2U, (char *)"$(patsubst %/,%,$(dir $@))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10857:Leaf
define_variable_in_set((char *)"%D", 2U, (char *)"$(patsubst %/,%,$(dir $%))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10858:Leaf
define_variable_in_set((char *)"*D", 2U, (char *)"$(patsubst %/,%,$(dir $*))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10859:Leaf
define_variable_in_set((char *)"<D", 2U, (char *)"$(patsubst %/,%,$(dir $<))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10860:Leaf
define_variable_in_set((char *)"?D", 2U, (char *)"$(patsubst %/,%,$(dir $?))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10861:Leaf
define_variable_in_set((char *)"^D", 2U, (char *)"$(patsubst %/,%,$(dir $^))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10862:Leaf
define_variable_in_set((char *)"+D", 2U, (char *)"$(patsubst %/,%,$(dir $+))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10863:Leaf
define_variable_in_set((char *)"@F", 2U, (char *)"$(notdir $@)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10864:Leaf
define_variable_in_set((char *)"%F", 2U, (char *)"$(notdir $%)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10865:Leaf
define_variable_in_set((char *)"*F", 2U, (char *)"$(notdir $*)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10866:Leaf
define_variable_in_set((char *)"<F", 2U, (char *)"$(notdir $<)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10867:Leaf
define_variable_in_set((char *)"?F", 2U, (char *)"$(notdir $?)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10868:Leaf
define_variable_in_set((char *)"^F", 2U, (char *)"$(notdir $^)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10869:Leaf
define_variable_in_set((char *)"+F", 2U, (char *)"$(notdir $+)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt10870:Leaf
return;

 }
}
 char **target_environment(struct file *file ) 
 { 
//Stmt10991:Leaf
struct variable_set_list *set_list ;

//Stmt10992:Leaf
register struct variable_set_list *s ;

//Stmt10993:Leaf
struct variable_bucket **table ;

//Stmt10994:Leaf
unsigned int buckets ;

//Stmt10995:Leaf
register unsigned int i ;

//Stmt10996:Leaf
register unsigned int nvariables ;

//Stmt10997:Leaf
char **result___0 ;

//Stmt10998:Leaf
unsigned int mklev_hash ;

//Stmt10999:Leaf
char *p ;

//Stmt11000:Leaf
char *tmp ;

//Stmt11001:Leaf
void *tmp___0 ;

//Stmt11002:Leaf
register struct variable_set *set ;

//Stmt11003:Leaf
register struct variable *v ;

//Stmt11004:Leaf
unsigned int j ;

//Stmt11005:Leaf
register struct variable_bucket *ov ;

//Stmt11006:Leaf
register char *p___0 ;

//Stmt11007:Leaf
int tmp___1 ;

//Stmt11008:Leaf
struct variable *gv ;

//Stmt11009:Leaf
size_t tmp___2 ;

//Stmt11010:Leaf
register char *np ;

//Stmt11011:Leaf
int tmp___3 ;

//Stmt11012:Leaf
register struct variable_bucket *entry ;

//Stmt11013:Leaf
void *tmp___4 ;

//Stmt11014:Leaf
char *tmp___5 ;

//Stmt11015:Leaf
register struct variable_bucket *b ;

//Stmt11016:Leaf
register struct variable *v___0 ;

//Stmt11017:Leaf
char *value ;

//Stmt11018:Leaf
char *tmp___6 ;

//Stmt11019:Leaf
unsigned int tmp___7 ;

//Stmt11020:Leaf
unsigned int tmp___8 ;

//Stmt11021:Leaf
char *tmp___9 ;

 
   {
//Stmt11022:Parent
if ((unsigned long )file == (unsigned long )((struct file *)0)) {
//Stmt10871:Leaf
set_list = current_variable_set_list;

   } else {
//Stmt10872:Leaf
set_list = file->variables;

   }

//Stmt11023:Leaf
s = set_list;

//Stmt11024:Leaf
buckets = (s->set)->buckets;

//Stmt11025:Leaf
s = s->next;

//Stmt11026:Parent
while ((unsigned long )s != (unsigned long )((struct variable_set_list *)0)) {
//Stmt10874:Parent
if ((s->set)->buckets < buckets) {
//Stmt10873:Leaf
buckets = (s->set)->buckets;

     }

//Stmt10875:Leaf
s = s->next;

   }

//Stmt11027:Leaf
p = (char *)"MAKELEVEL";

//Stmt11028:Leaf
mklev_hash = 0U;

//Stmt11029:Parent
while ((int )*p != 0) {
//Stmt10876:Leaf
tmp = p;

//Stmt10877:Leaf
p ++;

//Stmt10878:Leaf
mklev_hash += (unsigned int )*tmp;

//Stmt10879:Leaf
mklev_hash = (mklev_hash << 7) + (mklev_hash >> 20);

   }

//Stmt11030:Leaf
tmp___0 = __builtin_alloca((unsigned long )buckets * sizeof(struct variable_bucket *));

//Stmt11031:Leaf
table = (struct variable_bucket **)tmp___0;

//Stmt11032:Leaf
memset((void *)((char *)table), 0, (unsigned long )buckets * sizeof(struct variable_bucket *));

//Stmt11033:Leaf
nvariables = 0U;

//Stmt11034:Leaf
s = set_list;

//Stmt11035:Parent
while ((unsigned long )s != (unsigned long )((struct variable_set_list *)0)) {
//Stmt10964:Leaf
set = s->set;

//Stmt10965:Leaf
i = 0U;

//Stmt10966:Parent
while (i < set->buckets) {
//Stmt10961:Leaf
v = *(set->table + i);

//Stmt10962:Parent
while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt10952:Leaf
j = i % buckets;

//Stmt10953:Leaf
p___0 = v->name;

//Stmt10954:Parent
if (i == mklev_hash % set->buckets) {
//Stmt10887:Parent
if ((unsigned long )v->name == (unsigned long )"MAKELEVEL") {
//Stmt10885:Leaf
goto __Cont;

           } else
           {
//Stmt10886:Parent
if ((int )*(v->name) == (int )*"MAKELEVEL") {
//Stmt10884:Parent
if ((int )*(v->name) == 0) {
//Stmt10881:Leaf
goto __Cont;

             } else {
//Stmt10882:Leaf
tmp___1 = strcmp((char const   *)(v->name + 1), "MAKELEVEL" + 1);

//Stmt10883:Parent
if (! tmp___1) {
//Stmt10880:Leaf
goto __Cont;

               }

             }

           }
}


         }

//Stmt10955:Parent
if (v->per_target) {
//Stmt10892:Parent
if ((unsigned int )v->export == 3U) {
//Stmt10889:Leaf
tmp___2 = strlen((char const   *)v->name);

//Stmt10890:Leaf
gv = lookup_variable_in_set(v->name, (unsigned int )tmp___2, & global_variable_set);

//Stmt10891:Parent
if (gv) {
//Stmt10888:Leaf
v->export = gv->export;

             }

           }

         }

//Stmt10956:Parent
switch ((unsigned int )v->export) {
         case 3U:; 
//Stmt10896:Parent
if ((unsigned int )v->origin == 0U) {
//Stmt10894:Leaf
goto __Cont;

         } else
         {
//Stmt10895:Parent
if ((unsigned int )v->origin == 6U) {
//Stmt10893:Leaf
goto __Cont;

         }
}


//Stmt10924:Parent
if (! export_all_variables) {
//Stmt10900:Parent
if ((unsigned int )v->origin != 4U) {
//Stmt10899:Parent
if ((unsigned int )v->origin != 1U) {
//Stmt10898:Parent
if ((unsigned int )v->origin != 3U) {
//Stmt10897:Leaf
goto __Cont;

               }

             }

           }

         }

//Stmt10925:Parent
if ((int )*p___0 != 95) {
//Stmt10907:Parent
if ((int )*p___0 < 65) {
//Stmt10905:Leaf
goto _L;

           } else
           {
//Stmt10906:Parent
if ((int )*p___0 > 90) {
             _L: /* CIL Label */ 
             {
//Stmt10904:Parent
if ((int )*p___0 < 97) {
//Stmt10902:Leaf
goto __Cont;

             } else
             {
//Stmt10903:Parent
if ((int )*p___0 > 122) {
//Stmt10901:Leaf
goto __Cont;

             }
}

}

           }
}


         }

//Stmt10926:Leaf
p___0 ++;

//Stmt10927:Parent
while ((int )*p___0 != 0) {
//Stmt10919:Parent
if ((int )*p___0 != 95) {
//Stmt10917:Parent
if ((int )*p___0 < 97) {
//Stmt10915:Leaf
goto _L___1;

             } else
             {
//Stmt10916:Parent
if ((int )*p___0 > 122) {
               _L___1: /* CIL Label */ 
               {
//Stmt10914:Parent
if ((int )*p___0 < 65) {
//Stmt10912:Leaf
goto _L___0;

               } else
               {
//Stmt10913:Parent
if ((int )*p___0 > 90) {
                 _L___0: /* CIL Label */ 
                 {
//Stmt10911:Parent
if ((int )*p___0 < 48) {
//Stmt10909:Leaf
goto __Cont___0;

                 } else
                 {
//Stmt10910:Parent
if ((int )*p___0 > 57) {
//Stmt10908:Leaf
goto __Cont___0;

                 }
}

}

               }
}

}

             }
}


           }

           __Cont___0: /* CIL Label */ 
           {
//Stmt10918:Leaf
p___0 ++;

}
         }

//Stmt10928:Parent
if ((int )*p___0 != 0) {
//Stmt10920:Leaf
goto __Cont;

         }

         break;
         case 0U:; 
         break;
         case 1U:; 
//Stmt10921:Leaf
goto __Cont;

         case 2U:; 
//Stmt10923:Parent
if ((unsigned int )v->origin == 0U) {
//Stmt10922:Leaf
goto __Cont;

         }

         break;
         }

//Stmt10957:Parent
if (set->buckets != buckets) {
//Stmt10932:Leaf
j = 0U;

//Stmt10933:Leaf
np = v->name;

//Stmt10934:Parent
while ((int )*np != 0) {
//Stmt10929:Leaf
j += (unsigned int )*np;

//Stmt10930:Leaf
j = (j << 7) + (j >> 20);

//Stmt10931:Leaf
np ++;

           }

//Stmt10935:Leaf
j %= buckets;

         }

//Stmt10958:Leaf
ov = *(table + j);

//Stmt10959:Parent
while ((unsigned long )ov != (unsigned long )((struct variable_bucket *)0)) {
//Stmt10943:Parent
if ((unsigned long )v->name == (unsigned long )(ov->variable)->name) {
//Stmt10941:Leaf
break;

           } else
           {
//Stmt10942:Parent
if ((int )*(v->name) == (int )*((ov->variable)->name)) {
//Stmt10940:Parent
if ((int )*(v->name) == 0) {
//Stmt10937:Leaf
break;

             } else {
//Stmt10938:Leaf
tmp___3 = strcmp((char const   *)(v->name + 1), (char const   *)((ov->variable)->name + 1));

//Stmt10939:Parent
if (! tmp___3) {
//Stmt10936:Leaf
break;

               }

             }

           }
}


//Stmt10944:Leaf
ov = ov->next;

         }

//Stmt10960:Parent
if ((unsigned long )ov == (unsigned long )((struct variable_bucket *)0)) {
//Stmt10945:Leaf
tmp___4 = __builtin_alloca(sizeof(struct variable_bucket ));

//Stmt10946:Leaf
entry = (struct variable_bucket *)tmp___4;

//Stmt10947:Leaf
entry->next = *(table + j);

//Stmt10948:Leaf
entry->variable = v;

//Stmt10949:Leaf
*(table + j) = entry;

//Stmt10950:Leaf
nvariables ++;

         }

         __Cont: /* CIL Label */ 
         {
//Stmt10951:Leaf
v = v->next;

}
       }

//Stmt10963:Leaf
i ++;

     }

//Stmt10967:Leaf
s = s->next;

   }

//Stmt11036:Leaf
tmp___5 = xmalloc((unsigned int )((unsigned long )(nvariables + 2U) * sizeof(char *)));

//Stmt11037:Leaf
result___0 = (char **)tmp___5;

//Stmt11038:Leaf
nvariables = 0U;

//Stmt11039:Leaf
i = 0U;

//Stmt11040:Parent
while (i < buckets) {
//Stmt10988:Leaf
b = *(table + i);

//Stmt10989:Parent
while ((unsigned long )b != (unsigned long )((struct variable_bucket *)0)) {
//Stmt10985:Leaf
v___0 = b->variable;

//Stmt10986:Parent
if (v___0->recursive) {
//Stmt10981:Parent
if ((unsigned int )v___0->origin != 1U) {
//Stmt10977:Parent
if ((unsigned int )v___0->origin != 3U) {
//Stmt10968:Leaf
tmp___6 = recursively_expand(v___0);

//Stmt10969:Leaf
value = tmp___6;

//Stmt10970:Leaf
tmp___7 = nvariables;

//Stmt10971:Leaf
nvariables ++;

//Stmt10972:Leaf
*(result___0 + tmp___7) = concat(v___0->name, (char *)"=", value);

//Stmt10973:Leaf
free((void *)value);

           } else {
//Stmt10974:Leaf
tmp___8 = nvariables;

//Stmt10975:Leaf
nvariables ++;

//Stmt10976:Leaf
*(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);

           }

         } else {
//Stmt10978:Leaf
tmp___8 = nvariables;

//Stmt10979:Leaf
nvariables ++;

//Stmt10980:Leaf
*(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);

         }

       } else {
//Stmt10982:Leaf
tmp___8 = nvariables;

//Stmt10983:Leaf
nvariables ++;

//Stmt10984:Leaf
*(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);

       }

//Stmt10987:Leaf
b = b->next;

     }

//Stmt10990:Leaf
i ++;

   }

//Stmt11041:Leaf
tmp___9 = xmalloc(100U);

//Stmt11042:Leaf
*(result___0 + nvariables) = tmp___9;

//Stmt11043:Leaf
sprintf((char * __restrict  )*(result___0 + nvariables), (char const   * __restrict  )"MAKELEVEL=%u",
           makelevel + 1U);

//Stmt11044:Leaf
nvariables ++;

//Stmt11045:Leaf
*(result___0 + nvariables) = (char *)0;

//Stmt11046:Leaf
return (result___0);

 }
}
 struct variable *try_variable_definition(struct floc  const  *flocp , char *line ,
                                          enum variable_origin origin , int target_var ) 
 { 
//Stmt11143:Leaf
register int c ;

//Stmt11144:Leaf
register char *p ;

//Stmt11145:Leaf
register char *beg ;

//Stmt11146:Leaf
register char *end ;

//Stmt11147:Leaf
enum __anonenum_flavor_56 flavor ;

//Stmt11148:Leaf
char *name ;

//Stmt11149:Leaf
char *expanded_name ;

//Stmt11150:Leaf
char *value ;

//Stmt11151:Leaf
char *alloc_value ;

//Stmt11152:Leaf
struct variable *v ;

//Stmt11153:Leaf
int append ;

//Stmt11154:Leaf
char *tmp ;

//Stmt11155:Leaf
char *tmp___0 ;

//Stmt11156:Leaf
char *tmp___1 ;

//Stmt11157:Leaf
char *tmp___2 ;

//Stmt11158:Leaf
char closeparen ;

//Stmt11159:Leaf
int count ;

//Stmt11160:Leaf
char *tmp___3 ;

//Stmt11161:Leaf
unsigned short const   **tmp___4 ;

//Stmt11162:Leaf
void *tmp___5 ;

//Stmt11163:Leaf
char *tmp___6 ;

//Stmt11164:Leaf
size_t tmp___7 ;

//Stmt11165:Leaf
size_t tmp___8 ;

//Stmt11166:Leaf
unsigned int oldlen ;

//Stmt11167:Leaf
unsigned int newlen ;

//Stmt11168:Leaf
size_t tmp___9 ;

//Stmt11169:Leaf
size_t tmp___10 ;

//Stmt11170:Leaf
void *tmp___11 ;

//Stmt11171:Leaf
size_t tmp___12 ;

 
   {
//Stmt11172:Leaf
p = line;

//Stmt11173:Leaf
flavor = (enum __anonenum_flavor_56 )0;

//Stmt11174:Leaf
alloc_value = (char *)((void *)0);

//Stmt11175:Leaf
append = 0;

//Stmt11176:Parent
while (1) {
//Stmt11096:Leaf
tmp = p;

//Stmt11097:Leaf
p ++;

//Stmt11098:Leaf
c = (int )*tmp;

//Stmt11099:Parent
if (c == 0) {
//Stmt11048:Leaf
return ((struct variable *)0);

     } else
     {
//Stmt11049:Parent
if (c == 35) {
//Stmt11047:Leaf
return ((struct variable *)0);

     }
}


//Stmt11100:Parent
if (c == 61) {
//Stmt11092:Leaf
end = p - 1;

//Stmt11093:Leaf
flavor = (enum __anonenum_flavor_56 )2;

//Stmt11094:Leaf
break;

     } else
     {
//Stmt11095:Parent
if (c == 58) {
//Stmt11090:Parent
if ((int )*p == 61) {
//Stmt11050:Leaf
tmp___0 = p;

//Stmt11051:Leaf
p ++;

//Stmt11052:Leaf
end = tmp___0 - 1;

//Stmt11053:Leaf
flavor = (enum __anonenum_flavor_56 )1;

//Stmt11054:Leaf
break;

       } else {
//Stmt11055:Leaf
return ((struct variable *)0);

       }

     } else
     {
//Stmt11091:Parent
if (c == 43) {
//Stmt11089:Parent
if ((int )*p == 61) {
//Stmt11056:Leaf
tmp___1 = p;

//Stmt11057:Leaf
p ++;

//Stmt11058:Leaf
end = tmp___1 - 1;

//Stmt11059:Leaf
flavor = (enum __anonenum_flavor_56 )3;

//Stmt11060:Leaf
break;

       } else {
//Stmt11061:Leaf
goto _L___0;

       }

     } else
     _L___0: /* CIL Label */ 
     {
//Stmt11088:Parent
if (c == 63) {
//Stmt11087:Parent
if ((int )*p == 61) {
//Stmt11062:Leaf
tmp___2 = p;

//Stmt11063:Leaf
p ++;

//Stmt11064:Leaf
end = tmp___2 - 1;

//Stmt11065:Leaf
flavor = (enum __anonenum_flavor_56 )4;

//Stmt11066:Leaf
break;

       } else {
//Stmt11067:Leaf
goto _L;

       }

     } else
     _L: /* CIL Label */ 
     {
//Stmt11086:Parent
if (c == 36) {
//Stmt11080:Leaf
tmp___3 = p;

//Stmt11081:Leaf
p ++;

//Stmt11082:Leaf
c = (int )*tmp___3;

//Stmt11083:Parent
if (c == 40) {
//Stmt11070:Leaf
closeparen = (char )')';

       } else
       {
//Stmt11071:Parent
if (c == 123) {
//Stmt11068:Leaf
closeparen = (char )'}';

       } else {
//Stmt11069:Leaf
continue;

       }
}


//Stmt11084:Leaf
count = 0;

//Stmt11085:Parent
while ((int )*p != 0) {
//Stmt11078:Parent
if ((int )*p == c) {
//Stmt11076:Leaf
count ++;

         } else
         {
//Stmt11077:Parent
if ((int )*p == (int )closeparen) {
//Stmt11074:Leaf
count --;

//Stmt11075:Parent
if (count < 0) {
//Stmt11072:Leaf
p ++;

//Stmt11073:Leaf
break;

           }

         }
}


//Stmt11079:Leaf
p ++;

       }

     }
}

}

}

}


   }

//Stmt11177:Leaf
beg = next_token(line);

//Stmt11178:Parent
while (1) {
//Stmt11105:Parent
if ((unsigned long )end > (unsigned long )beg) {
//Stmt11102:Leaf
tmp___4 = __ctype_b_loc();

//Stmt11103:Parent
if (! ((int const   )*(*tmp___4 + (int )*(end + -1)) & 1)) {
//Stmt11101:Leaf
break;

       }

     } else {
//Stmt11104:Leaf
break;

     }

//Stmt11106:Leaf
end --;

   }

//Stmt11179:Leaf
p = next_token(p);

//Stmt11180:Leaf
tmp___5 = __builtin_alloca((unsigned long )((end - beg) + 1L));

//Stmt11181:Leaf
name = (char *)tmp___5;

//Stmt11182:Leaf
memmove((void *)name, (void const   *)beg, (size_t )(end - beg));

//Stmt11183:Leaf
*(name + (end - beg)) = (char )'\000';

//Stmt11184:Leaf
expanded_name = allocated_variable_expand_for_file(name, (struct file *)0);

//Stmt11185:Parent
if ((int )*(expanded_name + 0) == 0) {
//Stmt11107:Leaf
tmp___6 = dcgettext((char const   *)((void *)0), "empty variable name", 5);

//Stmt11108:Leaf
fatal(flocp, (char const   *)tmp___6);

   }

//Stmt11186:Parent
switch ((unsigned int )flavor) {
   case 0U:; 
//Stmt11109:Leaf
abort();

   case 1U:; 
//Stmt11110:Leaf
alloc_value = allocated_variable_expand_for_file(p, (struct file *)0);

//Stmt11135:Leaf
value = alloc_value;

   break;
   case 4U:; 
//Stmt11111:Leaf
tmp___7 = strlen((char const   *)expanded_name);

//Stmt11136:Leaf
v = lookup_variable(expanded_name, (unsigned int )tmp___7);

//Stmt11137:Parent
if (v) {
//Stmt11112:Leaf
free((void *)expanded_name);

//Stmt11113:Leaf
return (v);

   }

//Stmt11138:Leaf
flavor = (enum __anonenum_flavor_56 )2;

   case 2U:; 
//Stmt11114:Leaf
value = p;

   break;
   case 3U:; 
//Stmt11119:Parent
if (target_var) {
//Stmt11115:Leaf
append = 1;

//Stmt11116:Leaf
flavor = (enum __anonenum_flavor_56 )2;

//Stmt11117:Leaf
value = p;

//Stmt11118:Leaf
break;

   }

//Stmt11139:Leaf
tmp___8 = strlen((char const   *)expanded_name);

//Stmt11140:Leaf
v = lookup_variable(expanded_name, (unsigned int )tmp___8);

//Stmt11141:Parent
if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
//Stmt11123:Leaf
value = p;

//Stmt11124:Leaf
flavor = (enum __anonenum_flavor_56 )2;

   } else {
//Stmt11125:Parent
if (v->recursive) {
//Stmt11120:Leaf
flavor = (enum __anonenum_flavor_56 )2;

     } else {
//Stmt11121:Leaf
alloc_value = allocated_variable_expand_for_file(p, (struct file *)0);

//Stmt11122:Leaf
p = alloc_value;

     }

//Stmt11126:Leaf
tmp___9 = strlen((char const   *)v->value);

//Stmt11127:Leaf
oldlen = (unsigned int )tmp___9;

//Stmt11128:Leaf
tmp___10 = strlen((char const   *)p);

//Stmt11129:Leaf
newlen = (unsigned int )tmp___10;

//Stmt11130:Leaf
tmp___11 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));

//Stmt11131:Leaf
value = (char *)tmp___11;

//Stmt11132:Leaf
memmove((void *)value, (void const   *)v->value, (size_t )oldlen);

//Stmt11133:Leaf
*(value + oldlen) = (char )' ';

//Stmt11134:Leaf
memmove((void *)(value + (oldlen + 1U)), (void const   *)p, (size_t )(newlen + 1U));

   }

   }

//Stmt11187:Leaf
tmp___12 = strlen((char const   *)expanded_name);

//Stmt11188:Leaf
v = define_variable_in_set(expanded_name, (unsigned int )tmp___12, value, origin,
                              (unsigned int )flavor == 2U, current_variable_set_list->set,
                              flocp);

//Stmt11189:Leaf
v->append = (unsigned int )append;

//Stmt11190:Parent
if (alloc_value) {
//Stmt11142:Leaf
free((void *)alloc_value);

   }

//Stmt11191:Leaf
free((void *)expanded_name);

//Stmt11192:Leaf
return (v);

 }
}
 static void print_variable(struct variable *v , char *prefix ) 
 { 
//Stmt11234:Leaf
char const   *origin ;

//Stmt11235:Leaf
char *tmp ;

//Stmt11236:Leaf
char *tmp___0 ;

//Stmt11237:Leaf
char *tmp___1 ;

//Stmt11238:Leaf
char *tmp___2 ;

//Stmt11239:Leaf
char *tmp___3 ;

//Stmt11240:Leaf
char *tmp___4 ;

//Stmt11241:Leaf
char *tmp___5 ;

//Stmt11242:Leaf
register char *p ;

//Stmt11243:Leaf
char const   *tmp___6 ;

//Stmt11244:Leaf
char const   *tmp___7 ;

//Stmt11245:Leaf
char *tmp___8 ;

 
   {
//Stmt11246:Parent
switch ((unsigned int )v->origin) {
   case 0U:; 
//Stmt11193:Leaf
tmp = dcgettext((char const   *)((void *)0), "default", 5);

//Stmt11201:Leaf
origin = (char const   *)tmp;

   break;
   case 1U:; 
//Stmt11194:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "environment", 5);

//Stmt11202:Leaf
origin = (char const   *)tmp___0;

   break;
   case 2U:; 
//Stmt11195:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "makefile", 5);

//Stmt11203:Leaf
origin = (char const   *)tmp___1;

   break;
   case 3U:; 
//Stmt11196:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "environment under -e", 5);

//Stmt11204:Leaf
origin = (char const   *)tmp___2;

   break;
   case 4U:; 
//Stmt11197:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "command line", 5);

//Stmt11205:Leaf
origin = (char const   *)tmp___3;

   break;
   case 5U:; 
//Stmt11198:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "`override\' directive", 5);

//Stmt11206:Leaf
origin = (char const   *)tmp___4;

   break;
   case 6U:; 
//Stmt11199:Leaf
tmp___5 = dcgettext((char const   *)((void *)0), "automatic", 5);

//Stmt11207:Leaf
origin = (char const   *)tmp___5;

   break;
   default:; 
//Stmt11200:Leaf
abort();

   }

//Stmt11247:Leaf
fputs((char const   * __restrict  )"# ", (FILE * __restrict  )stdout);

//Stmt11248:Leaf
fputs((char const   * __restrict  )origin, (FILE * __restrict  )stdout);

//Stmt11249:Parent
if (v->fileinfo.filenm) {
//Stmt11208:Leaf
printf((char const   * __restrict  )" (from `%s\', line %lu)", v->fileinfo.filenm,
            v->fileinfo.lineno);

   }

//Stmt11250:Leaf
putchar('\n');

//Stmt11251:Leaf
fputs((char const   * __restrict  )prefix, (FILE * __restrict  )stdout);

//Stmt11252:Parent
if (v->recursive) {
//Stmt11228:Leaf
tmp___8 = strchr((char const   *)v->value, '\n');

//Stmt11229:Parent
if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
//Stmt11209:Leaf
printf((char const   * __restrict  )"define %s\n%s\nendef\n", v->name, v->value);

     } else {
//Stmt11210:Leaf
goto _L___0;

     }

   } else {
     _L___0: /* CIL Label */ 
     {
//Stmt11216:Parent
if (v->recursive) {
//Stmt11213:Parent
if (v->append) {
//Stmt11211:Leaf
tmp___6 = "+";

       } else {
//Stmt11212:Leaf
tmp___6 = "";

       }

//Stmt11214:Leaf
tmp___7 = tmp___6;

     } else {
//Stmt11215:Leaf
tmp___7 = ":";

     }
}

//Stmt11230:Leaf
printf((char const   * __restrict  )"%s %s= ", v->name, tmp___7);

//Stmt11231:Leaf
p = next_token(v->value);

//Stmt11232:Parent
if ((unsigned long )p != (unsigned long )v->value) {
//Stmt11227:Parent
if ((int )*p == 0) {
//Stmt11217:Leaf
printf((char const   * __restrict  )"$(subst ,,%s)", v->value);

       } else {
//Stmt11218:Leaf
goto _L;

       }

     } else
     _L: /* CIL Label */ 
     {
//Stmt11226:Parent
if (v->recursive) {
//Stmt11223:Leaf
fputs((char const   * __restrict  )v->value, (FILE * __restrict  )stdout);

     } else {
//Stmt11224:Leaf
p = v->value;

//Stmt11225:Parent
while ((int )*p != 0) {
//Stmt11220:Parent
if ((int )*p == 36) {
//Stmt11219:Leaf
putchar('$');

         }

//Stmt11221:Leaf
putchar((int )*p);

//Stmt11222:Leaf
p ++;

       }

     }
}


//Stmt11233:Leaf
putchar('\n');

   }

//Stmt11253:Leaf
return;

 }
}
 void print_variable_set(struct variable_set *set , char *prefix ) 
 { 
//Stmt11270:Leaf
register unsigned int i ;

//Stmt11271:Leaf
register unsigned int nvariables ;

//Stmt11272:Leaf
register unsigned int per_bucket ;

//Stmt11273:Leaf
register struct variable *v ;

//Stmt11274:Leaf
register unsigned int this_bucket ;

//Stmt11275:Leaf
char *tmp ;

//Stmt11276:Leaf
char *tmp___0 ;

//Stmt11277:Leaf
char *tmp___1 ;

 
   {
//Stmt11278:Leaf
nvariables = 0U;

//Stmt11279:Leaf
per_bucket = nvariables;

//Stmt11280:Leaf
i = 0U;

//Stmt11281:Parent
while (i < set->buckets) {
//Stmt11258:Leaf
this_bucket = 0U;

//Stmt11259:Leaf
v = *(set->table + i);

//Stmt11260:Parent
while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
//Stmt11254:Leaf
this_bucket ++;

//Stmt11255:Leaf
print_variable(v, prefix);

//Stmt11256:Leaf
v = v->next;

     }

//Stmt11261:Leaf
nvariables += this_bucket;

//Stmt11262:Parent
if (this_bucket > per_bucket) {
//Stmt11257:Leaf
per_bucket = this_bucket;

     }

//Stmt11263:Leaf
i ++;

   }

//Stmt11282:Parent
if (nvariables == 0U) {
//Stmt11264:Leaf
tmp = dcgettext((char const   *)((void *)0), "# No variables.", 5);

//Stmt11265:Leaf
puts((char const   *)tmp);

   } else {
//Stmt11266:Leaf
tmp___0 = dcgettext((char const   *)((void *)0), "# %u variables in %u hash buckets.\n",
                         5);

//Stmt11267:Leaf
printf((char const   * __restrict  )tmp___0, nvariables, set->buckets);

//Stmt11268:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "# average of %.1f variables per bucket, max %u in one bucket.\n",
                         5);

//Stmt11269:Leaf
printf((char const   * __restrict  )tmp___1, (double )nvariables / (double )set->buckets,
            per_bucket);

   }

//Stmt11283:Leaf
return;

 }
}
 void print_variable_data_base(void) 
 { 
//Stmt11284:Leaf
char *tmp ;

 
   {
//Stmt11285:Leaf
tmp = dcgettext((char const   *)((void *)0), "\n# Variables\n", 5);

//Stmt11286:Leaf
puts((char const   *)tmp);

//Stmt11287:Leaf
print_variable_set(& global_variable_set, (char *)"");

//Stmt11288:Leaf
return;

 }
}
 void print_file_variables(struct file *file ) 
 { 
 
 
{
//Stmt11290:Parent
if ((unsigned long )file->variables != (unsigned long )((struct variable_set_list *)0)) {
//Stmt11289:Leaf
print_variable_set((file->variables)->set, (char *)"# ");

   }

//Stmt11291:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-lr0nQLdA.i","-g,-O0")
 static struct vpath *vpaths  ;
 static struct vpath *general_vpath  ;
 static struct vpath *gpaths  ;
 static int selective_vpath_search(struct vpath *path , char **file , uintmax_t *mtime_ptr ) ;
 void build_vpath_lists(void) 
 { 
//Stmt11306:Leaf
register struct vpath *new ;

//Stmt11307:Leaf
register struct vpath *old ;

//Stmt11308:Leaf
register struct vpath *nexto ;

//Stmt11309:Leaf
register char *p ;

//Stmt11310:Leaf
int save ;

//Stmt11311:Leaf
struct vpath *save_vpaths ;

//Stmt11312:Leaf
int save___0 ;

//Stmt11313:Leaf
struct vpath *save_vpaths___0 ;

 
   {
//Stmt11314:Leaf
new = (struct vpath *)0;

//Stmt11315:Leaf
old = vpaths;

//Stmt11316:Parent
while ((unsigned long )old != (unsigned long )((struct vpath *)0)) {
//Stmt11292:Leaf
nexto = old->next;

//Stmt11293:Leaf
old->next = new;

//Stmt11294:Leaf
new = old;

//Stmt11295:Leaf
old = nexto;

   }

//Stmt11317:Leaf
vpaths = new;

//Stmt11318:Leaf
save = warn_undefined_variables_flag;

//Stmt11319:Leaf
warn_undefined_variables_flag = 0;

//Stmt11320:Leaf
p = variable_expand((char *)"$(strip $(VPATH))");

//Stmt11321:Leaf
warn_undefined_variables_flag = save;

//Stmt11322:Parent
if ((int )*p != 0) {
//Stmt11296:Leaf
save_vpaths = vpaths;

//Stmt11297:Leaf
vpaths = (struct vpath *)0;

//Stmt11298:Leaf
construct_vpath_list((char *)"%", p);

//Stmt11299:Leaf
general_vpath = vpaths;

//Stmt11300:Leaf
vpaths = save_vpaths;

   }

//Stmt11323:Leaf
save___0 = warn_undefined_variables_flag;

//Stmt11324:Leaf
warn_undefined_variables_flag = 0;

//Stmt11325:Leaf
p = variable_expand((char *)"$(strip $(GPATH))");

//Stmt11326:Leaf
warn_undefined_variables_flag = save___0;

//Stmt11327:Parent
if ((int )*p != 0) {
//Stmt11301:Leaf
save_vpaths___0 = vpaths;

//Stmt11302:Leaf
vpaths = (struct vpath *)0;

//Stmt11303:Leaf
construct_vpath_list((char *)"%", p);

//Stmt11304:Leaf
gpaths = vpaths;

//Stmt11305:Leaf
vpaths = save_vpaths___0;

   }

//Stmt11328:Leaf
return;

 }
}
 void construct_vpath_list(char *pattern , char *dirpath ) 
 { 
//Stmt11424:Leaf
register unsigned int elem ;

//Stmt11425:Leaf
register char *p ;

//Stmt11426:Leaf
register char **vpath ;

//Stmt11427:Leaf
register unsigned int maxvpath ;

//Stmt11428:Leaf
unsigned int maxelem ;

//Stmt11429:Leaf
char *percent ;

//Stmt11430:Leaf
register struct vpath *path ;

//Stmt11431:Leaf
register struct vpath *lastpath ;

//Stmt11432:Leaf
struct vpath *next ;

//Stmt11433:Leaf
int tmp ;

//Stmt11434:Leaf
char *tmp___0 ;

//Stmt11435:Leaf
unsigned short const   **tmp___1 ;

//Stmt11436:Leaf
char *tmp___2 ;

//Stmt11437:Leaf
unsigned short const   **tmp___3 ;

//Stmt11438:Leaf
char *v ;

//Stmt11439:Leaf
unsigned int len ;

//Stmt11440:Leaf
unsigned short const   **tmp___4 ;

//Stmt11441:Leaf
unsigned int tmp___5 ;

//Stmt11442:Leaf
int tmp___6 ;

//Stmt11443:Leaf
unsigned short const   **tmp___7 ;

//Stmt11444:Leaf
struct vpath *path___0 ;

//Stmt11445:Leaf
char *tmp___8 ;

//Stmt11446:Leaf
char *tmp___9 ;

//Stmt11447:Leaf
size_t tmp___10 ;

 
   {
//Stmt11448:Leaf
percent = (char *)((void *)0);

//Stmt11449:Parent
if ((unsigned long )pattern != (unsigned long )((char *)0)) {
//Stmt11329:Leaf
pattern = xstrdup((char const   *)pattern);

//Stmt11330:Leaf
percent = find_percent(pattern);

   }

//Stmt11450:Parent
if ((unsigned long )dirpath == (unsigned long )((char *)0)) {
//Stmt11357:Leaf
lastpath = (struct vpath *)0;

//Stmt11358:Leaf
path = vpaths;

//Stmt11359:Parent
while ((unsigned long )path != (unsigned long )((struct vpath *)0)) {
//Stmt11353:Leaf
next = path->next;

//Stmt11354:Parent
if ((unsigned long )pattern == (unsigned long )((char *)0)) {
//Stmt11351:Leaf
goto _L___1;

       } else
       {
//Stmt11352:Parent
if ((unsigned long )percent == (unsigned long )((char *)0)) {
//Stmt11350:Parent
if ((unsigned long )path->percent == (unsigned long )((char *)0)) {
//Stmt11331:Leaf
goto _L___2;

         } else {
//Stmt11332:Leaf
goto _L___3;

         }

       } else
       _L___3: /* CIL Label */ 
       {
//Stmt11349:Parent
if (percent - pattern == path->percent - path->pattern) {
         _L___2: /* CIL Label */ 
         {
//Stmt11347:Parent
if ((unsigned long )pattern == (unsigned long )path->pattern) {
//Stmt11345:Leaf
goto _L___1;

         } else
         {
//Stmt11346:Parent
if ((int )*pattern == (int )*(path->pattern)) {
//Stmt11343:Parent
if ((int )*pattern == 0) {
//Stmt11340:Leaf
goto _L___1;

           } else {
//Stmt11341:Leaf
tmp = strcmp((char const   *)(pattern + 1), (char const   *)(path->pattern + 1));

//Stmt11342:Parent
if (tmp) {
//Stmt11336:Leaf
lastpath = path;

             } else {
               _L___1: /* CIL Label */ 
               {
//Stmt11335:Parent
if ((unsigned long )lastpath == (unsigned long )((struct vpath *)0)) {
//Stmt11333:Leaf
vpaths = path->next;

               } else {
//Stmt11334:Leaf
lastpath->next = next;

               }
}

//Stmt11337:Leaf
free((void *)path->pattern);

//Stmt11338:Leaf
free((void *)((char *)path->searchpath));

//Stmt11339:Leaf
free((void *)((char *)path));

             }

           }

         } else {
//Stmt11344:Leaf
lastpath = path;

         }
}

}

       } else {
//Stmt11348:Leaf
lastpath = path;

       }
}

}


//Stmt11355:Leaf
path = next;

     }

//Stmt11360:Parent
if ((unsigned long )pattern != (unsigned long )((char *)0)) {
//Stmt11356:Leaf
free((void *)pattern);

     }

//Stmt11361:Leaf
return;

   }

//Stmt11451:Leaf
maxelem = 2U;

//Stmt11452:Leaf
p = dirpath;

//Stmt11453:Parent
while ((int )*p != 0) {
//Stmt11366:Leaf
tmp___0 = p;

//Stmt11367:Leaf
p ++;

//Stmt11368:Parent
if ((int )*tmp___0 == 58) {
//Stmt11363:Leaf
maxelem ++;

     } else {
//Stmt11364:Leaf
tmp___1 = __ctype_b_loc();

//Stmt11365:Parent
if ((int const   )*(*tmp___1 + (int )*p) & 1) {
//Stmt11362:Leaf
maxelem ++;

       }

     }

   }

//Stmt11454:Leaf
tmp___2 = xmalloc((unsigned int )((unsigned long )maxelem * sizeof(char *)));

//Stmt11455:Leaf
vpath = (char **)tmp___2;

//Stmt11456:Leaf
maxvpath = 0U;

//Stmt11457:Leaf
p = dirpath;

//Stmt11458:Parent
while (1) {
//Stmt11372:Parent
if (! ((int )*p == 58)) {
//Stmt11370:Leaf
tmp___3 = __ctype_b_loc();

//Stmt11371:Parent
if (! ((int const   )*(*tmp___3 + (int )*p) & 1)) {
//Stmt11369:Leaf
break;

       }

     }

//Stmt11373:Leaf
p ++;

   }

//Stmt11459:Leaf
elem = 0U;

//Stmt11460:Parent
while ((int )*p != 0) {
//Stmt11401:Leaf
v = p;

//Stmt11402:Parent
while (1) {
//Stmt11380:Parent
if ((int )*p != 0) {
//Stmt11378:Parent
if ((int )*p != 58) {
//Stmt11375:Leaf
tmp___4 = __ctype_b_loc();

//Stmt11376:Parent
if ((int const   )*(*tmp___4 + (int )*p) & 1) {
//Stmt11374:Leaf
break;

           }

         } else {
//Stmt11377:Leaf
break;

         }

       } else {
//Stmt11379:Leaf
break;

       }

//Stmt11381:Leaf
p ++;

     }

//Stmt11403:Leaf
len = (unsigned int )(p - v);

//Stmt11404:Parent
if (len > 1U) {
//Stmt11383:Parent
if ((int )*(p + -1) == 47) {
//Stmt11382:Leaf
len --;

       }

     }

//Stmt11405:Parent
if (len > 1U) {
//Stmt11394:Leaf
goto _L___4;

     } else
     {
//Stmt11395:Parent
if ((int )*v != 46) {
       _L___4: /* CIL Label */ 
       {
//Stmt11384:Leaf
v = savestring((char const   *)v, len);

}
//Stmt11392:Leaf
tmp___6 = dir_file_exists_p(v, (char *)"");

//Stmt11393:Parent
if (tmp___6) {
//Stmt11386:Leaf
tmp___5 = elem;

//Stmt11387:Leaf
elem ++;

//Stmt11388:Leaf
*(vpath + tmp___5) = dir_name(v);

//Stmt11389:Leaf
free((void *)v);

//Stmt11390:Parent
if (len > maxvpath) {
//Stmt11385:Leaf
maxvpath = len;

         }

       } else {
//Stmt11391:Leaf
free((void *)v);

       }

     }
}


//Stmt11406:Parent
while (1) {
//Stmt11399:Parent
if (! ((int )*p == 58)) {
//Stmt11397:Leaf
tmp___7 = __ctype_b_loc();

//Stmt11398:Parent
if (! ((int const   )*(*tmp___7 + (int )*p) & 1)) {
//Stmt11396:Leaf
break;

         }

       }

//Stmt11400:Leaf
p ++;

     }

   }

//Stmt11461:Parent
if (elem > 0U) {
//Stmt11410:Parent
if (elem < maxelem - 1U) {
//Stmt11407:Leaf
tmp___8 = xrealloc((char *)vpath, (unsigned int )((unsigned long )(elem + 1U) * sizeof(char *)));

//Stmt11408:Leaf
vpath = (char **)tmp___8;

     }

//Stmt11411:Leaf
*(vpath + elem) = (char *)0;

//Stmt11412:Leaf
tmp___9 = xmalloc((unsigned int )sizeof(struct vpath ));

//Stmt11413:Leaf
path___0 = (struct vpath *)tmp___9;

//Stmt11414:Leaf
path___0->searchpath = vpath;

//Stmt11415:Leaf
path___0->maxlen = maxvpath;

//Stmt11416:Leaf
path___0->next = vpaths;

//Stmt11417:Leaf
vpaths = path___0;

//Stmt11418:Leaf
path___0->pattern = pattern;

//Stmt11419:Leaf
path___0->percent = percent;

//Stmt11420:Leaf
tmp___10 = strlen((char const   *)pattern);

//Stmt11421:Leaf
path___0->patlen = (unsigned int )tmp___10;

   } else {
//Stmt11422:Leaf
free((void *)((char *)vpath));

//Stmt11423:Parent
if ((unsigned long )pattern != (unsigned long )((char *)0)) {
//Stmt11409:Leaf
free((void *)pattern);

     }

   }

//Stmt11462:Leaf
return;

 }
}
 int gpath_search(char *file , int len ) 
 { 
//Stmt11471:Leaf
register char **gp ;

//Stmt11472:Leaf
int tmp ;

 
   {
//Stmt11473:Parent
if (gpaths) {
//Stmt11470:Parent
if ((unsigned int )len <= gpaths->maxlen) {
//Stmt11468:Leaf
gp = gpaths->searchpath;

//Stmt11469:Parent
while ((unsigned long )*gp != (unsigned long )((void *)0)) {
//Stmt11465:Leaf
tmp = strncmp((char const   *)*gp, (char const   *)file, (size_t )len);

//Stmt11466:Parent
if (tmp == 0) {
//Stmt11464:Parent
if ((int )*(*gp + len) == 0) {
//Stmt11463:Leaf
return (1);

           }

         }

//Stmt11467:Leaf
gp ++;

       }

     }

   }

//Stmt11474:Leaf
return (0);

 }
}
 int vpath_search(char **file , uintmax_t *mtime_ptr ) 
 { 
//Stmt11488:Leaf
register struct vpath *v ;

//Stmt11489:Leaf
int tmp ;

//Stmt11490:Leaf
int tmp___0 ;

//Stmt11491:Leaf
int tmp___1 ;

 
   {
//Stmt11492:Parent
if ((int )*(*file) == 47) {
//Stmt11477:Leaf
return (0);

   } else
   {
//Stmt11478:Parent
if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
//Stmt11476:Parent
if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
//Stmt11475:Leaf
return (0);

     }

   }
}


//Stmt11493:Leaf
v = vpaths;

//Stmt11494:Parent
while ((unsigned long )v != (unsigned long )((struct vpath *)0)) {
//Stmt11482:Leaf
tmp___0 = pattern_matches(v->pattern, v->percent, *file);

//Stmt11483:Parent
if (tmp___0) {
//Stmt11480:Leaf
tmp = selective_vpath_search(v, file, mtime_ptr);

//Stmt11481:Parent
if (tmp) {
//Stmt11479:Leaf
return (1);

       }

     }

//Stmt11484:Leaf
v = v->next;

   }

//Stmt11495:Parent
if ((unsigned long )general_vpath != (unsigned long )((struct vpath *)0)) {
//Stmt11486:Leaf
tmp___1 = selective_vpath_search(general_vpath, file, mtime_ptr);

//Stmt11487:Parent
if (tmp___1) {
//Stmt11485:Leaf
return (1);

     }

   }

//Stmt11496:Leaf
return (0);

 }
}
 static int selective_vpath_search(struct vpath *path , char **file , uintmax_t *mtime_ptr ) 
 { 
//Stmt11558:Leaf
int not_target ;

//Stmt11559:Leaf
char *name ;

//Stmt11560:Leaf
char *n ;

//Stmt11561:Leaf
char *filename ;

//Stmt11562:Leaf
register char **vpath ;

//Stmt11563:Leaf
unsigned int maxvpath ;

//Stmt11564:Leaf
register unsigned int i ;

//Stmt11565:Leaf
unsigned int flen ;

//Stmt11566:Leaf
unsigned int vlen ;

//Stmt11567:Leaf
unsigned int name_dplen ;

//Stmt11568:Leaf
int exists ;

//Stmt11569:Leaf
struct file *f ;

//Stmt11570:Leaf
struct file *tmp ;

//Stmt11571:Leaf
int tmp___0 ;

//Stmt11572:Leaf
size_t tmp___1 ;

//Stmt11573:Leaf
char *tmp___2 ;

//Stmt11574:Leaf
int exists_in_cache ;

//Stmt11575:Leaf
size_t tmp___3 ;

//Stmt11576:Leaf
char *tmp___4 ;

//Stmt11577:Leaf
struct file *f___0 ;

//Stmt11578:Leaf
struct file *tmp___5 ;

//Stmt11579:Leaf
int tmp___6 ;

//Stmt11580:Leaf
struct stat st ;

//Stmt11581:Leaf
uintmax_t tmp___7 ;

//Stmt11582:Leaf
uintmax_t tmp___8 ;

//Stmt11583:Leaf
int tmp___9 ;

 
   {
//Stmt11584:Leaf
vpath = path->searchpath;

//Stmt11585:Leaf
maxvpath = path->maxlen;

//Stmt11586:Leaf
exists = 0;

//Stmt11587:Leaf
tmp = lookup_file(*file);

//Stmt11588:Leaf
f = tmp;

//Stmt11589:Parent
if ((unsigned long )f == (unsigned long )((struct file *)0)) {
//Stmt11499:Leaf
tmp___0 = 1;

   } else
   {
//Stmt11500:Parent
if (! f->is_target) {
//Stmt11497:Leaf
tmp___0 = 1;

   } else {
//Stmt11498:Leaf
tmp___0 = 0;

   }
}


//Stmt11590:Leaf
not_target = tmp___0;

//Stmt11591:Leaf
tmp___1 = strlen((char const   *)*file);

//Stmt11592:Leaf
flen = (unsigned int )tmp___1;

//Stmt11593:Leaf
n = strrchr((char const   *)*file, '/');

//Stmt11594:Parent
if ((unsigned long )n != (unsigned long )((char *)0)) {
//Stmt11501:Leaf
name_dplen = (unsigned int )(n - *file);

   } else {
//Stmt11502:Leaf
name_dplen = 0U;

   }

//Stmt11595:Parent
if (name_dplen > 0U) {
//Stmt11503:Leaf
filename = n + 1;

   } else {
//Stmt11504:Leaf
filename = *file;

   }

//Stmt11596:Parent
if (name_dplen > 0U) {
//Stmt11505:Leaf
flen -= name_dplen + 1U;

   }

//Stmt11597:Leaf
tmp___2 = xmalloc(((((maxvpath + 1U) + name_dplen) + 1U) + flen) + 1U);

//Stmt11598:Leaf
name = tmp___2;

//Stmt11599:Leaf
i = 0U;

//Stmt11600:Parent
while ((unsigned long )*(vpath + i) != (unsigned long )((char *)0)) {
//Stmt11544:Leaf
exists_in_cache = 0;

//Stmt11545:Leaf
n = name;

//Stmt11546:Leaf
tmp___3 = strlen((char const   *)*(vpath + i));

//Stmt11547:Leaf
vlen = (unsigned int )tmp___3;

//Stmt11548:Leaf
memmove((void *)n, (void const   *)*(vpath + i), (size_t )vlen);

//Stmt11549:Leaf
n += vlen;

//Stmt11550:Parent
if (name_dplen > 0U) {
//Stmt11506:Leaf
tmp___4 = n;

//Stmt11507:Leaf
n ++;

//Stmt11508:Leaf
*tmp___4 = (char )'/';

//Stmt11509:Leaf
memmove((void *)n, (void const   *)*file, (size_t )name_dplen);

//Stmt11510:Leaf
n += name_dplen;

     }

//Stmt11551:Parent
if ((unsigned long )n != (unsigned long )name) {
//Stmt11514:Parent
if ((int )*(n + -1) != 47) {
//Stmt11511:Leaf
*n = (char )'/';

//Stmt11512:Leaf
memmove((void *)(n + 1), (void const   *)filename, (size_t )(flen + 1U));

       } else {
//Stmt11513:Leaf
memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));

       }

     } else {
//Stmt11515:Leaf
memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));

     }

//Stmt11552:Leaf
tmp___5 = lookup_file(name);

//Stmt11553:Leaf
f___0 = tmp___5;

//Stmt11554:Parent
if ((unsigned long )f___0 != (unsigned long )((struct file *)0)) {
//Stmt11520:Parent
if (not_target) {
//Stmt11518:Leaf
tmp___6 = 1;

       } else
       {
//Stmt11519:Parent
if (f___0->is_target) {
//Stmt11516:Leaf
tmp___6 = 1;

       } else {
//Stmt11517:Leaf
tmp___6 = 0;

       }
}


//Stmt11521:Leaf
exists = tmp___6;

     }

//Stmt11555:Parent
if (! exists) {
//Stmt11522:Leaf
*n = (char )'\000';

//Stmt11523:Leaf
exists = dir_file_exists_p(name, filename);

//Stmt11524:Leaf
exists_in_cache = exists;

     }

//Stmt11556:Parent
if (exists) {
//Stmt11542:Leaf
*n = (char )'/';

//Stmt11543:Parent
if (! exists_in_cache) {
//Stmt11539:Leaf
goto _L;

       } else {
//Stmt11540:Leaf
tmp___9 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));

//Stmt11541:Parent
if (tmp___9 == 0) {
           _L: /* CIL Label */ 
           {
//Stmt11525:Leaf
*file = savestring((char const   *)name, (unsigned int )(((n + 1) - name) + (long )flen));

}
//Stmt11535:Parent
if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
//Stmt11534:Parent
if (exists_in_cache) {
//Stmt11530:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt11526:Leaf
tmp___7 = (uintmax_t )1000000000;

               } else {
//Stmt11527:Leaf
tmp___7 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

               }

//Stmt11531:Parent
if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
//Stmt11528:Leaf
tmp___8 = (uintmax_t )1000000000;

               } else {
//Stmt11529:Leaf
tmp___8 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));

               }

//Stmt11532:Leaf
*mtime_ptr = (uintmax_t )st.st_mtim.tv_sec * tmp___7 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___8) / 1000000000UL;

             } else {
//Stmt11533:Leaf
*mtime_ptr = (uintmax_t )0;

             }

           }

//Stmt11536:Leaf
free((void *)name);

//Stmt11537:Leaf
return (1);

         } else {
//Stmt11538:Leaf
exists = 0;

         }

       }

     }

//Stmt11557:Leaf
i ++;

   }

//Stmt11601:Leaf
free((void *)name);

//Stmt11602:Leaf
return (0);

 }
}
 void print_vpath_data_base(void) 
 { 
//Stmt11629:Leaf
register unsigned int nvpaths ;

//Stmt11630:Leaf
register struct vpath *v ;

//Stmt11631:Leaf
char *tmp ;

//Stmt11632:Leaf
register unsigned int i ;

//Stmt11633:Leaf
int tmp___0 ;

//Stmt11634:Leaf
char *tmp___1 ;

//Stmt11635:Leaf
char *tmp___2 ;

//Stmt11636:Leaf
char *tmp___3 ;

//Stmt11637:Leaf
register char **path ;

//Stmt11638:Leaf
register unsigned int i___0 ;

//Stmt11639:Leaf
char *tmp___4 ;

//Stmt11640:Leaf
int tmp___5 ;

 
   {
//Stmt11641:Leaf
tmp = dcgettext((char const   *)((void *)0), "\n# VPATH Search Paths\n", 5);

//Stmt11642:Leaf
puts((char const   *)tmp);

//Stmt11643:Leaf
nvpaths = 0U;

//Stmt11644:Leaf
v = vpaths;

//Stmt11645:Parent
while ((unsigned long )v != (unsigned long )((struct vpath *)0)) {
//Stmt11608:Leaf
nvpaths ++;

//Stmt11609:Leaf
printf((char const   * __restrict  )"vpath %s ", v->pattern);

//Stmt11610:Leaf
i = 0U;

//Stmt11611:Parent
while ((unsigned long )*(v->searchpath + i) != (unsigned long )((char *)0)) {
//Stmt11605:Parent
if ((unsigned long )*(v->searchpath + (i + 1U)) == (unsigned long )((char *)0)) {
//Stmt11603:Leaf
tmp___0 = '\n';

       } else {
//Stmt11604:Leaf
tmp___0 = ':';

       }

//Stmt11606:Leaf
printf((char const   * __restrict  )"%s%c", *(v->searchpath + i), tmp___0);

//Stmt11607:Leaf
i ++;

     }

//Stmt11612:Leaf
v = v->next;

   }

//Stmt11646:Parent
if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
//Stmt11613:Leaf
tmp___1 = dcgettext((char const   *)((void *)0), "# No `vpath\' search paths.",
                         5);

//Stmt11614:Leaf
puts((char const   *)tmp___1);

   } else {
//Stmt11615:Leaf
tmp___2 = dcgettext((char const   *)((void *)0), "\n# %u `vpath\' search paths.\n",
                         5);

//Stmt11616:Leaf
printf((char const   * __restrict  )tmp___2, nvpaths);

   }

//Stmt11647:Parent
if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
//Stmt11622:Leaf
tmp___3 = dcgettext((char const   *)((void *)0), "\n# No general (`VPATH\' variable) search path.",
                         5);

//Stmt11623:Leaf
puts((char const   *)tmp___3);

   } else {
//Stmt11624:Leaf
path = general_vpath->searchpath;

//Stmt11625:Leaf
tmp___4 = dcgettext((char const   *)((void *)0), "\n# General (`VPATH\' variable) search path:\n# ",
                         5);

//Stmt11626:Leaf
fputs((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);

//Stmt11627:Leaf
i___0 = 0U;

//Stmt11628:Parent
while ((unsigned long )*(path + i___0) != (unsigned long )((char *)0)) {
//Stmt11619:Parent
if ((unsigned long )*(path + (i___0 + 1U)) == (unsigned long )((char *)0)) {
//Stmt11617:Leaf
tmp___5 = '\n';

       } else {
//Stmt11618:Leaf
tmp___5 = ':';

       }

//Stmt11620:Leaf
printf((char const   * __restrict  )"%s%c", *(path + i___0), tmp___5);

//Stmt11621:Leaf
i___0 ++;

     }

   }

//Stmt11648:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-IL2nT0BF.i","-g,-O0")
 static char default_suffixes[136]  = 
   {      (char )'.',      (char )'o',      (char )'u',      (char )'t', 
         (char )' ',      (char )'.',      (char )'a',      (char )' ', 
         (char )'.',      (char )'l',      (char )'n',      (char )' ', 
         (char )'.',      (char )'o',      (char )' ',      (char )'.', 
         (char )'c',      (char )' ',      (char )'.',      (char )'c', 
         (char )'c',      (char )' ',      (char )'.',      (char )'C', 
         (char )' ',      (char )'.',      (char )'c',      (char )'p', 
         (char )'p',      (char )' ',      (char )'.',      (char )'p', 
         (char )' ',      (char )'.',      (char )'f',      (char )' ', 
         (char )'.',      (char )'F',      (char )' ',      (char )'.', 
         (char )'r',      (char )' ',      (char )'.',      (char )'y', 
         (char )' ',      (char )'.',      (char )'l',      (char )' ', 
         (char )'.',      (char )'s',      (char )' ',      (char )'.', 
         (char )'S',      (char )' ',      (char )'.',      (char )'m', 
         (char )'o',      (char )'d',      (char )' ',      (char )'.', 
         (char )'s',      (char )'y',      (char )'m',      (char )' ', 
         (char )'.',      (char )'d',      (char )'e',      (char )'f', 
         (char )' ',      (char )'.',      (char )'h',      (char )' ', 
         (char )'.',      (char )'i',      (char )'n',      (char )'f', 
         (char )'o',      (char )' ',      (char )'.',      (char )'d', 
         (char )'v',      (char )'i',      (char )' ',      (char )'.', 
         (char )'t',      (char )'e',      (char )'x',      (char )' ', 
         (char )'.',      (char )'t',      (char )'e',      (char )'x', 
         (char )'i',      (char )'n',      (char )'f',      (char )'o', 
         (char )' ',      (char )'.',      (char )'t',      (char )'e', 
         (char )'x',      (char )'i',      (char )' ',      (char )'.', 
         (char )'t',      (char )'x',      (char )'i',      (char )'n', 
         (char )'f',      (char )'o',      (char )' ',      (char )'.', 
         (char )'w',      (char )' ',      (char )'.',      (char )'c', 
         (char )'h',      (char )' ',      (char )'.',      (char )'w', 
         (char )'e',      (char )'b',      (char )' ',      (char )'.', 
         (char )'s',      (char )'h',      (char )' ',      (char )'.', 
         (char )'e',      (char )'l',      (char )'c',      (char )' ', 
         (char )'.',      (char )'e',      (char )'l',      (char )'\000'};
 static struct pspec default_pattern_rules[5]  = {      {(char *)"(%)", (char *)"%", (char *)"$(AR) $(ARFLAGS) $@ $<"}, 
         {(char *)"%.out", (char *)"%", (char *)"@rm -f $@ \n cp $< $@"}, 
         {(char *)"%.c", (char *)"%.w %.ch", (char *)"$(CTANGLE) $^ $@"}, 
         {(char *)"%.tex", (char *)"%.w %.ch", (char *)"$(CWEAVE) $^ $@"}, 
         {(char *)0, (char *)0, (char *)0}};
 static struct pspec default_terminal_rules[6]  = {      {(char *)"%", (char *)"%,v", (char *)"$(CHECKOUT,v)"}, 
         {(char *)"%", (char *)"RCS/%,v", (char *)"$(CHECKOUT,v)"}, 
         {(char *)"%", (char *)"RCS/%", (char *)"$(CHECKOUT,v)"}, 
         {(char *)"%", (char *)"s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
         {(char *)"%",
       (char *)"SCCS/s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
         {(char *)0, (char *)0, (char *)0}};
 static char *default_suffix_rules[92]  = 
   {      (char *)".o",      (char *)"$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".s",      (char *)"$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".S",      (char *)"$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".c",      (char *)"$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".cc",      (char *)"$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".C",      (char *)"$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".cpp",      (char *)"$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".f",      (char *)"$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".p",      (char *)"$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".F",      (char *)"$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".r",      (char *)"$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".mod",      (char *)"$(COMPILE.mod) -o $@ -e $@ $^", 
         (char *)".def.sym",      (char *)"$(COMPILE.def) -o $@ $<",      (char *)".sh",      (char *)"cat $< >$@ \n chmod a+x $@", 
         (char *)".s.o",      (char *)"$(COMPILE.s) -o $@ $<",      (char *)".S.o",      (char *)"$(COMPILE.S) -o $@ $<", 
         (char *)".c.o",      (char *)"$(COMPILE.c) $(OUTPUT_OPTION) $<",      (char *)".cc.o",      (char *)"$(COMPILE.cc) $(OUTPUT_OPTION) $<", 
         (char *)".C.o",      (char *)"$(COMPILE.C) $(OUTPUT_OPTION) $<",      (char *)".cpp.o",      (char *)"$(COMPILE.cpp) $(OUTPUT_OPTION) $<", 
         (char *)".f.o",      (char *)"$(COMPILE.f) $(OUTPUT_OPTION) $<",      (char *)".p.o",      (char *)"$(COMPILE.p) $(OUTPUT_OPTION) $<", 
         (char *)".F.o",      (char *)"$(COMPILE.F) $(OUTPUT_OPTION) $<",      (char *)".r.o",      (char *)"$(COMPILE.r) $(OUTPUT_OPTION) $<", 
         (char *)".mod.o",      (char *)"$(COMPILE.mod) -o $@ $<",      (char *)".c.ln",      (char *)"$(LINT.c) -C$* $<", 
         (char *)".y.ln",      (char *)"$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",      (char *)".l.ln",      (char *)"@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c", 
         (char *)".y.c",      (char *)"$(YACC.y) $< \n mv -f y.tab.c $@",      (char *)".l.c",      (char *)"@$(RM) $@ \n $(LEX.l) $< > $@", 
         (char *)".F.f",      (char *)"$(PREPROCESS.F) $(OUTPUT_OPTION) $<",      (char *)".r.f",      (char *)"$(PREPROCESS.r) $(OUTPUT_OPTION) $<", 
         (char *)".l.r",      (char *)"$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",      (char *)".S.s",      (char *)"$(PREPROCESS.S) $< > $@", 
         (char *)".texinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".texi.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@", 
         (char *)".txinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".tex.dvi",      (char *)"$(TEX) $<", 
         (char *)".texinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".texi.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<", 
         (char *)".txinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".w.c",      (char *)"$(CTANGLE) $< - $@", 
         (char *)".web.p",      (char *)"$(TANGLE) $<",      (char *)".w.tex",      (char *)"$(CWEAVE) $< - $@", 
         (char *)".web.tex",      (char *)"$(WEAVE) $<",      (char *)0,      (char *)0};
 static char *default_variables[118]  = 
   {      (char *)"AR",      (char *)"ar",      (char *)"ARFLAGS",      (char *)"rv", 
         (char *)"AS",      (char *)"as",      (char *)"CC",      (char *)"cc", 
         (char *)"CXX",      (char *)"g++",      (char *)"CHECKOUT,v",      (char *)"+$(if $(wildcard $@),,$(CO) $(COFLAGS) $< $@)", 
         (char *)"CO",      (char *)"co",      (char *)"COFLAGS",      (char *)"", 
         (char *)"CPP",      (char *)"$(CC) -E",      (char *)"FC",      (char *)"f77", 
         (char *)"F77",      (char *)"$(FC)",      (char *)"F77FLAGS",      (char *)"$(FFLAGS)", 
         (char *)"GET",      (char *)"get",      (char *)"LD",      (char *)"ld", 
         (char *)"LEX",      (char *)"lex",      (char *)"LINT",      (char *)"lint", 
         (char *)"M2C",      (char *)"m2c",      (char *)"PC",      (char *)"pc", 
         (char *)"YACC",      (char *)"yacc",      (char *)"MAKEINFO",      (char *)"makeinfo", 
         (char *)"TEX",      (char *)"tex",      (char *)"TEXI2DVI",      (char *)"texi2dvi", 
         (char *)"WEAVE",      (char *)"weave",      (char *)"CWEAVE",      (char *)"cweave", 
         (char *)"TANGLE",      (char *)"tangle",      (char *)"CTANGLE",      (char *)"ctangle", 
         (char *)"RM",      (char *)"rm -f",      (char *)"LINK.o",      (char *)"$(CC) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"COMPILE.C",      (char *)"$(COMPILE.cc)", 
         (char *)"COMPILE.cpp",      (char *)"$(COMPILE.cc)",      (char *)"LINK.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"LINK.C",      (char *)"$(LINK.cc)",      (char *)"LINK.cpp",      (char *)"$(LINK.cc)", 
         (char *)"YACC.y",      (char *)"$(YACC) $(YFLAGS)",      (char *)"LEX.l",      (char *)"$(LEX) $(LFLAGS) -t", 
         (char *)"COMPILE.f",      (char *)"$(FC) $(FFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.f",      (char *)"$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.def",      (char *)"$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.mod",      (char *)"$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"LINK.s",      (char *)"$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",      (char *)"COMPILE.s",      (char *)"$(AS) $(ASFLAGS) $(TARGET_MACH)", 
         (char *)"LINK.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",      (char *)"COMPILE.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c", 
         (char *)"PREPROCESS.S",      (char *)"$(CC) -E $(CPPFLAGS)",      (char *)"PREPROCESS.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F", 
         (char *)"PREPROCESS.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",      (char *)"LINT.c",      (char *)"$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)", 
         (char *)"OUTPUT_OPTION",      (char *)"-o $@",      (char *)".LIBPATTERNS",      (char *)"lib%.so lib%.a", 
         (char *)0,      (char *)0};
 void set_default_suffixes(void) 
 { 
//Stmt11655:Leaf
char *p ;

//Stmt11656:Leaf
struct nameseq *tmp ;

//Stmt11657:Leaf
struct nameseq *tmp___0 ;

 
   {
//Stmt11658:Leaf
suffix_file = enter_file((char *)".SUFFIXES");

//Stmt11659:Parent
if (no_builtin_rules_flag) {
//Stmt11649:Leaf
define_variable_in_set((char *)"SUFFIXES", 8U, (char *)"", (enum variable_origin )0,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

   } else {
//Stmt11650:Leaf
p = default_suffixes;

//Stmt11651:Leaf
tmp = parse_file_seq(& p, '\000', (unsigned int )sizeof(struct dep ), 1);

//Stmt11652:Leaf
tmp___0 = multi_glob(tmp, (unsigned int )sizeof(struct dep ));

//Stmt11653:Leaf
suffix_file->deps = (struct dep *)tmp___0;

//Stmt11654:Leaf
define_variable_in_set((char *)"SUFFIXES", 8U, default_suffixes, (enum variable_origin )0,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

   }

//Stmt11660:Leaf
return;

 }
}
 void install_default_suffix_rules(void) 
 { 
//Stmt11671:Leaf
register char **s ;

//Stmt11672:Leaf
register struct file *f ;

//Stmt11673:Leaf
struct file *tmp ;

//Stmt11674:Leaf
char *tmp___0 ;

 
   {
//Stmt11675:Parent
if (no_builtin_rules_flag) {
//Stmt11661:Leaf
return;

   }

//Stmt11676:Leaf
s = default_suffix_rules;

//Stmt11677:Parent
while ((unsigned long )*s != (unsigned long )((char *)0)) {
//Stmt11667:Leaf
tmp = enter_file(*(s + 0));

//Stmt11668:Leaf
f = tmp;

//Stmt11669:Parent
if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
//Stmt11662:Leaf
tmp___0 = xmalloc((unsigned int )sizeof(struct commands ));

//Stmt11663:Leaf
f->cmds = (struct commands *)tmp___0;

//Stmt11664:Leaf
(f->cmds)->fileinfo.filenm = (char *)0;

//Stmt11665:Leaf
(f->cmds)->commands = *(s + 1);

//Stmt11666:Leaf
(f->cmds)->command_lines = (char **)0;

     }

//Stmt11670:Leaf
s += 2;

   }

//Stmt11678:Leaf
return;

 }
}
 void install_default_implicit_rules(void) 
 { 
//Stmt11684:Leaf
register struct pspec *p ;

 
   {
//Stmt11685:Parent
if (no_builtin_rules_flag) {
//Stmt11679:Leaf
return;

   }

//Stmt11686:Leaf
p = default_pattern_rules;

//Stmt11687:Parent
while ((unsigned long )p->target != (unsigned long )((char *)0)) {
//Stmt11680:Leaf
install_pattern_rule(p, 0);

//Stmt11681:Leaf
p ++;

   }

//Stmt11688:Leaf
p = default_terminal_rules;

//Stmt11689:Parent
while ((unsigned long )p->target != (unsigned long )((char *)0)) {
//Stmt11682:Leaf
install_pattern_rule(p, 1);

//Stmt11683:Leaf
p ++;

   }

//Stmt11690:Leaf
return;

 }
}
 void define_default_variables(void) 
 { 
//Stmt11695:Leaf
register char **s ;

//Stmt11696:Leaf
size_t tmp ;

 
   {
//Stmt11697:Parent
if (no_builtin_variables_flag) {
//Stmt11691:Leaf
return;

   }

//Stmt11698:Leaf
s = default_variables;

//Stmt11699:Parent
while ((unsigned long )*s != (unsigned long )((char *)0)) {
//Stmt11692:Leaf
tmp = strlen((char const   *)*(s + 0));

//Stmt11693:Leaf
define_variable_in_set(*(s + 0), (unsigned int )tmp, *(s + 1), (enum variable_origin )0,
                            1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));

//Stmt11694:Leaf
s += 2;

   }

//Stmt11700:Leaf
return;

 }
}
 #pragma merger("0","/tmp/cil-lUReg5Kq.i","-g,-O0")
 char *remote_description  =    (char *)0;
 void remote_setup(void) 
 { 
 
 
{
//Stmt11701:Leaf
return;

 }
}
 void remote_cleanup(void) 
 { 
 
 
{
//Stmt11702:Leaf
return;

 }
}
 int start_remote_job_p(int first_p ) 
 { 
 
 
{
//Stmt11703:Leaf
return (0);

 }
}
 int start_remote_job(char **argv , char **envp , int stdin_fd , int *is_remote , int *id_ptr ,
                      int *used_stdin ) 
 { 
 
 
{
//Stmt11704:Leaf
return (-1);

 }
}
 int remote_status(int *exit_code_ptr , int *signal_ptr , int *coredump_ptr , int block ) 
 { 
//Stmt11705:Leaf
int *tmp ;

 
   {
//Stmt11706:Leaf
tmp = __errno_location();

//Stmt11707:Leaf
*tmp = 10;

//Stmt11708:Leaf
return (-1);

 }
}
 void block_remote_children(void) 
 { 
 
 
{
//Stmt11709:Leaf
return;

 }
}
 void unblock_remote_children(void) 
 { 
 
 
{
//Stmt11710:Leaf
return;

 }
}
 int remote_kill(int id , int sig ) 
 { 
 
 
{
//Stmt11711:Leaf
return (-1);

 }
}
 #pragma merger("0","/tmp/cil-1mks5shs.i","-g,-O0")
 char *version_string  =    (char *)"3.79";
 char *make_host  =    (char *)"";
 #pragma merger("0","/tmp/cil-wnI9fUGf.i","-g,-O0")
 #pragma merger("0","/tmp/cil-cDTpBoNV.i","-g,-O0")
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ) ;
 static char const   *_nl_normalize_codeset(unsigned char const   *codeset , size_t name_len ) ;
 static struct loaded_l10nfile *_nl_make_l10nflist(struct loaded_l10nfile **l10nfile_list ,
                                                   char const   *dirlist , size_t dirlist_len ,
                                                   int mask , char const   *language ,
                                                   char const   *territory , char const   *codeset ,
                                                   char const   *normalized_codeset ,
                                                   char const   *modifier , char const   *special ,
                                                   char const   *sponsor , char const   *revision ,
                                                   char const   *filename , int do_allocate ) ;
 static char const   *_nl_expand_alias(char const   *name ) ;
 static int _nl_explode_name(char *name , char const   **language , char const   **modifier ,
                             char const   **territory , char const   **codeset , char const   **normalized_codeset ,
                             char const   **special , char const   **sponsor , char const   **revision ) ;
 static size_t argz_count__(char const   *argz , size_t len ) ;
 static size_t argz_count__(char const   *argz , size_t len ) 
 { 
//Stmt11717:Leaf
size_t count ;

//Stmt11718:Leaf
size_t part_len ;

//Stmt11719:Leaf
size_t tmp ;

 
   {
//Stmt11720:Leaf
count = (size_t )0;

//Stmt11721:Parent
while (len > 0UL) {
//Stmt11712:Leaf
tmp = strlen(argz);

//Stmt11713:Leaf
part_len = tmp;

//Stmt11714:Leaf
argz += part_len + 1UL;

//Stmt11715:Leaf
len -= part_len + 1UL;

//Stmt11716:Leaf
count ++;

   }

//Stmt11722:Leaf
return (count);

 }
}
 static void argz_stringify__(char *argz , size_t len , int sep ) ;
 static void argz_stringify__(char *argz , size_t len , int sep ) 
 { 
//Stmt11731:Leaf
size_t part_len ;

//Stmt11732:Leaf
size_t tmp ;

//Stmt11733:Leaf
char *tmp___0 ;

 
   {
//Stmt11734:Parent
while (len > 0UL) {
//Stmt11726:Leaf
tmp = strlen((char const   *)argz);

//Stmt11727:Leaf
part_len = tmp;

//Stmt11728:Leaf
argz += part_len;

//Stmt11729:Leaf
len -= part_len + 1UL;

//Stmt11730:Parent
if (len > 0UL) {
//Stmt11723:Leaf
tmp___0 = argz;

//Stmt11724:Leaf
argz ++;

//Stmt11725:Leaf
*tmp___0 = (char )sep;

     }

   }

//Stmt11735:Leaf
return;

 }
}
 static char *argz_next__(char *argz , size_t argz_len , char const   *entry ) ;
 static char *argz_next__(char *argz , size_t argz_len , char const   *entry ) 
 { 
//Stmt11746:Leaf
char *tmp ;

//Stmt11747:Leaf
char *tmp___0 ;

 
   {
//Stmt11748:Parent
if (entry) {
//Stmt11742:Parent
if ((unsigned long )entry < (unsigned long )(argz + argz_len)) {
//Stmt11736:Leaf
tmp = strchr(entry, '\000');

//Stmt11737:Leaf
entry = (char const   *)(tmp + 1);

     }

//Stmt11743:Parent
if ((unsigned long )entry >= (unsigned long )(argz + argz_len)) {
//Stmt11738:Leaf
tmp___0 = (char *)((void *)0);

     } else {
//Stmt11739:Leaf
tmp___0 = (char *)entry;

     }

//Stmt11744:Leaf
return (tmp___0);

   } else
   {
//Stmt11745:Parent
if (argz_len > 0UL) {
//Stmt11740:Leaf
return (argz);

   } else {
//Stmt11741:Leaf
return ((char *)0);

   }
}


 }
}
 __inline static int pop(int x ) ;
 __inline static int pop(int x ) 
 { 
 
 
{
//Stmt11749:Leaf
x = ((x & -21846) >> 1) + (x & 21845);

//Stmt11750:Leaf
x = ((x & -13108) >> 2) + (x & 13107);

//Stmt11751:Leaf
x = ((x >> 4) + x) & 3855;

//Stmt11752:Leaf
x = ((x >> 8) + x) & 255;

//Stmt11753:Leaf
return (x);

 }
}
 static struct loaded_l10nfile *_nl_make_l10nflist(struct loaded_l10nfile **l10nfile_list ,
                                                   char const   *dirlist , size_t dirlist_len ,
                                                   int mask , char const   *language ,
                                                   char const   *territory , char const   *codeset ,
                                                   char const   *normalized_codeset ,
                                                   char const   *modifier , char const   *special ,
                                                   char const   *sponsor , char const   *revision ,
                                                   char const   *filename , int do_allocate ) 
 { 
//Stmt11862:Leaf
char *abs_filename ;

//Stmt11863:Leaf
struct loaded_l10nfile *last ;

//Stmt11864:Leaf
struct loaded_l10nfile *retval ;

//Stmt11865:Leaf
char *cp ;

//Stmt11866:Leaf
size_t entries ;

//Stmt11867:Leaf
int cnt ;

//Stmt11868:Leaf
size_t tmp ;

//Stmt11869:Leaf
size_t tmp___0 ;

//Stmt11870:Leaf
size_t tmp___1 ;

//Stmt11871:Leaf
size_t tmp___2 ;

//Stmt11872:Leaf
size_t tmp___3 ;

//Stmt11873:Leaf
size_t tmp___4 ;

//Stmt11874:Leaf
size_t tmp___5 ;

//Stmt11875:Leaf
size_t tmp___6 ;

//Stmt11876:Leaf
size_t tmp___7 ;

//Stmt11877:Leaf
size_t tmp___8 ;

//Stmt11878:Leaf
size_t tmp___9 ;

//Stmt11879:Leaf
size_t tmp___10 ;

//Stmt11880:Leaf
size_t tmp___11 ;

//Stmt11881:Leaf
size_t tmp___12 ;

//Stmt11882:Leaf
size_t tmp___13 ;

//Stmt11883:Leaf
size_t tmp___14 ;

//Stmt11884:Leaf
size_t tmp___15 ;

//Stmt11885:Leaf
int tmp___16 ;

//Stmt11886:Leaf
char *tmp___17 ;

//Stmt11887:Leaf
char *tmp___18 ;

//Stmt11888:Leaf
char *tmp___19 ;

//Stmt11889:Leaf
char *tmp___20 ;

//Stmt11890:Leaf
char *tmp___21 ;

//Stmt11891:Leaf
char *tmp___22 ;

//Stmt11892:Leaf
char *tmp___23 ;

//Stmt11893:Leaf
char *tmp___24 ;

//Stmt11894:Leaf
char *tmp___25 ;

//Stmt11895:Leaf
int compare ;

//Stmt11896:Leaf
int tmp___26 ;

//Stmt11897:Leaf
size_t tmp___27 ;

//Stmt11898:Leaf
int tmp___28 ;

//Stmt11899:Leaf
int tmp___29 ;

//Stmt11900:Leaf
size_t tmp___30 ;

//Stmt11901:Leaf
int tmp___31 ;

//Stmt11902:Leaf
size_t tmp___33 ;

//Stmt11903:Leaf
char *dir ;

//Stmt11904:Leaf
size_t tmp___34 ;

//Stmt11905:Leaf
size_t tmp___35 ;

 
   {
//Stmt11906:Leaf
last = (struct loaded_l10nfile *)((void *)0);

//Stmt11907:Leaf
tmp = strlen(language);

//Stmt11908:Parent
if ((mask & 32) != 0) {
//Stmt11754:Leaf
tmp___0 = strlen(territory);

//Stmt11755:Leaf
tmp___1 = tmp___0 + 1UL;

   } else {
//Stmt11756:Leaf
tmp___1 = (size_t )0;

   }

//Stmt11909:Parent
if ((mask & 16) != 0) {
//Stmt11757:Leaf
tmp___2 = strlen(codeset);

//Stmt11758:Leaf
tmp___3 = tmp___2 + 1UL;

   } else {
//Stmt11759:Leaf
tmp___3 = (size_t )0;

   }

//Stmt11910:Parent
if ((mask & 8) != 0) {
//Stmt11760:Leaf
tmp___4 = strlen(normalized_codeset);

//Stmt11761:Leaf
tmp___5 = tmp___4 + 1UL;

   } else {
//Stmt11762:Leaf
tmp___5 = (size_t )0;

   }

//Stmt11911:Parent
if ((mask & 128) != 0) {
//Stmt11766:Leaf
tmp___6 = strlen(modifier);

//Stmt11767:Leaf
tmp___7 = tmp___6 + 1UL;

   } else
   {
//Stmt11768:Parent
if ((mask & 64) != 0) {
//Stmt11763:Leaf
tmp___6 = strlen(modifier);

//Stmt11764:Leaf
tmp___7 = tmp___6 + 1UL;

   } else {
//Stmt11765:Leaf
tmp___7 = (size_t )0;

   }
}


//Stmt11912:Parent
if ((mask & 4) != 0) {
//Stmt11769:Leaf
tmp___8 = strlen(special);

//Stmt11770:Leaf
tmp___9 = tmp___8 + 1UL;

   } else {
//Stmt11771:Leaf
tmp___9 = (size_t )0;

   }

//Stmt11913:Parent
if ((mask & 2) != 0) {
//Stmt11782:Leaf
goto _L;

   } else
   {
//Stmt11783:Parent
if ((mask & 1) != 0) {
     _L: /* CIL Label */ 
     {
//Stmt11775:Parent
if ((mask & 2) != 0) {
//Stmt11772:Leaf
tmp___10 = strlen(sponsor);

//Stmt11773:Leaf
tmp___11 = tmp___10 + 1UL;

     } else {
//Stmt11774:Leaf
tmp___11 = (size_t )0;

     }
}

//Stmt11779:Parent
if ((mask & 1) != 0) {
//Stmt11776:Leaf
tmp___12 = strlen(revision);

//Stmt11777:Leaf
tmp___13 = tmp___12 + 1UL;

     } else {
//Stmt11778:Leaf
tmp___13 = (size_t )0;

     }

//Stmt11780:Leaf
tmp___14 = (1UL + tmp___11) + tmp___13;

   } else {
//Stmt11781:Leaf
tmp___14 = (size_t )0;

   }
}


//Stmt11914:Leaf
tmp___15 = strlen(filename);

//Stmt11915:Leaf
tmp___16 = (int )malloc((((((((((dirlist_len + tmp) + tmp___1) + tmp___3) + tmp___5) + tmp___7) + tmp___9) + tmp___14) + 1UL) + tmp___15) + 1UL);

//Stmt11916:Leaf
abs_filename = (char *)tmp___16;

//Stmt11917:Parent
if ((unsigned long )abs_filename == (unsigned long )((void *)0)) {
//Stmt11784:Leaf
return ((struct loaded_l10nfile *)((void *)0));

   }

//Stmt11918:Leaf
retval = (struct loaded_l10nfile *)((void *)0);

//Stmt11919:Leaf
last = (struct loaded_l10nfile *)((void *)0);

//Stmt11920:Leaf
memcpy((void * __restrict  )abs_filename, (void const   * __restrict  )dirlist,
          dirlist_len);

//Stmt11921:Leaf
argz_stringify__(abs_filename, dirlist_len, ':');

//Stmt11922:Leaf
cp = abs_filename + (dirlist_len - 1UL);

//Stmt11923:Leaf
tmp___17 = cp;

//Stmt11924:Leaf
cp ++;

//Stmt11925:Leaf
*tmp___17 = (char )'/';

//Stmt11926:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )language);

//Stmt11927:Parent
if ((mask & 32) != 0) {
//Stmt11785:Leaf
tmp___18 = cp;

//Stmt11786:Leaf
cp ++;

//Stmt11787:Leaf
*tmp___18 = (char )'_';

//Stmt11788:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )territory);

   }

//Stmt11928:Parent
if ((mask & 16) != 0) {
//Stmt11789:Leaf
tmp___19 = cp;

//Stmt11790:Leaf
cp ++;

//Stmt11791:Leaf
*tmp___19 = (char )'.';

//Stmt11792:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )codeset);

   }

//Stmt11929:Parent
if ((mask & 8) != 0) {
//Stmt11793:Leaf
tmp___20 = cp;

//Stmt11794:Leaf
cp ++;

//Stmt11795:Leaf
*tmp___20 = (char )'.';

//Stmt11796:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )normalized_codeset);

   }

//Stmt11930:Parent
if ((mask & 192) != 0) {
//Stmt11799:Leaf
tmp___21 = cp;

//Stmt11800:Leaf
cp ++;

//Stmt11801:Parent
if ((mask & 64) != 0) {
//Stmt11797:Leaf
*tmp___21 = (char )'+';

     } else {
//Stmt11798:Leaf
*tmp___21 = (char )'@';

     }

//Stmt11802:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )modifier);

   }

//Stmt11931:Parent
if ((mask & 4) != 0) {
//Stmt11803:Leaf
tmp___22 = cp;

//Stmt11804:Leaf
cp ++;

//Stmt11805:Leaf
*tmp___22 = (char )'+';

//Stmt11806:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )special);

   }

//Stmt11932:Parent
if ((mask & 3) != 0) {
//Stmt11812:Leaf
tmp___23 = cp;

//Stmt11813:Leaf
cp ++;

//Stmt11814:Leaf
*tmp___23 = (char )',';

//Stmt11815:Parent
if ((mask & 2) != 0) {
//Stmt11807:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )sponsor);

     }

//Stmt11816:Parent
if ((mask & 1) != 0) {
//Stmt11808:Leaf
tmp___24 = cp;

//Stmt11809:Leaf
cp ++;

//Stmt11810:Leaf
*tmp___24 = (char )'_';

//Stmt11811:Leaf
cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )revision);

     }

   }

//Stmt11933:Leaf
tmp___25 = cp;

//Stmt11934:Leaf
cp ++;

//Stmt11935:Leaf
*tmp___25 = (char )'/';

//Stmt11936:Leaf
stpcpy((char * __restrict  )cp, (char const   * __restrict  )filename);

//Stmt11937:Leaf
last = (struct loaded_l10nfile *)((void *)0);

//Stmt11938:Leaf
retval = *l10nfile_list;

//Stmt11939:Parent
while ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt11825:Parent
if ((unsigned long )retval->filename != (unsigned long )((void *)0)) {
//Stmt11820:Leaf
tmp___26 = strcmp(retval->filename, (char const   *)abs_filename);

//Stmt11821:Leaf
compare = tmp___26;

//Stmt11822:Parent
if (compare == 0) {
//Stmt11817:Leaf
break;

       }

//Stmt11823:Parent
if (compare < 0) {
//Stmt11818:Leaf
retval = (struct loaded_l10nfile *)((void *)0);

//Stmt11819:Leaf
break;

       }

//Stmt11824:Leaf
last = retval;

     }

//Stmt11826:Leaf
retval = retval->next;

   }

//Stmt11940:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt11829:Leaf
free(abs_filename);

//Stmt11830:Leaf
return (retval);

   } else
   {
//Stmt11831:Parent
if (do_allocate == 0) {
//Stmt11827:Leaf
free(abs_filename);

//Stmt11828:Leaf
return (retval);

   }
}


//Stmt11941:Leaf
tmp___27 = argz_count__(dirlist, dirlist_len);

//Stmt11942:Leaf
tmp___28 = pop(mask);

//Stmt11943:Leaf
tmp___29 = (int )malloc(sizeof(*retval) + (tmp___27 * (size_t )(1 << tmp___28)) * sizeof(struct loaded_l10nfile *));

//Stmt11944:Leaf
retval = (struct loaded_l10nfile *)tmp___29;

//Stmt11945:Parent
if ((unsigned long )retval == (unsigned long )((void *)0)) {
//Stmt11832:Leaf
return ((struct loaded_l10nfile *)((void *)0));

   }

//Stmt11946:Leaf
retval->filename = (char const   *)abs_filename;

//Stmt11947:Leaf
tmp___30 = argz_count__(dirlist, dirlist_len);

//Stmt11948:Parent
if (tmp___30 != 1UL) {
//Stmt11837:Leaf
tmp___31 = 1;

   } else
   {
//Stmt11838:Parent
if ((mask & 16) != 0) {
//Stmt11835:Parent
if ((mask & 8) != 0) {
//Stmt11833:Leaf
tmp___31 = 1;

     } else {
//Stmt11834:Leaf
tmp___31 = 0;

     }

   } else {
//Stmt11836:Leaf
tmp___31 = 0;

   }
}


//Stmt11949:Leaf
retval->decided = tmp___31;

//Stmt11950:Leaf
retval->data = (void const   *)((void *)0);

//Stmt11951:Parent
if ((unsigned long )last == (unsigned long )((void *)0)) {
//Stmt11839:Leaf
retval->next = *l10nfile_list;

//Stmt11840:Leaf
*l10nfile_list = retval;

   } else {
//Stmt11841:Leaf
retval->next = last->next;

//Stmt11842:Leaf
last->next = retval;

   }

//Stmt11952:Leaf
entries = (size_t )0;

//Stmt11953:Leaf
tmp___33 = argz_count__(dirlist, dirlist_len);

//Stmt11954:Parent
if (tmp___33 == 1UL) {
//Stmt11843:Leaf
cnt = mask - 1;

   } else {
//Stmt11844:Leaf
cnt = mask;

   }

//Stmt11955:Parent
while (cnt >= 0) {
//Stmt11860:Parent
if ((cnt & ~ mask) == 0) {
//Stmt11859:Parent
if ((cnt & 71) == 0) {
//Stmt11857:Leaf
goto _L___1;

       } else
       {
//Stmt11858:Parent
if ((cnt & 152) == 0) {
         _L___1: /* CIL Label */ 
         {
//Stmt11856:Parent
if ((cnt & 16) == 0) {
//Stmt11854:Leaf
goto _L___0;

         } else
         {
//Stmt11855:Parent
if ((cnt & 8) == 0) {
           _L___0: /* CIL Label */ 
           {
//Stmt11845:Leaf
dir = (char *)((void *)0);

}
//Stmt11853:Parent
while (1) {
//Stmt11847:Leaf
dir = argz_next__((char *)dirlist, dirlist_len, (char const   *)dir);

//Stmt11848:Parent
if (! ((unsigned long )dir != (unsigned long )((void *)0))) {
//Stmt11846:Leaf
break;

             }

//Stmt11849:Leaf
tmp___34 = entries;

//Stmt11850:Leaf
entries ++;

//Stmt11851:Leaf
tmp___35 = strlen((char const   *)dir);

//Stmt11852:Leaf
retval->successor[tmp___34] = _nl_make_l10nflist(l10nfile_list, (char const   *)dir,
                                                              tmp___35 + 1UL, cnt,
                                                              language, territory,
                                                              codeset, normalized_codeset,
                                                              modifier, special, sponsor,
                                                              revision, filename, 1);

           }

         }
}

}

       }
}


     }

//Stmt11861:Leaf
cnt --;

   }

//Stmt11956:Leaf
retval->successor[entries] = (struct loaded_l10nfile *)((void *)0);

//Stmt11957:Leaf
return (retval);

 }
}
 static char const   *_nl_normalize_codeset(unsigned char const   *codeset , size_t name_len ) 
 { 
//Stmt11985:Leaf
int len ;

//Stmt11986:Leaf
int only_digit ;

//Stmt11987:Leaf
char *retval ;

//Stmt11988:Leaf
char *wp ;

//Stmt11989:Leaf
size_t cnt ;

//Stmt11990:Leaf
unsigned short const   **tmp ;

//Stmt11991:Leaf
unsigned short const   **tmp___0 ;

//Stmt11992:Leaf
int tmp___1 ;

//Stmt11993:Leaf
int tmp___2 ;

//Stmt11994:Leaf
char *tmp___3 ;

//Stmt11995:Leaf
int tmp___4 ;

//Stmt11996:Leaf
char *tmp___5 ;

//Stmt11997:Leaf
unsigned short const   **tmp___6 ;

//Stmt11998:Leaf
unsigned short const   **tmp___7 ;

 
   {
//Stmt11999:Leaf
len = 0;

//Stmt12000:Leaf
only_digit = 1;

//Stmt12001:Leaf
cnt = (size_t )0;

//Stmt12002:Parent
while (cnt < name_len) {
//Stmt11962:Leaf
tmp___0 = __ctype_b_loc();

//Stmt11963:Parent
if ((int const   )*(*tmp___0 + (int )*(codeset + cnt)) & 8) {
//Stmt11959:Leaf
len ++;

//Stmt11960:Leaf
tmp = __ctype_b_loc();

//Stmt11961:Parent
if ((int const   )*(*tmp + (int )*(codeset + cnt)) & 1024) {
//Stmt11958:Leaf
only_digit = 0;

       }

     }

//Stmt11964:Leaf
cnt ++;

   }

//Stmt12003:Parent
if (only_digit) {
//Stmt11965:Leaf
tmp___1 = 3;

   } else {
//Stmt11966:Leaf
tmp___1 = 0;

   }

//Stmt12004:Leaf
tmp___2 = (int )malloc((tmp___1 + len) + 1);

//Stmt12005:Leaf
retval = (char *)tmp___2;

//Stmt12006:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt11981:Parent
if (only_digit) {
//Stmt11967:Leaf
wp = stpcpy((char * __restrict  )retval, (char const   * __restrict  )"iso");

     } else {
//Stmt11968:Leaf
wp = retval;

     }

//Stmt11982:Leaf
cnt = (size_t )0;

//Stmt11983:Parent
while (cnt < name_len) {
//Stmt11978:Leaf
tmp___7 = __ctype_b_loc();

//Stmt11979:Parent
if ((int const   )*(*tmp___7 + (int )*(codeset + cnt)) & 1024) {
//Stmt11972:Leaf
tmp___3 = wp;

//Stmt11973:Leaf
wp ++;

//Stmt11974:Leaf
tmp___4 = tolower((int )*(codeset + cnt));

//Stmt11975:Leaf
*tmp___3 = (char )tmp___4;

       } else {
//Stmt11976:Leaf
tmp___6 = __ctype_b_loc();

//Stmt11977:Parent
if ((int const   )*(*tmp___6 + (int )*(codeset + cnt)) & 2048) {
//Stmt11969:Leaf
tmp___5 = wp;

//Stmt11970:Leaf
wp ++;

//Stmt11971:Leaf
*tmp___5 = (char )*(codeset + cnt);

         }

       }

//Stmt11980:Leaf
cnt ++;

     }

//Stmt11984:Leaf
*wp = (char )'\000';

   }

//Stmt12007:Leaf
return ((char const   *)retval);

 }
}
 static int _nl_explode_name(char *name , char const   **language , char const   **modifier ,
                             char const   **territory , char const   **codeset , char const   **normalized_codeset ,
                             char const   **special , char const   **sponsor , char const   **revision ) 
 { 
//Stmt12124:Leaf
enum __anonenum_syntax_17 syntax ;

//Stmt12125:Leaf
char *cp ;

//Stmt12126:Leaf
int mask ;

//Stmt12127:Leaf
int tmp ;

 
   {
//Stmt12128:Leaf
*modifier = (char const   *)((void *)0);

//Stmt12129:Leaf
*territory = (char const   *)((void *)0);

//Stmt12130:Leaf
*codeset = (char const   *)((void *)0);

//Stmt12131:Leaf
*normalized_codeset = (char const   *)((void *)0);

//Stmt12132:Leaf
*special = (char const   *)((void *)0);

//Stmt12133:Leaf
*sponsor = (char const   *)((void *)0);

//Stmt12134:Leaf
*revision = (char const   *)((void *)0);

//Stmt12135:Leaf
mask = 0;

//Stmt12136:Leaf
syntax = (enum __anonenum_syntax_17 )0;

//Stmt12137:Leaf
cp = name;

//Stmt12138:Leaf
*language = (char const   *)cp;

//Stmt12139:Parent
while (1) {
//Stmt12017:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12015:Parent
if ((int )*(cp + 0) != 95) {
//Stmt12013:Parent
if ((int )*(cp + 0) != 64) {
//Stmt12011:Parent
if ((int )*(cp + 0) != 43) {
//Stmt12009:Parent
if (! ((int )*(cp + 0) != 44)) {
//Stmt12008:Leaf
break;

             }

           } else {
//Stmt12010:Leaf
break;

           }

         } else {
//Stmt12012:Leaf
break;

         }

       } else {
//Stmt12014:Leaf
break;

       }

     } else {
//Stmt12016:Leaf
break;

     }

//Stmt12018:Leaf
cp ++;

   }

//Stmt12140:Parent
if ((unsigned long )*language == (unsigned long )cp) {
//Stmt12056:Leaf
cp = strchr(*language, '\000');

   } else
   {
//Stmt12057:Parent
if ((int )*(cp + 0) == 95) {
//Stmt12050:Leaf
*(cp + 0) = (char )'\000';

//Stmt12051:Leaf
cp ++;

//Stmt12052:Leaf
*territory = (char const   *)cp;

//Stmt12053:Parent
while (1) {
//Stmt12030:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12028:Parent
if ((int )*(cp + 0) != 46) {
//Stmt12026:Parent
if ((int )*(cp + 0) != 64) {
//Stmt12024:Parent
if ((int )*(cp + 0) != 43) {
//Stmt12022:Parent
if ((int )*(cp + 0) != 44) {
//Stmt12020:Parent
if (! ((int )*(cp + 0) != 95)) {
//Stmt12019:Leaf
break;

                 }

               } else {
//Stmt12021:Leaf
break;

               }

             } else {
//Stmt12023:Leaf
break;

             }

           } else {
//Stmt12025:Leaf
break;

           }

         } else {
//Stmt12027:Leaf
break;

         }

       } else {
//Stmt12029:Leaf
break;

       }

//Stmt12031:Leaf
cp ++;

     }

//Stmt12054:Leaf
mask |= 32;

//Stmt12055:Parent
if ((int )*(cp + 0) == 46) {
//Stmt12043:Leaf
syntax = (enum __anonenum_syntax_17 )1;

//Stmt12044:Leaf
*(cp + 0) = (char )'\000';

//Stmt12045:Leaf
cp ++;

//Stmt12046:Leaf
*codeset = (char const   *)cp;

//Stmt12047:Parent
while (1) {
//Stmt12035:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12033:Parent
if (! ((int )*(cp + 0) != 64)) {
//Stmt12032:Leaf
break;

           }

         } else {
//Stmt12034:Leaf
break;

         }

//Stmt12036:Leaf
cp ++;

       }

//Stmt12048:Leaf
mask |= 16;

//Stmt12049:Parent
if ((unsigned long )*codeset != (unsigned long )cp) {
//Stmt12042:Parent
if ((int const   )*(*codeset + 0) != 0) {
//Stmt12039:Leaf
*normalized_codeset = _nl_normalize_codeset((unsigned char const   *)*codeset,
                                                       (size_t )(cp - (char *)*codeset));

//Stmt12040:Leaf
tmp = strcmp(*codeset, *normalized_codeset);

//Stmt12041:Parent
if (tmp == 0) {
//Stmt12037:Leaf
free((char *)*normalized_codeset);

           } else {
//Stmt12038:Leaf
mask |= 8;

           }

         }

       }

     }

   }
}


//Stmt12141:Parent
if ((int )*(cp + 0) == 64) {
//Stmt12078:Leaf
goto _L;

   } else
   {
//Stmt12079:Parent
if ((unsigned int )syntax != 1U) {
//Stmt12077:Parent
if ((int )*(cp + 0) == 43) {
       _L: /* CIL Label */ 
       {
//Stmt12060:Parent
if ((int )*(cp + 0) == 64) {
//Stmt12058:Leaf
syntax = (enum __anonenum_syntax_17 )1;

       } else {
//Stmt12059:Leaf
syntax = (enum __anonenum_syntax_17 )2;

       }
}

//Stmt12072:Leaf
*(cp + 0) = (char )'\000';

//Stmt12073:Leaf
cp ++;

//Stmt12074:Leaf
*modifier = (char const   *)cp;

//Stmt12075:Parent
while (1) {
//Stmt12070:Parent
if ((unsigned int )syntax == 2U) {
//Stmt12068:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12066:Parent
if ((int )*(cp + 0) != 43) {
//Stmt12064:Parent
if ((int )*(cp + 0) != 44) {
//Stmt12062:Parent
if (! ((int )*(cp + 0) != 95)) {
//Stmt12061:Leaf
break;

                 }

               } else {
//Stmt12063:Leaf
break;

               }

             } else {
//Stmt12065:Leaf
break;

             }

           } else {
//Stmt12067:Leaf
break;

           }

         } else {
//Stmt12069:Leaf
break;

         }

//Stmt12071:Leaf
cp ++;

       }

//Stmt12076:Leaf
mask |= 192;

     }

   }
}


//Stmt12142:Parent
if ((unsigned int )syntax != 1U) {
//Stmt12114:Parent
if ((int )*(cp + 0) == 43) {
//Stmt12112:Leaf
goto _L___0;

     } else
     {
//Stmt12113:Parent
if ((int )*(cp + 0) == 44) {
//Stmt12110:Leaf
goto _L___0;

     } else
     {
//Stmt12111:Parent
if ((int )*(cp + 0) == 95) {
       _L___0: /* CIL Label */ 
       {
//Stmt12080:Leaf
syntax = (enum __anonenum_syntax_17 )2;

}
//Stmt12107:Parent
if ((int )*(cp + 0) == 43) {
//Stmt12088:Leaf
*(cp + 0) = (char )'\000';

//Stmt12089:Leaf
cp ++;

//Stmt12090:Leaf
*special = (char const   *)cp;

//Stmt12091:Parent
while (1) {
//Stmt12086:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12084:Parent
if ((int )*(cp + 0) != 44) {
//Stmt12082:Parent
if (! ((int )*(cp + 0) != 95)) {
//Stmt12081:Leaf
break;

               }

             } else {
//Stmt12083:Leaf
break;

             }

           } else {
//Stmt12085:Leaf
break;

           }

//Stmt12087:Leaf
cp ++;

         }

//Stmt12092:Leaf
mask |= 4;

       }

//Stmt12108:Parent
if ((int )*(cp + 0) == 44) {
//Stmt12098:Leaf
*(cp + 0) = (char )'\000';

//Stmt12099:Leaf
cp ++;

//Stmt12100:Leaf
*sponsor = (char const   *)cp;

//Stmt12101:Parent
while (1) {
//Stmt12096:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12094:Parent
if (! ((int )*(cp + 0) != 95)) {
//Stmt12093:Leaf
break;

             }

           } else {
//Stmt12095:Leaf
break;

           }

//Stmt12097:Leaf
cp ++;

         }

//Stmt12102:Leaf
mask |= 2;

       }

//Stmt12109:Parent
if ((int )*(cp + 0) == 95) {
//Stmt12103:Leaf
*(cp + 0) = (char )'\000';

//Stmt12104:Leaf
cp ++;

//Stmt12105:Leaf
*revision = (char const   *)cp;

//Stmt12106:Leaf
mask |= 1;

       }

     }
}

}


   }

//Stmt12143:Parent
if ((unsigned int )syntax == 1U) {
//Stmt12121:Parent
if ((unsigned long )*territory != (unsigned long )((void *)0)) {
//Stmt12116:Parent
if ((int const   )*(*territory + 0) == 0) {
//Stmt12115:Leaf
mask &= -33;

       }

     }

//Stmt12122:Parent
if ((unsigned long )*codeset != (unsigned long )((void *)0)) {
//Stmt12118:Parent
if ((int const   )*(*codeset + 0) == 0) {
//Stmt12117:Leaf
mask &= -17;

       }

     }

//Stmt12123:Parent
if ((unsigned long )*modifier != (unsigned long )((void *)0)) {
//Stmt12120:Parent
if ((int const   )*(*modifier + 0) == 0) {
//Stmt12119:Leaf
mask &= -129;

       }

     }

   }

//Stmt12144:Leaf
return (mask);

 }
}
 __inline static nls_uint32 SWAP(nls_uint32 i ) ;
 __inline static nls_uint32 SWAP(nls_uint32 i ) 
 { 
 
 
{
//Stmt12145:Leaf
return ((((i << 24) | ((i & 65280U) << 8)) | ((i >> 8) & 65280U)) | (i >> 24));

 }
}
 int _nl_msg_cat_cntr  =    0;
 static void _nl_load_domain(struct loaded_l10nfile *domain_file ) 
 { 
//Stmt12208:Leaf
int fd ;

//Stmt12209:Leaf
size_t size ;

//Stmt12210:Leaf
struct stat st ;

//Stmt12211:Leaf
struct mo_file_header *data ;

//Stmt12212:Leaf
struct loaded_domain *domain ;

//Stmt12213:Leaf
int tmp ;

//Stmt12214:Leaf
size_t to_read ;

//Stmt12215:Leaf
char *read_ptr ;

//Stmt12216:Leaf
int tmp___0 ;

//Stmt12217:Leaf
long nb ;

//Stmt12218:Leaf
ssize_t tmp___1 ;

//Stmt12219:Leaf
int tmp___2 ;

//Stmt12220:Leaf
nls_uint32 tmp___3 ;

//Stmt12221:Leaf
nls_uint32 tmp___4 ;

//Stmt12222:Leaf
nls_uint32 tmp___5 ;

//Stmt12223:Leaf
nls_uint32 tmp___6 ;

//Stmt12224:Leaf
nls_uint32 tmp___7 ;

//Stmt12225:Leaf
nls_uint32 tmp___8 ;

//Stmt12226:Leaf
nls_uint32 tmp___9 ;

//Stmt12227:Leaf
nls_uint32 tmp___10 ;

//Stmt12228:Leaf
nls_uint32 tmp___11 ;

//Stmt12229:Leaf
nls_uint32 tmp___12 ;

 
   {
//Stmt12230:Leaf
data = (struct mo_file_header *)-1;

//Stmt12231:Leaf
domain_file->decided = 1;

//Stmt12232:Leaf
domain_file->data = (void const   *)((void *)0);

//Stmt12233:Parent
if ((unsigned long )domain_file->filename == (unsigned long )((void *)0)) {
//Stmt12146:Leaf
return;

   }

//Stmt12234:Leaf
fd = open(domain_file->filename, 0);

//Stmt12235:Parent
if (fd == -1) {
//Stmt12147:Leaf
return;

   }

//Stmt12236:Leaf
tmp = fstat(fd, & st);

//Stmt12237:Parent
if (tmp != 0) {
//Stmt12153:Leaf
close(fd);

//Stmt12154:Leaf
return;

   } else {
//Stmt12155:Leaf
size = (size_t )st.st_size;

//Stmt12156:Parent
if (size != (size_t )st.st_size) {
//Stmt12150:Leaf
close(fd);

//Stmt12151:Leaf
return;

     } else
     {
//Stmt12152:Parent
if (size < sizeof(struct mo_file_header )) {
//Stmt12148:Leaf
close(fd);

//Stmt12149:Leaf
return;

     }
}


   }

//Stmt12238:Parent
if ((unsigned long )data == (unsigned long )((struct mo_file_header *)-1)) {
//Stmt12167:Leaf
tmp___0 = (int )malloc(size);

//Stmt12168:Leaf
data = (struct mo_file_header *)tmp___0;

//Stmt12169:Parent
if ((unsigned long )data == (unsigned long )((void *)0)) {
//Stmt12157:Leaf
return;

     }

//Stmt12170:Leaf
to_read = size;

//Stmt12171:Leaf
read_ptr = (char *)data;

//Stmt12172:Parent
while (1) {
//Stmt12161:Leaf
tmp___1 = read(fd, (void *)read_ptr, to_read);

//Stmt12162:Leaf
nb = tmp___1;

//Stmt12163:Parent
if (nb == -1L) {
//Stmt12158:Leaf
close(fd);

//Stmt12159:Leaf
return;

       }

//Stmt12164:Leaf
read_ptr += nb;

//Stmt12165:Leaf
to_read -= (size_t )nb;

//Stmt12166:Parent
if (! (to_read > 0UL)) {
//Stmt12160:Leaf
break;

       }

     }

//Stmt12173:Leaf
close(fd);

   }

//Stmt12239:Parent
if (data->magic != 2500072158U) {
//Stmt12176:Parent
if (data->magic != 3725722773U) {
//Stmt12174:Leaf
free(data);

//Stmt12175:Leaf
return;

     }

   }

//Stmt12240:Leaf
tmp___2 = (int )malloc(sizeof(struct loaded_domain ));

//Stmt12241:Leaf
domain_file->data = (void const   *)((struct loaded_domain *)tmp___2);

//Stmt12242:Parent
if ((unsigned long )domain_file->data == (unsigned long )((void *)0)) {
//Stmt12177:Leaf
return;

   }

//Stmt12243:Leaf
domain = (struct loaded_domain *)domain_file->data;

//Stmt12244:Leaf
domain->data = (char const   *)((char *)data);

//Stmt12245:Leaf
domain->mmap_size = size;

//Stmt12246:Leaf
domain->must_swap = data->magic != 2500072158U;

//Stmt12247:Parent
if (domain->must_swap) {
//Stmt12178:Leaf
tmp___3 = SWAP(data->revision);

//Stmt12179:Leaf
tmp___4 = tmp___3;

   } else {
//Stmt12180:Leaf
tmp___4 = data->revision;

   }

//Stmt12248:Parent
switch (tmp___4) {
   case 0U:; 
//Stmt12184:Parent
if (domain->must_swap) {
//Stmt12181:Leaf
tmp___5 = SWAP(data->nstrings);

//Stmt12182:Leaf
domain->nstrings = tmp___5;

   } else {
//Stmt12183:Leaf
domain->nstrings = data->nstrings;

   }

//Stmt12198:Parent
if (domain->must_swap) {
//Stmt12185:Leaf
tmp___6 = SWAP(data->orig_tab_offset);

//Stmt12186:Leaf
tmp___7 = tmp___6;

   } else {
//Stmt12187:Leaf
tmp___7 = data->orig_tab_offset;

   }

//Stmt12199:Leaf
domain->orig_tab = (struct string_desc *)((char *)data + tmp___7);

//Stmt12200:Parent
if (domain->must_swap) {
//Stmt12188:Leaf
tmp___8 = SWAP(data->trans_tab_offset);

//Stmt12189:Leaf
tmp___9 = tmp___8;

   } else {
//Stmt12190:Leaf
tmp___9 = data->trans_tab_offset;

   }

//Stmt12201:Leaf
domain->trans_tab = (struct string_desc *)((char *)data + tmp___9);

//Stmt12202:Parent
if (domain->must_swap) {
//Stmt12191:Leaf
tmp___10 = SWAP(data->hash_tab_size);

//Stmt12192:Leaf
domain->hash_size = tmp___10;

   } else {
//Stmt12193:Leaf
domain->hash_size = data->hash_tab_size;

   }

//Stmt12203:Parent
if (domain->must_swap) {
//Stmt12194:Leaf
tmp___11 = SWAP(data->hash_tab_offset);

//Stmt12195:Leaf
tmp___12 = tmp___11;

   } else {
//Stmt12196:Leaf
tmp___12 = data->hash_tab_offset;

   }

//Stmt12204:Leaf
domain->hash_tab = (nls_uint32 *)((char *)data + tmp___12);

   break;
   default:; 
//Stmt12197:Leaf
free(data);

//Stmt12205:Leaf
free(domain);

//Stmt12206:Leaf
domain_file->data = (void const   *)((void *)0);

//Stmt12207:Leaf
return;

   }

//Stmt12249:Leaf
_nl_msg_cat_cntr ++;

//Stmt12250:Leaf
return;

 }
}
 static char *string_space  =    (char *)((void *)0);
 static size_t string_space_act  =    (size_t )0;
 static size_t string_space_max  =    (size_t )0;
 static struct alias_map *map  ;
 static size_t nmap  =    (size_t )0;
 static size_t maxmap  =    (size_t )0;
 static size_t read_alias_file(char const   *fname , int fname_len ) ;
 static void extend_alias_table(void) ;
 static int alias_compare(struct alias_map  const  *map1 , struct alias_map  const  *map2 ) ;
 static char const   *locale_alias_path  =    "/usr/local/share/locale:.";
 extern int ( /* missing proto */  bsearch)() ;
 static char const   *_nl_expand_alias(char const   *name ) 
 { 
//Stmt12278:Leaf
struct alias_map *retval ;

//Stmt12279:Leaf
char const   *result___0 ;

//Stmt12280:Leaf
size_t added ;

//Stmt12281:Leaf
struct alias_map item ;

//Stmt12282:Leaf
int tmp ;

//Stmt12283:Leaf
char const   *start ;

 
   {
//Stmt12284:Leaf
result___0 = (char const   *)((void *)0);

//Stmt12285:Parent
while (1) {
//Stmt12272:Leaf
item.alias = name;

//Stmt12273:Parent
if (nmap > 0UL) {
//Stmt12251:Leaf
tmp = bsearch(& item, map, nmap, sizeof(struct alias_map ), (int (*)(void const   * ,
                                                                            void const   * ))(& alias_compare));

//Stmt12252:Leaf
retval = (struct alias_map *)tmp;

     } else {
//Stmt12253:Leaf
retval = (struct alias_map *)((void *)0);

     }

//Stmt12274:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12254:Leaf
result___0 = retval->value;

//Stmt12255:Leaf
break;

     }

//Stmt12275:Leaf
added = (size_t )0;

//Stmt12276:Parent
while (1) {
//Stmt12266:Parent
if (added == 0UL) {
//Stmt12257:Parent
if (! ((int const   )*(locale_alias_path + 0) != 0)) {
//Stmt12256:Leaf
break;

         }

       } else {
//Stmt12258:Leaf
break;

       }

//Stmt12267:Parent
while ((int const   )*(locale_alias_path + 0) == 58) {
//Stmt12259:Leaf
locale_alias_path ++;

       }

//Stmt12268:Leaf
start = locale_alias_path;

//Stmt12269:Parent
while (1) {
//Stmt12263:Parent
if ((int const   )*(locale_alias_path + 0) != 0) {
//Stmt12261:Parent
if (! ((int const   )*(locale_alias_path + 0) != 58)) {
//Stmt12260:Leaf
break;

           }

         } else {
//Stmt12262:Leaf
break;

         }

//Stmt12264:Leaf
locale_alias_path ++;

       }

//Stmt12270:Parent
if ((unsigned long )start < (unsigned long )locale_alias_path) {
//Stmt12265:Leaf
added = read_alias_file(start, (int )(locale_alias_path - start));

       }

     }

//Stmt12277:Parent
if (! (added != 0UL)) {
//Stmt12271:Leaf
break;

     }

   }

//Stmt12286:Leaf
return (result___0);

 }
}
 static char const   aliasfile[14]  = 
   {      (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
         (char const   )'a',      (char const   )'l',      (char const   )'e',      (char const   )'.', 
         (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'a', 
         (char const   )'s',      (char const   )'\000'};
 static size_t read_alias_file(char const   *fname , int fname_len ) 
 { 
//Stmt12376:Leaf
FILE *fp ;

//Stmt12377:Leaf
char *full_fname ;

//Stmt12378:Leaf
size_t added ;

//Stmt12379:Leaf
void *tmp ;

//Stmt12380:Leaf
unsigned char buf___1[8192] ;

//Stmt12381:Leaf
unsigned char *alias ;

//Stmt12382:Leaf
unsigned char *value ;

//Stmt12383:Leaf
unsigned char *cp ;

//Stmt12384:Leaf
char *tmp___0 ;

//Stmt12385:Leaf
char altbuf[8192] ;

//Stmt12386:Leaf
char *tmp___1 ;

//Stmt12387:Leaf
char *tmp___2 ;

//Stmt12388:Leaf
char *tmp___3 ;

//Stmt12389:Leaf
unsigned short const   **tmp___4 ;

//Stmt12390:Leaf
unsigned char *tmp___5 ;

//Stmt12391:Leaf
unsigned short const   **tmp___6 ;

//Stmt12392:Leaf
unsigned char *tmp___7 ;

//Stmt12393:Leaf
unsigned short const   **tmp___8 ;

//Stmt12394:Leaf
size_t alias_len ;

//Stmt12395:Leaf
size_t value_len ;

//Stmt12396:Leaf
unsigned char *tmp___9 ;

//Stmt12397:Leaf
unsigned short const   **tmp___10 ;

//Stmt12398:Leaf
unsigned char *tmp___11 ;

//Stmt12399:Leaf
unsigned char *tmp___12 ;

//Stmt12400:Leaf
size_t tmp___13 ;

//Stmt12401:Leaf
size_t tmp___14 ;

//Stmt12402:Leaf
size_t new_size ;

//Stmt12403:Leaf
size_t tmp___15 ;

//Stmt12404:Leaf
char *new_pool ;

//Stmt12405:Leaf
int tmp___16 ;

//Stmt12406:Leaf
void *tmp___17 ;

//Stmt12407:Leaf
void *tmp___18 ;

//Stmt12408:Leaf
int tmp___19 ;

 
   {
//Stmt12409:Leaf
tmp = __builtin_alloca((unsigned long )fname_len + sizeof(aliasfile));

//Stmt12410:Leaf
full_fname = (char *)tmp;

//Stmt12411:Leaf
memcpy((void * __restrict  )full_fname, (void const   * __restrict  )fname, (size_t )fname_len);

//Stmt12412:Leaf
memcpy((void * __restrict  )(full_fname + fname_len), (void const   * __restrict  )(aliasfile),
          sizeof(aliasfile));

//Stmt12413:Leaf
fp = fopen((char const   * __restrict  )full_fname, (char const   * __restrict  )"r");

//Stmt12414:Parent
if ((unsigned long )fp == (unsigned long )((void *)0)) {
//Stmt12287:Leaf
return ((size_t )0);

   }

//Stmt12415:Leaf
added = (size_t )0;

//Stmt12416:Parent
while (1) {
//Stmt12366:Leaf
tmp___19 = feof(fp);

//Stmt12367:Parent
if (tmp___19) {
//Stmt12288:Leaf
break;

     }

//Stmt12368:Leaf
tmp___0 = fgets((char * __restrict  )((char *)(buf___1)), (int )sizeof(buf___1),
                     (FILE * __restrict  )fp);

//Stmt12369:Parent
if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
//Stmt12289:Leaf
break;

     }

//Stmt12370:Leaf
tmp___3 = strchr((char const   *)((char *)(buf___1)), '\n');

//Stmt12371:Parent
if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
//Stmt12296:Parent
while (1) {
//Stmt12292:Leaf
tmp___1 = fgets((char * __restrict  )(altbuf), (int )sizeof(altbuf), (FILE * __restrict  )fp);

//Stmt12293:Parent
if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
//Stmt12290:Leaf
break;

         }

//Stmt12294:Leaf
tmp___2 = strchr((char const   *)(altbuf), '\n');

//Stmt12295:Parent
if (! ((unsigned long )tmp___2 == (unsigned long )((void *)0))) {
//Stmt12291:Leaf
break;

         }

       }

     }

//Stmt12372:Leaf
cp = buf___1;

//Stmt12373:Parent
while (1) {
//Stmt12298:Leaf
tmp___4 = __ctype_b_loc();

//Stmt12299:Parent
if (! ((int const   )*(*tmp___4 + (int )*(cp + 0)) & 8192)) {
//Stmt12297:Leaf
break;

       }

//Stmt12300:Leaf
cp ++;

     }

//Stmt12374:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12365:Parent
if ((int )*(cp + 0) != 35) {
//Stmt12358:Leaf
tmp___5 = cp;

//Stmt12359:Leaf
cp ++;

//Stmt12360:Leaf
alias = tmp___5;

//Stmt12361:Parent
while (1) {
//Stmt12305:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12302:Leaf
tmp___6 = __ctype_b_loc();

//Stmt12303:Parent
if ((int const   )*(*tmp___6 + (int )*(cp + 0)) & 8192) {
//Stmt12301:Leaf
break;

             }

           } else {
//Stmt12304:Leaf
break;

           }

//Stmt12306:Leaf
cp ++;

         }

//Stmt12362:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12307:Leaf
tmp___7 = cp;

//Stmt12308:Leaf
cp ++;

//Stmt12309:Leaf
*tmp___7 = (unsigned char )'\000';

         }

//Stmt12363:Parent
while (1) {
//Stmt12311:Leaf
tmp___8 = __ctype_b_loc();

//Stmt12312:Parent
if (! ((int const   )*(*tmp___8 + (int )*(cp + 0)) & 8192)) {
//Stmt12310:Leaf
break;

           }

//Stmt12313:Leaf
cp ++;

         }

//Stmt12364:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12339:Leaf
tmp___9 = cp;

//Stmt12340:Leaf
cp ++;

//Stmt12341:Leaf
value = tmp___9;

//Stmt12342:Parent
while (1) {
//Stmt12318:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12315:Leaf
tmp___10 = __ctype_b_loc();

//Stmt12316:Parent
if ((int const   )*(*tmp___10 + (int )*(cp + 0)) & 8192) {
//Stmt12314:Leaf
break;

               }

             } else {
//Stmt12317:Leaf
break;

             }

//Stmt12319:Leaf
cp ++;

           }

//Stmt12343:Parent
if ((int )*(cp + 0) == 10) {
//Stmt12323:Leaf
tmp___11 = cp;

//Stmt12324:Leaf
cp ++;

//Stmt12325:Leaf
*tmp___11 = (unsigned char )'\000';

//Stmt12326:Leaf
*cp = (unsigned char )'\n';

           } else
           {
//Stmt12327:Parent
if ((int )*(cp + 0) != 0) {
//Stmt12320:Leaf
tmp___12 = cp;

//Stmt12321:Leaf
cp ++;

//Stmt12322:Leaf
*tmp___12 = (unsigned char )'\000';

           }
}


//Stmt12344:Parent
if (nmap >= maxmap) {
//Stmt12328:Leaf
extend_alias_table();

           }

//Stmt12345:Leaf
tmp___13 = strlen((char const   *)((char *)alias));

//Stmt12346:Leaf
alias_len = tmp___13 + 1UL;

//Stmt12347:Leaf
tmp___14 = strlen((char const   *)((char *)value));

//Stmt12348:Leaf
value_len = tmp___14 + 1UL;

//Stmt12349:Parent
if ((string_space_act + alias_len) + value_len > string_space_max) {
//Stmt12332:Parent
if (alias_len + value_len > 1024UL) {
//Stmt12329:Leaf
tmp___15 = alias_len + value_len;

             } else {
//Stmt12330:Leaf
tmp___15 = (size_t )1024;

             }

//Stmt12333:Leaf
new_size = string_space_max + tmp___15;

//Stmt12334:Leaf
tmp___16 = (int )realloc(string_space, new_size);

//Stmt12335:Leaf
new_pool = (char *)tmp___16;

//Stmt12336:Parent
if ((unsigned long )new_pool == (unsigned long )((void *)0)) {
//Stmt12331:Leaf
return (added);

             }

//Stmt12337:Leaf
string_space = new_pool;

//Stmt12338:Leaf
string_space_max = new_size;

           }

//Stmt12350:Leaf
tmp___17 = memcpy((void * __restrict  )(string_space + string_space_act),
                             (void const   * __restrict  )alias, alias_len);

//Stmt12351:Leaf
(map + nmap)->alias = (char const   *)tmp___17;

//Stmt12352:Leaf
string_space_act += alias_len;

//Stmt12353:Leaf
tmp___18 = memcpy((void * __restrict  )(string_space + string_space_act),
                             (void const   * __restrict  )value, value_len);

//Stmt12354:Leaf
(map + nmap)->value = (char const   *)tmp___18;

//Stmt12355:Leaf
string_space_act += value_len;

//Stmt12356:Leaf
nmap ++;

//Stmt12357:Leaf
added ++;

         }

       }

     }

   }

//Stmt12417:Leaf
fclose(fp);

//Stmt12418:Parent
if (added > 0UL) {
//Stmt12375:Leaf
qsort(map, nmap, sizeof(struct alias_map ), (int (*)(void const   * , void const   * ))(& alias_compare));

   }

//Stmt12419:Leaf
return (added);

 }
}
 static void extend_alias_table(void) 
 { 
//Stmt12423:Leaf
size_t new_size ;

//Stmt12424:Leaf
struct alias_map *new_map ;

//Stmt12425:Leaf
int tmp ;

 
   {
//Stmt12426:Parent
if (maxmap == 0UL) {
//Stmt12420:Leaf
new_size = (size_t )100;

   } else {
//Stmt12421:Leaf
new_size = 2UL * maxmap;

   }

//Stmt12427:Leaf
tmp = (int )realloc(map, new_size * sizeof(struct alias_map ));

//Stmt12428:Leaf
new_map = (struct alias_map *)tmp;

//Stmt12429:Parent
if ((unsigned long )new_map == (unsigned long )((void *)0)) {
//Stmt12422:Leaf
return;

   }

//Stmt12430:Leaf
map = new_map;

//Stmt12431:Leaf
maxmap = new_size;

//Stmt12432:Leaf
return;

 }
}
 static int alias_compare(struct alias_map  const  *map1 , struct alias_map  const  *map2 ) 
 { 
//Stmt12450:Leaf
unsigned char const   *p1 ;

//Stmt12451:Leaf
unsigned char const   *p2 ;

//Stmt12452:Leaf
unsigned char c1 ;

//Stmt12453:Leaf
unsigned char c2 ;

//Stmt12454:Leaf
int tmp___0 ;

//Stmt12455:Leaf
unsigned short const   **tmp___1 ;

//Stmt12456:Leaf
int tmp___3 ;

//Stmt12457:Leaf
unsigned short const   **tmp___4 ;

 
   {
//Stmt12458:Leaf
p1 = (unsigned char const   *)map1->alias;

//Stmt12459:Leaf
p2 = (unsigned char const   *)map2->alias;

//Stmt12460:Parent
if ((unsigned long )p1 == (unsigned long )p2) {
//Stmt12433:Leaf
return (0);

   }

//Stmt12461:Parent
while (1) {
//Stmt12442:Leaf
tmp___1 = __ctype_b_loc();

//Stmt12443:Parent
if ((int const   )*(*tmp___1 + (int )*p1) & 256) {
//Stmt12434:Leaf
tmp___0 = tolower((int )*p1);

//Stmt12435:Leaf
c1 = (unsigned char )tmp___0;

     } else {
//Stmt12436:Leaf
c1 = (unsigned char )*p1;

     }

//Stmt12444:Leaf
tmp___4 = __ctype_b_loc();

//Stmt12445:Parent
if ((int const   )*(*tmp___4 + (int )*p2) & 256) {
//Stmt12437:Leaf
tmp___3 = tolower((int )*p2);

//Stmt12438:Leaf
c2 = (unsigned char )tmp___3;

     } else {
//Stmt12439:Leaf
c2 = (unsigned char )*p2;

     }

//Stmt12446:Parent
if ((int )c1 == 0) {
//Stmt12440:Leaf
break;

     }

//Stmt12447:Leaf
p1 ++;

//Stmt12448:Leaf
p2 ++;

//Stmt12449:Parent
if (! ((int )c1 == (int )c2)) {
//Stmt12441:Leaf
break;

     }

   }

//Stmt12462:Leaf
return ((int )c1 - (int )c2);

 }
}
 char *gettext(char const   *msgid ) ;
 char *dgettext(char const   *domainname , char const   *msgid ) ;
 char *dcgettext__(char const   *domainname , char const   *msgid , int category ) ;
 static struct loaded_l10nfile *_nl_loaded_domains  ;
 static struct loaded_l10nfile *_nl_find_domain(char const   *dirname , char *locale ,
                                                char const   *domainname ) 
 { 
//Stmt12491:Leaf
struct loaded_l10nfile *retval ;

//Stmt12492:Leaf
char const   *language ;

//Stmt12493:Leaf
char const   *modifier ;

//Stmt12494:Leaf
char const   *territory ;

//Stmt12495:Leaf
char const   *codeset ;

//Stmt12496:Leaf
char const   *normalized_codeset ;

//Stmt12497:Leaf
char const   *special ;

//Stmt12498:Leaf
char const   *sponsor ;

//Stmt12499:Leaf
char const   *revision ;

//Stmt12500:Leaf
char const   *alias_value ;

//Stmt12501:Leaf
int mask ;

//Stmt12502:Leaf
size_t tmp ;

//Stmt12503:Leaf
int cnt ;

//Stmt12504:Leaf
struct loaded_l10nfile *tmp___0 ;

//Stmt12505:Leaf
size_t tmp___1 ;

//Stmt12506:Leaf
int cnt___0 ;

 
   {
//Stmt12507:Leaf
tmp = strlen(dirname);

//Stmt12508:Leaf
retval = _nl_make_l10nflist(& _nl_loaded_domains, dirname, tmp + 1UL, 0, (char const   *)locale,
                               (char const   *)((void *)0), (char const   *)((void *)0),
                               (char const   *)((void *)0), (char const   *)((void *)0),
                               (char const   *)((void *)0), (char const   *)((void *)0),
                               (char const   *)((void *)0), domainname, 0);

//Stmt12509:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12472:Parent
if (retval->decided == 0) {
//Stmt12463:Leaf
_nl_load_domain(retval);

     }

//Stmt12473:Parent
if ((unsigned long )retval->data != (unsigned long )((void *)0)) {
//Stmt12464:Leaf
return (retval);

     }

//Stmt12474:Leaf
cnt = 0;

//Stmt12475:Parent
while ((unsigned long )retval->successor[cnt] != (unsigned long )((void *)0)) {
//Stmt12467:Parent
if ((retval->successor[cnt])->decided == 0) {
//Stmt12465:Leaf
_nl_load_domain(retval->successor[cnt]);

       }

//Stmt12468:Parent
if ((unsigned long )(retval->successor[cnt])->data != (unsigned long )((void *)0)) {
//Stmt12466:Leaf
break;

       }

//Stmt12469:Leaf
cnt ++;

     }

//Stmt12476:Parent
if (cnt >= 0) {
//Stmt12470:Leaf
tmp___0 = retval;

     } else {
//Stmt12471:Leaf
tmp___0 = (struct loaded_l10nfile *)((void *)0);

     }

//Stmt12477:Leaf
return (tmp___0);

   }

//Stmt12510:Leaf
alias_value = _nl_expand_alias((char const   *)locale);

//Stmt12511:Parent
if ((unsigned long )alias_value != (unsigned long )((void *)0)) {
//Stmt12479:Leaf
locale = strdup(alias_value);

//Stmt12480:Parent
if ((unsigned long )locale == (unsigned long )((void *)0)) {
//Stmt12478:Leaf
return ((struct loaded_l10nfile *)((void *)0));

     }

   }

//Stmt12512:Leaf
mask = _nl_explode_name(locale, & language, & modifier, & territory, & codeset,
                           & normalized_codeset, & special, & sponsor, & revision);

//Stmt12513:Leaf
tmp___1 = strlen(dirname);

//Stmt12514:Leaf
retval = _nl_make_l10nflist(& _nl_loaded_domains, dirname, tmp___1 + 1UL, mask,
                               language, territory, codeset, normalized_codeset, modifier,
                               special, sponsor, revision, domainname, 1);

//Stmt12515:Parent
if ((unsigned long )retval == (unsigned long )((void *)0)) {
//Stmt12481:Leaf
return ((struct loaded_l10nfile *)((void *)0));

   }

//Stmt12516:Parent
if (retval->decided == 0) {
//Stmt12482:Leaf
_nl_load_domain(retval);

   }

//Stmt12517:Parent
if ((unsigned long )retval->data == (unsigned long )((void *)0)) {
//Stmt12488:Leaf
cnt___0 = 0;

//Stmt12489:Parent
while ((unsigned long )retval->successor[cnt___0] != (unsigned long )((void *)0)) {
//Stmt12485:Parent
if ((retval->successor[cnt___0])->decided == 0) {
//Stmt12483:Leaf
_nl_load_domain(retval->successor[cnt___0]);

       }

//Stmt12486:Parent
if ((unsigned long )(retval->successor[cnt___0])->data != (unsigned long )((void *)0)) {
//Stmt12484:Leaf
break;

       }

//Stmt12487:Leaf
cnt___0 ++;

     }

   }

//Stmt12518:Parent
if ((unsigned long )alias_value != (unsigned long )((void *)0)) {
//Stmt12490:Leaf
free(locale);

   }

//Stmt12519:Leaf
return (retval);

 }
}
 __inline static unsigned long hash_string(char const   *str_param ) ;
 __inline static unsigned long hash_string(char const   *str_param ) 
 { 
//Stmt12528:Leaf
unsigned long hval ;

//Stmt12529:Leaf
unsigned long g ;

//Stmt12530:Leaf
char const   *str ;

//Stmt12531:Leaf
char const   *tmp ;

 
   {
//Stmt12532:Leaf
str = str_param;

//Stmt12533:Leaf
hval = 0UL;

//Stmt12534:Parent
while ((int const   )*str != 0) {
//Stmt12522:Leaf
hval <<= 4;

//Stmt12523:Leaf
tmp = str;

//Stmt12524:Leaf
str ++;

//Stmt12525:Leaf
hval += (unsigned long )*tmp;

//Stmt12526:Leaf
g = hval & (15UL << 28);

//Stmt12527:Parent
if (g != 0UL) {
//Stmt12520:Leaf
hval ^= g >> 24;

//Stmt12521:Leaf
hval ^= g;

     }

   }

//Stmt12535:Leaf
return (hval);

 }
}
 static char const   _nl_default_default_domain[9]  = 
   {      (char const   )'m',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
         (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )'s', 
         (char const   )'\000'};
 static char const   *_nl_current_default_domain  =    _nl_default_default_domain;
 static char const   _nl_default_dirname[24]  = 
   {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
         (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
         (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'s', 
         (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
         (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
         (char const   )'a',      (char const   )'l',      (char const   )'e',      (char const   )'\000'};
 static struct binding *_nl_domain_bindings  ;
 static char *find_msg(struct loaded_l10nfile *domain_file , char const   *msgid ) ;
 static char const   *category_to_name(int category ) ;
 static char const   *guess_category_value(int category , char const   *categoryname ) ;
 char *dcgettext__(char const   *domainname , char const   *msgid , int category ) 
 { 
//Stmt12621:Leaf
struct loaded_l10nfile *domain ;

//Stmt12622:Leaf
struct binding *binding ;

//Stmt12623:Leaf
char const   *categoryname ;

//Stmt12624:Leaf
char const   *categoryvalue ;

//Stmt12625:Leaf
char *dirname ;

//Stmt12626:Leaf
char *xdomainname ;

//Stmt12627:Leaf
char *single_locale ;

//Stmt12628:Leaf
char *retval ;

//Stmt12629:Leaf
int saved_errno ;

//Stmt12630:Leaf
int *tmp ;

//Stmt12631:Leaf
int compare ;

//Stmt12632:Leaf
int tmp___0 ;

//Stmt12633:Leaf
size_t dirname_len ;

//Stmt12634:Leaf
size_t tmp___1 ;

//Stmt12635:Leaf
size_t path_max ;

//Stmt12636:Leaf
char *ret ;

//Stmt12637:Leaf
void *tmp___2 ;

//Stmt12638:Leaf
int *tmp___3 ;

//Stmt12639:Leaf
void *tmp___4 ;

//Stmt12640:Leaf
int *tmp___5 ;

//Stmt12641:Leaf
int *tmp___6 ;

//Stmt12642:Leaf
int *tmp___7 ;

//Stmt12643:Leaf
char *tmp___8 ;

//Stmt12644:Leaf
char *tmp___9 ;

//Stmt12645:Leaf
size_t tmp___10 ;

//Stmt12646:Leaf
size_t tmp___11 ;

//Stmt12647:Leaf
void *tmp___12 ;

//Stmt12648:Leaf
char *tmp___13 ;

//Stmt12649:Leaf
char *tmp___14 ;

//Stmt12650:Leaf
char *tmp___15 ;

//Stmt12651:Leaf
size_t tmp___16 ;

//Stmt12652:Leaf
void *tmp___17 ;

//Stmt12653:Leaf
char *cp ;

//Stmt12654:Leaf
char *tmp___18 ;

//Stmt12655:Leaf
char const   *tmp___19 ;

//Stmt12656:Leaf
int *tmp___20 ;

//Stmt12657:Leaf
int tmp___21 ;

//Stmt12658:Leaf
int tmp___22 ;

//Stmt12659:Leaf
int cnt ;

//Stmt12660:Leaf
int *tmp___23 ;

 
   {
//Stmt12661:Leaf
tmp = __errno_location();

//Stmt12662:Leaf
saved_errno = *tmp;

//Stmt12663:Parent
if ((unsigned long )msgid == (unsigned long )((void *)0)) {
//Stmt12536:Leaf
return ((char *)((void *)0));

   }

//Stmt12664:Parent
if ((unsigned long )domainname == (unsigned long )((void *)0)) {
//Stmt12537:Leaf
domainname = _nl_current_default_domain;

   }

//Stmt12665:Leaf
binding = _nl_domain_bindings;

//Stmt12666:Parent
while ((unsigned long )binding != (unsigned long )((void *)0)) {
//Stmt12541:Leaf
tmp___0 = strcmp(domainname, (char const   *)binding->domainname);

//Stmt12542:Leaf
compare = tmp___0;

//Stmt12543:Parent
if (compare == 0) {
//Stmt12538:Leaf
break;

     }

//Stmt12544:Parent
if (compare < 0) {
//Stmt12539:Leaf
binding = (struct binding *)((void *)0);

//Stmt12540:Leaf
break;

     }

//Stmt12545:Leaf
binding = binding->next;

   }

//Stmt12667:Parent
if ((unsigned long )binding == (unsigned long )((void *)0)) {
//Stmt12574:Leaf
dirname = (char *)(_nl_default_dirname);

   } else
   {
//Stmt12575:Parent
if ((int )*(binding->dirname + 0) == 47) {
//Stmt12560:Leaf
dirname = binding->dirname;

   } else {
//Stmt12561:Leaf
tmp___1 = strlen((char const   *)binding->dirname);

//Stmt12562:Leaf
dirname_len = tmp___1 + 1UL;

//Stmt12563:Leaf
path_max = (size_t )4096U;

//Stmt12564:Leaf
path_max += 2UL;

//Stmt12565:Leaf
tmp___2 = __builtin_alloca(path_max + dirname_len);

//Stmt12566:Leaf
dirname = (char *)tmp___2;

//Stmt12567:Leaf
tmp___3 = __errno_location();

//Stmt12568:Leaf
*tmp___3 = 0;

//Stmt12569:Parent
while (1) {
//Stmt12550:Leaf
ret = getcwd(dirname, path_max);

//Stmt12551:Parent
if ((unsigned long )ret == (unsigned long )((void *)0)) {
//Stmt12547:Leaf
tmp___6 = __errno_location();

//Stmt12548:Parent
if (! (*tmp___6 == 34)) {
//Stmt12546:Leaf
break;

         }

       } else {
//Stmt12549:Leaf
break;

       }

//Stmt12552:Leaf
path_max += 32UL;

//Stmt12553:Leaf
tmp___4 = __builtin_alloca(path_max + dirname_len);

//Stmt12554:Leaf
dirname = (char *)tmp___4;

//Stmt12555:Leaf
tmp___5 = __errno_location();

//Stmt12556:Leaf
*tmp___5 = 0;

     }

//Stmt12570:Parent
if ((unsigned long )ret == (unsigned long )((void *)0)) {
//Stmt12557:Leaf
tmp___7 = __errno_location();

//Stmt12558:Leaf
*tmp___7 = saved_errno;

//Stmt12559:Leaf
return ((char *)msgid);

     }

//Stmt12571:Leaf
tmp___8 = strchr((char const   *)dirname, '\000');

//Stmt12572:Leaf
tmp___9 = stpcpy((char * __restrict  )tmp___8, (char const   * __restrict  )"/");

//Stmt12573:Leaf
stpcpy((char * __restrict  )tmp___9, (char const   * __restrict  )binding->dirname);

   }
}


//Stmt12668:Leaf
categoryname = category_to_name(category);

//Stmt12669:Leaf
categoryvalue = guess_category_value(category, categoryname);

//Stmt12670:Leaf
tmp___10 = strlen(categoryname);

//Stmt12671:Leaf
tmp___11 = strlen(domainname);

//Stmt12672:Leaf
tmp___12 = __builtin_alloca((tmp___10 + tmp___11) + 5UL);

//Stmt12673:Leaf
xdomainname = (char *)tmp___12;

//Stmt12674:Leaf
tmp___13 = stpcpy((char * __restrict  )xdomainname, (char const   * __restrict  )categoryname);

//Stmt12675:Leaf
tmp___14 = stpcpy((char * __restrict  )tmp___13, (char const   * __restrict  )"/");

//Stmt12676:Leaf
tmp___15 = stpcpy((char * __restrict  )tmp___14, (char const   * __restrict  )domainname);

//Stmt12677:Leaf
stpcpy((char * __restrict  )tmp___15, (char const   * __restrict  )".mo");

//Stmt12678:Leaf
tmp___16 = strlen(categoryvalue);

//Stmt12679:Leaf
tmp___17 = __builtin_alloca(tmp___16 + 1UL);

//Stmt12680:Leaf
single_locale = (char *)tmp___17;

//Stmt12681:Parent
while (1) {
//Stmt12615:Parent
while (1) {
//Stmt12579:Parent
if ((int const   )*(categoryvalue + 0) != 0) {
//Stmt12577:Parent
if (! ((int const   )*(categoryvalue + 0) == 58)) {
//Stmt12576:Leaf
break;

         }

       } else {
//Stmt12578:Leaf
break;

       }

//Stmt12580:Leaf
categoryvalue ++;

     }

//Stmt12616:Parent
if ((int const   )*(categoryvalue + 0) == 0) {
//Stmt12590:Leaf
*(single_locale + 0) = (char )'C';

//Stmt12591:Leaf
*(single_locale + 1) = (char )'\000';

     } else {
//Stmt12592:Leaf
cp = single_locale;

//Stmt12593:Parent
while (1) {
//Stmt12584:Parent
if ((int const   )*(categoryvalue + 0) != 0) {
//Stmt12582:Parent
if (! ((int const   )*(categoryvalue + 0) != 58)) {
//Stmt12581:Leaf
break;

           }

         } else {
//Stmt12583:Leaf
break;

         }

//Stmt12585:Leaf
tmp___18 = cp;

//Stmt12586:Leaf
cp ++;

//Stmt12587:Leaf
tmp___19 = categoryvalue;

//Stmt12588:Leaf
categoryvalue ++;

//Stmt12589:Leaf
*tmp___18 = (char )*tmp___19;

       }

//Stmt12594:Leaf
*cp = (char )'\000';

     }

//Stmt12617:Leaf
tmp___21 = strcmp((char const   *)single_locale, "C");

//Stmt12618:Parent
if (tmp___21 == 0) {
//Stmt12598:Leaf
tmp___20 = __errno_location();

//Stmt12599:Leaf
*tmp___20 = saved_errno;

//Stmt12600:Leaf
return ((char *)msgid);

     } else {
//Stmt12601:Leaf
tmp___22 = strcmp((char const   *)single_locale, "POSIX");

//Stmt12602:Parent
if (tmp___22 == 0) {
//Stmt12595:Leaf
tmp___20 = __errno_location();

//Stmt12596:Leaf
*tmp___20 = saved_errno;

//Stmt12597:Leaf
return ((char *)msgid);

       }

     }

//Stmt12619:Leaf
domain = _nl_find_domain((char const   *)dirname, single_locale, (char const   *)xdomainname);

//Stmt12620:Parent
if ((unsigned long )domain != (unsigned long )((void *)0)) {
//Stmt12612:Leaf
retval = find_msg(domain, msgid);

//Stmt12613:Parent
if ((unsigned long )retval == (unsigned long )((void *)0)) {
//Stmt12607:Leaf
cnt = 0;

//Stmt12608:Parent
while ((unsigned long )domain->successor[cnt] != (unsigned long )((void *)0)) {
//Stmt12604:Leaf
retval = find_msg(domain->successor[cnt], msgid);

//Stmt12605:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12603:Leaf
break;

           }

//Stmt12606:Leaf
cnt ++;

         }

       }

//Stmt12614:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12609:Leaf
tmp___23 = __errno_location();

//Stmt12610:Leaf
*tmp___23 = saved_errno;

//Stmt12611:Leaf
return (retval);

       }

     }

   }

 }
}
 static char *find_msg(struct loaded_l10nfile *domain_file , char const   *msgid ) 
 { 
//Stmt12757:Leaf
size_t top ;

//Stmt12758:Leaf
size_t act ;

//Stmt12759:Leaf
size_t bottom ;

//Stmt12760:Leaf
struct loaded_domain *domain ;

//Stmt12761:Leaf
nls_uint32 len ;

//Stmt12762:Leaf
size_t tmp ;

//Stmt12763:Leaf
nls_uint32 hash_val ;

//Stmt12764:Leaf
unsigned long tmp___0 ;

//Stmt12765:Leaf
nls_uint32 idx ;

//Stmt12766:Leaf
nls_uint32 incr ;

//Stmt12767:Leaf
nls_uint32 nstr ;

//Stmt12768:Leaf
nls_uint32 tmp___1 ;

//Stmt12769:Leaf
nls_uint32 tmp___2 ;

//Stmt12770:Leaf
nls_uint32 tmp___3 ;

//Stmt12771:Leaf
nls_uint32 tmp___4 ;

//Stmt12772:Leaf
nls_uint32 tmp___5 ;

//Stmt12773:Leaf
nls_uint32 tmp___6 ;

//Stmt12774:Leaf
nls_uint32 tmp___7 ;

//Stmt12775:Leaf
nls_uint32 tmp___8 ;

//Stmt12776:Leaf
int tmp___9 ;

//Stmt12777:Leaf
nls_uint32 tmp___10 ;

//Stmt12778:Leaf
nls_uint32 tmp___11 ;

//Stmt12779:Leaf
nls_uint32 tmp___12 ;

//Stmt12780:Leaf
nls_uint32 tmp___13 ;

//Stmt12781:Leaf
nls_uint32 tmp___14 ;

//Stmt12782:Leaf
nls_uint32 tmp___15 ;

//Stmt12783:Leaf
nls_uint32 tmp___16 ;

//Stmt12784:Leaf
int tmp___17 ;

//Stmt12785:Leaf
int cmp_val ;

//Stmt12786:Leaf
nls_uint32 tmp___18 ;

//Stmt12787:Leaf
nls_uint32 tmp___19 ;

//Stmt12788:Leaf
nls_uint32 tmp___20 ;

//Stmt12789:Leaf
nls_uint32 tmp___21 ;

//Stmt12790:Leaf
char *tmp___22 ;

 
   {
//Stmt12791:Parent
if (domain_file->decided == 0) {
//Stmt12682:Leaf
_nl_load_domain(domain_file);

   }

//Stmt12792:Parent
if ((unsigned long )domain_file->data == (unsigned long )((void *)0)) {
//Stmt12683:Leaf
return ((char *)((void *)0));

   }

//Stmt12793:Leaf
domain = (struct loaded_domain *)domain_file->data;

//Stmt12794:Parent
if (domain->hash_size > 2U) {
//Stmt12739:Parent
if ((unsigned long )domain->hash_tab != (unsigned long )((void *)0)) {
//Stmt12727:Leaf
tmp = strlen(msgid);

//Stmt12728:Leaf
len = (nls_uint32 )tmp;

//Stmt12729:Leaf
tmp___0 = hash_string(msgid);

//Stmt12730:Leaf
hash_val = (nls_uint32 )tmp___0;

//Stmt12731:Leaf
idx = hash_val % domain->hash_size;

//Stmt12732:Leaf
incr = 1U + hash_val % (domain->hash_size - 2U);

//Stmt12733:Parent
if (domain->must_swap) {
//Stmt12684:Leaf
tmp___1 = SWAP(*(domain->hash_tab + idx));

//Stmt12685:Leaf
tmp___2 = tmp___1;

       } else {
//Stmt12686:Leaf
tmp___2 = *(domain->hash_tab + idx);

       }

//Stmt12734:Leaf
nstr = tmp___2;

//Stmt12735:Parent
if (nstr == 0U) {
//Stmt12687:Leaf
return ((char *)((void *)0));

       }

//Stmt12736:Parent
if (domain->must_swap) {
//Stmt12688:Leaf
tmp___5 = SWAP((domain->orig_tab + (nstr - 1U))->length);

//Stmt12689:Leaf
tmp___6 = tmp___5;

       } else {
//Stmt12690:Leaf
tmp___6 = (domain->orig_tab + (nstr - 1U))->length;

       }

//Stmt12737:Parent
if (tmp___6 == len) {
//Stmt12699:Parent
if (domain->must_swap) {
//Stmt12691:Leaf
tmp___7 = SWAP((domain->orig_tab + (nstr - 1U))->offset);

//Stmt12692:Leaf
tmp___8 = tmp___7;

         } else {
//Stmt12693:Leaf
tmp___8 = (domain->orig_tab + (nstr - 1U))->offset;

         }

//Stmt12700:Leaf
tmp___9 = strcmp(msgid, domain->data + tmp___8);

//Stmt12701:Parent
if (tmp___9 == 0) {
//Stmt12697:Parent
if (domain->must_swap) {
//Stmt12694:Leaf
tmp___3 = SWAP((domain->trans_tab + (nstr - 1U))->offset);

//Stmt12695:Leaf
tmp___4 = tmp___3;

           } else {
//Stmt12696:Leaf
tmp___4 = (domain->trans_tab + (nstr - 1U))->offset;

           }

//Stmt12698:Leaf
return ((char *)domain->data + tmp___4);

         }

       }

//Stmt12738:Parent
while (1) {
//Stmt12722:Parent
if (idx >= domain->hash_size - incr) {
//Stmt12702:Leaf
idx -= domain->hash_size - incr;

         } else {
//Stmt12703:Leaf
idx += incr;

         }

//Stmt12723:Parent
if (domain->must_swap) {
//Stmt12704:Leaf
tmp___10 = SWAP(*(domain->hash_tab + idx));

//Stmt12705:Leaf
nstr = tmp___10;

         } else {
//Stmt12706:Leaf
nstr = *(domain->hash_tab + idx);

         }

//Stmt12724:Parent
if (nstr == 0U) {
//Stmt12707:Leaf
return ((char *)((void *)0));

         }

//Stmt12725:Parent
if (domain->must_swap) {
//Stmt12708:Leaf
tmp___13 = SWAP((domain->orig_tab + (nstr - 1U))->length);

//Stmt12709:Leaf
tmp___14 = tmp___13;

         } else {
//Stmt12710:Leaf
tmp___14 = (domain->orig_tab + (nstr - 1U))->length;

         }

//Stmt12726:Parent
if (tmp___14 == len) {
//Stmt12719:Parent
if (domain->must_swap) {
//Stmt12711:Leaf
tmp___15 = SWAP((domain->orig_tab + (nstr - 1U))->offset);

//Stmt12712:Leaf
tmp___16 = tmp___15;

           } else {
//Stmt12713:Leaf
tmp___16 = (domain->orig_tab + (nstr - 1U))->offset;

           }

//Stmt12720:Leaf
tmp___17 = strcmp(msgid, domain->data + tmp___16);

//Stmt12721:Parent
if (tmp___17 == 0) {
//Stmt12717:Parent
if (domain->must_swap) {
//Stmt12714:Leaf
tmp___11 = SWAP((domain->trans_tab + (nstr - 1U))->offset);

//Stmt12715:Leaf
tmp___12 = tmp___11;

             } else {
//Stmt12716:Leaf
tmp___12 = (domain->trans_tab + (nstr - 1U))->offset;

             }

//Stmt12718:Leaf
return ((char *)domain->data + tmp___12);

           }

         }

       }

     }

   }

//Stmt12795:Leaf
bottom = (size_t )0;

//Stmt12796:Leaf
top = (size_t )domain->nstrings;

//Stmt12797:Parent
while (bottom < top) {
//Stmt12747:Leaf
act = (bottom + top) / 2UL;

//Stmt12748:Parent
if (domain->must_swap) {
//Stmt12740:Leaf
tmp___18 = SWAP((domain->orig_tab + act)->offset);

//Stmt12741:Leaf
tmp___19 = tmp___18;

     } else {
//Stmt12742:Leaf
tmp___19 = (domain->orig_tab + act)->offset;

     }

//Stmt12749:Leaf
cmp_val = strcmp(msgid, domain->data + tmp___19);

//Stmt12750:Parent
if (cmp_val < 0) {
//Stmt12745:Leaf
top = act;

     } else
     {
//Stmt12746:Parent
if (cmp_val > 0) {
//Stmt12743:Leaf
bottom = act + 1UL;

     } else {
//Stmt12744:Leaf
break;

     }
}


   }

//Stmt12798:Parent
if (bottom >= top) {
//Stmt12754:Leaf
tmp___22 = (char *)((void *)0);

   } else {
//Stmt12755:Parent
if (domain->must_swap) {
//Stmt12751:Leaf
tmp___20 = SWAP((domain->trans_tab + act)->offset);

//Stmt12752:Leaf
tmp___21 = tmp___20;

     } else {
//Stmt12753:Leaf
tmp___21 = (domain->trans_tab + act)->offset;

     }

//Stmt12756:Leaf
tmp___22 = (char *)domain->data + tmp___21;

   }

//Stmt12799:Leaf
return (tmp___22);

 }
}
 static char const   *category_to_name(int category ) 
 { 
//Stmt12808:Leaf
char const   *retval ;

 
   {
//Stmt12809:Parent
switch (category) {
   case 3:; 
//Stmt12800:Leaf
retval = "LC_COLLATE";

   break;
   case 0:; 
//Stmt12801:Leaf
retval = "LC_CTYPE";

   break;
   case 4:; 
//Stmt12802:Leaf
retval = "LC_MONETARY";

   break;
   case 1:; 
//Stmt12803:Leaf
retval = "LC_NUMERIC";

   break;
   case 2:; 
//Stmt12804:Leaf
retval = "LC_TIME";

   break;
   case 5:; 
//Stmt12805:Leaf
retval = "LC_MESSAGES";

   break;
   case 6:; 
//Stmt12806:Leaf
retval = "LC_ALL";

   break;
   default:; 
//Stmt12807:Leaf
retval = "LC_XXX";

   }

//Stmt12810:Leaf
return (retval);

 }
}
 static char const   *guess_category_value(int category , char const   *categoryname ) 
 {
 printf("EXECUTING guess_category_value\n");   
//Stmt12819:Leaf
char const   *retval ;

//Stmt12820:Leaf
int tmp ;

//Stmt12821:Leaf
int tmp___0 ;

//Stmt12822:Leaf
int tmp___1 ;

//Stmt12823:Leaf
int tmp___2 ;

 
   {
//Stmt12824:Leaf
tmp = (int )getenv("LANGUAGE");

//Stmt12825:Leaf
retval = (char const   *)tmp;

 printf("tmp: %d\n", tmp); 
 printf("Upon executing 12826\n"); 
 printf("Look here: %s\n", retval);

//Stmt12826:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12812:Parent
if ((int const   )*(retval + 0) != 0) {
//Stmt12811:Leaf
return (retval);

     }

   }

//Stmt12827:Leaf
tmp___0 = (int )getenv("LC_ALL");

//Stmt12828:Leaf
retval = (char const   *)tmp___0;

//Stmt12829:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12814:Parent
if ((int const   )*(retval + 0) != 0) {
//Stmt12813:Leaf
return (retval);

     }

   }

//Stmt12830:Leaf
tmp___1 = (int )getenv(categoryname);

//Stmt12831:Leaf
retval = (char const   *)tmp___1;

 printf("tmp___1: %d\n", tmp___1); 
 printf("Upon executing 12832\n");
 printf("Category name: %s\n", categoryname);
 printf("Retval: %s\n", retval);

 
 
//Stmt12832:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12816:Parent
if ((int const   )*(retval + 0) != 0) {
//Stmt12815:Leaf
return (retval);

     }

   }

//Stmt12833:Leaf
//tmp___2 = (int )getenv("LANG");

//printf("tmp___2: %d\n", tmp___2);
//printf("getenv(PATH): %s\n", getenv("PATH"));
//printf("getenv(LANG): %s\n", getenv("LANG"));
 
//Stmt12834:Leaf
//retval = (char const   *)tmp___2;
retval = getenv("LANG");

// printf("Upon executing 12835\n");
// printf("Retval: %s\n", retval);
 
//Stmt12835:Parent
if ((unsigned long )retval != (unsigned long )((void *)0)) {
//Stmt12818:Parent
if ((int const   )*(retval + 0) != 0) {
//Stmt12817:Leaf
return (retval);

     }

   }

//Stmt12836:Leaf
return ("C");

 }
}
 static char *bindtextdomain__(char const   *domainname , char const   *dirname ) 
 { 
//Stmt12894:Leaf
struct binding *binding ;

//Stmt12895:Leaf
int compare ;

//Stmt12896:Leaf
int tmp ;

//Stmt12897:Leaf
char *tmp___0 ;

//Stmt12898:Leaf
char *new_dirname ;

//Stmt12899:Leaf
int tmp___1 ;

//Stmt12900:Leaf
int tmp___2 ;

//Stmt12901:Leaf
struct binding *new_binding ;

//Stmt12902:Leaf
int tmp___3 ;

//Stmt12903:Leaf
int tmp___4 ;

//Stmt12904:Leaf
int tmp___5 ;

//Stmt12905:Leaf
int tmp___6 ;

 
   {
//Stmt12906:Parent
if ((unsigned long )domainname == (unsigned long )((void *)0)) {
//Stmt12838:Leaf
return ((char *)((void *)0));

   } else
   {
//Stmt12839:Parent
if ((int const   )*(domainname + 0) == 0) {
//Stmt12837:Leaf
return ((char *)((void *)0));

   }
}


//Stmt12907:Leaf
binding = _nl_domain_bindings;

//Stmt12908:Parent
while ((unsigned long )binding != (unsigned long )((void *)0)) {
//Stmt12843:Leaf
tmp = strcmp(domainname, (char const   *)binding->domainname);

//Stmt12844:Leaf
compare = tmp;

//Stmt12845:Parent
if (compare == 0) {
//Stmt12840:Leaf
break;

     }

//Stmt12846:Parent
if (compare < 0) {
//Stmt12841:Leaf
binding = (struct binding *)((void *)0);

//Stmt12842:Leaf
break;

     }

//Stmt12847:Leaf
binding = binding->next;

   }

//Stmt12909:Parent
if ((unsigned long )dirname == (unsigned long )((void *)0)) {
//Stmt12850:Parent
if ((unsigned long )binding == (unsigned long )((void *)0)) {
//Stmt12848:Leaf
tmp___0 = (char *)(_nl_default_dirname);

     } else {
//Stmt12849:Leaf
tmp___0 = binding->dirname;

     }

//Stmt12851:Leaf
return (tmp___0);

   }

//Stmt12910:Parent
if ((unsigned long )binding != (unsigned long )((void *)0)) {
//Stmt12883:Leaf
tmp___2 = strcmp(dirname, (char const   *)binding->dirname);

//Stmt12884:Parent
if (tmp___2 != 0) {
//Stmt12857:Leaf
tmp___1 = strcmp(dirname, _nl_default_dirname);

//Stmt12858:Parent
if (tmp___1 == 0) {
//Stmt12853:Leaf
new_dirname = (char *)(_nl_default_dirname);

       } else {
//Stmt12854:Leaf
new_dirname = strdup(dirname);

//Stmt12855:Parent
if ((unsigned long )new_dirname == (unsigned long )((void *)0)) {
//Stmt12852:Leaf
return ((char *)((void *)0));

         }

       }

//Stmt12859:Parent
if ((unsigned long )binding->dirname != (unsigned long )(_nl_default_dirname)) {
//Stmt12856:Leaf
free(binding->dirname);

       }

//Stmt12860:Leaf
binding->dirname = new_dirname;

     }

   } else {
//Stmt12885:Leaf
tmp___3 = (int )malloc(sizeof(*new_binding));

//Stmt12886:Leaf
new_binding = (struct binding *)tmp___3;

//Stmt12887:Parent
if ((unsigned long )new_binding == (unsigned long )((void *)0)) {
//Stmt12861:Leaf
return ((char *)((void *)0));

     }

//Stmt12888:Leaf
new_binding->domainname = strdup(domainname);

//Stmt12889:Parent
if ((unsigned long )new_binding->domainname == (unsigned long )((void *)0)) {
//Stmt12862:Leaf
return ((char *)((void *)0));

     }

//Stmt12890:Leaf
tmp___4 = strcmp(dirname, _nl_default_dirname);

//Stmt12891:Parent
if (tmp___4 == 0) {
//Stmt12864:Leaf
new_binding->dirname = (char *)(_nl_default_dirname);

     } else {
//Stmt12865:Leaf
new_binding->dirname = strdup(dirname);

//Stmt12866:Parent
if ((unsigned long )new_binding->dirname == (unsigned long )((void *)0)) {
//Stmt12863:Leaf
return ((char *)((void *)0));

       }

     }

//Stmt12892:Parent
if ((unsigned long )_nl_domain_bindings == (unsigned long )((void *)0)) {
//Stmt12879:Leaf
new_binding->next = _nl_domain_bindings;

//Stmt12880:Leaf
_nl_domain_bindings = new_binding;

     } else {
//Stmt12881:Leaf
tmp___6 = strcmp(domainname, (char const   *)_nl_domain_bindings->domainname);

//Stmt12882:Parent
if (tmp___6 < 0) {
//Stmt12873:Leaf
new_binding->next = _nl_domain_bindings;

//Stmt12874:Leaf
_nl_domain_bindings = new_binding;

       } else {
//Stmt12875:Leaf
binding = _nl_domain_bindings;

//Stmt12876:Parent
while (1) {
//Stmt12871:Parent
if ((unsigned long )binding->next != (unsigned long )((void *)0)) {
//Stmt12868:Leaf
tmp___5 = strcmp(domainname, (char const   *)(binding->next)->domainname);

//Stmt12869:Parent
if (! (tmp___5 > 0)) {
//Stmt12867:Leaf
break;

             }

           } else {
//Stmt12870:Leaf
break;

           }

//Stmt12872:Leaf
binding = binding->next;

         }

//Stmt12877:Leaf
new_binding->next = binding->next;

//Stmt12878:Leaf
binding->next = new_binding;

       }

     }

//Stmt12893:Leaf
binding = new_binding;

   }

//Stmt12911:Leaf
return (binding->dirname);

 }
}
 static char *dgettext__(char const   *domainname , char const   *msgid ) 
 { 
//Stmt12912:Leaf
char *tmp ;

 
   {
//Stmt12913:Leaf
tmp = dcgettext__(domainname, msgid, 5);

//Stmt12914:Leaf
return (tmp);

 }
}
 static char *gettext__(char const   *msgid ) 
 { 
//Stmt12915:Leaf
char *tmp ;

 
   {
//Stmt12916:Leaf
tmp = dgettext__((char const   *)((void *)0), msgid);

//Stmt12917:Leaf
return (tmp);

 }
}
 static char *textdomain__(char const   *domainname ) 
 { 
//Stmt12926:Leaf
char *old ;

//Stmt12927:Leaf
char *tmp ;

//Stmt12928:Leaf
int tmp___0 ;

 
   {
//Stmt12929:Parent
if ((unsigned long )domainname == (unsigned long )((void *)0)) {
//Stmt12918:Leaf
return ((char *)_nl_current_default_domain);

   }

//Stmt12930:Leaf
old = (char *)_nl_current_default_domain;

//Stmt12931:Parent
if ((int const   )*(domainname + 0) == 0) {
//Stmt12922:Leaf
_nl_current_default_domain = _nl_default_default_domain;

   } else {
//Stmt12923:Leaf
tmp___0 = strcmp(domainname, _nl_default_default_domain);

//Stmt12924:Parent
if (tmp___0 == 0) {
//Stmt12919:Leaf
_nl_current_default_domain = _nl_default_default_domain;

     } else {
//Stmt12920:Leaf
tmp = strdup(domainname);

//Stmt12921:Leaf
_nl_current_default_domain = (char const   *)tmp;

     }

   }

//Stmt12932:Parent
if ((unsigned long )old != (unsigned long )(_nl_default_default_domain)) {
//Stmt12925:Leaf
free(old);

   }

//Stmt12933:Leaf
return ((char *)_nl_current_default_domain);

 }
}
 char *bindtextdomain(char const   *domainname , char const   *dirname ) 
 { 
//Stmt12934:Leaf
char *tmp ;

 
   {
//Stmt12935:Leaf
tmp = bindtextdomain__(domainname, dirname);

//Stmt12936:Leaf
return (tmp);

 }
}
 char *dcgettext(char const   *domainname , char const   *msgid , int category ) 
 { 
//Stmt12937:Leaf
char *tmp ;

 
   {
//Stmt12938:Leaf
tmp = dcgettext__(domainname, msgid, category);

//Stmt12939:Leaf
return (tmp);

 }
}
 char *dgettext(char const   *domainname , char const   *msgid ) 
 { 
//Stmt12940:Leaf
char *tmp ;

 
   {
//Stmt12941:Leaf
tmp = dgettext__(domainname, msgid);

//Stmt12942:Leaf
return (tmp);

 }
}
 char *gettext(char const   *msgid ) 
 { 
//Stmt12943:Leaf
char *tmp ;

 
   {
//Stmt12944:Leaf
tmp = gettext__(msgid);

//Stmt12945:Leaf
return (tmp);

 }
}
 char *textdomain(char const   *domainname ) 
 { 
//Stmt12946:Leaf
char *tmp ;

 
   {
//Stmt12947:Leaf
tmp = textdomain__(domainname);

//Stmt12948:Leaf
return (tmp);

 }
}
