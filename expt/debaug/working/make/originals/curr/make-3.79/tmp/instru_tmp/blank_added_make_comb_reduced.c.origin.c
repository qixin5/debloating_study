 /* Generated by CIL v. 1.7.3 */
 /* print_CIL_Input is true */
 
 typedef unsigned long __uintmax_t;
 typedef long __time_t;
 typedef __time_t time_t;
 typedef unsigned long size_t;
 typedef __uintmax_t uintmax_t;
 struct floc {
    char *filenm ;
    unsigned long lineno ;
 };
 struct dep;
 struct commands;
 struct variable_set_list;
 enum __anonenum_command_state_55 {
     cs_not_started = 0,
     cs_deps_running = 1,
     cs_running = 2,
     cs_finished = 3
 } ;
 struct file {
    struct file *next ;
    char *name ;
    char *hname ;
    char *vpath ;
    struct dep *deps ;
    struct commands *cmds ;
    int command_flags ;
    char *stem ;
    struct dep *also_make ;
    uintmax_t last_mtime ;
    uintmax_t mtime_before_update ;
    struct file *prev ;
    struct file *renamed ;
    struct variable_set_list *variables ;
    struct variable_set_list *pat_variables ;
    struct file *parent ;
    struct file *double_colon ;
    short update_status ;
    enum __anonenum_command_state_55 command_state : 2 ;
    unsigned int precious : 1 ;
    unsigned int tried_implicit : 1 ;
    unsigned int updating : 1 ;
    unsigned int updated : 1 ;
    unsigned int is_target : 1 ;
    unsigned int cmd_target : 1 ;
    unsigned int phony : 1 ;
    unsigned int intermediate : 1 ;
    unsigned int secondary : 1 ;
    unsigned int dontcare : 1 ;
    unsigned int ignore_vpath : 1 ;
    unsigned int pat_searched : 1 ;
    unsigned int considered : 1 ;
 };
 struct dep {
    struct dep *next ;
    char *name ;
    struct file *file ;
    int changed ;
 };
 struct nameseq {
    struct nameseq *next ;
    char *name ;
 };
 struct ar_glob_state {
    char *arname ;
    char *pattern ;
    unsigned int size ;
    struct nameseq *chain ;
    unsigned int n ;
 };
 typedef unsigned long __dev_t;
 typedef unsigned int __uid_t;
 typedef unsigned int __gid_t;
 typedef unsigned long __ino_t;
 typedef unsigned int __mode_t;
 typedef unsigned long __nlink_t;
 typedef long __off_t;
 typedef long __blksize_t;
 typedef long __blkcnt_t;
 typedef long __ssize_t;
 typedef long __syscall_slong_t;
 typedef __ssize_t ssize_t;
 struct timespec {
    __time_t tv_sec ;
    __syscall_slong_t tv_nsec ;
 };
 struct stat {
    __dev_t st_dev ;
    __ino_t st_ino ;
    __nlink_t st_nlink ;
    __mode_t st_mode ;
    __uid_t st_uid ;
    __gid_t st_gid ;
    int __pad0 ;
    __dev_t st_rdev ;
    __off_t st_size ;
    __blksize_t st_blksize ;
    __blkcnt_t st_blocks ;
    struct timespec st_atim ;
    struct timespec st_mtim ;
    struct timespec st_ctim ;
    __syscall_slong_t __glibc_reserved[3] ;
 };
 struct ar_hdr {
    char ar_name[16] ;
    char ar_date[12] ;
    char ar_uid[6] ;
    char ar_gid[6] ;
    char ar_mode[8] ;
    char ar_size[10] ;
    char ar_fmag[2] ;
 };
 typedef long __off64_t;
 typedef int __pid_t;
 typedef __pid_t pid_t;
 typedef void (*__sighandler_t)(int  );
 struct _IO_FILE;
 typedef struct _IO_FILE FILE;
 typedef void _IO_lock_t;
 struct _IO_marker {
    struct _IO_marker *_next ;
    struct _IO_FILE *_sbuf ;
    int _pos ;
 };
 struct _IO_FILE {
    int _flags ;
    char *_IO_read_ptr ;
    char *_IO_read_end ;
    char *_IO_read_base ;
    char *_IO_write_base ;
    char *_IO_write_ptr ;
    char *_IO_write_end ;
    char *_IO_buf_base ;
    char *_IO_buf_end ;
    char *_IO_save_base ;
    char *_IO_backup_base ;
    char *_IO_save_end ;
    struct _IO_marker *_markers ;
    struct _IO_FILE *_chain ;
    int _fileno ;
    int _flags2 ;
    __off_t _old_offset ;
    unsigned short _cur_column ;
    signed char _vtable_offset ;
    char _shortbuf[1] ;
    _IO_lock_t *_lock ;
    __off64_t _offset ;
    void *__pad1 ;
    void *__pad2 ;
    void *__pad3 ;
    void *__pad4 ;
    size_t __pad5 ;
    int _mode ;
    char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
 };
 enum variable_origin {
     o_default = 0,
     o_env = 1,
     o_file = 2,
     o_env_override = 3,
     o_command = 4,
     o_override = 5,
     o_automatic = 6,
     o_invalid = 7
 } ;
 enum variable_export {
     v_export = 0,
     v_noexport = 1,
     v_ifset = 2,
     v_default = 3
 } ;
 struct variable {
    struct variable *next ;
    char *name ;
    char *value ;
    struct floc fileinfo ;
    enum variable_origin origin : 3 ;
    unsigned int recursive : 1 ;
    unsigned int expanding : 1 ;
    unsigned int per_target : 1 ;
    unsigned int append : 1 ;
    enum variable_export export : 2 ;
 };
 struct variable_set {
    struct variable **table ;
    unsigned int buckets ;
 };
 struct variable_set_list {
    struct variable_set_list *next ;
    struct variable_set *set ;
 };
 struct child {
    struct child *next ;
    struct file *file ;
    char **environment ;
    char **command_lines ;
    unsigned int command_line ;
    char *command_ptr ;
    pid_t pid ;
    char *sh_batch_file ;
    unsigned int remote : 1 ;
    unsigned int noerror : 1 ;
    unsigned int good_stdin : 1 ;
    unsigned int deleted : 1 ;
 };
 struct commands {
    struct floc fileinfo ;
    char *commands ;
    unsigned int ncommand_lines ;
    char **command_lines ;
    char *lines_flags ;
    int any_recurse ;
 };
 typedef __ino_t ino_t;
 typedef __dev_t dev_t;
 struct dirent {
    __ino_t d_ino ;
    __off_t d_off ;
    unsigned short d_reclen ;
    unsigned char d_type ;
    char d_name[256] ;
 };
 struct __dirstream;
 typedef struct __dirstream DIR;
 struct dirfile;
 struct directory_contents {
    struct directory_contents *next ;
    dev_t dev ;
    ino_t ino ;
    struct dirfile **files ;
    DIR *dirstream ;
 };
 struct directory {
    struct directory *next ;
    char *name ;
    struct directory_contents *contents ;
 };
 struct dirfile {
    struct dirfile *next ;
    char *name ;
    char impossible ;
 };
 struct __anonstruct_glob_t_56 {
    size_t gl_pathc ;
    char **gl_pathv ;
    size_t gl_offs ;
    int gl_flags ;
    void (*gl_closedir)(void * ) ;
    struct dirent *(*gl_readdir)(void * ) ;
    void *(*gl_opendir)(char const   * ) ;
    int (*gl_lstat)(char const   * , struct stat * ) ;
    int (*gl_stat)(char const   * , struct stat * ) ;
 };
 typedef struct __anonstruct_glob_t_56 glob_t;
 struct dirstream {
    struct directory_contents *contents ;
    unsigned int bucket ;
    struct dirfile *elt ;
 };
 typedef int __clockid_t;
 typedef __clockid_t clockid_t;
 struct tm {
    int tm_sec ;
    int tm_min ;
    int tm_hour ;
    int tm_mday ;
    int tm_mon ;
    int tm_year ;
    int tm_wday ;
    int tm_yday ;
    int tm_isdst ;
    long tm_gmtoff ;
    char const   *tm_zone ;
 };
 struct function_table_entry {
    char const   *name ;
    unsigned char len ;
    unsigned char minimum_args ;
    unsigned char maximum_args ;
    char expand_args ;
    char *(*func_ptr)(char *output , char **argv , char const   *fname ) ;
 };
 struct a_word {
    struct a_word *next ;
    char *str ;
    int matched ;
 };
 struct rule {
    struct rule *next ;
    char **targets ;
    unsigned int *lens ;
    char **suffixes ;
    struct dep *deps ;
    struct commands *cmds ;
    char terminal ;
    char in_use ;
 };
 struct __anonstruct___sigset_t_2 {
    unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
 };
 typedef struct __anonstruct___sigset_t_2 __sigset_t;
 typedef __sigset_t sigset_t;
 typedef unsigned int __uint32_t;
 typedef long __clock_t;
 union sigval {
    int sival_int ;
    void *sival_ptr ;
 };
 typedef union sigval __sigval_t;
 struct __anonstruct__kill_18 {
    __pid_t si_pid ;
    __uid_t si_uid ;
 };
 struct __anonstruct__timer_19 {
    int si_tid ;
    int si_overrun ;
    __sigval_t si_sigval ;
 };
 struct __anonstruct__rt_20 {
    __pid_t si_pid ;
    __uid_t si_uid ;
    __sigval_t si_sigval ;
 };
 struct __anonstruct__sigchld_21 {
    __pid_t si_pid ;
    __uid_t si_uid ;
    int si_status ;
    __clock_t si_utime ;
    __clock_t si_stime ;
 };
 struct __anonstruct__addr_bnd_24 {
    void *_lower ;
    void *_upper ;
 };
 union __anonunion__bounds_23 {
    struct __anonstruct__addr_bnd_24 _addr_bnd ;
    __uint32_t _pkey ;
 };
 struct __anonstruct__sigfault_22 {
    void *si_addr ;
    short si_addr_lsb ;
    union __anonunion__bounds_23 _bounds ;
 };
 struct __anonstruct__sigpoll_25 {
    long si_band ;
    int si_fd ;
 };
 struct __anonstruct__sigsys_26 {
    void *_call_addr ;
    int _syscall ;
    unsigned int _arch ;
 };
 union __anonunion__sifields_17 {
    int _pad[128UL / sizeof(int ) - 4UL] ;
    struct __anonstruct__kill_18 _kill ;
    struct __anonstruct__timer_19 _timer ;
    struct __anonstruct__rt_20 _rt ;
    struct __anonstruct__sigchld_21 _sigchld ;
    struct __anonstruct__sigfault_22 _sigfault ;
    struct __anonstruct__sigpoll_25 _sigpoll ;
    struct __anonstruct__sigsys_26 _sigsys ;
 };
 struct __anonstruct_siginfo_t_16 {
    int si_signo ;
    int si_errno ;
    int si_code ;
    int __pad0 ;
    union __anonunion__sifields_17 _sifields ;
 };
 typedef struct __anonstruct_siginfo_t_16 siginfo_t;
 union __anonunion___sigaction_handler_37 {
    void (*sa_handler)(int  ) ;
    void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
 };
 struct sigaction {
    union __anonunion___sigaction_handler_37 __sigaction_handler ;
    __sigset_t sa_mask ;
    int sa_flags ;
    void (*sa_restorer)(void) ;
 };
 struct option {
    char const   *name ;
    int has_arg ;
    int *flag ;
    int val ;
 };
 enum __anonenum_type_56 {
     flag = 0,
     flag_off = 1,
     string = 2,
     positive_int = 3,
     floating = 4,
     ignore = 5
 } ;
 struct command_switch {
    int c ;
    enum __anonenum_type_56 type ;
    char *value_ptr ;
    unsigned int env : 1 ;
    unsigned int toenv : 1 ;
    unsigned int no_makefile : 1 ;
    char *noarg_value ;
    char *default_value ;
    char *long_name ;
    char *argdesc ;
    char *description ;
 };
 struct stringlist {
    char **list ;
    unsigned int idx ;
    unsigned int max ;
 };
 struct command_variable {
    struct command_variable *next ;
    struct variable *variable ;
 };
 struct flag {
    struct flag *next ;
    struct command_switch  const  *cs ;
    char *arg ;
 };
 typedef __builtin_va_list __gnuc_va_list;
 typedef struct _IO_FILE _IO_FILE;
 typedef __gnuc_va_list va_list;
 enum __anonenum_current_access_55 {
     make = 0,
     user = 1
 } ;
 struct pattern_var {
    struct pattern_var *next ;
    char *target ;
    unsigned int len ;
    char *suffix ;
    struct variable_set_list *vars ;
 };
 struct passwd {
    char *pw_name ;
    char *pw_passwd ;
    __uid_t pw_uid ;
    __gid_t pw_gid ;
    char *pw_gecos ;
    char *pw_dir ;
    char *pw_shell ;
 };
 struct linebuffer {
    unsigned int size ;
    char *buffer ;
 };
 enum make_word_type {
     w_bogus = 0,
     w_eol = 1,
     w_static = 2,
     w_variable = 3,
     w_colon = 4,
     w_dcolon = 5,
     w_semicolon = 6,
     w_comment = 7,
     w_varassign = 8
 } ;
 struct conditionals {
    unsigned int if_cmds ;
    unsigned int allocated ;
    char *ignoring ;
    char *seen_else ;
 };
 struct pspec {
    char *target ;
    char *dep ;
    char *commands ;
 };
 struct __anonstruct_num_abbrev_55 {
    int number ;
    char const   *abbrev ;
 };
 typedef struct __anonstruct_num_abbrev_55 num_abbrev;
 struct variable_bucket {
    struct variable_bucket *next ;
    struct variable *variable ;
 };
 enum __anonenum_flavor_56 {
     f_bogus = 0,
     f_simple = 1,
     f_recursive = 2,
     f_append = 3,
     f_conditional = 4
 } ;
 struct vpath {
    struct vpath *next ;
    char *pattern ;
    char *percent ;
    unsigned int patlen ;
    char **searchpath ;
    unsigned int maxlen ;
 };
 struct loaded_l10nfile {
    char const   *filename ;
    int decided ;
    void const   *data ;
    struct loaded_l10nfile *next ;
    struct loaded_l10nfile *successor[1] ;
 };
 enum __anonenum_syntax_17 {
     undecided = 0,
     xpg = 1,
     cen = 2
 } ;
 typedef unsigned int nls_uint32;
 struct mo_file_header {
    nls_uint32 magic ;
    nls_uint32 revision ;
    nls_uint32 nstrings ;
    nls_uint32 orig_tab_offset ;
    nls_uint32 trans_tab_offset ;
    nls_uint32 hash_tab_size ;
    nls_uint32 hash_tab_offset ;
 };
 struct string_desc {
    nls_uint32 length ;
    nls_uint32 offset ;
 };
 struct loaded_domain {
    char const   *data ;
    int use_mmap ;
    size_t mmap_size ;
    int must_swap ;
    nls_uint32 nstrings ;
    struct string_desc *orig_tab ;
    struct string_desc *trans_tab ;
    nls_uint32 hash_size ;
    nls_uint32 *hash_tab ;
 };
 struct binding {
    struct binding *next ;
    char *domainname ;
    char *dirname ;
 };
 struct alias_map {
    char const   *alias ;
    char const   *value ;
 };
 /* compiler builtin: 
    void *__builtin_alloca(unsigned long  ) ;  */
 #pragma merger("0","/tmp/cil-S4IQuXVr.i","-g,-O0")
 char *dcgettext(char const   *domainname , char const   *msgid , int category ) ;
 extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
 extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                        size_t __size , int (*__compar)(void const   * ,
                                                                                        void const   * ) ) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                   void const   *__src ,
                                                                                                   size_t __n ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
 void ( /* format attribute */  error)(struct floc  const  *flocp , char const   *fmt 
                                       , ...) ;
  __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(struct floc  const  *flocp ,
                                                                      char const   *fmt 
                                                                      , ...) ;
 void perror_with_name(char *str , char *name ) ;
 char *savestring(char const   *str , unsigned int length___0 ) ;
 char *concat(char *s1 , char *s2 , char *s3 ) ;
 char *xmalloc(unsigned int size ) ;
 int alpha_compare(void const   *v1 , void const   *v2 ) ;
 int ar_name(char *name ) ;
 void ar_parse_name(char *name , char **arname_p , char **memname_p ) ;
 int ar_touch(char *name ) ;
 time_t ar_member_date(char *name ) ;
 int file_exists_p(char *name ) ;
 struct file *lookup_file(char *name ) ;
 struct file *enter_file(char *name ) ;
 uintmax_t f_mtime(struct file *file , int search ) ;
 struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) ;
 extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
 long ar_scan(char *archive , long (*function)() , long arg ) ;
 int ar_name_equal(char *name , char *mem , int truncated ) ;
 int ar_member_touch(char *arname , char *memname ) ;
 int ar_name(char *name ) 
 { 
   char *p ;
   char *tmp ;
   char *end ;
   size_t tmp___0 ;
   char *tmp___1 ;
 
   {
   tmp = strchr((char const   *)name, '(');
   p = tmp;
   tmp___0 = strlen((char const   *)name);
   end = (name + tmp___0) - 1;
   if ((unsigned long )p == (unsigned long )((char *)0)) {
     return (0);
   } else
   if ((unsigned long )p == (unsigned long )name) {
     return (0);
   } else
   if ((int )*end != 41) {
     return (0);
   }
   if ((int )*(p + 1) == 40) {
     if ((int )*(end + -1) == 41) {
       tmp___1 = dcgettext((char const   *)((void *)0), "attempt to use unsupported feature: `%s\'",
                           5);
       fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, name);
     }
   }
   return (1);
 }
 }
 void ar_parse_name(char *name , char **arname_p , char **memname_p ) 
 { 
   char *p ;
   char *tmp ;
   char *end ;
   size_t tmp___0 ;
 
   {
   tmp = strchr((char const   *)name, '(');
   p = tmp;
   tmp___0 = strlen((char const   *)name);
   end = (name + tmp___0) - 1;
   if ((unsigned long )arname_p != (unsigned long )((char **)0)) {
     *arname_p = savestring((char const   *)name, (unsigned int )(p - name));
   }
   if ((unsigned long )memname_p != (unsigned long )((char **)0)) {
     *memname_p = savestring((char const   *)(p + 1), (unsigned int )(end - (p + 1)));
   }
   return;
 }
 }
 static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                              long datapos , long size , long date , int uid , int gid ,
                              int mode , char *name ) ;
 time_t ar_member_date(char *name ) 
 { 
   char *arname ;
   int arname_used ;
   char *memname ;
   long val ;
   struct file *arfile ;
   int tmp ;
   time_t tmp___0 ;
 
   {
   arname_used = 0;
   ar_parse_name(name, & arname, & memname);
   arfile = lookup_file(arname);
   if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
     tmp = file_exists_p(arname);
     if (tmp) {
       arfile = enter_file(arname);
       arname_used = 1;
     }
   }
   if ((unsigned long )arfile != (unsigned long )((struct file *)0)) {
     f_mtime(arfile, 0);
   }
   val = ar_scan(arname, (long (*)())(& ar_member_date_1), (long )memname);
   if (! arname_used) {
     free((void *)arname);
   }
   free((void *)memname);
   if (val <= 0L) {
     tmp___0 = (time_t )-1;
   } else {
     tmp___0 = val;
   }
   return (tmp___0);
 }
 }
 static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                              long datapos , long size , long date , int uid , int gid ,
                              int mode , char *name ) 
 { 
   long tmp___0 ;
   int tmp___1 ;
 
   {
   tmp___1 = ar_name_equal(name, mem, truncated);
   if (tmp___1) {
     tmp___0 = date;
   } else {
     tmp___0 = 0L;
   }
   return (tmp___0);
 }
 }
 int ar_touch(char *name ) 
 { 
   char *arname ;
   char *memname ;
   int arname_used ;
   register int val ;
   struct file *arfile ;
   int tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
 
   {
   arname_used = 0;
   ar_parse_name(name, & arname, & memname);
   arfile = lookup_file(arname);
   if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
     arfile = enter_file(arname);
     arname_used = 1;
   }
   f_mtime(arfile, 0);
   val = 1;
   tmp = ar_member_touch(arname, memname);
   switch (tmp) {
   case -1: 
   tmp___0 = dcgettext((char const   *)((void *)0), "touch: Archive `%s\' does not exist",
                       5);
   error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, arname);
   break;
   case -2: 
   tmp___1 = dcgettext((char const   *)((void *)0), "touch: `%s\' is not a valid archive",
                       5);
   error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, arname);
   break;
   case -3: 
   perror_with_name((char *)"touch: ", arname);
   break;
   case 1: 
   tmp___2 = dcgettext((char const   *)((void *)0), "touch: Member `%s\' does not exist in `%s\'",
                       5);
   error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, memname,
         arname);
   break;
   case 0: 
   val = 0;
   break;
   default: 
   tmp___3 = dcgettext((char const   *)((void *)0), "touch: Bad return code from ar_member_touch on `%s\'",
                       5);
   error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___3, name);
   }
   if (! arname_used) {
     free((void *)arname);
   }
   free((void *)memname);
   return (val);
 }
 }
 static long ar_glob_match(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                           long size , long date , int uid , int gid , int mode , struct ar_glob_state *state ) 
 { 
   struct nameseq *new ;
   char *tmp ;
   int tmp___0 ;
 
   {
   tmp___0 = fnmatch((char const   *)state->pattern, (char const   *)mem, 1 | (1 << 2));
   if (tmp___0 == 0) {
     tmp = xmalloc(state->size);
     new = (struct nameseq *)tmp;
     new->name = concat(state->arname, mem, (char *)")");
     new->next = state->chain;
     state->chain = new;
     (state->n) ++;
   }
   return (0L);
 }
 }
 static int glob_pattern_p(char const   *pattern , int const   quote ) 
 { 
   register char const   *p ;
   int open___0 ;
 
   {
   open___0 = 0;
   p = pattern;
   while ((int const   )*p != 0) {
     switch ((int const   )*p) {
     case 42: 
     case 63: 
     return (1);
     case 92: 
     if (quote) {
       p ++;
     }
     break;
     case 91: 
     open___0 = 1;
     break;
     case 93: 
     if (open___0) {
       return (1);
     }
     break;
     }
     p ++;
   }
   return (0);
 }
 }
 struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) 
 { 
   struct ar_glob_state state ;
   char **names ;
   struct nameseq *n ;
   unsigned int i ;
   int tmp ;
   size_t tmp___0 ;
   void *tmp___1 ;
   void *tmp___2 ;
   unsigned int tmp___3 ;
   unsigned int tmp___4 ;
 
   {
   tmp = glob_pattern_p((char const   *)member_pattern, (int const   )1);
   if (! tmp) {
     return ((struct nameseq *)0);
   }
   tmp___0 = strlen((char const   *)arname);
   i = (unsigned int )tmp___0;
   tmp___1 = __builtin_alloca((unsigned long )(i + 2U));
   state.arname = (char *)tmp___1;
   memmove((void *)state.arname, (void const   *)arname, (size_t )i);
   *(state.arname + i) = (char )'(';
   *(state.arname + (i + 1U)) = (char )'\000';
   state.pattern = member_pattern;
   state.size = size;
   state.chain = (struct nameseq *)0;
   state.n = 0U;
   ar_scan(arname, (long (*)())(& ar_glob_match), (long )(& state));
   if ((unsigned long )state.chain == (unsigned long )((struct nameseq *)0)) {
     return ((struct nameseq *)0);
   }
   tmp___2 = __builtin_alloca((unsigned long )state.n * sizeof(char *));
   names = (char **)tmp___2;
   i = 0U;
   n = state.chain;
   while ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
     tmp___3 = i;
     i ++;
     *(names + tmp___3) = n->name;
     n = n->next;
   }
   qsort((void *)((char *)names), (size_t )i, sizeof(*names), & alpha_compare);
   i = 0U;
   n = state.chain;
   while ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
     tmp___4 = i;
     i ++;
     n->name = *(names + tmp___4);
     n = n->next;
   }
   return (state.chain);
 }
 }
 #pragma merger("0","/tmp/cil-M34r4uwp.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                             struct stat *__buf ) ;
 extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                  , ...) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                              char const   * __restrict  __format 
                                                                              , ...)  __asm__("__isoc99_sscanf")  ;
 extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
 extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                 __off_t __offset ,
                                                                                 int __whence ) ;
 extern int close(int __fd ) ;
 extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
 extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                                void const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                 char const   *__s2 ,
                                                                                                 size_t __n )  __attribute__((__pure__)) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                 int __c )  __attribute__((__pure__)) ;
 extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                    , ...) ;
 long ar_scan(char *archive , long (*function)() , long arg ) 
 { 
   int long_name ;
   char *namemap ;
   register int desc ;
   int tmp ;
   char buf___1[8] ;
   register int nread ;
   ssize_t tmp___0 ;
   int tmp___1 ;
   register long member_offset ;
   register int nread___0 ;
   struct ar_hdr member_header ;
   char namebuf[sizeof(member_header.ar_name) + 1UL] ;
   char *name ;
   int is_namemap ;
   long eltsize ;
   int eltmode ;
   long fnval ;
   __off_t tmp___2 ;
   ssize_t tmp___3 ;
   int tmp___4 ;
   register char *p ;
   int tmp___5 ;
   int tmp___6 ;
   int tmp___7 ;
   int tmp___8 ;
   int namesize ;
   int tmp___9 ;
   void *tmp___10 ;
   ssize_t tmp___11 ;
   int tmp___12 ;
   int tmp___13 ;
   long tmp___14 ;
   char *clear ;
   char *limit ;
   void *tmp___15 ;
   ssize_t tmp___16 ;
 
   {
   long_name = 0;
   namemap = (char *)0;
   tmp = open((char const   *)archive, 0, 0);
   desc = tmp;
   if (desc < 0) {
     return (-1L);
   }
   tmp___0 = read(desc, (void *)(buf___1), (size_t )8);
   nread = (int )tmp___0;
   if (nread != 8) {
     close(desc);
     return (-2L);
   } else {
     tmp___1 = memcmp((void const   *)(buf___1), (void const   *)"!<arch>\n", (size_t )8);
     if (tmp___1) {
       close(desc);
       return (-2L);
     }
   }
   member_offset = 8L;
   while (1) {
     tmp___2 = lseek(desc, member_offset, 0);
     if (tmp___2 < 0L) {
       close(desc);
       return (-2L);
     }
     tmp___3 = read(desc, (void *)((char *)(& member_header)), sizeof(struct ar_hdr ));
     nread___0 = (int )tmp___3;
     if (nread___0 == 0) {
       break;
     }
     if ((unsigned long )nread___0 != sizeof(struct ar_hdr )) {
       close(desc);
       return (-2L);
     } else {
       tmp___4 = memcmp((void const   *)(member_header.ar_fmag), (void const   *)"`\n",
                        (size_t )2);
       if (tmp___4) {
         close(desc);
         return (-2L);
       }
     }
     name = namebuf;
     memmove((void *)name, (void const   *)(member_header.ar_name), sizeof(member_header.ar_name));
     p = name + sizeof(member_header.ar_name);
     while (1) {
       *p = (char )'\000';
       if ((unsigned long )p > (unsigned long )name) {
         p --;
         if (! ((int )*p == 32)) {
           break;
         }
       } else {
         break;
       }
     }
     tmp___5 = strcmp((char const   *)name, "//");
     if (tmp___5) {
       tmp___6 = strcmp((char const   *)name, "ARFILENAMES/");
       if (tmp___6) {
         tmp___7 = 0;
       } else {
         tmp___7 = 1;
       }
     } else {
       tmp___7 = 1;
     }
     is_namemap = tmp___7;
     if ((int )*p == 47) {
       *p = (char )'\000';
     }
     if (! is_namemap) {
       if ((int )*(name + 0) == 32) {
         goto _L___1;
       } else
       if ((int )*(name + 0) == 47) {
         _L___1: /* CIL Label */ 
         if ((unsigned long )namemap != (unsigned long )((char *)0)) {
           tmp___8 = atoi((char const   *)(name + 1));
           name = namemap + tmp___8;
           long_name = 1;
         } else {
           goto _L___0;
         }
       } else {
         goto _L___0;
       }
     } else
     _L___0: /* CIL Label */ 
     if ((int )*(name + 0) == 35) {
       if ((int )*(name + 1) == 49) {
         if ((int )*(name + 2) == 47) {
           tmp___9 = atoi((char const   *)(name + 3));
           namesize = tmp___9;
           tmp___10 = __builtin_alloca((unsigned long )(namesize + 1));
           name = (char *)tmp___10;
           tmp___11 = read(desc, (void *)name, (size_t )namesize);
           nread___0 = (int )tmp___11;
           if (nread___0 != namesize) {
             close(desc);
             return (-2L);
           }
           *(name + namesize) = (char )'\000';
           long_name = 1;
         }
       }
     }
     sscanf((char const   * __restrict  )(member_header.ar_mode), (char const   * __restrict  )"%o",
            & eltmode);
     eltsize = atol((char const   *)(member_header.ar_size));
     tmp___12 = atoi((char const   *)(member_header.ar_gid));
     tmp___13 = atoi((char const   *)(member_header.ar_uid));
     tmp___14 = atol((char const   *)(member_header.ar_date));
     fnval = (*function)(desc, name, ! long_name, member_offset, (unsigned long )member_offset + sizeof(struct ar_hdr ),
                         eltsize, tmp___14, tmp___13, tmp___12, eltmode, arg);
     if (fnval) {
       close(desc);
       return (fnval);
     }
     if (is_namemap) {
       tmp___15 = __builtin_alloca((unsigned long )eltsize);
       namemap = (char *)tmp___15;
       tmp___16 = read(desc, (void *)namemap, (size_t )eltsize);
       nread___0 = (int )tmp___16;
       if ((long )nread___0 != eltsize) {
         close(desc);
         return (-2L);
       }
       limit = namemap + eltsize;
       clear = namemap;
       while ((unsigned long )clear < (unsigned long )limit) {
         if ((int )*clear == 10) {
           *clear = (char )'\000';
           if ((int )*(clear + -1) == 47) {
             *(clear + -1) = (char )'\000';
           }
         }
         clear ++;
       }
       is_namemap = 0;
     }
     member_offset = (long )((unsigned long )member_offset + (sizeof(struct ar_hdr ) + (unsigned long )eltsize));
     if (member_offset % 2L != 0L) {
       member_offset ++;
     }
   }
   close(desc);
   return (0L);
 }
 }
 int ar_name_equal(char *name , char *mem , int truncated ) 
 { 
   char *p ;
   struct ar_hdr hdr ;
   int tmp ;
   int tmp___0 ;
   int tmp___1 ;
 
   {
   p = strrchr((char const   *)name, '/');
   if ((unsigned long )p != (unsigned long )((char *)0)) {
     name = p + 1;
   }
   if (truncated) {
     tmp = strncmp((char const   *)name, (char const   *)mem, sizeof(hdr.ar_name) - 1UL);
     return (tmp == 0);
   }
   tmp___0 = strcmp((char const   *)name, (char const   *)mem);
   if (tmp___0) {
     tmp___1 = 0;
   } else {
     tmp___1 = 1;
   }
   return (tmp___1);
 }
 }
 static long ar_member_pos(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                           long size , long date , int uid , int gid , int mode , char *name ) 
 { 
   int tmp ;
 
   {
   tmp = ar_name_equal(name, mem, truncated);
   if (! tmp) {
     return (0L);
   }
   return (hdrpos);
 }
 }
 int ar_member_touch(char *arname , char *memname ) 
 { 
   register long pos ;
   long tmp ;
   register int fd ;
   struct ar_hdr ar_hdr ;
   register int i ;
   struct stat statbuf ;
   __off_t tmp___0 ;
   ssize_t tmp___1 ;
   __off_t tmp___2 ;
   ssize_t tmp___3 ;
   int tmp___4 ;
   int *tmp___5 ;
   __off_t tmp___6 ;
   ssize_t tmp___7 ;
   int *tmp___8 ;
   int *tmp___9 ;
 
   {
   tmp = ar_scan(arname, (long (*)())(& ar_member_pos), (long )memname);
   pos = tmp;
   if (pos < 0L) {
     return ((int )pos);
   }
   if (! pos) {
     return (1);
   }
   fd = open((char const   *)arname, 2, 438);
   if (fd < 0) {
     return (-3);
   }
   tmp___0 = lseek(fd, pos, 0);
   if (tmp___0 < 0L) {
     goto lose;
   }
   tmp___1 = read(fd, (void *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
   if (sizeof(struct ar_hdr ) != (unsigned long )tmp___1) {
     goto lose;
   }
   tmp___2 = lseek(fd, pos, 0);
   if (tmp___2 < 0L) {
     goto lose;
   }
   tmp___3 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
   if (sizeof(struct ar_hdr ) != (unsigned long )tmp___3) {
     goto lose;
   }
   while (1) {
     tmp___4 = fstat(fd, & statbuf);
     if (tmp___4 < 0) {
       tmp___5 = __errno_location();
       if (! (*tmp___5 == 4)) {
         break;
       }
     } else {
       break;
     }
   }
   i = 0;
   while ((unsigned long )i < sizeof(ar_hdr.ar_date)) {
     ar_hdr.ar_date[i] = (char )' ';
     i ++;
   }
   sprintf((char * __restrict  )(ar_hdr.ar_date), (char const   * __restrict  )"%ld",
           statbuf.st_mtim.tv_sec);
   tmp___6 = lseek(fd, pos, 0);
   if (tmp___6 < 0L) {
     goto lose;
   }
   tmp___7 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
   if (sizeof(struct ar_hdr ) != (unsigned long )tmp___7) {
     goto lose;
   }
   close(fd);
   return (0);
   lose: 
   tmp___8 = __errno_location();
   i = *tmp___8;
   close(fd);
   tmp___9 = __errno_location();
   *tmp___9 = i;
   return (-3);
 }
 }
 #pragma merger("0","/tmp/cil-0y88q6_t.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
 extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                         void (*__handler)(int  ) ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                            int __sig ) ;
 extern struct _IO_FILE *stdout ;
 extern int printf(char const   * __restrict  __format  , ...) ;
 extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
 extern int puts(char const   *__s ) ;
 extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
 extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
 extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
  __attribute__((__noreturn__)) void pfatal_with_name(char *name ) ;
 char *xrealloc(char *ptr , unsigned int size ) ;
 char *sindex(char const   *big , unsigned int blen , char const   *small , unsigned int slen ) ;
 int handling_fatal_signal ;
 void uniquize_deps(struct dep *chain ) ;
 struct file *default_file ;
 void remove_intermediates(int sig ) ;
 void set_command_state(struct file *file , int state ) ;
 void notice_finished_file(struct file *file ) ;
 void initialize_file_variables(struct file *file , int reading ) ;
 struct variable *define_variable_in_set(char *name , unsigned int length___0 , char *value ,
                                         enum variable_origin origin , int recursive ,
                                         struct variable_set *set , struct floc  const  *flocp ) ;
 struct child *children ;
 void new_job(struct file *file ) ;
 void reap_children(int block , int err ) ;
 unsigned int job_slots_used ;
 void execute_file_commands(struct file *file ) ;
 void print_commands(struct commands *cmds ) ;
 void delete_child_targets(struct child *child ) ;
 void chop_commands(struct commands *cmds ) ;
 int remote_kill(int id , int sig ) ;
 static void set_file_variables(struct file *file ) 
 { 
   register char *p ;
   char *at ;
   char *percent ;
   char *star ;
   char *less ;
   unsigned int len ;
   void *tmp ;
   size_t tmp___0 ;
   void *tmp___1 ;
   int tmp___2 ;
   register struct dep *d ;
   char *name ;
   unsigned int len___0 ;
   char *tmp___3 ;
   size_t tmp___4 ;
   size_t tmp___5 ;
   int tmp___6 ;
   struct file *tmp___7 ;
   unsigned int slen ;
   char *tmp___8 ;
   size_t tmp___9 ;
   char *tmp___10 ;
   int tmp___11 ;
   char *tmp___12 ;
   register unsigned int qmark_len ;
   register unsigned int plus_len ;
   char *caret_value ;
   char *plus_value ;
   register char *cp ;
   char *qmark_value ;
   register char *qp ;
   register struct dep *d___0 ;
   unsigned int len___1 ;
   char *tmp___13 ;
   size_t tmp___14 ;
   void *tmp___15 ;
   char *c ;
   char *tmp___16 ;
   char *tmp___17 ;
   size_t tmp___18 ;
   size_t tmp___19 ;
   int tmp___20 ;
   char *tmp___21 ;
   int tmp___22 ;
   void *tmp___23 ;
   char *c___0 ;
   char *tmp___24 ;
   char *tmp___25 ;
   size_t tmp___26 ;
   size_t tmp___27 ;
   int tmp___28 ;
   char *tmp___29 ;
   char *tmp___30 ;
   int tmp___31 ;
   int tmp___32 ;
 
   {
   tmp___2 = ar_name(file->name);
   if (tmp___2) {
     p = strchr((char const   *)file->name, '(');
     tmp = __builtin_alloca((unsigned long )((p - file->name) + 1L));
     at = (char *)tmp;
     memmove((void *)at, (void const   *)file->name, (size_t )(p - file->name));
     *(at + (p - file->name)) = (char )'\000';
     tmp___0 = strlen((char const   *)(p + 1));
     len = (unsigned int )tmp___0;
     tmp___1 = __builtin_alloca((unsigned long )len);
     percent = (char *)tmp___1;
     memmove((void *)percent, (void const   *)(p + 1), (size_t )(len - 1U));
     *(percent + (len - 1U)) = (char )'\000';
   } else {
     at = file->name;
     percent = (char *)"";
   }
   if ((unsigned long )file->stem == (unsigned long )((char *)0)) {
     tmp___6 = ar_name(file->name);
     if (tmp___6) {
       tmp___3 = strchr((char const   *)file->name, '(');
       name = tmp___3 + 1;
       tmp___4 = strlen((char const   *)name);
       len___0 = (unsigned int )(tmp___4 - 1UL);
     } else {
       name = file->name;
       tmp___5 = strlen((char const   *)name);
       len___0 = (unsigned int )tmp___5;
     }
     tmp___7 = enter_file((char *)".SUFFIXES");
     d = tmp___7->deps;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
         tmp___8 = (d->file)->name;
       } else {
         tmp___8 = d->name;
       }
       tmp___9 = strlen((char const   *)tmp___8);
       slen = (unsigned int )tmp___9;
       if (len___0 > slen) {
         if ((unsigned long )d->name == (unsigned long )((char *)0)) {
           tmp___10 = (d->file)->name;
         } else {
           tmp___10 = d->name;
         }
         tmp___11 = strncmp((char const   *)tmp___10, (char const   *)(name + (len___0 - slen)),
                            (size_t )slen);
         if (tmp___11 == 0) {
           file->stem = savestring((char const   *)name, len___0 - slen);
           break;
         }
       }
       d = d->next;
     }
     if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
       file->stem = (char *)"";
     }
   }
   star = file->stem;
   if ((unsigned long )file->deps != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )(file->deps)->name == (unsigned long )((char *)0)) {
       tmp___12 = ((file->deps)->file)->name;
     } else {
       tmp___12 = (file->deps)->name;
     }
     less = tmp___12;
   } else {
     less = (char *)"";
   }
   if ((unsigned long )file->cmds == (unsigned long )default_file->cmds) {
     less = at;
   }
   define_variable_in_set((char *)"<", 1U, less, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"*", 1U, star, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"@", 1U, at, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"%", 1U, percent, (enum variable_origin )6, 0, (file->variables)->set,
                          (struct floc  const  *)((struct floc *)0));
   plus_len = 0U;
   d___0 = file->deps;
   while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
       tmp___13 = (d___0->file)->name;
     } else {
       tmp___13 = d___0->name;
     }
     tmp___14 = strlen((char const   *)tmp___13);
     plus_len = (unsigned int )((size_t )plus_len + (tmp___14 + 1UL));
     d___0 = d___0->next;
   }
   if (plus_len == 0U) {
     len___1 = 1U;
   } else {
     len___1 = plus_len;
   }
   tmp___15 = __builtin_alloca((unsigned long )len___1);
   plus_value = (char *)tmp___15;
   cp = plus_value;
   qmark_len = plus_len;
   d___0 = file->deps;
   while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
       tmp___16 = (d___0->file)->name;
     } else {
       tmp___16 = d___0->name;
     }
     c = tmp___16;
     tmp___20 = ar_name(c);
     if (tmp___20) {
       tmp___17 = strchr((char const   *)c, '(');
       c = tmp___17 + 1;
       tmp___18 = strlen((char const   *)c);
       len___1 = (unsigned int )(tmp___18 - 1UL);
     } else {
       tmp___19 = strlen((char const   *)c);
       len___1 = (unsigned int )tmp___19;
     }
     memmove((void *)cp, (void const   *)c, (size_t )len___1);
     cp += len___1;
     tmp___21 = cp;
     cp ++;
     *tmp___21 = (char )' ';
     if (! d___0->changed) {
       qmark_len -= len___1 + 1U;
     }
     d___0 = d___0->next;
   }
   if ((unsigned long )cp > (unsigned long )plus_value) {
     tmp___22 = -1;
   } else {
     tmp___22 = 0;
   }
   *(cp + tmp___22) = (char )'\000';
   define_variable_in_set((char *)"+", 1U, plus_value, (enum variable_origin )6, 0,
                          (file->variables)->set, (struct floc  const  *)((struct floc *)0));
   uniquize_deps(file->deps);
   caret_value = plus_value;
   cp = caret_value;
   if (qmark_len == 0U) {
     len___1 = 1U;
   } else {
     len___1 = qmark_len;
   }
   tmp___23 = __builtin_alloca((unsigned long )len___1);
   qmark_value = (char *)tmp___23;
   qp = qmark_value;
   d___0 = file->deps;
   while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
       tmp___24 = (d___0->file)->name;
     } else {
       tmp___24 = d___0->name;
     }
     c___0 = tmp___24;
     tmp___28 = ar_name(c___0);
     if (tmp___28) {
       tmp___25 = strchr((char const   *)c___0, '(');
       c___0 = tmp___25 + 1;
       tmp___26 = strlen((char const   *)c___0);
       len___1 = (unsigned int )(tmp___26 - 1UL);
     } else {
       tmp___27 = strlen((char const   *)c___0);
       len___1 = (unsigned int )tmp___27;
     }
     memmove((void *)cp, (void const   *)c___0, (size_t )len___1);
     cp += len___1;
     tmp___29 = cp;
     cp ++;
     *tmp___29 = (char )' ';
     if (d___0->changed) {
       memmove((void *)qp, (void const   *)c___0, (size_t )len___1);
       qp += len___1;
       tmp___30 = qp;
       qp ++;
       *tmp___30 = (char )' ';
     }
     d___0 = d___0->next;
   }
   if ((unsigned long )cp > (unsigned long )caret_value) {
     tmp___31 = -1;
   } else {
     tmp___31 = 0;
   }
   *(cp + tmp___31) = (char )'\000';
   define_variable_in_set((char *)"^", 1U, caret_value, (enum variable_origin )6, 0,
                          (file->variables)->set, (struct floc  const  *)((struct floc *)0));
   if ((unsigned long )qp > (unsigned long )qmark_value) {
     tmp___32 = -1;
   } else {
     tmp___32 = 0;
   }
   *(qp + tmp___32) = (char )'\000';
   define_variable_in_set((char *)"?", 1U, qmark_value, (enum variable_origin )6, 0,
                          (file->variables)->set, (struct floc  const  *)((struct floc *)0));
   return;
 }
 }
 void chop_commands(struct commands *cmds ) 
 { 
   register char *p ;
   unsigned int nlines ;
   unsigned int idx ;
   char **lines ;
   char *tmp ;
   char *end ;
   size_t tmp___0 ;
   int backslash ;
   register char *b ;
   char *tmp___1 ;
   unsigned int tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   int flags ;
   unsigned short const   **tmp___5 ;
   unsigned int len ;
   size_t tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
 
   {
   if (! cmds) {
     return;
   } else
   if ((unsigned long )cmds->command_lines != (unsigned long )((char **)0)) {
     return;
   }
   nlines = 5U;
   tmp = xmalloc((unsigned int )(5UL * sizeof(char *)));
   lines = (char **)tmp;
   idx = 0U;
   p = cmds->commands;
   while ((int )*p != 0) {
     end = p;
     find_end: 
     end = strchr((char const   *)end, '\n');
     if ((unsigned long )end == (unsigned long )((char *)0)) {
       tmp___0 = strlen((char const   *)p);
       end = p + tmp___0;
     } else
     if ((unsigned long )end > (unsigned long )p) {
       if ((int )*(end + -1) == 92) {
         backslash = 1;
         b = end - 2;
         while (1) {
           if ((unsigned long )b >= (unsigned long )p) {
             if (! ((int )*b == 92)) {
               break;
             }
           } else {
             break;
           }
           backslash = ! backslash;
           b --;
         }
         if (backslash) {
           end ++;
           goto find_end;
         }
       }
     }
     if (idx == nlines) {
       nlines += 2U;
       tmp___1 = xrealloc((char *)lines, (unsigned int )((unsigned long )nlines * sizeof(char *)));
       lines = (char **)tmp___1;
     }
     tmp___2 = idx;
     idx ++;
     *(lines + tmp___2) = savestring((char const   *)p, (unsigned int )(end - p));
     p = end;
     if ((int )*p != 0) {
       p ++;
     }
   }
   if (idx != nlines) {
     nlines = idx;
     tmp___3 = xrealloc((char *)lines, (unsigned int )((unsigned long )nlines * sizeof(char *)));
     lines = (char **)tmp___3;
   }
   cmds->ncommand_lines = nlines;
   cmds->command_lines = lines;
   cmds->any_recurse = 0;
   tmp___4 = xmalloc(nlines);
   cmds->lines_flags = tmp___4;
   idx = 0U;
   while (idx < nlines) {
     flags = 0;
     p = *(lines + idx);
     while (1) {
       tmp___5 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___5 + (int )*p) & 1)) {
         if (! ((int )*p == 45)) {
           if (! ((int )*p == 64)) {
             if (! ((int )*p == 43)) {
               break;
             }
           }
         }
       }
       switch ((int )*p) {
       case 43: 
       flags |= 1;
       break;
       case 64: 
       flags |= 2;
       break;
       case 45: 
       flags |= 4;
       break;
       }
       p ++;
     }
     if (! (flags & 1)) {
       tmp___6 = strlen((char const   *)p);
       len = (unsigned int )tmp___6;
       tmp___7 = sindex((char const   *)p, len, "$(MAKE)", 7U);
       if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
         flags |= 1;
       } else {
         tmp___8 = sindex((char const   *)p, len, "${MAKE}", 7U);
         if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
           flags |= 1;
         }
       }
     }
     *(cmds->lines_flags + idx) = (char )flags;
     cmds->any_recurse |= flags & 1;
     idx ++;
   }
   return;
 }
 }
 void execute_file_commands(struct file *file ) 
 { 
   register char *p ;
   unsigned short const   **tmp ;
 
   {
   p = (file->cmds)->commands;
   while ((int )*p != 0) {
     tmp = __ctype_b_loc();
     if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
       if ((int )*p != 45) {
         if ((int )*p != 64) {
           break;
         }
       }
     }
     p ++;
   }
   if ((int )*p == 0) {
     set_command_state(file, 2);
     file->update_status = (short)0;
     notice_finished_file(file);
     return;
   }
   initialize_file_variables(file, 0);
   set_file_variables(file);
   new_job(file);
   return;
 }
 }
 int handling_fatal_signal  =    0;
 void fatal_error_signal(int sig ) 
 { 
   register struct child *c ;
   register struct child *c___0 ;
   __pid_t tmp ;
   int tmp___0 ;
 
   {
   handling_fatal_signal = 1;
   signal(sig, (void (*)(int  ))0);
   if (sig == 15) {
     c = children;
     while ((unsigned long )c != (unsigned long )((struct child *)0)) {
       if (! c->remote) {
         kill(c->pid, 15);
       }
       c = c->next;
     }
   }
   if (sig == 15) {
     goto _L;
   } else
   if (sig == 2) {
     goto _L;
   } else
   if (sig == 1) {
     goto _L;
   } else
   if (sig == 3) {
     _L: /* CIL Label */ 
     c___0 = children;
     while ((unsigned long )c___0 != (unsigned long )((struct child *)0)) {
       if (c___0->remote) {
         remote_kill(c___0->pid, sig);
       }
       c___0 = c___0->next;
     }
     c___0 = children;
     while ((unsigned long )c___0 != (unsigned long )((struct child *)0)) {
       delete_child_targets(c___0);
       c___0 = c___0->next;
     }
     while (job_slots_used > 0U) {
       reap_children(1, 0);
     }
   } else {
     while (job_slots_used > 0U) {
       reap_children(1, 1);
     }
   }
   remove_intermediates(1);
   if (sig == 3) {
     exit(1);
   }
   tmp = getpid();
   tmp___0 = kill(tmp, sig);
   if (tmp___0 < 0) {
     pfatal_with_name((char *)"kill");
   }
   return;
 }
 }
 static void delete_target(struct file *file , char *on_behalf_of ) 
 { 
   struct stat st ;
   char *tmp ;
   char *tmp___0 ;
   time_t tmp___1 ;
   uintmax_t tmp___2 ;
   uintmax_t tmp___3 ;
   int tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   int tmp___7 ;
   int *tmp___8 ;
   int tmp___9 ;
   uintmax_t tmp___10 ;
   uintmax_t tmp___11 ;
 
   {
   if (file->precious) {
     return;
   } else
   if (file->phony) {
     return;
   }
   tmp___4 = ar_name(file->name);
   if (tmp___4) {
     tmp___1 = ar_member_date(file->name);
     if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
       tmp___2 = (uintmax_t )1000000000;
     } else {
       tmp___2 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
     }
     if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
       tmp___3 = (uintmax_t )1000000000;
     } else {
       tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
     }
     if ((uintmax_t )tmp___1 != file->last_mtime / tmp___2 - (uintmax_t )(file->last_mtime % tmp___3 < 0UL)) {
       if (on_behalf_of) {
         tmp = dcgettext((char const   *)((void *)0), "*** [%s] Archive member `%s\' may be bogus; not deleted",
                         5);
         error((struct floc  const  *)((struct floc *)0), (char const   *)tmp, on_behalf_of,
               file->name);
       } else {
         tmp___0 = dcgettext((char const   *)((void *)0), "*** Archive member `%s\' may be bogus; not deleted",
                             5);
         error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0,
               file->name);
       }
     }
     return;
   }
   tmp___9 = stat((char const   * __restrict  )file->name, (struct stat * __restrict  )(& st));
   if (tmp___9 == 0) {
     if ((st.st_mode & 61440U) == 32768U) {
       if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
         tmp___10 = (uintmax_t )1000000000;
       } else {
         tmp___10 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
       }
       if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
         tmp___11 = (uintmax_t )1000000000;
       } else {
         tmp___11 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
       }
       if ((uintmax_t )st.st_mtim.tv_sec * tmp___10 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___11) / 1000000000UL != file->last_mtime) {
         if (on_behalf_of) {
           tmp___5 = dcgettext((char const   *)((void *)0), "*** [%s] Deleting file `%s\'",
                               5);
           error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___5,
                 on_behalf_of, file->name);
         } else {
           tmp___6 = dcgettext((char const   *)((void *)0), "*** Deleting file `%s\'",
                               5);
           error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                 file->name);
         }
         tmp___7 = unlink((char const   *)file->name);
         if (tmp___7 < 0) {
           tmp___8 = __errno_location();
           if (*tmp___8 != 2) {
             perror_with_name((char *)"unlink: ", file->name);
           }
         }
       }
     }
   }
   return;
 }
 }
 void delete_child_targets(struct child *child ) 
 { 
   struct dep *d ;
 
   {
   if (child->deleted) {
     return;
   }
   delete_target(child->file, (char *)0);
   d = (child->file)->also_make;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     delete_target(d->file, (child->file)->name);
     d = d->next;
   }
   child->deleted = 1U;
   return;
 }
 }
 void print_commands(struct commands *cmds ) 
 { 
   register char *s ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *end ;
   unsigned short const   **tmp___2 ;
   size_t tmp___3 ;
 
   {
   tmp = dcgettext((char const   *)((void *)0), "#  commands to execute", 5);
   fputs((char const   * __restrict  )tmp, (FILE * __restrict  )stdout);
   if ((unsigned long )cmds->fileinfo.filenm == (unsigned long )((char *)0)) {
     tmp___0 = dcgettext((char const   *)((void *)0), " (built-in):", 5);
     puts((char const   *)tmp___0);
   } else {
     tmp___1 = dcgettext((char const   *)((void *)0), " (from `%s\', line %lu):\n",
                         5);
     printf((char const   * __restrict  )tmp___1, cmds->fileinfo.filenm, cmds->fileinfo.lineno);
   }
   s = cmds->commands;
   while ((int )*s != 0) {
     while (1) {
       tmp___2 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192)) {
         break;
       }
       s ++;
     }
     end = strchr((char const   *)s, '\n');
     if ((unsigned long )end == (unsigned long )((char *)0)) {
       tmp___3 = strlen((char const   *)s);
       end = s + tmp___3;
     }
     printf((char const   * __restrict  )"\t%.*s\n", (int )(end - s), s);
     s = end;
   }
   return;
 }
 }
 #pragma merger("0","/tmp/cil-VKXtmFCh.i","-g,-O0")
 extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                                int __c ,
                                                                                                size_t __n ) ;
 char *xstrdup(char const   *ptr ) ;
 int dir_file_exists_p(char *dirname , char *filename ) ;
 int file_impossible_p(char *filename ) ;
 void file_impossible(char *filename ) ;
 char *dir_name(char *dir ) ;
 extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
 extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
 extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
 static struct directory_contents *directories_contents[199]  ;
 static struct directory *directories[199]  ;
 static unsigned int open_directories  =    0U;
 static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) ;
 static struct directory *find_directory(char *name ) ;
 static struct directory *find_directory(char *name ) 
 { 
   register unsigned int hash ;
   register char *p ;
   register struct directory *dir ;
   int tmp ;
   struct stat st ;
   char *tmp___0 ;
   struct directory_contents *dc ;
   char *tmp___1 ;
   char *tmp___2 ;
   int tmp___3 ;
 
   {
   hash = 0U;
   p = name;
   while ((int )*p != 0) {
     hash += (unsigned int )*p;
     hash = (hash << 7) + (hash >> 20);
     p ++;
   }
   hash %= 199U;
   dir = directories[hash];
   while ((unsigned long )dir != (unsigned long )((struct directory *)0)) {
     if ((unsigned long )dir->name == (unsigned long )name) {
       break;
     } else
     if ((int )*(dir->name) == (int )*name) {
       if ((int )*(dir->name) == 0) {
         break;
       } else {
         tmp = strcmp((char const   *)(dir->name + 1), (char const   *)(name + 1));
         if (! tmp) {
           break;
         }
       }
     }
     dir = dir->next;
   }
   if ((unsigned long )dir == (unsigned long )((struct directory *)0)) {
     tmp___0 = xmalloc((unsigned int )sizeof(struct directory ));
     dir = (struct directory *)tmp___0;
     dir->next = directories[hash];
     directories[hash] = dir;
     dir->name = savestring((char const   *)name, (unsigned int )(p - name));
     tmp___3 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
     if (tmp___3 < 0) {
       dir->contents = (struct directory_contents *)0;
     } else {
       hash = ((unsigned int )st.st_dev << 16) | (unsigned int )st.st_ino;
       hash %= 199U;
       dc = directories_contents[hash];
       while ((unsigned long )dc != (unsigned long )((struct directory_contents *)0)) {
         if (dc->dev == st.st_dev) {
           if (dc->ino == st.st_ino) {
             break;
           }
         }
         dc = dc->next;
       }
       if ((unsigned long )dc == (unsigned long )((struct directory_contents *)0)) {
         tmp___1 = xmalloc((unsigned int )sizeof(struct directory_contents ));
         dc = (struct directory_contents *)tmp___1;
         dc->dev = st.st_dev;
         dc->ino = st.st_ino;
         dc->next = directories_contents[hash];
         directories_contents[hash] = dc;
         dc->dirstream = opendir((char const   *)name);
         if ((unsigned long )dc->dirstream == (unsigned long )((DIR *)0)) {
           dc->files = (struct dirfile **)0;
         } else {
           tmp___2 = xmalloc((unsigned int )(sizeof(struct dirfile *) * 107UL));
           dc->files = (struct dirfile **)tmp___2;
           memset((void *)((char *)dc->files), 0, sizeof(struct dirfile *) * 107UL);
           open_directories ++;
           if (open_directories == 10U) {
             dir_contents_file_exists_p(dc, (char *)0);
           }
         }
       }
       dir->contents = dc;
     }
   }
   return (dir);
 }
 }
 static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) 
 { 
   register unsigned int hash ;
   register char *p ;
   register struct dirfile *df ;
   register struct dirent *d ;
   int tmp ;
   register unsigned int newhash ;
   unsigned int len ;
   register unsigned int i ;
   size_t tmp___0 ;
   char *tmp___1 ;
   int tmp___2 ;
 
   {
   if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
     return (0);
   } else
   if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
     return (0);
   }
   hash = 0U;
   if ((unsigned long )filename != (unsigned long )((char *)0)) {
     if ((int )*filename == 0) {
       return (1);
     }
     p = filename;
     while ((int )*p != 0) {
       hash += (unsigned int )*p;
       hash = (hash << 7) + (hash >> 20);
       p ++;
     }
     hash %= 107U;
     df = *(dir->files + hash);
     while ((unsigned long )df != (unsigned long )((struct dirfile *)0)) {
       if ((unsigned long )df->name == (unsigned long )filename) {
         return (! df->impossible);
       } else
       if ((int )*(df->name) == (int )*filename) {
         if ((int )*(df->name) == 0) {
           return (! df->impossible);
         } else {
           tmp = strcmp((char const   *)(df->name + 1), (char const   *)(filename + 1));
           if (! tmp) {
             return (! df->impossible);
           }
         }
       }
       df = df->next;
     }
   }
   if ((unsigned long )dir->dirstream == (unsigned long )((DIR *)0)) {
     return (0);
   }
   while (1) {
     d = readdir(dir->dirstream);
     if (! ((unsigned long )d != (unsigned long )((struct dirent *)0))) {
       break;
     }
     newhash = 0U;
     if (! (d->d_ino != 0UL)) {
       continue;
     }
     tmp___0 = strlen((char const   *)(d->d_name));
     len = (unsigned int )tmp___0;
     i = 0U;
     while (i < len) {
       newhash += (unsigned int )d->d_name[i];
       newhash = (newhash << 7) + (newhash >> 20);
       i ++;
     }
     newhash %= 107U;
     tmp___1 = xmalloc((unsigned int )sizeof(struct dirfile ));
     df = (struct dirfile *)tmp___1;
     df->next = *(dir->files + newhash);
     *(dir->files + newhash) = df;
     df->name = savestring((char const   *)(d->d_name), len);
     df->impossible = (char)0;
     if ((unsigned long )filename != (unsigned long )((char *)0)) {
       if (newhash == hash) {
         if ((unsigned long )(d->d_name) == (unsigned long )filename) {
           return (1);
         } else
         if ((int )d->d_name[0] == (int )*filename) {
           if ((int )d->d_name[0] == 0) {
             return (1);
           } else {
             tmp___2 = strcmp((char const   *)(d->d_name + 1), (char const   *)(filename + 1));
             if (! tmp___2) {
               return (1);
             }
           }
         }
       }
     }
   }
   if ((unsigned long )d == (unsigned long )((struct dirent *)0)) {
     open_directories --;
     closedir(dir->dirstream);
     dir->dirstream = (DIR *)0;
   }
   return (0);
 }
 }
 int dir_file_exists_p(char *dirname , char *filename ) 
 { 
   struct directory *tmp ;
   int tmp___0 ;
 
   {
   tmp = find_directory(dirname);
   tmp___0 = dir_contents_file_exists_p(tmp->contents, filename);
   return (tmp___0);
 }
 }
 int file_exists_p(char *name ) 
 { 
   char *dirend ;
   char *dirname ;
   char *slash ;
   time_t tmp ;
   int tmp___0 ;
   int tmp___1 ;
   void *tmp___2 ;
   int tmp___3 ;
 
   {
   tmp___0 = ar_name(name);
   if (tmp___0) {
     tmp = ar_member_date(name);
     return (tmp != -1L);
   }
   dirend = strrchr((char const   *)name, '/');
   if ((unsigned long )dirend == (unsigned long )((char *)0)) {
     tmp___1 = dir_file_exists_p((char *)".", name);
     return (tmp___1);
   }
   slash = dirend;
   if ((unsigned long )dirend == (unsigned long )name) {
     dirname = (char *)"/";
   } else {
     tmp___2 = __builtin_alloca((unsigned long )((dirend - name) + 1L));
     dirname = (char *)tmp___2;
     memmove((void *)dirname, (void const   *)name, (size_t )(dirend - name));
     *(dirname + (dirend - name)) = (char )'\000';
   }
   tmp___3 = dir_file_exists_p(dirname, slash + 1);
   return (tmp___3);
 }
 }
 void file_impossible(char *filename ) 
 { 
   char *dirend ;
   register char *p ;
   register unsigned int hash ;
   register struct directory *dir ;
   register struct dirfile *new ;
   char *dirname ;
   char *slash ;
   void *tmp ;
   char *tmp___0 ;
   ino_t tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
 
   {
   p = filename;
   dirend = strrchr((char const   *)p, '/');
   if ((unsigned long )dirend == (unsigned long )((char *)0)) {
     dir = find_directory((char *)".");
   } else {
     slash = dirend;
     if ((unsigned long )dirend == (unsigned long )p) {
       dirname = (char *)"/";
     } else {
       tmp = __builtin_alloca((unsigned long )((dirend - p) + 1L));
       dirname = (char *)tmp;
       memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));
       *(dirname + (dirend - p)) = (char )'\000';
     }
     dir = find_directory(dirname);
     p = slash + 1;
     filename = p;
   }
   hash = 0U;
   while ((int )*p != 0) {
     hash += (unsigned int )*p;
     hash = (hash << 7) + (hash >> 20);
     p ++;
   }
   hash %= 107U;
   if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
     tmp___0 = xmalloc((unsigned int )sizeof(struct directory_contents ));
     dir->contents = (struct directory_contents *)tmp___0;
     tmp___1 = (ino_t )0;
     (dir->contents)->ino = tmp___1;
     (dir->contents)->dev = tmp___1;
     (dir->contents)->files = (struct dirfile **)0;
     (dir->contents)->dirstream = (DIR *)0;
   }
   if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
     tmp___2 = xmalloc((unsigned int )(sizeof(struct dirfile ) * 107UL));
     (dir->contents)->files = (struct dirfile **)tmp___2;
     memset((void *)((char *)(dir->contents)->files), 0, sizeof(struct dirfile ) * 107UL);
   }
   tmp___3 = xmalloc((unsigned int )sizeof(struct dirfile ));
   new = (struct dirfile *)tmp___3;
   new->next = *((dir->contents)->files + hash);
   *((dir->contents)->files + hash) = new;
   new->name = xstrdup((char const   *)filename);
   new->impossible = (char)1;
   return;
 }
 }
 int file_impossible_p(char *filename ) 
 { 
   char *dirend ;
   register char *p ;
   register unsigned int hash ;
   register struct directory_contents *dir ;
   register struct dirfile *next ;
   struct directory *tmp ;
   char *dirname ;
   char *slash ;
   void *tmp___0 ;
   struct directory *tmp___1 ;
   int tmp___2 ;
 
   {
   p = filename;
   dirend = strrchr((char const   *)filename, '/');
   if ((unsigned long )dirend == (unsigned long )((char *)0)) {
     tmp = find_directory((char *)".");
     dir = tmp->contents;
   } else {
     slash = dirend;
     if ((unsigned long )dirend == (unsigned long )filename) {
       dirname = (char *)"/";
     } else {
       tmp___0 = __builtin_alloca((unsigned long )((dirend - filename) + 1L));
       dirname = (char *)tmp___0;
       memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));
       *(dirname + (dirend - p)) = (char )'\000';
     }
     tmp___1 = find_directory(dirname);
     dir = tmp___1->contents;
     filename = slash + 1;
     p = filename;
   }
   if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
     return (0);
   } else
   if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
     return (0);
   }
   hash = 0U;
   while ((int )*p != 0) {
     hash += (unsigned int )*p;
     hash = (hash << 7) + (hash >> 20);
     p ++;
   }
   hash %= 107U;
   next = *(dir->files + hash);
   while ((unsigned long )next != (unsigned long )((struct dirfile *)0)) {
     if ((unsigned long )filename == (unsigned long )next->name) {
       return ((int )next->impossible);
     } else
     if ((int )*filename == (int )*(next->name)) {
       if ((int )*filename == 0) {
         return ((int )next->impossible);
       } else {
         tmp___2 = strcmp((char const   *)(filename + 1), (char const   *)(next->name + 1));
         if (! tmp___2) {
           return ((int )next->impossible);
         }
       }
     }
     next = next->next;
   }
   return (0);
 }
 }
 char *dir_name(char *dir ) 
 { 
   struct directory *tmp ;
 
   {
   tmp = find_directory(dir);
   return (tmp->name);
 }
 }
 void print_dir_data_base(void) 
 { 
   register unsigned int i ;
   register unsigned int dirs___0 ;
   register unsigned int files___0 ;
   register unsigned int impossible ;
   register struct directory *dir ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   register unsigned int f ;
   register unsigned int im ;
   register unsigned int j ;
   register struct dirfile *df ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   char *tmp___9 ;
   char *tmp___10 ;
   char *tmp___11 ;
 
   {
   tmp = dcgettext((char const   *)((void *)0), "\n# Directories\n", 5);
   puts((char const   *)tmp);
   impossible = 0U;
   files___0 = impossible;
   dirs___0 = files___0;
   i = 0U;
   while (i < 199U) {
     dir = directories[i];
     while ((unsigned long )dir != (unsigned long )((struct directory *)0)) {
       dirs___0 ++;
       if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
         tmp___0 = dcgettext((char const   *)((void *)0), "# %s: could not be stat\'d.\n",
                             5);
         printf((char const   * __restrict  )tmp___0, dir->name);
       } else
       if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
         tmp___1 = dcgettext((char const   *)((void *)0), "# %s (device %ld, inode %ld): could not be opened.\n",
                             5);
         printf((char const   * __restrict  )tmp___1, dir->name, (long )(dir->contents)->dev,
                (long )(dir->contents)->ino);
       } else {
         f = 0U;
         im = 0U;
         j = 0U;
         while (j < 107U) {
           df = *((dir->contents)->files + j);
           while ((unsigned long )df != (unsigned long )((struct dirfile *)0)) {
             if (df->impossible) {
               im ++;
             } else {
               f ++;
             }
             df = df->next;
           }
           j ++;
         }
         tmp___2 = dcgettext((char const   *)((void *)0), "# %s (device %ld, inode %ld): ",
                             5);
         printf((char const   * __restrict  )tmp___2, dir->name, (long )(dir->contents)->dev,
                (long )(dir->contents)->ino);
         if (f == 0U) {
           tmp___3 = dcgettext((char const   *)((void *)0), "No", 5);
           fputs((char const   * __restrict  )tmp___3, (FILE * __restrict  )stdout);
         } else {
           printf((char const   * __restrict  )"%u", f);
         }
         tmp___4 = dcgettext((char const   *)((void *)0), " files, ", 5);
         fputs((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);
         if (im == 0U) {
           tmp___5 = dcgettext((char const   *)((void *)0), "no", 5);
           fputs((char const   * __restrict  )tmp___5, (FILE * __restrict  )stdout);
         } else {
           printf((char const   * __restrict  )"%u", im);
         }
         tmp___6 = dcgettext((char const   *)((void *)0), " impossibilities", 5);
         fputs((char const   * __restrict  )tmp___6, (FILE * __restrict  )stdout);
         if ((unsigned long )(dir->contents)->dirstream == (unsigned long )((DIR *)0)) {
           puts(".");
         } else {
           tmp___7 = dcgettext((char const   *)((void *)0), " so far.", 5);
           puts((char const   *)tmp___7);
         }
         files___0 += f;
         impossible += im;
       }
       dir = dir->next;
     }
     i ++;
   }
   fputs((char const   * __restrict  )"\n# ", (FILE * __restrict  )stdout);
   if (files___0 == 0U) {
     tmp___8 = dcgettext((char const   *)((void *)0), "No", 5);
     fputs((char const   * __restrict  )tmp___8, (FILE * __restrict  )stdout);
   } else {
     printf((char const   * __restrict  )"%u", files___0);
   }
   tmp___9 = dcgettext((char const   *)((void *)0), " files, ", 5);
   fputs((char const   * __restrict  )tmp___9, (FILE * __restrict  )stdout);
   if (impossible == 0U) {
     tmp___10 = dcgettext((char const   *)((void *)0), "no", 5);
     fputs((char const   * __restrict  )tmp___10, (FILE * __restrict  )stdout);
   } else {
     printf((char const   * __restrict  )"%u", impossible);
   }
   tmp___11 = dcgettext((char const   *)((void *)0), " impossibilities in %u directories.\n",
                        5);
   printf((char const   * __restrict  )tmp___11, dirs___0);
   return;
 }
 }
 static void *open_dirstream(char const   *directory ) ;
 static struct dirent *read_dirstream(void *stream ) ;
 static void *open_dirstream(char const   *directory ) 
 { 
   struct dirstream *new ;
   struct directory *dir ;
   struct directory *tmp ;
   char *tmp___0 ;
 
   {
   tmp = find_directory((char *)directory);
   dir = tmp;
   if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
     return ((void *)0);
   } else
   if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
     return ((void *)0);
   }
   dir_contents_file_exists_p(dir->contents, (char *)0);
   tmp___0 = xmalloc((unsigned int )sizeof(struct dirstream ));
   new = (struct dirstream *)tmp___0;
   new->contents = dir->contents;
   new->bucket = 0U;
   new->elt = *((new->contents)->files + 0);
   return ((void *)new);
 }
 }
 static char *buf  ;
 static unsigned int bufsz  ;
 static struct dirent *read_dirstream(void *stream ) 
 { 
   struct dirstream *ds ;
   register struct dirfile *df ;
   struct dirent *d ;
   unsigned int len ;
   size_t tmp ;
 
   {
   ds = (struct dirstream *)stream;
   while (ds->bucket < 107U) {
     while (1) {
       df = ds->elt;
       if (! ((unsigned long )df != (unsigned long )((struct dirfile *)0))) {
         break;
       }
       ds->elt = df->next;
       if (! df->impossible) {
         tmp = strlen((char const   *)df->name);
         len = (unsigned int )(tmp + 1UL);
         if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
           if ((unsigned long )buf != (unsigned long )((char *)0)) {
             free((void *)buf);
           }
           bufsz *= 2U;
           if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
             bufsz = (unsigned int )((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len);
           }
           buf = xmalloc(bufsz);
         }
         d = (struct dirent *)buf;
         d->d_ino = (__ino_t )1;
         d->d_type = (unsigned char)0;
         memcpy((void * __restrict  )(d->d_name), (void const   * __restrict  )df->name,
                (size_t )len);
         return (d);
       }
     }
     (ds->bucket) ++;
     if (ds->bucket == 107U) {
       break;
     }
     ds->elt = *((ds->contents)->files + ds->bucket);
   }
   return ((struct dirent *)0);
 }
 }
 static void ansi_free(void *p ) 
 { 
 
 
   {
   if (p) {
     free(p);
   }
   return;
 }
 }
 void dir_setup_glob(glob_t *gl ) 
 { 
 
 
   {
   gl->gl_opendir = & open_dirstream;
   gl->gl_readdir = & read_dirstream;
   gl->gl_closedir = & ansi_free;
   gl->gl_stat = (int (*)(char const   * , struct stat * ))(& stat);
   return;
 }
 }
 #pragma merger("0","/tmp/cil-3QgulJGN.i","-g,-O0")
 extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                    char const   *__file ,
                                                                                                    unsigned int __line ,
                                                                                                    char const   *__function ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ) ;
 char *lindex(char const   *s , char const   *limit , int c ) ;
 char *find_percent(char *pattern ) ;
 struct floc  const  *reading_file ;
 int warn_undefined_variables_flag ;
 char *variable_buffer  ;
 struct variable_set_list *current_variable_set_list ;
 char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) ;
 char *variable_expand(char *line ) ;
 char *allocated_variable_expand_for_file(char *line , struct file *file ) ;
 char *expand_argument(char *str , char *end ) ;
 char *variable_expand_string(char *line , char *string , long length___0 ) ;
 int handle_function(char **op , char **stringp ) ;
 char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                    unsigned int rlen , int by_word , int suffix_only ) ;
 char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                       char *replace_percent ) ;
 char *recursively_expand(struct variable *v ) ;
 struct variable *lookup_variable(char *name , unsigned int length___0 ) ;
 static unsigned int variable_buffer_length  ;
 char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) 
 { 
   register unsigned int newlen ;
   unsigned int offset ;
   char *tmp ;
 
   {
   newlen = (unsigned int )((long )length___0 + (ptr - variable_buffer));
   if (newlen + 5U > variable_buffer_length) {
     offset = (unsigned int )(ptr - variable_buffer);
     if (newlen + 100U > 2U * variable_buffer_length) {
       variable_buffer_length = newlen + 100U;
     } else {
       variable_buffer_length = 2U * variable_buffer_length;
     }
     tmp = xrealloc(variable_buffer, variable_buffer_length);
     variable_buffer = tmp;
     ptr = variable_buffer + offset;
   }
   memmove((void *)ptr, (void const   *)string, (size_t )length___0);
   return (ptr + length___0);
 }
 }
 static char *initialize_variable_output(void) 
 { 
   char *tmp ;
 
   {
   if ((unsigned long )variable_buffer == (unsigned long )((char *)0)) {
     variable_buffer_length = 200U;
     tmp = xmalloc(variable_buffer_length);
     variable_buffer = tmp;
     *(variable_buffer + 0) = (char )'\000';
   }
   return (variable_buffer);
 }
 }
 static char *allocated_variable_append(struct variable *v ) ;
 char *recursively_expand(struct variable *v ) 
 { 
   char *value ;
   char *tmp ;
 
   {
   if (v->expanding) {
     tmp = dcgettext((char const   *)((void *)0), "Recursive variable `%s\' references itself (eventually)",
                     5);
     fatal(reading_file, (char const   *)tmp, v->name);
   }
   v->expanding = 1U;
   if (v->append) {
     value = allocated_variable_append(v);
   } else {
     value = allocated_variable_expand_for_file(v->value, (struct file *)0);
   }
   v->expanding = 0U;
   return (value);
 }
 }
 __inline static void warn_undefined(char *name , unsigned int length___0 ) 
 { 
   char *tmp ;
 
   {
   if (warn_undefined_variables_flag) {
     tmp = dcgettext((char const   *)((void *)0), "warning: undefined variable `%.*s\'",
                     5);
     error(reading_file, (char const   *)tmp, (int )length___0, name);
   }
   return;
 }
 }
 __inline static char *reference_variable(char *o , char *name , unsigned int length___0 ) 
 { 
   register struct variable *v ;
   char *value ;
   char *tmp ;
   size_t tmp___0 ;
 
   {
   v = lookup_variable(name, length___0);
   if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
     warn_undefined(name, length___0);
   }
   if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
     return (o);
   } else
   if ((int )*(v->value) == 0) {
     return (o);
   }
   if (v->recursive) {
     tmp = recursively_expand(v);
     value = tmp;
   } else {
     value = v->value;
   }
   tmp___0 = strlen((char const   *)value);
   o = variable_buffer_output(o, value, (unsigned int )tmp___0);
   if (v->recursive) {
     free((void *)value);
   }
   return (o);
 }
 }
 char *variable_expand_string(char *line , char *string , long length___0 ) 
 { 
   register struct variable *v ;
   register char *p ;
   register char *o ;
   register char *p1 ;
   char save_char ;
   unsigned int line_offset ;
   size_t tmp ;
   size_t tmp___0 ;
   char openparen ;
   char closeparen ;
   int tmp___1 ;
   register char *beg ;
   int free_beg ;
   char *op ;
   char *begp ;
   char *end ;
   char *colon ;
   int tmp___2 ;
   char *tmp___3 ;
   int count ;
   char *subst_beg ;
   char *subst_end ;
   char *replace_beg ;
   char *replace_end ;
   char *value ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *pattern ;
   char *percent ;
   void *tmp___6 ;
   char *replace ;
   void *tmp___7 ;
   size_t tmp___8 ;
   unsigned short const   **tmp___9 ;
   char name[5] ;
   size_t tmp___10 ;
 
   {
   save_char = (char )'\000';
   if (! line) {
     line = initialize_variable_output();
   }
   p = string;
   o = line;
   line_offset = (unsigned int )(line - variable_buffer);
   if (length___0 >= 0L) {
     save_char = *(string + length___0);
     *(string + length___0) = (char )'\000';
   }
   while (1) {
     p1 = strchr((char const   *)p, '$');
     if ((unsigned long )p1 != (unsigned long )((char *)0)) {
       tmp___0 = (size_t )(p1 - p);
     } else {
       tmp = strlen((char const   *)p);
       tmp___0 = tmp + 1UL;
     }
     o = variable_buffer_output(o, p, (unsigned int )tmp___0);
     if ((unsigned long )p1 == (unsigned long )((char *)0)) {
       break;
     }
     p = p1 + 1;
     switch ((int )*p) {
     case 36: 
     o = variable_buffer_output(o, p, 1U);
     break;
     case 123: 
     case 40: 
     openparen = *p;
     if ((int )openparen == 40) {
       tmp___1 = ')';
     } else {
       tmp___1 = '}';
     }
     closeparen = (char )tmp___1;
     beg = p + 1;
     free_beg = 0;
     op = o;
     begp = p;
     tmp___2 = handle_function(& op, & begp);
     if (tmp___2) {
       o = op;
       p = begp;
       break;
     }
     end = strchr((char const   *)beg, (int )closeparen);
     if ((unsigned long )end == (unsigned long )((char *)0)) {
       tmp___3 = dcgettext((char const   *)((void *)0), "unterminated variable reference",
                           5);
       fatal(reading_file, (char const   *)tmp___3);
     }
     p1 = lindex((char const   *)beg, (char const   *)end, '$');
     if ((unsigned long )p1 != (unsigned long )((char *)0)) {
       count = 0;
       p = beg;
       while ((int )*p != 0) {
         if ((int )*p == (int )openparen) {
           count ++;
         } else
         if ((int )*p == (int )closeparen) {
           count --;
           if (count < 0) {
             break;
           }
         }
         p ++;
       }
       if (count < 0) {
         beg = expand_argument(beg, p);
         free_beg = 1;
         end = strchr((char const   *)beg, '\000');
       }
     } else {
       p = end;
     }
     colon = lindex((char const   *)beg, (char const   *)end, ':');
     if ((unsigned long )colon != (unsigned long )((char *)0)) {
       subst_beg = colon + 1;
       subst_end = strchr((char const   *)subst_beg, '=');
       if ((unsigned long )subst_end == (unsigned long )((char *)0)) {
         colon = (char *)0;
       } else {
         replace_beg = subst_end + 1;
         replace_end = end;
         v = lookup_variable(beg, (unsigned int )(colon - beg));
         if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
           warn_undefined(beg, (unsigned int )(colon - beg));
         }
         if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
           if ((int )*(v->value) != 0) {
             if (v->recursive) {
               tmp___4 = recursively_expand(v);
               tmp___5 = tmp___4;
             } else {
               tmp___5 = v->value;
             }
             value = tmp___5;
             if (free_beg) {
               *subst_end = (char )'\000';
               pattern = subst_beg;
             } else {
               tmp___6 = __builtin_alloca((unsigned long )((subst_end - subst_beg) + 1L));
               pattern = (char *)tmp___6;
               memmove((void *)pattern, (void const   *)subst_beg, (size_t )(subst_end - subst_beg));
               *(pattern + (subst_end - subst_beg)) = (char )'\000';
             }
             percent = find_percent(pattern);
             if ((unsigned long )percent != (unsigned long )((char *)0)) {
               if (free_beg) {
                 *replace_end = (char )'\000';
                 replace = replace_beg;
               } else {
                 tmp___7 = __builtin_alloca((unsigned long )((replace_end - replace_beg) + 1L));
                 replace = (char *)tmp___7;
                 memmove((void *)replace, (void const   *)replace_beg, (size_t )(replace_end - replace_beg));
                 *(replace + (replace_end - replace_beg)) = (char )'\000';
               }
               o = patsubst_expand(o, value, pattern, replace, percent, (char *)0);
             } else {
               tmp___8 = strlen((char const   *)pattern);
               o = subst_expand(o, value, pattern, replace_beg, (unsigned int )tmp___8,
                                (unsigned int )(end - replace_beg), 0, 1);
             }
             if (v->recursive) {
               free((void *)value);
             }
           }
         }
       }
     }
     if ((unsigned long )colon == (unsigned long )((char *)0)) {
       o = reference_variable(o, beg, (unsigned int )(end - beg));
     }
     if (free_beg) {
       free((void *)beg);
     }
     break;
     case 0: 
     break;
     default: 
     tmp___9 = __ctype_b_loc();
     if ((int const   )*(*tmp___9 + (int )*(p + -1)) & 1) {
       break;
     }
     name[0] = (char )'$';
     name[1] = (char )'(';
     name[2] = *p;
     name[3] = (char )')';
     name[4] = (char )'\000';
     p1 = allocated_variable_expand_for_file(name, (struct file *)0);
     tmp___10 = strlen((char const   *)p1);
     o = variable_buffer_output(o, p1, (unsigned int )tmp___10);
     free((void *)p1);
     break;
     }
     if ((int )*p == 0) {
       break;
     } else {
       p ++;
     }
   }
   if (save_char) {
     *(string + length___0) = save_char;
   }
   variable_buffer_output(o, (char *)"", 1U);
   return (variable_buffer + line_offset);
 }
 }
 char *variable_expand(char *line ) 
 { 
   char *tmp ;
 
   {
   tmp = variable_expand_string((char *)((void *)0), line, -1L);
   return (tmp);
 }
 }
 char *expand_argument(char *str , char *end ) 
 { 
   char *tmp ;
   void *tmp___0 ;
   char *tmp___1 ;
 
   {
   if (! end) {
     tmp = str;
   } else
   if ((int )*end == 0) {
     tmp = str;
   } else {
     tmp___0 = __builtin_alloca((unsigned long )((end - str) + 1L));
     tmp = (char *)tmp___0;
     memmove((void *)tmp, (void const   *)str, (size_t )(end - str));
     *(tmp + (end - str)) = (char )'\000';
   }
   tmp___1 = allocated_variable_expand_for_file(tmp, (struct file *)0);
   return (tmp___1);
 }
 }
 static char *variable_expand_for_file(char *line , struct file *file ) 
 { 
   char *result___0 ;
   struct variable_set_list *save ;
   char *tmp ;
 
   {
   if ((unsigned long )file == (unsigned long )((struct file *)0)) {
     tmp = variable_expand(line);
     return (tmp);
   }
   save = current_variable_set_list;
   current_variable_set_list = file->variables;
   if (file->cmds) {
     if ((file->cmds)->fileinfo.filenm) {
       reading_file = (struct floc  const  *)(& (file->cmds)->fileinfo);
     } else {
       reading_file = (struct floc  const  *)0;
     }
   } else {
     reading_file = (struct floc  const  *)0;
   }
   result___0 = variable_expand(line);
   current_variable_set_list = save;
   reading_file = (struct floc  const  *)0;
   return (result___0);
 }
 }
 static char *allocated_variable_append(struct variable *v ) 
 { 
   struct variable_set_list *save ;
   int len ;
   size_t tmp ;
   char *var ;
   void *tmp___0 ;
   char *value ;
   char *obuf ;
   unsigned int olen ;
   size_t tmp___2 ;
 
   {
   tmp = strlen((char const   *)v->name);
   len = (int )tmp;
   tmp___0 = __builtin_alloca((unsigned long )(len + 4));
   var = (char *)tmp___0;
   obuf = variable_buffer;
   olen = variable_buffer_length;
   variable_buffer = (char *)0;
   if (! ((unsigned long )current_variable_set_list->next != (unsigned long )((struct variable_set_list *)0))) {
     __assert_fail("current_variable_set_list->next != 0", "expand.c", 485U, "allocated_variable_append");
   }
   save = current_variable_set_list;
   current_variable_set_list = current_variable_set_list->next;
   *(var + 0) = (char )'$';
   *(var + 1) = (char )'(';
   strcpy((char * __restrict  )(var + 2), (char const   * __restrict  )v->name);
   *(var + (len + 2)) = (char )')';
   *(var + (len + 3)) = (char )'\000';
   value = variable_expand_for_file(var, (struct file *)0);
   current_variable_set_list = save;
   tmp___2 = strlen((char const   *)value);
   value += tmp___2;
   value = variable_buffer_output(value, (char *)" ", 1U);
   value = variable_expand_string(value, v->value, -1L);
   value = variable_buffer;
   variable_buffer = obuf;
   variable_buffer_length = olen;
   return (value);
 }
 }
 char *allocated_variable_expand_for_file(char *line , struct file *file ) 
 { 
   char *value ;
   char *obuf ;
   unsigned int olen ;
 
   {
   obuf = variable_buffer;
   olen = variable_buffer_length;
   variable_buffer = (char *)0;
   value = variable_expand_for_file(line, file);
   variable_buffer = obuf;
   variable_buffer_length = olen;
   return (value);
 }
 }
 #pragma merger("0","/tmp/cil-lFW07Sp1.i","-g,-O0")
 extern struct _IO_FILE *stderr ;
 extern int fflush(FILE *__stream ) ;
 extern int putchar(int __c ) ;
 extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
 extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                     struct timespec *__tp ) ;
 extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
 int just_print_flag ;
 int silent_flag ;
 int ignore_errors_flag ;
 int question_flag ;
 int touch_flag ;
 int posix_pedantic ;
 int not_parallel ;
 unsigned int num_intermediates ;
 unsigned int considered ;
 void snap_deps(void) ;
 void rename_file(struct file *file , char *name ) ;
 void rehash_file(struct file *file , char *name ) ;
 void file_hash_enter(struct file *file , char *name , unsigned int oldhash , char *oldname ) ;
 uintmax_t file_timestamp_now(void) ;
 void file_timestamp_sprintf(char *p , uintmax_t ts ) ;
 void print_file_variables(struct file *file ) ;
 void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) ;
 int export_all_variables ;
 static struct file *files[1007]  ;
 unsigned int num_intermediates  =    0U;
 unsigned int considered  =    0U;
 struct file *lookup_file(char *name ) 
 { 
   register struct file *f ;
   register char *n ;
   register unsigned int hashval ;
   int tmp___0 ;
 
   {
   if (! ((int )*name != 0)) {
     __assert_fail("*name != \'\\0\'", "file.c", 61U, "lookup_file");
   }
   while (1) {
     if ((int )*(name + 0) == 46) {
       if ((int )*(name + 1) == 47) {
         if (! ((int )*(name + 2) != 0)) {
           break;
         }
       } else {
         break;
       }
     } else {
       break;
     }
     name += 2;
     while ((int )*name == 47) {
       name ++;
     }
   }
   if ((int )*name == 0) {
     name = (char *)"./";
   }
   hashval = 0U;
   n = name;
   while ((int )*n != 0) {
     hashval += (unsigned int )*n;
     hashval = (hashval << 7) + (hashval >> 20);
     n ++;
   }
   hashval %= 1007U;
   f = files[hashval];
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if ((unsigned long )f->hname == (unsigned long )name) {
       return (f);
     } else
     if ((int )*(f->hname) == (int )*name) {
       if ((int )*(f->hname) == 0) {
         return (f);
       } else {
         tmp___0 = strcmp((char const   *)(f->hname + 1), (char const   *)(name + 1));
         if (! tmp___0) {
           return (f);
         }
       }
     }
     f = f->next;
   }
   return ((struct file *)0);
 }
 }
 struct file *enter_file(char *name ) 
 { 
   register struct file *f ;
   register struct file *new ;
   register char *n ;
   register unsigned int hashval ;
   int tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
 
   {
   if (! ((int )*name != 0)) {
     __assert_fail("*name != \'\\0\'", "file.c", 130U, "enter_file");
   }
   hashval = 0U;
   n = name;
   while ((int )*n != 0) {
     hashval += (unsigned int )*n;
     hashval = (hashval << 7) + (hashval >> 20);
     n ++;
   }
   hashval %= 1007U;
   f = files[hashval];
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if ((unsigned long )f->hname == (unsigned long )name) {
       break;
     } else
     if ((int )*(f->hname) == (int )*name) {
       if ((int )*(f->hname) == 0) {
         break;
       } else {
         tmp___0 = strcmp((char const   *)(f->hname + 1), (char const   *)(name + 1));
         if (! tmp___0) {
           break;
         }
       }
     }
     f = f->next;
   }
   if ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if (! f->double_colon) {
       return (f);
     }
   }
   tmp___1 = xmalloc((unsigned int )sizeof(struct file ));
   new = (struct file *)tmp___1;
   memset((void *)((char *)new), 0, sizeof(struct file ));
   tmp___2 = name;
   new->hname = tmp___2;
   new->name = tmp___2;
   new->update_status = (short)-1;
   if ((unsigned long )f == (unsigned long )((struct file *)0)) {
     new->next = files[hashval];
     files[hashval] = new;
   } else {
     new->double_colon = f;
     while ((unsigned long )f->prev != (unsigned long )((struct file *)0)) {
       f = f->prev;
     }
     f->prev = new;
   }
   return (new);
 }
 }
 void rehash_file(struct file *file , char *name ) 
 { 
   char *oldname ;
   register unsigned int oldhash ;
   register char *n ;
 
   {
   oldname = file->hname;
   while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
     file = file->renamed;
   }
   oldhash = 0U;
   n = oldname;
   while ((int )*n != 0) {
     oldhash += (unsigned int )*n;
     oldhash = (oldhash << 7) + (oldhash >> 20);
     n ++;
   }
   file_hash_enter(file, name, oldhash, file->name);
   return;
 }
 }
 void rename_file(struct file *file , char *name ) 
 { 
 
 
   {
   rehash_file(file, name);
   while (file) {
     file->name = file->hname;
     file = file->prev;
   }
   return;
 }
 }
 void file_hash_enter(struct file *file , char *name , unsigned int oldhash , char *oldname ) 
 { 
   unsigned int oldbucket ;
   register unsigned int newhash ;
   register unsigned int newbucket ;
   struct file *oldfile ;
   register char *n ;
   register struct file *f ;
   int tmp ;
   struct file *lastf ;
   register struct dep *d ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
 
   {
   oldbucket = oldhash % 1007U;
   newhash = 0U;
   n = name;
   while ((int )*n != 0) {
     newhash += (unsigned int )*n;
     newhash = (newhash << 7) + (newhash >> 20);
     n ++;
   }
   newbucket = newhash % 1007U;
   oldfile = files[newbucket];
   while ((unsigned long )oldfile != (unsigned long )((struct file *)0)) {
     if ((unsigned long )oldfile->hname == (unsigned long )name) {
       break;
     } else
     if ((int )*(oldfile->hname) == (int )*name) {
       if ((int )*(oldfile->hname) == 0) {
         break;
       } else {
         tmp = strcmp((char const   *)(oldfile->hname + 1), (char const   *)(name + 1));
         if (! tmp) {
           break;
         }
       }
     }
     oldfile = oldfile->next;
   }
   if ((unsigned long )oldfile == (unsigned long )file) {
     return;
   }
   if (oldhash != 0U) {
     if (newbucket != oldbucket) {
       goto _L;
     } else
     if ((unsigned long )oldfile != (unsigned long )((struct file *)0)) {
       _L: /* CIL Label */ 
       lastf = (struct file *)0;
       f = files[oldbucket];
       while ((unsigned long )f != (unsigned long )file) {
         lastf = f;
         f = f->next;
       }
       if ((unsigned long )lastf == (unsigned long )((struct file *)0)) {
         files[oldbucket] = f->next;
       } else {
         lastf->next = f->next;
       }
     }
   }
   file->hname = name;
   f = file->double_colon;
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     f->hname = name;
     f = f->prev;
   }
   if ((unsigned long )oldfile == (unsigned long )((struct file *)0)) {
     if (newbucket != oldbucket) {
       file->next = files[newbucket];
       files[newbucket] = file;
     }
   } else {
     if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
       if ((unsigned long )oldfile->cmds == (unsigned long )((struct commands *)0)) {
         oldfile->cmds = file->cmds;
       } else
       if ((unsigned long )file->cmds != (unsigned long )oldfile->cmds) {
         if ((unsigned long )(oldfile->cmds)->fileinfo.filenm != (unsigned long )((char *)0)) {
           tmp___0 = dcgettext((char const   *)((void *)0), "Commands were specified for file `%s\' at %s:%lu,",
                               5);
           error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___0,
                 oldname, (oldfile->cmds)->fileinfo.filenm, (oldfile->cmds)->fileinfo.lineno);
         } else {
           tmp___1 = dcgettext((char const   *)((void *)0), "Commands for file `%s\' were found by implicit rule search,",
                               5);
           error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___1,
                 oldname);
         }
         tmp___2 = dcgettext((char const   *)((void *)0), "but `%s\' is now considered the same file as `%s\'.",
                             5);
         error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___2,
               oldname, name);
         tmp___3 = dcgettext((char const   *)((void *)0), "Commands for `%s\' will be ignored in favor of those for `%s\'.",
                             5);
         error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___3,
               name, oldname);
       }
     }
     d = oldfile->deps;
     if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
       oldfile->deps = file->deps;
     } else {
       while ((unsigned long )d->next != (unsigned long )((struct dep *)0)) {
         d = d->next;
       }
       d->next = file->deps;
     }
     merge_variable_set_lists(& oldfile->variables, file->variables);
     if (oldfile->double_colon) {
       if (file->is_target) {
         if (! file->double_colon) {
           tmp___4 = dcgettext((char const   *)((void *)0), "can\'t rename single-colon `%s\' to double-colon `%s\'",
                               5);
           fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___4,
                 oldname, name);
         }
       }
     }
     if (! oldfile->double_colon) {
       if (file->double_colon) {
         if (oldfile->is_target) {
           tmp___5 = dcgettext((char const   *)((void *)0), "can\'t rename double-colon `%s\' to single-colon `%s\'",
                               5);
           fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___5,
                 oldname, name);
         } else {
           oldfile->double_colon = file->double_colon;
         }
       }
     }
     if (file->last_mtime > oldfile->last_mtime) {
       oldfile->last_mtime = file->last_mtime;
     }
     oldfile->mtime_before_update = file->mtime_before_update;
     oldfile->precious |= file->precious;
     oldfile->tried_implicit |= file->tried_implicit;
     oldfile->updating |= file->updating;
     oldfile->updated |= file->updated;
     oldfile->is_target |= file->is_target;
     oldfile->cmd_target |= file->cmd_target;
     oldfile->phony |= file->phony;
     oldfile->ignore_vpath |= file->ignore_vpath;
     file->renamed = oldfile;
   }
   return;
 }
 }
 void remove_intermediates(int sig ) 
 { 
   register int i ;
   register struct file *f ;
   char doneany ;
   int status ;
   int *tmp ;
   char *tmp___0 ;
 
   {
   if (question_flag) {
     return;
   } else
   if (touch_flag) {
     return;
   }
   if (sig) {
     if (just_print_flag) {
       return;
     }
   }
   doneany = (char)0;
   i = 0;
   while (i < 1007) {
     f = files[i];
     while ((unsigned long )f != (unsigned long )((struct file *)0)) {
       if (f->intermediate) {
         if (f->dontcare) {
           goto _L;
         } else
         if (! f->precious) {
           _L: /* CIL Label */ 
           if (! f->secondary) {
             if (! f->cmd_target) {
               if ((int )f->update_status == -1) {
                 goto __Cont;
               } else
               if (just_print_flag) {
                 status = 0;
               } else {
                 status = unlink((char const   *)f->name);
                 if (status < 0) {
                   tmp = __errno_location();
                   if (*tmp == 2) {
                     goto __Cont;
                   }
                 }
               }
               if (! f->dontcare) {
                 if (sig) {
                   tmp___0 = dcgettext((char const   *)((void *)0), "*** Deleting intermediate file `%s\'",
                                       5);
                   error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0,
                         f->name);
                 } else
                 if (! silent_flag) {
                   if (! doneany) {
                     fputs((char const   * __restrict  )"rm ", (FILE * __restrict  )stdout);
                     doneany = (char)1;
                   } else {
                     putchar(' ');
                   }
                   fputs((char const   * __restrict  )f->name, (FILE * __restrict  )stdout);
                   fflush(stdout);
                 }
                 if (status < 0) {
                   perror_with_name((char *)"unlink: ", f->name);
                 }
               }
             }
           }
         }
       }
       __Cont: /* CIL Label */ 
       f = f->next;
     }
     i ++;
   }
   if (doneany) {
     if (! sig) {
       putchar('\n');
       fflush(stdout);
     }
   }
   return;
 }
 }
 void snap_deps(void) 
 { 
   register struct file *f ;
   register struct file *f2 ;
   register struct dep *d ;
   register int i ;
   unsigned int tmp ;
   int i___0 ;
   unsigned int tmp___0 ;
 
   {
   i = 0;
   while (i < 1007) {
     f = files[i];
     while ((unsigned long )f != (unsigned long )((struct file *)0)) {
       f2 = f;
       while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
         d = f2->deps;
         while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
           if ((unsigned long )d->name != (unsigned long )((char *)0)) {
             d->file = lookup_file(d->name);
             if ((unsigned long )d->file == (unsigned long )((struct file *)0)) {
               d->file = enter_file(d->name);
             } else {
               free((void *)d->name);
             }
             d->name = (char *)0;
           }
           d = d->next;
         }
         f2 = f2->prev;
       }
       f = f->next;
     }
     i ++;
   }
   f = lookup_file((char *)".PRECIOUS");
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     d = f->deps;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       f2 = d->file;
       while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
         f2->precious = 1U;
         f2 = f2->prev;
       }
       d = d->next;
     }
     f = f->prev;
   }
   f = lookup_file((char *)".PHONY");
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     d = f->deps;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       f2 = d->file;
       while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
         f2->phony = 1U;
         f2->last_mtime = (uintmax_t )-1;
         f2->mtime_before_update = (uintmax_t )-1;
         f2 = f2->prev;
       }
       d = d->next;
     }
     f = f->prev;
   }
   f = lookup_file((char *)".INTERMEDIATE");
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     d = f->deps;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       f2 = d->file;
       while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
         f2->intermediate = 1U;
         f2 = f2->prev;
       }
       d = d->next;
     }
     f = f->prev;
   }
   f = lookup_file((char *)".SECONDARY");
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if (f->deps) {
       d = f->deps;
       while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
         f2 = d->file;
         while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
           tmp = 1U;
           f2->secondary = tmp;
           f2->intermediate = tmp;
           f2 = f2->prev;
         }
         d = d->next;
       }
     } else {
       i___0 = 0;
       while (i___0 < 1007) {
         f2 = files[i___0];
         while (f2) {
           tmp___0 = 1U;
           f2->secondary = tmp___0;
           f2->intermediate = tmp___0;
           f2 = f2->next;
         }
         i___0 ++;
       }
     }
     f = f->prev;
   }
   f = lookup_file((char *)".EXPORT_ALL_VARIABLES");
   if ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if (f->is_target) {
       export_all_variables = 1;
     }
   }
   f = lookup_file((char *)".IGNORE");
   if ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if (f->is_target) {
       if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
         ignore_errors_flag = 1;
       } else {
         d = f->deps;
         while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
           f2 = d->file;
           while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
             f2->command_flags |= 4;
             f2 = f2->prev;
           }
           d = d->next;
         }
       }
     }
   }
   f = lookup_file((char *)".SILENT");
   if ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if (f->is_target) {
       if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
         silent_flag = 1;
       } else {
         d = f->deps;
         while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
           f2 = d->file;
           while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
             f2->command_flags |= 2;
             f2 = f2->prev;
           }
           d = d->next;
         }
       }
     }
   }
   f = lookup_file((char *)".POSIX");
   if ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if (f->is_target) {
       posix_pedantic = 1;
     }
   }
   f = lookup_file((char *)".NOTPARALLEL");
   if ((unsigned long )f != (unsigned long )((struct file *)0)) {
     if (f->is_target) {
       not_parallel = 1;
     }
   }
   return;
 }
 }
 void set_command_state(struct file *file , int state ) 
 { 
   struct dep *d ;
 
   {
   file->command_state = (enum __anonenum_command_state_55 )state;
   d = file->also_make;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     (d->file)->command_state = (enum __anonenum_command_state_55 )state;
     d = d->next;
   }
   return;
 }
 }
 uintmax_t file_timestamp_now(void) 
 { 
   struct timespec timespec ;
   uintmax_t tmp ;
   uintmax_t tmp___0 ;
   int tmp___1 ;
   time_t tmp___2 ;
   uintmax_t tmp___3 ;
   uintmax_t tmp___4 ;
 
   {
   tmp___1 = clock_gettime(0, & timespec);
   if (tmp___1 == 0) {
     if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
       tmp = (uintmax_t )1000000000;
     } else {
       tmp = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
     }
     if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
       tmp___0 = (uintmax_t )1000000000;
     } else {
       tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
     }
     return ((uintmax_t )timespec.tv_sec * tmp + ((uintmax_t )timespec.tv_nsec * tmp___0) / 1000000000UL);
   }
   tmp___2 = time((time_t *)0);
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___3 = (uintmax_t )1000000000;
   } else {
     tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___4 = (uintmax_t )1000000000;
   } else {
     tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   return ((uintmax_t )tmp___2 * tmp___3);
 }
 }
 void file_timestamp_sprintf(char *p , uintmax_t ts ) 
 { 
   time_t t ;
   uintmax_t tmp ;
   uintmax_t tmp___0 ;
   struct tm *tm ;
   struct tm *tmp___1 ;
   size_t tmp___2 ;
   uintmax_t tmp___3 ;
   uintmax_t tmp___4 ;
   uintmax_t tmp___5 ;
   uintmax_t tmp___6 ;
   uintmax_t tmp___7 ;
   size_t tmp___8 ;
 
   {
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp = (uintmax_t )1000000000;
   } else {
     tmp = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___0 = (uintmax_t )1000000000;
   } else {
     tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   t = (time_t )(ts / tmp - (uintmax_t )(ts % tmp___0 < 0UL));
   tmp___1 = localtime((time_t const   *)(& t));
   tm = tmp___1;
   if (tm) {
     sprintf((char * __restrict  )p, (char const   * __restrict  )"%04d-%02d-%02d %02d:%02d:%02d",
             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min,
             tm->tm_sec);
   } else
   if (t < 0L) {
     sprintf((char * __restrict  )p, (char const   * __restrict  )"%ld", t);
   } else {
     sprintf((char * __restrict  )p, (char const   * __restrict  )"%lu", (unsigned long )t);
   }
   tmp___2 = strlen((char const   *)p);
   p += tmp___2;
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___3 = (uintmax_t )1000000000;
   } else {
     tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___4 = (uintmax_t )1000000000;
   } else {
     tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___5 = (uintmax_t )1000000000;
   } else {
     tmp___5 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___6 = (uintmax_t )1000000000;
   } else {
     tmp___6 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___7 = (uintmax_t )1000000000;
   } else {
     tmp___7 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   sprintf((char * __restrict  )p, (char const   * __restrict  )".%09ld", (long )(((ts % tmp___3 + (uintmax_t )(ts % tmp___4 < 0UL) * tmp___5) * 1000000000UL + (tmp___6 - 1UL)) / tmp___7));
   tmp___8 = strlen((char const   *)p);
   p += tmp___8 - 1UL;
   while ((int )*p == 48) {
     p --;
   }
   p += (int )*p != 46;
   *p = (char )'\000';
   return;
 }
 }
 static void print_file(struct file *f ) 
 { 
   register struct dep *d ;
   char *tmp ;
   char const   *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   char *tmp___9 ;
   char *tmp___10 ;
   char *tmp___11 ;
   char *tmp___12 ;
   char *tmp___13 ;
   char *tmp___14 ;
   char buf___1[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;
   char *tmp___15 ;
   char *tmp___16 ;
   char *tmp___17 ;
   char *tmp___18 ;
   char *tmp___19 ;
   char *tmp___20 ;
   char *tmp___21 ;
   char *tmp___23 ;
   char *tmp___24 ;
   char *tmp___25 ;
   char *tmp___26 ;
 
   {
   putchar('\n');
   if (! f->is_target) {
     tmp = dcgettext((char const   *)((void *)0), "# Not a target:", 5);
     puts((char const   *)tmp);
   }
   if (f->double_colon) {
     tmp___0 = ":";
   } else {
     tmp___0 = "";
   }
   printf((char const   * __restrict  )"%s:%s", f->name, tmp___0);
   d = f->deps;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )d->name == (unsigned long )((char *)0)) {
       tmp___1 = (d->file)->name;
     } else {
       tmp___1 = d->name;
     }
     printf((char const   * __restrict  )" %s", tmp___1);
     d = d->next;
   }
   putchar('\n');
   if (f->precious) {
     tmp___2 = dcgettext((char const   *)((void *)0), "#  Precious file (prerequisite of .PRECIOUS).",
                         5);
     puts((char const   *)tmp___2);
   }
   if (f->phony) {
     tmp___3 = dcgettext((char const   *)((void *)0), "#  Phony target (prerequisite of .PHONY).",
                         5);
     puts((char const   *)tmp___3);
   }
   if (f->cmd_target) {
     tmp___4 = dcgettext((char const   *)((void *)0), "#  Command-line target.", 5);
     puts((char const   *)tmp___4);
   }
   if (f->dontcare) {
     tmp___5 = dcgettext((char const   *)((void *)0), "#  A default or MAKEFILES makefile.",
                         5);
     puts((char const   *)tmp___5);
   }
   if (f->tried_implicit) {
     tmp___6 = dcgettext((char const   *)((void *)0), "#  Implicit rule search has been done.",
                         5);
     tmp___8 = tmp___6;
   } else {
     tmp___7 = dcgettext((char const   *)((void *)0), "#  Implicit rule search has not been done.",
                         5);
     tmp___8 = tmp___7;
   }
   puts((char const   *)tmp___8);
   if ((unsigned long )f->stem != (unsigned long )((char *)0)) {
     tmp___9 = dcgettext((char const   *)((void *)0), "#  Implicit/static pattern stem: `%s\'\n",
                         5);
     printf((char const   * __restrict  )tmp___9, f->stem);
   }
   if (f->intermediate) {
     tmp___10 = dcgettext((char const   *)((void *)0), "#  File is an intermediate prerequisite.",
                          5);
     puts((char const   *)tmp___10);
   }
   if ((unsigned long )f->also_make != (unsigned long )((struct dep *)0)) {
     tmp___11 = dcgettext((char const   *)((void *)0), "#  Also makes:", 5);
     fputs((char const   * __restrict  )tmp___11, (FILE * __restrict  )stdout);
     d = f->also_make;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
         tmp___12 = (d->file)->name;
       } else {
         tmp___12 = d->name;
       }
       printf((char const   * __restrict  )" %s", tmp___12);
       d = d->next;
     }
     putchar('\n');
   }
   if (f->last_mtime == 0UL) {
     tmp___13 = dcgettext((char const   *)((void *)0), "#  Modification time never checked.",
                          5);
     puts((char const   *)tmp___13);
   } else
   if (f->last_mtime == 0xffffffffffffffffUL) {
     tmp___14 = dcgettext((char const   *)((void *)0), "#  File does not exist.", 5);
     puts((char const   *)tmp___14);
   } else {
     file_timestamp_sprintf(buf___1, f->last_mtime);
     tmp___15 = dcgettext((char const   *)((void *)0), "#  Last modified %s\n", 5);
     printf((char const   * __restrict  )tmp___15, buf___1);
   }
   if (f->updated) {
     tmp___16 = dcgettext((char const   *)((void *)0), "#  File has been updated.",
                          5);
     tmp___18 = tmp___16;
   } else {
     tmp___17 = dcgettext((char const   *)((void *)0), "#  File has not been updated.",
                          5);
     tmp___18 = tmp___17;
   }
   puts((char const   *)tmp___18);
   switch ((unsigned int )f->command_state) {
   case 2U: 
   tmp___19 = dcgettext((char const   *)((void *)0), "#  Commands currently running (THIS IS A BUG).",
                        5);
   puts((char const   *)tmp___19);
   break;
   case 1U: 
   tmp___20 = dcgettext((char const   *)((void *)0), "#  Dependencies commands running (THIS IS A BUG).",
                        5);
   puts((char const   *)tmp___20);
   break;
   case 3U: 
   case 0U: 
   switch ((int )f->update_status) {
   case -1: 
   break;
   case 0: 
   tmp___21 = dcgettext((char const   *)((void *)0), "#  Successfully updated.", 5);
   puts((char const   *)tmp___21);
   break;
   case 1: 
   if (! question_flag) {
     __assert_fail("question_flag", "file.c", 681U, "print_file");
   }
   tmp___23 = dcgettext((char const   *)((void *)0), "#  Needs to be updated (-q is set).",
                        5);
   puts((char const   *)tmp___23);
   break;
   case 2: 
   tmp___24 = dcgettext((char const   *)((void *)0), "#  Failed to be updated.", 5);
   puts((char const   *)tmp___24);
   break;
   default: 
   tmp___25 = dcgettext((char const   *)((void *)0), "#  Invalid value in `update_status\' member!",
                        5);
   puts((char const   *)tmp___25);
   fflush(stdout);
   fflush(stderr);
   abort();
   }
   break;
   default: 
   tmp___26 = dcgettext((char const   *)((void *)0), "#  Invalid value in `command_state\' member!",
                        5);
   puts((char const   *)tmp___26);
   fflush(stdout);
   fflush(stderr);
   abort();
   }
   if ((unsigned long )f->variables != (unsigned long )((struct variable_set_list *)0)) {
     print_file_variables(f);
   }
   if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
     print_commands(f->cmds);
   }
   return;
 }
 }
 void print_file_data_base(void) 
 { 
   register unsigned int i ;
   register unsigned int nfiles ;
   register unsigned int per_bucket ;
   register struct file *file ;
   char *tmp ;
   register unsigned int this_bucket ;
   register struct file *f ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
 
   {
   tmp = dcgettext((char const   *)((void *)0), "\n# Files", 5);
   puts((char const   *)tmp);
   nfiles = 0U;
   per_bucket = nfiles;
   i = 0U;
   while (i < 1007U) {
     this_bucket = 0U;
     file = files[i];
     while ((unsigned long )file != (unsigned long )((struct file *)0)) {
       this_bucket ++;
       f = file;
       while ((unsigned long )f != (unsigned long )((struct file *)0)) {
         print_file(f);
         f = f->prev;
       }
       file = file->next;
     }
     nfiles += this_bucket;
     if (this_bucket > per_bucket) {
       per_bucket = this_bucket;
     }
     i ++;
   }
   if (nfiles == 0U) {
     tmp___0 = dcgettext((char const   *)((void *)0), "\n# No files.", 5);
     puts((char const   *)tmp___0);
   } else {
     tmp___1 = dcgettext((char const   *)((void *)0), "\n# %u files in %u hash buckets.\n",
                         5);
     printf((char const   * __restrict  )tmp___1, nfiles, 1007);
     tmp___2 = dcgettext((char const   *)((void *)0), "# average %.3f files per bucket, max %u files in one bucket.\n",
                         5);
     printf((char const   * __restrict  )tmp___2, (double )nfiles / (double )1007,
            per_bucket);
   }
   return;
 }
 }
 #pragma merger("0","/tmp/cil-xaw3DgWu.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
 extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
 char *find_next_token(char **ptr , unsigned int *lengthptr ) ;
 char *next_token(char *s ) ;
 char *end_of_token(char *s ) ;
 extern char **environ ;
 int pattern_matches(char *pattern , char *percent , char *str ) ;
 struct variable_set_list *push_new_variable_scope(void) ;
 void pop_variable_scope(void) ;
 struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) ;
 struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                                int strip ) ;
 char **construct_command_argv(char *line , char **restp , struct file *file , char **batch_filename_ptr ) ;
 void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) ;
 int db_level ;
 char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                    unsigned int rlen , int by_word , int suffix_only ) 
 { 
   register char *t ;
   register char *p ;
   size_t tmp ;
   char *tmp___0 ;
   size_t tmp___1 ;
   unsigned short const   **tmp___2 ;
   unsigned short const   **tmp___3 ;
   unsigned short const   **tmp___4 ;
 
   {
   t = text;
   if (slen == 0U) {
     if (! by_word) {
       if (! suffix_only) {
         tmp = strlen((char const   *)t);
         o = variable_buffer_output(o, t, (unsigned int )tmp);
         if (rlen > 0U) {
           o = variable_buffer_output(o, replace, rlen);
         }
         return (o);
       }
     }
   }
   while (1) {
     if (by_word | suffix_only) {
       if (slen == 0U) {
         tmp___0 = next_token(t);
         p = end_of_token(tmp___0);
       } else {
         goto _L;
       }
     } else {
       _L: /* CIL Label */ 
       p = sindex((char const   *)t, 0U, (char const   *)subst, slen);
       if ((unsigned long )p == (unsigned long )((char *)0)) {
         tmp___1 = strlen((char const   *)t);
         o = variable_buffer_output(o, t, (unsigned int )tmp___1);
         return (o);
       }
     }
     if ((unsigned long )p > (unsigned long )t) {
       o = variable_buffer_output(o, t, (unsigned int )(p - t));
     }
     if (by_word) {
       if ((unsigned long )p > (unsigned long )t) {
         tmp___2 = __ctype_b_loc();
         if ((int const   )*(*tmp___2 + (int )*(p + -1)) & 1) {
           goto _L___2;
         } else {
           o = variable_buffer_output(o, subst, slen);
         }
       } else
       _L___2: /* CIL Label */ 
       if ((int )*(p + slen) != 0) {
         tmp___3 = __ctype_b_loc();
         if ((int const   )*(*tmp___3 + (int )*(p + slen)) & 1) {
           goto _L___1;
         } else {
           o = variable_buffer_output(o, subst, slen);
         }
       } else {
         goto _L___1;
       }
     } else
     _L___1: /* CIL Label */ 
     if (suffix_only) {
       if ((int )*(p + slen) != 0) {
         tmp___4 = __ctype_b_loc();
         if ((int const   )*(*tmp___4 + (int )*(p + slen)) & 1) {
           goto _L___0;
         } else {
           o = variable_buffer_output(o, subst, slen);
         }
       } else {
         goto _L___0;
       }
     } else
     _L___0: /* CIL Label */ 
     if (rlen > 0U) {
       o = variable_buffer_output(o, replace, rlen);
     }
     t = p + slen;
     if (! ((int )*t != 0)) {
       break;
     }
   }
   return (o);
 }
 }
 char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                       char *replace_percent ) 
 { 
   unsigned int pattern_prepercent_len ;
   unsigned int pattern_postpercent_len ;
   unsigned int replace_prepercent_len ;
   unsigned int replace_postpercent_len ;
   char *t ;
   int len ;
   int doneany ;
   size_t tmp ;
   size_t tmp___0 ;
   size_t tmp___1 ;
   size_t tmp___2 ;
   char *tmp___3 ;
   size_t tmp___4 ;
   int fail ;
   int tmp___5 ;
   int tmp___6 ;
 
   {
   replace_postpercent_len = 0U;
   doneany = 0;
   if ((unsigned long )replace_percent == (unsigned long )((char *)0)) {
     replace_percent = find_percent(replace);
   }
   if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
     replace_prepercent_len = (unsigned int )(replace_percent - replace);
     tmp = strlen((char const   *)(replace_percent + 1));
     replace_postpercent_len = (unsigned int )tmp;
   } else {
     tmp___0 = strlen((char const   *)replace);
     replace_prepercent_len = (unsigned int )tmp___0;
   }
   if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
     pattern_percent = find_percent(pattern);
   }
   if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
     tmp___1 = strlen((char const   *)replace);
     tmp___2 = strlen((char const   *)pattern);
     tmp___3 = subst_expand(o, text, pattern, replace, (unsigned int )tmp___2, (unsigned int )tmp___1,
                            1, 0);
     return (tmp___3);
   }
   pattern_prepercent_len = (unsigned int )(pattern_percent - pattern);
   tmp___4 = strlen((char const   *)(pattern_percent + 1));
   pattern_postpercent_len = (unsigned int )tmp___4;
   while (1) {
     t = find_next_token(& text, (unsigned int *)(& len));
     if (! ((unsigned long )t != (unsigned long )((char *)0))) {
       break;
     }
     fail = 0;
     if ((unsigned int )len < pattern_prepercent_len + pattern_postpercent_len) {
       fail = 1;
     }
     if (! fail) {
       if (pattern_prepercent_len > 0U) {
         if ((int )*t != (int )*pattern) {
           fail = 1;
         } else
         if ((int )*(t + (pattern_prepercent_len - 1U)) != (int )*(pattern_percent + -1)) {
           fail = 1;
         } else {
           tmp___5 = strncmp((char const   *)(t + 1), (char const   *)(pattern + 1),
                             (size_t )(pattern_prepercent_len - 1U));
           if (! (tmp___5 == 0)) {
             fail = 1;
           }
         }
       }
     }
     if (! fail) {
       if (pattern_postpercent_len > 0U) {
         if ((int )*(t + (len - 1)) != (int )*(pattern_percent + pattern_postpercent_len)) {
           fail = 1;
         } else
         if ((int )*(t + ((unsigned int )len - pattern_postpercent_len)) != (int )*(pattern_percent + 1)) {
           fail = 1;
         } else {
           tmp___6 = strncmp((char const   *)(t + ((unsigned int )len - pattern_postpercent_len)),
                             (char const   *)(pattern_percent + 1), (size_t )(pattern_postpercent_len - 1U));
           if (! (tmp___6 == 0)) {
             fail = 1;
           }
         }
       }
     }
     if (fail) {
       o = variable_buffer_output(o, t, (unsigned int )len);
     } else {
       o = variable_buffer_output(o, replace, replace_prepercent_len);
       if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
         o = variable_buffer_output(o, t + pattern_prepercent_len, (unsigned int )len - (pattern_prepercent_len + pattern_postpercent_len));
         o = variable_buffer_output(o, replace_percent + 1, replace_postpercent_len);
       }
     }
     if (fail) {
       o = variable_buffer_output(o, (char *)" ", 1U);
       doneany = 1;
     } else
     if (replace_prepercent_len > 0U) {
       o = variable_buffer_output(o, (char *)" ", 1U);
       doneany = 1;
     } else
     if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
       if ((unsigned int )len + replace_postpercent_len > 0U) {
         o = variable_buffer_output(o, (char *)" ", 1U);
         doneany = 1;
       }
     }
   }
   if (doneany) {
     o --;
   }
   return (o);
 }
 }
 static struct function_table_entry  const  *lookup_function(struct function_table_entry  const  *table ,
                                                             char const   *s ) 
 { 
   int len ;
   size_t tmp ;
   unsigned short const   **tmp___0 ;
   int tmp___1 ;
 
   {
   tmp = strlen(s);
   len = (int )tmp;
   while ((unsigned long )table->name != (unsigned long )((void *)0)) {
     if ((int const   )table->len <= (int const   )len) {
       tmp___0 = __ctype_b_loc();
       if ((int const   )*(*tmp___0 + (int )*(s + table->len)) & 1) {
         goto _L;
       } else
       if ((int const   )*(s + table->len) == 0) {
         _L: /* CIL Label */ 
         tmp___1 = strncmp(s, (char const   *)table->name, (size_t )table->len);
         if (tmp___1 == 0) {
           return (table);
         }
       }
     }
     table ++;
   }
   return ((struct function_table_entry  const  *)((void *)0));
 }
 }
 int pattern_matches(char *pattern , char *percent , char *str ) 
 { 
   unsigned int sfxlen ;
   unsigned int strlength ;
   unsigned int len ;
   size_t tmp ;
   char *new_chars ;
   void *tmp___0 ;
   int tmp___1 ;
   int tmp___2 ;
   size_t tmp___3 ;
   size_t tmp___4 ;
   int tmp___5 ;
   int tmp___6 ;
   int tmp___7 ;
 
   {
   if ((unsigned long )percent == (unsigned long )((char *)0)) {
     tmp = strlen((char const   *)pattern);
     len = (unsigned int )(tmp + 1UL);
     tmp___0 = __builtin_alloca((unsigned long )len);
     new_chars = (char *)tmp___0;
     memmove((void *)new_chars, (void const   *)pattern, (size_t )len);
     pattern = new_chars;
     percent = find_percent(pattern);
     if ((unsigned long )percent == (unsigned long )((char *)0)) {
       if ((unsigned long )pattern == (unsigned long )str) {
         tmp___2 = 1;
       } else
       if ((int )*pattern == (int )*str) {
         if ((int )*pattern == 0) {
           tmp___2 = 1;
         } else {
           tmp___1 = strcmp((char const   *)(pattern + 1), (char const   *)(str + 1));
           if (tmp___1) {
             tmp___2 = 0;
           } else {
             tmp___2 = 1;
           }
         }
       } else {
         tmp___2 = 0;
       }
       return (tmp___2);
     }
   }
   tmp___3 = strlen((char const   *)(percent + 1));
   sfxlen = (unsigned int )tmp___3;
   tmp___4 = strlen((char const   *)str);
   strlength = (unsigned int )tmp___4;
   if ((long )strlength < (percent - pattern) + (long )sfxlen) {
     return (0);
   } else {
     tmp___5 = strncmp((char const   *)pattern, (char const   *)str, (size_t )(percent - pattern));
     if (! (tmp___5 == 0)) {
       return (0);
     }
   }
   tmp___6 = strcmp((char const   *)(percent + 1), (char const   *)(str + (strlength - sfxlen)));
   if (tmp___6) {
     tmp___7 = 0;
   } else {
     tmp___7 = 1;
   }
   return (tmp___7);
 }
 }
 static char *find_next_argument(char startparen , char endparen , char const   *ptr ,
                                 char const   *end ) 
 { 
   int count ;
 
   {
   count = 0;
   while ((unsigned long )ptr < (unsigned long )end) {
     if ((int const   )*ptr == (int const   )startparen) {
       count ++;
     } else
     if ((int const   )*ptr == (int const   )endparen) {
       count --;
       if (count < 0) {
         return ((char *)((void *)0));
       }
     } else
     if ((int const   )*ptr == 44) {
       if (! count) {
         return ((char *)ptr);
       }
     }
     ptr ++;
   }
   return ((char *)((void *)0));
 }
 }
 static char *string_glob(char *line ) ;
 static char *result  =    (char *)0;
 static unsigned int length  ;
 static char *string_glob(char *line ) 
 { 
   register struct nameseq *chain ;
   register unsigned int idx ;
   struct nameseq *tmp ;
   char *tmp___0 ;
   register char *name ;
   unsigned int len ;
   size_t tmp___1 ;
   struct nameseq *next ;
   char *tmp___2 ;
   unsigned int tmp___3 ;
   int tmp___4 ;
 
   {
   tmp = parse_file_seq(& line, '\000', (unsigned int )sizeof(struct nameseq ), 0);
   chain = multi_glob(tmp, (unsigned int )sizeof(struct nameseq ));
   if ((unsigned long )result == (unsigned long )((char *)0)) {
     length = 100U;
     tmp___0 = xmalloc(100U);
     result = tmp___0;
   }
   idx = 0U;
   while ((unsigned long )chain != (unsigned long )((struct nameseq *)0)) {
     name = chain->name;
     tmp___1 = strlen((char const   *)name);
     len = (unsigned int )tmp___1;
     next = chain->next;
     free((void *)((char *)chain));
     chain = next;
     tmp___4 = file_exists_p(name);
     if (tmp___4) {
       if ((idx + len) + 1U > length) {
         length += (len + 1U) * 2U;
         tmp___2 = xrealloc(result, length);
         result = tmp___2;
       }
       memmove((void *)(result + idx), (void const   *)name, (size_t )len);
       idx += len;
       tmp___3 = idx;
       idx ++;
       *(result + tmp___3) = (char )' ';
     }
     free((void *)name);
   }
   if (idx == 0U) {
     *(result + 0) = (char )'\000';
   } else {
     *(result + (idx - 1U)) = (char )'\000';
   }
   return (result);
 }
 }
 static char *func_patsubst(char *o , char **argv , char const   *funcname ) 
 { 
 
 
   {
   o = patsubst_expand(o, *(argv + 2), *(argv + 0), *(argv + 1), (char *)0, (char *)0);
   return (o);
 }
 }
 static char *func_join(char *o , char **argv , char const   *funcname ) 
 { 
   int doneany ;
   register char *tp ;
   register char *pp ;
   char *list1_iterator ;
   char *list2_iterator ;
   unsigned int len1 ;
   unsigned int len2 ;
 
   {
   doneany = 0;
   list1_iterator = *(argv + 0);
   list2_iterator = *(argv + 1);
   while (1) {
     tp = find_next_token(& list1_iterator, & len1);
     if ((unsigned long )tp != (unsigned long )((char *)0)) {
       o = variable_buffer_output(o, tp, len1);
     }
     pp = find_next_token(& list2_iterator, & len2);
     if ((unsigned long )pp != (unsigned long )((char *)0)) {
       o = variable_buffer_output(o, pp, len2);
     }
     if ((unsigned long )tp != (unsigned long )((char *)0)) {
       o = variable_buffer_output(o, (char *)" ", 1U);
       doneany = 1;
     } else
     if ((unsigned long )pp != (unsigned long )((char *)0)) {
       o = variable_buffer_output(o, (char *)" ", 1U);
       doneany = 1;
     }
     if (! ((unsigned long )tp != (unsigned long )((char *)0))) {
       if (! ((unsigned long )pp != (unsigned long )((char *)0))) {
         break;
       }
     }
   }
   if (doneany) {
     o --;
   }
   return (o);
 }
 }
 static char *func_origin(char *o , char **argv , char const   *funcname ) 
 { 
   register struct variable *v ;
   size_t tmp ;
   struct variable *tmp___0 ;
 
   {
   tmp = strlen((char const   *)*(argv + 0));
   tmp___0 = lookup_variable(*(argv + 0), (unsigned int )tmp);
   v = tmp___0;
   if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
     o = variable_buffer_output(o, (char *)"undefined", 9U);
   } else {
     switch ((unsigned int )v->origin) {
     default: 
     abort();
     break;
     case 0U: 
     o = variable_buffer_output(o, (char *)"default", 7U);
     break;
     case 1U: 
     o = variable_buffer_output(o, (char *)"environment", 11U);
     break;
     case 2U: 
     o = variable_buffer_output(o, (char *)"file", 4U);
     break;
     case 3U: 
     o = variable_buffer_output(o, (char *)"environment override", 20U);
     break;
     case 4U: 
     o = variable_buffer_output(o, (char *)"command line", 12U);
     break;
     case 5U: 
     o = variable_buffer_output(o, (char *)"override", 8U);
     break;
     case 6U: 
     o = variable_buffer_output(o, (char *)"automatic", 9U);
     break;
     }
   }
   return (o);
 }
 }
 static char *func_notdir_suffix(char *o , char **argv , char const   *funcname ) 
 { 
   char *list_iterator ;
   char *p2 ;
   int doneany ;
   unsigned int len ;
   int is_suffix ;
   int tmp ;
   int tmp___0 ;
   int is_notdir ;
   char *p ;
 
   {
   list_iterator = *(argv + 0);
   p2 = (char *)0;
   doneany = 0;
   len = 0U;
   if ((unsigned long )funcname == (unsigned long )"suffix") {
     tmp___0 = 1;
   } else
   if ((int const   )*funcname == (int const   )*"suffix") {
     if ((int const   )*funcname == 0) {
       tmp___0 = 1;
     } else {
       tmp = strcmp(funcname + 1, "suffix" + 1);
       if (tmp) {
         tmp___0 = 0;
       } else {
         tmp___0 = 1;
       }
     }
   } else {
     tmp___0 = 0;
   }
   is_suffix = tmp___0;
   is_notdir = ! is_suffix;
   while (1) {
     p2 = find_next_token(& list_iterator, & len);
     if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
       break;
     }
     p = p2 + len;
     while (1) {
       if ((unsigned long )p >= (unsigned long )p2) {
         if (! (! is_suffix)) {
           if (! ((int )*p != 46)) {
             break;
           }
         }
       } else {
         break;
       }
       if ((int )*p == 47) {
         break;
       }
       p --;
     }
     if ((unsigned long )p >= (unsigned long )p2) {
       if (is_notdir) {
         p ++;
       } else
       if ((int )*p != 46) {
         continue;
       }
       o = variable_buffer_output(o, p, (unsigned int )((long )len - (p - p2)));
     } else
     if (is_notdir) {
       o = variable_buffer_output(o, p2, len);
     }
     if (is_notdir) {
       o = variable_buffer_output(o, (char *)" ", 1U);
       doneany = 1;
     } else
     if ((unsigned long )p >= (unsigned long )p2) {
       o = variable_buffer_output(o, (char *)" ", 1U);
       doneany = 1;
     }
   }
   if (doneany) {
     o --;
   }
   return (o);
 }
 }
 static char *func_basename_dir(char *o , char **argv , char const   *funcname ) 
 { 
   char *p3 ;
   char *p2 ;
   int doneany ;
   unsigned int len ;
   char *p ;
   int is_basename ;
   int tmp ;
   int tmp___0 ;
   int is_dir ;
 
   {
   p3 = *(argv + 0);
   p2 = (char *)0;
   doneany = 0;
   len = 0U;
   p = (char *)0;
   if ((unsigned long )funcname == (unsigned long )"basename") {
     tmp___0 = 1;
   } else
   if ((int const   )*funcname == (int const   )*"basename") {
     if ((int const   )*funcname == 0) {
       tmp___0 = 1;
     } else {
       tmp = strcmp(funcname + 1, "basename" + 1);
       if (tmp) {
         tmp___0 = 0;
       } else {
         tmp___0 = 1;
       }
     }
   } else {
     tmp___0 = 0;
   }
   is_basename = tmp___0;
   is_dir = ! is_basename;
   while (1) {
     p2 = find_next_token(& p3, & len);
     if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
       break;
     }
     p = p2 + len;
     while (1) {
       if ((unsigned long )p >= (unsigned long )p2) {
         if (! (! is_basename)) {
           if (! ((int )*p != 46)) {
             break;
           }
         }
       } else {
         break;
       }
       if ((int )*p == 47) {
         break;
       }
       p --;
     }
     if ((unsigned long )p >= (unsigned long )p2) {
       if (is_dir) {
         p ++;
         o = variable_buffer_output(o, p2, (unsigned int )(p - p2));
       } else {
         goto _L___0;
       }
     } else
     _L___0: /* CIL Label */ 
     if ((unsigned long )p >= (unsigned long )p2) {
       if ((int )*p == 46) {
         o = variable_buffer_output(o, p2, (unsigned int )(p - p2));
       } else {
         goto _L;
       }
     } else
     _L: /* CIL Label */ 
     if (is_dir) {
       o = variable_buffer_output(o, (char *)"./", 2U);
     } else {
       o = variable_buffer_output(o, p2, len);
     }
     o = variable_buffer_output(o, (char *)" ", 1U);
     doneany = 1;
   }
   if (doneany) {
     o --;
   }
   return (o);
 }
 }
 static char *func_addsuffix_addprefix(char *o , char **argv , char const   *funcname ) 
 { 
   int fixlen ;
   size_t tmp ;
   char *list_iterator ;
   int is_addprefix ;
   int tmp___0 ;
   int tmp___1 ;
   int is_addsuffix ;
   int doneany ;
   char *p ;
   unsigned int len ;
 
   {
   tmp = strlen((char const   *)*(argv + 0));
   fixlen = (int )tmp;
   list_iterator = *(argv + 1);
   if ((unsigned long )funcname == (unsigned long )"addprefix") {
     tmp___1 = 1;
   } else
   if ((int const   )*funcname == (int const   )*"addprefix") {
     if ((int const   )*funcname == 0) {
       tmp___1 = 1;
     } else {
       tmp___0 = strcmp(funcname + 1, "addprefix" + 1);
       if (tmp___0) {
         tmp___1 = 0;
       } else {
         tmp___1 = 1;
       }
     }
   } else {
     tmp___1 = 0;
   }
   is_addprefix = tmp___1;
   is_addsuffix = ! is_addprefix;
   doneany = 0;
   while (1) {
     p = find_next_token(& list_iterator, & len);
     if (! ((unsigned long )p != (unsigned long )((char *)0))) {
       break;
     }
     if (is_addprefix) {
       o = variable_buffer_output(o, *(argv + 0), (unsigned int )fixlen);
     }
     o = variable_buffer_output(o, p, len);
     if (is_addsuffix) {
       o = variable_buffer_output(o, *(argv + 0), (unsigned int )fixlen);
     }
     o = variable_buffer_output(o, (char *)" ", 1U);
     doneany = 1;
   }
   if (doneany) {
     o --;
   }
   return (o);
 }
 }
 static char *func_subst(char *o , char **argv , char const   *funcname ) 
 { 
   size_t tmp ;
   size_t tmp___0 ;
 
   {
   tmp = strlen((char const   *)*(argv + 1));
   tmp___0 = strlen((char const   *)*(argv + 0));
   o = subst_expand(o, *(argv + 2), *(argv + 0), *(argv + 1), (unsigned int )tmp___0,
                    (unsigned int )tmp, 0, 0);
   return (o);
 }
 }
 static char *func_firstword(char *o , char **argv , char const   *funcname ) 
 { 
   unsigned int i ;
   char *words ;
   char *p ;
   char *tmp ;
 
   {
   words = *(argv + 0);
   tmp = find_next_token(& words, & i);
   p = tmp;
   if ((unsigned long )p != (unsigned long )((char *)0)) {
     o = variable_buffer_output(o, p, i);
   }
   return (o);
 }
 }
 static char *func_words(char *o , char **argv , char const   *funcname ) 
 { 
   int i ;
   char *word_iterator ;
   char buf___1[20] ;
   char *tmp ;
   size_t tmp___0 ;
 
   {
   i = 0;
   word_iterator = *(argv + 0);
   while (1) {
     tmp = find_next_token(& word_iterator, (unsigned int *)0);
     if (! ((unsigned long )tmp != (unsigned long )((char *)0))) {
       break;
     }
     i ++;
   }
   sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%d", i);
   tmp___0 = strlen((char const   *)(buf___1));
   o = variable_buffer_output(o, buf___1, (unsigned int )tmp___0);
   return (o);
 }
 }
 char *strip_whitespace(char **begpp , char **endpp ) 
 { 
   unsigned short const   **tmp ;
   unsigned short const   **tmp___0 ;
 
   {
   while (1) {
     tmp = __ctype_b_loc();
     if ((int const   )*(*tmp + (int )((unsigned char )*(*begpp))) & 8192) {
       if (! ((unsigned long )*begpp <= (unsigned long )*endpp)) {
         break;
       }
     } else {
       break;
     }
     (*begpp) ++;
   }
   while (1) {
     tmp___0 = __ctype_b_loc();
     if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*endpp))) & 8192) {
       if (! ((unsigned long )*endpp >= (unsigned long )*begpp)) {
         break;
       }
     } else {
       break;
     }
     (*endpp) --;
   }
   return (*begpp);
 }
 }
 int is_numeric(char *p ) 
 { 
   char *end ;
   size_t tmp ;
   char *beg ;
   char *tmp___0 ;
 
   {
   tmp = strlen((char const   *)p);
   end = (p + tmp) - 1;
   beg = p;
   strip_whitespace(& p, & end);
   while ((unsigned long )p <= (unsigned long )end) {
     tmp___0 = p;
     p ++;
     if (! ((unsigned int )*tmp___0 - 48U <= 9U)) {
       return (0);
     }
   }
   return (end - beg >= 0L);
 }
 }
 void check_numeric(char *s , char *message___0 ) 
 { 
   int tmp ;
 
   {
   tmp = is_numeric(s);
   if (! tmp) {
     fatal(reading_file, (char const   *)message___0);
   }
   return;
 }
 }
 static char *func_word(char *o , char **argv , char const   *funcname ) 
 { 
   char *end_p ;
   int i ;
   char *p ;
   char *tmp ;
   char *tmp___0 ;
 
   {
   end_p = (char *)0;
   i = 0;
   p = (char *)0;
   tmp = dcgettext((char const   *)((void *)0), "non-numeric first argument to `word\' function",
                   5);
   check_numeric(*(argv + 0), tmp);
   i = atoi((char const   *)*(argv + 0));
   if (i == 0) {
     tmp___0 = dcgettext((char const   *)((void *)0), "the `word\' function takes a positive index argument",
                         5);
     fatal(reading_file, (char const   *)tmp___0);
   }
   end_p = *(argv + 1);
   while (1) {
     p = find_next_token(& end_p, (unsigned int *)0);
     if (! ((unsigned long )p != (unsigned long )((char *)0))) {
       break;
     }
     i --;
     if (i == 0) {
       break;
     }
   }
   if (i == 0) {
     o = variable_buffer_output(o, p, (unsigned int )(end_p - p));
   }
   return (o);
 }
 }
 static char *func_wordlist(char *o , char **argv , char const   *funcname ) 
 { 
   int start ;
   int count ;
   char *tmp ;
   char *tmp___0 ;
   int tmp___1 ;
   char *p ;
   char *end_p ;
   char *tmp___2 ;
 
   {
   tmp = dcgettext((char const   *)((void *)0), "non-numeric first argument to `wordlist\' function",
                   5);
   check_numeric(*(argv + 0), tmp);
   tmp___0 = dcgettext((char const   *)((void *)0), "non-numeric second argument to `wordlist\' function",
                       5);
   check_numeric(*(argv + 1), tmp___0);
   start = atoi((char const   *)*(argv + 0));
   tmp___1 = atoi((char const   *)*(argv + 1));
   count = (tmp___1 - start) + 1;
   if (count > 0) {
     end_p = *(argv + 2);
     while (1) {
       p = find_next_token(& end_p, (unsigned int *)0);
       if ((unsigned long )p != (unsigned long )((char *)0)) {
         start --;
         if (! start) {
           break;
         }
       } else {
         break;
       }
     }
     if (p) {
       while (1) {
         count --;
         if (count) {
           tmp___2 = find_next_token(& end_p, (unsigned int *)0);
           if (! ((unsigned long )tmp___2 != (unsigned long )((char *)0))) {
             break;
           }
         } else {
           break;
         }
       }
       o = variable_buffer_output(o, p, (unsigned int )(end_p - p));
     }
   }
   return (o);
 }
 }
 static char *func_findstring(char *o , char **argv , char const   *funcname ) 
 { 
   int i ;
   size_t tmp ;
   char *tmp___0 ;
 
   {
   tmp = strlen((char const   *)*(argv + 0));
   i = (int )tmp;
   tmp___0 = sindex((char const   *)*(argv + 1), 0U, (char const   *)*(argv + 0), (unsigned int )i);
   if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
     o = variable_buffer_output(o, *(argv + 0), (unsigned int )i);
   }
   return (o);
 }
 }
 static char *func_foreach(char *o , char **argv , char const   *funcname ) 
 { 
   char *varname ;
   char *tmp ;
   char *list ;
   char *tmp___0 ;
   char *body ;
   int doneany ;
   char *list_iterator ;
   char *p ;
   unsigned int len ;
   register struct variable *var ;
   size_t tmp___1 ;
   char *result___0 ;
   char save ;
   char *tmp___2 ;
   size_t tmp___3 ;
 
   {
   tmp = expand_argument(*(argv + 0), (char *)((void *)0));
   varname = tmp;
   tmp___0 = expand_argument(*(argv + 1), (char *)((void *)0));
   list = tmp___0;
   body = *(argv + 2);
   doneany = 0;
   list_iterator = list;
   push_new_variable_scope();
   tmp___1 = strlen((char const   *)varname);
   var = define_variable_in_set(varname, (unsigned int )tmp___1, (char *)"", (enum variable_origin )6,
                                0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   while (1) {
     p = find_next_token(& list_iterator, & len);
     if (! ((unsigned long )p != (unsigned long )((char *)0))) {
       break;
     }
     result___0 = (char *)0;
     save = *(p + len);
     *(p + len) = (char )'\000';
     free((void *)var->value);
     tmp___2 = xstrdup((char const   *)p);
     var->value = tmp___2;
     *(p + len) = save;
     result___0 = allocated_variable_expand_for_file(body, (struct file *)0);
     tmp___3 = strlen((char const   *)result___0);
     o = variable_buffer_output(o, result___0, (unsigned int )tmp___3);
     o = variable_buffer_output(o, (char *)" ", 1U);
     doneany = 1;
     free((void *)result___0);
   }
   if (doneany) {
     o --;
   }
   pop_variable_scope();
   free((void *)varname);
   free((void *)list);
   return (o);
 }
 }
 static char *func_filter_filterout(char *o , char **argv , char const   *funcname ) 
 { 
   struct a_word *wordhead ;
   struct a_word *wordtail ;
   int is_filter ;
   int tmp ;
   int tmp___0 ;
   char *patterns ;
   char *word_iterator ;
   char *p ;
   unsigned int len ;
   struct a_word *w ;
   void *tmp___1 ;
   char *pat_iterator ;
   int doneany ;
   struct a_word *wp ;
   char *percent ;
   char save ;
   int tmp___2 ;
   int tmp___3 ;
   int tmp___4 ;
   int tmp___5 ;
   size_t tmp___6 ;
   int tmp___7 ;
 
   {
   wordhead = (struct a_word *)0;
   wordtail = (struct a_word *)0;
   if ((unsigned long )funcname == (unsigned long )"filter") {
     tmp___0 = 1;
   } else
   if ((int const   )*funcname == (int const   )*"filter") {
     if ((int const   )*funcname == 0) {
       tmp___0 = 1;
     } else {
       tmp = strcmp(funcname + 1, "filter" + 1);
       if (tmp) {
         tmp___0 = 0;
       } else {
         tmp___0 = 1;
       }
     }
   } else {
     tmp___0 = 0;
   }
   is_filter = tmp___0;
   patterns = *(argv + 0);
   word_iterator = *(argv + 1);
   while (1) {
     p = find_next_token(& word_iterator, & len);
     if (! ((unsigned long )p != (unsigned long )((char *)0))) {
       break;
     }
     tmp___1 = __builtin_alloca(sizeof(struct a_word ));
     w = (struct a_word *)tmp___1;
     if ((unsigned long )wordhead == (unsigned long )((struct a_word *)0)) {
       wordhead = w;
     } else {
       wordtail->next = w;
     }
     wordtail = w;
     if ((int )*word_iterator != 0) {
       word_iterator ++;
     }
     *(p + len) = (char )'\000';
     w->str = p;
     w->matched = 0;
   }
   if ((unsigned long )wordhead != (unsigned long )((struct a_word *)0)) {
     pat_iterator = patterns;
     doneany = 0;
     wordtail->next = (struct a_word *)0;
     while (1) {
       p = find_next_token(& pat_iterator, & len);
       if (! ((unsigned long )p != (unsigned long )((char *)0))) {
         break;
       }
       save = *(p + len);
       *(p + len) = (char )'\000';
       percent = find_percent(p);
       wp = wordhead;
       while ((unsigned long )wp != (unsigned long )((struct a_word *)0)) {
         if ((unsigned long )percent == (unsigned long )((char *)0)) {
           if ((unsigned long )p == (unsigned long )wp->str) {
             tmp___3 = 1;
           } else
           if ((int )*p == (int )*(wp->str)) {
             if ((int )*p == 0) {
               tmp___3 = 1;
             } else {
               tmp___2 = strcmp((char const   *)(p + 1), (char const   *)(wp->str + 1));
               if (tmp___2) {
                 tmp___3 = 0;
               } else {
                 tmp___3 = 1;
               }
             }
           } else {
             tmp___3 = 0;
           }
           tmp___5 = tmp___3;
         } else {
           tmp___4 = pattern_matches(p, percent, wp->str);
           tmp___5 = tmp___4;
         }
         wp->matched |= tmp___5;
         wp = wp->next;
       }
       *(p + len) = save;
     }
     wp = wordhead;
     while ((unsigned long )wp != (unsigned long )((struct a_word *)0)) {
       if (is_filter) {
         tmp___7 = wp->matched;
       } else {
         tmp___7 = ! wp->matched;
       }
       if (tmp___7) {
         tmp___6 = strlen((char const   *)wp->str);
         o = variable_buffer_output(o, wp->str, (unsigned int )tmp___6);
         o = variable_buffer_output(o, (char *)" ", 1U);
         doneany = 1;
       }
       wp = wp->next;
     }
     if (doneany) {
       o --;
     }
   }
   return (o);
 }
 }
 static char *func_strip(char *o , char **argv , char const   *funcname ) 
 { 
   char *p ;
   int doneany ;
   int i ;
   char *word_start ;
   unsigned short const   **tmp ;
   unsigned short const   **tmp___0 ;
 
   {
   p = *(argv + 0);
   doneany = 0;
   while ((int )*p != 0) {
     i = 0;
     word_start = (char *)0;
     while (1) {
       tmp = __ctype_b_loc();
       if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
         break;
       }
       p ++;
     }
     word_start = p;
     i = 0;
     while (1) {
       if ((int )*p != 0) {
         tmp___0 = __ctype_b_loc();
         if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 8192) {
           break;
         }
       } else {
         break;
       }
       p ++;
       i ++;
     }
     if (! i) {
       break;
     }
     o = variable_buffer_output(o, word_start, (unsigned int )i);
     o = variable_buffer_output(o, (char *)" ", 1U);
     doneany = 1;
   }
   if (doneany) {
     o --;
   }
   return (o);
 }
 }
 static char *func_error(char *o , char **argv , char const   *funcname ) 
 { 
   char **argvp ;
   char *msg ;
   char *p ;
   int len ;
   size_t tmp ;
   void *tmp___0 ;
   size_t tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
 
   {
   len = 0;
   argvp = argv;
   while ((unsigned long )*argvp != (unsigned long )((char *)0)) {
     tmp = strlen((char const   *)*argvp);
     len = (int )((size_t )len + (tmp + 2UL));
     argvp ++;
   }
   tmp___0 = __builtin_alloca((unsigned long )(len + 1));
   msg = (char *)tmp___0;
   p = msg;
   argvp = argv;
   while ((unsigned long )*(argvp + 1) != (unsigned long )((char *)0)) {
     strcpy((char * __restrict  )p, (char const   * __restrict  )*argvp);
     tmp___1 = strlen((char const   *)*argvp);
     p += tmp___1;
     tmp___2 = p;
     p ++;
     *tmp___2 = (char )',';
     tmp___3 = p;
     p ++;
     *tmp___3 = (char )' ';
     argvp ++;
   }
   strcpy((char * __restrict  )p, (char const   * __restrict  )*argvp);
   if ((int const   )*funcname == 101) {
     fatal(reading_file, "%s", msg);
   }
   error(reading_file, "%s", msg);
   return (o);
 }
 }
 static char *func_sort(char *o , char **argv , char const   *funcname ) 
 { 
   char **words ;
   int nwords ;
   register int wordi ;
   char *t ;
   char *p ;
   unsigned int len ;
   int i ;
   char *tmp ;
   int tmp___0 ;
   size_t tmp___1 ;
   size_t tmp___2 ;
   int tmp___3 ;
 
   {
   words = (char **)0;
   nwords = 0;
   wordi = 0;
   t = *(argv + 0);
   while (1) {
     p = find_next_token(& t, & len);
     if (! ((unsigned long )p != (unsigned long )((char *)0))) {
       break;
     }
     if (wordi >= nwords - 1) {
       nwords = 2 * nwords + 5;
       tmp = xrealloc((char *)words, (unsigned int )((unsigned long )nwords * sizeof(char *)));
       words = (char **)tmp;
     }
     tmp___0 = wordi;
     wordi ++;
     *(words + tmp___0) = savestring((char const   *)p, len);
   }
   if (! wordi) {
     return (o);
   }
   qsort((void *)((char *)words), (size_t )wordi, sizeof(char *), & alpha_compare);
   i = 0;
   while (i < wordi) {
     tmp___1 = strlen((char const   *)*(words + i));
     len = (unsigned int )tmp___1;
     if (i == wordi - 1) {
       o = variable_buffer_output(o, *(words + i), len);
       o = variable_buffer_output(o, (char *)" ", 1U);
     } else {
       tmp___2 = strlen((char const   *)*(words + (i + 1)));
       if (tmp___2 != (size_t )len) {
         o = variable_buffer_output(o, *(words + i), len);
         o = variable_buffer_output(o, (char *)" ", 1U);
       } else {
         tmp___3 = strcmp((char const   *)*(words + i), (char const   *)*(words + (i + 1)));
         if (tmp___3) {
           o = variable_buffer_output(o, *(words + i), len);
           o = variable_buffer_output(o, (char *)" ", 1U);
         }
       }
     }
     free((void *)*(words + i));
     i ++;
   }
   o --;
   free((void *)words);
   return (o);
 }
 }
 static char *func_if(char *o , char **argv , char const   *funcname ) 
 { 
   char *begp ;
   char *endp ;
   size_t tmp ;
   int result___0 ;
   char *expansion ;
   char *tmp___0 ;
   size_t tmp___1 ;
   char *expansion___0 ;
   size_t tmp___2 ;
 
   {
   begp = *(argv + 0);
   tmp = strlen((char const   *)*(argv + 0));
   endp = begp + tmp;
   result___0 = 0;
   strip_whitespace(& begp, & endp);
   if ((unsigned long )begp < (unsigned long )endp) {
     tmp___0 = expand_argument(begp, (char *)((void *)0));
     expansion = tmp___0;
     tmp___1 = strlen((char const   *)expansion);
     result___0 = (int )tmp___1;
     free((void *)expansion);
   }
   argv += 1 + ! result___0;
   if (*(argv + 0)) {
     expansion___0 = expand_argument(*(argv + 0), (char *)((void *)0));
     tmp___2 = strlen((char const   *)expansion___0);
     o = variable_buffer_output(o, expansion___0, (unsigned int )tmp___2);
     free((void *)expansion___0);
   }
   return (o);
 }
 }
 static char *func_wildcard(char *o , char **argv , char const   *funcname ) 
 { 
   char *p ;
   char *tmp ;
   size_t tmp___0 ;
 
   {
   tmp = string_glob(*(argv + 0));
   p = tmp;
   tmp___0 = strlen((char const   *)p);
   o = variable_buffer_output(o, p, (unsigned int )tmp___0);
   return (o);
 }
 }
 void fold_newlines(char *buffer , int *length___0 ) 
 { 
   char *dst ;
   char *src ;
   char *last_nonnl ;
   char *tmp ;
   char *tmp___0 ;
 
   {
   dst = buffer;
   src = buffer;
   last_nonnl = buffer - 1;
   *(src + *length___0) = (char)0;
   while ((int )*src != 0) {
     if ((int )*(src + 0) == 13) {
       if ((int )*(src + 1) == 10) {
         goto __Cont;
       }
     }
     if ((int )*src == 10) {
       tmp = dst;
       dst ++;
       *tmp = (char )' ';
     } else {
       last_nonnl = dst;
       tmp___0 = dst;
       dst ++;
       *tmp___0 = *src;
     }
     __Cont: /* CIL Label */ 
     src ++;
   }
   last_nonnl ++;
   *last_nonnl = (char )'\000';
   *length___0 = (int )(last_nonnl - buffer);
   return;
 }
 }
 int shell_function_pid  =    0;
 int shell_function_completed  ;
 static char *func_shell(char *o , char **argv , char const   *funcname ) 
 { 
   char *batch_filename ;
   int i ;
   char **command_argv ;
   char *error_prefix ;
   char **envp ;
   int pipedes[2] ;
   int pid ;
   size_t tmp ;
   void *tmp___0 ;
   int tmp___1 ;
   char *buffer ;
   unsigned int maxlen ;
   int cc ;
   char *tmp___2 ;
   char *tmp___3 ;
   int *tmp___4 ;
   ssize_t tmp___5 ;
   int *tmp___6 ;
   char *tmp___7 ;
 
   {
   batch_filename = (char *)((void *)0);
   command_argv = construct_command_argv(*(argv + 0), (char **)((void *)0), (struct file *)0,
                                         & batch_filename);
   if ((unsigned long )command_argv == (unsigned long )((char **)0)) {
     return (o);
   }
   envp = environ;
   if ((unsigned long )reading_file != (unsigned long )((struct floc  const  *)0)) {
     tmp = strlen((char const   *)reading_file->filenm);
     tmp___0 = __builtin_alloca((tmp + 11UL) + 4UL);
     error_prefix = (char *)tmp___0;
     sprintf((char * __restrict  )error_prefix, (char const   * __restrict  )"%s:%lu: ",
             reading_file->filenm, reading_file->lineno);
   } else {
     error_prefix = (char *)"";
   }
   tmp___1 = pipe((int *)(pipedes));
   if (tmp___1 < 0) {
     perror_with_name(error_prefix, (char *)"pipe");
     return (o);
   }
   pid = vfork();
   if (pid < 0) {
     perror_with_name(error_prefix, (char *)"fork");
   } else
   if (pid == 0) {
     child_execute_job(0, pipedes[1], command_argv, envp);
   } else {
     shell_function_pid = pid;
     shell_function_completed = 0;
     free((void *)*(command_argv + 0));
     free((void *)((char *)command_argv));
     close(pipedes[1]);
     maxlen = 200U;
     tmp___2 = xmalloc(maxlen + 1U);
     buffer = tmp___2;
     i = 0;
     while (1) {
       if ((unsigned int )i == maxlen) {
         maxlen += 512U;
         tmp___3 = xrealloc(buffer, maxlen + 1U);
         buffer = tmp___3;
       }
       tmp___4 = __errno_location();
       *tmp___4 = 0;
       tmp___5 = read(pipedes[0], (void *)(buffer + i), (size_t )(maxlen - (unsigned int )i));
       cc = (int )tmp___5;
       if (cc > 0) {
         i += cc;
       }
       if (! (cc > 0)) {
         tmp___6 = __errno_location();
         if (! (*tmp___6 == 4)) {
           break;
         }
       }
     }
     close(pipedes[0]);
     while (shell_function_completed == 0) {
       reap_children(1, 0);
     }
     if (batch_filename) {
       while (1) {
         if (2 & db_level) {
           tmp___7 = dcgettext((char const   *)((void *)0), "Cleaning up temporary batch file %s\n",
                               5);
           printf((char const   * __restrict  )tmp___7, batch_filename);
           fflush(stdout);
         }
         break;
       }
       remove((char const   *)batch_filename);
       free((void *)batch_filename);
     }
     shell_function_pid = 0;
     if (shell_function_completed == -1) {
       fputs((char const   * __restrict  )buffer, (FILE * __restrict  )stderr);
       fflush(stderr);
     } else {
       fold_newlines(buffer, & i);
       o = variable_buffer_output(o, buffer, (unsigned int )i);
     }
     free((void *)buffer);
   }
   return (o);
 }
 }
 static char *func_call(char *o , char **argv , char const   *funcname ) ;
 static struct function_table_entry function_table[27]  = 
   {      {"addprefix", (unsigned char )(sizeof("addprefix") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_addsuffix_addprefix}, 
         {"addsuffix", (unsigned char )(sizeof("addsuffix") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_addsuffix_addprefix}, 
         {"basename", (unsigned char )(sizeof("basename") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_basename_dir}, 
         {"dir", (unsigned char )(sizeof("dir") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_basename_dir}, 
         {"notdir", (unsigned char )(sizeof("notdir") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_notdir_suffix}, 
         {"subst", (unsigned char )(sizeof("subst") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)1, & func_subst}, 
         {"suffix", (unsigned char )(sizeof("suffix") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_notdir_suffix}, 
         {"filter", (unsigned char )(sizeof("filter") - 1UL), (unsigned char)2, (unsigned char)2,
       (char)1, & func_filter_filterout}, 
         {"filter-out", (unsigned char )(sizeof("filter-out") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_filter_filterout}, 
         {"findstring", (unsigned char )(sizeof("findstring") - 1UL), (unsigned char)2,
       (unsigned char)2, (char)1, & func_findstring}, 
         {"firstword", (unsigned char )(sizeof("firstword") - 1UL), (unsigned char)1,
       (unsigned char)1, (char)1, & func_firstword}, 
         {"join", (unsigned char )(sizeof("join") - 1UL), (unsigned char)2, (unsigned char)2,
       (char)1, & func_join}, 
         {"patsubst", (unsigned char )(sizeof("patsubst") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)1, & func_patsubst}, 
         {"shell", (unsigned char )(sizeof("shell") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_shell}, 
         {"sort", (unsigned char )(sizeof("sort") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_sort}, 
         {"strip", (unsigned char )(sizeof("strip") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_strip}, 
         {"wildcard", (unsigned char )(sizeof("wildcard") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_wildcard}, 
         {"word", (unsigned char )(sizeof("word") - 1UL), (unsigned char)2, (unsigned char)2,
       (char)1, & func_word}, 
         {"wordlist", (unsigned char )(sizeof("wordlist") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)1, & func_wordlist}, 
         {"words", (unsigned char )(sizeof("words") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_words}, 
         {"origin", (unsigned char )(sizeof("origin") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_origin}, 
         {"foreach", (unsigned char )(sizeof("foreach") - 1UL), (unsigned char)3, (unsigned char)3,
       (char)0, & func_foreach}, 
         {"call", (unsigned char )(sizeof("call") - 1UL), (unsigned char)1, (unsigned char)0,
       (char)1, & func_call}, 
         {"error", (unsigned char )(sizeof("error") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_error}, 
         {"warning", (unsigned char )(sizeof("warning") - 1UL), (unsigned char)1, (unsigned char)1,
       (char)1, & func_error}, 
         {"if", (unsigned char )(sizeof("if") - 1UL), (unsigned char)2, (unsigned char)3,
       (char)0, & func_if}, 
         {(char const   *)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (char)0,
       (char *(*)(char *output , char **argv , char const   *fname ))0}};
 static char *expand_builtin_function(char *o , int argc , char **argv , struct function_table_entry *entry_p ) 
 { 
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
 
   {
   if (argc < (int )entry_p->minimum_args) {
     tmp = dcgettext((char const   *)((void *)0), "Insufficient number of arguments (%d) to function `%s\'",
                     5);
     fatal(reading_file, (char const   *)tmp, argc, entry_p->name);
   }
   if (! entry_p->func_ptr) {
     tmp___0 = dcgettext((char const   *)((void *)0), "Unimplemented on this platform: function `%s\'",
                         5);
     fatal(reading_file, (char const   *)tmp___0, entry_p->name);
   }
   tmp___1 = (*(entry_p->func_ptr))(o, argv, entry_p->name);
   return (tmp___1);
 }
 }
 int handle_function(char **op , char **stringp ) 
 { 
   struct function_table_entry  const  *entry_p ;
   char openparen ;
   char closeparen ;
   int tmp ;
   char *beg ;
   char *end ;
   int count ;
   register char *p ;
   char **argv ;
   char **argvp ;
   int nargs ;
   char *tmp___0 ;
   void *tmp___1 ;
   int len ;
   char *next ;
 
   {
   openparen = *(*stringp + 0);
   if ((int )openparen == 40) {
     tmp = ')';
   } else {
     tmp = '}';
   }
   closeparen = (char )tmp;
   count = 0;
   beg = *stringp + 1;
   entry_p = lookup_function((struct function_table_entry  const  *)(function_table),
                             (char const   *)beg);
   if (! entry_p) {
     return (0);
   }
   beg = next_token(beg + (int const   )entry_p->len);
   nargs = 1;
   end = beg;
   while ((int )*end != 0) {
     if ((int )*end == 44) {
       nargs ++;
     } else
     if ((int )*end == (int )openparen) {
       count ++;
     } else
     if ((int )*end == (int )closeparen) {
       count --;
       if (count < 0) {
         break;
       }
     }
     end ++;
   }
   if (count >= 0) {
     tmp___0 = dcgettext((char const   *)((void *)0), "unterminated call to function `%s\': missing `%c\'",
                         5);
     fatal(reading_file, (char const   *)tmp___0, entry_p->name, (int )closeparen);
   }
   *stringp = end;
   tmp___1 = __builtin_alloca(sizeof(char *) * (unsigned long )(nargs + 2));
   argv = (char **)tmp___1;
   argvp = argv;
   if (! entry_p->expand_args) {
     len = (int )(end - beg);
     p = xmalloc((unsigned int )(len + 1));
     memcpy((void * __restrict  )p, (void const   * __restrict  )beg, (size_t )len);
     *(p + len) = (char )'\000';
     beg = p;
     end = beg + len;
   }
   p = beg;
   nargs = 0;
   p = beg;
   nargs = 0;
   while ((unsigned long )p < (unsigned long )end) {
     nargs ++;
     if (nargs == (int )entry_p->maximum_args) {
       next = end;
     } else {
       next = find_next_argument(openparen, closeparen, (char const   *)p, (char const   *)end);
       if (! next) {
         next = end;
       }
     }
     if (entry_p->expand_args) {
       *argvp = expand_argument(p, next);
     } else {
       *argvp = p;
       *next = (char )'\000';
     }
     p = next + 1;
     argvp ++;
   }
   *argvp = (char *)((void *)0);
   *op = expand_builtin_function(*op, nargs, argv, (struct function_table_entry *)entry_p);
   if (entry_p->expand_args) {
     argvp = argv;
     while ((unsigned long )*argvp != (unsigned long )((char *)0)) {
       free((void *)*argvp);
       argvp ++;
     }
   } else {
     free((void *)beg);
   }
   return (1);
 }
 }
 static char *func_call(char *o , char **argv , char const   *funcname ) 
 { 
   char *fname ;
   char *cp ;
   int flen ;
   char *body ;
   int i ;
   struct function_table_entry  const  *entry_p ;
   unsigned short const   **tmp ;
   size_t tmp___0 ;
   unsigned short const   **tmp___1 ;
   char *tmp___2 ;
   size_t tmp___3 ;
   void *tmp___4 ;
   char num[11] ;
   size_t tmp___5 ;
   size_t tmp___6 ;
 
   {
   fname = *(argv + 0);
   while (1) {
     if ((int )*fname != 0) {
       tmp = __ctype_b_loc();
       if (! ((int const   )*(*tmp + (int )((unsigned char )*fname)) & 8192)) {
         break;
       }
     } else {
       break;
     }
     fname ++;
   }
   tmp___0 = strlen((char const   *)fname);
   cp = (fname + tmp___0) - 1;
   while (1) {
     if ((unsigned long )cp > (unsigned long )fname) {
       tmp___1 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*cp)) & 8192)) {
         break;
       }
     } else {
       break;
     }
     cp --;
   }
   *(cp + 1) = (char )'\000';
   if ((int )*fname == 0) {
     return (o);
   }
   entry_p = lookup_function((struct function_table_entry  const  *)(function_table),
                             (char const   *)fname);
   if (entry_p) {
     i = 0;
     while (*(argv + (i + 1))) {
       i ++;
     }
     tmp___2 = expand_builtin_function(o, i, argv + 1, (struct function_table_entry *)entry_p);
     return (tmp___2);
   }
   tmp___3 = strlen((char const   *)fname);
   flen = (int )tmp___3;
   tmp___4 = __builtin_alloca((unsigned long )(flen + 4));
   body = (char *)tmp___4;
   *(body + 0) = (char )'$';
   *(body + 1) = (char )'(';
   memcpy((void * __restrict  )(body + 2), (void const   * __restrict  )fname, (size_t )flen);
   *(body + (flen + 2)) = (char )')';
   *(body + (flen + 3)) = (char )'\000';
   push_new_variable_scope();
   i = 0;
   while (*argv) {
     sprintf((char * __restrict  )(num), (char const   * __restrict  )"%d", i);
     tmp___5 = strlen((char const   *)(num));
     define_variable_in_set(num, (unsigned int )tmp___5, *argv, (enum variable_origin )6,
                            1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
     i ++;
     argv ++;
   }
   o = variable_expand_string(o, body, (long )(flen + 3));
   pop_variable_scope();
   tmp___6 = strlen((char const   *)o);
   return (o + tmp___6);
 }
 }
 #pragma merger("0","/tmp/cil-DQjlIciI.i","-g,-O0")
 #pragma merger("0","/tmp/cil-ElSTEfZg.i","-g,-O0")
 void print_spaces(unsigned int n ) ;
 int vpath_search(char **file , uintmax_t *mtime_ptr ) ;
 struct rule *pattern_rules ;
 unsigned int num_pattern_rules ;
 unsigned int max_pattern_deps ;
 unsigned int max_pattern_targets ;
 unsigned int max_pattern_dep_length ;
 static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) ;
 int try_implicit_rule(struct file *file , unsigned int depth ) 
 { 
   char *tmp ;
   int tmp___0 ;
   char *tmp___1 ;
   int tmp___2 ;
   int tmp___3 ;
 
   {
   while (1) {
     if (8 & db_level) {
       print_spaces(depth);
       tmp = dcgettext((char const   *)((void *)0), "Looking for an implicit rule for `%s\'.\n",
                       5);
       printf((char const   * __restrict  )tmp, file->name);
       fflush(stdout);
     }
     break;
   }
   tmp___0 = pattern_search(file, 0, depth, 0U);
   if (tmp___0) {
     return (1);
   }
   tmp___3 = ar_name(file->name);
   if (tmp___3) {
     while (1) {
       if (8 & db_level) {
         print_spaces(depth);
         tmp___1 = dcgettext((char const   *)((void *)0), "Looking for archive-member implicit rule for `%s\'.\n",
                             5);
         printf((char const   * __restrict  )tmp___1, file->name);
         fflush(stdout);
       }
       break;
     }
     tmp___2 = pattern_search(file, 1, depth, 0U);
     if (tmp___2) {
       return (1);
     }
   }
   return (0);
 }
 }
 static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) 
 { 
   char *filename ;
   char *tmp ;
   char *tmp___0 ;
   unsigned int namelen ;
   size_t tmp___1 ;
   char *lastslash ;
   struct file *intermediate_file ;
   struct file **intermediate_files ;
   void *tmp___2 ;
   char **intermediate_patterns ;
   void *tmp___3 ;
   char **found_files ;
   void *tmp___4 ;
   unsigned int deps_found ;
   register char *depname ;
   void *tmp___5 ;
   register char *stem ;
   register unsigned int stemlen ;
   struct rule **tryrules ;
   void *tmp___6 ;
   unsigned int nrules ;
   unsigned int *matches ;
   void *tmp___7 ;
   char *checked_lastslash ;
   void *tmp___8 ;
   unsigned int foundrule ;
   int intermed_ok ;
   int specific_rule_matched ;
   register unsigned int i ;
   register struct rule *rule ;
   register struct dep *dep ;
   char *p ;
   char *vp ;
   int tmp___9 ;
   char *tmp___10 ;
   char *target ;
   char *suffix ;
   int check_lastslash ;
   char *tmp___11 ;
   int tmp___12 ;
   unsigned int difference ;
   int tmp___13 ;
   int tmp___14 ;
   int tmp___15 ;
   register unsigned int j ;
   int check_lastslash___0 ;
   char *tmp___16 ;
   char *tmp___17 ;
   register unsigned int i___0 ;
   char *tmp___18 ;
   char *tmp___19 ;
   char *tmp___20 ;
   char *tmp___21 ;
   char *tmp___22 ;
   char *tmp___23 ;
   int tmp___24 ;
   char *tmp___25 ;
   char *tmp___26 ;
   char *tmp___27 ;
   unsigned int tmp___28 ;
   struct file *tmp___29 ;
   int tmp___30 ;
   char *tmp___31 ;
   unsigned int tmp___32 ;
   int tmp___33 ;
   void *tmp___34 ;
   char *tmp___35 ;
   int tmp___36 ;
   register struct file *f ;
   size_t tmp___37 ;
   unsigned int tmp___38 ;
   register char *s ;
   struct file *imf ;
   register struct file *f___0 ;
   struct file *tmp___39 ;
   char *tmp___40 ;
   unsigned int tmp___41 ;
   char *tmp___42 ;
   struct dep *new ;
   char *tmp___43 ;
   char *tmp___44 ;
 
   {
   if (archive) {
     tmp = strchr((char const   *)file->name, '(');
     tmp___0 = tmp;
   } else {
     tmp___0 = file->name;
   }
   filename = tmp___0;
   tmp___1 = strlen((char const   *)filename);
   namelen = (unsigned int )tmp___1;
   intermediate_file = (struct file *)0;
   tmp___2 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(struct file *));
   intermediate_files = (struct file **)tmp___2;
   tmp___3 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));
   intermediate_patterns = (char **)tmp___3;
   tmp___4 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));
   found_files = (char **)tmp___4;
   deps_found = 0U;
   tmp___5 = __builtin_alloca((unsigned long )(namelen + max_pattern_dep_length));
   depname = (char *)tmp___5;
   stem = (char *)0;
   stemlen = 0U;
   tmp___6 = __builtin_alloca((unsigned long )(num_pattern_rules * max_pattern_targets) * sizeof(struct rule *));
   tryrules = (struct rule **)tmp___6;
   tmp___7 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(unsigned int ));
   matches = (unsigned int *)tmp___7;
   tmp___8 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(char ));
   checked_lastslash = (char *)tmp___8;
   specific_rule_matched = 0;
   i = 0U;
   if (archive) {
     lastslash = (char *)0;
   } else {
     tmp___9 = ar_name(filename);
     if (tmp___9) {
       lastslash = (char *)0;
     } else {
       lastslash = strrchr((char const   *)filename, '/');
       if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
         if ((int )*(lastslash + 1) == 0) {
           lastslash = (char *)0;
         }
       }
     }
   }
   nrules = 0U;
   rule = pattern_rules;
   while ((unsigned long )rule != (unsigned long )((struct rule *)0)) {
     if ((unsigned long )rule->deps != (unsigned long )((struct dep *)0)) {
       if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
         goto __Cont;
       }
     }
     if (rule->in_use) {
       while (1) {
         if (8 & db_level) {
           print_spaces(depth);
           tmp___10 = dcgettext((char const   *)((void *)0), "Avoiding implicit rule recursion.\n",
                                5);
           printf((char const   * __restrict  )tmp___10);
           fflush(stdout);
         }
         break;
       }
       goto __Cont;
     }
     i = 0U;
     while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
       target = *(rule->targets + i);
       suffix = *(rule->suffixes + i);
       if (recursions > 0U) {
         if ((int )*(target + 1) == 0) {
           if (! rule->terminal) {
             goto __Cont___0;
           }
         }
       }
       if (*(rule->lens + i) > namelen) {
         goto __Cont___0;
       }
       stem = filename + ((suffix - target) - 1L);
       stemlen = (namelen - *(rule->lens + i)) + 1U;
       if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
         tmp___11 = strchr((char const   *)target, '/');
         if ((unsigned long )tmp___11 == (unsigned long )((char *)0)) {
           tmp___12 = 1;
         } else {
           tmp___12 = 0;
         }
       } else {
         tmp___12 = 0;
       }
       check_lastslash = tmp___12;
       if (check_lastslash) {
         difference = (unsigned int )((lastslash - filename) + 1L);
         if (difference > stemlen) {
           goto __Cont___0;
         }
         stemlen -= difference;
         stem += difference;
       }
       if (check_lastslash) {
         if ((unsigned long )stem > (unsigned long )(lastslash + 1)) {
           tmp___13 = strncmp((char const   *)target, (char const   *)(lastslash + 1),
                              (size_t )((stem - lastslash) - 1L));
           if (! (tmp___13 == 0)) {
             goto __Cont___0;
           }
         }
       } else
       if ((unsigned long )stem > (unsigned long )filename) {
         tmp___14 = strncmp((char const   *)target, (char const   *)filename, (size_t )(stem - filename));
         if (! (tmp___14 == 0)) {
           goto __Cont___0;
         }
       }
       if ((int )*suffix != (int )*(stem + stemlen)) {
         goto __Cont___0;
       } else
       if ((int )*suffix != 0) {
         if (! ((unsigned long )(suffix + 1) == (unsigned long )(stem + (stemlen + 1U)))) {
           if ((int )*(suffix + 1) == (int )*(stem + (stemlen + 1U))) {
             if (! ((int )*(suffix + 1) == 0)) {
               tmp___15 = strcmp((char const   *)((suffix + 1) + 1), (char const   *)((stem + (stemlen + 1U)) + 1));
               if (tmp___15) {
                 goto __Cont___0;
               }
             }
           } else {
             goto __Cont___0;
           }
         }
       }
       if ((int )*(target + 1) != 0) {
         specific_rule_matched = 1;
       }
       if ((unsigned long )rule->deps == (unsigned long )((struct dep *)0)) {
         if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
           goto __Cont___0;
         }
       }
       *(tryrules + nrules) = rule;
       *(matches + nrules) = i;
       *(checked_lastslash + nrules) = (char )check_lastslash;
       nrules ++;
       __Cont___0: /* CIL Label */ 
       i ++;
     }
     __Cont: /* CIL Label */ 
     rule = rule->next;
   }
   if (specific_rule_matched) {
     i = 0U;
     while (i < nrules) {
       if (! (*(tryrules + i))->terminal) {
         j = 0U;
         while ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0)) {
           if ((int )*(*((*(tryrules + i))->targets + j) + 1) == 0) {
             break;
           }
           j ++;
         }
         if ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0)) {
           *(tryrules + i) = (struct rule *)0;
         }
       }
       i ++;
     }
   }
   intermed_ok = 0;
   while (intermed_ok == ! (! intermed_ok)) {
     i = 0U;
     while (i < nrules) {
       rule = *(tryrules + i);
       if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
         goto __Cont___1;
       }
       if (intermed_ok) {
         if (rule->terminal) {
           goto __Cont___1;
         }
       }
       rule->in_use = (char)1;
       stem = (filename + (*(rule->suffixes + *(matches + i)) - *(rule->targets + *(matches + i)))) - 1;
       stemlen = (namelen - *(rule->lens + *(matches + i))) + 1U;
       check_lastslash___0 = (int )*(checked_lastslash + i);
       if (check_lastslash___0) {
         stem += (lastslash - filename) + 1L;
         stemlen = (unsigned int )((long )stemlen - ((lastslash - filename) + 1L));
       }
       while (1) {
         if (8 & db_level) {
           print_spaces(depth);
           tmp___16 = dcgettext((char const   *)((void *)0), "Trying pattern rule with stem `%.*s\'.\n",
                                5);
           printf((char const   * __restrict  )tmp___16, (int )stemlen, stem);
           fflush(stdout);
         }
         break;
       }
       deps_found = 0U;
       dep = rule->deps;
       while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
         if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
           tmp___17 = (dep->file)->name;
         } else {
           tmp___17 = dep->name;
         }
         p = strchr((char const   *)tmp___17, '%');
         if ((unsigned long )p != (unsigned long )((char *)0)) {
           if (check_lastslash___0) {
             i___0 = (unsigned int )((lastslash - filename) + 1L);
             memmove((void *)depname, (void const   *)filename, (size_t )i___0);
           } else {
             i___0 = 0U;
           }
           if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
             tmp___18 = (dep->file)->name;
           } else {
             tmp___18 = dep->name;
           }
           if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
             tmp___19 = (dep->file)->name;
           } else {
             tmp___19 = dep->name;
           }
           memmove((void *)(depname + i___0), (void const   *)tmp___19, (size_t )(p - tmp___18));
           if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
             tmp___20 = (dep->file)->name;
           } else {
             tmp___20 = dep->name;
           }
           i___0 = (unsigned int )((long )i___0 + (p - tmp___20));
           memmove((void *)(depname + i___0), (void const   *)stem, (size_t )stemlen);
           i___0 += stemlen;
           strcpy((char * __restrict  )(depname + i___0), (char const   * __restrict  )(p + 1));
           p = depname;
         } else
         if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
           p = (dep->file)->name;
         } else {
           p = dep->name;
         }
         tmp___24 = file_impossible_p(p);
         if (tmp___24) {
           while (1) {
             if (8 & db_level) {
               print_spaces(depth);
               if ((unsigned long )p == (unsigned long )depname) {
                 tmp___21 = dcgettext((char const   *)((void *)0), "Rejecting impossible implicit prerequisite `%s\'.\n",
                                      5);
                 tmp___23 = tmp___21;
               } else {
                 tmp___22 = dcgettext((char const   *)((void *)0), "Rejecting impossible rule prerequisite `%s\'.\n",
                                      5);
                 tmp___23 = tmp___22;
               }
               printf((char const   * __restrict  )tmp___23, p);
               fflush(stdout);
             }
             break;
           }
           *(tryrules + i) = (struct rule *)0;
           break;
         }
         *(intermediate_files + deps_found) = (struct file *)0;
         while (1) {
           if (8 & db_level) {
             print_spaces(depth);
             if ((unsigned long )p == (unsigned long )depname) {
               tmp___25 = dcgettext((char const   *)((void *)0), "Trying implicit prerequisite `%s\'.\n",
                                    5);
               tmp___27 = tmp___25;
             } else {
               tmp___26 = dcgettext((char const   *)((void *)0), "Trying rule prerequisite `%s\'.\n",
                                    5);
               tmp___27 = tmp___26;
             }
             printf((char const   * __restrict  )tmp___27, p);
             fflush(stdout);
           }
           break;
         }
         if (! dep->changed) {
           goto _L;
         } else
         if (check_lastslash___0) {
           _L: /* CIL Label */ 
           tmp___29 = lookup_file(p);
           if ((unsigned long )tmp___29 != (unsigned long )((struct file *)0)) {
             tmp___28 = deps_found;
             deps_found ++;
             *(found_files + tmp___28) = xstrdup((char const   *)p);
             goto __Cont___2;
           } else {
             tmp___30 = file_exists_p(p);
             if (tmp___30) {
               tmp___28 = deps_found;
               deps_found ++;
               *(found_files + tmp___28) = xstrdup((char const   *)p);
               goto __Cont___2;
             }
           }
         }
         vp = p;
         tmp___33 = vpath_search(& vp, (uintmax_t *)0);
         if (tmp___33) {
           while (1) {
             if (8 & db_level) {
               print_spaces(depth);
               tmp___31 = dcgettext((char const   *)((void *)0), "Found prerequisite `%s\' as VPATH `%s\'\n",
                                    5);
               printf((char const   * __restrict  )tmp___31, p, vp);
               fflush(stdout);
             }
             break;
           }
           strcpy((char * __restrict  )vp, (char const   * __restrict  )p);
           tmp___32 = deps_found;
           deps_found ++;
           *(found_files + tmp___32) = vp;
           goto __Cont___2;
         }
         if (intermed_ok) {
           if ((unsigned long )intermediate_file == (unsigned long )((struct file *)0)) {
             tmp___34 = __builtin_alloca(sizeof(struct file ));
             intermediate_file = (struct file *)tmp___34;
           }
           while (1) {
             if (8 & db_level) {
               print_spaces(depth);
               tmp___35 = dcgettext((char const   *)((void *)0), "Looking for a rule with intermediate file `%s\'.\n",
                                    5);
               printf((char const   * __restrict  )tmp___35, p);
               fflush(stdout);
             }
             break;
           }
           memset((void *)((char *)intermediate_file), 0, sizeof(struct file ));
           intermediate_file->name = p;
           tmp___36 = pattern_search(intermediate_file, 0, depth + 1U, recursions + 1U);
           if (tmp___36) {
             p = xstrdup((char const   *)p);
             *(intermediate_patterns + deps_found) = intermediate_file->name;
             intermediate_file->name = p;
             *(intermediate_files + deps_found) = intermediate_file;
             intermediate_file = (struct file *)0;
             *(found_files + deps_found) = xstrdup((char const   *)p);
             deps_found ++;
             goto __Cont___2;
           }
           file_impossible(p);
         }
         break;
         __Cont___2: /* CIL Label */ 
         dep = dep->next;
       }
       rule->in_use = (char)0;
       if ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
         while (1) {
           tmp___38 = deps_found;
           deps_found --;
           if (! (tmp___38 > 0U)) {
             break;
           }
           f = *(intermediate_files + deps_found);
           free((void *)*(found_files + deps_found));
           if ((unsigned long )f != (unsigned long )((struct file *)0)) {
             if ((unsigned long )f->stem < (unsigned long )f->name) {
               free((void *)f->stem);
             } else {
               tmp___37 = strlen((char const   *)f->name);
               if ((unsigned long )f->stem > (unsigned long )(f->name + tmp___37)) {
                 free((void *)f->stem);
               }
             }
           }
         }
       } else {
         break;
       }
       __Cont___1: /* CIL Label */ 
       i ++;
     }
     if (i < nrules) {
       break;
     }
     rule = (struct rule *)0;
     intermed_ok ++;
   }
   if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
     return (0);
   }
   foundrule = i;
   if (recursions > 0U) {
     file->name = *(rule->targets + *(matches + foundrule));
   }
   while (1) {
     tmp___41 = deps_found;
     deps_found --;
     if (! (tmp___41 > 0U)) {
       break;
     }
     if ((unsigned long )*(intermediate_files + deps_found) != (unsigned long )((struct file *)0)) {
       imf = *(intermediate_files + deps_found);
       tmp___39 = enter_file(imf->name);
       f___0 = tmp___39;
       f___0->deps = imf->deps;
       f___0->cmds = imf->cmds;
       f___0->stem = imf->stem;
       f___0->also_make = imf->also_make;
       imf = lookup_file(*(intermediate_patterns + deps_found));
       if ((unsigned long )imf != (unsigned long )((struct file *)0)) {
         if (imf->precious) {
           f___0->precious = 1U;
         }
       }
       f___0->intermediate = 1U;
       f___0->tried_implicit = 1U;
       dep = f___0->deps;
       while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
         dep->file = enter_file(dep->name);
         if ((unsigned long )dep->name != (unsigned long )(dep->file)->name) {
           free((void *)dep->name);
         }
         dep->name = (char *)0;
         (dep->file)->tried_implicit |= (unsigned int )dep->changed;
         dep = dep->next;
       }
       num_intermediates ++;
     }
     tmp___40 = xmalloc((unsigned int )sizeof(struct dep ));
     dep = (struct dep *)tmp___40;
     s = *(found_files + deps_found);
     if (recursions == 0U) {
       dep->name = (char *)0;
       dep->file = lookup_file(s);
       if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
         dep->file = enter_file(s);
       } else {
         free((void *)s);
       }
     } else {
       dep->name = s;
       dep->file = (struct file *)0;
       dep->changed = 0;
     }
     if ((unsigned long )*(intermediate_files + deps_found) == (unsigned long )((struct file *)0)) {
       if ((*(tryrules + foundrule))->terminal) {
         if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
           dep->changed = 1;
         } else {
           (dep->file)->tried_implicit = 1U;
         }
       }
     }
     dep->next = file->deps;
     file->deps = dep;
   }
   if (! *(checked_lastslash + foundrule)) {
     file->stem = savestring((char const   *)stem, stemlen);
   } else {
     tmp___42 = xmalloc((unsigned int )((((lastslash + 1) - filename) + (long )stemlen) + 1L));
     file->stem = tmp___42;
     memmove((void *)file->stem, (void const   *)filename, (size_t )((lastslash + 1) - filename));
     memmove((void *)(file->stem + ((lastslash + 1) - filename)), (void const   *)stem,
             (size_t )stemlen);
     *(file->stem + (((lastslash + 1) - filename) + (long )stemlen)) = (char )'\000';
   }
   file->cmds = rule->cmds;
   if ((unsigned long )*(rule->targets + 1) != (unsigned long )((char *)0)) {
     i = 0U;
     while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
       if (i != *(matches + foundrule)) {
         tmp___43 = xmalloc((unsigned int )sizeof(struct dep ));
         new = (struct dep *)tmp___43;
         tmp___44 = xmalloc((*(rule->lens + i) + stemlen) + 1U);
         p = tmp___44;
         new->name = p;
         memmove((void *)p, (void const   *)*(rule->targets + i), (size_t )((*(rule->suffixes + i) - *(rule->targets + i)) - 1L));
         p += (*(rule->suffixes + i) - *(rule->targets + i)) - 1L;
         memmove((void *)p, (void const   *)stem, (size_t )stemlen);
         p += stemlen;
         memmove((void *)p, (void const   *)*(rule->suffixes + i), (size_t )(((long )*(rule->lens + i) - (*(rule->suffixes + i) - *(rule->targets + i))) + 1L));
         new->file = enter_file(new->name);
         new->next = file->also_make;
         file->also_make = new;
       }
       i ++;
     }
   }
   return (1);
 }
 }
 #pragma merger("0","/tmp/cil-2QdUWNY1.i","-g,-O0")
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                   sigset_t const   * __restrict  __set ,
                                                                                   sigset_t * __restrict  __oset ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                            int __fd2 ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                                char * const  *__argv ) ;
 extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *loadavg ,
                                                                                                  int nelem ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
 void ( /* format attribute */  message)(int prefix , char const   *fmt  , ...) ;
  __attribute__((__noreturn__)) void die(int status ) ;
 void user_access(void) ;
 void make_access(void) ;
 void child_access(void) ;
 int keep_going_flag ;
 int batch_mode_shell ;
 unsigned int job_slots ;
 int job_fds[2] ;
 int job_rfd ;
 double max_load_average ;
 unsigned int commands_started ;
 void start_waiting_jobs(void) ;
 void exec_command(char **argv , char **envp ) ;
 void block_sigs(void) ;
 void unblock_sigs(void) ;
 char **target_environment(struct file *file ) ;
 char default_shell[8]  = 
   {      (char )'/',      (char )'b',      (char )'i',      (char )'n', 
         (char )'/',      (char )'s',      (char )'h',      (char )'\000'};
 int batch_mode_shell  =    0;
 extern int fcntl(int __fd , int __cmd  , ...) ;
 extern __pid_t wait(int *__stat_loc ) ;
 extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
 int start_remote_job(char **argv , char **envp , int stdin_fd , int *is_remote , int *id_ptr ,
                      int *used_stdin ) ;
 int start_remote_job_p(int first_p ) ;
 int remote_status(int *exit_code_ptr , int *signal_ptr , int *coredump_ptr , int block ) ;
 void child_handler(int sig ) ;
 static void free_child(struct child *child ) ;
 static void start_job_command(struct child *child ) ;
 static int load_too_high(void) ;
 static int job_next_command(struct child *child ) ;
 static int start_waiting_job(struct child *c ) ;
 struct child *children  =    (struct child *)0;
 unsigned int job_slots_used  =    0U;
 static int good_stdin_used  =    0;
 static struct child *waiting_jobs  =    (struct child *)0;
 int unixy_shell  =    1;
 static void child_error(char *target_name , int exit_code , int exit_sig , int coredump ,
                         int ignored ) 
 { 
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char const   *tmp___3 ;
   char *tmp___4 ;
 
   {
   if (ignored) {
     if (silent_flag) {
       return;
     }
   }
   if (exit_sig == 0) {
     if (ignored) {
       tmp = dcgettext((char const   *)((void *)0), "[%s] Error %d (ignored)", 5);
       tmp___1 = tmp;
     } else {
       tmp___0 = dcgettext((char const   *)((void *)0), "*** [%s] Error %d", 5);
       tmp___1 = tmp___0;
     }
     error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, target_name,
           exit_code);
   } else {
     if (coredump) {
       tmp___2 = dcgettext((char const   *)((void *)0), " (core dumped)", 5);
       tmp___3 = (char const   *)tmp___2;
     } else {
       tmp___3 = "";
     }
     tmp___4 = strsignal(exit_sig);
     error((struct floc  const  *)((struct floc *)0), "*** [%s] %s%s", target_name,
           tmp___4, tmp___3);
   }
   return;
 }
 }
 static unsigned int dead_children  =    0U;
 void child_handler(int sig ) 
 { 
   char *tmp ;
 
   {
   dead_children ++;
   if (job_rfd >= 0) {
     close(job_rfd);
     job_rfd = -1;
   }
   while (1) {
     if (4 & db_level) {
       tmp = dcgettext((char const   *)((void *)0), "Got a SIGCHLD; %u unreaped children.\n",
                       5);
       printf((char const   * __restrict  )tmp, dead_children);
       fflush(stdout);
     }
     break;
   }
   return;
 }
 }
 static int delete_on_error  =    -1;
 void reap_children(int block , int err ) 
 { 
   int status ;
   int reap_more ;
   int remote ;
   register int pid ;
   int exit_code ;
   int exit_sig ;
   int coredump ;
   register struct child *lastc ;
   register struct child *c ;
   int child_failed ;
   int any_remote ;
   int any_local ;
   char *tmp ;
   char *tmp___0 ;
   char const   *tmp___1 ;
   char *tmp___2 ;
   int *tmp___3 ;
   int *tmp___4 ;
   int tmp___5 ;
   char *tmp___6 ;
   char const   *tmp___7 ;
   char *tmp___8 ;
   char *tmp___9 ;
   char *tmp___10 ;
   char *tmp___11 ;
   struct file *f ;
   struct file *tmp___12 ;
   int tmp___13 ;
   int tmp___14 ;
   int tmp___15 ;
   char *tmp___16 ;
   char const   *tmp___17 ;
   char *tmp___18 ;
 
   {
   reap_more = 1;
   while (1) {
     if ((unsigned long )children != (unsigned long )((struct child *)0)) {
       goto _L___1;
     } else
     if (shell_function_pid != 0) {
       _L___1: /* CIL Label */ 
       if (! block) {
         if (! reap_more) {
           break;
         }
       }
     } else {
       break;
     }
     remote = 0;
     if (err) {
       if (block) {
         fflush(stdout);
         tmp = dcgettext((char const   *)((void *)0), "*** Waiting for unfinished jobs....",
                         5);
         error((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
       }
     }
     if (dead_children > 0U) {
       dead_children --;
     }
     any_remote = 0;
     any_local = shell_function_pid != 0;
     c = children;
     while ((unsigned long )c != (unsigned long )((struct child *)0)) {
       any_remote = (int )((unsigned int )any_remote | c->remote);
       any_local |= ! c->remote;
       while (1) {
         if (4 & db_level) {
           if (c->remote) {
             tmp___0 = dcgettext((char const   *)((void *)0), " (remote)", 5);
             tmp___1 = (char const   *)tmp___0;
           } else {
             tmp___1 = "";
           }
           tmp___2 = dcgettext((char const   *)((void *)0), "Live child 0x%08lx (%s) PID %ld %s\n",
                               5);
           printf((char const   * __restrict  )tmp___2, (unsigned long )c, (c->file)->name,
                  (long )c->pid, tmp___1);
           fflush(stdout);
         }
         break;
       }
       c = c->next;
     }
     if (any_remote) {
       pid = remote_status(& exit_code, & exit_sig, & coredump, 0);
     } else {
       pid = 0;
     }
     if (pid > 0) {
       remote = 1;
     } else
     if (pid < 0) {
       remote_status_lose: 
       tmp___3 = __errno_location();
       if (*tmp___3 == 4) {
         continue;
       }
       pfatal_with_name((char *)"remote_status");
     } else {
       if (any_local) {
         local_wait: 
         if (! block) {
           pid = waitpid(-1, & status, 1);
         } else {
           pid = wait(& status);
         }
       } else {
         pid = 0;
       }
       if (pid < 0) {
         tmp___4 = __errno_location();
         if (*tmp___4 == 4) {
           goto local_wait;
         }
         pfatal_with_name((char *)"wait");
       } else
       if (pid > 0) {
         exit_code = (status & 65280) >> 8;
         if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
           exit_sig = status & 127;
         } else {
           exit_sig = 0;
         }
         coredump = status & 128;
       } else {
         reap_more = 0;
         if (! block) {
           break;
         } else
         if (! any_remote) {
           break;
         }
         pid = remote_status(& exit_code, & exit_sig, & coredump, 1);
         if (pid < 0) {
           goto remote_status_lose;
         } else
         if (pid == 0) {
           break;
         }
         remote = 1;
       }
     }
     if (! remote) {
       if (pid == shell_function_pid) {
         if (exit_sig == 0) {
           if (exit_code == 127) {
             shell_function_completed = -1;
           } else {
             shell_function_completed = 1;
           }
         } else {
           shell_function_completed = 1;
         }
         break;
       }
     }
     if (exit_sig != 0) {
       tmp___5 = 1;
     } else
     if (exit_code != 0) {
       tmp___5 = 1;
     } else {
       tmp___5 = 0;
     }
     child_failed = tmp___5;
     lastc = (struct child *)0;
     c = children;
     while ((unsigned long )c != (unsigned long )((struct child *)0)) {
       if (c->remote == (unsigned int )remote) {
         if (c->pid == pid) {
           break;
         }
       }
       lastc = c;
       c = c->next;
     }
     if ((unsigned long )c == (unsigned long )((struct child *)0)) {
       continue;
     }
     while (1) {
       if (4 & db_level) {
         if (c->remote) {
           tmp___6 = dcgettext((char const   *)((void *)0), " (remote)", 5);
           tmp___7 = (char const   *)tmp___6;
         } else {
           tmp___7 = "";
         }
         if (child_failed) {
           tmp___8 = dcgettext((char const   *)((void *)0), "Reaping losing child 0x%08lx PID %ld %s\n",
                               5);
           tmp___10 = tmp___8;
         } else {
           tmp___9 = dcgettext((char const   *)((void *)0), "Reaping winning child 0x%08lx PID %ld %s\n",
                               5);
           tmp___10 = tmp___9;
         }
         printf((char const   * __restrict  )tmp___10, (unsigned long )c, (long )c->pid,
                tmp___7);
         fflush(stdout);
       }
       break;
     }
     if (c->sh_batch_file) {
       while (1) {
         if (4 & db_level) {
           tmp___11 = dcgettext((char const   *)((void *)0), "Cleaning up temp batch file %s\n",
                                5);
           printf((char const   * __restrict  )tmp___11, c->sh_batch_file);
           fflush(stdout);
         }
         break;
       }
       remove((char const   *)c->sh_batch_file);
       free((void *)c->sh_batch_file);
       c->sh_batch_file = (char *)((void *)0);
     }
     if (c->good_stdin) {
       good_stdin_used = 0;
     }
     if (child_failed) {
       if (! c->noerror) {
         if (! ignore_errors_flag) {
           child_error((c->file)->name, exit_code, exit_sig, coredump, 0);
           (c->file)->update_status = (short)2;
           if (delete_on_error == -1) {
             tmp___12 = lookup_file((char *)".DELETE_ON_ERROR");
             f = tmp___12;
             if ((unsigned long )f != (unsigned long )((struct file *)0)) {
               if (f->is_target) {
                 tmp___13 = 1;
               } else {
                 tmp___13 = 0;
               }
             } else {
               tmp___13 = 0;
             }
             delete_on_error = tmp___13;
           }
           if (exit_sig != 0) {
             delete_child_targets(c);
           } else
           if (delete_on_error) {
             delete_child_targets(c);
           }
         } else {
           goto _L___0;
         }
       } else {
         goto _L___0;
       }
     } else {
       _L___0: /* CIL Label */ 
       if (child_failed) {
         child_error((c->file)->name, exit_code, exit_sig, coredump, 1);
         child_failed = 0;
       }
       tmp___15 = job_next_command(c);
       if (tmp___15) {
         if (handling_fatal_signal) {
           (c->file)->update_status = (short)2;
         } else {
           tmp___14 = start_remote_job_p(0);
           c->remote = (unsigned int )tmp___14;
           start_job_command(c);
           unblock_sigs();
           if ((unsigned int )(c->file)->command_state == 2U) {
             continue;
           }
         }
         if ((int )(c->file)->update_status != 0) {
           delete_child_targets(c);
         }
       } else {
         (c->file)->update_status = (short)0;
       }
     }
     if (! handling_fatal_signal) {
       notice_finished_file(c->file);
     }
     while (1) {
       if (4 & db_level) {
         if (c->remote) {
           tmp___16 = dcgettext((char const   *)((void *)0), " (remote)", 5);
           tmp___17 = (char const   *)tmp___16;
         } else {
           tmp___17 = "";
         }
         tmp___18 = dcgettext((char const   *)((void *)0), "Removing child 0x%08lx PID %ld %s from chain.\n",
                              5);
         printf((char const   * __restrict  )tmp___18, (unsigned long )c, (long )c->pid,
                tmp___17);
         fflush(stdout);
       }
       break;
     }
     block_sigs();
     if (job_slots_used > 0U) {
       job_slots_used --;
     }
     if ((unsigned long )lastc == (unsigned long )((struct child *)0)) {
       children = c->next;
     } else {
       lastc->next = c->next;
     }
     free_child(c);
     unblock_sigs();
     if (! err) {
       if (child_failed) {
         if (! keep_going_flag) {
           if (! handling_fatal_signal) {
             die(2);
           }
         }
       }
     }
     block = 0;
   }
   return;
 }
 }
 static void free_child(struct child *child ) 
 { 
   char token ;
   char *tmp ;
   int *tmp___0 ;
   ssize_t tmp___1 ;
   char *tmp___2 ;
   register unsigned int i ;
   register char **ep ;
   char **tmp___3 ;
 
   {
   if (job_fds[1] >= 0) {
     if (children) {
       token = (char )'+';
       while (1) {
         tmp___1 = write(job_fds[1], (void const   *)(& token), (size_t )1);
         if (! (tmp___1 != 1L)) {
           break;
         }
         tmp___0 = __errno_location();
         if (! (*tmp___0 == 4)) {
           tmp = dcgettext((char const   *)((void *)0), "write jobserver", 5);
           pfatal_with_name(tmp);
         }
       }
       while (1) {
         if (4 & db_level) {
           tmp___2 = dcgettext((char const   *)((void *)0), "Released token for child 0x%08lx (%s).\n",
                               5);
           printf((char const   * __restrict  )tmp___2, (unsigned long )child, (child->file)->name);
           fflush(stdout);
         }
         break;
       }
     }
   }
   if (handling_fatal_signal) {
     return;
   }
   if ((unsigned long )child->command_lines != (unsigned long )((char **)0)) {
     i = 0U;
     while (i < ((child->file)->cmds)->ncommand_lines) {
       free((void *)*(child->command_lines + i));
       i ++;
     }
     free((void *)((char *)child->command_lines));
   }
   if ((unsigned long )child->environment != (unsigned long )((char **)0)) {
     ep = child->environment;
     while ((unsigned long )*ep != (unsigned long )((char *)0)) {
       tmp___3 = ep;
       ep ++;
       free((void *)*tmp___3);
     }
     free((void *)((char *)child->environment));
   }
   free((void *)((char *)child));
   return;
 }
 }
 sigset_t fatal_signal_set ;
 void block_sigs(void) 
 { 
 
 
   {
   sigprocmask(0, (sigset_t const   * __restrict  )(& fatal_signal_set), (sigset_t * __restrict  )((sigset_t *)0));
   return;
 }
 }
 void unblock_sigs(void) 
 { 
   sigset_t empty ;
 
   {
   sigemptyset(& empty);
   sigprocmask(2, (sigset_t const   * __restrict  )(& empty), (sigset_t * __restrict  )((sigset_t *)0));
   return;
 }
 }
 static int bad_stdin  =    -1;
 static void start_job_command(struct child *child ) 
 { 
   register char *p ;
   int flags ;
   char **argv ;
   unsigned short const   **tmp ;
   char *end ;
   char *tmp___0 ;
   int tmp___1 ;
   char const   *tmp___2 ;
   int tmp___3 ;
   int pd[2] ;
   int tmp___4 ;
   int is_remote ;
   int id ;
   int used_stdin ;
   int tmp___5 ;
   int tmp___6 ;
   char **parent_environ ;
   int tmp___7 ;
 
   {
   if (! child->command_ptr) {
     goto next_command;
   }
   flags = (child->file)->command_flags | (int )*(((child->file)->cmds)->lines_flags + (child->command_line - 1U));
   p = child->command_ptr;
   child->noerror = (unsigned int )(flags & 4);
   while ((int )*p != 0) {
     if ((int )*p == 64) {
       flags |= 2;
     } else
     if ((int )*p == 43) {
       flags |= 1;
     } else
     if ((int )*p == 45) {
       child->noerror = 1U;
     } else {
       tmp = __ctype_b_loc();
       if (! ((int const   )*(*tmp + (int )*p) & 1)) {
         break;
       }
     }
     p ++;
   }
   *(((child->file)->cmds)->lines_flags + (child->command_line - 1U)) = (char )((int )*(((child->file)->cmds)->lines_flags + (child->command_line - 1U)) | flags);
   if (question_flag) {
     if (! (flags & 1)) {
       (child->file)->update_status = (short)1;
       notice_finished_file(child->file);
       return;
     }
   }
   p = next_token(p);
   end = (char *)0;
   argv = construct_command_argv(p, & end, child->file, & child->sh_batch_file);
   if ((unsigned long )end == (unsigned long )((void *)0)) {
     child->command_ptr = (char *)((void *)0);
   } else {
     tmp___0 = end;
     end ++;
     *tmp___0 = (char )'\000';
     child->command_ptr = end;
   }
   if (touch_flag) {
     if (! (flags & 1)) {
       free((void *)*(argv + 0));
       free((void *)((char *)argv));
       argv = (char **)0;
     }
   }
   if ((unsigned long )argv == (unsigned long )((char **)0)) {
     next_command: 
     tmp___1 = job_next_command(child);
     if (tmp___1) {
       start_job_command(child);
     } else {
       set_command_state(child->file, 2);
       (child->file)->update_status = (short)0;
       notice_finished_file(child->file);
     }
     return;
   }
   if (just_print_flag) {
     tmp___2 = "%s";
   } else
   if (! (flags & 2)) {
     if (! silent_flag) {
       tmp___2 = "%s";
     } else {
       tmp___2 = (char const   *)((char *)0);
     }
   } else {
     tmp___2 = (char const   *)((char *)0);
   }
   message(0, tmp___2, p);
   if (*(argv + 0)) {
     tmp___3 = strcmp((char const   *)*(argv + 0), "/bin/sh");
     if (! tmp___3) {
       if (*(argv + 1)) {
         if ((int )*(*(argv + 1) + 0) == 45) {
           if ((int )*(*(argv + 1) + 1) == 99) {
             if ((int )*(*(argv + 1) + 2) == 0) {
               if (*(argv + 2)) {
                 if ((int )*(*(argv + 2) + 0) == 58) {
                   if ((int )*(*(argv + 2) + 1) == 0) {
                     if ((unsigned long )*(argv + 3) == (unsigned long )((void *)0)) {
                       free((void *)*(argv + 0));
                       free((void *)((char *)argv));
                       goto next_command;
                     }
                   }
                 }
               }
             }
           }
         }
       }
     }
   }
   commands_started ++;
   if (just_print_flag) {
     if (! (flags & 1)) {
       free((void *)*(argv + 0));
       free((void *)((char *)argv));
       goto next_command;
     }
   }
   fflush(stdout);
   fflush(stderr);
   if (bad_stdin == -1) {
     tmp___4 = pipe((int *)(pd));
     if (tmp___4 == 0) {
       close(pd[1]);
       bad_stdin = pd[0];
       fcntl(bad_stdin, 2, 1);
     }
   }
   child->good_stdin = (unsigned int )(! good_stdin_used);
   if (child->good_stdin) {
     good_stdin_used = 1;
   }
   child->deleted = 0U;
   if ((unsigned long )child->environment == (unsigned long )((char **)0)) {
     child->environment = target_environment(child->file);
   }
   if (child->remote) {
     if (child->good_stdin) {
       tmp___5 = 0;
     } else {
       tmp___5 = bad_stdin;
     }
     tmp___6 = start_remote_job(argv, child->environment, tmp___5, & is_remote, & id,
                                & used_stdin);
     if (tmp___6) {
       goto run_local;
     } else {
       if (child->good_stdin) {
         if (! used_stdin) {
           child->good_stdin = 0U;
           good_stdin_used = 0;
         }
       }
       child->remote = (unsigned int )is_remote;
       child->pid = id;
     }
   } else {
     run_local: 
     block_sigs();
     child->remote = 0U;
     parent_environ = environ;
     child->pid = vfork();
     environ = parent_environ;
     if (child->pid == 0) {
       unblock_sigs();
       if (! (flags & 1)) {
         if (job_fds[0] >= 0) {
           close(job_fds[0]);
           close(job_fds[1]);
         }
       }
       if (job_rfd >= 0) {
         close(job_rfd);
       }
       if (child->good_stdin) {
         tmp___7 = 0;
       } else {
         tmp___7 = bad_stdin;
       }
       child_execute_job(tmp___7, 1, argv, child->environment);
     } else
     if (child->pid < 0) {
       unblock_sigs();
       perror_with_name((char *)"vfork", (char *)"");
       goto error;
     }
   }
   set_command_state(child->file, 2);
   free((void *)*(argv + 0));
   free((void *)((char *)argv));
   return;
   error: 
   (child->file)->update_status = (short)2;
   notice_finished_file(child->file);
   return;
 }
 }
 static int start_waiting_job(struct child *c ) 
 { 
   struct file *f ;
   int tmp ;
   int tmp___0 ;
   char *tmp___1 ;
   char const   *tmp___2 ;
   char *tmp___3 ;
 
   {
   f = c->file;
   tmp = start_remote_job_p(1);
   c->remote = (unsigned int )tmp;
   if (! c->remote) {
     if (job_slots_used > 0U) {
       tmp___0 = load_too_high();
       if (tmp___0) {
         set_command_state(f, 2);
         c->next = waiting_jobs;
         waiting_jobs = c;
         return (0);
       }
     }
   }
   start_job_command(c);
   switch ((unsigned int )f->command_state) {
   case 2U: 
   c->next = children;
   while (1) {
     if (4 & db_level) {
       if (c->remote) {
         tmp___1 = dcgettext((char const   *)((void *)0), " (remote)", 5);
         tmp___2 = (char const   *)tmp___1;
       } else {
         tmp___2 = "";
       }
       tmp___3 = dcgettext((char const   *)((void *)0), "Putting child 0x%08lx (%s) PID %ld%s on the chain.\n",
                           5);
       printf((char const   * __restrict  )tmp___3, (unsigned long )c, (c->file)->name,
              (long )c->pid, tmp___2);
       fflush(stdout);
     }
     break;
   }
   children = c;
   job_slots_used ++;
   unblock_sigs();
   break;
   case 0U: 
   f->update_status = (short)0;
   case 3U: 
   notice_finished_file(f);
   free_child(c);
   break;
   default: 
   if (! ((unsigned int )f->command_state == 3U)) {
     __assert_fail("f->command_state == cs_finished", "job.c", 1313U, "start_waiting_job");
   }
   break;
   }
   return (1);
 }
 }
 void new_job(struct file *file ) 
 { 
   register struct commands *cmds ;
   register struct child *c ;
   char **lines ;
   register unsigned int i ;
   char *tmp ;
   char *in ;
   char *out ;
   char *ref___0 ;
   char openparen ;
   char closeparen ;
   int tmp___0 ;
   int count ;
   char *p ;
   char *tmp___1 ;
   char *tmp___2 ;
   int quoted ;
   char *tmp___3 ;
   char *tmp___4 ;
   unsigned short const   **tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   char *tmp___9 ;
   char token ;
   char *tmp___10 ;
   ssize_t tmp___11 ;
   char *tmp___12 ;
   int *tmp___13 ;
   int *tmp___14 ;
 
   {
   cmds = file->cmds;
   start_waiting_jobs();
   reap_children(0, 0);
   chop_commands(cmds);
   tmp = xmalloc((unsigned int )((unsigned long )cmds->ncommand_lines * sizeof(char *)));
   lines = (char **)tmp;
   i = 0U;
   while (i < cmds->ncommand_lines) {
     out = *(cmds->command_lines + i);
     in = out;
     while (1) {
       ref___0 = strchr((char const   *)in, '$');
       if (! ((unsigned long )ref___0 != (unsigned long )((char *)0))) {
         break;
       }
       ref___0 ++;
       if ((unsigned long )out != (unsigned long )in) {
         memmove((void *)out, (void const   *)in, (size_t )(ref___0 - in));
       }
       out += ref___0 - in;
       in = ref___0;
       if ((int )*ref___0 == 40) {
         goto _L___1;
       } else
       if ((int )*ref___0 == 123) {
         _L___1: /* CIL Label */ 
         openparen = *ref___0;
         if ((int )openparen == 40) {
           tmp___0 = ')';
         } else {
           tmp___0 = '}';
         }
         closeparen = (char )tmp___0;
         tmp___1 = out;
         out ++;
         tmp___2 = in;
         in ++;
         *tmp___1 = *tmp___2;
         count = 0;
         while ((int )*in != 0) {
           if ((int )*in == (int )closeparen) {
             count --;
             if (count < 0) {
               break;
             } else {
               goto _L___0;
             }
           } else
           _L___0: /* CIL Label */ 
           if ((int )*in == 92) {
             if ((int )*(in + 1) == 10) {
               quoted = 0;
               p = in - 1;
               while (1) {
                 if ((unsigned long )p > (unsigned long )ref___0) {
                   if (! ((int )*p == 92)) {
                     break;
                   }
                 } else {
                   break;
                 }
                 quoted = ! quoted;
                 p --;
               }
               if (quoted) {
                 tmp___3 = out;
                 out ++;
                 tmp___4 = in;
                 in ++;
                 *tmp___3 = *tmp___4;
               } else {
                 in = next_token(in + 2);
                 while (1) {
                   if ((unsigned long )out > (unsigned long )ref___0) {
                     tmp___5 = __ctype_b_loc();
                     if (! ((int const   )*(*tmp___5 + (int )*(out + -1)) & 1)) {
                       break;
                     }
                   } else {
                     break;
                   }
                   out --;
                 }
                 tmp___6 = out;
                 out ++;
                 *tmp___6 = (char )' ';
               }
             } else {
               goto _L;
             }
           } else {
             _L: /* CIL Label */ 
             if ((int )*in == (int )openparen) {
               count ++;
             }
             tmp___7 = out;
             out ++;
             tmp___8 = in;
             in ++;
             *tmp___7 = *tmp___8;
           }
         }
       }
     }
     if ((unsigned long )out != (unsigned long )in) {
       strcpy((char * __restrict  )out, (char const   * __restrict  )in);
     }
     *(lines + i) = allocated_variable_expand_for_file(*(cmds->command_lines + i),
                                                       file);
     i ++;
   }
   tmp___9 = xmalloc((unsigned int )sizeof(struct child ));
   c = (struct child *)tmp___9;
   memset((void *)((char *)c), 0, sizeof(struct child ));
   c->file = file;
   c->command_lines = lines;
   c->sh_batch_file = (char *)((void *)0);
   job_next_command(c);
   if (job_slots != 0U) {
     while (job_slots_used == job_slots) {
       reap_children(1, 0);
     }
   } else
   if (job_fds[0] >= 0) {
     while (! (! children)) {
       tmp___11 = read(job_rfd, (void *)(& token), (size_t )1);
       if (tmp___11 == 1L) {
         while (1) {
           if (4 & db_level) {
             tmp___10 = dcgettext((char const   *)((void *)0), "Obtained token for child 0x%08lx (%s).\n",
                                  5);
             printf((char const   * __restrict  )tmp___10, (unsigned long )c, (c->file)->name);
             fflush(stdout);
           }
           break;
         }
         break;
       }
       tmp___13 = __errno_location();
       if (*tmp___13 != 4) {
         tmp___14 = __errno_location();
         if (*tmp___14 != 9) {
           tmp___12 = dcgettext((char const   *)((void *)0), "read jobs pipe", 5);
           pfatal_with_name(tmp___12);
         }
       }
       if (job_rfd < 0) {
         job_rfd = dup(job_fds[0]);
       }
       reap_children(0, 0);
     }
   }
   start_waiting_job(c);
   if (job_slots == 1U) {
     goto _L___2;
   } else
   if (not_parallel) {
     _L___2: /* CIL Label */ 
     while ((unsigned int )file->command_state == 2U) {
       reap_children(1, 0);
     }
   }
   return;
 }
 }
 static int job_next_command(struct child *child ) 
 { 
   unsigned int tmp ;
 
   {
   while (1) {
     if (! ((unsigned long )child->command_ptr == (unsigned long )((char *)0))) {
       if (! ((int )*(child->command_ptr) == 0)) {
         break;
       }
     }
     if (child->command_line == ((child->file)->cmds)->ncommand_lines) {
       child->command_ptr = (char *)0;
       return (0);
     } else {
       tmp = child->command_line;
       (child->command_line) ++;
       child->command_ptr = *(child->command_lines + tmp);
     }
   }
   return (1);
 }
 }
 static int lossage  =    -1;
 static int load_too_high(void) 
 { 
   double load ;
   char *tmp ;
   char *tmp___0 ;
   int *tmp___1 ;
   int *tmp___2 ;
   int *tmp___3 ;
   int tmp___4 ;
 
   {
   if (max_load_average < (double )0) {
     return (0);
   }
   make_access();
   tmp___4 = getloadavg(& load, 1);
   if (tmp___4 != 1) {
     if (lossage == -1) {
       goto _L;
     } else {
       tmp___2 = __errno_location();
       if (*tmp___2 != lossage) {
         _L: /* CIL Label */ 
         tmp___1 = __errno_location();
         if (*tmp___1 == 0) {
           tmp = dcgettext((char const   *)((void *)0), "cannot enforce load limits on this operating system",
                           5);
           error((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
         } else {
           tmp___0 = dcgettext((char const   *)((void *)0), "cannot enforce load limit: ",
                               5);
           perror_with_name(tmp___0, (char *)"getloadavg");
         }
       }
     }
     tmp___3 = __errno_location();
     lossage = *tmp___3;
     load = (double )0;
   }
   user_access();
   return (load >= max_load_average);
 }
 }
 void start_waiting_jobs(void) 
 { 
   struct child *job ;
   int tmp ;
 
   {
   if ((unsigned long )waiting_jobs == (unsigned long )((struct child *)0)) {
     return;
   }
   while (1) {
     reap_children(0, 0);
     job = waiting_jobs;
     waiting_jobs = job->next;
     tmp = start_waiting_job(job);
     if (tmp) {
       if (! ((unsigned long )waiting_jobs != (unsigned long )((struct child *)0))) {
         break;
       }
     } else {
       break;
     }
   }
   return;
 }
 }
 void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) 
 { 
 
 
   {
   if (stdin_fd != 0) {
     dup2(stdin_fd, 0);
   }
   if (stdout_fd != 1) {
     dup2(stdout_fd, 1);
   }
   if (stdin_fd != 0) {
     close(stdin_fd);
   }
   if (stdout_fd != 1) {
     close(stdout_fd);
   }
   exec_command(argv, envp);
   return;
 }
 }
 void exec_command(char **argv , char **envp ) 
 { 
   int *tmp ;
   char *tmp___0 ;
   char *shell ;
   char **new_argv ;
   int argc ;
   void *tmp___1 ;
   char *tmp___2 ;
   int *tmp___3 ;
 
   {
   child_access();
   environ = envp;
   execvp((char const   *)*(argv + 0), (char * const  *)argv);
   tmp = __errno_location();
   switch (*tmp) {
   case 2: 
   tmp___0 = dcgettext((char const   *)((void *)0), "%s: Command not found", 5);
   error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, *(argv + 0));
   break;
   case 8: 
   shell = getenv("SHELL");
   if ((unsigned long )shell == (unsigned long )((char *)0)) {
     shell = default_shell;
   }
   argc = 1;
   while ((unsigned long )*(argv + argc) != (unsigned long )((char *)0)) {
     argc ++;
   }
   tmp___1 = __builtin_alloca((unsigned long )((1 + argc) + 1) * sizeof(char *));
   new_argv = (char **)tmp___1;
   *(new_argv + 0) = shell;
   *(new_argv + 1) = *(argv + 0);
   while (argc > 0) {
     *(new_argv + (1 + argc)) = *(argv + argc);
     argc --;
   }
   execvp((char const   *)shell, (char * const  *)new_argv);
   tmp___3 = __errno_location();
   if (*tmp___3 == 2) {
     tmp___2 = dcgettext((char const   *)((void *)0), "%s: Shell program not found",
                         5);
     error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, shell);
   } else {
     perror_with_name((char *)"execvp: ", shell);
   }
   break;
   default: 
   perror_with_name((char *)"execvp: ", *(argv + 0));
   break;
   }
   _exit(127);
 }
 }
 static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                               char *ifs , char **batch_filename_ptr ) ;
 static char sh_chars[19]  = 
   {      (char )'#',      (char )';',      (char )'\"',      (char )'*', 
         (char )'?',      (char )'[',      (char )']',      (char )'&', 
         (char )'|',      (char )'<',      (char )'>',      (char )'(', 
         (char )')',      (char )'{',      (char )'}',      (char )'$', 
         (char )'`',      (char )'^',      (char )'\000'};
 static char *sh_cmds[25]  = 
   {      (char *)"cd",      (char *)"eval",      (char *)"exec",      (char *)"exit", 
         (char *)"login",      (char *)"logout",      (char *)"set",      (char *)"umask", 
         (char *)"wait",      (char *)"while",      (char *)"for",      (char *)"case", 
         (char *)"if",      (char *)":",      (char *)".",      (char *)"break", 
         (char *)"continue",      (char *)"export",      (char *)"read",      (char *)"readonly", 
         (char *)"shift",      (char *)"times",      (char *)"trap",      (char *)"switch", 
         (char *)0};
 static char minus_c[5]  = {      (char )' ',      (char )'-',      (char )'c',      (char )' ', 
         (char )'\000'};
 static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                               char *ifs , char **batch_filename_ptr ) 
 { 
   register int i ;
   register char *p ;
   register char *ap ;
   char *end ;
   int instring ;
   int word_has_equals ;
   int seen_nonequals ;
   int last_argument_was_empty ;
   char **new_argv ;
   unsigned short const   **tmp ;
   int tmp___0 ;
   size_t tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   size_t tmp___8 ;
   char *tmp___9 ;
   char *tmp___10 ;
   char *tmp___11 ;
   char *tmp___12 ;
   register int j ;
   int tmp___13 ;
   char *tmp___14 ;
   char *tmp___15 ;
   register int j___0 ;
   int tmp___16 ;
   unsigned int shell_len ;
   size_t tmp___17 ;
   unsigned int line_len ;
   size_t tmp___18 ;
   char *new_line ;
   void *tmp___19 ;
   char *command_ptr ;
   size_t tmp___20 ;
   char *tmp___21 ;
   char *tmp___22 ;
   char *tmp___23 ;
   unsigned short const   **tmp___24 ;
   char *tmp___25 ;
   char *tmp___26 ;
   char *tmp___27 ;
 
   {
   new_argv = (char **)0;
   if ((unsigned long )restp != (unsigned long )((void *)0)) {
     *restp = (char *)((void *)0);
   }
   while (1) {
     tmp = __ctype_b_loc();
     if (! ((int const   )*(*tmp + (int )*line) & 1)) {
       break;
     }
     line ++;
   }
   if ((int )*line == 0) {
     return ((char **)0);
   }
   if ((unsigned long )shell == (unsigned long )((char *)0)) {
     shell = default_shell;
   } else {
     tmp___0 = strcmp((char const   *)shell, (char const   *)(default_shell));
     if (tmp___0) {
       goto slow;
     }
   }
   if ((unsigned long )ifs != (unsigned long )((char *)0)) {
     ap = ifs;
     while ((int )*ap != 0) {
       if ((int )*ap != 32) {
         if ((int )*ap != 9) {
           if ((int )*ap != 10) {
             goto slow;
           }
         }
       }
       ap ++;
     }
   }
   tmp___1 = strlen((char const   *)line);
   i = (int )(tmp___1 + 1UL);
   tmp___2 = xmalloc((unsigned int )((unsigned long )i * sizeof(char *)));
   new_argv = (char **)tmp___2;
   tmp___4 = xmalloc((unsigned int )i);
   tmp___3 = tmp___4;
   *(new_argv + 0) = tmp___3;
   ap = tmp___3;
   end = ap + i;
   i = 0;
   last_argument_was_empty = 0;
   seen_nonequals = last_argument_was_empty;
   word_has_equals = seen_nonequals;
   instring = word_has_equals;
   p = line;
   while ((int )*p != 0) {
     if ((unsigned long )ap > (unsigned long )end) {
       abort();
     }
     if (instring) {
       string_char: 
       if ((int )*p == instring) {
         instring = 0;
         if ((unsigned long )ap == (unsigned long )*(new_argv + 0)) {
           last_argument_was_empty = 1;
         } else
         if ((int )*(ap - 1) == 0) {
           last_argument_was_empty = 1;
         }
       } else
       if ((int )*p == 92) {
         if ((int )*(p + 1) == 10) {
           goto swallow_escaped_newline;
         } else {
           goto _L___0;
         }
       } else
       _L___0: /* CIL Label */ 
       if ((int )*p == 10) {
         if ((unsigned long )restp != (unsigned long )((void *)0)) {
           *restp = p;
           goto end_of_line;
         } else {
           goto _L;
         }
       } else
       _L: /* CIL Label */ 
       if (instring == 34) {
         tmp___6 = strchr("\\$`", (int )*p);
         if ((unsigned long )tmp___6 != (unsigned long )((char *)0)) {
           if (unixy_shell) {
             goto slow;
           } else {
             tmp___5 = ap;
             ap ++;
             *tmp___5 = *p;
           }
         } else {
           tmp___5 = ap;
           ap ++;
           *tmp___5 = *p;
         }
       } else {
         tmp___5 = ap;
         ap ++;
         *tmp___5 = *p;
       }
     } else {
       tmp___15 = strchr((char const   *)(sh_chars), (int )*p);
       if ((unsigned long )tmp___15 != (unsigned long )((char *)0)) {
         goto slow;
       } else {
         switch ((int )*p) {
         case 61: 
         if (! seen_nonequals) {
           if (unixy_shell) {
             goto slow;
           }
         }
         word_has_equals = 1;
         tmp___7 = ap;
         ap ++;
         *tmp___7 = (char )'=';
         break;
         case 92: 
         if ((int )*(p + 1) == 10) {
           swallow_escaped_newline: 
           p += 2;
           if ((int )*p == 9) {
             tmp___8 = strlen((char const   *)p);
             memmove((void *)p, (void const   *)(p + 1), tmp___8);
           }
           if (instring) {
             goto string_char;
           } else
           if ((unsigned long )ap != (unsigned long )*(new_argv + i)) {
             goto end_of_arg;
           } else {
             tmp___9 = next_token(p);
             p = tmp___9 - 1;
           }
         } else
         if ((int )*(p + 1) != 0) {
           tmp___10 = ap;
           ap ++;
           p ++;
           *tmp___10 = *p;
         }
         break;
         case 34: 
         case 39: 
         instring = (int )*p;
         break;
         case 10: 
         if ((unsigned long )restp != (unsigned long )((void *)0)) {
           *restp = p;
           goto end_of_line;
         } else {
           tmp___11 = ap;
           ap ++;
           *tmp___11 = (char )'\n';
         }
         break;
         end_of_arg: 
         case 9: 
         case 32: 
         tmp___12 = ap;
         ap ++;
         *tmp___12 = (char )'\000';
         i ++;
         *(new_argv + i) = ap;
         last_argument_was_empty = 0;
         seen_nonequals |= ! word_has_equals;
         if (word_has_equals) {
           if (! seen_nonequals) {
             goto slow;
           }
         }
         word_has_equals = 0;
         if (i == 1) {
           j = 0;
           while ((unsigned long )sh_cmds[j] != (unsigned long )((char *)0)) {
             if ((unsigned long )sh_cmds[j] == (unsigned long )*(new_argv + 0)) {
               goto slow;
             } else
             if ((int )*(sh_cmds[j]) == (int )*(*(new_argv + 0))) {
               if ((int )*(sh_cmds[j]) == 0) {
                 goto slow;
               } else {
                 tmp___13 = strcmp((char const   *)(sh_cmds[j] + 1), (char const   *)(*(new_argv + 0) + 1));
                 if (! tmp___13) {
                   goto slow;
                 }
               }
             }
             j ++;
           }
         }
         p = next_token(p);
         p --;
         break;
         default: 
         tmp___14 = ap;
         ap ++;
         *tmp___14 = *p;
         break;
         }
       }
     }
     p ++;
   }
   end_of_line: 
   if (instring) {
     goto slow;
   }
   *ap = (char )'\000';
   if ((int )*(*(new_argv + i) + 0) != 0) {
     i ++;
   } else
   if (last_argument_was_empty) {
     i ++;
   }
   *(new_argv + i) = (char *)0;
   if (i == 1) {
     j___0 = 0;
     while ((unsigned long )sh_cmds[j___0] != (unsigned long )((char *)0)) {
       if ((unsigned long )sh_cmds[j___0] == (unsigned long )*(new_argv + 0)) {
         goto slow;
       } else
       if ((int )*(sh_cmds[j___0]) == (int )*(*(new_argv + 0))) {
         if ((int )*(sh_cmds[j___0]) == 0) {
           goto slow;
         } else {
           tmp___16 = strcmp((char const   *)(sh_cmds[j___0] + 1), (char const   *)(*(new_argv + 0) + 1));
           if (! tmp___16) {
             goto slow;
           }
         }
       }
       j___0 ++;
     }
   }
   if ((unsigned long )*(new_argv + 0) == (unsigned long )((char *)0)) {
     return ((char **)0);
   } else {
     return (new_argv);
   }
   slow: ;
   if ((unsigned long )new_argv != (unsigned long )((char **)0)) {
     free((void *)*(new_argv + 0));
     free((void *)new_argv);
   }
   tmp___17 = strlen((char const   *)shell);
   shell_len = (unsigned int )tmp___17;
   tmp___18 = strlen((char const   *)line);
   line_len = (unsigned int )tmp___18;
   tmp___19 = __builtin_alloca((((unsigned long )shell_len + (sizeof(minus_c) - 1UL)) + (unsigned long )(line_len * 2U)) + 1UL);
   new_line = (char *)tmp___19;
   command_ptr = (char *)((void *)0);
   ap = new_line;
   memmove((void *)ap, (void const   *)shell, (size_t )shell_len);
   ap += shell_len;
   memmove((void *)ap, (void const   *)(minus_c), sizeof(minus_c) - 1UL);
   ap += sizeof(minus_c) - 1UL;
   command_ptr = ap;
   p = line;
   while ((int )*p != 0) {
     if ((unsigned long )restp != (unsigned long )((void *)0)) {
       if ((int )*p == 10) {
         *restp = p;
         break;
       } else {
         goto _L___1;
       }
     } else
     _L___1: /* CIL Label */ 
     if ((int )*p == 92) {
       if ((int )*(p + 1) == 10) {
         p += 2;
         if ((int )*p == 9) {
           tmp___20 = strlen((char const   *)p);
           memmove((void *)p, (void const   *)(p + 1), tmp___20);
         }
         p = next_token(p);
         p --;
         if (unixy_shell) {
           if (! batch_mode_shell) {
             tmp___21 = ap;
             ap ++;
             *tmp___21 = (char )'\\';
           }
         }
         tmp___22 = ap;
         ap ++;
         *tmp___22 = (char )' ';
         goto __Cont;
       }
     }
     if (unixy_shell) {
       if (! batch_mode_shell) {
         if ((int )*p == 92) {
           tmp___23 = ap;
           ap ++;
           *tmp___23 = (char )'\\';
         } else
         if ((int )*p == 39) {
           tmp___23 = ap;
           ap ++;
           *tmp___23 = (char )'\\';
         } else
         if ((int )*p == 34) {
           tmp___23 = ap;
           ap ++;
           *tmp___23 = (char )'\\';
         } else {
           tmp___24 = __ctype_b_loc();
           if ((int const   )*(*tmp___24 + (int )((unsigned char )*p)) & 8192) {
             tmp___23 = ap;
             ap ++;
             *tmp___23 = (char )'\\';
           } else {
             tmp___25 = strchr((char const   *)(sh_chars), (int )*p);
             if ((unsigned long )tmp___25 != (unsigned long )((char *)0)) {
               tmp___23 = ap;
               ap ++;
               *tmp___23 = (char )'\\';
             }
           }
         }
       }
     }
     tmp___26 = ap;
     ap ++;
     *tmp___26 = *p;
     __Cont: /* CIL Label */ 
     p ++;
   }
   if ((unsigned long )ap == (unsigned long )(((new_line + shell_len) + sizeof(minus_c)) - 1)) {
     return ((char **)0);
   }
   *ap = (char )'\000';
   if (unixy_shell) {
     new_argv = construct_command_argv_internal(new_line, (char **)((void *)0), (char *)0,
                                                (char *)0, (char **)0);
   } else {
     tmp___27 = dcgettext((char const   *)((void *)0), "%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n",
                          5);
     fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27, "job.c",
           2925);
   }
   return (new_argv);
 }
 }
 char **construct_command_argv(char *line , char **restp , struct file *file , char **batch_filename_ptr ) 
 { 
   char *shell ;
   char *ifs ;
   char **argv ;
   int save ;
 
   {
   save = warn_undefined_variables_flag;
   warn_undefined_variables_flag = 0;
   shell = allocated_variable_expand_for_file((char *)"$(SHELL)", file);
   ifs = allocated_variable_expand_for_file((char *)"$(IFS)", file);
   warn_undefined_variables_flag = save;
   argv = construct_command_argv_internal(line, restp, shell, ifs, batch_filename_ptr);
   free((void *)shell);
   free((void *)ifs);
   return (argv);
 }
 }
 #pragma merger("0","/tmp/cil-QjP850rb.i","-g,-O0")
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                   char const   *__locale ) ;
 char *textdomain(char const   *domainname ) ;
 char *bindtextdomain(char const   *domainname , char const   *dirname ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                 int __signo ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                 struct sigaction  const  * __restrict  __act ,
                                                                                 struct sigaction * __restrict  __oact ) ;
 extern struct _IO_FILE *stdin ;
 extern int fclose(FILE *__stream ) ;
 extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                                char const   *__modes ) ;
 extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
 extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                    , ...) ;
 extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
 extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                      FILE * __restrict  __s ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                                size_t __size ) ;
 extern char *optarg ;
 extern int optind ;
 extern int opterr ;
 extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
 extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
 void log_working_directory(int entering ) ;
 FILE *open_tmpfile(char **name , char const   *template ) ;
 void define_default_variables(void) ;
 void set_default_suffixes(void) ;
 void install_default_suffix_rules(void) ;
 void install_default_implicit_rules(void) ;
 void build_vpath_lists(void) ;
 void construct_include_path(char **arg_dirs ) ;
 int just_print_flag  ;
 int silent_flag  ;
 int keep_going_flag  ;
 int print_data_base_flag ;
 int touch_flag  ;
 int env_overrides ;
 int no_builtin_rules_flag ;
 int no_builtin_variables_flag ;
 int print_version_flag ;
 int print_directory_flag ;
 int warn_undefined_variables_flag  ;
 int posix_pedantic  ;
 int not_parallel  ;
 int clock_skew_detected  ;
 char *program  ;
 char *starting_directory  ;
 unsigned int makelevel  ;
 char *version_string ;
 char *remote_description ;
 char *tilde_expand(char *name ) ;
 struct dep *read_all_makefiles(char **makefiles___0 ) ;
 int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) ;
 struct file *default_goal_file  ;
 struct file *default_file  ;
 void define_automatic_variables(void) ;
 struct variable *try_variable_definition(struct floc  const  *flocp , char *line ,
                                          enum variable_origin origin , int target_var ) ;
 void count_implicit_rule_limits(void) ;
 void convert_to_pattern(void) ;
 extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                        struct option  const  *longopts , int *longind ) ;
 void remote_setup(void) ;
 void remote_cleanup(void) ;
 void print_variable_data_base(void) ;
 void print_rule_data_base(void) ;
 void print_vpath_data_base(void) ;
 static void print_data_base(void) ;
 static void print_version(void) ;
 static void decode_switches(int argc , char **argv , int env ) ;
 static void decode_env_switches(char *envar , unsigned int len ) ;
 static void define_makeflags(int all , int makefile ) ;
 static char *quote_for_env(char *out , char *in ) ;
 static struct stringlist *db_flags  ;
 static int debug_flag  =    0;
 int db_level  =    0;
 int env_overrides  =    0;
 int ignore_errors_flag  =    0;
 int print_data_base_flag  =    0;
 int question_flag  =    0;
 int no_builtin_rules_flag  =    0;
 int no_builtin_variables_flag  =    0;
 int default_keep_going_flag  =    0;
 int print_directory_flag  =    0;
 int inhibit_print_directory_flag  =    0;
 int print_version_flag  =    0;
 static struct stringlist *makefiles  =    (struct stringlist *)0;
 unsigned int job_slots  =    1U;
 unsigned int default_job_slots  =    1U;
 static unsigned int inf_jobs  =    0U;
 static struct stringlist *jobserver_fds  =    (struct stringlist *)0;
 int job_fds[2]  = {      -1,      -1};
 int job_rfd  =    -1;
 double max_load_average  =    - 1.0;
 double default_load_average  =    - 1.0;
 static struct stringlist *directories___0  =    (struct stringlist *)0;
 static struct stringlist *include_directories  =    (struct stringlist *)0;
 static struct stringlist *old_files  =    (struct stringlist *)0;
 static struct stringlist *new_files  =    (struct stringlist *)0;
 static int print_usage_flag  =    0;
 static struct command_switch  const  switches[29]  = 
   {      {'b', (enum __anonenum_type_56 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)0, (char *)0, (char *)"Ignored for compatibility"}, 
         {'C', (enum __anonenum_type_56 )2, (char *)(& directories___0), 0U, 0U, 0U, (char *)0,
       (char *)0, (char *)"directory", (char *)"DIRECTORY", (char *)"Change to DIRECTORY before doing anything"}, 
         {'d',
       (enum __anonenum_type_56 )0, (char *)(& debug_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)0, (char *)0, (char *)"Print lots of debugging information"}, 
         {128,
       (enum __anonenum_type_56 )2, (char *)(& db_flags), 1U, 1U, 0U, (char *)"basic",
       (char *)0, (char *)"debug", (char *)"FLAGS", (char *)"Print various types of debugging information"}, 
         {'e',
       (enum __anonenum_type_56 )0, (char *)(& env_overrides), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"environment-overrides", (char *)0, (char *)"Environment variables override makefiles"}, 
         {'f',
       (enum __anonenum_type_56 )2, (char *)(& makefiles), 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)"file", (char *)"FILE", (char *)"Read FILE as a makefile"}, 
         {'h', (enum __anonenum_type_56 )0, (char *)(& print_usage_flag), 0U, 0U, 0U,
       (char *)0, (char *)0, (char *)"help", (char *)0, (char *)"Print this message and exit"}, 
         {'i',
       (enum __anonenum_type_56 )0, (char *)(& ignore_errors_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"ignore-errors", (char *)0, (char *)"Ignore errors from commands"}, 
         {'I',
       (enum __anonenum_type_56 )2, (char *)(& include_directories), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"include-dir", (char *)"DIRECTORY", (char *)"Search DIRECTORY for included makefiles"}, 
         {'j',
       (enum __anonenum_type_56 )3, (char *)(& job_slots), 1U, 1U, 0U, (char *)(& inf_jobs),
       (char *)(& default_job_slots), (char *)"jobs", (char *)"N", (char *)"Allow N jobs at once; infinite jobs with no arg"}, 
         {129,
       (enum __anonenum_type_56 )2, (char *)(& jobserver_fds), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"jobserver-fds", (char *)0, (char *)0}, 
         {'k', (enum __anonenum_type_56 )0, (char *)(& keep_going_flag), 1U, 1U, 0U, (char *)0,
       (char *)(& default_keep_going_flag), (char *)"keep-going", (char *)0, (char *)"Keep going when some targets can\'t be made"}, 
         {'l',
       (enum __anonenum_type_56 )4, (char *)(& max_load_average), 1U, 1U, 0U, (char *)(& default_load_average),
       (char *)(& default_load_average), (char *)"load-average", (char *)"N", (char *)"Don\'t start multiple jobs unless load is below N"}, 
         {'m',
       (enum __anonenum_type_56 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0,
       (char *)0, (char *)"-b"}, 
         {'n', (enum __anonenum_type_56 )0, (char *)(& just_print_flag), 1U, 1U, 1U, (char *)0,
       (char *)0, (char *)"just-print", (char *)0, (char *)"Don\'t actually run any commands; just print them"}, 
         {'o',
       (enum __anonenum_type_56 )2, (char *)(& old_files), 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)"old-file", (char *)"FILE", (char *)"Consider FILE to be very old and don\'t remake it"}, 
         {'p',
       (enum __anonenum_type_56 )0, (char *)(& print_data_base_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"print-data-base", (char *)0, (char *)"Print make\'s internal database"}, 
         {'q',
       (enum __anonenum_type_56 )0, (char *)(& question_flag), 1U, 1U, 1U, (char *)0,
       (char *)0, (char *)"question", (char *)0, (char *)"Run no commands; exit status says if up to date"}, 
         {'r',
       (enum __anonenum_type_56 )0, (char *)(& no_builtin_rules_flag), 1U, 1U, 0U,
       (char *)0, (char *)0, (char *)"no-builtin-rules", (char *)0, (char *)"Disable the built-in implicit rules"}, 
         {'R',
       (enum __anonenum_type_56 )0, (char *)(& no_builtin_variables_flag), 1U, 1U,
       0U, (char *)0, (char *)0, (char *)"no-builtin-variables", (char *)0, (char *)"Disable the built-in variable settings"}, 
         {'s',
       (enum __anonenum_type_56 )0, (char *)(& silent_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"silent", (char *)0, (char *)"Don\'t echo commands"}, 
         {'S', (enum __anonenum_type_56 )1, (char *)(& keep_going_flag), 1U, 1U, 0U, (char *)0,
       (char *)(& default_keep_going_flag), (char *)"no-keep-going", (char *)0, (char *)"Turns off -k"}, 
         {'t',
       (enum __anonenum_type_56 )0, (char *)(& touch_flag), 1U, 1U, 1U, (char *)0,
       (char *)0, (char *)"touch", (char *)0, (char *)"Touch targets instead of remaking them"}, 
         {'v',
       (enum __anonenum_type_56 )0, (char *)(& print_version_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"version", (char *)0, (char *)"Print the version number of make and exit"}, 
         {'w',
       (enum __anonenum_type_56 )0, (char *)(& print_directory_flag), 1U, 1U, 0U, (char *)0,
       (char *)0, (char *)"print-directory", (char *)0, (char *)"Print the current directory"}, 
         {130,
       (enum __anonenum_type_56 )0, (char *)(& inhibit_print_directory_flag), 1U, 1U,
       0U, (char *)0, (char *)0, (char *)"no-print-directory", (char *)0, (char *)"Turn off -w, even if it was turned on implicitly"}, 
         {'W',
       (enum __anonenum_type_56 )2, (char *)(& new_files), 0U, 0U, 0U, (char *)0, (char *)0,
       (char *)"what-if", (char *)"FILE", (char *)"Consider FILE to be infinitely new"}, 
         {131,
       (enum __anonenum_type_56 )0, (char *)(& warn_undefined_variables_flag), 1U,
       1U, 0U, (char *)0, (char *)0, (char *)"warn-undefined-variables", (char *)0,
       (char *)"Warn when an undefined variable is referenced"}, 
         {'\000', 0U, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0, (char *)0,
       (char *)0}};
 static struct option long_option_aliases[9]  = 
   {      {"quiet", 0, (int *)0, 's'}, 
         {"stop", 0, (int *)0, 'S'}, 
         {"new-file", 1, (int *)0, 'W'}, 
         {"assume-new", 1, (int *)0, 'W'}, 
         {"assume-old", 1, (int *)0, 'o'}, 
         {"max-load", 2, (int *)0, 'l'}, 
         {"dry-run", 0, (int *)0, 'n'}, 
         {"recon", 0, (int *)0, 'n'}, 
         {"makefile", 1, (int *)0, 'f'}};
 static struct dep *goals  ;
 static struct dep *lastgoal  ;
 static struct command_variable *command_variables  ;
 char *directory_before_chdir  ;
 sigset_t fatal_signal_set  ;
 static struct file *enter_command_line_file(char *name ) 
 { 
   char *tmp ;
   char *expanded ;
   char *tmp___0 ;
   char *tmp___1 ;
   struct file *tmp___2 ;
 
   {
   if ((int )*(name + 0) == 0) {
     tmp = dcgettext((char const   *)((void *)0), "empty string invalid as file name",
                     5);
     fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
   }
   if ((int )*(name + 0) == 126) {
     tmp___0 = tilde_expand(name);
     expanded = tmp___0;
     if ((unsigned long )expanded != (unsigned long )((char *)0)) {
       name = expanded;
     }
   }
   while (1) {
     if ((int )*(name + 0) == 46) {
       if ((int )*(name + 1) == 47) {
         if (! ((int )*(name + 2) != 0)) {
           break;
         }
       } else {
         break;
       }
     } else {
       break;
     }
     name += 2;
     while ((int )*name == 47) {
       name ++;
     }
   }
   if ((int )*name == 0) {
     while (1) {
       name --;
       if (! ((int )*(name + 0) != 46)) {
         break;
       }
     }
     *(name + 2) = (char )'\000';
   }
   tmp___1 = xstrdup((char const   *)name);
   tmp___2 = enter_file(tmp___1);
   return (tmp___2);
 }
 }
 static void debug_signal_handler(int sig ) 
 { 
 
 
   {
   if (db_level) {
     db_level = 0;
   } else {
     db_level = 1;
   }
   return;
 }
 }
 static void decode_debug_flags(void) 
 { 
   char **pp ;
   char const   *p ;
   int tmp ;
   char *tmp___0 ;
 
   {
   if (debug_flag) {
     db_level = 4095;
   }
   if (! db_flags) {
     return;
   }
   pp = db_flags->list;
   while (*pp) {
     p = (char const   *)*pp;
     while (1) {
       tmp = tolower((int )*(p + 0));
       switch (tmp) {
       case 97: 
       db_level |= 4095;
       break;
       case 98: 
       db_level |= 1;
       break;
       case 105: 
       db_level |= 9;
       break;
       case 106: 
       db_level |= 4;
       break;
       case 109: 
       db_level |= 257;
       break;
       case 118: 
       db_level |= 3;
       break;
       default: 
       tmp___0 = dcgettext((char const   *)((void *)0), "unknown debug level specification `%s\'",
                           5);
       fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, p);
       }
       while (1) {
         p ++;
         if (! ((int const   )*p != 0)) {
           break;
         }
         if ((int const   )*p == 44) {
           break;
         } else
         if ((int const   )*p == 32) {
           break;
         }
       }
       if ((int const   )*p == 0) {
         break;
       }
       p ++;
     }
     pp ++;
   }
   return;
 }
 }
 FILE *open_tmpfile(char **name , char const   *template ) 
 { 
   int fd ;
   size_t tmp ;
   FILE *tmp___0 ;
 
   {
   tmp = strlen(template);
   *name = xmalloc((unsigned int )(tmp + 1UL));
   strcpy((char * __restrict  )*name, (char const   * __restrict  )template);
   fd = mkstemp(*name);
   if (fd == -1) {
     return ((FILE *)0);
   }
   tmp___0 = fdopen(fd, "w");
   return (tmp___0);
 }
 }
 int main(int argc , char **argv , char **envp ) ;
 static char *stdin_nm  =    (char *)0;
 int main(int argc , char **argv , char **envp ) 
 { 
   register struct file *f ;
   register unsigned int i ;
   char **p ;
   struct dep *read_makefiles___0 ;
   char current_directory[4096] ;
   __sighandler_t tmp ;
   __sighandler_t tmp___0 ;
   __sighandler_t tmp___1 ;
   __sighandler_t tmp___2 ;
   __sighandler_t tmp___3 ;
   __sighandler_t tmp___4 ;
   char *tmp___5 ;
   int do_not_define ;
   register char *ep ;
   struct variable *tmp___6 ;
   char *tmp___7 ;
   struct command_variable *cv ;
   struct variable *v ;
   unsigned int len ;
   char *value ;
   char *p___0 ;
   size_t tmp___8 ;
   size_t tmp___9 ;
   void *tmp___10 ;
   char *tmp___11 ;
   char *tmp___12 ;
   char *tmp___13 ;
   char *dir ;
   char *expanded ;
   char *tmp___14 ;
   int tmp___15 ;
   struct variable *v___0 ;
   struct variable *tmp___16 ;
   int tmp___17 ;
   char **tmp___18 ;
   char *tmp___19 ;
   register unsigned int i___0 ;
   FILE *outfile ;
   char *tmp___20 ;
   char *tmp___21 ;
   char buf___1[2048] ;
   unsigned int n ;
   size_t tmp___22 ;
   char *tmp___23 ;
   size_t tmp___24 ;
   int tmp___25 ;
   struct sigaction sa ;
   char **tmp___26 ;
   char *cp ;
   char *tmp___27 ;
   int tmp___28 ;
   char *tmp___29 ;
   int tmp___30 ;
   char *tmp___31 ;
   char *tmp___32 ;
   int *tmp___33 ;
   char *tmp___34 ;
   char c ;
   char *tmp___35 ;
   int tmp___36 ;
   char *tmp___37 ;
   int *tmp___38 ;
   ssize_t tmp___39 ;
   char *tmp___40 ;
   char *tmp___41 ;
   uintmax_t tmp___42 ;
   uintmax_t tmp___43 ;
   uintmax_t *makefile_mtimes ;
   unsigned int mm_idx ;
   char **nargv ;
   int nargc ;
   int orig_db_level ;
   char *tmp___44 ;
   register struct dep *d ;
   register struct dep *last ;
   register struct file *f___0 ;
   char *tmp___45 ;
   char *tmp___46 ;
   unsigned int tmp___47 ;
   uintmax_t tmp___48 ;
   int tmp___49 ;
   int any_remade ;
   int any_failed ;
   register unsigned int i___1 ;
   struct dep *d___0 ;
   uintmax_t tmp___50 ;
   uintmax_t tmp___51 ;
   uintmax_t mtime ;
   char *tmp___52 ;
   uintmax_t tmp___53 ;
   int tmp___54 ;
   char *tmp___55 ;
   char *tmp___56 ;
   char *tmp___57 ;
   char *tmp___58 ;
   register unsigned int i___2 ;
   register unsigned int j ;
   char *p___1 ;
   int tmp___59 ;
   char *tmp___60 ;
   int tmp___61 ;
   char bad ;
   int tmp___62 ;
   char *tmp___63 ;
   char *sgi_loses ;
   void *tmp___64 ;
   int tmp___65 ;
   char **p___2 ;
   char *tmp___66 ;
   char *tmp___67 ;
   int tmp___68 ;
   int *tmp___69 ;
   int status ;
   char *tmp___70 ;
   char *tmp___71 ;
   char *tmp___72 ;
   char *tmp___73 ;
   int tmp___74 ;
   char *tmp___75 ;
 
   {
   default_goal_file = (struct file *)0;
   reading_file = (struct floc  const  *)0;
   setlocale(6, "");
   bindtextdomain("make", "/usr/local/share/locale");
   textdomain("make");
   sigemptyset(& fatal_signal_set);
   tmp = signal(1, & fatal_error_signal);
   if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))1)) {
     signal(1, (void (*)(int  ))1);
   } else {
     sigaddset(& fatal_signal_set, 1);
   }
   tmp___0 = signal(3, & fatal_error_signal);
   if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
     signal(3, (void (*)(int  ))1);
   } else {
     sigaddset(& fatal_signal_set, 3);
   }
   tmp___1 = signal(2, & fatal_error_signal);
   if ((unsigned long )tmp___1 == (unsigned long )((void (*)(int  ))1)) {
     signal(2, (void (*)(int  ))1);
   } else {
     sigaddset(& fatal_signal_set, 2);
   }
   tmp___2 = signal(15, & fatal_error_signal);
   if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))1)) {
     signal(15, (void (*)(int  ))1);
   } else {
     sigaddset(& fatal_signal_set, 15);
   }
   tmp___3 = signal(24, & fatal_error_signal);
   if ((unsigned long )tmp___3 == (unsigned long )((void (*)(int  ))1)) {
     signal(24, (void (*)(int  ))1);
   } else {
     sigaddset(& fatal_signal_set, 24);
   }
   tmp___4 = signal(25, & fatal_error_signal);
   if ((unsigned long )tmp___4 == (unsigned long )((void (*)(int  ))1)) {
     signal(25, (void (*)(int  ))1);
   } else {
     sigaddset(& fatal_signal_set, 25);
   }
   signal(17, (void (*)(int  ))0);
   setlinebuf(stdout);
   if ((unsigned long )*(argv + 0) == (unsigned long )((char *)0)) {
     *(argv + 0) = (char *)"";
   }
   if ((int )*(*(argv + 0) + 0) == 0) {
     program = (char *)"make";
   } else {
     program = strrchr((char const   *)*(argv + 0), '/');
     if ((unsigned long )program == (unsigned long )((char *)0)) {
       program = *(argv + 0);
     } else {
       program ++;
     }
   }
   user_access();
   tmp___5 = getcwd(current_directory, (size_t )4096);
   if ((unsigned long )tmp___5 == (unsigned long )((char *)0)) {
     perror_with_name((char *)"getcwd: ", (char *)"");
     current_directory[0] = (char )'\000';
     directory_before_chdir = (char *)0;
   } else {
     directory_before_chdir = xstrdup((char const   *)(current_directory));
   }
   i = 0U;
   while ((unsigned long )*(envp + i) != (unsigned long )((char *)0)) {
     ep = *(envp + i);
     do_not_define = 0;
     while ((int )*ep != 61) {
       ep ++;
     }
     if (! do_not_define) {
       tmp___6 = define_variable_in_set(*(envp + i), (unsigned int )(ep - *(envp + i)),
                                        ep + 1, (enum variable_origin )1, 1, current_variable_set_list->set,
                                        (struct floc  const  *)((struct floc *)0));
       tmp___6->export = (enum variable_export )0;
     }
     i ++;
   }
   decode_env_switches((char *)"MAKEFLAGS", 9U);
   decode_switches(argc, argv, 0);
   decode_debug_flags();
   if (print_version_flag) {
     print_version();
   } else
   if (print_data_base_flag) {
     print_version();
   } else
   if (db_level) {
     print_version();
   }
   if (print_version_flag) {
     die(0);
   }
   if ((int )current_directory[0] != 0) {
     if ((unsigned long )*(argv + 0) != (unsigned long )((char *)0)) {
       if ((int )*(*(argv + 0) + 0) != 47) {
         tmp___7 = strchr((char const   *)*(argv + 0), '/');
         if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
           *(argv + 0) = concat(current_directory, (char *)"/", *(argv + 0));
         }
       }
     }
   }
   define_variable_in_set((char *)"MAKE_COMMAND", 12U, *(argv + 0), (enum variable_origin )0,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"MAKE", 4U, (char *)"$(MAKE_COMMAND)", (enum variable_origin )0,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
     len = 0U;
     cv = command_variables;
     while ((unsigned long )cv != (unsigned long )((struct command_variable *)0)) {
       v = cv->variable;
       tmp___8 = strlen((char const   *)v->name);
       len = (unsigned int )((size_t )len + 2UL * tmp___8);
       if (! v->recursive) {
         len ++;
       }
       len ++;
       tmp___9 = strlen((char const   *)v->value);
       len = (unsigned int )((size_t )len + 2UL * tmp___9);
       len ++;
       cv = cv->next;
     }
     tmp___10 = __builtin_alloca((unsigned long )len);
     value = (char *)tmp___10;
     p___0 = value;
     cv = command_variables;
     while ((unsigned long )cv != (unsigned long )((struct command_variable *)0)) {
       v = cv->variable;
       p___0 = quote_for_env(p___0, v->name);
       if (! v->recursive) {
         tmp___11 = p___0;
         p___0 ++;
         *tmp___11 = (char )':';
       }
       tmp___12 = p___0;
       p___0 ++;
       *tmp___12 = (char )'=';
       p___0 = quote_for_env(p___0, v->value);
       tmp___13 = p___0;
       p___0 ++;
       *tmp___13 = (char )' ';
       cv = cv->next;
     }
     *(p___0 + -1) = (char )'\000';
     define_variable_in_set((char *)"-*-command-variables-*-", 23U, value, (enum variable_origin )6,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
     define_variable_in_set((char *)"MAKEOVERRIDES", 13U, (char *)"${-*-command-variables-*-}",
                            (enum variable_origin )1, 1, current_variable_set_list->set,
                            (struct floc  const  *)((struct floc *)0));
   }
   if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
     i = 0U;
     while ((unsigned long )*(directories___0->list + i) != (unsigned long )((char *)0)) {
       dir = *(directories___0->list + i);
       if ((int )*(dir + 0) == 126) {
         tmp___14 = tilde_expand(dir);
         expanded = tmp___14;
         if ((unsigned long )expanded != (unsigned long )((char *)0)) {
           dir = expanded;
         }
       }
       tmp___15 = chdir((char const   *)dir);
       if (tmp___15 < 0) {
         pfatal_with_name(dir);
       }
       if ((unsigned long )dir != (unsigned long )*(directories___0->list + i)) {
         free((void *)dir);
       }
       i ++;
     }
   }
   tmp___16 = lookup_variable((char *)"MAKELEVEL", 9U);
   v___0 = tmp___16;
   if ((unsigned long )v___0 != (unsigned long )((struct variable *)0)) {
     if ((int )*(v___0->value) != 0) {
       if ((int )*(v___0->value) != 45) {
         tmp___17 = atoi((char const   *)v___0->value);
         makelevel = (unsigned int )tmp___17;
       } else {
         makelevel = 0U;
       }
     } else {
       makelevel = 0U;
     }
   } else {
     makelevel = 0U;
   }
   if (! silent_flag) {
     if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
       print_directory_flag = 1;
     } else
     if (makelevel > 0U) {
       print_directory_flag = 1;
     }
   }
   if (inhibit_print_directory_flag) {
     print_directory_flag = 0;
   }
   if (no_builtin_variables_flag) {
     no_builtin_rules_flag = 1;
   }
   if ((unsigned long )include_directories == (unsigned long )((struct stringlist *)0)) {
     tmp___18 = (char **)0;
   } else {
     tmp___18 = include_directories->list;
   }
   construct_include_path(tmp___18);
   if ((unsigned long )directories___0 == (unsigned long )((struct stringlist *)0)) {
     starting_directory = current_directory;
   } else {
     tmp___19 = getcwd(current_directory, (size_t )4096);
     if ((unsigned long )tmp___19 == (unsigned long )((char *)0)) {
       perror_with_name((char *)"getcwd: ", (char *)"");
       starting_directory = (char *)0;
     } else {
       starting_directory = current_directory;
     }
   }
   define_variable_in_set((char *)"CURDIR", 6U, current_directory, (enum variable_origin )0,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
     i___0 = 0U;
     while (i___0 < makefiles->idx) {
       if ((int )*(*(makefiles->list + i___0) + 0) == 45) {
         if ((int )*(*(makefiles->list + i___0) + 1) == 0) {
           if (stdin_nm) {
             tmp___20 = dcgettext((char const   *)((void *)0), "Makefile from standard input specified twice.",
                                  5);
             fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___20);
           }
           outfile = open_tmpfile(& stdin_nm, "/tmp/GmXXXXXX");
           if ((unsigned long )outfile == (unsigned long )((FILE *)0)) {
             tmp___21 = dcgettext((char const   *)((void *)0), "fopen (temporary file)",
                                  5);
             pfatal_with_name(tmp___21);
           }
           while (1) {
             tmp___25 = feof(stdin);
             if (tmp___25) {
               break;
             }
             tmp___22 = fread((void * __restrict  )(buf___1), (size_t )1, sizeof(buf___1),
                              (FILE * __restrict  )stdin);
             n = (unsigned int )tmp___22;
             if (n > 0U) {
               tmp___24 = fwrite((void const   * __restrict  )(buf___1), (size_t )1,
                                 (size_t )n, (FILE * __restrict  )outfile);
               if (tmp___24 != (size_t )n) {
                 tmp___23 = dcgettext((char const   *)((void *)0), "fwrite (temporary file)",
                                      5);
                 pfatal_with_name(tmp___23);
               }
             }
           }
           fclose(outfile);
           *(makefiles->list + i___0) = xstrdup((char const   *)stdin_nm);
           f = enter_file(stdin_nm);
           f->updated = 1U;
           f->update_status = (short)0;
           f->command_state = (enum __anonenum_command_state_55 )3;
           f->intermediate = 0U;
           f->dontcare = 0U;
         }
       }
       i___0 ++;
     }
   }
   memset((void *)((char *)(& sa)), 0, sizeof(struct sigaction ));
   sa.__sigaction_handler.sa_handler = & child_handler;
   sa.sa_flags = 536870912;
   sigaction(17, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
   signal(10, & debug_signal_handler);
   set_default_suffixes();
   install_default_suffix_rules();
   define_automatic_variables();
   define_makeflags(0, 0);
   define_default_variables();
   default_file = enter_file((char *)".DEFAULT");
   if ((unsigned long )makefiles == (unsigned long )((struct stringlist *)0)) {
     tmp___26 = (char **)0;
   } else {
     tmp___26 = makefiles->list;
   }
   read_makefiles___0 = read_all_makefiles(tmp___26);
   decode_env_switches((char *)"MAKEFLAGS", 9U);
   if (jobserver_fds) {
     i = 1U;
     while (i < jobserver_fds->idx) {
       if (! ((unsigned long )*(jobserver_fds->list + 0) == (unsigned long )*(jobserver_fds->list + i))) {
         if ((int )*(*(jobserver_fds->list + 0)) == (int )*(*(jobserver_fds->list + i))) {
           if (! ((int )*(*(jobserver_fds->list + 0)) == 0)) {
             tmp___28 = strcmp((char const   *)(*(jobserver_fds->list + 0) + 1), (char const   *)(*(jobserver_fds->list + i) + 1));
             if (tmp___28) {
               tmp___27 = dcgettext((char const   *)((void *)0), "internal error: multiple --jobserver-fds options",
                                    5);
               fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27);
             }
           }
         } else {
           tmp___27 = dcgettext((char const   *)((void *)0), "internal error: multiple --jobserver-fds options",
                                5);
           fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27);
         }
       }
       i ++;
     }
     cp = *(jobserver_fds->list + 0);
     tmp___30 = sscanf((char const   * __restrict  )cp, (char const   * __restrict  )"%d,%d",
                       & job_fds[0], & job_fds[1]);
     if (tmp___30 != 2) {
       tmp___29 = dcgettext((char const   *)((void *)0), "internal error: invalid --jobserver-fds string `%s\'",
                            5);
       fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___29, cp);
     }
     if (job_slots > 0U) {
       tmp___31 = dcgettext((char const   *)((void *)0), "warning: -jN forced in submake: disabling jobserver mode.",
                            5);
       error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___31);
     } else {
       job_rfd = dup(job_fds[0]);
       if (job_rfd < 0) {
         tmp___33 = __errno_location();
         if (*tmp___33 != 9) {
           tmp___32 = dcgettext((char const   *)((void *)0), "dup jobserver", 5);
           pfatal_with_name(tmp___32);
         }
         tmp___34 = dcgettext((char const   *)((void *)0), "warning: jobserver unavailable: using -j1.  Add `+\' to parent make rule.",
                              5);
         error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___34);
         job_slots = 1U;
       }
     }
     if (job_slots > 0U) {
       close(job_fds[0]);
       close(job_fds[1]);
       job_fds[1] = -1;
       job_fds[0] = job_fds[1];
       free((void *)jobserver_fds->list);
       free((void *)jobserver_fds);
       jobserver_fds = (struct stringlist *)0;
     }
   }
   if (job_slots > 1U) {
     c = (char )'+';
     tmp___36 = pipe((int *)(job_fds));
     if (tmp___36 < 0) {
       tmp___35 = dcgettext((char const   *)((void *)0), "creating jobs pipe", 5);
       pfatal_with_name(tmp___35);
     } else {
       job_rfd = dup(job_fds[0]);
       if (job_rfd < 0) {
         tmp___35 = dcgettext((char const   *)((void *)0), "creating jobs pipe", 5);
         pfatal_with_name(tmp___35);
       }
     }
     while (1) {
       job_slots --;
       if (! job_slots) {
         break;
       }
       while (1) {
         tmp___39 = write(job_fds[1], (void const   *)(& c), (size_t )1);
         if (! (tmp___39 != 1L)) {
           break;
         }
         tmp___38 = __errno_location();
         if (! (*tmp___38 == 4)) {
           tmp___37 = dcgettext((char const   *)((void *)0), "init jobserver pipe",
                                5);
           pfatal_with_name(tmp___37);
         }
       }
     }
     tmp___40 = xmalloc((unsigned int )sizeof(struct stringlist ));
     jobserver_fds = (struct stringlist *)tmp___40;
     tmp___41 = xmalloc((unsigned int )sizeof(char *));
     jobserver_fds->list = (char **)tmp___41;
     *(jobserver_fds->list + 0) = xmalloc((unsigned int )(sizeof("1024") * 2UL + 1UL));
     sprintf((char * __restrict  )*(jobserver_fds->list + 0), (char const   * __restrict  )"%d,%d",
             job_fds[0], job_fds[1]);
     jobserver_fds->idx = 1U;
     jobserver_fds->max = 1U;
   }
   define_makeflags(1, 0);
   snap_deps();
   convert_to_pattern();
   install_default_implicit_rules();
   count_implicit_rule_limits();
   build_vpath_lists();
   if ((unsigned long )old_files != (unsigned long )((struct stringlist *)0)) {
     p = old_files->list;
     while ((unsigned long )*p != (unsigned long )((char *)0)) {
       f = enter_command_line_file(*p);
       tmp___42 = (uintmax_t )1;
       f->mtime_before_update = tmp___42;
       f->last_mtime = tmp___42;
       f->updated = 1U;
       f->update_status = (short)0;
       f->command_state = (enum __anonenum_command_state_55 )3;
       p ++;
     }
   }
   if ((unsigned long )new_files != (unsigned long )((struct stringlist *)0)) {
     p = new_files->list;
     while ((unsigned long )*p != (unsigned long )((char *)0)) {
       f = enter_command_line_file(*p);
       tmp___43 = 0xfffffffffffffffeUL;
       f->mtime_before_update = tmp___43;
       f->last_mtime = tmp___43;
       p ++;
     }
   }
   remote_setup();
   if ((unsigned long )read_makefiles___0 != (unsigned long )((struct dep *)0)) {
     makefile_mtimes = (uintmax_t *)0;
     mm_idx = 0U;
     nargv = argv;
     nargc = argc;
     orig_db_level = db_level;
     if (! (256 & db_level)) {
       db_level = 0;
     }
     while (1) {
       if (1 & db_level) {
         tmp___44 = dcgettext((char const   *)((void *)0), "Updating makefiles....\n",
                              5);
         printf((char const   * __restrict  )tmp___44);
         fflush(stdout);
       }
       break;
     }
     last = (struct dep *)0;
     d = read_makefiles___0;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       f___0 = d->file;
       if (f___0->double_colon) {
         f___0 = f___0->double_colon;
         while ((unsigned long )f___0 != (unsigned long )((void *)0)) {
           if ((unsigned long )f___0->deps == (unsigned long )((struct dep *)0)) {
             if ((unsigned long )f___0->cmds != (unsigned long )((struct commands *)0)) {
               while (1) {
                 if (2 & db_level) {
                   tmp___45 = dcgettext((char const   *)((void *)0), "Makefile `%s\' might loop; not remaking it.\n",
                                        5);
                   printf((char const   * __restrict  )tmp___45, f___0->name);
                   fflush(stdout);
                 }
                 break;
               }
               if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
                 read_makefiles___0 = d->next;
               } else {
                 last->next = d->next;
               }
               free((void *)((char *)d));
               if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
                 d = read_makefiles___0;
               } else {
                 d = last->next;
               }
               break;
             }
           }
           f___0 = f___0->prev;
         }
       }
       if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
         goto _L;
       } else
       if (! f___0->double_colon) {
         _L: /* CIL Label */ 
         tmp___46 = xrealloc((char *)makefile_mtimes, (unsigned int )((unsigned long )(mm_idx + 1U) * sizeof(uintmax_t )));
         makefile_mtimes = (uintmax_t *)tmp___46;
         tmp___47 = mm_idx;
         mm_idx ++;
         if ((d->file)->last_mtime) {
           *(makefile_mtimes + tmp___47) = (d->file)->last_mtime;
         } else {
           tmp___48 = f_mtime(d->file, 0);
           *(makefile_mtimes + tmp___47) = tmp___48;
         }
         last = d;
         d = d->next;
       }
     }
     define_makeflags(1, 1);
     tmp___49 = update_goal_chain(read_makefiles___0, 1);
     switch (tmp___49) {
     default: 
     __assert_fail("BOGUS_UPDATE_STATUS", "main.c", 1641U, "main");
     break;
     case -1: 
     break;
     case 2: 
     any_remade = 0;
     any_failed = 0;
     i___1 = 0U;
     d___0 = read_makefiles___0;
     while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
       (d___0->file)->considered = 0U;
       if ((d___0->file)->updated) {
         if ((int )(d___0->file)->update_status == 0) {
           if ((d___0->file)->last_mtime) {
             tmp___51 = (d___0->file)->last_mtime;
           } else {
             tmp___50 = f_mtime(d___0->file, 0);
             tmp___51 = tmp___50;
           }
           any_remade |= tmp___51 != *(makefile_mtimes + i___1);
         } else
         if (! (d___0->changed & (1 << 2))) {
           tmp___52 = dcgettext((char const   *)((void *)0), "Failed to remake makefile `%s\'.",
                                5);
           error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___52,
                 (d___0->file)->name);
           if ((d___0->file)->last_mtime) {
             mtime = (d___0->file)->last_mtime;
           } else {
             tmp___53 = f_mtime(d___0->file, 0);
             mtime = tmp___53;
           }
           if (mtime != 0xffffffffffffffffUL) {
             if (mtime != *(makefile_mtimes + i___1)) {
               tmp___54 = 1;
             } else {
               tmp___54 = 0;
             }
           } else {
             tmp___54 = 0;
           }
           any_remade |= tmp___54;
         }
       } else
       if (! (d___0->changed & (1 << 2))) {
         if (d___0->changed & (1 << 1)) {
           if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
             tmp___55 = (d___0->file)->name;
           } else {
             tmp___55 = d___0->name;
           }
           tmp___56 = dcgettext((char const   *)((void *)0), "Included makefile `%s\' was not found.",
                                5);
           error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___56,
                 tmp___55);
         } else {
           if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
             tmp___57 = (d___0->file)->name;
           } else {
             tmp___57 = d___0->name;
           }
           tmp___58 = dcgettext((char const   *)((void *)0), "Makefile `%s\' was not found",
                                5);
           error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___58,
                 tmp___57);
           any_failed = 1;
         }
       }
       i___1 ++;
       d___0 = d___0->next;
     }
     read_makefiles___0 = (struct dep *)0;
     if (any_remade) {
       goto re_exec;
     }
     if (any_failed) {
       die(2);
     }
     break;
     re_exec: 
     case 0: 
     remove_intermediates(0);
     if (print_data_base_flag) {
       print_data_base();
     }
     log_working_directory(0);
     if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
       j = 0U;
       i___2 = 1U;
       while (i___2 < (unsigned int )argc) {
         tmp___59 = strncmp((char const   *)*(argv + i___2), "-f", (size_t )2);
         if (tmp___59 == 0) {
           p___1 = *(argv + i___2) + 2;
           if ((int )*p___1 == 0) {
             i___2 ++;
             *(argv + i___2) = *(makefiles->list + j);
           } else {
             *(argv + i___2) = concat((char *)"-f", *(makefiles->list + j), (char *)"");
           }
           j ++;
         }
         i___2 ++;
       }
     }
     if (stdin_nm) {
       tmp___60 = xmalloc((unsigned int )((unsigned long )(nargc + 2) * sizeof(char *)));
       nargv = (char **)tmp___60;
       memmove((void *)((char *)nargv), (void const   *)((char *)argv), (unsigned long )argc * sizeof(char *));
       tmp___61 = nargc;
       nargc ++;
       *(nargv + tmp___61) = concat((char *)"-o", stdin_nm, (char *)"");
       *(nargv + nargc) = (char *)0;
     }
     if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
       if (directories___0->idx > 0U) {
         if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
           tmp___62 = chdir((char const   *)directory_before_chdir);
           if (tmp___62 < 0) {
             perror_with_name((char *)"chdir", (char *)"");
             bad = (char)1;
           } else {
             bad = (char)0;
           }
         } else {
           bad = (char)1;
         }
         if (bad) {
           tmp___63 = dcgettext((char const   *)((void *)0), "Couldn\'t change back to original directory.",
                                5);
           fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___63);
         }
       }
     }
     p = environ;
     while ((unsigned long )*p != (unsigned long )((char *)0)) {
       tmp___65 = strncmp((char const   *)*p, "MAKELEVEL=", (size_t )10);
       if (tmp___65 == 0) {
         tmp___64 = __builtin_alloca(40UL);
         sgi_loses = (char *)tmp___64;
         *p = sgi_loses;
         sprintf((char * __restrict  )*p, (char const   * __restrict  )"MAKELEVEL=%u",
                 makelevel);
         break;
       }
       p ++;
     }
     if (1 & db_level) {
       tmp___66 = dcgettext((char const   *)((void *)0), "Re-executing:", 5);
       fputs((char const   * __restrict  )tmp___66, (FILE * __restrict  )stdout);
       p___2 = nargv;
       while ((unsigned long )*p___2 != (unsigned long )((char *)0)) {
         printf((char const   * __restrict  )" %s", *p___2);
         p___2 ++;
       }
       putchar('\n');
     }
     fflush(stdout);
     fflush(stderr);
     if (job_rfd >= 0) {
       close(job_rfd);
     }
     exec_command(nargv, environ);
     }
     db_level = orig_db_level;
   }
   define_makeflags(1, 0);
   if (stdin_nm) {
     tmp___68 = unlink((char const   *)stdin_nm);
     if (tmp___68 < 0) {
       tmp___69 = __errno_location();
       if (*tmp___69 != 2) {
         tmp___67 = dcgettext((char const   *)((void *)0), "unlink (temporary file): ",
                              5);
         perror_with_name(tmp___67, stdin_nm);
       }
     }
   }
   if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
     if ((unsigned long )default_goal_file != (unsigned long )((struct file *)0)) {
       tmp___70 = xmalloc((unsigned int )sizeof(struct dep ));
       goals = (struct dep *)tmp___70;
       goals->next = (struct dep *)0;
       goals->name = (char *)0;
       goals->file = default_goal_file;
     }
   } else {
     lastgoal->next = (struct dep *)0;
   }
   if (! goals) {
     if ((unsigned long )read_makefiles___0 == (unsigned long )((struct dep *)0)) {
       tmp___71 = dcgettext((char const   *)((void *)0), "No targets specified and no makefile found",
                            5);
       fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___71);
     }
     tmp___72 = dcgettext((char const   *)((void *)0), "No targets", 5);
     fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___72);
   }
   while (1) {
     if (1 & db_level) {
       tmp___73 = dcgettext((char const   *)((void *)0), "Updating goal targets....\n",
                            5);
       printf((char const   * __restrict  )tmp___73);
       fflush(stdout);
     }
     break;
   }
   tmp___74 = update_goal_chain(goals, 0);
   switch (tmp___74) {
   case 0: 
   case -1: 
   status = 0;
   break;
   case 2: 
   status = 2;
   break;
   case 1: 
   status = 1;
   break;
   default: 
   abort();
   }
   if (clock_skew_detected) {
     tmp___75 = dcgettext((char const   *)((void *)0), "warning:  Clock skew detected.  Your build may be incomplete.",
                          5);
     error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___75);
   }
   die(status);
   return (0);
 }
 }
 static char options[1UL + (sizeof(switches) / sizeof(switches[0])) * 3UL]  ;
 static struct option long_options[sizeof(switches) / sizeof(switches[0]) + sizeof(long_option_aliases) / sizeof(long_option_aliases[0])]  ;
 static void init_switches(void) 
 { 
   register char *p ;
   register int c ;
   register unsigned int i ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   unsigned int tmp___3 ;
 
   {
   if ((int )options[0] != 0) {
     return;
   }
   p = options;
   tmp = p;
   p ++;
   *tmp = (char )'-';
   i = 0U;
   while (switches[i].c != 0) {
     if ((unsigned long )switches[i].long_name == (unsigned long )((char * const  )0)) {
       long_options[i].name = "";
     } else {
       long_options[i].name = (char const   *)switches[i].long_name;
     }
     long_options[i].flag = (int *)0;
     long_options[i].val = (int )switches[i].c;
     if (switches[i].c <= 127) {
       tmp___0 = p;
       p ++;
       *tmp___0 = (char )switches[i].c;
     }
     switch ((unsigned int const   )switches[i].type) {
     case 5U: 
     case 1U: 
     case 0U: 
     long_options[i].has_arg = 0;
     break;
     case 4U: 
     case 3U: 
     case 2U: 
     if (switches[i].c <= 127) {
       tmp___1 = p;
       p ++;
       *tmp___1 = (char )':';
     }
     if ((unsigned long )switches[i].noarg_value != (unsigned long )((char * const  )0)) {
       if (switches[i].c <= 127) {
         tmp___2 = p;
         p ++;
         *tmp___2 = (char )':';
       }
       long_options[i].has_arg = 2;
     } else {
       long_options[i].has_arg = 1;
     }
     break;
     }
     i ++;
   }
   *p = (char )'\000';
   c = 0;
   while ((unsigned long )c < sizeof(long_option_aliases) / sizeof(long_option_aliases[0])) {
     tmp___3 = i;
     i ++;
     long_options[tmp___3] = long_option_aliases[c];
     c ++;
   }
   long_options[i].name = (char const   *)0;
   return;
 }
 }
 static void handle_non_switch_argument(char *arg , int env ) 
 { 
   struct variable *v ;
   struct command_variable *cv ;
   char *tmp ;
   struct file *f ;
   struct file *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   struct variable *v___0 ;
   char *value ;
   unsigned int oldlen ;
   unsigned int newlen ;
   size_t tmp___3 ;
   size_t tmp___4 ;
   void *tmp___5 ;
 
   {
   if ((int )*(arg + 0) == 45) {
     if ((int )*(arg + 1) == 0) {
       return;
     }
   }
   v = try_variable_definition((struct floc  const  *)0, arg, (enum variable_origin )4,
                               0);
   if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
     tmp = xmalloc((unsigned int )sizeof(*cv));
     cv = (struct command_variable *)tmp;
     cv->variable = v;
     cv->next = command_variables;
     command_variables = cv;
   } else
   if (! env) {
     tmp___0 = enter_command_line_file(arg);
     f = tmp___0;
     f->cmd_target = 1U;
     if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
       tmp___1 = xmalloc((unsigned int )sizeof(struct dep ));
       goals = (struct dep *)tmp___1;
       lastgoal = goals;
     } else {
       tmp___2 = xmalloc((unsigned int )sizeof(struct dep ));
       lastgoal->next = (struct dep *)tmp___2;
       lastgoal = lastgoal->next;
     }
     lastgoal->name = (char *)0;
     lastgoal->file = f;
     v___0 = lookup_variable((char *)"MAKECMDGOALS", 12U);
     if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
       value = f->name;
     } else {
       tmp___3 = strlen((char const   *)v___0->value);
       oldlen = (unsigned int )tmp___3;
       tmp___4 = strlen((char const   *)f->name);
       newlen = (unsigned int )tmp___4;
       tmp___5 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));
       value = (char *)tmp___5;
       memmove((void *)value, (void const   *)v___0->value, (size_t )oldlen);
       *(value + oldlen) = (char )' ';
       memmove((void *)(value + (oldlen + 1U)), (void const   *)f->name, (size_t )(newlen + 1U));
     }
     define_variable_in_set((char *)"MAKECMDGOALS", 12U, value, (enum variable_origin )0,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   }
   return;
 }
 }
 static void print_usage(int bad ) 
 { 
   register struct command_switch  const  *cs ;
   FILE *usageto ;
   char *tmp ;
   char *tmp___0 ;
   char buf___1[1024] ;
   char shortarg[50] ;
   char longarg[50] ;
   char *p ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   size_t tmp___5 ;
   unsigned int i ;
   char const   *tmp___6 ;
   size_t tmp___7 ;
   size_t tmp___8 ;
   struct command_switch  const  *ncs ;
   size_t tmp___9 ;
   size_t tmp___10 ;
   char *tmp___11 ;
   char *tmp___12 ;
 
   {
   if (print_version_flag) {
     print_version();
   }
   if (bad) {
     usageto = stderr;
   } else {
     usageto = stdout;
   }
   tmp = dcgettext((char const   *)((void *)0), "Usage: %s [options] [target] ...\n",
                   5);
   fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )tmp, program);
   tmp___0 = dcgettext((char const   *)((void *)0), "Options:\n", 5);
   fputs((char const   * __restrict  )tmp___0, (FILE * __restrict  )usageto);
   cs = switches;
   while (cs->c != 0) {
     if (! cs->description) {
       goto __Cont;
     } else
     if ((int )*(cs->description + 0) == 45) {
       goto __Cont;
     }
     switch (long_options[cs - switches].has_arg) {
     case 0: 
     longarg[0] = (char )'\000';
     shortarg[0] = longarg[0];
     break;
     case 1: 
     tmp___1 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);
     sprintf((char * __restrict  )(longarg), (char const   * __restrict  )"=%s", tmp___1);
     tmp___2 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);
     sprintf((char * __restrict  )(shortarg), (char const   * __restrict  )" %s", tmp___2);
     break;
     case 2: 
     tmp___3 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);
     sprintf((char * __restrict  )(longarg), (char const   * __restrict  )"[=%s]",
             tmp___3);
     tmp___4 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                         5);
     sprintf((char * __restrict  )(shortarg), (char const   * __restrict  )" [%s]",
             tmp___4);
     break;
     }
     p = buf___1;
     if (cs->c <= 127) {
       sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"  -%c%s",
               cs->c, shortarg);
       tmp___5 = strlen((char const   *)p);
       p += tmp___5;
     }
     if ((unsigned long )cs->long_name != (unsigned long )((char * const  )0)) {
       if (! (cs->c <= 127)) {
         tmp___6 = "  ";
       } else {
         tmp___6 = ", ";
       }
       sprintf((char * __restrict  )p, (char const   * __restrict  )"%s--%s%s", tmp___6,
               cs->long_name, longarg);
       tmp___7 = strlen((char const   *)p);
       p += tmp___7;
       i = 0U;
       while ((unsigned long )i < sizeof(long_option_aliases) / sizeof(long_option_aliases[0])) {
         if (long_option_aliases[i].val == (int )cs->c) {
           sprintf((char * __restrict  )p, (char const   * __restrict  )", --%s%s",
                   long_option_aliases[i].name, longarg);
           tmp___8 = strlen((char const   *)p);
           p += tmp___8;
         }
         i ++;
       }
     }
     ncs = cs;
     while (1) {
       ncs ++;
       if (! (ncs->c != 0)) {
         break;
       }
       if (ncs->description) {
         if ((int )*(ncs->description + 0) == 45) {
           if ((int )*(ncs->description + 1) == (int )cs->c) {
             sprintf((char * __restrict  )p, (char const   * __restrict  )", -%c%s",
                     ncs->c, shortarg);
             tmp___9 = strlen((char const   *)p);
             p += tmp___9;
             if ((unsigned long )ncs->long_name != (unsigned long )((char * const  )0)) {
               sprintf((char * __restrict  )p, (char const   * __restrict  )", --%s%s",
                       ncs->long_name, longarg);
               tmp___10 = strlen((char const   *)p);
               p += tmp___10;
             }
           }
         }
       }
     }
     if (p - buf___1 > 28L) {
       fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )"%s\n", buf___1);
       buf___1[0] = (char )'\000';
     }
     tmp___11 = dcgettext((char const   *)((void *)0), (char const   *)cs->description,
                          5);
     fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )"%*s%s.\n",
             -30, buf___1, tmp___11);
     __Cont: /* CIL Label */ 
     cs ++;
   }
   tmp___12 = dcgettext((char const   *)((void *)0), "\nReport bugs to <bug-make@gnu.org>.\n",
                        5);
   fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )tmp___12);
   return;
 }
 }
 static void decode_switches(int argc , char **argv , int env ) 
 { 
   int bad ;
   register struct command_switch  const  *cs ;
   register struct stringlist *sl ;
   register int c ;
   int doit ;
   int tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   unsigned int tmp___3 ;
   int tmp___4 ;
   int i ;
   int tmp___5 ;
   char *tmp___6 ;
   int tmp___7 ;
   double tmp___8 ;
   int tmp___9 ;
   int tmp___10 ;
 
   {
   bad = 0;
   init_switches();
   opterr = ! env;
   optind = 0;
   while (optind < argc) {
     c = getopt_long(argc, (char * const  *)argv, (char const   *)(options), (struct option  const  *)(long_options),
                     (int *)0);
     if (c == -1) {
       break;
     } else
     if (c == 1) {
       handle_non_switch_argument(optarg, env);
     } else
     if (c == 63) {
       bad = 1;
     } else {
       cs = switches;
       while (cs->c != 0) {
         if (cs->c == (int const   )c) {
           if (! env) {
             tmp = 1;
           } else
           if (cs->env) {
             tmp = 1;
           } else {
             tmp = 0;
           }
           doit = tmp;
           switch ((unsigned int const   )cs->type) {
           default: 
           abort();
           case 5U: 
           break;
           case 1U: 
           case 0U: 
           if (doit) {
             *((int *)cs->value_ptr) = (unsigned int const   )cs->type == 0U;
           }
           break;
           case 2U: 
           if (! doit) {
             break;
           }
           if ((unsigned long )optarg == (unsigned long )((char *)0)) {
             optarg = (char *)cs->noarg_value;
           }
           sl = *((struct stringlist **)cs->value_ptr);
           if ((unsigned long )sl == (unsigned long )((struct stringlist *)0)) {
             tmp___0 = xmalloc((unsigned int )sizeof(struct stringlist ));
             sl = (struct stringlist *)tmp___0;
             sl->max = 5U;
             sl->idx = 0U;
             tmp___1 = xmalloc((unsigned int )(5UL * sizeof(char *)));
             sl->list = (char **)tmp___1;
             *((struct stringlist **)cs->value_ptr) = sl;
           } else
           if (sl->idx == sl->max - 1U) {
             sl->max += 5U;
             tmp___2 = xrealloc((char *)sl->list, (unsigned int )((unsigned long )sl->max * sizeof(char *)));
             sl->list = (char **)tmp___2;
           }
           tmp___3 = sl->idx;
           (sl->idx) ++;
           *(sl->list + tmp___3) = optarg;
           *(sl->list + sl->idx) = (char *)0;
           break;
           case 3U: 
           if ((unsigned long )optarg == (unsigned long )((char *)0)) {
             if (argc > optind) {
               if ((unsigned int )*(*(argv + optind) + 0) - 48U <= 9U) {
                 tmp___4 = optind;
                 optind ++;
                 optarg = *(argv + tmp___4);
               }
             }
           }
           if (! doit) {
             break;
           }
           if ((unsigned long )optarg != (unsigned long )((char *)0)) {
             tmp___5 = atoi((char const   *)optarg);
             i = tmp___5;
             if (i < 1) {
               if (doit) {
                 tmp___6 = dcgettext((char const   *)((void *)0), "the `-%c\' option requires a positive integral argument",
                                     5);
                 error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                       cs->c);
               }
               bad = 1;
             } else {
               *((unsigned int *)cs->value_ptr) = (unsigned int )i;
             }
           } else {
             *((unsigned int *)cs->value_ptr) = *((unsigned int *)cs->noarg_value);
           }
           break;
           case 4U: 
           if ((unsigned long )optarg == (unsigned long )((char *)0)) {
             if (optind < argc) {
               if ((unsigned int )*(*(argv + optind) + 0) - 48U <= 9U) {
                 tmp___7 = optind;
                 optind ++;
                 optarg = *(argv + tmp___7);
               } else
               if ((int )*(*(argv + optind) + 0) == 46) {
                 tmp___7 = optind;
                 optind ++;
                 optarg = *(argv + tmp___7);
               }
             }
           }
           if (doit) {
             if ((unsigned long )optarg != (unsigned long )((char *)0)) {
               tmp___8 = atof((char const   *)optarg);
               *((double *)cs->value_ptr) = tmp___8;
             } else {
               *((double *)cs->value_ptr) = *((double *)cs->noarg_value);
             }
           }
           break;
           }
           break;
         }
         cs ++;
       }
     }
   }
   while (optind < argc) {
     tmp___9 = optind;
     optind ++;
     handle_non_switch_argument(*(argv + tmp___9), env);
   }
   if (! env) {
     if (bad) {
       goto _L;
     } else
     if (print_usage_flag) {
       _L: /* CIL Label */ 
       print_usage(bad);
       if (bad) {
         tmp___10 = 2;
       } else {
         tmp___10 = 0;
       }
       die(tmp___10);
     }
   }
   return;
 }
 }
 static void decode_env_switches(char *envar , unsigned int len ) 
 { 
   char *varref ;
   void *tmp ;
   char *value ;
   char *p ;
   int argc ;
   char **argv ;
   size_t tmp___0 ;
   void *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   unsigned short const   **tmp___4 ;
   unsigned short const   **tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
 
   {
   tmp = __builtin_alloca((unsigned long )((2U + len) + 2U));
   varref = (char *)tmp;
   *(varref + 0) = (char )'$';
   *(varref + 1) = (char )'(';
   memmove((void *)(varref + 2), (void const   *)envar, (size_t )len);
   *(varref + (2U + len)) = (char )')';
   *(varref + ((2U + len) + 1U)) = (char )'\000';
   value = variable_expand(varref);
   value = next_token(value);
   tmp___0 = strlen((char const   *)value);
   len = (unsigned int )tmp___0;
   if (len == 0U) {
     return;
   }
   tmp___1 = __builtin_alloca((unsigned long )((1U + len) + 1U) * sizeof(char *));
   argv = (char **)tmp___1;
   tmp___2 = xmalloc(2U * len);
   p = tmp___2;
   *(argv + 0) = (char *)0;
   argc = 1;
   *(argv + argc) = p;
   while ((int )*value != 0) {
     if ((int )*value == 92) {
       if ((int )*(value + 1) != 0) {
         value ++;
       } else {
         goto _L;
       }
     } else {
       _L: /* CIL Label */ 
       tmp___5 = __ctype_b_loc();
       if ((int const   )*(*tmp___5 + (int )*value) & 1) {
         tmp___3 = p;
         p ++;
         *tmp___3 = (char )'\000';
         argc ++;
         *(argv + argc) = p;
         while (1) {
           value ++;
           tmp___4 = __ctype_b_loc();
           if (! ((int const   )*(*tmp___4 + (int )*value) & 1)) {
             break;
           }
         }
         continue;
       }
     }
     tmp___6 = p;
     p ++;
     tmp___7 = value;
     value ++;
     *tmp___6 = *tmp___7;
   }
   *p = (char )'\000';
   argc ++;
   *(argv + argc) = (char *)0;
   if ((int )*(*(argv + 1) + 0) != 45) {
     tmp___8 = strchr((char const   *)*(argv + 1), '=');
     if ((unsigned long )tmp___8 == (unsigned long )((char *)0)) {
       *(argv + 1) = concat((char *)"-", *(argv + 1), (char *)"");
     }
   }
   decode_switches(argc, argv, 1);
   return;
 }
 }
 static char *quote_for_env(char *out , char *in ) 
 { 
   char *tmp ;
   char *tmp___0 ;
   unsigned short const   **tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
 
   {
   while ((int )*in != 0) {
     if ((int )*in == 36) {
       tmp = out;
       out ++;
       *tmp = (char )'$';
     } else {
       tmp___1 = __ctype_b_loc();
       if ((int const   )*(*tmp___1 + (int )*in) & 1) {
         tmp___0 = out;
         out ++;
         *tmp___0 = (char )'\\';
       } else
       if ((int )*in == 92) {
         tmp___0 = out;
         out ++;
         *tmp___0 = (char )'\\';
       }
     }
     tmp___2 = out;
     out ++;
     tmp___3 = in;
     in ++;
     *tmp___2 = *tmp___3;
   }
   return (out);
 }
 }
 static char const   ref[17]  = 
   {      (char const   )'$',      (char const   )'(',      (char const   )'M',      (char const   )'A', 
         (char const   )'K',      (char const   )'E',      (char const   )'O',      (char const   )'V', 
         (char const   )'E',      (char const   )'R',      (char const   )'R',      (char const   )'I', 
         (char const   )'D',      (char const   )'E',      (char const   )'S',      (char const   )')', 
         (char const   )'\000'};
 static char const   posixref[27]  = 
   {      (char const   )'$',      (char const   )'(',      (char const   )'-',      (char const   )'*', 
         (char const   )'-',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
         (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
         (char const   )'-',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
         (char const   )'i',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
         (char const   )'e',      (char const   )'s',      (char const   )'-',      (char const   )'*', 
         (char const   )'-',      (char const   )')',      (char const   )'\000'};
 static void define_makeflags(int all , int makefile ) 
 { 
   register struct command_switch  const  *cs ;
   char *flagstring ;
   register char *p ;
   unsigned int words ;
   struct variable *v ;
   struct flag *flags ;
   unsigned int flagslen ;
   struct flag *new ;
   void *tmp ;
   size_t tmp___0 ;
   struct flag *new___0 ;
   void *tmp___1 ;
   size_t tmp___2 ;
   struct flag *new___1 ;
   void *tmp___3 ;
   size_t tmp___4 ;
   char *buf___1 ;
   void *tmp___5 ;
   struct flag *new___2 ;
   void *tmp___6 ;
   size_t tmp___7 ;
   size_t tmp___8 ;
   struct flag *new___3 ;
   void *tmp___9 ;
   size_t tmp___10 ;
   char *buf___2 ;
   void *tmp___11 ;
   struct flag *new___4 ;
   void *tmp___12 ;
   size_t tmp___13 ;
   size_t tmp___14 ;
   struct stringlist *sl ;
   register unsigned int i ;
   struct flag *new___5 ;
   void *tmp___15 ;
   size_t tmp___16 ;
   size_t tmp___17 ;
   unsigned int tmp___18 ;
   void *tmp___19 ;
   char *tmp___20 ;
   char *tmp___21 ;
   char *tmp___22 ;
   char *tmp___23 ;
   char *tmp___24 ;
   size_t tmp___25 ;
   char *tmp___26 ;
   char *tmp___27 ;
   char *tmp___28 ;
   char *tmp___29 ;
   char *tmp___30 ;
   char *tmp___31 ;
   char *tmp___32 ;
   char *tmp___33 ;
   char *tmp___34 ;
   int tmp___35 ;
 
   {
   flags = (struct flag *)0;
   flagslen = 0U;
   cs = switches;
   while (cs->c != 0) {
     if (cs->toenv) {
       if (! makefile) {
         goto _L___4;
       } else
       if (! cs->no_makefile) {
         _L___4: /* CIL Label */ 
         switch ((unsigned int const   )cs->type) {
         default: 
         abort();
         case 5U: 
         break;
         case 1U: 
         case 0U: 
         if (! *((int *)cs->value_ptr) == ((unsigned int const   )cs->type == 1U)) {
           if ((unsigned long )cs->default_value == (unsigned long )((char * const  )0)) {
             goto _L;
           } else
           if (*((int *)cs->value_ptr) != *((int *)cs->default_value)) {
             _L: /* CIL Label */ 
             while (1) {
               tmp = __builtin_alloca(sizeof(struct flag ));
               new = (struct flag *)tmp;
               new->cs = cs;
               new->arg = (char *)0;
               new->next = flags;
               flags = new;
               if ((unsigned long )new->arg == (unsigned long )((char *)0)) {
                 flagslen ++;
               } else {
                 flagslen += 4U;
               }
               if (! (cs->c <= 127)) {
                 tmp___0 = strlen((char const   *)cs->long_name);
                 flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___0));
               }
               break;
             }
           }
         }
         break;
         case 3U: 
         if (all) {
           if ((unsigned long )cs->default_value != (unsigned long )((char * const  )0)) {
             if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->default_value)) {
               break;
             } else {
               goto _L___1;
             }
           } else
           _L___1: /* CIL Label */ 
           if ((unsigned long )cs->noarg_value != (unsigned long )((char * const  )0)) {
             if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->noarg_value)) {
               while (1) {
                 tmp___1 = __builtin_alloca(sizeof(struct flag ));
                 new___0 = (struct flag *)tmp___1;
                 new___0->cs = cs;
                 new___0->arg = (char *)"";
                 new___0->next = flags;
                 flags = new___0;
                 if ((unsigned long )new___0->arg == (unsigned long )((char *)0)) {
                   flagslen ++;
                 } else {
                   flagslen += 4U;
                 }
                 if (! (cs->c <= 127)) {
                   tmp___2 = strlen((char const   *)cs->long_name);
                   flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___2));
                 }
                 break;
               }
             } else {
               goto _L___0;
             }
           } else
           _L___0: /* CIL Label */ 
           if (cs->c == 106) {
             while (1) {
               tmp___3 = __builtin_alloca(sizeof(struct flag ));
               new___1 = (struct flag *)tmp___3;
               new___1->cs = cs;
               new___1->arg = (char *)"1";
               new___1->next = flags;
               flags = new___1;
               if ((unsigned long )new___1->arg == (unsigned long )((char *)0)) {
                 flagslen ++;
               } else {
                 flagslen += 7U;
               }
               if (! (cs->c <= 127)) {
                 tmp___4 = strlen((char const   *)cs->long_name);
                 flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___4));
               }
               break;
             }
           } else {
             tmp___5 = __builtin_alloca(30UL);
             buf___1 = (char *)tmp___5;
             sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%u",
                     *((unsigned int *)cs->value_ptr));
             while (1) {
               tmp___6 = __builtin_alloca(sizeof(struct flag ));
               new___2 = (struct flag *)tmp___6;
               new___2->cs = cs;
               new___2->arg = buf___1;
               new___2->next = flags;
               flags = new___2;
               if ((unsigned long )new___2->arg == (unsigned long )((char *)0)) {
                 flagslen ++;
               } else {
                 tmp___7 = strlen((char const   *)buf___1);
                 flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___7));
               }
               if (! (cs->c <= 127)) {
                 tmp___8 = strlen((char const   *)cs->long_name);
                 flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___8));
               }
               break;
             }
           }
         }
         break;
         case 4U: 
         if (all) {
           if ((unsigned long )cs->default_value != (unsigned long )((char * const  )0)) {
             if (*((double *)cs->value_ptr) == *((double *)cs->default_value)) {
               break;
             } else {
               goto _L___3;
             }
           } else
           _L___3: /* CIL Label */ 
           if ((unsigned long )cs->noarg_value != (unsigned long )((char * const  )0)) {
             if (*((double *)cs->value_ptr) == *((double *)cs->noarg_value)) {
               while (1) {
                 tmp___9 = __builtin_alloca(sizeof(struct flag ));
                 new___3 = (struct flag *)tmp___9;
                 new___3->cs = cs;
                 new___3->arg = (char *)"";
                 new___3->next = flags;
                 flags = new___3;
                 if ((unsigned long )new___3->arg == (unsigned long )((char *)0)) {
                   flagslen ++;
                 } else {
                   flagslen += 4U;
                 }
                 if (! (cs->c <= 127)) {
                   tmp___10 = strlen((char const   *)cs->long_name);
                   flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___10));
                 }
                 break;
               }
             } else {
               goto _L___2;
             }
           } else {
             _L___2: /* CIL Label */ 
             tmp___11 = __builtin_alloca(100UL);
             buf___2 = (char *)tmp___11;
             sprintf((char * __restrict  )buf___2, (char const   * __restrict  )"%g",
                     *((double *)cs->value_ptr));
             while (1) {
               tmp___12 = __builtin_alloca(sizeof(struct flag ));
               new___4 = (struct flag *)tmp___12;
               new___4->cs = cs;
               new___4->arg = buf___2;
               new___4->next = flags;
               flags = new___4;
               if ((unsigned long )new___4->arg == (unsigned long )((char *)0)) {
                 flagslen ++;
               } else {
                 tmp___13 = strlen((char const   *)buf___2);
                 flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___13));
               }
               if (! (cs->c <= 127)) {
                 tmp___14 = strlen((char const   *)cs->long_name);
                 flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___14));
               }
               break;
             }
           }
         }
         break;
         case 2U: 
         if (all) {
           sl = *((struct stringlist **)cs->value_ptr);
           if ((unsigned long )sl != (unsigned long )((struct stringlist *)0)) {
             i = sl->idx;
             while (1) {
               tmp___18 = i;
               i --;
               if (! (tmp___18 > 0U)) {
                 break;
               }
               while (1) {
                 tmp___15 = __builtin_alloca(sizeof(struct flag ));
                 new___5 = (struct flag *)tmp___15;
                 new___5->cs = cs;
                 new___5->arg = *(sl->list + i);
                 new___5->next = flags;
                 flags = new___5;
                 if ((unsigned long )new___5->arg == (unsigned long )((char *)0)) {
                   flagslen ++;
                 } else {
                   tmp___16 = strlen((char const   *)*(sl->list + i));
                   flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___16));
                 }
                 if (! (cs->c <= 127)) {
                   tmp___17 = strlen((char const   *)cs->long_name);
                   flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___17));
                 }
                 break;
               }
             }
           }
         }
         break;
         }
       }
     }
     cs ++;
   }
   flagslen = (unsigned int )((unsigned long )flagslen + (4UL + sizeof(posixref)));
   tmp___19 = __builtin_alloca((unsigned long )((1U + flagslen) + 1U));
   flagstring = (char *)tmp___19;
   memset((void *)flagstring, 0, (size_t )((1U + flagslen) + 1U));
   p = flagstring;
   words = 1U;
   tmp___20 = p;
   p ++;
   *tmp___20 = (char )'-';
   while ((unsigned long )flags != (unsigned long )((struct flag *)0)) {
     if ((flags->cs)->c <= 127) {
       tmp___21 = p;
       p ++;
       *tmp___21 = (char )(flags->cs)->c;
     } else {
       if ((int )*p != 45) {
         tmp___22 = p;
         p ++;
         *tmp___22 = (char )' ';
         tmp___23 = p;
         p ++;
         *tmp___23 = (char )'-';
       }
       tmp___24 = p;
       p ++;
       *tmp___24 = (char )'-';
       strcpy((char * __restrict  )p, (char const   * __restrict  )(flags->cs)->long_name);
       tmp___25 = strlen((char const   *)p);
       p += tmp___25;
     }
     if ((unsigned long )flags->arg != (unsigned long )((char *)0)) {
       if ((int )*(flags->arg + 0) != 0) {
         tmp___26 = p;
         p ++;
         if (! ((flags->cs)->c <= 127)) {
           *tmp___26 = (char )'=';
         } else {
           *tmp___26 = (char )' ';
         }
         p = quote_for_env(p, flags->arg);
       }
       words ++;
       tmp___27 = p;
       p ++;
       *tmp___27 = (char )' ';
       tmp___28 = p;
       p ++;
       *tmp___28 = (char )'-';
     } else
     if (! ((flags->cs)->c <= 127)) {
       words ++;
       tmp___29 = p;
       p ++;
       *tmp___29 = (char )' ';
       tmp___30 = p;
       p ++;
       *tmp___30 = (char )'-';
     }
     flags = flags->next;
   }
   if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
     *(flagstring + 0) = (char )'\000';
   } else
   if ((int )*(p + -1) == 45) {
     p -= 2;
     *p = (char )'\000';
   } else {
     *p = (char )'\000';
   }
   define_variable_in_set((char *)"MFLAGS", 6U, flagstring, (enum variable_origin )1,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   if (all) {
     if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
       if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
         p = flagstring;
       } else {
         if ((int )*(p + -1) != 45) {
           tmp___31 = p;
           p ++;
           *tmp___31 = (char )' ';
           tmp___32 = p;
           p ++;
           *tmp___32 = (char )'-';
         }
         tmp___33 = p;
         p ++;
         *tmp___33 = (char )'-';
         tmp___34 = p;
         p ++;
         *tmp___34 = (char )' ';
       }
       if (posix_pedantic) {
         memmove((void *)p, (void const   *)(posixref), sizeof(posixref) - 1UL);
         p += sizeof(posixref) - 1UL;
       } else {
         memmove((void *)p, (void const   *)(ref), sizeof(ref) - 1UL);
         p += sizeof(ref) - 1UL;
       }
     } else {
       goto _L___5;
     }
   } else
   _L___5: /* CIL Label */ 
   if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
     words = 0U;
     p --;
   } else
   if ((int )*(p + -1) == 45) {
     p -= 2;
   }
   *p = (char )'\000';
   if ((int )*(flagstring + 0) == 45) {
     if ((int )*(flagstring + 1) != 45) {
       tmp___35 = 1;
     } else {
       tmp___35 = 0;
     }
   } else {
     tmp___35 = 0;
   }
   v = define_variable_in_set((char *)"MAKEFLAGS", 9U, flagstring + tmp___35, (enum variable_origin )2,
                              1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   if (! all) {
     v->export = (enum variable_export )0;
   }
   return;
 }
 }
 char *make_host ;
 static int printed_version  =    0;
 static void print_version(void) 
 { 
   char *precede ;
   char const   *tmp ;
   char *tmp___0 ;
 
   {
   if (print_data_base_flag) {
     tmp = "# ";
   } else {
     tmp = "";
   }
   precede = (char *)tmp;
   if (printed_version) {
     return;
   }
   printf((char const   * __restrict  )"%sGNU Make version %s", precede, version_string);
   if ((unsigned long )remote_description != (unsigned long )((char *)0)) {
     if ((int )*remote_description != 0) {
       printf((char const   * __restrict  )"-%s", remote_description);
     }
   }
   tmp___0 = dcgettext((char const   *)((void *)0), ", by Richard Stallman and Roland McGrath.\n%sBuilt for %s\n%sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n%s\tFree Software Foundation, Inc.\n%sThis is free software; see the source for copying conditions.\n%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n%sPARTICULAR PURPOSE.\n\n%sReport bugs to <bug-make@gnu.org>.\n\n",
                       5);
   printf((char const   * __restrict  )tmp___0, precede, make_host, precede, precede,
          precede, precede, precede, precede);
   printed_version = 1;
   fflush(stdout);
   return;
 }
 }
 static void print_data_base(void) 
 { 
   time_t when ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
 
   {
   when = time((time_t *)0);
   tmp = ctime((time_t const   *)(& when));
   tmp___0 = dcgettext((char const   *)((void *)0), "\n# Make data base, printed on %s",
                       5);
   printf((char const   * __restrict  )tmp___0, tmp);
   print_variable_data_base();
   print_dir_data_base();
   print_rule_data_base();
   print_file_data_base();
   print_vpath_data_base();
   when = time((time_t *)0);
   tmp___1 = ctime((time_t const   *)(& when));
   tmp___2 = dcgettext((char const   *)((void *)0), "\n# Finished Make data base on %s\n",
                       5);
   printf((char const   * __restrict  )tmp___2, tmp___1);
   return;
 }
 }
 static char dying  =    (char)0;
  __attribute__((__noreturn__)) void die(int status ) ;
 void die(int status ) 
 { 
   int err ;
 
   {
   if (! dying) {
     dying = (char)1;
     if (print_version_flag) {
       print_version();
     }
     err = status != 0;
     while (job_slots_used > 0U) {
       reap_children(1, err);
       err = 0;
     }
     remote_cleanup();
     remove_intermediates(0);
     if (print_data_base_flag) {
       print_data_base();
     }
     if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
       chdir((char const   *)directory_before_chdir);
     }
     log_working_directory(0);
   }
   exit(status);
 }
 }
 static int entered  =    0;
 void log_working_directory(int entering ) 
 { 
   char *msg ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
 
   {
   if (entering) {
     tmp = dcgettext((char const   *)((void *)0), "Entering", 5);
     tmp___1 = tmp;
   } else {
     tmp___0 = dcgettext((char const   *)((void *)0), "Leaving", 5);
     tmp___1 = tmp___0;
   }
   msg = tmp___1;
   if (! print_directory_flag) {
     return;
   } else
   if (entering == entered) {
     return;
   }
   entered = entering;
   if (print_data_base_flag) {
     fputs((char const   * __restrict  )"# ", (FILE * __restrict  )stdout);
   }
   if (makelevel == 0U) {
     printf((char const   * __restrict  )"%s: %s ", program, msg);
   } else {
     printf((char const   * __restrict  )"%s[%u]: %s ", program, makelevel, msg);
   }
   if ((unsigned long )starting_directory == (unsigned long )((char *)0)) {
     tmp___2 = dcgettext((char const   *)((void *)0), "an unknown directory", 5);
     puts((char const   *)tmp___2);
   } else {
     tmp___3 = dcgettext((char const   *)((void *)0), "directory `%s\'\n", 5);
     printf((char const   * __restrict  )tmp___3, starting_directory);
   }
   return;
 }
 }
 /* compiler builtin: 
    void __builtin_va_start(__builtin_va_list  ) ;  */
 /* compiler builtin: 
    void __builtin_va_end(__builtin_va_list  ) ;  */
 #pragma merger("0","/tmp/cil-jXxeXTt3.i","-g,-O0")
 extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
 extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                     __gnuc_va_list __arg ) ;
 extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
 extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
 extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
 extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
 extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
 __leaf__)) realloc)(void *__ptr , size_t __size ) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
 extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int errnum ) ;
 void collapse_continuations(char *line ) ;
 void remove_comments(char *line ) ;
 char *find_char_unquote(char *string , char *stopchars , int blank ) ;
 struct dep *copy_dep_chain(struct dep *d ) ;
 int alpha_compare(void const   *v1 , void const   *v2 ) 
 { 
   char const   *s1 ;
   char const   *s2 ;
   int tmp ;
 
   {
   s1 = (char const   *)*((char **)v1);
   s2 = (char const   *)*((char **)v2);
   if ((int const   )*s1 != (int const   )*s2) {
     return ((int )((int const   )*s1 - (int const   )*s2));
   }
   tmp = strcmp(s1, s2);
   return (tmp);
 }
 }
 void collapse_continuations(char *line ) 
 { 
   register char *in ;
   register char *out ;
   register char *p ;
   register int backslash ;
   register unsigned int bs_write ;
   char *tmp ;
   unsigned int tmp___0 ;
   unsigned short const   **tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
 
   {
   in = strchr((char const   *)line, '\n');
   if ((unsigned long )in == (unsigned long )((char *)0)) {
     return;
   }
   out = in;
   while (1) {
     if ((unsigned long )out > (unsigned long )line) {
       if (! ((int )*(out + -1) == 92)) {
         break;
       }
     } else {
       break;
     }
     out --;
   }
   while ((int )*in != 0) {
     backslash = 0;
     bs_write = 0U;
     p = in - 1;
     while (1) {
       if ((unsigned long )p >= (unsigned long )line) {
         if (! ((int )*p == 92)) {
           break;
         }
       } else {
         break;
       }
       if (backslash) {
         bs_write ++;
       }
       backslash = ! backslash;
       if ((unsigned long )in == (unsigned long )(out - 1)) {
         abort();
       }
       p --;
     }
     while (1) {
       tmp___0 = bs_write;
       bs_write --;
       if (! (tmp___0 > 0U)) {
         break;
       }
       tmp = out;
       out ++;
       *tmp = (char )'\\';
     }
     in ++;
     if (backslash) {
       in = next_token(in);
       while (1) {
         if ((unsigned long )out > (unsigned long )line) {
           tmp___1 = __ctype_b_loc();
           if (! ((int const   )*(*tmp___1 + (int )*(out + -1)) & 1)) {
             break;
           }
         } else {
           break;
         }
         out --;
       }
       tmp___2 = out;
       out ++;
       *tmp___2 = (char )' ';
     } else {
       tmp___3 = out;
       out ++;
       *tmp___3 = (char )'\n';
     }
     while ((int )*in != 0) {
       if ((int )*in == 92) {
         p = in + 1;
         while ((int )*p == 92) {
           p ++;
         }
         if ((int )*p == 10) {
           in = p;
           break;
         }
         while ((unsigned long )in < (unsigned long )p) {
           tmp___4 = out;
           out ++;
           tmp___5 = in;
           in ++;
           *tmp___4 = *tmp___5;
         }
       } else {
         tmp___6 = out;
         out ++;
         tmp___7 = in;
         in ++;
         *tmp___6 = *tmp___7;
       }
     }
   }
   *out = (char )'\000';
   return;
 }
 }
 void remove_comments(char *line ) 
 { 
   char *comment ;
 
   {
   comment = find_char_unquote(line, (char *)"#", 0);
   if ((unsigned long )comment != (unsigned long )((char *)0)) {
     *comment = (char )'\000';
   }
   return;
 }
 }
 void print_spaces(unsigned int n ) 
 { 
   unsigned int tmp ;
 
   {
   while (1) {
     tmp = n;
     n --;
     if (! (tmp > 0U)) {
       break;
     }
     putchar(' ');
   }
   return;
 }
 }
 char *concat(char *s1 , char *s2 , char *s3 ) 
 { 
   register unsigned int len1 ;
   register unsigned int len2 ;
   register unsigned int len3 ;
   register char *result___0 ;
   size_t tmp ;
   size_t tmp___0 ;
   size_t tmp___1 ;
   char *tmp___2 ;
 
   {
   if ((int )*s1 != 0) {
     tmp = strlen((char const   *)s1);
     len1 = (unsigned int )tmp;
   } else {
     len1 = 0U;
   }
   if ((int )*s2 != 0) {
     tmp___0 = strlen((char const   *)s2);
     len2 = (unsigned int )tmp___0;
   } else {
     len2 = 0U;
   }
   if ((int )*s3 != 0) {
     tmp___1 = strlen((char const   *)s3);
     len3 = (unsigned int )tmp___1;
   } else {
     len3 = 0U;
   }
   tmp___2 = xmalloc(((len1 + len2) + len3) + 1U);
   result___0 = tmp___2;
   if ((int )*s1 != 0) {
     memmove((void *)result___0, (void const   *)s1, (size_t )len1);
   }
   if ((int )*s2 != 0) {
     memmove((void *)(result___0 + len1), (void const   *)s2, (size_t )len2);
   }
   if ((int )*s3 != 0) {
     memmove((void *)((result___0 + len1) + len2), (void const   *)s3, (size_t )len3);
   }
   *(((result___0 + len1) + len2) + len3) = (char )'\000';
   return (result___0);
 }
 }
 void ( /* format attribute */  message)(int prefix , char const   *fmt  , ...) 
 { 
   va_list args ;
 
   {
   log_working_directory(1);
   if ((unsigned long )fmt != (unsigned long )((char const   *)0)) {
     if (prefix) {
       if (makelevel == 0U) {
         printf((char const   * __restrict  )"%s: ", program);
       } else {
         printf((char const   * __restrict  )"%s[%u]: ", program, makelevel);
       }
     }
     __builtin_va_start(args, fmt);
     vfprintf((FILE * __restrict  )stdout, (char const   * __restrict  )fmt, args);
     __builtin_va_end(args);
     putchar('\n');
   }
   fflush(stdout);
   return;
 }
 }
 void ( /* format attribute */  error)(struct floc  const  *flocp , char const   *fmt 
                                       , ...) 
 { 
   va_list args ;
 
   {
   log_working_directory(1);
   if (flocp) {
     if (flocp->filenm) {
       fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%lu: ",
               flocp->filenm, flocp->lineno);
     } else {
       goto _L;
     }
   } else
   _L: /* CIL Label */ 
   if (makelevel == 0U) {
     fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", program);
   } else {
     fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s[%u]: ",
             program, makelevel);
   }
   __builtin_va_start(args, fmt);
   vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
   __builtin_va_end(args);
   _IO_putc('\n', stderr);
   fflush(stderr);
   return;
 }
 }
  __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(struct floc  const  *flocp ,
                                                                      char const   *fmt 
                                                                      , ...) ;
 void ( /* format attribute */  fatal)(struct floc  const  *flocp , char const   *fmt 
                                       , ...) 
 { 
   va_list args ;
   char *tmp ;
 
   {
   log_working_directory(1);
   if (flocp) {
     if (flocp->filenm) {
       fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%lu: *** ",
               flocp->filenm, flocp->lineno);
     } else {
       goto _L;
     }
   } else
   _L: /* CIL Label */ 
   if (makelevel == 0U) {
     fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: *** ",
             program);
   } else {
     fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s[%u]: *** ",
             program, makelevel);
   }
   __builtin_va_start(args, fmt);
   vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
   __builtin_va_end(args);
   tmp = dcgettext((char const   *)((void *)0), ".  Stop.\n", 5);
   fputs((char const   * __restrict  )tmp, (FILE * __restrict  )stderr);
   die(2);
 }
 }
 void perror_with_name(char *str , char *name ) 
 { 
   int *tmp ;
   char *tmp___0 ;
 
   {
   tmp = __errno_location();
   tmp___0 = strerror(*tmp);
   error((struct floc  const  *)((struct floc *)0), "%s%s: %s", str, name, tmp___0);
   return;
 }
 }
  __attribute__((__noreturn__)) void pfatal_with_name(char *name ) ;
 void pfatal_with_name(char *name ) 
 { 
   int *tmp ;
   char *tmp___0 ;
 
   {
   tmp = __errno_location();
   tmp___0 = strerror(*tmp);
   fatal((struct floc  const  *)((struct floc *)0), "%s: %s", name, tmp___0);
 }
 }
 char *xmalloc(unsigned int size ) 
 { 
   char *result___0 ;
   void *tmp ;
   char *tmp___0 ;
 
   {
   tmp = malloc((size_t )size);
   result___0 = (char *)tmp;
   if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
     tmp___0 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
     fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0);
   }
   return (result___0);
 }
 }
 char *xrealloc(char *ptr , unsigned int size ) 
 { 
   char *result___0 ;
   void *tmp ;
   void *tmp___0 ;
   char *tmp___1 ;
 
   {
   if (ptr) {
     tmp = realloc((void *)ptr, (size_t )size);
     result___0 = (char *)tmp;
   } else {
     tmp___0 = malloc((size_t )size);
     result___0 = (char *)tmp___0;
   }
   if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
     tmp___1 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
     fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1);
   }
   return (result___0);
 }
 }
 char *xstrdup(char const   *ptr ) 
 { 
   char *result___0 ;
   char *tmp ;
 
   {
   result___0 = strdup(ptr);
   if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
     tmp = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
     fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
   }
   return (result___0);
 }
 }
 char *savestring(char const   *str , unsigned int length___0 ) 
 { 
   register char *out ;
   char *tmp ;
 
   {
   tmp = xmalloc(length___0 + 1U);
   out = tmp;
   if (length___0 > 0U) {
     memmove((void *)out, (void const   *)str, (size_t )length___0);
   }
   *(out + length___0) = (char )'\000';
   return (out);
 }
 }
 char *sindex(char const   *big , unsigned int blen , char const   *small , unsigned int slen ) 
 { 
   size_t tmp ;
   size_t tmp___0 ;
   register unsigned int b ;
   int tmp___1 ;
 
   {
   if (! blen) {
     tmp = strlen(big);
     blen = (unsigned int )tmp;
   }
   if (! slen) {
     tmp___0 = strlen(small);
     slen = (unsigned int )tmp___0;
   }
   if (slen) {
     if (blen >= slen) {
       slen --;
       blen -= slen;
       b = 0U;
       while (b < blen) {
         if ((int const   )*big == (int const   )*small) {
           tmp___1 = strncmp(big + 1, small + 1, (size_t )slen);
           if (tmp___1 == 0) {
             return ((char *)big);
           }
         }
         b ++;
         big ++;
       }
     }
   }
   return ((char *)0);
 }
 }
 char *lindex(char const   *s , char const   *limit , int c ) 
 { 
   char const   *tmp ;
 
   {
   while ((unsigned long )s < (unsigned long )limit) {
     tmp = s;
     s ++;
     if ((int const   )*tmp == (int const   )c) {
       return ((char *)(s - 1));
     }
   }
   return ((char *)0);
 }
 }
 char *end_of_token(char *s ) 
 { 
   unsigned short const   **tmp ;
 
   {
   while (1) {
     if ((int )*s != 0) {
       tmp = __ctype_b_loc();
       if ((int const   )*(*tmp + (int )*s) & 1) {
         break;
       }
     } else {
       break;
     }
     s ++;
   }
   return (s);
 }
 }
 char *next_token(char *s ) 
 { 
   register char *p ;
   unsigned short const   **tmp ;
 
   {
   p = s;
   while (1) {
     tmp = __ctype_b_loc();
     if (! ((int const   )*(*tmp + (int )*p) & 1)) {
       break;
     }
     p ++;
   }
   return (p);
 }
 }
 char *find_next_token(char **ptr , unsigned int *lengthptr ) 
 { 
   char *p ;
   char *tmp ;
   char *end ;
 
   {
   tmp = next_token(*ptr);
   p = tmp;
   if ((int )*p == 0) {
     return ((char *)0);
   }
   end = end_of_token(p);
   *ptr = end;
   if ((unsigned long )lengthptr != (unsigned long )((unsigned int *)0)) {
     *lengthptr = (unsigned int )(end - p);
   }
   return (p);
 }
 }
 struct dep *copy_dep_chain(struct dep *d ) 
 { 
   register struct dep *c ;
   struct dep *firstnew ;
   struct dep *lastnew ;
   char *tmp ;
   struct dep *tmp___0 ;
 
   {
   firstnew = (struct dep *)0;
   lastnew = (struct dep *)0;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     tmp = xmalloc((unsigned int )sizeof(struct dep ));
     c = (struct dep *)tmp;
     memmove((void *)((char *)c), (void const   *)((char *)d), sizeof(struct dep ));
     if ((unsigned long )c->name != (unsigned long )((char *)0)) {
       c->name = xstrdup((char const   *)c->name);
     }
     c->next = (struct dep *)0;
     if ((unsigned long )firstnew == (unsigned long )((struct dep *)0)) {
       lastnew = c;
       firstnew = lastnew;
     } else {
       tmp___0 = c;
       lastnew->next = tmp___0;
       lastnew = tmp___0;
     }
     d = d->next;
   }
   return (firstnew);
 }
 }
 static int user_uid  =    -1;
 static int user_gid  =    -1;
 static int make_uid  =    -1;
 static int make_gid  =    -1;
 static enum __anonenum_current_access_55 current_access  ;
 static void log_access(char *flavor ) 
 { 
   __gid_t tmp ;
   __gid_t tmp___0 ;
   __uid_t tmp___1 ;
   __uid_t tmp___2 ;
   char *tmp___3 ;
 
   {
   if (! (4 & db_level)) {
     return;
   }
   tmp = getgid();
   tmp___0 = getegid();
   tmp___1 = getuid();
   tmp___2 = geteuid();
   tmp___3 = dcgettext((char const   *)((void *)0), "%s access: user %lu (real %lu), group %lu (real %lu)\n",
                       5);
   fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___3, flavor,
           (unsigned long )tmp___2, (unsigned long )tmp___1, (unsigned long )tmp___0,
           (unsigned long )tmp);
   fflush(stderr);
   return;
 }
 }
 static void init_access(void) 
 { 
   __uid_t tmp ;
   __gid_t tmp___0 ;
   __uid_t tmp___1 ;
   __gid_t tmp___2 ;
   char *tmp___3 ;
 
   {
   tmp = getuid();
   user_uid = (int )tmp;
   tmp___0 = getgid();
   user_gid = (int )tmp___0;
   tmp___1 = geteuid();
   make_uid = (int )tmp___1;
   tmp___2 = getegid();
   make_gid = (int )tmp___2;
   if (user_uid == -1) {
     pfatal_with_name((char *)"get{e}[gu]id");
   } else
   if (user_gid == -1) {
     pfatal_with_name((char *)"get{e}[gu]id");
   } else
   if (make_uid == -1) {
     pfatal_with_name((char *)"get{e}[gu]id");
   } else
   if (make_gid == -1) {
     pfatal_with_name((char *)"get{e}[gu]id");
   }
   tmp___3 = dcgettext((char const   *)((void *)0), "Initialized", 5);
   log_access(tmp___3);
   current_access = (enum __anonenum_current_access_55 )0;
   return;
 }
 }
 void user_access(void) 
 { 
   int tmp ;
   int tmp___0 ;
 
   {
   if (! (user_uid != -1)) {
     init_access();
   }
   if ((unsigned int )current_access == 1U) {
     return;
   }
   tmp = seteuid((__uid_t )user_uid);
   if (tmp < 0) {
     pfatal_with_name((char *)"user_access: seteuid");
   }
   tmp___0 = setegid((__gid_t )user_gid);
   if (tmp___0 < 0) {
     pfatal_with_name((char *)"user_access: setegid");
   }
   current_access = (enum __anonenum_current_access_55 )1;
   log_access((char *)"User");
   return;
 }
 }
 void make_access(void) 
 { 
   int tmp ;
   int tmp___0 ;
 
   {
   if (! (user_uid != -1)) {
     init_access();
   }
   if ((unsigned int )current_access == 0U) {
     return;
   }
   tmp = seteuid((__uid_t )make_uid);
   if (tmp < 0) {
     pfatal_with_name((char *)"make_access: seteuid");
   }
   tmp___0 = setegid((__gid_t )make_gid);
   if (tmp___0 < 0) {
     pfatal_with_name((char *)"make_access: setegid");
   }
   current_access = (enum __anonenum_current_access_55 )0;
   log_access((char *)"Make");
   return;
 }
 }
 void child_access(void) 
 { 
   int tmp ;
   int tmp___0 ;
 
   {
   if (! (user_uid != -1)) {
     abort();
   }
   tmp = setuid((__uid_t )user_uid);
   if (tmp < 0) {
     pfatal_with_name((char *)"child_access: setuid");
   }
   tmp___0 = setgid((__gid_t )user_gid);
   if (tmp___0 < 0) {
     pfatal_with_name((char *)"child_access: setgid");
   }
   log_access((char *)"Child");
   return;
 }
 }
 #pragma merger("0","/tmp/cil-EmMgOVB_.i","-g,-O0")
 extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
 extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
 extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
 extern char *getlogin(void) ;
 void construct_vpath_list(char *pattern , char *dirpath ) ;
 struct floc  const  *reading_file  ;
 extern int glob(char const   *__pattern , int __flags , int (*__errfunc)(char const   * ,
                                                                          int  ) ,
                 glob_t *__pglob ) ;
 extern void globfree(glob_t *__pglob ) ;
 struct file *suffix_file ;
 struct pattern_var *create_pattern_var(char *target , char *suffix ) ;
 void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                          struct dep *deps , struct commands *commands , int override ) ;
 extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
 static struct conditionals toplevel_conditionals  ;
 static struct conditionals *conditionals  =    & toplevel_conditionals;
 static char *default_include_directories[5]  = {      (char *)"/usr/local/include",      (char *)"/usr/gnu/include",      (char *)"/usr/local/include",      (char *)"/usr/include", 
         (char *)0};
 static char **include_directories___0  ;
 static unsigned int max_incl_len  ;
 static struct dep *read_makefiles  =    (struct dep *)0;
 static int read_makefile(char *filename , int flags ) ;
 static unsigned long readline(struct linebuffer *linebuffer , FILE *stream , struct floc  const  *flocp ) ;
 static void do_define(char *name , unsigned int namelen , enum variable_origin origin ,
                       FILE *infile , struct floc *flocp ) ;
 static int conditional_line(char *line , struct floc  const  *flocp ) ;
 static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                          struct dep *deps , unsigned int cmds_started , char *commands ,
                          unsigned int commands_idx , int two_colon , struct floc  const  *flocp ,
                          int set_default ) ;
 static void record_target_var(struct nameseq *filenames , char *defn , int two_colon ,
                               enum variable_origin origin , struct floc  const  *flocp ) ;
 static enum make_word_type get_next_mword(char *buffer , char *delim , char **startp ,
                                           unsigned int *length___0 ) ;
 static char *default_makefiles[4]  = {      (char *)"GNUmakefile",      (char *)"makefile",      (char *)"Makefile",      (char *)0};
 struct dep *read_all_makefiles(char **makefiles___0 ) 
 { 
   unsigned int num_makefiles ;
   char *tmp ;
   char *value ;
   char *name ;
   char *p ;
   unsigned int length___0 ;
   int save ;
   char *tmp___0 ;
   int tmp___1 ;
   struct dep *tail ;
   register struct dep *d ;
   int tmp___2 ;
   register char **p___0 ;
   int tmp___3 ;
   int tmp___4 ;
   struct dep *tail___0 ;
   struct dep *d___0 ;
   char *tmp___5 ;
 
   {
   num_makefiles = 0U;
   while (1) {
     if (1 & db_level) {
       tmp = dcgettext((char const   *)((void *)0), "Reading makefiles...\n", 5);
       printf((char const   * __restrict  )tmp);
       fflush(stdout);
     }
     break;
   }
   save = warn_undefined_variables_flag;
   warn_undefined_variables_flag = 0;
   value = allocated_variable_expand_for_file((char *)"$(MAKEFILES)", (struct file *)0);
   warn_undefined_variables_flag = save;
   p = value;
   while (1) {
     name = find_next_token(& p, & length___0);
     if (! ((unsigned long )name != (unsigned long )((char *)0))) {
       break;
     }
     if ((int )*p != 0) {
       tmp___0 = p;
       p ++;
       *tmp___0 = (char )'\000';
     }
     name = xstrdup((char const   *)name);
     tmp___1 = read_makefile(name, (1 | (1 << 1)) | (1 << 2));
     if (tmp___1 < 2) {
       free((void *)name);
     }
   }
   free((void *)value);
   if ((unsigned long )makefiles___0 != (unsigned long )((char **)0)) {
     while ((unsigned long )*makefiles___0 != (unsigned long )((char *)0)) {
       tail = read_makefiles;
       tmp___2 = read_makefile(*makefiles___0, 0);
       if (! tmp___2) {
         perror_with_name((char *)"", *makefiles___0);
       }
       d = read_makefiles;
       while ((unsigned long )d->next != (unsigned long )tail) {
         d = d->next;
       }
       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
         *makefiles___0 = (d->file)->name;
       } else {
         *makefiles___0 = d->name;
       }
       num_makefiles ++;
       makefiles___0 ++;
     }
   }
   if (num_makefiles == 0U) {
     p___0 = default_makefiles;
     while (1) {
       if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
         tmp___3 = file_exists_p(*p___0);
         if (tmp___3) {
           break;
         }
       } else {
         break;
       }
       p___0 ++;
     }
     if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
       tmp___4 = read_makefile(*p___0, 0);
       if (! tmp___4) {
         perror_with_name((char *)"", *p___0);
       }
     } else {
       tail___0 = read_makefiles;
       while (1) {
         if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
           if (! ((unsigned long )tail___0->next != (unsigned long )((struct dep *)0))) {
             break;
           }
         } else {
           break;
         }
         tail___0 = tail___0->next;
       }
       p___0 = default_makefiles;
       while ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
         tmp___5 = xmalloc((unsigned int )sizeof(struct dep ));
         d___0 = (struct dep *)tmp___5;
         d___0->name = (char *)0;
         d___0->file = enter_file(*p___0);
         (d___0->file)->dontcare = 1U;
         d___0->changed = 1 << 2;
         if ((unsigned long )tail___0 == (unsigned long )((struct dep *)0)) {
           read_makefiles = d___0;
         } else {
           tail___0->next = d___0;
         }
         tail___0 = d___0;
         p___0 ++;
       }
       if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
         tail___0->next = (struct dep *)0;
       }
     }
   }
   return (read_makefiles);
 }
 }
 static char *collapsed  =    (char *)0;
 static unsigned int collapsed_length  =    0U;
 static int read_makefile(char *filename , int flags ) 
 { 
   register FILE *infile ;
   struct linebuffer lb ;
   unsigned int commands_len ;
   char *commands ;
   unsigned int commands_idx ;
   unsigned int cmds_started ;
   unsigned int tgts_started ;
   char *p ;
   char *p2 ;
   int len ;
   int reading_target ;
   int ignoring ;
   int in_ignored_define ;
   int no_targets ;
   int using_filename ;
   struct floc fileinfo ;
   char *passed_filename ;
   struct nameseq *filenames ;
   struct dep *deps ;
   unsigned int nlines ;
   int two_colon ;
   char *pattern ;
   char *pattern_percent ;
   int makefile_errno ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *expanded ;
   char *tmp___4 ;
   int *tmp___5 ;
   register unsigned int i ;
   char *name ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   int *tmp___9 ;
   char *tmp___10 ;
   unsigned long tmp___11 ;
   unsigned int len___0 ;
   size_t tmp___12 ;
   char *tmp___13 ;
   unsigned int tmp___14 ;
   char *tmp___15 ;
   unsigned short const   **tmp___16 ;
   unsigned short const   **tmp___17 ;
   unsigned short const   **tmp___18 ;
   int i___0 ;
   int tmp___19 ;
   char *tmp___20 ;
   int tmp___21 ;
   int tmp___22 ;
   int tmp___23 ;
   int tmp___24 ;
   int tmp___25 ;
   int tmp___26 ;
   char *tmp___27 ;
   int tmp___28 ;
   char *tmp___29 ;
   unsigned short const   **tmp___30 ;
   int tmp___31 ;
   char *tmp___32 ;
   char *tmp___33 ;
   unsigned short const   **tmp___34 ;
   char *tmp___35 ;
   struct variable *tmp___36 ;
   int tmp___37 ;
   unsigned short const   **tmp___38 ;
   int tmp___39 ;
   struct variable *v ;
   unsigned int len___1 ;
   unsigned int len___2 ;
   struct variable *v___0 ;
   char *pattern___0 ;
   unsigned int len___3 ;
   struct conditionals *save ;
   struct conditionals new_conditionals ;
   struct nameseq *files___0 ;
   int noerror ;
   int tmp___40 ;
   char *tmp___41 ;
   char const   *tmp___42 ;
   char *tmp___43 ;
   struct nameseq *tmp___44 ;
   struct floc fi ;
   struct nameseq *next ;
   char *name___0 ;
   int r ;
   int tmp___45 ;
   int *tmp___46 ;
   char *tmp___47 ;
   unsigned short const   **tmp___48 ;
   char *tmp___49 ;
   enum make_word_type wtype ;
   enum variable_origin v_origin ;
   char *cmdleft ;
   char *lb_next ;
   unsigned int len___4 ;
   unsigned int plen ;
   char *colonp ;
   struct floc fi___0 ;
   char *tmp___50 ;
   char *tmp___51 ;
   unsigned long p2_off ;
   unsigned long cmd_off ;
   char *pend ;
   size_t tmp___52 ;
   size_t tmp___53 ;
   size_t tmp___54 ;
   char *tmp___55 ;
   char *tmp___57 ;
   char const   *tmp___58 ;
   int tmp___59 ;
   char *tmp___60 ;
   struct nameseq *tmp___61 ;
   unsigned int l ;
   size_t tmp___63 ;
   size_t tmp___64 ;
   int tmp___65 ;
   unsigned int l___0 ;
   char *tmp___66 ;
   register char *q ;
   register int backslash ;
   char *tmp___67 ;
   struct nameseq *target ;
   char *tmp___68 ;
   char *tmp___69 ;
   char *tmp___70 ;
   struct nameseq *tmp___71 ;
   struct nameseq *tmp___72 ;
   unsigned int len___5 ;
   size_t tmp___73 ;
   char *tmp___74 ;
   unsigned int tmp___75 ;
   struct variable *tmp___76 ;
   int tmp___77 ;
   int tmp___78 ;
   int tmp___79 ;
   int tmp___80 ;
   int tmp___81 ;
   int tmp___82 ;
   struct floc fi___1 ;
   int tmp___83 ;
   char *tmp___84 ;
   struct floc fi___2 ;
 
   {
   commands_len = 200U;
   commands_idx = 0U;
   ignoring = 0;
   in_ignored_define = 0;
   no_targets = 0;
   using_filename = 0;
   passed_filename = filename;
   filenames = (struct nameseq *)0;
   nlines = 0U;
   two_colon = 0;
   pattern = (char *)0;
   fileinfo.filenm = filename;
   fileinfo.lineno = 1UL;
   pattern_percent = (char *)0;
   tgts_started = (unsigned int )fileinfo.lineno;
   cmds_started = tgts_started;
   if (2 & db_level) {
     tmp = dcgettext((char const   *)((void *)0), "Reading makefile `%s\'", 5);
     printf((char const   * __restrict  )tmp, fileinfo.filenm);
     if (flags & 1) {
       tmp___0 = dcgettext((char const   *)((void *)0), " (no default goal)", 5);
       printf((char const   * __restrict  )tmp___0);
     }
     if (flags & (1 << 1)) {
       tmp___1 = dcgettext((char const   *)((void *)0), " (search path)", 5);
       printf((char const   * __restrict  )tmp___1);
     }
     if (flags & (1 << 2)) {
       tmp___2 = dcgettext((char const   *)((void *)0), " (don\'t care)", 5);
       printf((char const   * __restrict  )tmp___2);
     }
     if (flags & (1 << 3)) {
       tmp___3 = dcgettext((char const   *)((void *)0), " (no ~ expansion)", 5);
       printf((char const   * __restrict  )tmp___3);
     }
     puts("...");
   }
   if (! (flags & (1 << 3))) {
     if ((int )*(filename + 0) == 126) {
       tmp___4 = tilde_expand(filename);
       expanded = tmp___4;
       if ((unsigned long )expanded != (unsigned long )((char *)0)) {
         filename = expanded;
       }
     }
   }
   infile = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
   tmp___5 = __errno_location();
   makefile_errno = *tmp___5;
   if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
     if (flags & (1 << 1)) {
       if ((int )*filename != 47) {
         i = 0U;
         while ((unsigned long )*(include_directories___0 + i) != (unsigned long )((char *)0)) {
           tmp___6 = concat(*(include_directories___0 + i), (char *)"/", filename);
           name = tmp___6;
           infile = fopen((char const   * __restrict  )name, (char const   * __restrict  )"r");
           if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
             free((void *)name);
           } else {
             filename = name;
             break;
           }
           i ++;
         }
       }
     }
   }
   tmp___7 = xmalloc((unsigned int )sizeof(struct dep ));
   deps = (struct dep *)tmp___7;
   deps->next = read_makefiles;
   read_makefiles = deps;
   deps->name = (char *)0;
   deps->file = lookup_file(filename);
   if ((unsigned long )deps->file == (unsigned long )((struct file *)0)) {
     tmp___8 = xstrdup((char const   *)filename);
     deps->file = enter_file(tmp___8);
     if (flags & (1 << 2)) {
       (deps->file)->dontcare = 1U;
     }
   }
   if ((unsigned long )filename != (unsigned long )passed_filename) {
     free((void *)filename);
   }
   filename = (deps->file)->name;
   deps->changed = flags;
   deps = (struct dep *)0;
   if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
     tmp___9 = __errno_location();
     *tmp___9 = makefile_errno;
     return (0);
   }
   reading_file = (struct floc  const  *)(& fileinfo);
   lb.size = 200U;
   tmp___10 = xmalloc(lb.size);
   lb.buffer = tmp___10;
   commands = xmalloc(200U);
   while (1) {
     tmp___83 = feof(infile);
     if (tmp___83) {
       break;
     }
     fileinfo.lineno += (unsigned long )nlines;
     tmp___11 = readline(& lb, infile, (struct floc  const  *)(& fileinfo));
     nlines = (unsigned int )tmp___11;
     if ((int )*(lb.buffer + 0) == 9) {
       if (no_targets) {
         continue;
       }
       if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
         if (ignoring) {
           continue;
         }
         p = lb.buffer;
         if (commands_idx == 0U) {
           cmds_started = (unsigned int )fileinfo.lineno;
         }
         tmp___12 = strlen((char const   *)p);
         len___0 = (unsigned int )tmp___12;
         if ((len___0 + 1U) + commands_idx > commands_len) {
           commands_len = ((len___0 + 1U) + commands_idx) * 2U;
           tmp___13 = xrealloc(commands, commands_len);
           commands = tmp___13;
         }
         memmove((void *)(commands + commands_idx), (void const   *)p, (size_t )len___0);
         commands_idx += len___0;
         tmp___14 = commands_idx;
         commands_idx ++;
         *(commands + tmp___14) = (char )'\n';
         continue;
       }
     }
     if (collapsed_length < lb.size) {
       collapsed_length = lb.size;
       if ((unsigned long )collapsed != (unsigned long )((char *)0)) {
         free((void *)collapsed);
       }
       tmp___15 = xmalloc(collapsed_length);
       collapsed = tmp___15;
     }
     strcpy((char * __restrict  )collapsed, (char const   * __restrict  )lb.buffer);
     collapse_continuations(collapsed);
     remove_comments(collapsed);
     p = collapsed;
     while (1) {
       tmp___16 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___16 + (int )((unsigned char )*p)) & 8192)) {
         break;
       }
       p ++;
     }
     if ((int )*p == 0) {
       continue;
     }
     p2 = p + 1;
     while (1) {
       if ((int )*p2 != 0) {
         tmp___17 = __ctype_b_loc();
         if ((int const   )*(*tmp___17 + (int )((unsigned char )*p2)) & 8192) {
           break;
         }
       } else {
         break;
       }
       p2 ++;
     }
     len = (int )(p2 - p);
     reading_target = 0;
     while (1) {
       tmp___18 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___18 + (int )((unsigned char )*p2)) & 8192)) {
         break;
       }
       p2 ++;
     }
     if ((int )*p2 == 0) {
       p2 = (char *)((void *)0);
     } else
     if ((int )*(p2 + 0) == 58) {
       if ((int )*(p2 + 1) == 0) {
         reading_target = 1;
         goto skip_conditionals;
       }
     }
     if (! in_ignored_define) {
       if (len == 5) {
         tmp___21 = strncmp("ifdef", (char const   *)p, (size_t )5);
         if (tmp___21 == 0) {
           goto _L;
         } else {
           goto _L___4;
         }
       } else
       _L___4: /* CIL Label */ 
       if (len == 6) {
         tmp___22 = strncmp("ifndef", (char const   *)p, (size_t )6);
         if (tmp___22 == 0) {
           goto _L;
         } else {
           goto _L___3;
         }
       } else
       _L___3: /* CIL Label */ 
       if (len == 4) {
         tmp___23 = strncmp("ifeq", (char const   *)p, (size_t )4);
         if (tmp___23 == 0) {
           goto _L;
         } else {
           goto _L___2;
         }
       } else
       _L___2: /* CIL Label */ 
       if (len == 5) {
         tmp___24 = strncmp("ifneq", (char const   *)p, (size_t )5);
         if (tmp___24 == 0) {
           goto _L;
         } else {
           goto _L___1;
         }
       } else
       _L___1: /* CIL Label */ 
       if (len == 4) {
         tmp___25 = strncmp("else", (char const   *)p, (size_t )4);
         if (tmp___25 == 0) {
           goto _L;
         } else {
           goto _L___0;
         }
       } else
       _L___0: /* CIL Label */ 
       if (len == 5) {
         tmp___26 = strncmp("endif", (char const   *)p, (size_t )5);
         if (tmp___26 == 0) {
           _L: /* CIL Label */ 
           tmp___19 = conditional_line(p, (struct floc  const  *)(& fileinfo));
           i___0 = tmp___19;
           if (i___0 >= 0) {
             ignoring = i___0;
           } else {
             tmp___20 = dcgettext((char const   *)((void *)0), "invalid syntax in conditional",
                                  5);
             fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___20);
           }
           continue;
         }
       }
     }
     if (len == 5) {
       tmp___28 = strncmp("endef", (char const   *)p, (size_t )5);
       if (tmp___28 == 0) {
         if (in_ignored_define) {
           in_ignored_define = 0;
         } else {
           tmp___27 = dcgettext((char const   *)((void *)0), "extraneous `endef\'",
                                5);
           fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___27);
         }
         continue;
       }
     }
     if (len == 6) {
       tmp___31 = strncmp("define", (char const   *)p, (size_t )6);
       if (tmp___31 == 0) {
         if (ignoring) {
           in_ignored_define = 1;
         } else {
           p2 = next_token(p + 6);
           if ((int )*p2 == 0) {
             tmp___29 = dcgettext((char const   *)((void *)0), "empty variable name",
                                  5);
             fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___29);
           }
           p = strchr((char const   *)p2, '\000');
           while (1) {
             tmp___30 = __ctype_b_loc();
             if (! ((int const   )*(*tmp___30 + (int )*(p + -1)) & 1)) {
               break;
             }
             p --;
           }
           do_define(p2, (unsigned int )(p - p2), (enum variable_origin )2, infile,
                     & fileinfo);
         }
         continue;
       }
     }
     if (len == 8) {
       tmp___39 = strncmp("override", (char const   *)p, (size_t )8);
       if (tmp___39 == 0) {
         p2 = next_token(p + 8);
         if ((int )*p2 == 0) {
           tmp___32 = dcgettext((char const   *)((void *)0), "empty `override\' directive",
                                5);
           error((struct floc  const  *)(& fileinfo), (char const   *)tmp___32);
         }
         tmp___37 = strncmp((char const   *)p2, "define", (size_t )6);
         if (tmp___37 == 0) {
           tmp___38 = __ctype_b_loc();
           if ((int const   )*(*tmp___38 + (int )*(p2 + 6)) & 1) {
             goto _L___6;
           } else
           if ((int )*(p2 + 6) == 0) {
             _L___6: /* CIL Label */ 
             if (ignoring) {
               in_ignored_define = 1;
             } else {
               p2 = next_token(p2 + 6);
               if ((int )*p2 == 0) {
                 tmp___33 = dcgettext((char const   *)((void *)0), "empty variable name",
                                      5);
                 fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___33);
               }
               p = strchr((char const   *)p2, '\000');
               while (1) {
                 tmp___34 = __ctype_b_loc();
                 if (! ((int const   )*(*tmp___34 + (int )*(p + -1)) & 1)) {
                   break;
                 }
                 p --;
               }
               do_define(p2, (unsigned int )(p - p2), (enum variable_origin )5, infile,
                         & fileinfo);
             }
           } else {
             goto _L___5;
           }
         } else
         _L___5: /* CIL Label */ 
         if (! ignoring) {
           tmp___36 = try_variable_definition((struct floc  const  *)(& fileinfo),
                                              p2, (enum variable_origin )5, 0);
           if (! tmp___36) {
             tmp___35 = dcgettext((char const   *)((void *)0), "invalid `override\' directive",
                                  5);
             error((struct floc  const  *)(& fileinfo), (char const   *)tmp___35);
           }
         }
         continue;
       }
     }
     skip_conditionals: 
     if (ignoring) {
       continue;
     }
     if (! reading_target) {
       if (len == 6) {
         tmp___82 = strncmp("export", (char const   *)p, (size_t )6);
         if (tmp___82 == 0) {
           p2 = next_token(p + 6);
           if ((int )*p2 == 0) {
             export_all_variables = 1;
           }
           v = try_variable_definition((struct floc  const  *)(& fileinfo), p2, (enum variable_origin )2,
                                       0);
           if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
             v->export = (enum variable_export )0;
           } else {
             p = find_next_token(& p2, & len___1);
             while ((unsigned long )p != (unsigned long )((char *)0)) {
               v = lookup_variable(p, len___1);
               if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
                 v = define_variable_in_set(p, len___1, (char *)"", (enum variable_origin )2,
                                            0, current_variable_set_list->set, (struct floc  const  *)(& fileinfo));
               }
               v->export = (enum variable_export )0;
               p = find_next_token(& p2, & len___1);
             }
           }
         } else {
           goto _L___14;
         }
       } else {
         goto _L___14;
       }
     } else
     _L___14: /* CIL Label */ 
     if (! reading_target) {
       if (len == 8) {
         tmp___81 = strncmp("unexport", (char const   *)p, (size_t )8);
         if (tmp___81 == 0) {
           p2 = next_token(p + 8);
           if ((int )*p2 == 0) {
             export_all_variables = 0;
           }
           p = find_next_token(& p2, & len___2);
           while ((unsigned long )p != (unsigned long )((char *)0)) {
             v___0 = lookup_variable(p, len___2);
             if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
               v___0 = define_variable_in_set(p, len___2, (char *)"", (enum variable_origin )2,
                                              0, current_variable_set_list->set, (struct floc  const  *)(& fileinfo));
             }
             v___0->export = (enum variable_export )1;
             p = find_next_token(& p2, & len___2);
           }
         } else {
           goto _L___13;
         }
       } else {
         goto _L___13;
       }
     } else
     _L___13: /* CIL Label */ 
     if (len == 5) {
       tmp___80 = strncmp("vpath", (char const   *)p, (size_t )5);
       if (tmp___80 == 0) {
         p2 = variable_expand(p + 5);
         p = find_next_token(& p2, & len___3);
         if ((unsigned long )p != (unsigned long )((char *)0)) {
           pattern___0 = savestring((char const   *)p, len___3);
           p = find_next_token(& p2, & len___3);
         } else {
           pattern___0 = (char *)0;
         }
         construct_vpath_list(pattern___0, p);
         if ((unsigned long )pattern___0 != (unsigned long )((char *)0)) {
           free((void *)pattern___0);
         }
       } else {
         goto _L___12;
       }
     } else
     _L___12: /* CIL Label */ 
     if (len == 7) {
       tmp___77 = strncmp("include", (char const   *)p, (size_t )7);
       if (tmp___77 == 0) {
         goto _L___8;
       } else {
         goto _L___11;
       }
     } else
     _L___11: /* CIL Label */ 
     if (len == 8) {
       tmp___78 = strncmp("-include", (char const   *)p, (size_t )8);
       if (tmp___78 == 0) {
         goto _L___8;
       } else {
         goto _L___10;
       }
     } else
     _L___10: /* CIL Label */ 
     if (len == 8) {
       tmp___79 = strncmp("sinclude", (char const   *)p, (size_t )8);
       if (tmp___79 == 0) {
         _L___8: /* CIL Label */ 
         noerror = (int )*(p + 0) != 105;
         if (noerror) {
           tmp___40 = 8;
         } else {
           tmp___40 = 7;
         }
         tmp___41 = next_token(p + tmp___40);
         p = allocated_variable_expand_for_file(tmp___41, (struct file *)0);
         if ((int )*p == 0) {
           if (noerror) {
             tmp___42 = "-";
           } else {
             tmp___42 = "";
           }
           tmp___43 = dcgettext((char const   *)((void *)0), "no file name for `%sinclude\'",
                                5);
           error((struct floc  const  *)(& fileinfo), (char const   *)tmp___43, tmp___42);
           continue;
         }
         p2 = p;
         tmp___44 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct nameseq ),
                                   1);
         files___0 = multi_glob(tmp___44, (unsigned int )sizeof(struct nameseq ));
         free((void *)p);
         save = conditionals;
         memset((void *)((char *)(& new_conditionals)), 0, sizeof(new_conditionals));
         conditionals = & new_conditionals;
         while (1) {
           if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
             fi.filenm = fileinfo.filenm;
             fi.lineno = (unsigned long )tgts_started;
             record_files(filenames, pattern, pattern_percent, deps, cmds_started,
                          commands, commands_idx, two_colon, (struct floc  const  *)(& fi),
                          ! (flags & 1));
             using_filename |= commands_idx > 0U;
           }
           filenames = (struct nameseq *)0;
           commands_idx = 0U;
           if (pattern) {
             free((void *)pattern);
             pattern = (char *)0;
           }
           break;
         }
         while ((unsigned long )files___0 != (unsigned long )((struct nameseq *)0)) {
           next = files___0->next;
           name___0 = files___0->name;
           free((void *)((char *)files___0));
           files___0 = next;
           if (noerror) {
             tmp___45 = 1 << 2;
           } else {
             tmp___45 = 0;
           }
           r = read_makefile(name___0, ((1 << 1) | (1 << 3)) | tmp___45);
           if (! r) {
             if (! noerror) {
               tmp___46 = __errno_location();
               tmp___47 = strerror(*tmp___46);
               error((struct floc  const  *)(& fileinfo), "%s: %s", name___0, tmp___47);
             }
           }
           if (r < 2) {
             free((void *)name___0);
           }
         }
         if (conditionals->ignoring) {
           free((void *)conditionals->ignoring);
         }
         if (conditionals->seen_else) {
           free((void *)conditionals->seen_else);
         }
         conditionals = save;
         reading_file = (struct floc  const  *)(& fileinfo);
       } else {
         goto _L___9;
       }
     } else {
       _L___9: /* CIL Label */ 
       tmp___76 = try_variable_definition((struct floc  const  *)(& fileinfo), p, (enum variable_origin )2,
                                          0);
       if (! tmp___76) {
         if ((int )*(lb.buffer + 0) == 9) {
           p = collapsed;
           while (1) {
             tmp___48 = __ctype_b_loc();
             if (! ((int const   )*(*tmp___48 + (int )*p) & 1)) {
               break;
             }
             p ++;
           }
           if ((int )*p == 0) {
             continue;
           }
           tmp___49 = dcgettext((char const   *)((void *)0), "commands commence before first target",
                                5);
           fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___49);
         } else {
           plen = 0U;
           while (1) {
             if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
               fi___0.filenm = fileinfo.filenm;
               fi___0.lineno = (unsigned long )tgts_started;
               record_files(filenames, pattern, pattern_percent, deps, cmds_started,
                            commands, commands_idx, two_colon, (struct floc  const  *)(& fi___0),
                            ! (flags & 1));
               using_filename |= commands_idx > 0U;
             }
             filenames = (struct nameseq *)0;
             commands_idx = 0U;
             if (pattern) {
               free((void *)pattern);
               pattern = (char *)0;
             }
             break;
           }
           tgts_started = (unsigned int )fileinfo.lineno;
           cmdleft = find_char_unquote(lb.buffer, (char *)";#", 0);
           if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
             if ((int )*cmdleft == 35) {
               *cmdleft = (char )'\000';
               cmdleft = (char *)0;
             } else {
               goto _L___7;
             }
           } else
           _L___7: /* CIL Label */ 
           if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
             tmp___50 = cmdleft;
             cmdleft ++;
             *tmp___50 = (char )'\000';
           }
           collapse_continuations(lb.buffer);
           wtype = get_next_mword(lb.buffer, (char *)((void *)0), & lb_next, & len___4);
           switch ((unsigned int )wtype) {
           case 1U: 
           if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
             tmp___51 = dcgettext((char const   *)((void *)0), "missing rule before commands",
                                  5);
             fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___51);
           }
           continue;
           case 5U: 
           case 4U: 
           no_targets = 1;
           continue;
           default: 
           break;
           }
           p2 = variable_expand_string((char *)((void *)0), lb_next, (long )len___4);
           while (1) {
             lb_next += len___4;
             if ((unsigned long )cmdleft == (unsigned long )((char *)0)) {
               cmdleft = find_char_unquote(p2, (char *)";", 0);
               if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
                 p2_off = (unsigned long )(p2 - variable_buffer);
                 cmd_off = (unsigned long )(cmdleft - variable_buffer);
                 tmp___52 = strlen((char const   *)p2);
                 pend = p2 + tmp___52;
                 *cmdleft = (char )'\000';
                 variable_expand_string(pend, lb_next, -1L);
                 tmp___53 = strlen((char const   *)lb_next);
                 lb_next += tmp___53;
                 p2 = variable_buffer + p2_off;
                 cmdleft = (variable_buffer + cmd_off) + 1;
               }
             }
             colonp = find_char_unquote(p2, (char *)":", 0);
             if ((unsigned long )colonp != (unsigned long )((char *)0)) {
               break;
             }
             wtype = get_next_mword(lb_next, (char *)((void *)0), & lb_next, & len___4);
             if ((unsigned int )wtype == 1U) {
               break;
             }
             tmp___54 = strlen((char const   *)p2);
             p2 += tmp___54;
             tmp___55 = p2;
             p2 ++;
             *tmp___55 = (char )' ';
             p2 = variable_expand_string(p2, lb_next, (long )len___4);
           }
           p2 = next_token(variable_buffer);
           if ((unsigned int )wtype == 1U) {
             if ((int )*p2 != 0) {
               tmp___59 = strncmp((char const   *)lb.buffer, "        ", (size_t )8);
               if (tmp___59 == 0) {
                 tmp___57 = dcgettext((char const   *)((void *)0), " (did you mean TAB instead of 8 spaces?)",
                                      5);
                 tmp___58 = (char const   *)tmp___57;
               } else {
                 tmp___58 = "";
               }
               tmp___60 = dcgettext((char const   *)((void *)0), "missing separator%s",
                                    5);
               fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___60,
                     tmp___58);
             }
             continue;
           }
           *colonp = (char )'\000';
           tmp___61 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct nameseq ),
                                     1);
           filenames = multi_glob(tmp___61, (unsigned int )sizeof(struct nameseq ));
           *p2 = (char )':';
           if (! filenames) {
             no_targets = 1;
             continue;
           }
           if (! ((int )*p2 != 0)) {
             __assert_fail("*p2 != \'\\0\'", "read.c", 896U, "read_makefile");
           }
           p2 ++;
           two_colon = (int )*p2 == 58;
           if (two_colon) {
             p2 ++;
           }
           if ((int )*lb_next != 0) {
             l = (unsigned int )(p2 - variable_buffer);
             tmp___63 = strlen((char const   *)p2);
             plen = (unsigned int )tmp___63;
             tmp___64 = strlen((char const   *)lb_next);
             variable_buffer_output(p2 + plen, lb_next, (unsigned int )(tmp___64 + 1UL));
             p2 = variable_buffer + l;
           }
           wtype = get_next_mword(p2, (char *)((void *)0), & p, & len___4);
           v_origin = (enum variable_origin )2;
           if ((unsigned int )wtype == 2U) {
             if ((unsigned long )len___4 == sizeof("override") - 1UL) {
               tmp___65 = strncmp((char const   *)p, "override", (size_t )len___4);
               if (tmp___65 == 0) {
                 v_origin = (enum variable_origin )5;
                 wtype = get_next_mword(p + len___4, (char *)((void *)0), & p, & len___4);
               }
             }
           }
           if ((unsigned int )wtype != 1U) {
             wtype = get_next_mword(p + len___4, (char *)((void *)0), (char **)((void *)0),
                                    (unsigned int *)((void *)0));
           }
           if ((unsigned int )wtype == 8U) {
             record_target_var(filenames, p, two_colon, v_origin, (struct floc  const  *)(& fileinfo));
             filenames = (struct nameseq *)0;
             continue;
           }
           find_char_unquote(lb_next, (char *)"=", 0);
           no_targets = 0;
           if ((int )*lb_next != 0) {
             l___0 = (unsigned int )(p2 - variable_buffer);
             variable_expand_string(p2 + plen, lb_next, -1L);
             p2 = variable_buffer + l___0;
             if ((unsigned long )cmdleft == (unsigned long )((char *)0)) {
               cmdleft = find_char_unquote(p2, (char *)";", 0);
               if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
                 tmp___66 = cmdleft;
                 cmdleft ++;
                 *tmp___66 = (char )'\000';
               }
             }
           }
           p = strchr((char const   *)p2, ':');
           while (1) {
             if ((unsigned long )p != (unsigned long )((char *)0)) {
               if (! ((int )*(p + -1) == 92)) {
                 break;
               }
             } else {
               break;
             }
             q = p + -1;
             backslash = 0;
             while (1) {
               tmp___67 = q;
               q --;
               if (! ((int )*tmp___67 == 92)) {
                 break;
               }
               backslash = ! backslash;
             }
             if (backslash) {
               p = strchr((char const   *)(p + 1), ':');
             } else {
               break;
             }
           }
           if ((unsigned long )p != (unsigned long )((char *)0)) {
             target = parse_file_seq(& p2, ':', (unsigned int )sizeof(struct nameseq ),
                                     1);
             p2 ++;
             if ((unsigned long )target == (unsigned long )((struct nameseq *)0)) {
               tmp___68 = dcgettext((char const   *)((void *)0), "missing target pattern",
                                    5);
               fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___68);
             } else
             if ((unsigned long )target->next != (unsigned long )((struct nameseq *)0)) {
               tmp___69 = dcgettext((char const   *)((void *)0), "multiple target patterns",
                                    5);
               fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___69);
             }
             pattern = target->name;
             pattern_percent = find_percent(pattern);
             if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
               tmp___70 = dcgettext((char const   *)((void *)0), "target pattern contains no `%%\'",
                                    5);
               fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___70);
             }
             free((void *)((char *)target));
           } else {
             pattern = (char *)0;
           }
           tmp___71 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct dep ),
                                     1);
           tmp___72 = multi_glob(tmp___71, (unsigned int )sizeof(struct dep ));
           deps = (struct dep *)tmp___72;
           commands_idx = 0U;
           if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
             tmp___73 = strlen((char const   *)cmdleft);
             len___5 = (unsigned int )tmp___73;
             cmds_started = (unsigned int )fileinfo.lineno;
             if (len___5 + 2U > commands_len) {
               commands_len = (len___5 + 2U) * 2U;
               tmp___74 = xrealloc(commands, commands_len);
               commands = tmp___74;
             }
             memmove((void *)commands, (void const   *)cmdleft, (size_t )len___5);
             commands_idx += len___5;
             tmp___75 = commands_idx;
             commands_idx ++;
             *(commands + tmp___75) = (char )'\n';
           }
           continue;
         }
       }
     }
     while (1) {
       if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
         fi___1.filenm = fileinfo.filenm;
         fi___1.lineno = (unsigned long )tgts_started;
         record_files(filenames, pattern, pattern_percent, deps, cmds_started, commands,
                      commands_idx, two_colon, (struct floc  const  *)(& fi___1), ! (flags & 1));
         using_filename |= commands_idx > 0U;
       }
       filenames = (struct nameseq *)0;
       commands_idx = 0U;
       if (pattern) {
         free((void *)pattern);
         pattern = (char *)0;
       }
       break;
     }
     no_targets = 0;
   }
   if (conditionals->if_cmds) {
     tmp___84 = dcgettext((char const   *)((void *)0), "missing `endif\'", 5);
     fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___84);
   }
   while (1) {
     if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
       fi___2.filenm = fileinfo.filenm;
       fi___2.lineno = (unsigned long )tgts_started;
       record_files(filenames, pattern, pattern_percent, deps, cmds_started, commands,
                    commands_idx, two_colon, (struct floc  const  *)(& fi___2), ! (flags & 1));
       using_filename |= commands_idx > 0U;
     }
     filenames = (struct nameseq *)0;
     commands_idx = 0U;
     if (pattern) {
       free((void *)pattern);
       pattern = (char *)0;
     }
     break;
   }
   free((void *)lb.buffer);
   free((void *)commands);
   fclose(infile);
   reading_file = (struct floc  const  *)0;
   return (1 + using_filename);
 }
 }
 static void do_define(char *name , unsigned int namelen , enum variable_origin origin ,
                       FILE *infile , struct floc *flocp ) 
 { 
   struct linebuffer lb ;
   unsigned int nlines ;
   unsigned int length___0 ;
   char *definition ;
   char *tmp ;
   register unsigned int idx ;
   register char *p ;
   char *var ;
   void *tmp___0 ;
   char *tmp___1 ;
   unsigned int len ;
   unsigned long tmp___2 ;
   size_t tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   size_t tmp___6 ;
   size_t tmp___7 ;
   char *tmp___8 ;
   unsigned int tmp___9 ;
   unsigned short const   **tmp___10 ;
   int tmp___11 ;
   int tmp___12 ;
   char *tmp___13 ;
 
   {
   nlines = 0U;
   length___0 = 100U;
   tmp = xmalloc(100U);
   definition = tmp;
   idx = 0U;
   tmp___0 = __builtin_alloca((unsigned long )(namelen + 1U));
   var = (char *)tmp___0;
   memmove((void *)var, (void const   *)name, (size_t )namelen);
   *(var + namelen) = (char )'\000';
   var = variable_expand(var);
   lb.size = 200U;
   tmp___1 = xmalloc(lb.size);
   lb.buffer = tmp___1;
   while (1) {
     tmp___12 = feof(infile);
     if (tmp___12) {
       break;
     }
     flocp->lineno += (unsigned long )nlines;
     tmp___2 = readline(& lb, infile, (struct floc  const  *)flocp);
     nlines = (unsigned int )tmp___2;
     collapse_continuations(lb.buffer);
     p = next_token(lb.buffer);
     tmp___3 = strlen((char const   *)p);
     len = (unsigned int )tmp___3;
     if (len == 5U) {
       goto _L___0;
     } else
     if (len > 5U) {
       tmp___10 = __ctype_b_loc();
       if ((int const   )*(*tmp___10 + (int )*(p + 5)) & 1) {
         _L___0: /* CIL Label */ 
         tmp___11 = strncmp((char const   *)p, "endef", (size_t )5);
         if (tmp___11 == 0) {
           p += 5;
           remove_comments(p);
           tmp___5 = next_token(p);
           if ((int )*tmp___5 != 0) {
             tmp___4 = dcgettext((char const   *)((void *)0), "Extraneous text after `endef\' directive",
                                 5);
             error((struct floc  const  *)flocp, (char const   *)tmp___4);
           }
           if (idx == 0U) {
             *(definition + 0) = (char )'\000';
           } else {
             *(definition + (idx - 1U)) = (char )'\000';
           }
           tmp___6 = strlen((char const   *)var);
           define_variable_in_set(var, (unsigned int )tmp___6, definition, origin,
                                  1, current_variable_set_list->set, (struct floc  const  *)flocp);
           free((void *)definition);
           free((void *)lb.buffer);
           return;
         } else {
           goto _L___1;
         }
       } else {
         goto _L___1;
       }
     } else {
       _L___1: /* CIL Label */ 
       tmp___7 = strlen((char const   *)lb.buffer);
       len = (unsigned int )tmp___7;
       if ((idx + len) + 1U > length___0) {
         length___0 = (idx + len) * 2U;
         tmp___8 = xrealloc(definition, length___0 + 1U);
         definition = tmp___8;
       }
       memmove((void *)(definition + idx), (void const   *)lb.buffer, (size_t )len);
       idx += len;
       tmp___9 = idx;
       idx ++;
       *(definition + tmp___9) = (char )'\n';
     }
   }
   tmp___13 = dcgettext((char const   *)((void *)0), "missing `endef\', unterminated `define\'",
                        5);
   fatal((struct floc  const  *)flocp, (char const   *)tmp___13);
   return;
 }
 }
 static int conditional_line(char *line , struct floc  const  *flocp ) 
 { 
   int notdef ;
   char *cmdname ;
   register unsigned int i ;
   int tmp ;
   int tmp___0 ;
   int tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   struct variable *v ;
   register char *p ;
   char *tmp___9 ;
   int tmp___10 ;
   char *s1 ;
   char *s2 ;
   unsigned int len ;
   char termin ;
   int tmp___11 ;
   register int count ;
   char *p___0 ;
   char *tmp___12 ;
   unsigned short const   **tmp___13 ;
   char *tmp___14 ;
   size_t tmp___15 ;
   void *tmp___16 ;
   register int count___0 ;
   char *tmp___17 ;
   int tmp___18 ;
   int tmp___19 ;
   int tmp___20 ;
 
   {
   if ((int )*line == 105) {
     notdef = (int )*(line + 2) == 110;
     if (notdef) {
       if ((int )*(line + 3) == 100) {
         cmdname = (char *)"ifndef";
       } else {
         cmdname = (char *)"ifneq";
       }
       if ((int )*(cmdname + 3) == 100) {
         tmp = 7;
       } else {
         tmp = 6;
       }
       line += tmp;
     } else {
       if ((int )*(line + 2) == 100) {
         cmdname = (char *)"ifdef";
       } else {
         cmdname = (char *)"ifeq";
       }
       if ((int )*(cmdname + 2) == 100) {
         tmp___0 = 6;
       } else {
         tmp___0 = 5;
       }
       line += tmp___0;
     }
   } else {
     notdef = (int )*(line + 1) == 110;
     if (notdef) {
       cmdname = (char *)"endif";
     } else {
       cmdname = (char *)"else";
     }
     if (notdef) {
       tmp___1 = 5;
     } else {
       tmp___1 = 4;
     }
     line += tmp___1;
   }
   line = next_token(line);
   if ((int )*cmdname == 101) {
     if ((int )*line != 0) {
       tmp___2 = dcgettext((char const   *)((void *)0), "Extraneous text after `%s\' directive",
                           5);
       error(flocp, (char const   *)tmp___2, cmdname);
     }
     if (conditionals->if_cmds == 0U) {
       tmp___3 = dcgettext((char const   *)((void *)0), "extraneous `%s\'", 5);
       fatal(flocp, (char const   *)tmp___3, cmdname);
     }
     if (notdef) {
       (conditionals->if_cmds) --;
     } else
     if (*(conditionals->seen_else + (conditionals->if_cmds - 1U))) {
       tmp___4 = dcgettext((char const   *)((void *)0), "only one `else\' per conditional",
                           5);
       fatal(flocp, (char const   *)tmp___4);
     } else {
       *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(! *(conditionals->ignoring + (conditionals->if_cmds - 1U)));
       *(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)1;
     }
     i = 0U;
     while (i < conditionals->if_cmds) {
       if (*(conditionals->ignoring + i)) {
         return (1);
       }
       i ++;
     }
     return (0);
   }
   if (conditionals->allocated == 0U) {
     conditionals->allocated = 5U;
     tmp___5 = xmalloc(conditionals->allocated);
     conditionals->ignoring = tmp___5;
     tmp___6 = xmalloc(conditionals->allocated);
     conditionals->seen_else = tmp___6;
   }
   (conditionals->if_cmds) ++;
   if (conditionals->if_cmds > conditionals->allocated) {
     conditionals->allocated += 5U;
     tmp___7 = xrealloc(conditionals->ignoring, conditionals->allocated);
     conditionals->ignoring = tmp___7;
     tmp___8 = xrealloc(conditionals->seen_else, conditionals->allocated);
     conditionals->seen_else = tmp___8;
   }
   *(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)0;
   i = 0U;
   while (i < conditionals->if_cmds - 1U) {
     if (*(conditionals->ignoring + i)) {
       *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char)1;
       return (1);
     }
     i ++;
   }
   if (notdef) {
     tmp___20 = 3;
   } else {
     tmp___20 = 2;
   }
   if ((int )*(cmdname + tmp___20) == 100) {
     tmp___9 = end_of_token(line);
     p = tmp___9;
     i = (unsigned int )(p - line);
     p = next_token(p);
     if ((int )*p != 0) {
       return (-1);
     }
     v = lookup_variable(line, i);
     if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
       if ((int )*(v->value) != 0) {
         tmp___10 = 1;
       } else {
         tmp___10 = 0;
       }
     } else {
       tmp___10 = 0;
     }
     *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___10 == notdef);
   } else {
     if ((int )*line == 40) {
       tmp___11 = ',';
     } else {
       tmp___11 = (int )*line;
     }
     termin = (char )tmp___11;
     if ((int )termin != 44) {
       if ((int )termin != 34) {
         if ((int )termin != 39) {
           return (-1);
         }
       }
     }
     line ++;
     s1 = line;
     if ((int )termin == 44) {
       count = 0;
       while ((int )*line != 0) {
         if ((int )*line == 40) {
           count ++;
         } else
         if ((int )*line == 41) {
           count --;
         } else
         if ((int )*line == 44) {
           if (count <= 0) {
             break;
           }
         }
         line ++;
       }
     } else {
       while (1) {
         if ((int )*line != 0) {
           if (! ((int )*line != (int )termin)) {
             break;
           }
         } else {
           break;
         }
         line ++;
       }
     }
     if ((int )*line == 0) {
       return (-1);
     }
     if ((int )termin == 44) {
       tmp___12 = line;
       line ++;
       p___0 = tmp___12;
       while (1) {
         tmp___13 = __ctype_b_loc();
         if (! ((int const   )*(*tmp___13 + (int )*(p___0 + -1)) & 1)) {
           break;
         }
         p___0 --;
       }
       *p___0 = (char )'\000';
     } else {
       tmp___14 = line;
       line ++;
       *tmp___14 = (char )'\000';
     }
     s2 = variable_expand(s1);
     tmp___15 = strlen((char const   *)s2);
     len = (unsigned int )tmp___15;
     tmp___16 = __builtin_alloca((unsigned long )(len + 1U));
     s1 = (char *)tmp___16;
     memmove((void *)s1, (void const   *)s2, (size_t )(len + 1U));
     if ((int )termin != 44) {
       line = next_token(line);
     }
     if ((int )termin == 44) {
       termin = (char )')';
     } else {
       termin = *line;
     }
     if ((int )termin != 41) {
       if ((int )termin != 34) {
         if ((int )termin != 39) {
           return (-1);
         }
       }
     }
     if ((int )termin == 41) {
       count___0 = 0;
       s2 = next_token(line);
       line = s2;
       while ((int )*line != 0) {
         if ((int )*line == 40) {
           count___0 ++;
         } else
         if ((int )*line == 41) {
           if (count___0 <= 0) {
             break;
           } else {
             count___0 --;
           }
         }
         line ++;
       }
     } else {
       line ++;
       s2 = line;
       while (1) {
         if ((int )*line != 0) {
           if (! ((int )*line != (int )termin)) {
             break;
           }
         } else {
           break;
         }
         line ++;
       }
     }
     if ((int )*line == 0) {
       return (-1);
     }
     *line = (char )'\000';
     line ++;
     line = next_token(line);
     if ((int )*line != 0) {
       tmp___17 = dcgettext((char const   *)((void *)0), "Extraneous text after `%s\' directive",
                            5);
       error(flocp, (char const   *)tmp___17, cmdname);
     }
     s2 = variable_expand(s2);
     if ((unsigned long )s1 == (unsigned long )s2) {
       tmp___19 = 1;
     } else
     if ((int )*s1 == (int )*s2) {
       if ((int )*s1 == 0) {
         tmp___19 = 1;
       } else {
         tmp___18 = strcmp((char const   *)(s1 + 1), (char const   *)(s2 + 1));
         if (tmp___18) {
           tmp___19 = 0;
         } else {
           tmp___19 = 1;
         }
       }
     } else {
       tmp___19 = 0;
     }
     *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___19 == notdef);
   }
   i = 0U;
   while (i < conditionals->if_cmds) {
     if (*(conditionals->ignoring + i)) {
       return (1);
     }
     i ++;
   }
   return (0);
 }
 }
 void uniquize_deps(struct dep *chain ) 
 { 
   register struct dep *d ;
   struct dep *last ;
   struct dep *next ;
   struct dep *n ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   int tmp___6 ;
 
   {
   d = chain;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     last = d;
     next = d->next;
     while ((unsigned long )next != (unsigned long )((struct dep *)0)) {
       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
         tmp = (d->file)->name;
       } else {
         tmp = d->name;
       }
       if ((unsigned long )next->name == (unsigned long )((char *)0)) {
         tmp___0 = (next->file)->name;
       } else {
         tmp___0 = next->name;
       }
       if ((unsigned long )tmp == (unsigned long )tmp___0) {
         goto _L___0;
       } else {
         if ((unsigned long )d->name == (unsigned long )((char *)0)) {
           tmp___1 = (d->file)->name;
         } else {
           tmp___1 = d->name;
         }
         if ((unsigned long )next->name == (unsigned long )((char *)0)) {
           tmp___2 = (next->file)->name;
         } else {
           tmp___2 = next->name;
         }
         if ((int )*tmp___1 == (int )*tmp___2) {
           if ((unsigned long )d->name == (unsigned long )((char *)0)) {
             tmp___3 = (d->file)->name;
           } else {
             tmp___3 = d->name;
           }
           if ((int )*tmp___3 == 0) {
             goto _L___0;
           } else {
             if ((unsigned long )next->name == (unsigned long )((char *)0)) {
               tmp___4 = (next->file)->name;
             } else {
               tmp___4 = next->name;
             }
             if ((unsigned long )d->name == (unsigned long )((char *)0)) {
               tmp___5 = (d->file)->name;
             } else {
               tmp___5 = d->name;
             }
             tmp___6 = strcmp((char const   *)(tmp___5 + 1), (char const   *)(tmp___4 + 1));
             if (tmp___6) {
               last = next;
               next = next->next;
             } else {
               _L___0: /* CIL Label */ 
               n = next->next;
               last->next = n;
               if ((unsigned long )next->name != (unsigned long )((char *)0)) {
                 if ((unsigned long )next->name != (unsigned long )d->name) {
                   free((void *)next->name);
                 }
               }
               if ((unsigned long )next != (unsigned long )d) {
                 free((void *)((char *)next));
               }
               next = n;
             }
           }
         } else {
           last = next;
           next = next->next;
         }
       }
     }
     d = d->next;
   }
   return;
 }
 }
 static void record_target_var(struct nameseq *filenames , char *defn , int two_colon ,
                               enum variable_origin origin , struct floc  const  *flocp ) 
 { 
   struct nameseq *nextf ;
   struct variable_set_list *global ;
   struct variable *v ;
   register char *name ;
   struct variable_set_list *vlist ;
   char *fname ;
   char *percent ;
   struct pattern_var *p ;
   struct file *f ;
   char *tmp ;
   struct variable *gv ;
   int len ;
   size_t tmp___0 ;
   size_t tmp___1 ;
 
   {
   global = current_variable_set_list;
   while ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
     name = filenames->name;
     nextf = filenames->next;
     free((void *)((char *)filenames));
     percent = find_percent(name);
     if (percent) {
       p = create_pattern_var(name, percent);
       vlist = p->vars;
       fname = p->target;
     } else {
       f = enter_file(name);
       initialize_file_variables(f, 1);
       vlist = f->variables;
       fname = f->name;
     }
     current_variable_set_list = vlist;
     v = try_variable_definition(flocp, defn, origin, 1);
     if (! v) {
       tmp = dcgettext((char const   *)((void *)0), "Malformed per-target variable definition",
                       5);
       error(flocp, (char const   *)tmp);
     }
     v->per_target = 1U;
     if ((unsigned int )origin != 5U) {
       tmp___0 = strlen((char const   *)v->name);
       len = (int )tmp___0;
       current_variable_set_list = global;
       gv = lookup_variable(v->name, (unsigned int )len);
       if (gv) {
         if ((unsigned int )gv->origin == 3U) {
           define_variable_in_set(v->name, (unsigned int )len, gv->value, gv->origin,
                                  (int )gv->recursive, vlist->set, flocp);
         } else
         if ((unsigned int )gv->origin == 4U) {
           define_variable_in_set(v->name, (unsigned int )len, gv->value, gv->origin,
                                  (int )gv->recursive, vlist->set, flocp);
         }
       }
     }
     if ((unsigned long )name != (unsigned long )fname) {
       if ((unsigned long )name < (unsigned long )fname) {
         free((void *)name);
       } else {
         tmp___1 = strlen((char const   *)fname);
         if ((unsigned long )name > (unsigned long )(fname + tmp___1)) {
           free((void *)name);
         }
       }
     }
     filenames = nextf;
   }
   current_variable_set_list = global;
   return;
 }
 }
 static char *percent___0  =    (char *)"%";
 static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                          struct dep *deps , unsigned int cmds_started , char *commands ,
                          unsigned int commands_idx , int two_colon , struct floc  const  *flocp ,
                          int set_default ) 
 { 
   struct nameseq *nextf ;
   int implicit ;
   unsigned int max_targets ;
   unsigned int target_idx ;
   char **targets ;
   char **target_percents ;
   struct commands *cmds ;
   char *tmp ;
   register char *name ;
   register struct file *f ;
   register struct dep *d ;
   struct dep *this ;
   char *implicit_percent ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   struct dep *tmp___6 ;
   char *tmp___7 ;
   char *buffer ;
   char *tmp___8 ;
   char *o ;
   char *percent ;
   char *tmp___9 ;
   char *tmp___10 ;
   int tmp___11 ;
   char *tmp___12 ;
   char *tmp___13 ;
   char *tmp___14 ;
   char *tmp___15 ;
   struct dep *nextd ;
   struct dep *firstdeps ;
   struct dep *moredeps ;
   char *buffer___0 ;
   char *tmp___16 ;
   char *o___0 ;
   char *tmp___17 ;
   char *tmp___18 ;
   size_t tmp___19 ;
   int reject ;
   register struct dep *d2 ;
   char *tmp___20 ;
   char *tmp___21 ;
   char *tmp___22 ;
   char *tmp___23 ;
   int tmp___24 ;
   register unsigned int len ;
   char *tmp___25 ;
   size_t tmp___26 ;
   char *tmp___27 ;
   int tmp___28 ;
   char *tmp___29 ;
   char *tmp___30 ;
   char *tmp___31 ;
   int tmp___32 ;
   char *tmp___33 ;
 
   {
   implicit = 0;
   max_targets = 0U;
   target_idx = 0U;
   targets = (char **)0;
   target_percents = (char **)0;
   if (commands_idx > 0U) {
     tmp = xmalloc((unsigned int )sizeof(struct commands ));
     cmds = (struct commands *)tmp;
     cmds->fileinfo.filenm = (char *)flocp->filenm;
     cmds->fileinfo.lineno = (unsigned long )cmds_started;
     cmds->commands = savestring((char const   *)commands, commands_idx);
     cmds->command_lines = (char **)0;
   } else {
     cmds = (struct commands *)0;
   }
   while ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
     name = filenames->name;
     nextf = filenames->next;
     free((void *)filenames);
     implicit_percent = find_percent(name);
     implicit |= (unsigned long )implicit_percent != (unsigned long )((char *)0);
     if (implicit) {
       if ((unsigned long )pattern != (unsigned long )((char *)0)) {
         tmp___0 = dcgettext((char const   *)((void *)0), "mixed implicit and static pattern rules",
                             5);
         fatal(flocp, (char const   *)tmp___0);
       }
     }
     if (implicit) {
       if ((unsigned long )implicit_percent == (unsigned long )((char *)0)) {
         tmp___1 = dcgettext((char const   *)((void *)0), "mixed implicit and normal rules",
                             5);
         fatal(flocp, (char const   *)tmp___1);
       }
     }
     if (implicit) {
       if ((unsigned long )targets == (unsigned long )((char **)0)) {
         max_targets = 5U;
         tmp___2 = xmalloc((unsigned int )(5UL * sizeof(char *)));
         targets = (char **)tmp___2;
         tmp___3 = xmalloc((unsigned int )(5UL * sizeof(char *)));
         target_percents = (char **)tmp___3;
         target_idx = 0U;
       } else
       if (target_idx == max_targets - 1U) {
         max_targets += 5U;
         tmp___4 = xrealloc((char *)targets, (unsigned int )((unsigned long )max_targets * sizeof(char *)));
         targets = (char **)tmp___4;
         tmp___5 = xrealloc((char *)target_percents, (unsigned int )((unsigned long )max_targets * sizeof(char *)));
         target_percents = (char **)tmp___5;
       }
       *(targets + target_idx) = name;
       *(target_percents + target_idx) = implicit_percent;
       target_idx ++;
       goto __Cont;
     }
     if ((unsigned long )nextf != (unsigned long )((struct nameseq *)0)) {
       tmp___6 = copy_dep_chain(deps);
       this = tmp___6;
     } else {
       this = deps;
     }
     if ((unsigned long )pattern != (unsigned long )((char *)0)) {
       tmp___11 = pattern_matches(pattern, pattern_percent, name);
       if (tmp___11) {
         tmp___8 = variable_expand((char *)"");
         buffer = tmp___8;
         d = this;
         while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
           tmp___9 = find_percent(d->name);
           percent = tmp___9;
           if ((unsigned long )percent == (unsigned long )((char *)0)) {
             goto __Cont___0;
           }
           o = patsubst_expand(buffer, name, pattern, d->name, pattern_percent, percent);
           if ((unsigned long )o == (unsigned long )buffer) {
             tmp___10 = dcgettext((char const   *)((void *)0), "target `%s\' leaves prerequisite pattern empty",
                                  5);
             fatal(flocp, (char const   *)tmp___10, name);
           }
           free((void *)d->name);
           d->name = savestring((char const   *)buffer, (unsigned int )(o - buffer));
           __Cont___0: /* CIL Label */ 
           d = d->next;
         }
       } else {
         tmp___7 = dcgettext((char const   *)((void *)0), "target `%s\' doesn\'t match the target pattern",
                             5);
         error(flocp, (char const   *)tmp___7, name);
         this = (struct dep *)0;
       }
     }
     if (! two_colon) {
       f = enter_file(name);
       if (f->double_colon) {
         tmp___12 = dcgettext((char const   *)((void *)0), "target file `%s\' has both : and :: entries",
                              5);
         fatal(flocp, (char const   *)tmp___12, f->name);
       }
       if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
         if ((unsigned long )cmds == (unsigned long )f->cmds) {
           tmp___13 = dcgettext((char const   *)((void *)0), "target `%s\' given more than once in the same rule.",
                                5);
           error(flocp, (char const   *)tmp___13, f->name);
         } else {
           goto _L;
         }
       } else
       _L: /* CIL Label */ 
       if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
         if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
           if (f->is_target) {
             tmp___14 = dcgettext((char const   *)((void *)0), "warning: overriding commands for target `%s\'",
                                  5);
             error((struct floc  const  *)(& cmds->fileinfo), (char const   *)tmp___14,
                   f->name);
             tmp___15 = dcgettext((char const   *)((void *)0), "warning: ignoring old commands for target `%s\'",
                                  5);
             error((struct floc  const  *)(& (f->cmds)->fileinfo), (char const   *)tmp___15,
                   f->name);
           }
         }
       }
       f->is_target = 1U;
       if ((unsigned long )f == (unsigned long )default_file) {
         if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
           if ((unsigned long )cmds == (unsigned long )((struct commands *)0)) {
             f->cmds = (struct commands *)0;
           }
         }
       }
       if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
         f->cmds = cmds;
       }
       if ((unsigned long )f == (unsigned long )suffix_file) {
         if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
           d = f->deps;
           while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
             nextd = d->next;
             free((void *)d->name);
             free((void *)((char *)d));
             d = nextd;
           }
           f->deps = (struct dep *)0;
         } else {
           goto _L___0;
         }
       } else
       _L___0: /* CIL Label */ 
       if ((unsigned long )f->deps != (unsigned long )((struct dep *)0)) {
         if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
           firstdeps = this;
           moredeps = f->deps;
         } else {
           firstdeps = f->deps;
           moredeps = this;
         }
         if ((unsigned long )firstdeps == (unsigned long )((struct dep *)0)) {
           firstdeps = moredeps;
         } else {
           d = firstdeps;
           while ((unsigned long )d->next != (unsigned long )((struct dep *)0)) {
             d = d->next;
           }
           d->next = moredeps;
         }
         f->deps = firstdeps;
       } else {
         f->deps = this;
       }
       if ((unsigned long )pattern != (unsigned long )((char *)0)) {
         tmp___16 = variable_expand((char *)"");
         buffer___0 = tmp___16;
         tmp___17 = patsubst_expand(buffer___0, name, pattern, percent___0, pattern_percent,
                                    percent___0);
         o___0 = tmp___17;
         f->stem = savestring((char const   *)buffer___0, (unsigned int )(o___0 - buffer___0));
       }
     } else {
       f = lookup_file(name);
       if ((unsigned long )f != (unsigned long )((struct file *)0)) {
         if (f->is_target) {
           if (! f->double_colon) {
             tmp___18 = dcgettext((char const   *)((void *)0), "target file `%s\' has both : and :: entries",
                                  5);
             fatal(flocp, (char const   *)tmp___18, f->name);
           }
         }
       }
       f = enter_file(name);
       if ((unsigned long )f->double_colon == (unsigned long )((struct file *)0)) {
         f->double_colon = f;
       }
       f->is_target = 1U;
       f->deps = this;
       f->cmds = cmds;
     }
     if ((unsigned long )f != (unsigned long )((struct file *)0)) {
       if ((unsigned long )name != (unsigned long )f->name) {
         if ((unsigned long )name < (unsigned long )f->name) {
           free((void *)name);
           name = f->name;
         } else {
           tmp___19 = strlen((char const   *)f->name);
           if ((unsigned long )name > (unsigned long )(f->name + tmp___19)) {
             free((void *)name);
             name = f->name;
           }
         }
       }
     }
     if ((unsigned long )default_goal_file == (unsigned long )((struct file *)0)) {
       if (set_default) {
         if ((int )*name != 46) {
           goto _L___1;
         } else {
           tmp___33 = strchr((char const   *)name, '/');
           if ((unsigned long )tmp___33 != (unsigned long )((char *)0)) {
             _L___1: /* CIL Label */ 
             reject = 0;
             d = suffix_file->deps;
             while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
               if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                 tmp___20 = (d->file)->name;
               } else {
                 tmp___20 = d->name;
               }
               if ((int )*tmp___20 != 46) {
                 if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                   tmp___21 = (d->file)->name;
                 } else {
                   tmp___21 = d->name;
                 }
                 if ((unsigned long )name == (unsigned long )tmp___21) {
                   reject = 1;
                   break;
                 } else {
                   if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                     tmp___22 = (d->file)->name;
                   } else {
                     tmp___22 = d->name;
                   }
                   if ((int )*name == (int )*tmp___22) {
                     if ((int )*name == 0) {
                       reject = 1;
                       break;
                     } else {
                       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                         tmp___23 = (d->file)->name;
                       } else {
                         tmp___23 = d->name;
                       }
                       tmp___24 = strcmp((char const   *)(name + 1), (char const   *)(tmp___23 + 1));
                       if (! tmp___24) {
                         reject = 1;
                         break;
                       }
                     }
                   }
                 }
               }
               d2 = suffix_file->deps;
               while ((unsigned long )d2 != (unsigned long )((struct dep *)0)) {
                 if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
                   tmp___25 = (d2->file)->name;
                 } else {
                   tmp___25 = d2->name;
                 }
                 tmp___26 = strlen((char const   *)tmp___25);
                 len = (unsigned int )tmp___26;
                 if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
                   tmp___27 = (d2->file)->name;
                 } else {
                   tmp___27 = d2->name;
                 }
                 tmp___28 = strncmp((char const   *)name, (char const   *)tmp___27,
                                    (size_t )len);
                 if (! (tmp___28 == 0)) {
                   goto __Cont___1;
                 }
                 if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                   tmp___29 = (d->file)->name;
                 } else {
                   tmp___29 = d->name;
                 }
                 if ((unsigned long )(name + len) == (unsigned long )tmp___29) {
                   reject = 1;
                   break;
                 } else {
                   if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                     tmp___30 = (d->file)->name;
                   } else {
                     tmp___30 = d->name;
                   }
                   if ((int )*(name + len) == (int )*tmp___30) {
                     if ((int )*(name + len) == 0) {
                       reject = 1;
                       break;
                     } else {
                       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                         tmp___31 = (d->file)->name;
                       } else {
                         tmp___31 = d->name;
                       }
                       tmp___32 = strcmp((char const   *)((name + len) + 1), (char const   *)(tmp___31 + 1));
                       if (! tmp___32) {
                         reject = 1;
                         break;
                       }
                     }
                   }
                 }
                 __Cont___1: /* CIL Label */ 
                 d2 = d2->next;
               }
               if (reject) {
                 break;
               }
               d = d->next;
             }
             if (! reject) {
               default_goal_file = f;
             }
           }
         }
       }
     }
     __Cont: /* CIL Label */ 
     filenames = nextf;
   }
   if (implicit) {
     *(targets + target_idx) = (char *)0;
     *(target_percents + target_idx) = (char *)0;
     create_pattern_rule(targets, target_percents, two_colon, deps, cmds, 1);
     free((void *)((char *)target_percents));
   }
   return;
 }
 }
 char *find_char_unquote(char *string , char *stopchars , int blank ) 
 { 
   unsigned int string_len ;
   register char *p ;
   char *tmp ;
   unsigned short const   **tmp___0 ;
   register int i ;
   size_t tmp___1 ;
 
   {
   string_len = 0U;
   p = string;
   while (1) {
     while (1) {
       if ((int )*p != 0) {
         tmp = strchr((char const   *)stopchars, (int )*p);
         if ((unsigned long )tmp == (unsigned long )((char *)0)) {
           if (! (! blank)) {
             tmp___0 = __ctype_b_loc();
             if ((int const   )*(*tmp___0 + (int )*p) & 1) {
               break;
             }
           }
         } else {
           break;
         }
       } else {
         break;
       }
       p ++;
     }
     if ((int )*p == 0) {
       break;
     }
     if ((unsigned long )p > (unsigned long )string) {
       if ((int )*(p + -1) == 92) {
         i = -2;
         while (1) {
           if ((unsigned long )(p + i) >= (unsigned long )string) {
             if (! ((int )*(p + i) == 92)) {
               break;
             }
           } else {
             break;
           }
           i --;
         }
         i ++;
         if (string_len == 0U) {
           tmp___1 = strlen((char const   *)string);
           string_len = (unsigned int )tmp___1;
         }
         memmove((void *)(p + i), (void const   *)(p + i / 2), (size_t )((((long )string_len - (p - string)) - (long )(i / 2)) + 1L));
         p += i / 2;
         if (i % 2 == 0) {
           return (p);
         }
       } else {
         return (p);
       }
     } else {
       return (p);
     }
   }
   return ((char *)0);
 }
 }
 char *find_percent(char *pattern ) 
 { 
   char *tmp ;
 
   {
   tmp = find_char_unquote(pattern, (char *)"%", 0);
   return (tmp);
 }
 }
 struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                                int strip ) 
 { 
   register struct nameseq *new ;
   register struct nameseq *new1 ;
   register struct nameseq *lastnew1 ;
   register char *p ;
   char *q ;
   char *name ;
   char stopchars[3] ;
   size_t tmp ;
   char *tmp___0 ;
   struct nameseq *n ;
   struct nameseq *lastn ;
   char *paren ;
   char *libname ;
   void *tmp___1 ;
   size_t tmp___2 ;
   char *tmp___3 ;
 
   {
   new = (struct nameseq *)0;
   p = *stringp;
   stopchars[0] = (char )stopchar;
   stopchars[1] = (char )'\000';
   while (1) {
     p = next_token(p);
     if ((int )*p == 0) {
       break;
     }
     if ((int )*p == stopchar) {
       break;
     }
     q = p;
     p = find_char_unquote(q, stopchars, 1);
     if ((unsigned long )p == (unsigned long )((char *)0)) {
       tmp = strlen((char const   *)q);
       p = q + tmp;
     }
     if (strip) {
       while (1) {
         if (p - q > 2L) {
           if ((int )*(q + 0) == 46) {
             if (! ((int )*(q + 1) == 47)) {
               break;
             }
           } else {
             break;
           }
         } else {
           break;
         }
         q += 2;
         while (1) {
           if ((unsigned long )q < (unsigned long )p) {
             if (! ((int )*q == 47)) {
               break;
             }
           } else {
             break;
           }
           q ++;
         }
       }
     }
     if ((unsigned long )q == (unsigned long )p) {
       name = savestring("./", 2U);
     } else {
       name = savestring((char const   *)q, (unsigned int )(p - q));
     }
     tmp___0 = xmalloc(size);
     new1 = (struct nameseq *)tmp___0;
     new1->name = name;
     new1->next = new;
     new = new1;
   }
   new1 = new;
   lastnew1 = (struct nameseq *)0;
   while ((unsigned long )new1 != (unsigned long )((struct nameseq *)0)) {
     if ((int )*(new1->name + 0) != 40) {
       tmp___2 = strlen((char const   *)new1->name);
       if ((int )*(new1->name + (tmp___2 - 1UL)) == 41) {
         tmp___3 = strchr((char const   *)new1->name, '(');
         if ((unsigned long )tmp___3 == (unsigned long )((char *)0)) {
           n = new1->next;
           lastn = new1;
           paren = (char *)0;
           while (1) {
             if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
               paren = strchr((char const   *)n->name, '(');
               if (! ((unsigned long )paren == (unsigned long )((char *)0))) {
                 break;
               }
             } else {
               break;
             }
             lastn = n;
             n = n->next;
           }
           if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
             if ((int )*(n->name + 0) != 40) {
               paren ++;
               tmp___1 = __builtin_alloca((unsigned long )((paren - n->name) + 1L));
               libname = (char *)tmp___1;
               memmove((void *)libname, (void const   *)n->name, (size_t )(paren - n->name));
               *(libname + (paren - n->name)) = (char )'\000';
               if ((int )*paren == 0) {
                 lastn->next = n->next;
                 free((void *)n->name);
                 free((void *)((char *)n));
                 n = lastn->next;
               } else {
                 name = concat(libname, paren, (char *)")");
                 free((void *)n->name);
                 n->name = name;
               }
               if ((int )*(new1->name + 1) == 0) {
                 if ((unsigned long )lastnew1 == (unsigned long )((struct nameseq *)0)) {
                   new = new1->next;
                 } else {
                   lastnew1->next = new1->next;
                 }
                 lastn = new1;
                 new1 = new1->next;
                 free((void *)lastn->name);
                 free((void *)((char *)lastn));
               } else {
                 name = concat(libname, new1->name, (char *)"");
                 free((void *)new1->name);
                 new1->name = name;
                 new1 = new1->next;
               }
               while ((unsigned long )new1 != (unsigned long )n) {
                 name = concat(libname, new1->name, (char *)")");
                 free((void *)new1->name);
                 new1->name = name;
                 lastnew1 = new1;
                 new1 = new1->next;
               }
             } else {
               lastnew1 = new1;
               new1 = new1->next;
             }
           } else {
             lastnew1 = new1;
             new1 = new1->next;
           }
         } else {
           lastnew1 = new1;
           new1 = new1->next;
         }
       } else {
         lastnew1 = new1;
         new1 = new1->next;
       }
     } else {
       lastnew1 = new1;
       new1 = new1->next;
     }
   }
   *stringp = p;
   return (new);
 }
 }
 static unsigned long readline(struct linebuffer *linebuffer , FILE *stream , struct floc  const  *flocp ) 
 { 
   char *buffer ;
   register char *p ;
   register char *end ;
   register int len ;
   register int lastlen ;
   register char *p2 ;
   register unsigned int nlines ;
   register int backslash ;
   size_t tmp ;
   char *tmp___0 ;
   register unsigned int p_off ;
   char *tmp___1 ;
   register unsigned int p_off___0 ;
   char *tmp___2 ;
   char *tmp___3 ;
   int tmp___4 ;
 
   {
   buffer = linebuffer->buffer;
   p = linebuffer->buffer;
   end = p + linebuffer->size;
   lastlen = 0;
   nlines = 0U;
   *p = (char )'\000';
   while (1) {
     tmp___3 = fgets((char * __restrict  )p, (int )(end - p), (FILE * __restrict  )stream);
     if (! ((unsigned long )tmp___3 != (unsigned long )((char *)0))) {
       break;
     }
     tmp = strlen((char const   *)p);
     len = (int )tmp;
     if (len == 0) {
       tmp___0 = dcgettext((char const   *)((void *)0), "warning: NUL character seen; rest of line ignored",
                           5);
       error(flocp, (char const   *)tmp___0);
       *(p + 0) = (char )'\n';
       len = 1;
     }
     p += len;
     if ((int )*(p + -1) != 10) {
       p_off = (unsigned int )(p - buffer);
       linebuffer->size *= 2U;
       tmp___1 = xrealloc(buffer, linebuffer->size);
       buffer = tmp___1;
       p = buffer + p_off;
       end = buffer + linebuffer->size;
       linebuffer->buffer = buffer;
       *p = (char )'\000';
       lastlen = len;
       continue;
     }
     nlines ++;
     if (len > 1) {
       if ((int )*(p + -2) == 13) {
         len --;
         p --;
         *(p + -1) = (char )'\n';
       }
     }
     if (len == 1) {
       if ((unsigned long )p > (unsigned long )buffer) {
         len += lastlen;
       }
     }
     lastlen = len;
     backslash = 0;
     p2 = p - 2;
     while (1) {
       len --;
       if (! (len > 0)) {
         break;
       }
       if ((int )*p2 == 92) {
         backslash = ! backslash;
       } else {
         break;
       }
       p2 --;
     }
     if (! backslash) {
       *(p + -1) = (char )'\000';
       break;
     }
     if (end - p <= 1L) {
       p_off___0 = (unsigned int )(p - buffer);
       linebuffer->size *= 2U;
       tmp___2 = xrealloc(buffer, linebuffer->size);
       buffer = tmp___2;
       p = buffer + p_off___0;
       end = buffer + linebuffer->size;
       linebuffer->buffer = buffer;
     }
   }
   tmp___4 = ferror(stream);
   if (tmp___4) {
     pfatal_with_name((char *)flocp->filenm);
   }
   return ((unsigned long )nlines);
 }
 }
 static enum make_word_type get_next_mword(char *buffer , char *delim , char **startp ,
                                           unsigned int *length___0 ) 
 { 
   enum make_word_type wtype ;
   char *p ;
   char *beg ;
   char c ;
   unsigned short const   **tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char closeparen ;
   int count ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
 
   {
   wtype = (enum make_word_type )0;
   p = buffer;
   while (1) {
     tmp = __ctype_b_loc();
     if (! ((int const   )*(*tmp + (int )*p) & 1)) {
       break;
     }
     p ++;
   }
   beg = p;
   tmp___0 = p;
   p ++;
   c = *tmp___0;
   switch ((int )c) {
   case 0: 
   wtype = (enum make_word_type )1;
   break;
   case 35: 
   wtype = (enum make_word_type )7;
   break;
   case 59: 
   wtype = (enum make_word_type )6;
   break;
   case 61: 
   wtype = (enum make_word_type )8;
   break;
   case 58: 
   wtype = (enum make_word_type )4;
   switch ((int )*p) {
   case 58: 
   p ++;
   wtype = (enum make_word_type )5;
   break;
   case 61: 
   p ++;
   wtype = (enum make_word_type )8;
   break;
   }
   break;
   case 63: 
   case 43: 
   if ((int )*p == 61) {
     p ++;
     wtype = (enum make_word_type )8;
     break;
   }
   default: 
   if (delim) {
     tmp___1 = strchr((char const   *)delim, (int )c);
     if (tmp___1) {
       wtype = (enum make_word_type )2;
     }
   }
   break;
   }
   if ((unsigned int )wtype != 0U) {
     goto done;
   }
   wtype = (enum make_word_type )2;
   while (1) {
     switch ((int )c) {
     case 35: 
     case 61: 
     case 9: 
     case 32: 
     case 0: 
     goto done_word;
     case 58: 
     goto done_word;
     case 36: 
     tmp___2 = p;
     p ++;
     c = *tmp___2;
     if ((int )c == 36) {
       break;
     }
     wtype = (enum make_word_type )3;
     if ((int )c == 40) {
       closeparen = (char )')';
     } else
     if ((int )c == 123) {
       closeparen = (char )'}';
     } else {
       break;
     }
     count = 0;
     while ((int )*p != 0) {
       if ((int )*p == (int )c) {
         count ++;
       } else
       if ((int )*p == (int )closeparen) {
         count --;
         if (count < 0) {
           p ++;
           break;
         }
       }
       p ++;
     }
     break;
     case 43: 
     case 63: 
     if ((int )*p == 61) {
       goto done_word;
     }
     break;
     case 92: 
     switch ((int )*p) {
     case 92: 
     case 61: 
     case 59: 
     case 58: 
     p ++;
     break;
     }
     break;
     default: 
     if (delim) {
       tmp___3 = strchr((char const   *)delim, (int )c);
       if (tmp___3) {
         goto done_word;
       }
     }
     break;
     }
     tmp___4 = p;
     p ++;
     c = *tmp___4;
   }
   done_word: 
   p --;
   done: 
   if (startp) {
     *startp = beg;
   }
   if (length___0) {
     *length___0 = (unsigned int )(p - beg);
   }
   return (wtype);
 }
 }
 void construct_include_path(char **arg_dirs ) 
 { 
   register unsigned int i ;
   struct stat stbuf ;
   register unsigned int defsize ;
   register unsigned int max ;
   register char **dirs___0 ;
   char *tmp ;
   register unsigned int idx ;
   char *dir ;
   char **tmp___0 ;
   char *expanded ;
   char *tmp___1 ;
   char *tmp___2 ;
   unsigned int tmp___3 ;
   int tmp___4 ;
   unsigned int tmp___5 ;
   int tmp___6 ;
   unsigned int len ;
   size_t tmp___7 ;
 
   {
   defsize = (unsigned int )(sizeof(default_include_directories) / sizeof(default_include_directories[0]));
   max = 5U;
   tmp = xmalloc((unsigned int )((unsigned long )(5U + defsize) * sizeof(char *)));
   dirs___0 = (char **)tmp;
   idx = 0U;
   if ((unsigned long )arg_dirs != (unsigned long )((char **)0)) {
     while ((unsigned long )*arg_dirs != (unsigned long )((char *)0)) {
       tmp___0 = arg_dirs;
       arg_dirs ++;
       dir = *tmp___0;
       if ((int )*(dir + 0) == 126) {
         tmp___1 = tilde_expand(dir);
         expanded = tmp___1;
         if ((unsigned long )expanded != (unsigned long )((char *)0)) {
           dir = expanded;
         }
       }
       tmp___4 = stat((char const   * __restrict  )dir, (struct stat * __restrict  )(& stbuf));
       if (tmp___4 == 0) {
         if ((stbuf.st_mode & 61440U) == 16384U) {
           if (idx == max - 1U) {
             max += 5U;
             tmp___2 = xrealloc((char *)dirs___0, (unsigned int )((unsigned long )(max + defsize) * sizeof(char *)));
             dirs___0 = (char **)tmp___2;
           }
           tmp___3 = idx;
           idx ++;
           *(dirs___0 + tmp___3) = dir;
         } else {
           goto _L;
         }
       } else
       _L: /* CIL Label */ 
       if ((unsigned long )dir != (unsigned long )*(arg_dirs + -1)) {
         free((void *)dir);
       }
     }
   }
   i = 0U;
   while ((unsigned long )default_include_directories[i] != (unsigned long )((char *)0)) {
     tmp___6 = stat((char const   * __restrict  )default_include_directories[i], (struct stat * __restrict  )(& stbuf));
     if (tmp___6 == 0) {
       if ((stbuf.st_mode & 61440U) == 16384U) {
         tmp___5 = idx;
         idx ++;
         *(dirs___0 + tmp___5) = default_include_directories[i];
       }
     }
     i ++;
   }
   *(dirs___0 + idx) = (char *)0;
   max_incl_len = 0U;
   i = 0U;
   while (i < idx) {
     tmp___7 = strlen((char const   *)*(dirs___0 + i));
     len = (unsigned int )tmp___7;
     if ((int )*(*(dirs___0 + i) + (len - 1U)) == 47) {
       *(dirs___0 + i) = savestring((char const   *)*(dirs___0 + i), len - 1U);
     }
     if (len > max_incl_len) {
       max_incl_len = len;
     }
     i ++;
   }
   include_directories___0 = dirs___0;
   return;
 }
 }
 char *tilde_expand(char *name ) 
 { 
   char *home_dir ;
   int is_variable ;
   int save ;
   char *logname ;
   char *tmp ;
   struct passwd *p ;
   struct passwd *tmp___0 ;
   char *new ;
   char *tmp___1 ;
   struct passwd *pwent ;
   char *userend ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
 
   {
   if ((int )*(name + 1) == 47) {
     goto _L___0;
   } else
   if ((int )*(name + 1) == 0) {
     _L___0: /* CIL Label */ 
     save = warn_undefined_variables_flag;
     warn_undefined_variables_flag = 0;
     home_dir = allocated_variable_expand_for_file((char *)"$(HOME)", (struct file *)0);
     warn_undefined_variables_flag = save;
     is_variable = (int )*(home_dir + 0) != 0;
     if (! is_variable) {
       free((void *)home_dir);
       home_dir = getenv("HOME");
     }
     if ((unsigned long )home_dir == (unsigned long )((char *)0)) {
       goto _L;
     } else
     if ((int )*(home_dir + 0) == 0) {
       _L: /* CIL Label */ 
       tmp = getlogin();
       logname = tmp;
       home_dir = (char *)0;
       if ((unsigned long )logname != (unsigned long )((char *)0)) {
         tmp___0 = getpwnam((char const   *)logname);
         p = tmp___0;
         if ((unsigned long )p != (unsigned long )((struct passwd *)0)) {
           home_dir = p->pw_dir;
         }
       }
     }
     if ((unsigned long )home_dir != (unsigned long )((char *)0)) {
       tmp___1 = concat(home_dir, (char *)"", name + 1);
       new = tmp___1;
       if (is_variable) {
         free((void *)home_dir);
       }
       return (new);
     }
   } else {
     tmp___2 = strchr((char const   *)(name + 1), '/');
     userend = tmp___2;
     if ((unsigned long )userend != (unsigned long )((char *)0)) {
       *userend = (char )'\000';
     }
     pwent = getpwnam((char const   *)(name + 1));
     if ((unsigned long )pwent != (unsigned long )((struct passwd *)0)) {
       if ((unsigned long )userend == (unsigned long )((char *)0)) {
         tmp___3 = xstrdup((char const   *)pwent->pw_dir);
         return (tmp___3);
       } else {
         tmp___4 = concat(pwent->pw_dir, (char *)"/", userend + 1);
         return (tmp___4);
       }
     } else
     if ((unsigned long )userend != (unsigned long )((char *)0)) {
       *userend = (char )'/';
     }
   }
   return ((char *)0);
 }
 }
 struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) 
 { 
   register struct nameseq *new ;
   register struct nameseq *old ;
   struct nameseq *nexto ;
   glob_t gl ;
   char *memname ;
   char *newname ;
   char *tmp ;
   char *arname ;
   int tmp___0 ;
   int tmp___1 ;
   register int i ;
   struct nameseq *found ;
   struct nameseq *tmp___2 ;
   struct nameseq *elt ;
   char *tmp___3 ;
   unsigned int alen ;
   size_t tmp___4 ;
   unsigned int mlen ;
   size_t tmp___5 ;
   char *tmp___6 ;
   struct nameseq *f ;
   struct nameseq *elt___0 ;
   char *tmp___7 ;
   int tmp___8 ;
   char *tmp___9 ;
 
   {
   new = (struct nameseq *)0;
   dir_setup_glob(& gl);
   old = chain;
   while ((unsigned long )old != (unsigned long )((struct nameseq *)0)) {
     nexto = old->next;
     if ((int )*(old->name + 0) == 126) {
       tmp = tilde_expand(old->name);
       newname = tmp;
       if ((unsigned long )newname != (unsigned long )((char *)0)) {
         free((void *)old->name);
         old->name = newname;
       }
     }
     tmp___0 = ar_name(old->name);
     if (tmp___0) {
       ar_parse_name(old->name, & arname, & memname);
       free((void *)old->name);
       old->name = arname;
     } else {
       memname = (char *)0;
     }
     tmp___1 = glob((char const   *)old->name, (1 << 4) | (1 << 9), (int (*)(char const   * ,
                                                                             int  ))((void *)0),
                    & gl);
     switch (tmp___1) {
     case 0: 
     i = (int )gl.gl_pathc;
     while (1) {
       tmp___8 = i;
       i --;
       if (! (tmp___8 > 0)) {
         break;
       }
       if ((unsigned long )memname != (unsigned long )((char *)0)) {
         tmp___2 = ar_glob(*(gl.gl_pathv + i), memname, size);
         found = tmp___2;
         if ((unsigned long )found == (unsigned long )((struct nameseq *)0)) {
           tmp___3 = xmalloc(size);
           elt = (struct nameseq *)tmp___3;
           tmp___4 = strlen((char const   *)*(gl.gl_pathv + i));
           alen = (unsigned int )tmp___4;
           tmp___5 = strlen((char const   *)memname);
           mlen = (unsigned int )tmp___5;
           tmp___6 = xmalloc(((alen + 1U) + mlen) + 2U);
           elt->name = tmp___6;
           memmove((void *)elt->name, (void const   *)*(gl.gl_pathv + i), (size_t )alen);
           *(elt->name + alen) = (char )'(';
           memmove((void *)(elt->name + (alen + 1U)), (void const   *)memname, (size_t )mlen);
           *(elt->name + ((alen + 1U) + mlen)) = (char )')';
           *(elt->name + (((alen + 1U) + mlen) + 1U)) = (char )'\000';
           elt->next = new;
           new = elt;
         } else {
           f = found;
           while ((unsigned long )f->next != (unsigned long )((struct nameseq *)0)) {
             f = f->next;
           }
           f->next = new;
           new = found;
         }
         free((void *)memname);
       } else {
         tmp___7 = xmalloc(size);
         elt___0 = (struct nameseq *)tmp___7;
         elt___0->name = xstrdup((char const   *)*(gl.gl_pathv + i));
         elt___0->next = new;
         new = elt___0;
       }
     }
     globfree(& gl);
     free((void *)old->name);
     free((void *)((char *)old));
     break;
     case 1: 
     tmp___9 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
     fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___9);
     break;
     default: 
     old->next = new;
     new = old;
     break;
     }
     old = nexto;
   }
   return (new);
 }
 }
 #pragma merger("0","/tmp/cil-iRzmYf7g.i","-g,-O0")
 int gpath_search(char *file , int len ) ;
 unsigned int commands_started  =    0U;
 static int update_file(struct file *file , unsigned int depth ) ;
 static int update_file_1(struct file *file , unsigned int depth ) ;
 static int check_dep(struct file *file , unsigned int depth , uintmax_t this_mtime ,
                      int *must_make_ptr ) ;
 static int touch_file(struct file *file ) ;
 static void remake_file(struct file *file ) ;
 static uintmax_t name_mtime(char *name ) ;
 static int library_search(char **lib , uintmax_t *mtime_ptr ) ;
 int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) 
 { 
   int t ;
   int q ;
   int n ;
   unsigned int j ;
   int status ;
   struct dep *g ;
   register struct dep *g___0 ;
   register struct dep *lastgoal___0 ;
   struct file *file ;
   int stop ;
   int any_not_updated ;
   unsigned int ocommands_started ;
   int x ;
   int tmp ;
   int tmp___0 ;
   uintmax_t mtime ;
   uintmax_t tmp___1 ;
   uintmax_t tmp___2 ;
   uintmax_t tmp___3 ;
   uintmax_t tmp___4 ;
   uintmax_t tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
 
   {
   t = touch_flag;
   q = question_flag;
   n = just_print_flag;
   j = job_slots;
   status = -1;
   goals___0 = copy_dep_chain(goals___0);
   g = goals___0;
   while ((unsigned long )g != (unsigned long )((struct dep *)0)) {
     g->changed = 0;
     g = g->next;
   }
   considered = 1U;
   while ((unsigned long )goals___0 != (unsigned long )((struct dep *)0)) {
     start_waiting_jobs();
     reap_children(1, 0);
     lastgoal___0 = (struct dep *)0;
     g___0 = goals___0;
     while ((unsigned long )g___0 != (unsigned long )((struct dep *)0)) {
       stop = 0;
       any_not_updated = 0;
       if ((g___0->file)->double_colon) {
         file = (g___0->file)->double_colon;
       } else {
         file = g___0->file;
       }
       while ((unsigned long )file != (unsigned long )((void *)0)) {
         while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
           file = file->renamed;
         }
         if (makefiles___0) {
           if (file->cmd_target) {
             touch_flag = t;
             question_flag = q;
             just_print_flag = n;
           } else {
             just_print_flag = 0;
             question_flag = just_print_flag;
             touch_flag = question_flag;
           }
         }
         ocommands_started = commands_started;
         if (makefiles___0) {
           tmp = 1;
         } else {
           tmp = 0;
         }
         x = update_file(file, (unsigned int )tmp);
         while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
           file = file->renamed;
         }
         g___0->changed = (int )((unsigned int )g___0->changed + (commands_started - ocommands_started));
         stop = 0;
         if (x != 0) {
           goto _L;
         } else
         if (file->updated) {
           _L: /* CIL Label */ 
           if (status < 1) {
             if ((int )file->update_status != 0) {
               status = (int )file->update_status;
               if (! keep_going_flag) {
                 if (! question_flag) {
                   if (! makefiles___0) {
                     tmp___0 = 1;
                   } else {
                     tmp___0 = 0;
                   }
                 } else {
                   tmp___0 = 0;
                 }
               } else {
                 tmp___0 = 0;
               }
               stop = tmp___0;
             } else {
               if (makefiles___0) {
                 if (file->last_mtime) {
                   tmp___2 = file->last_mtime;
                 } else {
                   tmp___1 = f_mtime(file, 0);
                   tmp___2 = tmp___1;
                 }
                 tmp___5 = tmp___2;
               } else {
                 if (file->last_mtime) {
                   tmp___4 = file->last_mtime;
                 } else {
                   tmp___3 = f_mtime(file, 1);
                   tmp___4 = tmp___3;
                 }
                 tmp___5 = tmp___4;
               }
               mtime = tmp___5;
               while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
                 file = file->renamed;
               }
               if (file->updated) {
                 if (g___0->changed) {
                   if (mtime != file->mtime_before_update) {
                     if (! makefiles___0) {
                       status = 0;
                     } else
                     if (! just_print_flag) {
                       if (! question_flag) {
                         status = 0;
                       }
                     }
                     if (makefiles___0) {
                       if (file->dontcare) {
                         stop = 1;
                       }
                     }
                   }
                 }
               }
             }
           }
         }
         any_not_updated |= ! file->updated;
         if (stop) {
           break;
         }
         file = file->prev;
       }
       file = g___0->file;
       if (stop) {
         goto _L___0;
       } else
       if (! any_not_updated) {
         _L___0: /* CIL Label */ 
         if (! makefiles___0) {
           if ((int )file->update_status == 0) {
             if (! g___0->changed) {
               if (! silent_flag) {
                 if (! question_flag) {
                   if (file->phony) {
                     tmp___6 = dcgettext((char const   *)((void *)0), "Nothing to be done for `%s\'.",
                                         5);
                     tmp___8 = tmp___6;
                   } else
                   if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
                     tmp___6 = dcgettext((char const   *)((void *)0), "Nothing to be done for `%s\'.",
                                         5);
                     tmp___8 = tmp___6;
                   } else {
                     tmp___7 = dcgettext((char const   *)((void *)0), "`%s\' is up to date.",
                                         5);
                     tmp___8 = tmp___7;
                   }
                   message(1, (char const   *)tmp___8, file->name);
                 }
               }
             }
           }
         }
         if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
           goals___0 = g___0->next;
         } else {
           lastgoal___0->next = g___0->next;
         }
         free((void *)((char *)g___0));
         if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
           g___0 = goals___0;
         } else {
           g___0 = lastgoal___0->next;
         }
         if (stop) {
           break;
         }
       } else {
         lastgoal___0 = g___0;
         g___0 = g___0->next;
       }
     }
     if ((unsigned long )g___0 == (unsigned long )((struct dep *)0)) {
       considered = (unsigned int )(! considered);
     }
   }
   if (makefiles___0) {
     touch_flag = t;
     question_flag = q;
     just_print_flag = n;
     job_slots = j;
   }
   return (status);
 }
 }
 static int update_file(struct file *file , unsigned int depth ) 
 { 
   register int status ;
   register struct file *f ;
   char *tmp ;
   int tmp___0 ;
   int tmp___1 ;
   struct dep *d ;
   int tmp___2 ;
 
   {
   status = 0;
   if (file->double_colon) {
     f = file->double_colon;
   } else {
     f = file;
   }
   if (f->considered == considered) {
     while (1) {
       if (2 & db_level) {
         print_spaces(depth);
         tmp = dcgettext((char const   *)((void *)0), "Pruning file `%s\'.\n", 5);
         printf((char const   * __restrict  )tmp, file->name);
         fflush(stdout);
       }
       break;
     }
     if ((unsigned int )f->command_state == 3U) {
       tmp___0 = (int )f->update_status;
     } else {
       tmp___0 = 0;
     }
     return (tmp___0);
   }
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     f->considered = considered;
     tmp___1 = update_file_1(f, depth);
     status |= tmp___1;
     while ((unsigned long )f->renamed != (unsigned long )((struct file *)0)) {
       f = f->renamed;
     }
     if (status != 0) {
       if (! keep_going_flag) {
         break;
       }
     }
     if ((unsigned int )f->command_state == 2U) {
       status = 0;
       break;
     } else
     if ((unsigned int )f->command_state == 1U) {
       status = 0;
       break;
     }
     f = f->prev;
   }
   while ((unsigned long )f != (unsigned long )((struct file *)0)) {
     f->considered = considered;
     d = f->deps;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       tmp___2 = update_file(d->file, depth + 1U);
       status |= tmp___2;
       d = d->next;
     }
     f = f->prev;
   }
   return (status);
 }
 }
 static int update_file_1(struct file *file , unsigned int depth ) 
 { 
   register uintmax_t this_mtime ;
   int noexist ;
   int must_make ;
   int deps_changed ;
   int dep_status ;
   register struct dep *d ;
   register struct dep *lastd ;
   int running ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   struct file *tmp___4 ;
   uintmax_t tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   int tmp___9 ;
   char *tmp___10 ;
   uintmax_t mtime ;
   uintmax_t tmp___11 ;
   char *tmp___12 ;
   struct file *tmp___13 ;
   int tmp___14 ;
   register struct file *f ;
   int tmp___15 ;
   uintmax_t tmp___16 ;
   uintmax_t tmp___17 ;
   uintmax_t mtime___0 ;
   uintmax_t tmp___18 ;
   uintmax_t tmp___19 ;
   int tmp___20 ;
   register struct file *f___0 ;
   int tmp___21 ;
   uintmax_t tmp___22 ;
   uintmax_t tmp___23 ;
   int tmp___24 ;
   struct file *tmp___25 ;
   char *tmp___26 ;
   char *tmp___27 ;
   char *tmp___28 ;
   char *tmp___29 ;
   uintmax_t d_mtime ;
   uintmax_t tmp___30 ;
   uintmax_t tmp___31 ;
   int tmp___32 ;
   char const   *fmt ;
   char *tmp___33 ;
   char *tmp___34 ;
   char *tmp___35 ;
   char *tmp___36 ;
   char *tmp___37 ;
   char *tmp___38 ;
   char *tmp___39 ;
   char *tmp___40 ;
   int tmp___41 ;
   char *tmp___42 ;
   char *tmp___43 ;
   int tmp___44 ;
   char *tmp___45 ;
   char *tmp___46 ;
   char *tmp___47 ;
   char *tmp___48 ;
 
   {
   dep_status = 0;
   running = 0;
   while (1) {
     if (2 & db_level) {
       print_spaces(depth);
       tmp = dcgettext((char const   *)((void *)0), "Considering target file `%s\'.\n",
                       5);
       printf((char const   * __restrict  )tmp, file->name);
       fflush(stdout);
     }
     break;
   }
   if (file->updated) {
     if ((int )file->update_status > 0) {
       while (1) {
         if (2 & db_level) {
           print_spaces(depth);
           tmp___0 = dcgettext((char const   *)((void *)0), "Recently tried and failed to update file `%s\'.\n",
                               5);
           printf((char const   * __restrict  )tmp___0, file->name);
           fflush(stdout);
         }
         break;
       }
       return ((int )file->update_status);
     }
     while (1) {
       if (2 & db_level) {
         print_spaces(depth);
         tmp___1 = dcgettext((char const   *)((void *)0), "File `%s\' was considered already.\n",
                             5);
         printf((char const   * __restrict  )tmp___1, file->name);
         fflush(stdout);
       }
       break;
     }
     return (0);
   }
   switch ((unsigned int )file->command_state) {
   case 1U: 
   case 0U: 
   break;
   case 2U: 
   while (1) {
     if (2 & db_level) {
       print_spaces(depth);
       tmp___2 = dcgettext((char const   *)((void *)0), "Still updating file `%s\'.\n",
                           5);
       printf((char const   * __restrict  )tmp___2, file->name);
       fflush(stdout);
     }
     break;
   }
   return (0);
   case 3U: 
   while (1) {
     if (2 & db_level) {
       print_spaces(depth);
       tmp___3 = dcgettext((char const   *)((void *)0), "Finished updating file `%s\'.\n",
                           5);
       printf((char const   * __restrict  )tmp___3, file->name);
       fflush(stdout);
     }
     break;
   }
   return ((int )file->update_status);
   default: 
   abort();
   }
   depth ++;
   if (file->double_colon) {
     tmp___4 = file->double_colon;
   } else {
     tmp___4 = file;
   }
   tmp___4->updating = 1U;
   if (file->last_mtime) {
     this_mtime = file->last_mtime;
   } else {
     tmp___5 = f_mtime(file, 1);
     this_mtime = tmp___5;
   }
   while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
     file = file->renamed;
   }
   noexist = this_mtime == 0xffffffffffffffffUL;
   if (noexist) {
     while (1) {
       if (1 & db_level) {
         print_spaces(depth);
         tmp___6 = dcgettext((char const   *)((void *)0), "File `%s\' does not exist.\n",
                             5);
         printf((char const   * __restrict  )tmp___6, file->name);
         fflush(stdout);
       }
       break;
     }
   }
   must_make = noexist;
   if (! file->phony) {
     if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
       if (! file->tried_implicit) {
         tmp___9 = try_implicit_rule(file, depth);
         if (tmp___9) {
           while (1) {
             if (8 & db_level) {
               print_spaces(depth);
               tmp___7 = dcgettext((char const   *)((void *)0), "Found an implicit rule for `%s\'.\n",
                                   5);
               printf((char const   * __restrict  )tmp___7, file->name);
               fflush(stdout);
             }
             break;
           }
         } else {
           while (1) {
             if (8 & db_level) {
               print_spaces(depth);
               tmp___8 = dcgettext((char const   *)((void *)0), "No implicit rule found for `%s\'.\n",
                                   5);
               printf((char const   * __restrict  )tmp___8, file->name);
               fflush(stdout);
             }
             break;
           }
         }
         file->tried_implicit = 1U;
       }
     }
   }
   if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
     if (! file->is_target) {
       if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
         if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
           while (1) {
             if (8 & db_level) {
               print_spaces(depth);
               tmp___10 = dcgettext((char const   *)((void *)0), "Using default commands for `%s\'.\n",
                                    5);
               printf((char const   * __restrict  )tmp___10, file->name);
               fflush(stdout);
             }
             break;
           }
           file->cmds = default_file->cmds;
         }
       }
     }
   }
   lastd = (struct dep *)0;
   d = file->deps;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
       d->file = (d->file)->renamed;
     }
     if ((d->file)->last_mtime) {
       mtime = (d->file)->last_mtime;
     } else {
       tmp___11 = f_mtime(d->file, 1);
       mtime = tmp___11;
     }
     while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
       d->file = (d->file)->renamed;
     }
     if ((d->file)->double_colon) {
       tmp___13 = (d->file)->double_colon;
     } else {
       tmp___13 = d->file;
     }
     if (tmp___13->updating) {
       tmp___12 = dcgettext((char const   *)((void *)0), "Circular %s <- %s dependency dropped.",
                            5);
       error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___12, file->name,
             (d->file)->name);
       if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
         file->deps = d->next;
       } else {
         lastd->next = d->next;
       }
       d = d->next;
       continue;
     }
     (d->file)->parent = file;
     tmp___14 = check_dep(d->file, depth, this_mtime, & must_make);
     dep_status |= tmp___14;
     while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
       d->file = (d->file)->renamed;
     }
     f = d->file;
     if (f->double_colon) {
       f = f->double_colon;
     }
     while (1) {
       if ((unsigned int )f->command_state == 2U) {
         tmp___15 = 1;
       } else
       if ((unsigned int )f->command_state == 1U) {
         tmp___15 = 1;
       } else {
         tmp___15 = 0;
       }
       running |= tmp___15;
       f = f->prev;
       if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
         break;
       }
     }
     if (dep_status != 0) {
       if (! keep_going_flag) {
         break;
       }
     }
     if (! running) {
       if ((d->file)->last_mtime) {
         tmp___17 = (d->file)->last_mtime;
       } else {
         tmp___16 = f_mtime(d->file, 1);
         tmp___17 = tmp___16;
       }
       d->changed = tmp___17 != mtime;
     }
     lastd = d;
     d = d->next;
   }
   if (must_make) {
     d = file->deps;
     while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
       if ((d->file)->intermediate) {
         if ((d->file)->last_mtime) {
           tmp___19 = (d->file)->last_mtime;
         } else {
           tmp___18 = f_mtime(d->file, 1);
           tmp___19 = tmp___18;
         }
         mtime___0 = tmp___19;
         while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
           d->file = (d->file)->renamed;
         }
         (d->file)->parent = file;
         tmp___20 = update_file(d->file, depth);
         dep_status |= tmp___20;
         while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
           d->file = (d->file)->renamed;
         }
         f___0 = d->file;
         if (f___0->double_colon) {
           f___0 = f___0->double_colon;
         }
         while (1) {
           if ((unsigned int )f___0->command_state == 2U) {
             tmp___21 = 1;
           } else
           if ((unsigned int )f___0->command_state == 1U) {
             tmp___21 = 1;
           } else {
             tmp___21 = 0;
           }
           running |= tmp___21;
           f___0 = f___0->prev;
           if (! ((unsigned long )f___0 != (unsigned long )((struct file *)0))) {
             break;
           }
         }
         if (dep_status != 0) {
           if (! keep_going_flag) {
             break;
           }
         }
         if (! running) {
           if (file->phony) {
             if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
               tmp___24 = 1;
             } else {
               goto _L;
             }
           } else {
             _L: /* CIL Label */ 
             if ((d->file)->last_mtime) {
               tmp___23 = (d->file)->last_mtime;
             } else {
               tmp___22 = f_mtime(d->file, 1);
               tmp___23 = tmp___22;
             }
             if (tmp___23 != mtime___0) {
               tmp___24 = 1;
             } else {
               tmp___24 = 0;
             }
           }
           d->changed = tmp___24;
         }
       }
       d = d->next;
     }
   }
   if (file->double_colon) {
     tmp___25 = file->double_colon;
   } else {
     tmp___25 = file;
   }
   tmp___25->updating = 0U;
   while (1) {
     if (2 & db_level) {
       print_spaces(depth);
       tmp___26 = dcgettext((char const   *)((void *)0), "Finished prerequisites of target file `%s\'.\n",
                            5);
       printf((char const   * __restrict  )tmp___26, file->name);
       fflush(stdout);
     }
     break;
   }
   if (running) {
     set_command_state(file, 1);
     depth --;
     while (1) {
       if (2 & db_level) {
         print_spaces(depth);
         tmp___27 = dcgettext((char const   *)((void *)0), "The prerequisites of `%s\' are being made.\n",
                              5);
         printf((char const   * __restrict  )tmp___27, file->name);
         fflush(stdout);
       }
       break;
     }
     return (0);
   }
   if (dep_status != 0) {
     file->update_status = (short )dep_status;
     notice_finished_file(file);
     depth --;
     while (1) {
       if (2 & db_level) {
         print_spaces(depth);
         tmp___28 = dcgettext((char const   *)((void *)0), "Giving up on target file `%s\'.\n",
                              5);
         printf((char const   * __restrict  )tmp___28, file->name);
         fflush(stdout);
       }
       break;
     }
     if (depth == 0U) {
       if (keep_going_flag) {
         if (! just_print_flag) {
           if (! question_flag) {
             tmp___29 = dcgettext((char const   *)((void *)0), "Target `%s\' not remade because of errors.",
                                  5);
             error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___29,
                   file->name);
           }
         }
       }
     }
     return (dep_status);
   }
   if ((unsigned int )file->command_state == 1U) {
     set_command_state(file, 0);
   }
   deps_changed = 0;
   d = file->deps;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     if ((d->file)->last_mtime) {
       tmp___31 = (d->file)->last_mtime;
     } else {
       tmp___30 = f_mtime(d->file, 1);
       tmp___31 = tmp___30;
     }
     d_mtime = tmp___31;
     while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
       d->file = (d->file)->renamed;
     }
     if (d_mtime == 0xffffffffffffffffUL) {
       if (! (d->file)->intermediate) {
         must_make = 1;
       }
     }
     deps_changed |= d->changed;
     if (noexist) {
       tmp___32 = 1;
     } else
     if (d_mtime > this_mtime) {
       tmp___32 = 1;
     } else {
       tmp___32 = 0;
     }
     d->changed |= tmp___32;
     if (! noexist) {
       if (3 & db_level) {
         fmt = (char const   *)0;
         if (d_mtime == 0xffffffffffffffffUL) {
           if (1 & db_level) {
             tmp___33 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' of target `%s\' does not exist.\n",
                                  5);
             fmt = (char const   *)tmp___33;
           }
         } else
         if (d->changed) {
           if (1 & db_level) {
             tmp___34 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' is newer than target `%s\'.\n",
                                  5);
             fmt = (char const   *)tmp___34;
           }
         } else
         if (2 & db_level) {
           tmp___35 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' is older than target `%s\'.\n",
                                5);
           fmt = (char const   *)tmp___35;
         }
         if (fmt) {
           print_spaces(depth);
           if ((unsigned long )d->name == (unsigned long )((char *)0)) {
             tmp___36 = (d->file)->name;
           } else {
             tmp___36 = d->name;
           }
           printf((char const   * __restrict  )fmt, tmp___36, file->name);
           fflush(stdout);
         }
       }
     }
     d = d->next;
   }
   depth --;
   if (file->double_colon) {
     if ((unsigned long )file->deps == (unsigned long )((struct dep *)0)) {
       must_make = 1;
       while (1) {
         if (1 & db_level) {
           print_spaces(depth);
           tmp___37 = dcgettext((char const   *)((void *)0), "Target `%s\' is double-colon and has no prerequisites.\n",
                                5);
           printf((char const   * __restrict  )tmp___37, file->name);
           fflush(stdout);
         }
         break;
       }
     } else {
       goto _L___0;
     }
   } else
   _L___0: /* CIL Label */ 
   if (! noexist) {
     if (file->is_target) {
       if (! deps_changed) {
         if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
           must_make = 0;
           while (1) {
             if (2 & db_level) {
               print_spaces(depth);
               tmp___38 = dcgettext((char const   *)((void *)0), "No commands for `%s\' and no prerequisites actually changed.\n",
                                    5);
               printf((char const   * __restrict  )tmp___38, file->name);
               fflush(stdout);
             }
             break;
           }
         }
       }
     }
   }
   if (! must_make) {
     if (2 & db_level) {
       print_spaces(depth);
       tmp___39 = dcgettext((char const   *)((void *)0), "No need to remake target `%s\'",
                            5);
       printf((char const   * __restrict  )tmp___39, file->name);
       if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
         if ((int )*(file->name) == (int )*(file->hname)) {
           if (! ((int )*(file->name) == 0)) {
             tmp___41 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));
             if (tmp___41) {
               tmp___40 = dcgettext((char const   *)((void *)0), "; using VPATH name `%s\'",
                                    5);
               printf((char const   * __restrict  )tmp___40, file->hname);
             }
           }
         } else {
           tmp___40 = dcgettext((char const   *)((void *)0), "; using VPATH name `%s\'",
                                5);
           printf((char const   * __restrict  )tmp___40, file->hname);
         }
       }
       puts(".");
       fflush(stdout);
     }
     notice_finished_file(file);
     while (file) {
       file->name = file->hname;
       file = file->prev;
     }
     return (0);
   }
   while (1) {
     if (1 & db_level) {
       print_spaces(depth);
       tmp___42 = dcgettext((char const   *)((void *)0), "Must remake target `%s\'.\n",
                            5);
       printf((char const   * __restrict  )tmp___42, file->name);
       fflush(stdout);
     }
     break;
   }
   if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
     if ((int )*(file->name) == (int )*(file->hname)) {
       if (! ((int )*(file->name) == 0)) {
         tmp___44 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));
         if (tmp___44) {
           goto _L___1;
         }
       }
     } else {
       _L___1: /* CIL Label */ 
       while (1) {
         if (1 & db_level) {
           tmp___43 = dcgettext((char const   *)((void *)0), "  Ignoring VPATH name `%s\'.\n",
                                5);
           printf((char const   * __restrict  )tmp___43, file->hname);
           fflush(stdout);
         }
         break;
       }
       file->ignore_vpath = 1U;
     }
   }
   remake_file(file);
   if ((unsigned int )file->command_state != 3U) {
     while (1) {
       if (2 & db_level) {
         print_spaces(depth);
         tmp___45 = dcgettext((char const   *)((void *)0), "Commands of `%s\' are being run.\n",
                              5);
         printf((char const   * __restrict  )tmp___45, file->name);
         fflush(stdout);
       }
       break;
     }
     return (0);
   }
   switch ((int )file->update_status) {
   case 2: 
   while (1) {
     if (1 & db_level) {
       print_spaces(depth);
       tmp___46 = dcgettext((char const   *)((void *)0), "Failed to remake target file `%s\'.\n",
                            5);
       printf((char const   * __restrict  )tmp___46, file->name);
       fflush(stdout);
     }
     break;
   }
   break;
   case 0: 
   while (1) {
     if (1 & db_level) {
       print_spaces(depth);
       tmp___47 = dcgettext((char const   *)((void *)0), "Successfully remade target file `%s\'.\n",
                            5);
       printf((char const   * __restrict  )tmp___47, file->name);
       fflush(stdout);
     }
     break;
   }
   break;
   case 1: 
   while (1) {
     if (1 & db_level) {
       print_spaces(depth);
       tmp___48 = dcgettext((char const   *)((void *)0), "Target file `%s\' needs remade under -q.\n",
                            5);
       printf((char const   * __restrict  )tmp___48, file->name);
       fflush(stdout);
     }
     break;
   }
   break;
   default: 
   if ((int )file->update_status >= 0) {
     if (! ((int )file->update_status <= 2)) {
       __assert_fail("file->update_status >= 0 && file->update_status <= 2", "remake.c",
                     676U, "update_file_1");
     }
   } else {
     __assert_fail("file->update_status >= 0 && file->update_status <= 2", "remake.c",
                   676U, "update_file_1");
   }
   break;
   }
   file->updated = 1U;
   return ((int )file->update_status);
 }
 }
 void notice_finished_file(struct file *file ) 
 { 
   struct dep *d ;
   int ran ;
   unsigned int i ;
   int tmp ;
   struct file *f ;
   int i___0 ;
 
   {
   ran = (unsigned int )file->command_state == 2U;
   file->command_state = (enum __anonenum_command_state_55 )3;
   file->updated = 1U;
   if (touch_flag) {
     if ((int )file->update_status == 0) {
       if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
         if ((file->cmds)->any_recurse) {
           i = 0U;
           while (i < (file->cmds)->ncommand_lines) {
             if (! ((int )*((file->cmds)->lines_flags + i) & 1)) {
               goto have_nonrecursing;
             }
             i ++;
           }
         } else {
           goto have_nonrecursing;
         }
       } else
       have_nonrecursing: 
       if (file->phony) {
         file->update_status = (short)0;
       } else {
         tmp = touch_file(file);
         file->update_status = (short )tmp;
       }
     }
   }
   if (file->mtime_before_update == 0UL) {
     file->mtime_before_update = file->last_mtime;
   }
   if (ran) {
     if (! file->phony) {
       i___0 = 0;
       if (question_flag) {
         goto _L___0;
       } else
       if (just_print_flag) {
         _L___0: /* CIL Label */ 
         i___0 = (int )(file->cmds)->ncommand_lines;
         while (i___0 > 0) {
           if (! ((int )*((file->cmds)->lines_flags + (i___0 - 1)) & 1)) {
             break;
           }
           i___0 --;
         }
       } else
       if (file->is_target) {
         if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
           i___0 = 1;
         }
       }
       if (i___0 == 0) {
         file->last_mtime = (uintmax_t )0;
       } else {
         file->last_mtime = 0xfffffffffffffffeUL;
       }
       f = file->double_colon;
       while ((unsigned long )f != (unsigned long )((struct file *)0)) {
         f->last_mtime = file->last_mtime;
         f = f->next;
       }
     }
   }
   if (ran) {
     if ((int )file->update_status != -1) {
       d = file->also_make;
       while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
         (d->file)->command_state = (enum __anonenum_command_state_55 )3;
         (d->file)->updated = 1U;
         (d->file)->update_status = file->update_status;
         if (ran) {
           if (! (d->file)->phony) {
             f_mtime(d->file, 0);
           }
         }
         d = d->next;
       }
     } else {
       goto _L___1;
     }
   } else
   _L___1: /* CIL Label */ 
   if ((int )file->update_status == -1) {
     file->update_status = (short)0;
   }
   return;
 }
 }
 static int check_dep(struct file *file , unsigned int depth , uintmax_t this_mtime ,
                      int *must_make_ptr ) 
 { 
   register struct dep *d ;
   int dep_status ;
   struct file *tmp ;
   uintmax_t mtime ;
   uintmax_t tmp___0 ;
   uintmax_t mtime___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   int tmp___3 ;
   char *tmp___4 ;
   uintmax_t tmp___5 ;
   register struct dep *lastd ;
   char *tmp___6 ;
   struct file *tmp___7 ;
   int tmp___8 ;
   struct file *tmp___9 ;
 
   {
   dep_status = 0;
   depth ++;
   if (file->double_colon) {
     tmp = file->double_colon;
   } else {
     tmp = file;
   }
   tmp->updating = 1U;
   if (! file->intermediate) {
     dep_status = update_file(file, depth);
     while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
       file = file->renamed;
     }
     if (file->last_mtime) {
       mtime = file->last_mtime;
     } else {
       tmp___0 = f_mtime(file, 1);
       mtime = tmp___0;
     }
     while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
       file = file->renamed;
     }
     if (mtime == 0xffffffffffffffffUL) {
       *must_make_ptr = 1;
     } else
     if (mtime > this_mtime) {
       *must_make_ptr = 1;
     }
   } else {
     if (! file->phony) {
       if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
         if (! file->tried_implicit) {
           tmp___3 = try_implicit_rule(file, depth);
           if (tmp___3) {
             while (1) {
               if (8 & db_level) {
                 print_spaces(depth);
                 tmp___1 = dcgettext((char const   *)((void *)0), "Found an implicit rule for `%s\'.\n",
                                     5);
                 printf((char const   * __restrict  )tmp___1, file->name);
                 fflush(stdout);
               }
               break;
             }
           } else {
             while (1) {
               if (8 & db_level) {
                 print_spaces(depth);
                 tmp___2 = dcgettext((char const   *)((void *)0), "No implicit rule found for `%s\'.\n",
                                     5);
                 printf((char const   * __restrict  )tmp___2, file->name);
                 fflush(stdout);
               }
               break;
             }
           }
           file->tried_implicit = 1U;
         }
       }
     }
     if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
       if (! file->is_target) {
         if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
           if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
             while (1) {
               if (8 & db_level) {
                 print_spaces(depth);
                 tmp___4 = dcgettext((char const   *)((void *)0), "Using default commands for `%s\'.\n",
                                     5);
                 printf((char const   * __restrict  )tmp___4, file->name);
                 fflush(stdout);
               }
               break;
             }
             file->cmds = default_file->cmds;
           }
         }
       }
     }
     while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
       file = file->renamed;
     }
     if (file->last_mtime) {
       mtime___0 = file->last_mtime;
     } else {
       tmp___5 = f_mtime(file, 1);
       mtime___0 = tmp___5;
     }
     while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
       file = file->renamed;
     }
     if (mtime___0 != 0xffffffffffffffffUL) {
       if (mtime___0 > this_mtime) {
         *must_make_ptr = 1;
       } else {
         goto _L;
       }
     } else {
       _L: /* CIL Label */ 
       lastd = (struct dep *)0;
       d = file->deps;
       while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
         if ((d->file)->double_colon) {
           tmp___7 = (d->file)->double_colon;
         } else {
           tmp___7 = d->file;
         }
         if (tmp___7->updating) {
           tmp___6 = dcgettext((char const   *)((void *)0), "Circular %s <- %s dependency dropped.",
                               5);
           error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                 file->name, (d->file)->name);
           if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
             file->deps = d->next;
             free((void *)((char *)d));
             d = file->deps;
           } else {
             lastd->next = d->next;
             free((void *)((char *)d));
             d = lastd->next;
           }
           continue;
         }
         (d->file)->parent = file;
         tmp___8 = check_dep(d->file, depth, this_mtime, must_make_ptr);
         dep_status |= tmp___8;
         while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
           d->file = (d->file)->renamed;
         }
         if (dep_status != 0) {
           if (! keep_going_flag) {
             break;
           }
         }
         if ((unsigned int )(d->file)->command_state == 2U) {
           set_command_state(file, 1);
         } else
         if ((unsigned int )(d->file)->command_state == 1U) {
           set_command_state(file, 1);
         }
         lastd = d;
         d = d->next;
       }
     }
   }
   if (file->double_colon) {
     tmp___9 = file->double_colon;
   } else {
     tmp___9 = file;
   }
   tmp___9->updating = 0U;
   return (dep_status);
 }
 }
 static int touch_file(struct file *file ) 
 { 
   int tmp ;
   int fd ;
   int tmp___0 ;
   struct stat statbuf ;
   char buf___1 ;
   int status ;
   int *tmp___1 ;
   ssize_t tmp___2 ;
   __off_t tmp___3 ;
   ssize_t tmp___4 ;
   int tmp___5 ;
 
   {
   if (! silent_flag) {
     message(0, "touch %s", file->name);
   }
   tmp___5 = ar_name(file->name);
   if (tmp___5) {
     tmp = ar_touch(file->name);
     return (tmp);
   } else {
     tmp___0 = open((char const   *)file->name, 66, 438);
     fd = tmp___0;
     if (fd < 0) {
       perror_with_name((char *)"touch: open: ", file->name);
       return (1);
     } else {
       while (1) {
         status = fstat(fd, & statbuf);
         if (status < 0) {
           tmp___1 = __errno_location();
           if (! (*tmp___1 == 4)) {
             break;
           }
         } else {
           break;
         }
       }
       if (status < 0) {
         perror_with_name((char *)"touch: fstat: ", file->name);
         return (1);
       }
       tmp___2 = read(fd, (void *)(& buf___1), (size_t )1);
       if (tmp___2 < 0L) {
         perror_with_name((char *)"touch: read: ", file->name);
         return (1);
       }
       tmp___3 = lseek(fd, 0L, 0);
       if (tmp___3 < 0L) {
         perror_with_name((char *)"touch: lseek: ", file->name);
         return (1);
       }
       tmp___4 = write(fd, (void const   *)(& buf___1), (size_t )1);
       if (tmp___4 < 0L) {
         perror_with_name((char *)"touch: write: ", file->name);
         return (1);
       }
       if (statbuf.st_size == 0L) {
         close(fd);
         fd = open((char const   *)file->name, 514, 438);
         if (fd < 0) {
           perror_with_name((char *)"touch: open: ", file->name);
           return (1);
         }
       }
       close(fd);
     }
   }
   return (0);
 }
 }
 static void remake_file(struct file *file ) 
 { 
   char const   *msg_noparent ;
   char *tmp ;
   char const   *msg_parent ;
   char *tmp___0 ;
 
   {
   if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
     if (file->phony) {
       file->update_status = (short)0;
     } else
     if (file->is_target) {
       file->update_status = (short)0;
     } else {
       tmp = dcgettext((char const   *)((void *)0), "%sNo rule to make target `%s\'%s",
                       5);
       msg_noparent = (char const   *)tmp;
       tmp___0 = dcgettext((char const   *)((void *)0), "%sNo rule to make target `%s\', needed by `%s\'%s",
                           5);
       msg_parent = (char const   *)tmp___0;
       if (! keep_going_flag) {
         if (! file->dontcare) {
           if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
             fatal((struct floc  const  *)((struct floc *)0), msg_noparent, "", file->name,
                   "");
           }
           fatal((struct floc  const  *)((struct floc *)0), msg_parent, "", file->name,
                 (file->parent)->name, "");
         }
       }
       if (! file->dontcare) {
         if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
           error((struct floc  const  *)((struct floc *)0), msg_noparent, "*** ", file->name,
                 ".");
         } else {
           error((struct floc  const  *)((struct floc *)0), msg_parent, "*** ", file->name,
                 (file->parent)->name, ".");
         }
       }
       file->update_status = (short)2;
     }
   } else {
     chop_commands(file->cmds);
     if (! touch_flag) {
       execute_file_commands(file);
       return;
     } else
     if ((file->cmds)->any_recurse) {
       execute_file_commands(file);
       return;
     }
     file->update_status = (short)0;
   }
   notice_finished_file(file);
   return;
 }
 }
 static uintmax_t now  =    (uintmax_t )0;
 uintmax_t f_mtime(struct file *file , int search ) 
 { 
   uintmax_t mtime ;
   char *arname ;
   char *memname ;
   struct file *arfile ;
   int arname_used ;
   char *name ;
   unsigned int arlen ;
   unsigned int memlen ;
   size_t tmp ;
   size_t tmp___0 ;
   char *tmp___1 ;
   int tmp___2 ;
   time_t tmp___3 ;
   uintmax_t tmp___4 ;
   uintmax_t tmp___5 ;
   char *name___0 ;
   uintmax_t tmp___6 ;
   uintmax_t tmp___7 ;
   size_t tmp___8 ;
   size_t tmp___9 ;
   int tmp___10 ;
   int tmp___11 ;
   int tmp___12 ;
   int tmp___13 ;
   char mtimebuf[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;
   char nowbuf[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;
   char *tmp___14 ;
 
   {
   tmp___13 = ar_name(file->name);
   if (tmp___13) {
     arname_used = 0;
     ar_parse_name(file->name, & arname, & memname);
     arfile = lookup_file(arname);
     if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
       arfile = enter_file(arname);
       arname_used = 1;
     }
     mtime = f_mtime(arfile, search);
     while ((unsigned long )arfile->renamed != (unsigned long )((struct file *)0)) {
       arfile = arfile->renamed;
     }
     if (search) {
       tmp___2 = strcmp((char const   *)arfile->hname, (char const   *)arname);
       if (tmp___2) {
         if (! arname_used) {
           free((void *)arname);
           arname_used = 1;
         }
         arname = arfile->hname;
         tmp = strlen((char const   *)arname);
         arlen = (unsigned int )tmp;
         tmp___0 = strlen((char const   *)memname);
         memlen = (unsigned int )tmp___0;
         tmp___1 = xmalloc(((arlen + 1U) + memlen) + 2U);
         name = tmp___1;
         memmove((void *)name, (void const   *)arname, (size_t )arlen);
         *(name + arlen) = (char )'(';
         memmove((void *)((name + arlen) + 1), (void const   *)memname, (size_t )memlen);
         *(name + ((arlen + 1U) + memlen)) = (char )')';
         *(name + (((arlen + 1U) + memlen) + 1U)) = (char )'\000';
         if ((unsigned long )arfile->name == (unsigned long )arfile->hname) {
           rename_file(file, name);
         } else {
           rehash_file(file, name);
         }
         while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
           file = file->renamed;
         }
       }
     }
     if (! arname_used) {
       free((void *)arname);
     }
     free((void *)memname);
     if (mtime == 0xffffffffffffffffUL) {
       return ((uintmax_t )-1);
     }
     tmp___3 = ar_member_date(file->hname);
     if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
       tmp___4 = (uintmax_t )1000000000;
     } else {
       tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
     }
     if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
       tmp___5 = (uintmax_t )1000000000;
     } else {
       tmp___5 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
     }
     mtime = (uintmax_t )tmp___3 * tmp___4;
   } else {
     mtime = name_mtime(file->name);
     if (mtime == 0xffffffffffffffffUL) {
       if (search) {
         if (! file->ignore_vpath) {
           name___0 = file->name;
           tmp___11 = vpath_search(& name___0, & mtime);
           if (tmp___11) {
             goto _L;
           } else
           if ((int )*(name___0 + 0) == 45) {
             if ((int )*(name___0 + 1) == 108) {
               tmp___12 = library_search(& name___0, & mtime);
               if (tmp___12) {
                 _L: /* CIL Label */ 
                 if (mtime != 0UL) {
                   file->last_mtime = mtime;
                 }
                 tmp___8 = strlen((char const   *)name___0);
                 tmp___9 = strlen((char const   *)file->name);
                 tmp___10 = gpath_search(name___0, (int )((tmp___8 - tmp___9) - 1UL));
                 if (tmp___10) {
                   rename_file(file, name___0);
                   while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
                     file = file->renamed;
                   }
                   if (file->last_mtime) {
                     tmp___7 = file->last_mtime;
                   } else {
                     tmp___6 = f_mtime(file, 1);
                     tmp___7 = tmp___6;
                   }
                   return (tmp___7);
                 }
                 rehash_file(file, name___0);
                 while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
                   file = file->renamed;
                 }
                 mtime = name_mtime(name___0);
               }
             }
           }
         }
       }
     }
   }
   if (! clock_skew_detected) {
     if (mtime != 0xffffffffffffffffUL) {
       if (mtime > now) {
         if (! file->updated) {
           now = file_timestamp_now();
           if (mtime > now) {
             file_timestamp_sprintf(mtimebuf, mtime);
             file_timestamp_sprintf(nowbuf, now);
             tmp___14 = dcgettext((char const   *)((void *)0), "*** Warning: File `%s\' has modification time in the future (%s > %s)",
                                  5);
             error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___14,
                   file->name, mtimebuf, nowbuf);
             clock_skew_detected = 1;
           }
         }
       }
     }
   }
   if (file->double_colon) {
     file = file->double_colon;
   }
   while (1) {
     if (mtime != 0xffffffffffffffffUL) {
       if ((unsigned int )file->command_state == 0U) {
         if (! file->tried_implicit) {
           if (file->intermediate) {
             file->intermediate = 0U;
           }
         }
       }
     }
     file->last_mtime = mtime;
     file = file->prev;
     if (! ((unsigned long )file != (unsigned long )((struct file *)0))) {
       break;
     }
   }
   return (mtime);
 }
 }
 static uintmax_t name_mtime(char *name ) 
 { 
   struct stat st ;
   int tmp ;
   uintmax_t tmp___0 ;
   uintmax_t tmp___1 ;
 
   {
   tmp = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
   if (tmp < 0) {
     return ((uintmax_t )-1);
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___0 = (uintmax_t )1000000000;
   } else {
     tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
     tmp___1 = (uintmax_t )1000000000;
   } else {
     tmp___1 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
   }
   return ((uintmax_t )st.st_mtim.tv_sec * tmp___0 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___1) / 1000000000UL);
 }
 }
 static char *dirs[4]  = {      (char *)"/lib",      (char *)"/usr/lib",      (char *)"/usr/local/lib",      (char *)0};
 static char *libpatterns  =    (char *)((void *)0);
 static char *buf___0  =    (char *)((void *)0);
 static int buflen  =    0;
 static int libdir_maxlen  =    -1;
 static int library_search(char **lib , uintmax_t *mtime_ptr ) 
 { 
   char *libname ;
   uintmax_t mtime ;
   char *p ;
   char *p2 ;
   unsigned int len ;
   char *file ;
   char **dp ;
   int save ;
   char *tmp ;
   char *libbuf ;
   char *tmp___0 ;
   char c ;
   char *p3 ;
   char *p4 ;
   char *tmp___1 ;
   size_t tmp___2 ;
   int tmp___3 ;
   int l ;
   size_t tmp___4 ;
   size_t tmp___5 ;
   size_t tmp___6 ;
   size_t tmp___7 ;
 
   {
   libname = *lib + 2;
   if (! libpatterns) {
     save = warn_undefined_variables_flag;
     warn_undefined_variables_flag = 0;
     tmp = variable_expand((char *)"$(strip $(.LIBPATTERNS))");
     libpatterns = xstrdup((char const   *)tmp);
     warn_undefined_variables_flag = save;
   }
   p2 = libpatterns;
   while (1) {
     p = find_next_token(& p2, & len);
     if (! ((unsigned long )p != (unsigned long )((char *)0))) {
       break;
     }
     tmp___0 = variable_expand((char *)"");
     libbuf = tmp___0;
     c = *(p + len);
     *(p + len) = (char )'\000';
     p3 = find_percent(p);
     if (! p3) {
       tmp___1 = dcgettext((char const   *)((void *)0), ".LIBPATTERNS element `%s\' is not a pattern",
                           5);
       error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, p);
       while (len) {
         *p = (char )' ';
         len --;
         p ++;
       }
       *p = c;
       continue;
     }
     p4 = variable_buffer_output(libbuf, p, (unsigned int )(p3 - p));
     tmp___2 = strlen((char const   *)libname);
     p4 = variable_buffer_output(p4, libname, (unsigned int )tmp___2);
     p4 = variable_buffer_output(p4, p3 + 1, (unsigned int )((long )len - (p3 - p)));
     *(p + len) = c;
     mtime = name_mtime(libbuf);
     if (mtime != 0xffffffffffffffffUL) {
       *lib = xstrdup((char const   *)libbuf);
       if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
         *mtime_ptr = mtime;
       }
       return (1);
     }
     file = libbuf;
     tmp___3 = vpath_search(& file, mtime_ptr);
     if (tmp___3) {
       *lib = file;
       return (1);
     }
     if (! buflen) {
       dp = dirs;
       while ((unsigned long )*dp != (unsigned long )((char *)0)) {
         tmp___4 = strlen((char const   *)*dp);
         l = (int )tmp___4;
         if (l > libdir_maxlen) {
           libdir_maxlen = l;
         }
         dp ++;
       }
       tmp___5 = strlen((char const   *)libbuf);
       buflen = (int )tmp___5;
       buf___0 = xmalloc((unsigned int )((libdir_maxlen + buflen) + 2));
     } else {
       tmp___7 = strlen((char const   *)libbuf);
       if ((size_t )buflen < tmp___7) {
         tmp___6 = strlen((char const   *)libbuf);
         buflen = (int )tmp___6;
         buf___0 = xrealloc(buf___0, (unsigned int )((libdir_maxlen + buflen) + 2));
       }
     }
     dp = dirs;
     while ((unsigned long )*dp != (unsigned long )((char *)0)) {
       sprintf((char * __restrict  )buf___0, (char const   * __restrict  )"%s/%s",
               *dp, libbuf);
       mtime = name_mtime(buf___0);
       if (mtime != 0xffffffffffffffffUL) {
         *lib = xstrdup((char const   *)buf___0);
         if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
           *mtime_ptr = mtime;
         }
         return (1);
       }
       dp ++;
     }
   }
   return (0);
 }
 }
 #pragma merger("0","/tmp/cil-ku_yXt8Q.i","-g,-O0")
 struct file *suffix_file  ;
 struct variable_set_list *create_new_variable_set(void) ;
 void print_variable_set(struct variable_set *set , char *prefix ) ;
 struct rule *pattern_rules  ;
 struct rule *last_pattern_rule  ;
 unsigned int num_pattern_rules  ;
 unsigned int max_pattern_deps  ;
 unsigned int max_pattern_targets  ;
 unsigned int max_pattern_dep_length  ;
 unsigned int maxsuffix  ;
 void install_pattern_rule(struct pspec *p , int terminal ) ;
 int new_pattern_rule(struct rule *rule , int override ) ;
 struct pattern_var *lookup_pattern_var(char *target ) ;
 static void freerule(struct rule *rule , struct rule *lastrule ) ;
 static struct pattern_var *pattern_vars  ;
 static struct pattern_var *last_pattern_var  ;
 void count_implicit_rule_limits(void) 
 { 
   char *name ;
   unsigned int namelen ;
   register struct rule *rule ;
   register struct rule *lastrule ;
   unsigned int ndeps ;
   register struct dep *dep ;
   struct rule *next ;
   unsigned int ntargets ;
   unsigned int len ;
   size_t tmp ;
   char *p ;
   char *tmp___0 ;
   char *p2 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   int tmp___4 ;
   int tmp___5 ;
 
   {
   max_pattern_deps = 0U;
   max_pattern_targets = max_pattern_deps;
   num_pattern_rules = max_pattern_targets;
   max_pattern_dep_length = 0U;
   name = (char *)0;
   namelen = 0U;
   rule = pattern_rules;
   lastrule = (struct rule *)0;
   while ((unsigned long )rule != (unsigned long )((struct rule *)0)) {
     ndeps = 0U;
     next = rule->next;
     num_pattern_rules ++;
     ntargets = 0U;
     while ((unsigned long )*(rule->targets + ntargets) != (unsigned long )((char *)0)) {
       ntargets ++;
     }
     if (ntargets > max_pattern_targets) {
       max_pattern_targets = ntargets;
     }
     dep = rule->deps;
     while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
       tmp = strlen((char const   *)dep->name);
       len = (unsigned int )tmp;
       tmp___0 = strrchr((char const   *)dep->name, '/');
       p = tmp___0;
       if ((unsigned long )p != (unsigned long )((char *)0)) {
         tmp___1 = strchr((char const   *)dep->name, '%');
         tmp___2 = tmp___1;
       } else {
         tmp___2 = (char *)0;
       }
       p2 = tmp___2;
       ndeps ++;
       if (len > max_pattern_dep_length) {
         max_pattern_dep_length = len;
       }
       if ((unsigned long )p != (unsigned long )((char *)0)) {
         if ((unsigned long )p2 > (unsigned long )p) {
           if ((unsigned long )p == (unsigned long )dep->name) {
             p ++;
           }
           if (p - dep->name > (long )namelen) {
             if ((unsigned long )name != (unsigned long )((char *)0)) {
               free((void *)name);
             }
             namelen = (unsigned int )(p - dep->name);
             tmp___3 = xmalloc(namelen + 1U);
             name = tmp___3;
           }
           memmove((void *)name, (void const   *)dep->name, (size_t )(p - dep->name));
           *(name + (p - dep->name)) = (char )'\000';
           tmp___4 = dir_file_exists_p(name, (char *)"");
           if (tmp___4) {
             tmp___5 = 0;
           } else {
             tmp___5 = 1;
           }
           dep->changed = tmp___5;
           if (dep->changed) {
             if ((int )*name == 47) {
               freerule(rule, lastrule);
               num_pattern_rules --;
               goto end_main_loop;
             }
           }
         } else {
           dep->changed = 0;
         }
       } else {
         dep->changed = 0;
       }
       dep = dep->next;
     }
     if (ndeps > max_pattern_deps) {
       max_pattern_deps = ndeps;
     }
     lastrule = rule;
     end_main_loop: 
     rule = next;
   }
   if ((unsigned long )name != (unsigned long )((char *)0)) {
     free((void *)name);
   }
   return;
 }
 }
 static void convert_suffix_rule(char *target , char *source , struct commands *cmds ) 
 { 
   char *targname ;
   char *targpercent ;
   char *depname ;
   char **names ;
   char **percents ;
   struct dep *deps ;
   unsigned int len ;
   size_t tmp ;
   char *tmp___0 ;
   void *tmp___1 ;
   char *tmp___2 ;
   size_t tmp___3 ;
   char *tmp___4 ;
 
   {
   if ((unsigned long )target == (unsigned long )((char *)0)) {
     targname = savestring("(%.o)", 5U);
     targpercent = targname + 1;
   } else {
     tmp = strlen((char const   *)target);
     len = (unsigned int )tmp;
     targname = xmalloc((1U + len) + 1U);
     *(targname + 0) = (char )'%';
     memmove((void *)(targname + 1), (void const   *)target, (size_t )(len + 1U));
     targpercent = targname;
   }
   tmp___0 = xmalloc((unsigned int )(2UL * sizeof(char *)));
   names = (char **)tmp___0;
   tmp___1 = __builtin_alloca(2UL * sizeof(char *));
   percents = (char **)tmp___1;
   *(names + 0) = targname;
   *(percents + 0) = targpercent;
   tmp___2 = (char *)0;
   *(percents + 1) = tmp___2;
   *(names + 1) = tmp___2;
   if ((unsigned long )source == (unsigned long )((char *)0)) {
     deps = (struct dep *)0;
   } else {
     tmp___3 = strlen((char const   *)source);
     len = (unsigned int )tmp___3;
     depname = xmalloc((1U + len) + 1U);
     *(depname + 0) = (char )'%';
     memmove((void *)(depname + 1), (void const   *)source, (size_t )(len + 1U));
     tmp___4 = xmalloc((unsigned int )sizeof(struct dep ));
     deps = (struct dep *)tmp___4;
     deps->next = (struct dep *)0;
     deps->name = depname;
   }
   create_pattern_rule(names, percents, 0, deps, cmds, 0);
   return;
 }
 }
 void convert_to_pattern(void) 
 { 
   register struct dep *d ;
   register struct dep *d2 ;
   register struct file *f ;
   register char *rulename ;
   register unsigned int slen ;
   register unsigned int s2len ;
   register unsigned int namelen ;
   char *tmp ;
   size_t tmp___0 ;
   void *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   size_t tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   size_t tmp___8 ;
   char *tmp___9 ;
   char *tmp___10 ;
   char *tmp___11 ;
   char *tmp___12 ;
   char *tmp___13 ;
   char *tmp___14 ;
   char *tmp___15 ;
   int tmp___16 ;
   char *tmp___17 ;
   char *tmp___18 ;
   char *tmp___19 ;
   char *tmp___20 ;
 
   {
   maxsuffix = 0U;
   d = suffix_file->deps;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )d->name == (unsigned long )((char *)0)) {
       tmp = (d->file)->name;
     } else {
       tmp = d->name;
     }
     tmp___0 = strlen((char const   *)tmp);
     namelen = (unsigned int )tmp___0;
     if (namelen > maxsuffix) {
       maxsuffix = namelen;
     }
     d = d->next;
   }
   tmp___1 = __builtin_alloca((unsigned long )(maxsuffix * 2U + 1U));
   rulename = (char *)tmp___1;
   d = suffix_file->deps;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )d->name == (unsigned long )((char *)0)) {
       tmp___2 = (d->file)->name;
     } else {
       tmp___2 = d->name;
     }
     convert_suffix_rule(tmp___2, (char *)0, (struct commands *)0);
     f = d->file;
     if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
         tmp___3 = (d->file)->name;
       } else {
         tmp___3 = d->name;
       }
       convert_suffix_rule((char *)"", tmp___3, f->cmds);
     }
     if ((unsigned long )d->name == (unsigned long )((char *)0)) {
       tmp___4 = (d->file)->name;
     } else {
       tmp___4 = d->name;
     }
     tmp___5 = strlen((char const   *)tmp___4);
     slen = (unsigned int )tmp___5;
     if ((unsigned long )d->name == (unsigned long )((char *)0)) {
       tmp___6 = (d->file)->name;
     } else {
       tmp___6 = d->name;
     }
     memmove((void *)rulename, (void const   *)tmp___6, (size_t )slen);
     d2 = suffix_file->deps;
     while ((unsigned long )d2 != (unsigned long )((struct dep *)0)) {
       if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
         tmp___7 = (d2->file)->name;
       } else {
         tmp___7 = d2->name;
       }
       tmp___8 = strlen((char const   *)tmp___7);
       s2len = (unsigned int )tmp___8;
       if (slen == s2len) {
         if ((unsigned long )d->name == (unsigned long )((char *)0)) {
           tmp___9 = (d->file)->name;
         } else {
           tmp___9 = d->name;
         }
         if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
           tmp___10 = (d2->file)->name;
         } else {
           tmp___10 = d2->name;
         }
         if ((unsigned long )tmp___9 == (unsigned long )tmp___10) {
           goto __Cont;
         } else {
           if ((unsigned long )d->name == (unsigned long )((char *)0)) {
             tmp___11 = (d->file)->name;
           } else {
             tmp___11 = d->name;
           }
           if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
             tmp___12 = (d2->file)->name;
           } else {
             tmp___12 = d2->name;
           }
           if ((int )*tmp___11 == (int )*tmp___12) {
             if ((unsigned long )d->name == (unsigned long )((char *)0)) {
               tmp___13 = (d->file)->name;
             } else {
               tmp___13 = d->name;
             }
             if ((int )*tmp___13 == 0) {
               goto __Cont;
             } else {
               if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
                 tmp___14 = (d2->file)->name;
               } else {
                 tmp___14 = d2->name;
               }
               if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                 tmp___15 = (d->file)->name;
               } else {
                 tmp___15 = d->name;
               }
               tmp___16 = strcmp((char const   *)(tmp___15 + 1), (char const   *)(tmp___14 + 1));
               if (! tmp___16) {
                 goto __Cont;
               }
             }
           }
         }
       }
       if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
         tmp___17 = (d2->file)->name;
       } else {
         tmp___17 = d2->name;
       }
       memmove((void *)(rulename + slen), (void const   *)tmp___17, (size_t )(s2len + 1U));
       f = lookup_file(rulename);
       if ((unsigned long )f == (unsigned long )((struct file *)0)) {
         goto __Cont;
       } else
       if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
         goto __Cont;
       }
       if (s2len == 2U) {
         if ((int )*(rulename + slen) == 46) {
           if ((int )*(rulename + (slen + 1U)) == 97) {
             if ((unsigned long )d->name == (unsigned long )((char *)0)) {
               tmp___18 = (d->file)->name;
             } else {
               tmp___18 = d->name;
             }
             convert_suffix_rule((char *)0, tmp___18, f->cmds);
           }
         }
       }
       if ((unsigned long )d->name == (unsigned long )((char *)0)) {
         tmp___19 = (d->file)->name;
       } else {
         tmp___19 = d->name;
       }
       if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
         tmp___20 = (d2->file)->name;
       } else {
         tmp___20 = d2->name;
       }
       convert_suffix_rule(tmp___20, tmp___19, f->cmds);
       __Cont: /* CIL Label */ 
       d2 = d2->next;
     }
     d = d->next;
   }
   return;
 }
 }
 int new_pattern_rule(struct rule *rule , int override ) 
 { 
   register struct rule *r ;
   register struct rule *lastrule ;
   register unsigned int i ;
   register unsigned int j ;
   int tmp ;
   register struct dep *d ;
   register struct dep *d2 ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   int tmp___7 ;
 
   {
   rule->in_use = (char)0;
   rule->terminal = (char)0;
   rule->next = (struct rule *)0;
   lastrule = (struct rule *)0;
   r = pattern_rules;
   while ((unsigned long )r != (unsigned long )((struct rule *)0)) {
     i = 0U;
     while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
       j = 0U;
       while ((unsigned long )*(r->targets + j) != (unsigned long )((char *)0)) {
         if (! ((unsigned long )*(rule->targets + i) == (unsigned long )*(r->targets + j))) {
           if ((int )*(*(rule->targets + i)) == (int )*(*(r->targets + j))) {
             if (! ((int )*(*(rule->targets + i)) == 0)) {
               tmp = strcmp((char const   *)(*(rule->targets + i) + 1), (char const   *)(*(r->targets + j) + 1));
               if (tmp) {
                 break;
               }
             }
           } else {
             break;
           }
         }
         j ++;
       }
       if ((unsigned long )*(r->targets + j) == (unsigned long )((char *)0)) {
         d = rule->deps;
         d2 = r->deps;
         while (1) {
           if ((unsigned long )d != (unsigned long )((struct dep *)0)) {
             if (! ((unsigned long )d2 != (unsigned long )((struct dep *)0))) {
               break;
             }
           } else {
             break;
           }
           if ((unsigned long )d->name == (unsigned long )((char *)0)) {
             tmp___0 = (d->file)->name;
           } else {
             tmp___0 = d->name;
           }
           if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
             tmp___1 = (d2->file)->name;
           } else {
             tmp___1 = d2->name;
           }
           if (! ((unsigned long )tmp___0 == (unsigned long )tmp___1)) {
             if ((unsigned long )d->name == (unsigned long )((char *)0)) {
               tmp___2 = (d->file)->name;
             } else {
               tmp___2 = d->name;
             }
             if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
               tmp___3 = (d2->file)->name;
             } else {
               tmp___3 = d2->name;
             }
             if ((int )*tmp___2 == (int )*tmp___3) {
               if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                 tmp___4 = (d->file)->name;
               } else {
                 tmp___4 = d->name;
               }
               if (! ((int )*tmp___4 == 0)) {
                 if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
                   tmp___5 = (d2->file)->name;
                 } else {
                   tmp___5 = d2->name;
                 }
                 if ((unsigned long )d->name == (unsigned long )((char *)0)) {
                   tmp___6 = (d->file)->name;
                 } else {
                   tmp___6 = d->name;
                 }
                 tmp___7 = strcmp((char const   *)(tmp___6 + 1), (char const   *)(tmp___5 + 1));
                 if (tmp___7) {
                   break;
                 }
               }
             } else {
               break;
             }
           }
           d = d->next;
           d2 = d2->next;
         }
         if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
           if ((unsigned long )d2 == (unsigned long )((struct dep *)0)) {
             if (override) {
               freerule(r, lastrule);
               if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
                 pattern_rules = rule;
               } else {
                 last_pattern_rule->next = rule;
               }
               last_pattern_rule = rule;
               goto matched;
             } else {
               freerule(rule, (struct rule *)0);
               return (0);
             }
           }
         }
       }
       i ++;
     }
     lastrule = r;
     r = r->next;
   }
   matched: ;
   if ((unsigned long )r == (unsigned long )((struct rule *)0)) {
     if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
       pattern_rules = rule;
     } else {
       last_pattern_rule->next = rule;
     }
     last_pattern_rule = rule;
   }
   return (1);
 }
 }
 void install_pattern_rule(struct pspec *p , int terminal ) 
 { 
   register struct rule *r ;
   char *ptr ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   size_t tmp___3 ;
   struct nameseq *tmp___4 ;
   struct nameseq *tmp___5 ;
   char *tmp___6 ;
   int tmp___7 ;
 
   {
   tmp = xmalloc((unsigned int )sizeof(struct rule ));
   r = (struct rule *)tmp;
   tmp___0 = xmalloc((unsigned int )(2UL * sizeof(char *)));
   r->targets = (char **)tmp___0;
   tmp___1 = xmalloc((unsigned int )(2UL * sizeof(char *)));
   r->suffixes = (char **)tmp___1;
   tmp___2 = xmalloc((unsigned int )(2UL * sizeof(unsigned int )));
   r->lens = (unsigned int *)tmp___2;
   *(r->targets + 1) = (char *)0;
   *(r->suffixes + 1) = (char *)0;
   *(r->lens + 1) = 0U;
   tmp___3 = strlen((char const   *)p->target);
   *(r->lens + 0) = (unsigned int )tmp___3;
   *(r->targets + 0) = savestring((char const   *)p->target, *(r->lens + 0));
   *(r->suffixes + 0) = find_percent(*(r->targets + 0));
   if ((unsigned long )*(r->suffixes + 0) == (unsigned long )((char *)0)) {
     abort();
   } else {
     (*(r->suffixes + 0)) ++;
   }
   ptr = p->dep;
   tmp___4 = parse_file_seq(& ptr, '\000', (unsigned int )sizeof(struct dep ), 1);
   tmp___5 = multi_glob(tmp___4, (unsigned int )sizeof(struct dep ));
   r->deps = (struct dep *)tmp___5;
   tmp___7 = new_pattern_rule(r, 0);
   if (tmp___7) {
     r->terminal = (char )terminal;
     tmp___6 = xmalloc((unsigned int )sizeof(struct commands ));
     r->cmds = (struct commands *)tmp___6;
     (r->cmds)->fileinfo.filenm = (char *)0;
     (r->cmds)->fileinfo.lineno = 0UL;
     (r->cmds)->commands = xstrdup((char const   *)p->commands);
     (r->cmds)->command_lines = (char **)0;
   }
   return;
 }
 }
 static void freerule(struct rule *rule , struct rule *lastrule ) 
 { 
   struct rule *next ;
   register unsigned int i ;
   register struct dep *dep ;
   struct dep *t ;
 
   {
   next = rule->next;
   i = 0U;
   while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
     free((void *)*(rule->targets + i));
     i ++;
   }
   dep = rule->deps;
   while (dep) {
     t = dep->next;
     free((void *)((char *)dep));
     dep = t;
   }
   free((void *)((char *)rule->targets));
   free((void *)((char *)rule->suffixes));
   free((void *)((char *)rule->lens));
   free((void *)((char *)rule));
   if ((unsigned long )pattern_rules == (unsigned long )rule) {
     if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
       abort();
     } else {
       pattern_rules = next;
     }
   } else
   if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
     lastrule->next = next;
   }
   if ((unsigned long )last_pattern_rule == (unsigned long )rule) {
     last_pattern_rule = lastrule;
   }
   return;
 }
 }
 void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                          struct dep *deps , struct commands *commands , int override ) 
 { 
   register struct rule *r ;
   char *tmp ;
   register unsigned int max_targets ;
   register unsigned int i ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   size_t tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   int tmp___9 ;
 
   {
   tmp = xmalloc((unsigned int )sizeof(struct rule ));
   r = (struct rule *)tmp;
   r->cmds = commands;
   r->deps = deps;
   r->targets = targets;
   max_targets = 2U;
   tmp___0 = xmalloc((unsigned int )(2UL * sizeof(unsigned int )));
   r->lens = (unsigned int *)tmp___0;
   tmp___1 = xmalloc((unsigned int )(2UL * sizeof(char *)));
   r->suffixes = (char **)tmp___1;
   i = 0U;
   while ((unsigned long )*(targets + i) != (unsigned long )((char *)0)) {
     if (i == max_targets - 1U) {
       max_targets += 5U;
       tmp___2 = xrealloc((char *)r->lens, (unsigned int )((unsigned long )max_targets * sizeof(unsigned int )));
       r->lens = (unsigned int *)tmp___2;
       tmp___3 = xrealloc((char *)r->suffixes, (unsigned int )((unsigned long )max_targets * sizeof(char *)));
       r->suffixes = (char **)tmp___3;
     }
     tmp___4 = strlen((char const   *)*(targets + i));
     *(r->lens + i) = (unsigned int )tmp___4;
     if ((unsigned long )target_percents == (unsigned long )((char **)0)) {
       tmp___5 = find_percent(*(targets + i));
       tmp___6 = tmp___5;
     } else {
       tmp___6 = *(target_percents + i);
     }
     *(r->suffixes + i) = tmp___6 + 1;
     if ((unsigned long )*(r->suffixes + i) == (unsigned long )((char *)0)) {
       abort();
     }
     i ++;
   }
   if (i < max_targets - 1U) {
     tmp___7 = xrealloc((char *)r->lens, (unsigned int )((unsigned long )(i + 1U) * sizeof(unsigned int )));
     r->lens = (unsigned int *)tmp___7;
     tmp___8 = xrealloc((char *)r->suffixes, (unsigned int )((unsigned long )(i + 1U) * sizeof(char *)));
     r->suffixes = (char **)tmp___8;
   }
   tmp___9 = new_pattern_rule(r, override);
   if (tmp___9) {
     r->terminal = (char )terminal;
   }
   return;
 }
 }
 struct pattern_var *create_pattern_var(char *target , char *suffix ) 
 { 
   register struct pattern_var *p ;
   unsigned int len ;
   size_t tmp ;
   int tmp___0 ;
   char *tmp___1 ;
 
   {
   p = (struct pattern_var *)0;
   tmp = strlen((char const   *)target);
   len = (unsigned int )tmp;
   p = pattern_vars;
   while ((unsigned long )p != (unsigned long )((void *)0)) {
     if (p->len == len) {
       tmp___0 = strcmp((char const   *)p->target, (char const   *)target);
       if (! tmp___0) {
         break;
       }
     }
     p = p->next;
   }
   if ((unsigned long )p == (unsigned long )((struct pattern_var *)0)) {
     tmp___1 = xmalloc((unsigned int )sizeof(struct pattern_var ));
     p = (struct pattern_var *)tmp___1;
     if ((unsigned long )last_pattern_var != (unsigned long )((struct pattern_var *)0)) {
       last_pattern_var->next = p;
     } else {
       pattern_vars = p;
     }
     last_pattern_var = p;
     p->next = (struct pattern_var *)0;
     p->target = target;
     p->len = len;
     p->suffix = suffix + 1;
     p->vars = create_new_variable_set();
   }
   return (p);
 }
 }
 struct pattern_var *lookup_pattern_var(char *target ) 
 { 
   struct pattern_var *p ;
   unsigned int targlen ;
   size_t tmp ;
   char *stem ;
   unsigned int stemlen ;
   int tmp___0 ;
   int tmp___1 ;
 
   {
   tmp = strlen((char const   *)target);
   targlen = (unsigned int )tmp;
   p = pattern_vars;
   while ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
     if (p->len > targlen) {
       goto __Cont;
     }
     stem = target + ((p->suffix - p->target) - 1L);
     stemlen = (targlen - p->len) + 1U;
     if ((unsigned long )stem > (unsigned long )target) {
       tmp___0 = strncmp((char const   *)p->target, (char const   *)target, (size_t )(stem - target));
       if (! (tmp___0 == 0)) {
         goto __Cont;
       }
     }
     if ((int )*(p->suffix) == (int )*(stem + stemlen)) {
       if ((int )*(p->suffix) == 0) {
         break;
       } else
       if ((unsigned long )(p->suffix + 1) == (unsigned long )(stem + (stemlen + 1U))) {
         break;
       } else
       if ((int )*(p->suffix + 1) == (int )*(stem + (stemlen + 1U))) {
         if ((int )*(p->suffix + 1) == 0) {
           break;
         } else {
           tmp___1 = strcmp((char const   *)((p->suffix + 1) + 1), (char const   *)((stem + (stemlen + 1U)) + 1));
           if (! tmp___1) {
             break;
           }
         }
       }
     }
     __Cont: /* CIL Label */ 
     p = p->next;
   }
   return (p);
 }
 }
 static void print_rule(struct rule *r ) 
 { 
   register unsigned int i ;
   register struct dep *d ;
   char *tmp ;
 
   {
   i = 0U;
   while ((unsigned long )*(r->targets + i) != (unsigned long )((char *)0)) {
     fputs((char const   * __restrict  )*(r->targets + i), (FILE * __restrict  )stdout);
     if ((unsigned long )*(r->targets + (i + 1U)) != (unsigned long )((char *)0)) {
       putchar(' ');
     } else {
       putchar(':');
     }
     i ++;
   }
   if (r->terminal) {
     putchar(':');
   }
   d = r->deps;
   while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
     if ((unsigned long )d->name == (unsigned long )((char *)0)) {
       tmp = (d->file)->name;
     } else {
       tmp = d->name;
     }
     printf((char const   * __restrict  )" %s", tmp);
     d = d->next;
   }
   putchar('\n');
   if ((unsigned long )r->cmds != (unsigned long )((struct commands *)0)) {
     print_commands(r->cmds);
   }
   return;
 }
 }
 void print_rule_data_base(void) 
 { 
   register unsigned int rules ;
   register unsigned int terminal ;
   register struct rule *r ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   struct pattern_var *p ;
   char *tmp___4 ;
   char *tmp___5 ;
 
   {
   puts("\n# Implicit Rules");
   terminal = 0U;
   rules = terminal;
   r = pattern_rules;
   while ((unsigned long )r != (unsigned long )((struct rule *)0)) {
     rules ++;
     putchar('\n');
     print_rule(r);
     if (r->terminal) {
       terminal ++;
     }
     r = r->next;
   }
   if (rules == 0U) {
     tmp = dcgettext((char const   *)((void *)0), "\n# No implicit rules.", 5);
     puts((char const   *)tmp);
   } else {
     tmp___0 = dcgettext((char const   *)((void *)0), "\n# %u implicit rules, %u",
                         5);
     printf((char const   * __restrict  )tmp___0, rules, terminal);
     printf((char const   * __restrict  )" (%.1f%%)", ((double )terminal / (double )rules) * 100.0);
     tmp___1 = dcgettext((char const   *)((void *)0), " terminal.", 5);
     puts((char const   *)tmp___1);
   }
   if (num_pattern_rules != rules) {
     if (num_pattern_rules != 0U) {
       tmp___2 = dcgettext((char const   *)((void *)0), "BUG: num_pattern_rules wrong!  %u != %u",
                           5);
       fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, num_pattern_rules,
             rules);
     }
   }
   tmp___3 = dcgettext((char const   *)((void *)0), "\n# Pattern-specific variable values",
                       5);
   puts((char const   *)tmp___3);
   rules = 0U;
   p = pattern_vars;
   while ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
     rules ++;
     printf((char const   * __restrict  )"\n%s :\n", p->target);
     print_variable_set((p->vars)->set, (char *)"# ");
     p = p->next;
   }
   if (rules == 0U) {
     tmp___4 = dcgettext((char const   *)((void *)0), "\n# No pattern-specific variable values.",
                         5);
     puts((char const   *)tmp___4);
   } else {
     tmp___5 = dcgettext((char const   *)((void *)0), "\n# %u pattern-specific variable values",
                         5);
     printf((char const   * __restrict  )tmp___5, rules);
   }
   return;
 }
 }
 #pragma merger("0","/tmp/cil-aO4sE5WY.i","-g,-O0")
 void signame_init(void) ;
 char *sig_abbrev(int number ) ;
 int sig_number(char const   *abbrev ) ;
 static num_abbrev sig_table[130]  ;
 static int sig_table_nelts  =    0;
 static void init_sig(int number , char const   *abbrev , char const   *name ) 
 { 
   int tmp ;
 
   {
   if (sig_table_nelts < 130) {
     sig_table[sig_table_nelts].number = number;
     tmp = sig_table_nelts;
     sig_table_nelts ++;
     sig_table[tmp].abbrev = abbrev;
   }
   return;
 }
 }
 void signame_init(void) 
 { 
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   char *tmp___6 ;
   char *tmp___7 ;
   char *tmp___8 ;
   char *tmp___9 ;
   char *tmp___10 ;
   char *tmp___11 ;
   char *tmp___12 ;
   char *tmp___13 ;
   char *tmp___14 ;
   char *tmp___15 ;
   char *tmp___16 ;
   char *tmp___17 ;
   char *tmp___18 ;
   char *tmp___19 ;
   char *tmp___20 ;
   char *tmp___21 ;
   char *tmp___22 ;
   char *tmp___23 ;
   char *tmp___24 ;
   char *tmp___25 ;
   char *tmp___26 ;
   char *tmp___27 ;
   char *tmp___28 ;
   char *tmp___29 ;
   char *tmp___30 ;
   char *tmp___31 ;
 
   {
   tmp = dcgettext((char const   *)((void *)0), "Hangup", 5);
   init_sig(1, "HUP", (char const   *)tmp);
   tmp___0 = dcgettext((char const   *)((void *)0), "Interrupt", 5);
   init_sig(2, "INT", (char const   *)tmp___0);
   tmp___1 = dcgettext((char const   *)((void *)0), "Quit", 5);
   init_sig(3, "QUIT", (char const   *)tmp___1);
   tmp___2 = dcgettext((char const   *)((void *)0), "Illegal Instruction", 5);
   init_sig(4, "ILL", (char const   *)tmp___2);
   tmp___3 = dcgettext((char const   *)((void *)0), "Trace/breakpoint trap", 5);
   init_sig(5, "TRAP", (char const   *)tmp___3);
   tmp___4 = dcgettext((char const   *)((void *)0), "Aborted", 5);
   init_sig(6, "ABRT", (char const   *)tmp___4);
   tmp___5 = dcgettext((char const   *)((void *)0), "IOT trap", 5);
   init_sig(6, "IOT", (char const   *)tmp___5);
   tmp___6 = dcgettext((char const   *)((void *)0), "Floating point exception", 5);
   init_sig(8, "FPE", (char const   *)tmp___6);
   tmp___7 = dcgettext((char const   *)((void *)0), "Killed", 5);
   init_sig(9, "KILL", (char const   *)tmp___7);
   tmp___8 = dcgettext((char const   *)((void *)0), "Bus error", 5);
   init_sig(7, "BUS", (char const   *)tmp___8);
   tmp___9 = dcgettext((char const   *)((void *)0), "Segmentation fault", 5);
   init_sig(11, "SEGV", (char const   *)tmp___9);
   tmp___10 = dcgettext((char const   *)((void *)0), "Bad system call", 5);
   init_sig(31, "SYS", (char const   *)tmp___10);
   tmp___11 = dcgettext((char const   *)((void *)0), "Broken pipe", 5);
   init_sig(13, "PIPE", (char const   *)tmp___11);
   tmp___12 = dcgettext((char const   *)((void *)0), "Alarm clock", 5);
   init_sig(14, "ALRM", (char const   *)tmp___12);
   tmp___13 = dcgettext((char const   *)((void *)0), "Terminated", 5);
   init_sig(15, "TERM", (char const   *)tmp___13);
   tmp___14 = dcgettext((char const   *)((void *)0), "User defined signal 1", 5);
   init_sig(10, "USR1", (char const   *)tmp___14);
   tmp___15 = dcgettext((char const   *)((void *)0), "User defined signal 2", 5);
   init_sig(12, "USR2", (char const   *)tmp___15);
   tmp___16 = dcgettext((char const   *)((void *)0), "Child exited", 5);
   init_sig(17, "CHLD", (char const   *)tmp___16);
   tmp___17 = dcgettext((char const   *)((void *)0), "Child exited", 5);
   init_sig(17, "CLD", (char const   *)tmp___17);
   tmp___18 = dcgettext((char const   *)((void *)0), "Power failure", 5);
   init_sig(30, "PWR", (char const   *)tmp___18);
   tmp___19 = dcgettext((char const   *)((void *)0), "Stopped", 5);
   init_sig(20, "TSTP", (char const   *)tmp___19);
   tmp___20 = dcgettext((char const   *)((void *)0), "Stopped (tty input)", 5);
   init_sig(21, "TTIN", (char const   *)tmp___20);
   tmp___21 = dcgettext((char const   *)((void *)0), "Stopped (tty output)", 5);
   init_sig(22, "TTOU", (char const   *)tmp___21);
   tmp___22 = dcgettext((char const   *)((void *)0), "Stopped (signal)", 5);
   init_sig(19, "STOP", (char const   *)tmp___22);
   tmp___23 = dcgettext((char const   *)((void *)0), "CPU time limit exceeded", 5);
   init_sig(24, "XCPU", (char const   *)tmp___23);
   tmp___24 = dcgettext((char const   *)((void *)0), "File size limit exceeded", 5);
   init_sig(25, "XFSZ", (char const   *)tmp___24);
   tmp___25 = dcgettext((char const   *)((void *)0), "Virtual timer expired", 5);
   init_sig(26, "VTALRM", (char const   *)tmp___25);
   tmp___26 = dcgettext((char const   *)((void *)0), "Profiling timer expired", 5);
   init_sig(27, "PROF", (char const   *)tmp___26);
   tmp___27 = dcgettext((char const   *)((void *)0), "Window changed", 5);
   init_sig(28, "WINCH", (char const   *)tmp___27);
   tmp___28 = dcgettext((char const   *)((void *)0), "Continued", 5);
   init_sig(18, "CONT", (char const   *)tmp___28);
   tmp___29 = dcgettext((char const   *)((void *)0), "Urgent I/O condition", 5);
   init_sig(23, "URG", (char const   *)tmp___29);
   tmp___30 = dcgettext((char const   *)((void *)0), "I/O possible", 5);
   init_sig(29, "IO", (char const   *)tmp___30);
   tmp___31 = dcgettext((char const   *)((void *)0), "I/O possible", 5);
   init_sig(29, "POLL", (char const   *)tmp___31);
   return;
 }
 }
 char *sig_abbrev(int number ) 
 { 
   int i ;
 
   {
   if (sig_table_nelts == 0) {
     signame_init();
   }
   i = 0;
   while (i < sig_table_nelts) {
     if (sig_table[i].number == number) {
       return ((char *)sig_table[i].abbrev);
     }
     i ++;
   }
   return ((char *)((void *)0));
 }
 }
 int sig_number(char const   *abbrev ) 
 { 
   int i ;
   int tmp ;
 
   {
   if (sig_table_nelts == 0) {
     signame_init();
   }
   if ((int const   )*(abbrev + 0) == 83) {
     if ((int const   )*(abbrev + 1) == 73) {
       if ((int const   )*(abbrev + 2) == 71) {
         abbrev += 3;
       }
     }
   }
   i = 0;
   while (i < sig_table_nelts) {
     if ((int const   )*(abbrev + 0) == (int const   )*(sig_table[i].abbrev + 0)) {
       tmp = strcmp(abbrev, sig_table[i].abbrev);
       if (tmp == 0) {
         return (sig_table[i].number);
       }
     }
     i ++;
   }
   return (-1);
 }
 }
 #pragma merger("0","/tmp/cil-3nJ90Uj5.i","-g,-O0")
 int export_all_variables  ;
 static struct variable *variable_table[523]  ;
 static struct variable_set global_variable_set  =    {variable_table, 523U};
 static struct variable_set_list global_setlist  =    {(struct variable_set_list *)0, & global_variable_set};
 struct variable_set_list *current_variable_set_list  =    & global_setlist;
 static struct variable *lookup_variable_in_set(char *name , unsigned int length___0 ,
                                                struct variable_set *set ) ;
 struct variable *define_variable_in_set(char *name , unsigned int length___0 , char *value ,
                                         enum variable_origin origin , int recursive ,
                                         struct variable_set *set , struct floc  const  *flocp ) 
 { 
   register unsigned int i ;
   register unsigned int hashval ;
   register struct variable *v ;
   int tmp ;
   char *tmp___0 ;
 
   {
   hashval = 0U;
   i = 0U;
   while (i < length___0) {
     hashval += (unsigned int )*(name + i);
     hashval = (hashval << 7) + (hashval >> 20);
     i ++;
   }
   hashval %= set->buckets;
   v = *(set->table + hashval);
   while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
     if ((int )*(v->name) == (int )*name) {
       tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));
       if (tmp == 0) {
         if ((int )*(v->name + length___0) == 0) {
           break;
         }
       }
     }
     v = v->next;
   }
   if (env_overrides) {
     if ((unsigned int )origin == 1U) {
       origin = (enum variable_origin )3;
     }
   }
   if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
     if (env_overrides) {
       if ((unsigned int )v->origin == 1U) {
         v->origin = (enum variable_origin )3;
       }
     }
     if ((int )origin >= (int )v->origin) {
       if ((unsigned long )v->value != (unsigned long )((char *)0)) {
         free((void *)v->value);
       }
       v->value = xstrdup((char const   *)value);
       if ((unsigned long )flocp != (unsigned long )((struct floc  const  *)0)) {
         v->fileinfo = (struct floc )*flocp;
       } else {
         v->fileinfo.filenm = (char *)0;
       }
       v->origin = origin;
       v->recursive = (unsigned int )recursive;
     }
     return (v);
   }
   tmp___0 = xmalloc((unsigned int )sizeof(struct variable ));
   v = (struct variable *)tmp___0;
   v->name = savestring((char const   *)name, length___0);
   v->value = xstrdup((char const   *)value);
   if ((unsigned long )flocp != (unsigned long )((struct floc  const  *)0)) {
     v->fileinfo = (struct floc )*flocp;
   } else {
     v->fileinfo.filenm = (char *)0;
   }
   v->origin = origin;
   v->recursive = (unsigned int )recursive;
   v->expanding = 0U;
   v->per_target = 0U;
   v->append = 0U;
   v->export = (enum variable_export )3;
   v->next = *(set->table + hashval);
   *(set->table + hashval) = v;
   return (v);
 }
 }
 struct variable *lookup_variable(char *name , unsigned int length___0 ) 
 { 
   register struct variable_set_list *setlist ;
   struct variable *firstv ;
   register unsigned int i ;
   register unsigned int rawhash ;
   register struct variable_set *set ;
   register unsigned int hashval ;
   register struct variable *v ;
   int tmp ;
 
   {
   firstv = (struct variable *)0;
   rawhash = 0U;
   i = 0U;
   while (i < length___0) {
     rawhash += (unsigned int )*(name + i);
     rawhash = (rawhash << 7) + (rawhash >> 20);
     i ++;
   }
   setlist = current_variable_set_list;
   while ((unsigned long )setlist != (unsigned long )((struct variable_set_list *)0)) {
     set = setlist->set;
     hashval = rawhash % set->buckets;
     v = *(set->table + hashval);
     while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
       if ((int )*(v->name) == (int )*name) {
         tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));
         if (tmp == 0) {
           if ((int )*(v->name + length___0) == 0) {
             break;
           }
         }
       }
       v = v->next;
     }
     if (! v) {
       goto __Cont;
     }
     if (! v->expanding) {
       return (v);
     }
     if (! firstv) {
       firstv = v;
     }
     __Cont: /* CIL Label */ 
     setlist = setlist->next;
   }
   return (firstv);
 }
 }
 static struct variable *lookup_variable_in_set(char *name , unsigned int length___0 ,
                                                struct variable_set *set ) 
 { 
   register unsigned int i ;
   register unsigned int hash ;
   register struct variable *v ;
   int tmp ;
 
   {
   hash = 0U;
   i = 0U;
   while (i < length___0) {
     hash += (unsigned int )*(name + i);
     hash = (hash << 7) + (hash >> 20);
     i ++;
   }
   hash %= set->buckets;
   v = *(set->table + hash);
   while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
     if ((int )*(v->name) == (int )*name) {
       tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));
       if (tmp == 0) {
         if ((int )*(v->name + length___0) == 0) {
           return (v);
         }
       }
     }
     v = v->next;
   }
   return ((struct variable *)0);
 }
 }
 void initialize_file_variables(struct file *file , int reading ) 
 { 
   register struct variable_set_list *l ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   struct pattern_var *p ;
   struct pattern_var *tmp___2 ;
   char *tmp___3 ;
 
   {
   l = file->variables;
   if ((unsigned long )l == (unsigned long )((struct variable_set_list *)0)) {
     tmp = xmalloc((unsigned int )sizeof(struct variable_set_list ));
     l = (struct variable_set_list *)tmp;
     tmp___0 = xmalloc((unsigned int )sizeof(struct variable_set ));
     l->set = (struct variable_set *)tmp___0;
     (l->set)->buckets = 23U;
     tmp___1 = xmalloc((unsigned int )((unsigned long )(l->set)->buckets * sizeof(struct variable *)));
     (l->set)->table = (struct variable **)tmp___1;
     memset((void *)((char *)(l->set)->table), 0, (unsigned long )(l->set)->buckets * sizeof(struct variable *));
     file->variables = l;
   }
   if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
     l->next = & global_setlist;
   } else {
     initialize_file_variables(file->parent, reading);
     l->next = (file->parent)->variables;
   }
   if (! reading) {
     if (! file->pat_searched) {
       tmp___2 = lookup_pattern_var(file->name);
       p = tmp___2;
       file->pat_searched = 1U;
       if ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
         tmp___3 = xmalloc((unsigned int )sizeof(struct variable_set_list ));
         file->pat_variables = (struct variable_set_list *)tmp___3;
         (file->pat_variables)->set = (p->vars)->set;
       }
     }
   }
   if ((unsigned long )file->pat_variables != (unsigned long )((struct variable_set_list *)0)) {
     (file->pat_variables)->next = l->next;
     l->next = file->pat_variables;
   }
   return;
 }
 }
 void pop_variable_scope(void) 
 { 
   register struct variable_set_list *setlist ;
   register struct variable_set *set ;
   register unsigned int i ;
   register struct variable *next ;
   register struct variable *v ;
 
   {
   setlist = current_variable_set_list;
   set = setlist->set;
   current_variable_set_list = setlist->next;
   free((void *)((char *)setlist));
   i = 0U;
   while (i < set->buckets) {
     next = *(set->table + i);
     while ((unsigned long )next != (unsigned long )((struct variable *)0)) {
       v = next;
       next = v->next;
       free((void *)v->name);
       if (v->value) {
         free((void *)v->value);
       }
       free((void *)((char *)v));
     }
     i ++;
   }
   free((void *)((char *)set->table));
   free((void *)((char *)set));
   return;
 }
 }
 struct variable_set_list *create_new_variable_set(void) 
 { 
   register struct variable_set_list *setlist ;
   register struct variable_set *set ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
 
   {
   tmp = xmalloc((unsigned int )sizeof(struct variable_set ));
   set = (struct variable_set *)tmp;
   set->buckets = 13U;
   tmp___0 = xmalloc((unsigned int )((unsigned long )set->buckets * sizeof(struct variable *)));
   set->table = (struct variable **)tmp___0;
   memset((void *)((char *)set->table), 0, (unsigned long )set->buckets * sizeof(struct variable *));
   tmp___1 = xmalloc((unsigned int )sizeof(struct variable_set_list ));
   setlist = (struct variable_set_list *)tmp___1;
   setlist->set = set;
   setlist->next = current_variable_set_list;
   return (setlist);
 }
 }
 struct variable_set_list *push_new_variable_scope(void) 
 { 
 
 
   {
   current_variable_set_list = create_new_variable_set();
   return (current_variable_set_list);
 }
 }
 static void merge_variable_sets(struct variable_set *set0 , struct variable_set *set1 ) 
 { 
   register unsigned int bucket1 ;
   register struct variable *v1 ;
   struct variable *next ;
   unsigned int bucket0 ;
   register struct variable *v0 ;
   register char *n ;
   int tmp ;
 
   {
   bucket1 = 0U;
   while (bucket1 < set1->buckets) {
     v1 = *(set1->table + bucket1);
     while ((unsigned long )v1 != (unsigned long )((struct variable *)0)) {
       next = v1->next;
       if (set1->buckets >= set0->buckets) {
         bucket0 = bucket1;
       } else {
         bucket0 = 0U;
         n = v1->name;
         while ((int )*n != 0) {
           bucket0 += (unsigned int )*n;
           bucket0 = (bucket0 << 7) + (bucket0 >> 20);
           n ++;
         }
       }
       bucket0 %= set0->buckets;
       v0 = *(set0->table + bucket0);
       while ((unsigned long )v0 != (unsigned long )((struct variable *)0)) {
         if ((unsigned long )v0->name == (unsigned long )v1->name) {
           break;
         } else
         if ((int )*(v0->name) == (int )*(v1->name)) {
           if ((int )*(v0->name) == 0) {
             break;
           } else {
             tmp = strcmp((char const   *)(v0->name + 1), (char const   *)(v1->name + 1));
             if (! tmp) {
               break;
             }
           }
         }
         v0 = v0->next;
       }
       if ((unsigned long )v0 == (unsigned long )((struct variable *)0)) {
         v1->next = *(set0->table + bucket0);
         *(set0->table + bucket0) = v1;
       } else {
         free((void *)v1->value);
         free((void *)((char *)v1));
       }
       v1 = next;
     }
     bucket1 ++;
   }
   return;
 }
 }
 void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) 
 { 
   register struct variable_set_list *list0 ;
   struct variable_set_list *last0 ;
   struct variable_set_list *next ;
 
   {
   list0 = *setlist0;
   last0 = (struct variable_set_list *)0;
   while (1) {
     if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
       if (! ((unsigned long )list0 != (unsigned long )((struct variable_set_list *)0))) {
         break;
       }
     } else {
       break;
     }
     next = setlist1;
     setlist1 = setlist1->next;
     merge_variable_sets(list0->set, next->set);
     last0 = list0;
     list0 = list0->next;
   }
   if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
     if ((unsigned long )last0 == (unsigned long )((struct variable_set_list *)0)) {
       *setlist0 = setlist1;
     } else {
       last0->next = setlist1;
     }
   }
   return;
 }
 }
 void define_automatic_variables(void) 
 { 
   register struct variable *v ;
   char buf___1[200] ;
   char const   *tmp ;
   char const   *tmp___0 ;
 
   {
   sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%u", makelevel);
   define_variable_in_set((char *)"MAKELEVEL", 9U, buf___1, (enum variable_origin )1,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
     tmp = "";
   } else
   if ((int )*(remote_description + 0) == 0) {
     tmp = "";
   } else {
     tmp = (char const   *)remote_description;
   }
   if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
     tmp___0 = "";
   } else
   if ((int )*(remote_description + 0) == 0) {
     tmp___0 = "";
   } else {
     tmp___0 = "-";
   }
   sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%s%s%s", version_string,
           tmp___0, tmp);
   define_variable_in_set((char *)"MAKE_VERSION", 12U, buf___1, (enum variable_origin )0,
                          0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   v = define_variable_in_set((char *)"SHELL", 5U, default_shell, (enum variable_origin )0,
                              0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   v->export = (enum variable_export )0;
   if ((int )*(v->value) == 0) {
     free((void *)v->value);
     v->origin = (enum variable_origin )2;
     v->value = xstrdup((char const   *)(default_shell));
   } else
   if ((unsigned int )v->origin == 1U) {
     free((void *)v->value);
     v->origin = (enum variable_origin )2;
     v->value = xstrdup((char const   *)(default_shell));
   } else
   if ((unsigned int )v->origin == 3U) {
     free((void *)v->value);
     v->origin = (enum variable_origin )2;
     v->value = xstrdup((char const   *)(default_shell));
   }
   v = define_variable_in_set((char *)"MAKEFILES", 9U, (char *)"", (enum variable_origin )0,
                              0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   v->export = (enum variable_export )2;
   define_variable_in_set((char *)"@D", 2U, (char *)"$(patsubst %/,%,$(dir $@))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"%D", 2U, (char *)"$(patsubst %/,%,$(dir $%))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"*D", 2U, (char *)"$(patsubst %/,%,$(dir $*))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"<D", 2U, (char *)"$(patsubst %/,%,$(dir $<))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"?D", 2U, (char *)"$(patsubst %/,%,$(dir $?))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"^D", 2U, (char *)"$(patsubst %/,%,$(dir $^))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"+D", 2U, (char *)"$(patsubst %/,%,$(dir $+))", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"@F", 2U, (char *)"$(notdir $@)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"%F", 2U, (char *)"$(notdir $%)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"*F", 2U, (char *)"$(notdir $*)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"<F", 2U, (char *)"$(notdir $<)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"?F", 2U, (char *)"$(notdir $?)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"^F", 2U, (char *)"$(notdir $^)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   define_variable_in_set((char *)"+F", 2U, (char *)"$(notdir $+)", (enum variable_origin )6,
                          1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   return;
 }
 }
 char **target_environment(struct file *file ) 
 { 
   struct variable_set_list *set_list ;
   register struct variable_set_list *s ;
   struct variable_bucket **table ;
   unsigned int buckets ;
   register unsigned int i ;
   register unsigned int nvariables ;
   char **result___0 ;
   unsigned int mklev_hash ;
   char *p ;
   char *tmp ;
   void *tmp___0 ;
   register struct variable_set *set ;
   register struct variable *v ;
   unsigned int j ;
   register struct variable_bucket *ov ;
   register char *p___0 ;
   int tmp___1 ;
   struct variable *gv ;
   size_t tmp___2 ;
   register char *np ;
   int tmp___3 ;
   register struct variable_bucket *entry ;
   void *tmp___4 ;
   char *tmp___5 ;
   register struct variable_bucket *b ;
   register struct variable *v___0 ;
   char *value ;
   char *tmp___6 ;
   unsigned int tmp___7 ;
   unsigned int tmp___8 ;
   char *tmp___9 ;
 
   {
   if ((unsigned long )file == (unsigned long )((struct file *)0)) {
     set_list = current_variable_set_list;
   } else {
     set_list = file->variables;
   }
   s = set_list;
   buckets = (s->set)->buckets;
   s = s->next;
   while ((unsigned long )s != (unsigned long )((struct variable_set_list *)0)) {
     if ((s->set)->buckets < buckets) {
       buckets = (s->set)->buckets;
     }
     s = s->next;
   }
   p = (char *)"MAKELEVEL";
   mklev_hash = 0U;
   while ((int )*p != 0) {
     tmp = p;
     p ++;
     mklev_hash += (unsigned int )*tmp;
     mklev_hash = (mklev_hash << 7) + (mklev_hash >> 20);
   }
   tmp___0 = __builtin_alloca((unsigned long )buckets * sizeof(struct variable_bucket *));
   table = (struct variable_bucket **)tmp___0;
   memset((void *)((char *)table), 0, (unsigned long )buckets * sizeof(struct variable_bucket *));
   nvariables = 0U;
   s = set_list;
   while ((unsigned long )s != (unsigned long )((struct variable_set_list *)0)) {
     set = s->set;
     i = 0U;
     while (i < set->buckets) {
       v = *(set->table + i);
       while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
         j = i % buckets;
         p___0 = v->name;
         if (i == mklev_hash % set->buckets) {
           if ((unsigned long )v->name == (unsigned long )"MAKELEVEL") {
             goto __Cont;
           } else
           if ((int )*(v->name) == (int )*"MAKELEVEL") {
             if ((int )*(v->name) == 0) {
               goto __Cont;
             } else {
               tmp___1 = strcmp((char const   *)(v->name + 1), "MAKELEVEL" + 1);
               if (! tmp___1) {
                 goto __Cont;
               }
             }
           }
         }
         if (v->per_target) {
           if ((unsigned int )v->export == 3U) {
             tmp___2 = strlen((char const   *)v->name);
             gv = lookup_variable_in_set(v->name, (unsigned int )tmp___2, & global_variable_set);
             if (gv) {
               v->export = gv->export;
             }
           }
         }
         switch ((unsigned int )v->export) {
         case 3U: 
         if ((unsigned int )v->origin == 0U) {
           goto __Cont;
         } else
         if ((unsigned int )v->origin == 6U) {
           goto __Cont;
         }
         if (! export_all_variables) {
           if ((unsigned int )v->origin != 4U) {
             if ((unsigned int )v->origin != 1U) {
               if ((unsigned int )v->origin != 3U) {
                 goto __Cont;
               }
             }
           }
         }
         if ((int )*p___0 != 95) {
           if ((int )*p___0 < 65) {
             goto _L;
           } else
           if ((int )*p___0 > 90) {
             _L: /* CIL Label */ 
             if ((int )*p___0 < 97) {
               goto __Cont;
             } else
             if ((int )*p___0 > 122) {
               goto __Cont;
             }
           }
         }
         p___0 ++;
         while ((int )*p___0 != 0) {
           if ((int )*p___0 != 95) {
             if ((int )*p___0 < 97) {
               goto _L___1;
             } else
             if ((int )*p___0 > 122) {
               _L___1: /* CIL Label */ 
               if ((int )*p___0 < 65) {
                 goto _L___0;
               } else
               if ((int )*p___0 > 90) {
                 _L___0: /* CIL Label */ 
                 if ((int )*p___0 < 48) {
                   goto __Cont___0;
                 } else
                 if ((int )*p___0 > 57) {
                   goto __Cont___0;
                 }
               }
             }
           }
           __Cont___0: /* CIL Label */ 
           p___0 ++;
         }
         if ((int )*p___0 != 0) {
           goto __Cont;
         }
         break;
         case 0U: 
         break;
         case 1U: 
         goto __Cont;
         case 2U: 
         if ((unsigned int )v->origin == 0U) {
           goto __Cont;
         }
         break;
         }
         if (set->buckets != buckets) {
           j = 0U;
           np = v->name;
           while ((int )*np != 0) {
             j += (unsigned int )*np;
             j = (j << 7) + (j >> 20);
             np ++;
           }
           j %= buckets;
         }
         ov = *(table + j);
         while ((unsigned long )ov != (unsigned long )((struct variable_bucket *)0)) {
           if ((unsigned long )v->name == (unsigned long )(ov->variable)->name) {
             break;
           } else
           if ((int )*(v->name) == (int )*((ov->variable)->name)) {
             if ((int )*(v->name) == 0) {
               break;
             } else {
               tmp___3 = strcmp((char const   *)(v->name + 1), (char const   *)((ov->variable)->name + 1));
               if (! tmp___3) {
                 break;
               }
             }
           }
           ov = ov->next;
         }
         if ((unsigned long )ov == (unsigned long )((struct variable_bucket *)0)) {
           tmp___4 = __builtin_alloca(sizeof(struct variable_bucket ));
           entry = (struct variable_bucket *)tmp___4;
           entry->next = *(table + j);
           entry->variable = v;
           *(table + j) = entry;
           nvariables ++;
         }
         __Cont: /* CIL Label */ 
         v = v->next;
       }
       i ++;
     }
     s = s->next;
   }
   tmp___5 = xmalloc((unsigned int )((unsigned long )(nvariables + 2U) * sizeof(char *)));
   result___0 = (char **)tmp___5;
   nvariables = 0U;
   i = 0U;
   while (i < buckets) {
     b = *(table + i);
     while ((unsigned long )b != (unsigned long )((struct variable_bucket *)0)) {
       v___0 = b->variable;
       if (v___0->recursive) {
         if ((unsigned int )v___0->origin != 1U) {
           if ((unsigned int )v___0->origin != 3U) {
             tmp___6 = recursively_expand(v___0);
             value = tmp___6;
             tmp___7 = nvariables;
             nvariables ++;
             *(result___0 + tmp___7) = concat(v___0->name, (char *)"=", value);
             free((void *)value);
           } else {
             tmp___8 = nvariables;
             nvariables ++;
             *(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);
           }
         } else {
           tmp___8 = nvariables;
           nvariables ++;
           *(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);
         }
       } else {
         tmp___8 = nvariables;
         nvariables ++;
         *(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);
       }
       b = b->next;
     }
     i ++;
   }
   tmp___9 = xmalloc(100U);
   *(result___0 + nvariables) = tmp___9;
   sprintf((char * __restrict  )*(result___0 + nvariables), (char const   * __restrict  )"MAKELEVEL=%u",
           makelevel + 1U);
   nvariables ++;
   *(result___0 + nvariables) = (char *)0;
   return (result___0);
 }
 }
 struct variable *try_variable_definition(struct floc  const  *flocp , char *line ,
                                          enum variable_origin origin , int target_var ) 
 { 
   register int c ;
   register char *p ;
   register char *beg ;
   register char *end ;
   enum __anonenum_flavor_56 flavor ;
   char *name ;
   char *expanded_name ;
   char *value ;
   char *alloc_value ;
   struct variable *v ;
   int append ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char closeparen ;
   int count ;
   char *tmp___3 ;
   unsigned short const   **tmp___4 ;
   void *tmp___5 ;
   char *tmp___6 ;
   size_t tmp___7 ;
   size_t tmp___8 ;
   unsigned int oldlen ;
   unsigned int newlen ;
   size_t tmp___9 ;
   size_t tmp___10 ;
   void *tmp___11 ;
   size_t tmp___12 ;
 
   {
   p = line;
   flavor = (enum __anonenum_flavor_56 )0;
   alloc_value = (char *)((void *)0);
   append = 0;
   while (1) {
     tmp = p;
     p ++;
     c = (int )*tmp;
     if (c == 0) {
       return ((struct variable *)0);
     } else
     if (c == 35) {
       return ((struct variable *)0);
     }
     if (c == 61) {
       end = p - 1;
       flavor = (enum __anonenum_flavor_56 )2;
       break;
     } else
     if (c == 58) {
       if ((int )*p == 61) {
         tmp___0 = p;
         p ++;
         end = tmp___0 - 1;
         flavor = (enum __anonenum_flavor_56 )1;
         break;
       } else {
         return ((struct variable *)0);
       }
     } else
     if (c == 43) {
       if ((int )*p == 61) {
         tmp___1 = p;
         p ++;
         end = tmp___1 - 1;
         flavor = (enum __anonenum_flavor_56 )3;
         break;
       } else {
         goto _L___0;
       }
     } else
     _L___0: /* CIL Label */ 
     if (c == 63) {
       if ((int )*p == 61) {
         tmp___2 = p;
         p ++;
         end = tmp___2 - 1;
         flavor = (enum __anonenum_flavor_56 )4;
         break;
       } else {
         goto _L;
       }
     } else
     _L: /* CIL Label */ 
     if (c == 36) {
       tmp___3 = p;
       p ++;
       c = (int )*tmp___3;
       if (c == 40) {
         closeparen = (char )')';
       } else
       if (c == 123) {
         closeparen = (char )'}';
       } else {
         continue;
       }
       count = 0;
       while ((int )*p != 0) {
         if ((int )*p == c) {
           count ++;
         } else
         if ((int )*p == (int )closeparen) {
           count --;
           if (count < 0) {
             p ++;
             break;
           }
         }
         p ++;
       }
     }
   }
   beg = next_token(line);
   while (1) {
     if ((unsigned long )end > (unsigned long )beg) {
       tmp___4 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___4 + (int )*(end + -1)) & 1)) {
         break;
       }
     } else {
       break;
     }
     end --;
   }
   p = next_token(p);
   tmp___5 = __builtin_alloca((unsigned long )((end - beg) + 1L));
   name = (char *)tmp___5;
   memmove((void *)name, (void const   *)beg, (size_t )(end - beg));
   *(name + (end - beg)) = (char )'\000';
   expanded_name = allocated_variable_expand_for_file(name, (struct file *)0);
   if ((int )*(expanded_name + 0) == 0) {
     tmp___6 = dcgettext((char const   *)((void *)0), "empty variable name", 5);
     fatal(flocp, (char const   *)tmp___6);
   }
   switch ((unsigned int )flavor) {
   case 0U: 
   abort();
   case 1U: 
   alloc_value = allocated_variable_expand_for_file(p, (struct file *)0);
   value = alloc_value;
   break;
   case 4U: 
   tmp___7 = strlen((char const   *)expanded_name);
   v = lookup_variable(expanded_name, (unsigned int )tmp___7);
   if (v) {
     free((void *)expanded_name);
     return (v);
   }
   flavor = (enum __anonenum_flavor_56 )2;
   case 2U: 
   value = p;
   break;
   case 3U: 
   if (target_var) {
     append = 1;
     flavor = (enum __anonenum_flavor_56 )2;
     value = p;
     break;
   }
   tmp___8 = strlen((char const   *)expanded_name);
   v = lookup_variable(expanded_name, (unsigned int )tmp___8);
   if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
     value = p;
     flavor = (enum __anonenum_flavor_56 )2;
   } else {
     if (v->recursive) {
       flavor = (enum __anonenum_flavor_56 )2;
     } else {
       alloc_value = allocated_variable_expand_for_file(p, (struct file *)0);
       p = alloc_value;
     }
     tmp___9 = strlen((char const   *)v->value);
     oldlen = (unsigned int )tmp___9;
     tmp___10 = strlen((char const   *)p);
     newlen = (unsigned int )tmp___10;
     tmp___11 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));
     value = (char *)tmp___11;
     memmove((void *)value, (void const   *)v->value, (size_t )oldlen);
     *(value + oldlen) = (char )' ';
     memmove((void *)(value + (oldlen + 1U)), (void const   *)p, (size_t )(newlen + 1U));
   }
   }
   tmp___12 = strlen((char const   *)expanded_name);
   v = define_variable_in_set(expanded_name, (unsigned int )tmp___12, value, origin,
                              (unsigned int )flavor == 2U, current_variable_set_list->set,
                              flocp);
   v->append = (unsigned int )append;
   if (alloc_value) {
     free((void *)alloc_value);
   }
   free((void *)expanded_name);
   return (v);
 }
 }
 static void print_variable(struct variable *v , char *prefix ) 
 { 
   char const   *origin ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   char *tmp___4 ;
   char *tmp___5 ;
   register char *p ;
   char const   *tmp___6 ;
   char const   *tmp___7 ;
   char *tmp___8 ;
 
   {
   switch ((unsigned int )v->origin) {
   case 0U: 
   tmp = dcgettext((char const   *)((void *)0), "default", 5);
   origin = (char const   *)tmp;
   break;
   case 1U: 
   tmp___0 = dcgettext((char const   *)((void *)0), "environment", 5);
   origin = (char const   *)tmp___0;
   break;
   case 2U: 
   tmp___1 = dcgettext((char const   *)((void *)0), "makefile", 5);
   origin = (char const   *)tmp___1;
   break;
   case 3U: 
   tmp___2 = dcgettext((char const   *)((void *)0), "environment under -e", 5);
   origin = (char const   *)tmp___2;
   break;
   case 4U: 
   tmp___3 = dcgettext((char const   *)((void *)0), "command line", 5);
   origin = (char const   *)tmp___3;
   break;
   case 5U: 
   tmp___4 = dcgettext((char const   *)((void *)0), "`override\' directive", 5);
   origin = (char const   *)tmp___4;
   break;
   case 6U: 
   tmp___5 = dcgettext((char const   *)((void *)0), "automatic", 5);
   origin = (char const   *)tmp___5;
   break;
   default: 
   abort();
   }
   fputs((char const   * __restrict  )"# ", (FILE * __restrict  )stdout);
   fputs((char const   * __restrict  )origin, (FILE * __restrict  )stdout);
   if (v->fileinfo.filenm) {
     printf((char const   * __restrict  )" (from `%s\', line %lu)", v->fileinfo.filenm,
            v->fileinfo.lineno);
   }
   putchar('\n');
   fputs((char const   * __restrict  )prefix, (FILE * __restrict  )stdout);
   if (v->recursive) {
     tmp___8 = strchr((char const   *)v->value, '\n');
     if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
       printf((char const   * __restrict  )"define %s\n%s\nendef\n", v->name, v->value);
     } else {
       goto _L___0;
     }
   } else {
     _L___0: /* CIL Label */ 
     if (v->recursive) {
       if (v->append) {
         tmp___6 = "+";
       } else {
         tmp___6 = "";
       }
       tmp___7 = tmp___6;
     } else {
       tmp___7 = ":";
     }
     printf((char const   * __restrict  )"%s %s= ", v->name, tmp___7);
     p = next_token(v->value);
     if ((unsigned long )p != (unsigned long )v->value) {
       if ((int )*p == 0) {
         printf((char const   * __restrict  )"$(subst ,,%s)", v->value);
       } else {
         goto _L;
       }
     } else
     _L: /* CIL Label */ 
     if (v->recursive) {
       fputs((char const   * __restrict  )v->value, (FILE * __restrict  )stdout);
     } else {
       p = v->value;
       while ((int )*p != 0) {
         if ((int )*p == 36) {
           putchar('$');
         }
         putchar((int )*p);
         p ++;
       }
     }
     putchar('\n');
   }
   return;
 }
 }
 void print_variable_set(struct variable_set *set , char *prefix ) 
 { 
   register unsigned int i ;
   register unsigned int nvariables ;
   register unsigned int per_bucket ;
   register struct variable *v ;
   register unsigned int this_bucket ;
   char *tmp ;
   char *tmp___0 ;
   char *tmp___1 ;
 
   {
   nvariables = 0U;
   per_bucket = nvariables;
   i = 0U;
   while (i < set->buckets) {
     this_bucket = 0U;
     v = *(set->table + i);
     while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
       this_bucket ++;
       print_variable(v, prefix);
       v = v->next;
     }
     nvariables += this_bucket;
     if (this_bucket > per_bucket) {
       per_bucket = this_bucket;
     }
     i ++;
   }
   if (nvariables == 0U) {
     tmp = dcgettext((char const   *)((void *)0), "# No variables.", 5);
     puts((char const   *)tmp);
   } else {
     tmp___0 = dcgettext((char const   *)((void *)0), "# %u variables in %u hash buckets.\n",
                         5);
     printf((char const   * __restrict  )tmp___0, nvariables, set->buckets);
     tmp___1 = dcgettext((char const   *)((void *)0), "# average of %.1f variables per bucket, max %u in one bucket.\n",
                         5);
     printf((char const   * __restrict  )tmp___1, (double )nvariables / (double )set->buckets,
            per_bucket);
   }
   return;
 }
 }
 void print_variable_data_base(void) 
 { 
   char *tmp ;
 
   {
   tmp = dcgettext((char const   *)((void *)0), "\n# Variables\n", 5);
   puts((char const   *)tmp);
   print_variable_set(& global_variable_set, (char *)"");
   return;
 }
 }
 void print_file_variables(struct file *file ) 
 { 
 
 
   {
   if ((unsigned long )file->variables != (unsigned long )((struct variable_set_list *)0)) {
     print_variable_set((file->variables)->set, (char *)"# ");
   }
   return;
 }
 }
 #pragma merger("0","/tmp/cil-lr0nQLdA.i","-g,-O0")
 static struct vpath *vpaths  ;
 static struct vpath *general_vpath  ;
 static struct vpath *gpaths  ;
 static int selective_vpath_search(struct vpath *path , char **file , uintmax_t *mtime_ptr ) ;
 void build_vpath_lists(void) 
 { 
   register struct vpath *new ;
   register struct vpath *old ;
   register struct vpath *nexto ;
   register char *p ;
   int save ;
   struct vpath *save_vpaths ;
   int save___0 ;
   struct vpath *save_vpaths___0 ;
 
   {
   new = (struct vpath *)0;
   old = vpaths;
   while ((unsigned long )old != (unsigned long )((struct vpath *)0)) {
     nexto = old->next;
     old->next = new;
     new = old;
     old = nexto;
   }
   vpaths = new;
   save = warn_undefined_variables_flag;
   warn_undefined_variables_flag = 0;
   p = variable_expand((char *)"$(strip $(VPATH))");
   warn_undefined_variables_flag = save;
   if ((int )*p != 0) {
     save_vpaths = vpaths;
     vpaths = (struct vpath *)0;
     construct_vpath_list((char *)"%", p);
     general_vpath = vpaths;
     vpaths = save_vpaths;
   }
   save___0 = warn_undefined_variables_flag;
   warn_undefined_variables_flag = 0;
   p = variable_expand((char *)"$(strip $(GPATH))");
   warn_undefined_variables_flag = save___0;
   if ((int )*p != 0) {
     save_vpaths___0 = vpaths;
     vpaths = (struct vpath *)0;
     construct_vpath_list((char *)"%", p);
     gpaths = vpaths;
     vpaths = save_vpaths___0;
   }
   return;
 }
 }
 void construct_vpath_list(char *pattern , char *dirpath ) 
 { 
   register unsigned int elem ;
   register char *p ;
   register char **vpath ;
   register unsigned int maxvpath ;
   unsigned int maxelem ;
   char *percent ;
   register struct vpath *path ;
   register struct vpath *lastpath ;
   struct vpath *next ;
   int tmp ;
   char *tmp___0 ;
   unsigned short const   **tmp___1 ;
   char *tmp___2 ;
   unsigned short const   **tmp___3 ;
   char *v ;
   unsigned int len ;
   unsigned short const   **tmp___4 ;
   unsigned int tmp___5 ;
   int tmp___6 ;
   unsigned short const   **tmp___7 ;
   struct vpath *path___0 ;
   char *tmp___8 ;
   char *tmp___9 ;
   size_t tmp___10 ;
 
   {
   percent = (char *)((void *)0);
   if ((unsigned long )pattern != (unsigned long )((char *)0)) {
     pattern = xstrdup((char const   *)pattern);
     percent = find_percent(pattern);
   }
   if ((unsigned long )dirpath == (unsigned long )((char *)0)) {
     lastpath = (struct vpath *)0;
     path = vpaths;
     while ((unsigned long )path != (unsigned long )((struct vpath *)0)) {
       next = path->next;
       if ((unsigned long )pattern == (unsigned long )((char *)0)) {
         goto _L___1;
       } else
       if ((unsigned long )percent == (unsigned long )((char *)0)) {
         if ((unsigned long )path->percent == (unsigned long )((char *)0)) {
           goto _L___2;
         } else {
           goto _L___3;
         }
       } else
       _L___3: /* CIL Label */ 
       if (percent - pattern == path->percent - path->pattern) {
         _L___2: /* CIL Label */ 
         if ((unsigned long )pattern == (unsigned long )path->pattern) {
           goto _L___1;
         } else
         if ((int )*pattern == (int )*(path->pattern)) {
           if ((int )*pattern == 0) {
             goto _L___1;
           } else {
             tmp = strcmp((char const   *)(pattern + 1), (char const   *)(path->pattern + 1));
             if (tmp) {
               lastpath = path;
             } else {
               _L___1: /* CIL Label */ 
               if ((unsigned long )lastpath == (unsigned long )((struct vpath *)0)) {
                 vpaths = path->next;
               } else {
                 lastpath->next = next;
               }
               free((void *)path->pattern);
               free((void *)((char *)path->searchpath));
               free((void *)((char *)path));
             }
           }
         } else {
           lastpath = path;
         }
       } else {
         lastpath = path;
       }
       path = next;
     }
     if ((unsigned long )pattern != (unsigned long )((char *)0)) {
       free((void *)pattern);
     }
     return;
   }
   maxelem = 2U;
   p = dirpath;
   while ((int )*p != 0) {
     tmp___0 = p;
     p ++;
     if ((int )*tmp___0 == 58) {
       maxelem ++;
     } else {
       tmp___1 = __ctype_b_loc();
       if ((int const   )*(*tmp___1 + (int )*p) & 1) {
         maxelem ++;
       }
     }
   }
   tmp___2 = xmalloc((unsigned int )((unsigned long )maxelem * sizeof(char *)));
   vpath = (char **)tmp___2;
   maxvpath = 0U;
   p = dirpath;
   while (1) {
     if (! ((int )*p == 58)) {
       tmp___3 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___3 + (int )*p) & 1)) {
         break;
       }
     }
     p ++;
   }
   elem = 0U;
   while ((int )*p != 0) {
     v = p;
     while (1) {
       if ((int )*p != 0) {
         if ((int )*p != 58) {
           tmp___4 = __ctype_b_loc();
           if ((int const   )*(*tmp___4 + (int )*p) & 1) {
             break;
           }
         } else {
           break;
         }
       } else {
         break;
       }
       p ++;
     }
     len = (unsigned int )(p - v);
     if (len > 1U) {
       if ((int )*(p + -1) == 47) {
         len --;
       }
     }
     if (len > 1U) {
       goto _L___4;
     } else
     if ((int )*v != 46) {
       _L___4: /* CIL Label */ 
       v = savestring((char const   *)v, len);
       tmp___6 = dir_file_exists_p(v, (char *)"");
       if (tmp___6) {
         tmp___5 = elem;
         elem ++;
         *(vpath + tmp___5) = dir_name(v);
         free((void *)v);
         if (len > maxvpath) {
           maxvpath = len;
         }
       } else {
         free((void *)v);
       }
     }
     while (1) {
       if (! ((int )*p == 58)) {
         tmp___7 = __ctype_b_loc();
         if (! ((int const   )*(*tmp___7 + (int )*p) & 1)) {
           break;
         }
       }
       p ++;
     }
   }
   if (elem > 0U) {
     if (elem < maxelem - 1U) {
       tmp___8 = xrealloc((char *)vpath, (unsigned int )((unsigned long )(elem + 1U) * sizeof(char *)));
       vpath = (char **)tmp___8;
     }
     *(vpath + elem) = (char *)0;
     tmp___9 = xmalloc((unsigned int )sizeof(struct vpath ));
     path___0 = (struct vpath *)tmp___9;
     path___0->searchpath = vpath;
     path___0->maxlen = maxvpath;
     path___0->next = vpaths;
     vpaths = path___0;
     path___0->pattern = pattern;
     path___0->percent = percent;
     tmp___10 = strlen((char const   *)pattern);
     path___0->patlen = (unsigned int )tmp___10;
   } else {
     free((void *)((char *)vpath));
     if ((unsigned long )pattern != (unsigned long )((char *)0)) {
       free((void *)pattern);
     }
   }
   return;
 }
 }
 int gpath_search(char *file , int len ) 
 { 
   register char **gp ;
   int tmp ;
 
   {
   if (gpaths) {
     if ((unsigned int )len <= gpaths->maxlen) {
       gp = gpaths->searchpath;
       while ((unsigned long )*gp != (unsigned long )((void *)0)) {
         tmp = strncmp((char const   *)*gp, (char const   *)file, (size_t )len);
         if (tmp == 0) {
           if ((int )*(*gp + len) == 0) {
             return (1);
           }
         }
         gp ++;
       }
     }
   }
   return (0);
 }
 }
 int vpath_search(char **file , uintmax_t *mtime_ptr ) 
 { 
   register struct vpath *v ;
   int tmp ;
   int tmp___0 ;
   int tmp___1 ;
 
   {
   if ((int )*(*file) == 47) {
     return (0);
   } else
   if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
     if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
       return (0);
     }
   }
   v = vpaths;
   while ((unsigned long )v != (unsigned long )((struct vpath *)0)) {
     tmp___0 = pattern_matches(v->pattern, v->percent, *file);
     if (tmp___0) {
       tmp = selective_vpath_search(v, file, mtime_ptr);
       if (tmp) {
         return (1);
       }
     }
     v = v->next;
   }
   if ((unsigned long )general_vpath != (unsigned long )((struct vpath *)0)) {
     tmp___1 = selective_vpath_search(general_vpath, file, mtime_ptr);
     if (tmp___1) {
       return (1);
     }
   }
   return (0);
 }
 }
 static int selective_vpath_search(struct vpath *path , char **file , uintmax_t *mtime_ptr ) 
 { 
   int not_target ;
   char *name ;
   char *n ;
   char *filename ;
   register char **vpath ;
   unsigned int maxvpath ;
   register unsigned int i ;
   unsigned int flen ;
   unsigned int vlen ;
   unsigned int name_dplen ;
   int exists ;
   struct file *f ;
   struct file *tmp ;
   int tmp___0 ;
   size_t tmp___1 ;
   char *tmp___2 ;
   int exists_in_cache ;
   size_t tmp___3 ;
   char *tmp___4 ;
   struct file *f___0 ;
   struct file *tmp___5 ;
   int tmp___6 ;
   struct stat st ;
   uintmax_t tmp___7 ;
   uintmax_t tmp___8 ;
   int tmp___9 ;
 
   {
   vpath = path->searchpath;
   maxvpath = path->maxlen;
   exists = 0;
   tmp = lookup_file(*file);
   f = tmp;
   if ((unsigned long )f == (unsigned long )((struct file *)0)) {
     tmp___0 = 1;
   } else
   if (! f->is_target) {
     tmp___0 = 1;
   } else {
     tmp___0 = 0;
   }
   not_target = tmp___0;
   tmp___1 = strlen((char const   *)*file);
   flen = (unsigned int )tmp___1;
   n = strrchr((char const   *)*file, '/');
   if ((unsigned long )n != (unsigned long )((char *)0)) {
     name_dplen = (unsigned int )(n - *file);
   } else {
     name_dplen = 0U;
   }
   if (name_dplen > 0U) {
     filename = n + 1;
   } else {
     filename = *file;
   }
   if (name_dplen > 0U) {
     flen -= name_dplen + 1U;
   }
   tmp___2 = xmalloc(((((maxvpath + 1U) + name_dplen) + 1U) + flen) + 1U);
   name = tmp___2;
   i = 0U;
   while ((unsigned long )*(vpath + i) != (unsigned long )((char *)0)) {
     exists_in_cache = 0;
     n = name;
     tmp___3 = strlen((char const   *)*(vpath + i));
     vlen = (unsigned int )tmp___3;
     memmove((void *)n, (void const   *)*(vpath + i), (size_t )vlen);
     n += vlen;
     if (name_dplen > 0U) {
       tmp___4 = n;
       n ++;
       *tmp___4 = (char )'/';
       memmove((void *)n, (void const   *)*file, (size_t )name_dplen);
       n += name_dplen;
     }
     if ((unsigned long )n != (unsigned long )name) {
       if ((int )*(n + -1) != 47) {
         *n = (char )'/';
         memmove((void *)(n + 1), (void const   *)filename, (size_t )(flen + 1U));
       } else {
         memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));
       }
     } else {
       memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));
     }
     tmp___5 = lookup_file(name);
     f___0 = tmp___5;
     if ((unsigned long )f___0 != (unsigned long )((struct file *)0)) {
       if (not_target) {
         tmp___6 = 1;
       } else
       if (f___0->is_target) {
         tmp___6 = 1;
       } else {
         tmp___6 = 0;
       }
       exists = tmp___6;
     }
     if (! exists) {
       *n = (char )'\000';
       exists = dir_file_exists_p(name, filename);
       exists_in_cache = exists;
     }
     if (exists) {
       *n = (char )'/';
       if (! exists_in_cache) {
         goto _L;
       } else {
         tmp___9 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
         if (tmp___9 == 0) {
           _L: /* CIL Label */ 
           *file = savestring((char const   *)name, (unsigned int )(((n + 1) - name) + (long )flen));
           if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
             if (exists_in_cache) {
               if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
                 tmp___7 = (uintmax_t )1000000000;
               } else {
                 tmp___7 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
               }
               if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
                 tmp___8 = (uintmax_t )1000000000;
               } else {
                 tmp___8 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
               }
               *mtime_ptr = (uintmax_t )st.st_mtim.tv_sec * tmp___7 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___8) / 1000000000UL;
             } else {
               *mtime_ptr = (uintmax_t )0;
             }
           }
           free((void *)name);
           return (1);
         } else {
           exists = 0;
         }
       }
     }
     i ++;
   }
   free((void *)name);
   return (0);
 }
 }
 void print_vpath_data_base(void) 
 { 
   register unsigned int nvpaths ;
   register struct vpath *v ;
   char *tmp ;
   register unsigned int i ;
   int tmp___0 ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   register char **path ;
   register unsigned int i___0 ;
   char *tmp___4 ;
   int tmp___5 ;
 
   {
   tmp = dcgettext((char const   *)((void *)0), "\n# VPATH Search Paths\n", 5);
   puts((char const   *)tmp);
   nvpaths = 0U;
   v = vpaths;
   while ((unsigned long )v != (unsigned long )((struct vpath *)0)) {
     nvpaths ++;
     printf((char const   * __restrict  )"vpath %s ", v->pattern);
     i = 0U;
     while ((unsigned long )*(v->searchpath + i) != (unsigned long )((char *)0)) {
       if ((unsigned long )*(v->searchpath + (i + 1U)) == (unsigned long )((char *)0)) {
         tmp___0 = '\n';
       } else {
         tmp___0 = ':';
       }
       printf((char const   * __restrict  )"%s%c", *(v->searchpath + i), tmp___0);
       i ++;
     }
     v = v->next;
   }
   if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
     tmp___1 = dcgettext((char const   *)((void *)0), "# No `vpath\' search paths.",
                         5);
     puts((char const   *)tmp___1);
   } else {
     tmp___2 = dcgettext((char const   *)((void *)0), "\n# %u `vpath\' search paths.\n",
                         5);
     printf((char const   * __restrict  )tmp___2, nvpaths);
   }
   if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
     tmp___3 = dcgettext((char const   *)((void *)0), "\n# No general (`VPATH\' variable) search path.",
                         5);
     puts((char const   *)tmp___3);
   } else {
     path = general_vpath->searchpath;
     tmp___4 = dcgettext((char const   *)((void *)0), "\n# General (`VPATH\' variable) search path:\n# ",
                         5);
     fputs((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);
     i___0 = 0U;
     while ((unsigned long )*(path + i___0) != (unsigned long )((char *)0)) {
       if ((unsigned long )*(path + (i___0 + 1U)) == (unsigned long )((char *)0)) {
         tmp___5 = '\n';
       } else {
         tmp___5 = ':';
       }
       printf((char const   * __restrict  )"%s%c", *(path + i___0), tmp___5);
       i___0 ++;
     }
   }
   return;
 }
 }
 #pragma merger("0","/tmp/cil-IL2nT0BF.i","-g,-O0")
 static char default_suffixes[136]  = 
   {      (char )'.',      (char )'o',      (char )'u',      (char )'t', 
         (char )' ',      (char )'.',      (char )'a',      (char )' ', 
         (char )'.',      (char )'l',      (char )'n',      (char )' ', 
         (char )'.',      (char )'o',      (char )' ',      (char )'.', 
         (char )'c',      (char )' ',      (char )'.',      (char )'c', 
         (char )'c',      (char )' ',      (char )'.',      (char )'C', 
         (char )' ',      (char )'.',      (char )'c',      (char )'p', 
         (char )'p',      (char )' ',      (char )'.',      (char )'p', 
         (char )' ',      (char )'.',      (char )'f',      (char )' ', 
         (char )'.',      (char )'F',      (char )' ',      (char )'.', 
         (char )'r',      (char )' ',      (char )'.',      (char )'y', 
         (char )' ',      (char )'.',      (char )'l',      (char )' ', 
         (char )'.',      (char )'s',      (char )' ',      (char )'.', 
         (char )'S',      (char )' ',      (char )'.',      (char )'m', 
         (char )'o',      (char )'d',      (char )' ',      (char )'.', 
         (char )'s',      (char )'y',      (char )'m',      (char )' ', 
         (char )'.',      (char )'d',      (char )'e',      (char )'f', 
         (char )' ',      (char )'.',      (char )'h',      (char )' ', 
         (char )'.',      (char )'i',      (char )'n',      (char )'f', 
         (char )'o',      (char )' ',      (char )'.',      (char )'d', 
         (char )'v',      (char )'i',      (char )' ',      (char )'.', 
         (char )'t',      (char )'e',      (char )'x',      (char )' ', 
         (char )'.',      (char )'t',      (char )'e',      (char )'x', 
         (char )'i',      (char )'n',      (char )'f',      (char )'o', 
         (char )' ',      (char )'.',      (char )'t',      (char )'e', 
         (char )'x',      (char )'i',      (char )' ',      (char )'.', 
         (char )'t',      (char )'x',      (char )'i',      (char )'n', 
         (char )'f',      (char )'o',      (char )' ',      (char )'.', 
         (char )'w',      (char )' ',      (char )'.',      (char )'c', 
         (char )'h',      (char )' ',      (char )'.',      (char )'w', 
         (char )'e',      (char )'b',      (char )' ',      (char )'.', 
         (char )'s',      (char )'h',      (char )' ',      (char )'.', 
         (char )'e',      (char )'l',      (char )'c',      (char )' ', 
         (char )'.',      (char )'e',      (char )'l',      (char )'\000'};
 static struct pspec default_pattern_rules[5]  = {      {(char *)"(%)", (char *)"%", (char *)"$(AR) $(ARFLAGS) $@ $<"}, 
         {(char *)"%.out", (char *)"%", (char *)"@rm -f $@ \n cp $< $@"}, 
         {(char *)"%.c", (char *)"%.w %.ch", (char *)"$(CTANGLE) $^ $@"}, 
         {(char *)"%.tex", (char *)"%.w %.ch", (char *)"$(CWEAVE) $^ $@"}, 
         {(char *)0, (char *)0, (char *)0}};
 static struct pspec default_terminal_rules[6]  = {      {(char *)"%", (char *)"%,v", (char *)"$(CHECKOUT,v)"}, 
         {(char *)"%", (char *)"RCS/%,v", (char *)"$(CHECKOUT,v)"}, 
         {(char *)"%", (char *)"RCS/%", (char *)"$(CHECKOUT,v)"}, 
         {(char *)"%", (char *)"s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
         {(char *)"%",
       (char *)"SCCS/s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
         {(char *)0, (char *)0, (char *)0}};
 static char *default_suffix_rules[92]  = 
   {      (char *)".o",      (char *)"$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".s",      (char *)"$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".S",      (char *)"$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".c",      (char *)"$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".cc",      (char *)"$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".C",      (char *)"$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".cpp",      (char *)"$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".f",      (char *)"$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".p",      (char *)"$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".F",      (char *)"$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
         (char *)".r",      (char *)"$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".mod",      (char *)"$(COMPILE.mod) -o $@ -e $@ $^", 
         (char *)".def.sym",      (char *)"$(COMPILE.def) -o $@ $<",      (char *)".sh",      (char *)"cat $< >$@ \n chmod a+x $@", 
         (char *)".s.o",      (char *)"$(COMPILE.s) -o $@ $<",      (char *)".S.o",      (char *)"$(COMPILE.S) -o $@ $<", 
         (char *)".c.o",      (char *)"$(COMPILE.c) $(OUTPUT_OPTION) $<",      (char *)".cc.o",      (char *)"$(COMPILE.cc) $(OUTPUT_OPTION) $<", 
         (char *)".C.o",      (char *)"$(COMPILE.C) $(OUTPUT_OPTION) $<",      (char *)".cpp.o",      (char *)"$(COMPILE.cpp) $(OUTPUT_OPTION) $<", 
         (char *)".f.o",      (char *)"$(COMPILE.f) $(OUTPUT_OPTION) $<",      (char *)".p.o",      (char *)"$(COMPILE.p) $(OUTPUT_OPTION) $<", 
         (char *)".F.o",      (char *)"$(COMPILE.F) $(OUTPUT_OPTION) $<",      (char *)".r.o",      (char *)"$(COMPILE.r) $(OUTPUT_OPTION) $<", 
         (char *)".mod.o",      (char *)"$(COMPILE.mod) -o $@ $<",      (char *)".c.ln",      (char *)"$(LINT.c) -C$* $<", 
         (char *)".y.ln",      (char *)"$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",      (char *)".l.ln",      (char *)"@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c", 
         (char *)".y.c",      (char *)"$(YACC.y) $< \n mv -f y.tab.c $@",      (char *)".l.c",      (char *)"@$(RM) $@ \n $(LEX.l) $< > $@", 
         (char *)".F.f",      (char *)"$(PREPROCESS.F) $(OUTPUT_OPTION) $<",      (char *)".r.f",      (char *)"$(PREPROCESS.r) $(OUTPUT_OPTION) $<", 
         (char *)".l.r",      (char *)"$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",      (char *)".S.s",      (char *)"$(PREPROCESS.S) $< > $@", 
         (char *)".texinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".texi.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@", 
         (char *)".txinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".tex.dvi",      (char *)"$(TEX) $<", 
         (char *)".texinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".texi.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<", 
         (char *)".txinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".w.c",      (char *)"$(CTANGLE) $< - $@", 
         (char *)".web.p",      (char *)"$(TANGLE) $<",      (char *)".w.tex",      (char *)"$(CWEAVE) $< - $@", 
         (char *)".web.tex",      (char *)"$(WEAVE) $<",      (char *)0,      (char *)0};
 static char *default_variables[118]  = 
   {      (char *)"AR",      (char *)"ar",      (char *)"ARFLAGS",      (char *)"rv", 
         (char *)"AS",      (char *)"as",      (char *)"CC",      (char *)"cc", 
         (char *)"CXX",      (char *)"g++",      (char *)"CHECKOUT,v",      (char *)"+$(if $(wildcard $@),,$(CO) $(COFLAGS) $< $@)", 
         (char *)"CO",      (char *)"co",      (char *)"COFLAGS",      (char *)"", 
         (char *)"CPP",      (char *)"$(CC) -E",      (char *)"FC",      (char *)"f77", 
         (char *)"F77",      (char *)"$(FC)",      (char *)"F77FLAGS",      (char *)"$(FFLAGS)", 
         (char *)"GET",      (char *)"get",      (char *)"LD",      (char *)"ld", 
         (char *)"LEX",      (char *)"lex",      (char *)"LINT",      (char *)"lint", 
         (char *)"M2C",      (char *)"m2c",      (char *)"PC",      (char *)"pc", 
         (char *)"YACC",      (char *)"yacc",      (char *)"MAKEINFO",      (char *)"makeinfo", 
         (char *)"TEX",      (char *)"tex",      (char *)"TEXI2DVI",      (char *)"texi2dvi", 
         (char *)"WEAVE",      (char *)"weave",      (char *)"CWEAVE",      (char *)"cweave", 
         (char *)"TANGLE",      (char *)"tangle",      (char *)"CTANGLE",      (char *)"ctangle", 
         (char *)"RM",      (char *)"rm -f",      (char *)"LINK.o",      (char *)"$(CC) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"COMPILE.C",      (char *)"$(COMPILE.cc)", 
         (char *)"COMPILE.cpp",      (char *)"$(COMPILE.cc)",      (char *)"LINK.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"LINK.C",      (char *)"$(LINK.cc)",      (char *)"LINK.cpp",      (char *)"$(LINK.cc)", 
         (char *)"YACC.y",      (char *)"$(YACC) $(YFLAGS)",      (char *)"LEX.l",      (char *)"$(LEX) $(LFLAGS) -t", 
         (char *)"COMPILE.f",      (char *)"$(FC) $(FFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.f",      (char *)"$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.def",      (char *)"$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.mod",      (char *)"$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)", 
         (char *)"COMPILE.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
         (char *)"LINK.s",      (char *)"$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",      (char *)"COMPILE.s",      (char *)"$(AS) $(ASFLAGS) $(TARGET_MACH)", 
         (char *)"LINK.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",      (char *)"COMPILE.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c", 
         (char *)"PREPROCESS.S",      (char *)"$(CC) -E $(CPPFLAGS)",      (char *)"PREPROCESS.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F", 
         (char *)"PREPROCESS.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",      (char *)"LINT.c",      (char *)"$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)", 
         (char *)"OUTPUT_OPTION",      (char *)"-o $@",      (char *)".LIBPATTERNS",      (char *)"lib%.so lib%.a", 
         (char *)0,      (char *)0};
 void set_default_suffixes(void) 
 { 
   char *p ;
   struct nameseq *tmp ;
   struct nameseq *tmp___0 ;
 
   {
   suffix_file = enter_file((char *)".SUFFIXES");
   if (no_builtin_rules_flag) {
     define_variable_in_set((char *)"SUFFIXES", 8U, (char *)"", (enum variable_origin )0,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   } else {
     p = default_suffixes;
     tmp = parse_file_seq(& p, '\000', (unsigned int )sizeof(struct dep ), 1);
     tmp___0 = multi_glob(tmp, (unsigned int )sizeof(struct dep ));
     suffix_file->deps = (struct dep *)tmp___0;
     define_variable_in_set((char *)"SUFFIXES", 8U, default_suffixes, (enum variable_origin )0,
                            0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
   }
   return;
 }
 }
 void install_default_suffix_rules(void) 
 { 
   register char **s ;
   register struct file *f ;
   struct file *tmp ;
   char *tmp___0 ;
 
   {
   if (no_builtin_rules_flag) {
     return;
   }
   s = default_suffix_rules;
   while ((unsigned long )*s != (unsigned long )((char *)0)) {
     tmp = enter_file(*(s + 0));
     f = tmp;
     if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
       tmp___0 = xmalloc((unsigned int )sizeof(struct commands ));
       f->cmds = (struct commands *)tmp___0;
       (f->cmds)->fileinfo.filenm = (char *)0;
       (f->cmds)->commands = *(s + 1);
       (f->cmds)->command_lines = (char **)0;
     }
     s += 2;
   }
   return;
 }
 }
 void install_default_implicit_rules(void) 
 { 
   register struct pspec *p ;
 
   {
   if (no_builtin_rules_flag) {
     return;
   }
   p = default_pattern_rules;
   while ((unsigned long )p->target != (unsigned long )((char *)0)) {
     install_pattern_rule(p, 0);
     p ++;
   }
   p = default_terminal_rules;
   while ((unsigned long )p->target != (unsigned long )((char *)0)) {
     install_pattern_rule(p, 1);
     p ++;
   }
   return;
 }
 }
 void define_default_variables(void) 
 { 
   register char **s ;
   size_t tmp ;
 
   {
   if (no_builtin_variables_flag) {
     return;
   }
   s = default_variables;
   while ((unsigned long )*s != (unsigned long )((char *)0)) {
     tmp = strlen((char const   *)*(s + 0));
     define_variable_in_set(*(s + 0), (unsigned int )tmp, *(s + 1), (enum variable_origin )0,
                            1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
     s += 2;
   }
   return;
 }
 }
 #pragma merger("0","/tmp/cil-lUReg5Kq.i","-g,-O0")
 char *remote_description  =    (char *)0;
 void remote_setup(void) 
 { 
 
 
   {
   return;
 }
 }
 void remote_cleanup(void) 
 { 
 
 
   {
   return;
 }
 }
 int start_remote_job_p(int first_p ) 
 { 
 
 
   {
   return (0);
 }
 }
 int start_remote_job(char **argv , char **envp , int stdin_fd , int *is_remote , int *id_ptr ,
                      int *used_stdin ) 
 { 
 
 
   {
   return (-1);
 }
 }
 int remote_status(int *exit_code_ptr , int *signal_ptr , int *coredump_ptr , int block ) 
 { 
   int *tmp ;
 
   {
   tmp = __errno_location();
   *tmp = 10;
   return (-1);
 }
 }
 void block_remote_children(void) 
 { 
 
 
   {
   return;
 }
 }
 void unblock_remote_children(void) 
 { 
 
 
   {
   return;
 }
 }
 int remote_kill(int id , int sig ) 
 { 
 
 
   {
   return (-1);
 }
 }
 #pragma merger("0","/tmp/cil-1mks5shs.i","-g,-O0")
 char *version_string  =    (char *)"3.79";
 char *make_host  =    (char *)"";
 #pragma merger("0","/tmp/cil-wnI9fUGf.i","-g,-O0")
 #pragma merger("0","/tmp/cil-cDTpBoNV.i","-g,-O0")
 extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ) ;
 static char const   *_nl_normalize_codeset(unsigned char const   *codeset , size_t name_len ) ;
 static struct loaded_l10nfile *_nl_make_l10nflist(struct loaded_l10nfile **l10nfile_list ,
                                                   char const   *dirlist , size_t dirlist_len ,
                                                   int mask , char const   *language ,
                                                   char const   *territory , char const   *codeset ,
                                                   char const   *normalized_codeset ,
                                                   char const   *modifier , char const   *special ,
                                                   char const   *sponsor , char const   *revision ,
                                                   char const   *filename , int do_allocate ) ;
 static char const   *_nl_expand_alias(char const   *name ) ;
 static int _nl_explode_name(char *name , char const   **language , char const   **modifier ,
                             char const   **territory , char const   **codeset , char const   **normalized_codeset ,
                             char const   **special , char const   **sponsor , char const   **revision ) ;
 static size_t argz_count__(char const   *argz , size_t len ) ;
 static size_t argz_count__(char const   *argz , size_t len ) 
 { 
   size_t count ;
   size_t part_len ;
   size_t tmp ;
 
   {
   count = (size_t )0;
   while (len > 0UL) {
     tmp = strlen(argz);
     part_len = tmp;
     argz += part_len + 1UL;
     len -= part_len + 1UL;
     count ++;
   }
   return (count);
 }
 }
 static void argz_stringify__(char *argz , size_t len , int sep ) ;
 static void argz_stringify__(char *argz , size_t len , int sep ) 
 { 
   size_t part_len ;
   size_t tmp ;
   char *tmp___0 ;
 
   {
   while (len > 0UL) {
     tmp = strlen((char const   *)argz);
     part_len = tmp;
     argz += part_len;
     len -= part_len + 1UL;
     if (len > 0UL) {
       tmp___0 = argz;
       argz ++;
       *tmp___0 = (char )sep;
     }
   }
   return;
 }
 }
 static char *argz_next__(char *argz , size_t argz_len , char const   *entry ) ;
 static char *argz_next__(char *argz , size_t argz_len , char const   *entry ) 
 { 
   char *tmp ;
   char *tmp___0 ;
 
   {
   if (entry) {
     if ((unsigned long )entry < (unsigned long )(argz + argz_len)) {
       tmp = strchr(entry, '\000');
       entry = (char const   *)(tmp + 1);
     }
     if ((unsigned long )entry >= (unsigned long )(argz + argz_len)) {
       tmp___0 = (char *)((void *)0);
     } else {
       tmp___0 = (char *)entry;
     }
     return (tmp___0);
   } else
   if (argz_len > 0UL) {
     return (argz);
   } else {
     return ((char *)0);
   }
 }
 }
 __inline static int pop(int x ) ;
 __inline static int pop(int x ) 
 { 
 
 
   {
   x = ((x & -21846) >> 1) + (x & 21845);
   x = ((x & -13108) >> 2) + (x & 13107);
   x = ((x >> 4) + x) & 3855;
   x = ((x >> 8) + x) & 255;
   return (x);
 }
 }
 static struct loaded_l10nfile *_nl_make_l10nflist(struct loaded_l10nfile **l10nfile_list ,
                                                   char const   *dirlist , size_t dirlist_len ,
                                                   int mask , char const   *language ,
                                                   char const   *territory , char const   *codeset ,
                                                   char const   *normalized_codeset ,
                                                   char const   *modifier , char const   *special ,
                                                   char const   *sponsor , char const   *revision ,
                                                   char const   *filename , int do_allocate ) 
 { 
   char *abs_filename ;
   struct loaded_l10nfile *last ;
   struct loaded_l10nfile *retval ;
   char *cp ;
   size_t entries ;
   int cnt ;
   size_t tmp ;
   size_t tmp___0 ;
   size_t tmp___1 ;
   size_t tmp___2 ;
   size_t tmp___3 ;
   size_t tmp___4 ;
   size_t tmp___5 ;
   size_t tmp___6 ;
   size_t tmp___7 ;
   size_t tmp___8 ;
   size_t tmp___9 ;
   size_t tmp___10 ;
   size_t tmp___11 ;
   size_t tmp___12 ;
   size_t tmp___13 ;
   size_t tmp___14 ;
   size_t tmp___15 ;
   int tmp___16 ;
   char *tmp___17 ;
   char *tmp___18 ;
   char *tmp___19 ;
   char *tmp___20 ;
   char *tmp___21 ;
   char *tmp___22 ;
   char *tmp___23 ;
   char *tmp___24 ;
   char *tmp___25 ;
   int compare ;
   int tmp___26 ;
   size_t tmp___27 ;
   int tmp___28 ;
   int tmp___29 ;
   size_t tmp___30 ;
   int tmp___31 ;
   size_t tmp___33 ;
   char *dir ;
   size_t tmp___34 ;
   size_t tmp___35 ;
 
   {
   last = (struct loaded_l10nfile *)((void *)0);
   tmp = strlen(language);
   if ((mask & 32) != 0) {
     tmp___0 = strlen(territory);
     tmp___1 = tmp___0 + 1UL;
   } else {
     tmp___1 = (size_t )0;
   }
   if ((mask & 16) != 0) {
     tmp___2 = strlen(codeset);
     tmp___3 = tmp___2 + 1UL;
   } else {
     tmp___3 = (size_t )0;
   }
   if ((mask & 8) != 0) {
     tmp___4 = strlen(normalized_codeset);
     tmp___5 = tmp___4 + 1UL;
   } else {
     tmp___5 = (size_t )0;
   }
   if ((mask & 128) != 0) {
     tmp___6 = strlen(modifier);
     tmp___7 = tmp___6 + 1UL;
   } else
   if ((mask & 64) != 0) {
     tmp___6 = strlen(modifier);
     tmp___7 = tmp___6 + 1UL;
   } else {
     tmp___7 = (size_t )0;
   }
   if ((mask & 4) != 0) {
     tmp___8 = strlen(special);
     tmp___9 = tmp___8 + 1UL;
   } else {
     tmp___9 = (size_t )0;
   }
   if ((mask & 2) != 0) {
     goto _L;
   } else
   if ((mask & 1) != 0) {
     _L: /* CIL Label */ 
     if ((mask & 2) != 0) {
       tmp___10 = strlen(sponsor);
       tmp___11 = tmp___10 + 1UL;
     } else {
       tmp___11 = (size_t )0;
     }
     if ((mask & 1) != 0) {
       tmp___12 = strlen(revision);
       tmp___13 = tmp___12 + 1UL;
     } else {
       tmp___13 = (size_t )0;
     }
     tmp___14 = (1UL + tmp___11) + tmp___13;
   } else {
     tmp___14 = (size_t )0;
   }
   tmp___15 = strlen(filename);
   tmp___16 = (int )malloc((((((((((dirlist_len + tmp) + tmp___1) + tmp___3) + tmp___5) + tmp___7) + tmp___9) + tmp___14) + 1UL) + tmp___15) + 1UL);
   abs_filename = (char *)tmp___16;
   if ((unsigned long )abs_filename == (unsigned long )((void *)0)) {
     return ((struct loaded_l10nfile *)((void *)0));
   }
   retval = (struct loaded_l10nfile *)((void *)0);
   last = (struct loaded_l10nfile *)((void *)0);
   memcpy((void * __restrict  )abs_filename, (void const   * __restrict  )dirlist,
          dirlist_len);
   argz_stringify__(abs_filename, dirlist_len, ':');
   cp = abs_filename + (dirlist_len - 1UL);
   tmp___17 = cp;
   cp ++;
   *tmp___17 = (char )'/';
   cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )language);
   if ((mask & 32) != 0) {
     tmp___18 = cp;
     cp ++;
     *tmp___18 = (char )'_';
     cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )territory);
   }
   if ((mask & 16) != 0) {
     tmp___19 = cp;
     cp ++;
     *tmp___19 = (char )'.';
     cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )codeset);
   }
   if ((mask & 8) != 0) {
     tmp___20 = cp;
     cp ++;
     *tmp___20 = (char )'.';
     cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )normalized_codeset);
   }
   if ((mask & 192) != 0) {
     tmp___21 = cp;
     cp ++;
     if ((mask & 64) != 0) {
       *tmp___21 = (char )'+';
     } else {
       *tmp___21 = (char )'@';
     }
     cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )modifier);
   }
   if ((mask & 4) != 0) {
     tmp___22 = cp;
     cp ++;
     *tmp___22 = (char )'+';
     cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )special);
   }
   if ((mask & 3) != 0) {
     tmp___23 = cp;
     cp ++;
     *tmp___23 = (char )',';
     if ((mask & 2) != 0) {
       cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )sponsor);
     }
     if ((mask & 1) != 0) {
       tmp___24 = cp;
       cp ++;
       *tmp___24 = (char )'_';
       cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )revision);
     }
   }
   tmp___25 = cp;
   cp ++;
   *tmp___25 = (char )'/';
   stpcpy((char * __restrict  )cp, (char const   * __restrict  )filename);
   last = (struct loaded_l10nfile *)((void *)0);
   retval = *l10nfile_list;
   while ((unsigned long )retval != (unsigned long )((void *)0)) {
     if ((unsigned long )retval->filename != (unsigned long )((void *)0)) {
       tmp___26 = strcmp(retval->filename, (char const   *)abs_filename);
       compare = tmp___26;
       if (compare == 0) {
         break;
       }
       if (compare < 0) {
         retval = (struct loaded_l10nfile *)((void *)0);
         break;
       }
       last = retval;
     }
     retval = retval->next;
   }
   if ((unsigned long )retval != (unsigned long )((void *)0)) {
     free(abs_filename);
     return (retval);
   } else
   if (do_allocate == 0) {
     free(abs_filename);
     return (retval);
   }
   tmp___27 = argz_count__(dirlist, dirlist_len);
   tmp___28 = pop(mask);
   tmp___29 = (int )malloc(sizeof(*retval) + (tmp___27 * (size_t )(1 << tmp___28)) * sizeof(struct loaded_l10nfile *));
   retval = (struct loaded_l10nfile *)tmp___29;
   if ((unsigned long )retval == (unsigned long )((void *)0)) {
     return ((struct loaded_l10nfile *)((void *)0));
   }
   retval->filename = (char const   *)abs_filename;
   tmp___30 = argz_count__(dirlist, dirlist_len);
   if (tmp___30 != 1UL) {
     tmp___31 = 1;
   } else
   if ((mask & 16) != 0) {
     if ((mask & 8) != 0) {
       tmp___31 = 1;
     } else {
       tmp___31 = 0;
     }
   } else {
     tmp___31 = 0;
   }
   retval->decided = tmp___31;
   retval->data = (void const   *)((void *)0);
   if ((unsigned long )last == (unsigned long )((void *)0)) {
     retval->next = *l10nfile_list;
     *l10nfile_list = retval;
   } else {
     retval->next = last->next;
     last->next = retval;
   }
   entries = (size_t )0;
   tmp___33 = argz_count__(dirlist, dirlist_len);
   if (tmp___33 == 1UL) {
     cnt = mask - 1;
   } else {
     cnt = mask;
   }
   while (cnt >= 0) {
     if ((cnt & ~ mask) == 0) {
       if ((cnt & 71) == 0) {
         goto _L___1;
       } else
       if ((cnt & 152) == 0) {
         _L___1: /* CIL Label */ 
         if ((cnt & 16) == 0) {
           goto _L___0;
         } else
         if ((cnt & 8) == 0) {
           _L___0: /* CIL Label */ 
           dir = (char *)((void *)0);
           while (1) {
             dir = argz_next__((char *)dirlist, dirlist_len, (char const   *)dir);
             if (! ((unsigned long )dir != (unsigned long )((void *)0))) {
               break;
             }
             tmp___34 = entries;
             entries ++;
             tmp___35 = strlen((char const   *)dir);
             retval->successor[tmp___34] = _nl_make_l10nflist(l10nfile_list, (char const   *)dir,
                                                              tmp___35 + 1UL, cnt,
                                                              language, territory,
                                                              codeset, normalized_codeset,
                                                              modifier, special, sponsor,
                                                              revision, filename, 1);
           }
         }
       }
     }
     cnt --;
   }
   retval->successor[entries] = (struct loaded_l10nfile *)((void *)0);
   return (retval);
 }
 }
 static char const   *_nl_normalize_codeset(unsigned char const   *codeset , size_t name_len ) 
 { 
   int len ;
   int only_digit ;
   char *retval ;
   char *wp ;
   size_t cnt ;
   unsigned short const   **tmp ;
   unsigned short const   **tmp___0 ;
   int tmp___1 ;
   int tmp___2 ;
   char *tmp___3 ;
   int tmp___4 ;
   char *tmp___5 ;
   unsigned short const   **tmp___6 ;
   unsigned short const   **tmp___7 ;
 
   {
   len = 0;
   only_digit = 1;
   cnt = (size_t )0;
   while (cnt < name_len) {
     tmp___0 = __ctype_b_loc();
     if ((int const   )*(*tmp___0 + (int )*(codeset + cnt)) & 8) {
       len ++;
       tmp = __ctype_b_loc();
       if ((int const   )*(*tmp + (int )*(codeset + cnt)) & 1024) {
         only_digit = 0;
       }
     }
     cnt ++;
   }
   if (only_digit) {
     tmp___1 = 3;
   } else {
     tmp___1 = 0;
   }
   tmp___2 = (int )malloc((tmp___1 + len) + 1);
   retval = (char *)tmp___2;
   if ((unsigned long )retval != (unsigned long )((void *)0)) {
     if (only_digit) {
       wp = stpcpy((char * __restrict  )retval, (char const   * __restrict  )"iso");
     } else {
       wp = retval;
     }
     cnt = (size_t )0;
     while (cnt < name_len) {
       tmp___7 = __ctype_b_loc();
       if ((int const   )*(*tmp___7 + (int )*(codeset + cnt)) & 1024) {
         tmp___3 = wp;
         wp ++;
         tmp___4 = tolower((int )*(codeset + cnt));
         *tmp___3 = (char )tmp___4;
       } else {
         tmp___6 = __ctype_b_loc();
         if ((int const   )*(*tmp___6 + (int )*(codeset + cnt)) & 2048) {
           tmp___5 = wp;
           wp ++;
           *tmp___5 = (char )*(codeset + cnt);
         }
       }
       cnt ++;
     }
     *wp = (char )'\000';
   }
   return ((char const   *)retval);
 }
 }
 static int _nl_explode_name(char *name , char const   **language , char const   **modifier ,
                             char const   **territory , char const   **codeset , char const   **normalized_codeset ,
                             char const   **special , char const   **sponsor , char const   **revision ) 
 { 
   enum __anonenum_syntax_17 syntax ;
   char *cp ;
   int mask ;
   int tmp ;
 
   {
   *modifier = (char const   *)((void *)0);
   *territory = (char const   *)((void *)0);
   *codeset = (char const   *)((void *)0);
   *normalized_codeset = (char const   *)((void *)0);
   *special = (char const   *)((void *)0);
   *sponsor = (char const   *)((void *)0);
   *revision = (char const   *)((void *)0);
   mask = 0;
   syntax = (enum __anonenum_syntax_17 )0;
   cp = name;
   *language = (char const   *)cp;
   while (1) {
     if ((int )*(cp + 0) != 0) {
       if ((int )*(cp + 0) != 95) {
         if ((int )*(cp + 0) != 64) {
           if ((int )*(cp + 0) != 43) {
             if (! ((int )*(cp + 0) != 44)) {
               break;
             }
           } else {
             break;
           }
         } else {
           break;
         }
       } else {
         break;
       }
     } else {
       break;
     }
     cp ++;
   }
   if ((unsigned long )*language == (unsigned long )cp) {
     cp = strchr(*language, '\000');
   } else
   if ((int )*(cp + 0) == 95) {
     *(cp + 0) = (char )'\000';
     cp ++;
     *territory = (char const   *)cp;
     while (1) {
       if ((int )*(cp + 0) != 0) {
         if ((int )*(cp + 0) != 46) {
           if ((int )*(cp + 0) != 64) {
             if ((int )*(cp + 0) != 43) {
               if ((int )*(cp + 0) != 44) {
                 if (! ((int )*(cp + 0) != 95)) {
                   break;
                 }
               } else {
                 break;
               }
             } else {
               break;
             }
           } else {
             break;
           }
         } else {
           break;
         }
       } else {
         break;
       }
       cp ++;
     }
     mask |= 32;
     if ((int )*(cp + 0) == 46) {
       syntax = (enum __anonenum_syntax_17 )1;
       *(cp + 0) = (char )'\000';
       cp ++;
       *codeset = (char const   *)cp;
       while (1) {
         if ((int )*(cp + 0) != 0) {
           if (! ((int )*(cp + 0) != 64)) {
             break;
           }
         } else {
           break;
         }
         cp ++;
       }
       mask |= 16;
       if ((unsigned long )*codeset != (unsigned long )cp) {
         if ((int const   )*(*codeset + 0) != 0) {
           *normalized_codeset = _nl_normalize_codeset((unsigned char const   *)*codeset,
                                                       (size_t )(cp - (char *)*codeset));
           tmp = strcmp(*codeset, *normalized_codeset);
           if (tmp == 0) {
             free((char *)*normalized_codeset);
           } else {
             mask |= 8;
           }
         }
       }
     }
   }
   if ((int )*(cp + 0) == 64) {
     goto _L;
   } else
   if ((unsigned int )syntax != 1U) {
     if ((int )*(cp + 0) == 43) {
       _L: /* CIL Label */ 
       if ((int )*(cp + 0) == 64) {
         syntax = (enum __anonenum_syntax_17 )1;
       } else {
         syntax = (enum __anonenum_syntax_17 )2;
       }
       *(cp + 0) = (char )'\000';
       cp ++;
       *modifier = (char const   *)cp;
       while (1) {
         if ((unsigned int )syntax == 2U) {
           if ((int )*(cp + 0) != 0) {
             if ((int )*(cp + 0) != 43) {
               if ((int )*(cp + 0) != 44) {
                 if (! ((int )*(cp + 0) != 95)) {
                   break;
                 }
               } else {
                 break;
               }
             } else {
               break;
             }
           } else {
             break;
           }
         } else {
           break;
         }
         cp ++;
       }
       mask |= 192;
     }
   }
   if ((unsigned int )syntax != 1U) {
     if ((int )*(cp + 0) == 43) {
       goto _L___0;
     } else
     if ((int )*(cp + 0) == 44) {
       goto _L___0;
     } else
     if ((int )*(cp + 0) == 95) {
       _L___0: /* CIL Label */ 
       syntax = (enum __anonenum_syntax_17 )2;
       if ((int )*(cp + 0) == 43) {
         *(cp + 0) = (char )'\000';
         cp ++;
         *special = (char const   *)cp;
         while (1) {
           if ((int )*(cp + 0) != 0) {
             if ((int )*(cp + 0) != 44) {
               if (! ((int )*(cp + 0) != 95)) {
                 break;
               }
             } else {
               break;
             }
           } else {
             break;
           }
           cp ++;
         }
         mask |= 4;
       }
       if ((int )*(cp + 0) == 44) {
         *(cp + 0) = (char )'\000';
         cp ++;
         *sponsor = (char const   *)cp;
         while (1) {
           if ((int )*(cp + 0) != 0) {
             if (! ((int )*(cp + 0) != 95)) {
               break;
             }
           } else {
             break;
           }
           cp ++;
         }
         mask |= 2;
       }
       if ((int )*(cp + 0) == 95) {
         *(cp + 0) = (char )'\000';
         cp ++;
         *revision = (char const   *)cp;
         mask |= 1;
       }
     }
   }
   if ((unsigned int )syntax == 1U) {
     if ((unsigned long )*territory != (unsigned long )((void *)0)) {
       if ((int const   )*(*territory + 0) == 0) {
         mask &= -33;
       }
     }
     if ((unsigned long )*codeset != (unsigned long )((void *)0)) {
       if ((int const   )*(*codeset + 0) == 0) {
         mask &= -17;
       }
     }
     if ((unsigned long )*modifier != (unsigned long )((void *)0)) {
       if ((int const   )*(*modifier + 0) == 0) {
         mask &= -129;
       }
     }
   }
   return (mask);
 }
 }
 __inline static nls_uint32 SWAP(nls_uint32 i ) ;
 __inline static nls_uint32 SWAP(nls_uint32 i ) 
 { 
 
 
   {
   return ((((i << 24) | ((i & 65280U) << 8)) | ((i >> 8) & 65280U)) | (i >> 24));
 }
 }
 int _nl_msg_cat_cntr  =    0;
 static void _nl_load_domain(struct loaded_l10nfile *domain_file ) 
 { 
   int fd ;
   size_t size ;
   struct stat st ;
   struct mo_file_header *data ;
   struct loaded_domain *domain ;
   int tmp ;
   size_t to_read ;
   char *read_ptr ;
   int tmp___0 ;
   long nb ;
   ssize_t tmp___1 ;
   int tmp___2 ;
   nls_uint32 tmp___3 ;
   nls_uint32 tmp___4 ;
   nls_uint32 tmp___5 ;
   nls_uint32 tmp___6 ;
   nls_uint32 tmp___7 ;
   nls_uint32 tmp___8 ;
   nls_uint32 tmp___9 ;
   nls_uint32 tmp___10 ;
   nls_uint32 tmp___11 ;
   nls_uint32 tmp___12 ;
 
   {
   data = (struct mo_file_header *)-1;
   domain_file->decided = 1;
   domain_file->data = (void const   *)((void *)0);
   if ((unsigned long )domain_file->filename == (unsigned long )((void *)0)) {
     return;
   }
   fd = open(domain_file->filename, 0);
   if (fd == -1) {
     return;
   }
   tmp = fstat(fd, & st);
   if (tmp != 0) {
     close(fd);
     return;
   } else {
     size = (size_t )st.st_size;
     if (size != (size_t )st.st_size) {
       close(fd);
       return;
     } else
     if (size < sizeof(struct mo_file_header )) {
       close(fd);
       return;
     }
   }
   if ((unsigned long )data == (unsigned long )((struct mo_file_header *)-1)) {
     tmp___0 = (int )malloc(size);
     data = (struct mo_file_header *)tmp___0;
     if ((unsigned long )data == (unsigned long )((void *)0)) {
       return;
     }
     to_read = size;
     read_ptr = (char *)data;
     while (1) {
       tmp___1 = read(fd, (void *)read_ptr, to_read);
       nb = tmp___1;
       if (nb == -1L) {
         close(fd);
         return;
       }
       read_ptr += nb;
       to_read -= (size_t )nb;
       if (! (to_read > 0UL)) {
         break;
       }
     }
     close(fd);
   }
   if (data->magic != 2500072158U) {
     if (data->magic != 3725722773U) {
       free(data);
       return;
     }
   }
   tmp___2 = (int )malloc(sizeof(struct loaded_domain ));
   domain_file->data = (void const   *)((struct loaded_domain *)tmp___2);
   if ((unsigned long )domain_file->data == (unsigned long )((void *)0)) {
     return;
   }
   domain = (struct loaded_domain *)domain_file->data;
   domain->data = (char const   *)((char *)data);
   domain->mmap_size = size;
   domain->must_swap = data->magic != 2500072158U;
   if (domain->must_swap) {
     tmp___3 = SWAP(data->revision);
     tmp___4 = tmp___3;
   } else {
     tmp___4 = data->revision;
   }
   switch (tmp___4) {
   case 0U: 
   if (domain->must_swap) {
     tmp___5 = SWAP(data->nstrings);
     domain->nstrings = tmp___5;
   } else {
     domain->nstrings = data->nstrings;
   }
   if (domain->must_swap) {
     tmp___6 = SWAP(data->orig_tab_offset);
     tmp___7 = tmp___6;
   } else {
     tmp___7 = data->orig_tab_offset;
   }
   domain->orig_tab = (struct string_desc *)((char *)data + tmp___7);
   if (domain->must_swap) {
     tmp___8 = SWAP(data->trans_tab_offset);
     tmp___9 = tmp___8;
   } else {
     tmp___9 = data->trans_tab_offset;
   }
   domain->trans_tab = (struct string_desc *)((char *)data + tmp___9);
   if (domain->must_swap) {
     tmp___10 = SWAP(data->hash_tab_size);
     domain->hash_size = tmp___10;
   } else {
     domain->hash_size = data->hash_tab_size;
   }
   if (domain->must_swap) {
     tmp___11 = SWAP(data->hash_tab_offset);
     tmp___12 = tmp___11;
   } else {
     tmp___12 = data->hash_tab_offset;
   }
   domain->hash_tab = (nls_uint32 *)((char *)data + tmp___12);
   break;
   default: 
   free(data);
   free(domain);
   domain_file->data = (void const   *)((void *)0);
   return;
   }
   _nl_msg_cat_cntr ++;
   return;
 }
 }
 static char *string_space  =    (char *)((void *)0);
 static size_t string_space_act  =    (size_t )0;
 static size_t string_space_max  =    (size_t )0;
 static struct alias_map *map  ;
 static size_t nmap  =    (size_t )0;
 static size_t maxmap  =    (size_t )0;
 static size_t read_alias_file(char const   *fname , int fname_len ) ;
 static void extend_alias_table(void) ;
 static int alias_compare(struct alias_map  const  *map1 , struct alias_map  const  *map2 ) ;
 static char const   *locale_alias_path  =    "/usr/local/share/locale:.";
 extern int ( /* missing proto */  bsearch)() ;
 static char const   *_nl_expand_alias(char const   *name ) 
 { 
   struct alias_map *retval ;
   char const   *result___0 ;
   size_t added ;
   struct alias_map item ;
   int tmp ;
   char const   *start ;
 
   {
   result___0 = (char const   *)((void *)0);
   while (1) {
     item.alias = name;
     if (nmap > 0UL) {
       tmp = bsearch(& item, map, nmap, sizeof(struct alias_map ), (int (*)(void const   * ,
                                                                            void const   * ))(& alias_compare));
       retval = (struct alias_map *)tmp;
     } else {
       retval = (struct alias_map *)((void *)0);
     }
     if ((unsigned long )retval != (unsigned long )((void *)0)) {
       result___0 = retval->value;
       break;
     }
     added = (size_t )0;
     while (1) {
       if (added == 0UL) {
         if (! ((int const   )*(locale_alias_path + 0) != 0)) {
           break;
         }
       } else {
         break;
       }
       while ((int const   )*(locale_alias_path + 0) == 58) {
         locale_alias_path ++;
       }
       start = locale_alias_path;
       while (1) {
         if ((int const   )*(locale_alias_path + 0) != 0) {
           if (! ((int const   )*(locale_alias_path + 0) != 58)) {
             break;
           }
         } else {
           break;
         }
         locale_alias_path ++;
       }
       if ((unsigned long )start < (unsigned long )locale_alias_path) {
         added = read_alias_file(start, (int )(locale_alias_path - start));
       }
     }
     if (! (added != 0UL)) {
       break;
     }
   }
   return (result___0);
 }
 }
 static char const   aliasfile[14]  = 
   {      (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
         (char const   )'a',      (char const   )'l',      (char const   )'e',      (char const   )'.', 
         (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'a', 
         (char const   )'s',      (char const   )'\000'};
 static size_t read_alias_file(char const   *fname , int fname_len ) 
 { 
   FILE *fp ;
   char *full_fname ;
   size_t added ;
   void *tmp ;
   unsigned char buf___1[8192] ;
   unsigned char *alias ;
   unsigned char *value ;
   unsigned char *cp ;
   char *tmp___0 ;
   char altbuf[8192] ;
   char *tmp___1 ;
   char *tmp___2 ;
   char *tmp___3 ;
   unsigned short const   **tmp___4 ;
   unsigned char *tmp___5 ;
   unsigned short const   **tmp___6 ;
   unsigned char *tmp___7 ;
   unsigned short const   **tmp___8 ;
   size_t alias_len ;
   size_t value_len ;
   unsigned char *tmp___9 ;
   unsigned short const   **tmp___10 ;
   unsigned char *tmp___11 ;
   unsigned char *tmp___12 ;
   size_t tmp___13 ;
   size_t tmp___14 ;
   size_t new_size ;
   size_t tmp___15 ;
   char *new_pool ;
   int tmp___16 ;
   void *tmp___17 ;
   void *tmp___18 ;
   int tmp___19 ;
 
   {
   tmp = __builtin_alloca((unsigned long )fname_len + sizeof(aliasfile));
   full_fname = (char *)tmp;
   memcpy((void * __restrict  )full_fname, (void const   * __restrict  )fname, (size_t )fname_len);
   memcpy((void * __restrict  )(full_fname + fname_len), (void const   * __restrict  )(aliasfile),
          sizeof(aliasfile));
   fp = fopen((char const   * __restrict  )full_fname, (char const   * __restrict  )"r");
   if ((unsigned long )fp == (unsigned long )((void *)0)) {
     return ((size_t )0);
   }
   added = (size_t )0;
   while (1) {
     tmp___19 = feof(fp);
     if (tmp___19) {
       break;
     }
     tmp___0 = fgets((char * __restrict  )((char *)(buf___1)), (int )sizeof(buf___1),
                     (FILE * __restrict  )fp);
     if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
       break;
     }
     tmp___3 = strchr((char const   *)((char *)(buf___1)), '\n');
     if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
       while (1) {
         tmp___1 = fgets((char * __restrict  )(altbuf), (int )sizeof(altbuf), (FILE * __restrict  )fp);
         if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
           break;
         }
         tmp___2 = strchr((char const   *)(altbuf), '\n');
         if (! ((unsigned long )tmp___2 == (unsigned long )((void *)0))) {
           break;
         }
       }
     }
     cp = buf___1;
     while (1) {
       tmp___4 = __ctype_b_loc();
       if (! ((int const   )*(*tmp___4 + (int )*(cp + 0)) & 8192)) {
         break;
       }
       cp ++;
     }
     if ((int )*(cp + 0) != 0) {
       if ((int )*(cp + 0) != 35) {
         tmp___5 = cp;
         cp ++;
         alias = tmp___5;
         while (1) {
           if ((int )*(cp + 0) != 0) {
             tmp___6 = __ctype_b_loc();
             if ((int const   )*(*tmp___6 + (int )*(cp + 0)) & 8192) {
               break;
             }
           } else {
             break;
           }
           cp ++;
         }
         if ((int )*(cp + 0) != 0) {
           tmp___7 = cp;
           cp ++;
           *tmp___7 = (unsigned char )'\000';
         }
         while (1) {
           tmp___8 = __ctype_b_loc();
           if (! ((int const   )*(*tmp___8 + (int )*(cp + 0)) & 8192)) {
             break;
           }
           cp ++;
         }
         if ((int )*(cp + 0) != 0) {
           tmp___9 = cp;
           cp ++;
           value = tmp___9;
           while (1) {
             if ((int )*(cp + 0) != 0) {
               tmp___10 = __ctype_b_loc();
               if ((int const   )*(*tmp___10 + (int )*(cp + 0)) & 8192) {
                 break;
               }
             } else {
               break;
             }
             cp ++;
           }
           if ((int )*(cp + 0) == 10) {
             tmp___11 = cp;
             cp ++;
             *tmp___11 = (unsigned char )'\000';
             *cp = (unsigned char )'\n';
           } else
           if ((int )*(cp + 0) != 0) {
             tmp___12 = cp;
             cp ++;
             *tmp___12 = (unsigned char )'\000';
           }
           if (nmap >= maxmap) {
             extend_alias_table();
           }
           tmp___13 = strlen((char const   *)((char *)alias));
           alias_len = tmp___13 + 1UL;
           tmp___14 = strlen((char const   *)((char *)value));
           value_len = tmp___14 + 1UL;
           if ((string_space_act + alias_len) + value_len > string_space_max) {
             if (alias_len + value_len > 1024UL) {
               tmp___15 = alias_len + value_len;
             } else {
               tmp___15 = (size_t )1024;
             }
             new_size = string_space_max + tmp___15;
             tmp___16 = (int )realloc(string_space, new_size);
             new_pool = (char *)tmp___16;
             if ((unsigned long )new_pool == (unsigned long )((void *)0)) {
               return (added);
             }
             string_space = new_pool;
             string_space_max = new_size;
           }
           tmp___17 = memcpy((void * __restrict  )(string_space + string_space_act),
                             (void const   * __restrict  )alias, alias_len);
           (map + nmap)->alias = (char const   *)tmp___17;
           string_space_act += alias_len;
           tmp___18 = memcpy((void * __restrict  )(string_space + string_space_act),
                             (void const   * __restrict  )value, value_len);
           (map + nmap)->value = (char const   *)tmp___18;
           string_space_act += value_len;
           nmap ++;
           added ++;
         }
       }
     }
   }
   fclose(fp);
   if (added > 0UL) {
     qsort(map, nmap, sizeof(struct alias_map ), (int (*)(void const   * , void const   * ))(& alias_compare));
   }
   return (added);
 }
 }
 static void extend_alias_table(void) 
 { 
   size_t new_size ;
   struct alias_map *new_map ;
   int tmp ;
 
   {
   if (maxmap == 0UL) {
     new_size = (size_t )100;
   } else {
     new_size = 2UL * maxmap;
   }
   tmp = (int )realloc(map, new_size * sizeof(struct alias_map ));
   new_map = (struct alias_map *)tmp;
   if ((unsigned long )new_map == (unsigned long )((void *)0)) {
     return;
   }
   map = new_map;
   maxmap = new_size;
   return;
 }
 }
 static int alias_compare(struct alias_map  const  *map1 , struct alias_map  const  *map2 ) 
 { 
   unsigned char const   *p1 ;
   unsigned char const   *p2 ;
   unsigned char c1 ;
   unsigned char c2 ;
   int tmp___0 ;
   unsigned short const   **tmp___1 ;
   int tmp___3 ;
   unsigned short const   **tmp___4 ;
 
   {
   p1 = (unsigned char const   *)map1->alias;
   p2 = (unsigned char const   *)map2->alias;
   if ((unsigned long )p1 == (unsigned long )p2) {
     return (0);
   }
   while (1) {
     tmp___1 = __ctype_b_loc();
     if ((int const   )*(*tmp___1 + (int )*p1) & 256) {
       tmp___0 = tolower((int )*p1);
       c1 = (unsigned char )tmp___0;
     } else {
       c1 = (unsigned char )*p1;
     }
     tmp___4 = __ctype_b_loc();
     if ((int const   )*(*tmp___4 + (int )*p2) & 256) {
       tmp___3 = tolower((int )*p2);
       c2 = (unsigned char )tmp___3;
     } else {
       c2 = (unsigned char )*p2;
     }
     if ((int )c1 == 0) {
       break;
     }
     p1 ++;
     p2 ++;
     if (! ((int )c1 == (int )c2)) {
       break;
     }
   }
   return ((int )c1 - (int )c2);
 }
 }
 char *gettext(char const   *msgid ) ;
 char *dgettext(char const   *domainname , char const   *msgid ) ;
 char *dcgettext__(char const   *domainname , char const   *msgid , int category ) ;
 static struct loaded_l10nfile *_nl_loaded_domains  ;
 static struct loaded_l10nfile *_nl_find_domain(char const   *dirname , char *locale ,
                                                char const   *domainname ) 
 { 
   struct loaded_l10nfile *retval ;
   char const   *language ;
   char const   *modifier ;
   char const   *territory ;
   char const   *codeset ;
   char const   *normalized_codeset ;
   char const   *special ;
   char const   *sponsor ;
   char const   *revision ;
   char const   *alias_value ;
   int mask ;
   size_t tmp ;
   int cnt ;
   struct loaded_l10nfile *tmp___0 ;
   size_t tmp___1 ;
   int cnt___0 ;
 
   {
   tmp = strlen(dirname);
   retval = _nl_make_l10nflist(& _nl_loaded_domains, dirname, tmp + 1UL, 0, (char const   *)locale,
                               (char const   *)((void *)0), (char const   *)((void *)0),
                               (char const   *)((void *)0), (char const   *)((void *)0),
                               (char const   *)((void *)0), (char const   *)((void *)0),
                               (char const   *)((void *)0), domainname, 0);
   if ((unsigned long )retval != (unsigned long )((void *)0)) {
     if (retval->decided == 0) {
       _nl_load_domain(retval);
     }
     if ((unsigned long )retval->data != (unsigned long )((void *)0)) {
       return (retval);
     }
     cnt = 0;
     while ((unsigned long )retval->successor[cnt] != (unsigned long )((void *)0)) {
       if ((retval->successor[cnt])->decided == 0) {
         _nl_load_domain(retval->successor[cnt]);
       }
       if ((unsigned long )(retval->successor[cnt])->data != (unsigned long )((void *)0)) {
         break;
       }
       cnt ++;
     }
     if (cnt >= 0) {
       tmp___0 = retval;
     } else {
       tmp___0 = (struct loaded_l10nfile *)((void *)0);
     }
     return (tmp___0);
   }
   alias_value = _nl_expand_alias((char const   *)locale);
   if ((unsigned long )alias_value != (unsigned long )((void *)0)) {
     locale = strdup(alias_value);
     if ((unsigned long )locale == (unsigned long )((void *)0)) {
       return ((struct loaded_l10nfile *)((void *)0));
     }
   }
   mask = _nl_explode_name(locale, & language, & modifier, & territory, & codeset,
                           & normalized_codeset, & special, & sponsor, & revision);
   tmp___1 = strlen(dirname);
   retval = _nl_make_l10nflist(& _nl_loaded_domains, dirname, tmp___1 + 1UL, mask,
                               language, territory, codeset, normalized_codeset, modifier,
                               special, sponsor, revision, domainname, 1);
   if ((unsigned long )retval == (unsigned long )((void *)0)) {
     return ((struct loaded_l10nfile *)((void *)0));
   }
   if (retval->decided == 0) {
     _nl_load_domain(retval);
   }
   if ((unsigned long )retval->data == (unsigned long )((void *)0)) {
     cnt___0 = 0;
     while ((unsigned long )retval->successor[cnt___0] != (unsigned long )((void *)0)) {
       if ((retval->successor[cnt___0])->decided == 0) {
         _nl_load_domain(retval->successor[cnt___0]);
       }
       if ((unsigned long )(retval->successor[cnt___0])->data != (unsigned long )((void *)0)) {
         break;
       }
       cnt___0 ++;
     }
   }
   if ((unsigned long )alias_value != (unsigned long )((void *)0)) {
     free(locale);
   }
   return (retval);
 }
 }
 __inline static unsigned long hash_string(char const   *str_param ) ;
 __inline static unsigned long hash_string(char const   *str_param ) 
 { 
   unsigned long hval ;
   unsigned long g ;
   char const   *str ;
   char const   *tmp ;
 
   {
   str = str_param;
   hval = 0UL;
   while ((int const   )*str != 0) {
     hval <<= 4;
     tmp = str;
     str ++;
     hval += (unsigned long )*tmp;
     g = hval & (15UL << 28);
     if (g != 0UL) {
       hval ^= g >> 24;
       hval ^= g;
     }
   }
   return (hval);
 }
 }
 static char const   _nl_default_default_domain[9]  = 
   {      (char const   )'m',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
         (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )'s', 
         (char const   )'\000'};
 static char const   *_nl_current_default_domain  =    _nl_default_default_domain;
 static char const   _nl_default_dirname[24]  = 
   {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
         (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
         (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'s', 
         (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
         (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
         (char const   )'a',      (char const   )'l',      (char const   )'e',      (char const   )'\000'};
 static struct binding *_nl_domain_bindings  ;
 static char *find_msg(struct loaded_l10nfile *domain_file , char const   *msgid ) ;
 static char const   *category_to_name(int category ) ;
 static char const   *guess_category_value(int category , char const   *categoryname ) ;
 char *dcgettext__(char const   *domainname , char const   *msgid , int category ) 
 { 
   struct loaded_l10nfile *domain ;
   struct binding *binding ;
   char const   *categoryname ;
   char const   *categoryvalue ;
   char *dirname ;
   char *xdomainname ;
   char *single_locale ;
   char *retval ;
   int saved_errno ;
   int *tmp ;
   int compare ;
   int tmp___0 ;
   size_t dirname_len ;
   size_t tmp___1 ;
   size_t path_max ;
   char *ret ;
   void *tmp___2 ;
   int *tmp___3 ;
   void *tmp___4 ;
   int *tmp___5 ;
   int *tmp___6 ;
   int *tmp___7 ;
   char *tmp___8 ;
   char *tmp___9 ;
   size_t tmp___10 ;
   size_t tmp___11 ;
   void *tmp___12 ;
   char *tmp___13 ;
   char *tmp___14 ;
   char *tmp___15 ;
   size_t tmp___16 ;
   void *tmp___17 ;
   char *cp ;
   char *tmp___18 ;
   char const   *tmp___19 ;
   int *tmp___20 ;
   int tmp___21 ;
   int tmp___22 ;
   int cnt ;
   int *tmp___23 ;
 
   {
   tmp = __errno_location();
   saved_errno = *tmp;
   if ((unsigned long )msgid == (unsigned long )((void *)0)) {
     return ((char *)((void *)0));
   }
   if ((unsigned long )domainname == (unsigned long )((void *)0)) {
     domainname = _nl_current_default_domain;
   }
   binding = _nl_domain_bindings;
   while ((unsigned long )binding != (unsigned long )((void *)0)) {
     tmp___0 = strcmp(domainname, (char const   *)binding->domainname);
     compare = tmp___0;
     if (compare == 0) {
       break;
     }
     if (compare < 0) {
       binding = (struct binding *)((void *)0);
       break;
     }
     binding = binding->next;
   }
   if ((unsigned long )binding == (unsigned long )((void *)0)) {
     dirname = (char *)(_nl_default_dirname);
   } else
   if ((int )*(binding->dirname + 0) == 47) {
     dirname = binding->dirname;
   } else {
     tmp___1 = strlen((char const   *)binding->dirname);
     dirname_len = tmp___1 + 1UL;
     path_max = (size_t )4096U;
     path_max += 2UL;
     tmp___2 = __builtin_alloca(path_max + dirname_len);
     dirname = (char *)tmp___2;
     tmp___3 = __errno_location();
     *tmp___3 = 0;
     while (1) {
       ret = getcwd(dirname, path_max);
       if ((unsigned long )ret == (unsigned long )((void *)0)) {
         tmp___6 = __errno_location();
         if (! (*tmp___6 == 34)) {
           break;
         }
       } else {
         break;
       }
       path_max += 32UL;
       tmp___4 = __builtin_alloca(path_max + dirname_len);
       dirname = (char *)tmp___4;
       tmp___5 = __errno_location();
       *tmp___5 = 0;
     }
     if ((unsigned long )ret == (unsigned long )((void *)0)) {
       tmp___7 = __errno_location();
       *tmp___7 = saved_errno;
       return ((char *)msgid);
     }
     tmp___8 = strchr((char const   *)dirname, '\000');
     tmp___9 = stpcpy((char * __restrict  )tmp___8, (char const   * __restrict  )"/");
     stpcpy((char * __restrict  )tmp___9, (char const   * __restrict  )binding->dirname);
   }
   categoryname = category_to_name(category);
   categoryvalue = guess_category_value(category, categoryname);
   tmp___10 = strlen(categoryname);
   tmp___11 = strlen(domainname);
   tmp___12 = __builtin_alloca((tmp___10 + tmp___11) + 5UL);
   xdomainname = (char *)tmp___12;
   tmp___13 = stpcpy((char * __restrict  )xdomainname, (char const   * __restrict  )categoryname);
   tmp___14 = stpcpy((char * __restrict  )tmp___13, (char const   * __restrict  )"/");
   tmp___15 = stpcpy((char * __restrict  )tmp___14, (char const   * __restrict  )domainname);
   stpcpy((char * __restrict  )tmp___15, (char const   * __restrict  )".mo");
   tmp___16 = strlen(categoryvalue);
   tmp___17 = __builtin_alloca(tmp___16 + 1UL);
   single_locale = (char *)tmp___17;
   while (1) {
     while (1) {
       if ((int const   )*(categoryvalue + 0) != 0) {
         if (! ((int const   )*(categoryvalue + 0) == 58)) {
           break;
         }
       } else {
         break;
       }
       categoryvalue ++;
     }
     if ((int const   )*(categoryvalue + 0) == 0) {
       *(single_locale + 0) = (char )'C';
       *(single_locale + 1) = (char )'\000';
     } else {
       cp = single_locale;
       while (1) {
         if ((int const   )*(categoryvalue + 0) != 0) {
           if (! ((int const   )*(categoryvalue + 0) != 58)) {
             break;
           }
         } else {
           break;
         }
         tmp___18 = cp;
         cp ++;
         tmp___19 = categoryvalue;
         categoryvalue ++;
         *tmp___18 = (char )*tmp___19;
       }
       *cp = (char )'\000';
     }
     tmp___21 = strcmp((char const   *)single_locale, "C");
     if (tmp___21 == 0) {
       tmp___20 = __errno_location();
       *tmp___20 = saved_errno;
       return ((char *)msgid);
     } else {
       tmp___22 = strcmp((char const   *)single_locale, "POSIX");
       if (tmp___22 == 0) {
         tmp___20 = __errno_location();
         *tmp___20 = saved_errno;
         return ((char *)msgid);
       }
     }
     domain = _nl_find_domain((char const   *)dirname, single_locale, (char const   *)xdomainname);
     if ((unsigned long )domain != (unsigned long )((void *)0)) {
       retval = find_msg(domain, msgid);
       if ((unsigned long )retval == (unsigned long )((void *)0)) {
         cnt = 0;
         while ((unsigned long )domain->successor[cnt] != (unsigned long )((void *)0)) {
           retval = find_msg(domain->successor[cnt], msgid);
           if ((unsigned long )retval != (unsigned long )((void *)0)) {
             break;
           }
           cnt ++;
         }
       }
       if ((unsigned long )retval != (unsigned long )((void *)0)) {
         tmp___23 = __errno_location();
         *tmp___23 = saved_errno;
         return (retval);
       }
     }
   }
 }
 }
 static char *find_msg(struct loaded_l10nfile *domain_file , char const   *msgid ) 
 { 
   size_t top ;
   size_t act ;
   size_t bottom ;
   struct loaded_domain *domain ;
   nls_uint32 len ;
   size_t tmp ;
   nls_uint32 hash_val ;
   unsigned long tmp___0 ;
   nls_uint32 idx ;
   nls_uint32 incr ;
   nls_uint32 nstr ;
   nls_uint32 tmp___1 ;
   nls_uint32 tmp___2 ;
   nls_uint32 tmp___3 ;
   nls_uint32 tmp___4 ;
   nls_uint32 tmp___5 ;
   nls_uint32 tmp___6 ;
   nls_uint32 tmp___7 ;
   nls_uint32 tmp___8 ;
   int tmp___9 ;
   nls_uint32 tmp___10 ;
   nls_uint32 tmp___11 ;
   nls_uint32 tmp___12 ;
   nls_uint32 tmp___13 ;
   nls_uint32 tmp___14 ;
   nls_uint32 tmp___15 ;
   nls_uint32 tmp___16 ;
   int tmp___17 ;
   int cmp_val ;
   nls_uint32 tmp___18 ;
   nls_uint32 tmp___19 ;
   nls_uint32 tmp___20 ;
   nls_uint32 tmp___21 ;
   char *tmp___22 ;
 
   {
   if (domain_file->decided == 0) {
     _nl_load_domain(domain_file);
   }
   if ((unsigned long )domain_file->data == (unsigned long )((void *)0)) {
     return ((char *)((void *)0));
   }
   domain = (struct loaded_domain *)domain_file->data;
   if (domain->hash_size > 2U) {
     if ((unsigned long )domain->hash_tab != (unsigned long )((void *)0)) {
       tmp = strlen(msgid);
       len = (nls_uint32 )tmp;
       tmp___0 = hash_string(msgid);
       hash_val = (nls_uint32 )tmp___0;
       idx = hash_val % domain->hash_size;
       incr = 1U + hash_val % (domain->hash_size - 2U);
       if (domain->must_swap) {
         tmp___1 = SWAP(*(domain->hash_tab + idx));
         tmp___2 = tmp___1;
       } else {
         tmp___2 = *(domain->hash_tab + idx);
       }
       nstr = tmp___2;
       if (nstr == 0U) {
         return ((char *)((void *)0));
       }
       if (domain->must_swap) {
         tmp___5 = SWAP((domain->orig_tab + (nstr - 1U))->length);
         tmp___6 = tmp___5;
       } else {
         tmp___6 = (domain->orig_tab + (nstr - 1U))->length;
       }
       if (tmp___6 == len) {
         if (domain->must_swap) {
           tmp___7 = SWAP((domain->orig_tab + (nstr - 1U))->offset);
           tmp___8 = tmp___7;
         } else {
           tmp___8 = (domain->orig_tab + (nstr - 1U))->offset;
         }
         tmp___9 = strcmp(msgid, domain->data + tmp___8);
         if (tmp___9 == 0) {
           if (domain->must_swap) {
             tmp___3 = SWAP((domain->trans_tab + (nstr - 1U))->offset);
             tmp___4 = tmp___3;
           } else {
             tmp___4 = (domain->trans_tab + (nstr - 1U))->offset;
           }
           return ((char *)domain->data + tmp___4);
         }
       }
       while (1) {
         if (idx >= domain->hash_size - incr) {
           idx -= domain->hash_size - incr;
         } else {
           idx += incr;
         }
         if (domain->must_swap) {
           tmp___10 = SWAP(*(domain->hash_tab + idx));
           nstr = tmp___10;
         } else {
           nstr = *(domain->hash_tab + idx);
         }
         if (nstr == 0U) {
           return ((char *)((void *)0));
         }
         if (domain->must_swap) {
           tmp___13 = SWAP((domain->orig_tab + (nstr - 1U))->length);
           tmp___14 = tmp___13;
         } else {
           tmp___14 = (domain->orig_tab + (nstr - 1U))->length;
         }
         if (tmp___14 == len) {
           if (domain->must_swap) {
             tmp___15 = SWAP((domain->orig_tab + (nstr - 1U))->offset);
             tmp___16 = tmp___15;
           } else {
             tmp___16 = (domain->orig_tab + (nstr - 1U))->offset;
           }
           tmp___17 = strcmp(msgid, domain->data + tmp___16);
           if (tmp___17 == 0) {
             if (domain->must_swap) {
               tmp___11 = SWAP((domain->trans_tab + (nstr - 1U))->offset);
               tmp___12 = tmp___11;
             } else {
               tmp___12 = (domain->trans_tab + (nstr - 1U))->offset;
             }
             return ((char *)domain->data + tmp___12);
           }
         }
       }
     }
   }
   bottom = (size_t )0;
   top = (size_t )domain->nstrings;
   while (bottom < top) {
     act = (bottom + top) / 2UL;
     if (domain->must_swap) {
       tmp___18 = SWAP((domain->orig_tab + act)->offset);
       tmp___19 = tmp___18;
     } else {
       tmp___19 = (domain->orig_tab + act)->offset;
     }
     cmp_val = strcmp(msgid, domain->data + tmp___19);
     if (cmp_val < 0) {
       top = act;
     } else
     if (cmp_val > 0) {
       bottom = act + 1UL;
     } else {
       break;
     }
   }
   if (bottom >= top) {
     tmp___22 = (char *)((void *)0);
   } else {
     if (domain->must_swap) {
       tmp___20 = SWAP((domain->trans_tab + act)->offset);
       tmp___21 = tmp___20;
     } else {
       tmp___21 = (domain->trans_tab + act)->offset;
     }
     tmp___22 = (char *)domain->data + tmp___21;
   }
   return (tmp___22);
 }
 }
 static char const   *category_to_name(int category ) 
 { 
   char const   *retval ;
 
   {
   switch (category) {
   case 3: 
   retval = "LC_COLLATE";
   break;
   case 0: 
   retval = "LC_CTYPE";
   break;
   case 4: 
   retval = "LC_MONETARY";
   break;
   case 1: 
   retval = "LC_NUMERIC";
   break;
   case 2: 
   retval = "LC_TIME";
   break;
   case 5: 
   retval = "LC_MESSAGES";
   break;
   case 6: 
   retval = "LC_ALL";
   break;
   default: 
   retval = "LC_XXX";
   }
   return (retval);
 }
 }
 static char const   *guess_category_value(int category , char const   *categoryname ) 
 { 
   char const   *retval ;
   int tmp ;
   int tmp___0 ;
   int tmp___1 ;
   int tmp___2 ;
 
   {
   tmp = (int )getenv("LANGUAGE");
   retval = (char const   *)tmp;
   if ((unsigned long )retval != (unsigned long )((void *)0)) {
     if ((int const   )*(retval + 0) != 0) {
       return (retval);
     }
   }
   tmp___0 = (int )getenv("LC_ALL");
   retval = (char const   *)tmp___0;
   if ((unsigned long )retval != (unsigned long )((void *)0)) {
     if ((int const   )*(retval + 0) != 0) {
       return (retval);
     }
   }
   tmp___1 = (int )getenv(categoryname);
   retval = (char const   *)tmp___1;
   if ((unsigned long )retval != (unsigned long )((void *)0)) {
     if ((int const   )*(retval + 0) != 0) {
       return (retval);
     }
   }
   tmp___2 = (int )getenv("LANG");
   retval = (char const   *)tmp___2;
   if ((unsigned long )retval != (unsigned long )((void *)0)) {
     if ((int const   )*(retval + 0) != 0) {
       return (retval);
     }
   }
   return ("C");
 }
 }
 static char *bindtextdomain__(char const   *domainname , char const   *dirname ) 
 { 
   struct binding *binding ;
   int compare ;
   int tmp ;
   char *tmp___0 ;
   char *new_dirname ;
   int tmp___1 ;
   int tmp___2 ;
   struct binding *new_binding ;
   int tmp___3 ;
   int tmp___4 ;
   int tmp___5 ;
   int tmp___6 ;
 
   {
   if ((unsigned long )domainname == (unsigned long )((void *)0)) {
     return ((char *)((void *)0));
   } else
   if ((int const   )*(domainname + 0) == 0) {
     return ((char *)((void *)0));
   }
   binding = _nl_domain_bindings;
   while ((unsigned long )binding != (unsigned long )((void *)0)) {
     tmp = strcmp(domainname, (char const   *)binding->domainname);
     compare = tmp;
     if (compare == 0) {
       break;
     }
     if (compare < 0) {
       binding = (struct binding *)((void *)0);
       break;
     }
     binding = binding->next;
   }
   if ((unsigned long )dirname == (unsigned long )((void *)0)) {
     if ((unsigned long )binding == (unsigned long )((void *)0)) {
       tmp___0 = (char *)(_nl_default_dirname);
     } else {
       tmp___0 = binding->dirname;
     }
     return (tmp___0);
   }
   if ((unsigned long )binding != (unsigned long )((void *)0)) {
     tmp___2 = strcmp(dirname, (char const   *)binding->dirname);
     if (tmp___2 != 0) {
       tmp___1 = strcmp(dirname, _nl_default_dirname);
       if (tmp___1 == 0) {
         new_dirname = (char *)(_nl_default_dirname);
       } else {
         new_dirname = strdup(dirname);
         if ((unsigned long )new_dirname == (unsigned long )((void *)0)) {
           return ((char *)((void *)0));
         }
       }
       if ((unsigned long )binding->dirname != (unsigned long )(_nl_default_dirname)) {
         free(binding->dirname);
       }
       binding->dirname = new_dirname;
     }
   } else {
     tmp___3 = (int )malloc(sizeof(*new_binding));
     new_binding = (struct binding *)tmp___3;
     if ((unsigned long )new_binding == (unsigned long )((void *)0)) {
       return ((char *)((void *)0));
     }
     new_binding->domainname = strdup(domainname);
     if ((unsigned long )new_binding->domainname == (unsigned long )((void *)0)) {
       return ((char *)((void *)0));
     }
     tmp___4 = strcmp(dirname, _nl_default_dirname);
     if (tmp___4 == 0) {
       new_binding->dirname = (char *)(_nl_default_dirname);
     } else {
       new_binding->dirname = strdup(dirname);
       if ((unsigned long )new_binding->dirname == (unsigned long )((void *)0)) {
         return ((char *)((void *)0));
       }
     }
     if ((unsigned long )_nl_domain_bindings == (unsigned long )((void *)0)) {
       new_binding->next = _nl_domain_bindings;
       _nl_domain_bindings = new_binding;
     } else {
       tmp___6 = strcmp(domainname, (char const   *)_nl_domain_bindings->domainname);
       if (tmp___6 < 0) {
         new_binding->next = _nl_domain_bindings;
         _nl_domain_bindings = new_binding;
       } else {
         binding = _nl_domain_bindings;
         while (1) {
           if ((unsigned long )binding->next != (unsigned long )((void *)0)) {
             tmp___5 = strcmp(domainname, (char const   *)(binding->next)->domainname);
             if (! (tmp___5 > 0)) {
               break;
             }
           } else {
             break;
           }
           binding = binding->next;
         }
         new_binding->next = binding->next;
         binding->next = new_binding;
       }
     }
     binding = new_binding;
   }
   return (binding->dirname);
 }
 }
 static char *dgettext__(char const   *domainname , char const   *msgid ) 
 { 
   char *tmp ;
 
   {
   tmp = dcgettext__(domainname, msgid, 5);
   return (tmp);
 }
 }
 static char *gettext__(char const   *msgid ) 
 { 
   char *tmp ;
 
   {
   tmp = dgettext__((char const   *)((void *)0), msgid);
   return (tmp);
 }
 }
 static char *textdomain__(char const   *domainname ) 
 { 
   char *old ;
   char *tmp ;
   int tmp___0 ;
 
   {
   if ((unsigned long )domainname == (unsigned long )((void *)0)) {
     return ((char *)_nl_current_default_domain);
   }
   old = (char *)_nl_current_default_domain;
   if ((int const   )*(domainname + 0) == 0) {
     _nl_current_default_domain = _nl_default_default_domain;
   } else {
     tmp___0 = strcmp(domainname, _nl_default_default_domain);
     if (tmp___0 == 0) {
       _nl_current_default_domain = _nl_default_default_domain;
     } else {
       tmp = strdup(domainname);
       _nl_current_default_domain = (char const   *)tmp;
     }
   }
   if ((unsigned long )old != (unsigned long )(_nl_default_default_domain)) {
     free(old);
   }
   return ((char *)_nl_current_default_domain);
 }
 }
 char *bindtextdomain(char const   *domainname , char const   *dirname ) 
 { 
   char *tmp ;
 
   {
   tmp = bindtextdomain__(domainname, dirname);
   return (tmp);
 }
 }
 char *dcgettext(char const   *domainname , char const   *msgid , int category ) 
 { 
   char *tmp ;
 
   {
   tmp = dcgettext__(domainname, msgid, category);
   return (tmp);
 }
 }
 char *dgettext(char const   *domainname , char const   *msgid ) 
 { 
   char *tmp ;
 
   {
   tmp = dgettext__(domainname, msgid);
   return (tmp);
 }
 }
 char *gettext(char const   *msgid ) 
 { 
   char *tmp ;
 
   {
   tmp = gettext__(msgid);
   return (tmp);
 }
 }
 char *textdomain(char const   *domainname ) 
 { 
   char *tmp ;
 
   {
   tmp = textdomain__(domainname);
   return (tmp);
 }
 }
