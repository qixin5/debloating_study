/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/6/include/stddef.h"
typedef unsigned long size_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 366 "make.h"
struct floc {
   char *filenm ;
   unsigned long lineno ;
};
#line 25 "filedef.h"
struct dep;
#line 25
struct commands;
#line 25
struct variable_set_list;
#line 25
enum __anonenum_command_state_55 {
    cs_not_started = 0,
    cs_deps_running = 1,
    cs_running = 2,
    cs_finished = 3
} ;
#line 25 "filedef.h"
struct file {
   struct file *next ;
   char *name ;
   char *hname ;
   char *vpath ;
   struct dep *deps ;
   struct commands *cmds ;
   int command_flags ;
   char *stem ;
   struct dep *also_make ;
   uintmax_t last_mtime ;
   uintmax_t mtime_before_update ;
   struct file *prev ;
   struct file *renamed ;
   struct variable_set_list *variables ;
   struct variable_set_list *pat_variables ;
   struct file *parent ;
   struct file *double_colon ;
   short update_status ;
   enum __anonenum_command_state_55 command_state : 2 ;
   unsigned int precious : 1 ;
   unsigned int tried_implicit : 1 ;
   unsigned int updating : 1 ;
   unsigned int updated : 1 ;
   unsigned int is_target : 1 ;
   unsigned int cmd_target : 1 ;
   unsigned int phony : 1 ;
   unsigned int intermediate : 1 ;
   unsigned int secondary : 1 ;
   unsigned int dontcare : 1 ;
   unsigned int ignore_vpath : 1 ;
   unsigned int pat_searched : 1 ;
   unsigned int considered : 1 ;
};
#line 36 "dep.h"
struct dep {
   struct dep *next ;
   char *name ;
   struct file *file ;
   int changed ;
};
#line 47 "dep.h"
struct nameseq {
   struct nameseq *next ;
   char *name ;
};
#line 203 "ar.c"
struct ar_glob_state {
   char *arname ;
   char *pattern ;
   unsigned int size ;
   struct nameseq *chain ;
   unsigned int n ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/ar.h"
struct ar_hdr {
   char ar_name[16] ;
   char ar_date[12] ;
   char ar_uid[6] ;
   char ar_gid[6] ;
   char ar_mode[8] ;
   char ar_size[10] ;
   char ar_fmag[2] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "variable.h"
enum variable_origin {
    o_default = 0,
    o_env = 1,
    o_file = 2,
    o_env_override = 3,
    o_command = 4,
    o_override = 5,
    o_automatic = 6,
    o_invalid = 7
} ;
#line 38
enum variable_export {
    v_export = 0,
    v_noexport = 1,
    v_ifset = 2,
    v_default = 3
} ;
#line 38 "variable.h"
struct variable {
   struct variable *next ;
   char *name ;
   char *value ;
   struct floc fileinfo ;
   enum variable_origin origin : 3 ;
   unsigned int recursive : 1 ;
   unsigned int expanding : 1 ;
   unsigned int per_target : 1 ;
   unsigned int append : 1 ;
   enum variable_export export : 2 ;
};
#line 62 "variable.h"
struct variable_set {
   struct variable **table ;
   unsigned int buckets ;
};
#line 70 "variable.h"
struct variable_set_list {
   struct variable_set_list *next ;
   struct variable_set *set ;
};
#line 25 "job.h"
struct child {
   struct child *next ;
   struct file *file ;
   char **environment ;
   char **command_lines ;
   unsigned int command_line ;
   char *command_ptr ;
   pid_t pid ;
   char *sh_batch_file ;
   unsigned int remote : 1 ;
   unsigned int noerror : 1 ;
   unsigned int good_stdin : 1 ;
   unsigned int deleted : 1 ;
};
#line 23 "commands.h"
struct commands {
   struct floc fileinfo ;
   char *commands ;
   unsigned int ncommand_lines ;
   char **command_lines ;
   char *lines_flags ;
   int any_recurse ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 217 "dir.c"
struct dirfile;
#line 217 "dir.c"
struct directory_contents {
   struct directory_contents *next ;
   dev_t dev ;
   ino_t ino ;
   struct dirfile **files ;
   DIR *dirstream ;
};
#line 251 "dir.c"
struct directory {
   struct directory *next ;
   char *name ;
   struct directory_contents *contents ;
};
#line 276 "dir.c"
struct dirfile {
   struct dirfile *next ;
   char *name ;
   char impossible ;
};
#line 116 "./glob/glob.h"
struct __anonstruct_glob_t_56 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 116 "./glob/glob.h"
typedef struct __anonstruct_glob_t_56 glob_t;
#line 991 "dir.c"
struct dirstream {
   struct directory_contents *contents ;
   unsigned int bucket ;
   struct dirfile *elt ;
};
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 33 "function.c"
struct function_table_entry {
   char const   *name ;
   unsigned char len ;
   unsigned char minimum_args ;
   unsigned char maximum_args ;
   char expand_args ;
   char *(*func_ptr)(char *output , char **argv , char const   *fname ) ;
};
#line 862 "function.c"
struct a_word {
   struct a_word *next ;
   char *str ;
   int matched ;
};
#line 22 "rule.h"
struct rule {
   struct rule *next ;
   char **targets ;
   unsigned int *lens ;
   char **suffixes ;
   struct dep *deps ;
   struct commands *cmds ;
   char terminal ;
   char in_use ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_18 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_19 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_21 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_24 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_23 {
   struct __anonstruct__addr_bnd_24 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_22 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_23 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_25 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_26 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_17 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_18 _kill ;
   struct __anonstruct__timer_19 _timer ;
   struct __anonstruct__rt_20 _rt ;
   struct __anonstruct__sigchld_21 _sigchld ;
   struct __anonstruct__sigfault_22 _sigfault ;
   struct __anonstruct__sigpoll_25 _sigpoll ;
   struct __anonstruct__sigsys_26 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_16 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_17 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_16 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_37 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_37 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 81 "getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 81 "main.c"
enum __anonenum_type_56 {
    flag = 0,
    flag_off = 1,
    string = 2,
    positive_int = 3,
    floating = 4,
    ignore = 5
} ;
#line 81 "main.c"
struct command_switch {
   int c ;
   enum __anonenum_type_56 type ;
   char *value_ptr ;
   unsigned int env : 1 ;
   unsigned int toenv : 1 ;
   unsigned int no_makefile : 1 ;
   char *noarg_value ;
   char *default_value ;
   char *long_name ;
   char *argdesc ;
   char *description ;
};
#line 117 "main.c"
struct stringlist {
   char **list ;
   unsigned int idx ;
   unsigned int max ;
};
#line 390 "main.c"
struct command_variable {
   struct command_variable *next ;
   struct variable *variable ;
};
#line 2397 "main.c"
struct flag {
   struct flag *next ;
   struct command_switch  const  *cs ;
   char *arg ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 637 "misc.c"
enum __anonenum_current_access_55 {
    make = 0,
    user = 1
} ;
#line 34 "rule.h"
struct pattern_var {
   struct pattern_var *next ;
   char *target ;
   unsigned int len ;
   char *suffix ;
   struct variable_set_list *vars ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 49 "read.c"
struct linebuffer {
   unsigned int size ;
   char *buffer ;
};
#line 63
enum make_word_type {
    w_bogus = 0,
    w_eol = 1,
    w_static = 2,
    w_variable = 3,
    w_colon = 4,
    w_dcolon = 5,
    w_semicolon = 6,
    w_comment = 7,
    w_varassign = 8
} ;
#line 78 "read.c"
struct conditionals {
   unsigned int if_cmds ;
   unsigned int allocated ;
   char *ignoring ;
   char *seen_else ;
};
#line 44 "rule.h"
struct pspec {
   char *target ;
   char *dep ;
   char *commands ;
};
#line 60 "signame.c"
struct __anonstruct_num_abbrev_55 {
   int number ;
   char const   *abbrev ;
};
#line 60 "signame.c"
typedef struct __anonstruct_num_abbrev_55 num_abbrev;
#line 588 "variable.c"
struct variable_bucket {
   struct variable_bucket *next ;
   struct variable *variable ;
};
#line 792
enum __anonenum_flavor_56 {
    f_bogus = 0,
    f_simple = 1,
    f_recursive = 2,
    f_append = 3,
    f_conditional = 4
} ;
#line 30 "vpath.c"
struct vpath {
   struct vpath *next ;
   char *pattern ;
   char *percent ;
   unsigned int patlen ;
   char **searchpath ;
   unsigned int maxlen ;
};
#line 111 "gettext.c"
struct loaded_l10nfile {
   char const   *filename ;
   int decided ;
   void const   *data ;
   struct loaded_l10nfile *next ;
   struct loaded_l10nfile *successor[1] ;
};
#line 514
enum __anonenum_syntax_21 {
    undecided = 0,
    xpg = 1,
    cen = 2
} ;
#line 713 "gettext.c"
typedef unsigned int nls_uint32;
#line 729 "gettext.c"
struct mo_file_header {
   nls_uint32 magic ;
   nls_uint32 revision ;
   nls_uint32 nstrings ;
   nls_uint32 orig_tab_offset ;
   nls_uint32 trans_tab_offset ;
   nls_uint32 hash_tab_size ;
   nls_uint32 hash_tab_offset ;
};
#line 747 "gettext.c"
struct string_desc {
   nls_uint32 length ;
   nls_uint32 offset ;
};
#line 802 "gettext.c"
struct loaded_domain {
   char const   *data ;
   int use_mmap ;
   size_t mmap_size ;
   int must_swap ;
   nls_uint32 nstrings ;
   struct string_desc *orig_tab ;
   struct string_desc *trans_tab ;
   nls_uint32 hash_size ;
   nls_uint32 *hash_tab ;
};
#line 815 "gettext.c"
struct binding {
   struct binding *next ;
   char *domainname ;
   char *dirname ;
};
#line 1099 "gettext.c"
struct alias_map {
   char const   *alias ;
   char const   *value ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 1 "ar.o"
#pragma merger("0","/tmp/cil-zTLW9IrK.i","-g,-O0")
#line 101 "gettext.h"
char *dcgettext(char const   *domainname , char const   *msgid , int category ) ;
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 827
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 379 "make.h"
void ( /* format attribute */  error)(struct floc  const  *flocp , char const   *fmt 
                                      , ...) ;
#line 381
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(struct floc  const  *flocp ,
                                                                     char const   *fmt 
                                                                     , ...) ;
#line 392
void perror_with_name(char *str , char *name ) ;
#line 393
char *savestring(char const   *str , unsigned int length___0 ) ;
#line 394
char *concat(char *s1 , char *s2 , char *s3 ) ;
#line 395
char *xmalloc(unsigned int size ) ;
#line 406
int alpha_compare(void const   *v1 , void const   *v2 ) ;
#line 413
int ar_name(char *name ) ;
#line 414
void ar_parse_name(char *name , char **arname_p , char **memname_p ) ;
#line 415
int ar_touch(char *name ) ;
#line 416
time_t ar_member_date(char *name ) ;
#line 420
int file_exists_p(char *name ) ;
#line 108 "filedef.h"
struct file *lookup_file(char *name ) ;
#line 109
struct file *enter_file(char *name ) ;
#line 173
uintmax_t f_mtime(struct file *file , int search ) ;
#line 63 "dep.h"
struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) ;
#line 77 "./glob/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 29 "ar.c"
long ar_scan(char *archive , long (*function)() , long arg ) ;
#line 30
int ar_name_equal(char *name , char *mem , int truncated ) ;
#line 32
int ar_member_touch(char *arname , char *memname ) ;
#line 40 "ar.c"
int ar_name(char *name ) 
{ 
  char *p ;
  char *tmp ;
  char *end ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 44
  tmp = strchr((char const   *)name, '(');
#line 44
  p = tmp;
#line 44
  tmp___0 = strlen((char const   *)name);
#line 44
  end = (name + tmp___0) - 1;
#line 46
  if ((unsigned long )p == (unsigned long )((char *)0)) {
#line 47
    return (0);
  } else
#line 46
  if ((unsigned long )p == (unsigned long )name) {
#line 47
    return (0);
  } else
#line 46
  if ((int )*end != 41) {
#line 47
    return (0);
  }
#line 49
  if ((int )*(p + 1) == 40) {
#line 49
    if ((int )*(end + -1) == 41) {
#line 50
      tmp___1 = dcgettext((char const   *)((void *)0), "attempt to use unsupported feature: `%s\'",
                          5);
#line 50
      fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, name);
    }
  }
#line 52
  return (1);
}
}
#line 60 "ar.c"
void ar_parse_name(char *name , char **arname_p , char **memname_p ) 
{ 
  char *p ;
  char *tmp ;
  char *end ;
  size_t tmp___0 ;

  {
#line 64
  tmp = strchr((char const   *)name, '(');
#line 64
  p = tmp;
#line 64
  tmp___0 = strlen((char const   *)name);
#line 64
  end = (name + tmp___0) - 1;
#line 66
  if ((unsigned long )arname_p != (unsigned long )((char **)0)) {
#line 67
    *arname_p = savestring((char const   *)name, (unsigned int )(p - name));
  }
#line 69
  if ((unsigned long )memname_p != (unsigned long )((char **)0)) {
#line 70
    *memname_p = savestring((char const   *)(p + 1), (unsigned int )(end - (p + 1)));
  }
#line 71
  return;
}
}
#line 73
static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                             long datapos , long size , long date , int uid , int gid ,
                             int mode , char *name ) ;
#line 78 "ar.c"
time_t ar_member_date(char *name ) 
{ 
  char *arname ;
  int arname_used ;
  char *memname ;
  long val ;
  struct file *arfile ;
  int tmp ;
  time_t tmp___0 ;

  {
#line 83
  arname_used = 0;
#line 87
  ar_parse_name(name, & arname, & memname);
#line 98
  arfile = lookup_file(arname);
#line 99
  if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
#line 99
    tmp = file_exists_p(arname);
#line 99
    if (tmp) {
#line 101
      arfile = enter_file(arname);
#line 102
      arname_used = 1;
    }
  }
#line 105
  if ((unsigned long )arfile != (unsigned long )((struct file *)0)) {
#line 106
    f_mtime(arfile, 0);
  }
#line 109
  val = ar_scan(arname, (long (*)())(& ar_member_date_1), (long )memname);
#line 111
  if (! arname_used) {
#line 112
    free((void *)arname);
  }
#line 113
  free((void *)memname);
#line 115
  if (val <= 0L) {
#line 115
    tmp___0 = (time_t )-1;
  } else {
#line 115
    tmp___0 = val;
  }
#line 115
  return (tmp___0);
}
}
#line 121 "ar.c"
static long ar_member_date_1(int desc , char *mem , int truncated , long hdrpos ,
                             long datapos , long size , long date , int uid , int gid ,
                             int mode , char *name ) 
{ 
  long tmp___0 ;
  int tmp___1 ;

  {
#line 131
  tmp___1 = ar_name_equal(name, mem, truncated);
#line 131
  if (tmp___1) {
#line 131
    tmp___0 = date;
  } else {
#line 131
    tmp___0 = 0L;
  }
#line 131
  return (tmp___0);
}
}
#line 145 "ar.c"
int ar_touch(char *name ) 
{ 
  char *arname ;
  char *memname ;
  int arname_used ;
  register int val ;
  struct file *arfile ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 150
  arname_used = 0;
#line 153
  ar_parse_name(name, & arname, & memname);
#line 159
  arfile = lookup_file(arname);
#line 160
  if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
#line 162
    arfile = enter_file(arname);
#line 163
    arname_used = 1;
  }
#line 166
  f_mtime(arfile, 0);
#line 169
  val = 1;
#line 170
  tmp = ar_member_touch(arname, memname);
#line 170
  switch (tmp) {
  case -1: 
#line 173
  tmp___0 = dcgettext((char const   *)((void *)0), "touch: Archive `%s\' does not exist",
                      5);
#line 173
  error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, arname);
#line 174
  break;
  case -2: 
#line 176
  tmp___1 = dcgettext((char const   *)((void *)0), "touch: `%s\' is not a valid archive",
                      5);
#line 176
  error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, arname);
#line 177
  break;
  case -3: 
#line 179
  perror_with_name((char *)"touch: ", arname);
#line 180
  break;
  case 1: 
#line 182
  tmp___2 = dcgettext((char const   *)((void *)0), "touch: Member `%s\' does not exist in `%s\'",
                      5);
#line 182
  error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, memname,
        arname);
#line 184
  break;
  case 0: 
#line 186
  val = 0;
#line 187
  break;
  default: 
#line 189
  tmp___3 = dcgettext((char const   *)((void *)0), "touch: Bad return code from ar_member_touch on `%s\'",
                      5);
#line 189
  error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___3, name);
  }
#line 193
  if (! arname_used) {
#line 194
    free((void *)arname);
  }
#line 195
  free((void *)memname);
#line 197
  return (val);
}
}
#line 215 "ar.c"
static long ar_glob_match(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                          long size , long date , int uid , int gid , int mode , struct ar_glob_state *state ) 
{ 
  struct nameseq *new ;
  char *tmp ;
  int tmp___0 ;

  {
#line 226
  tmp___0 = fnmatch((char const   *)state->pattern, (char const   *)mem, 1 | (1 << 2));
#line 226
  if (tmp___0 == 0) {
#line 229
    tmp = xmalloc(state->size);
#line 229
    new = (struct nameseq *)tmp;
#line 230
    new->name = concat(state->arname, mem, (char *)")");
#line 231
    new->next = state->chain;
#line 232
    state->chain = new;
#line 233
    (state->n) ++;
  }
#line 236
  return (0L);
}
}
#line 241 "ar.c"
static int glob_pattern_p(char const   *pattern , int const   quote ) 
{ 
  register char const   *p ;
  int open___0 ;

  {
#line 247
  open___0 = 0;
#line 249
  p = pattern;
#line 249
  while ((int const   )*p != 0) {
#line 250
    switch ((int const   )*p) {
    case 42: 
    case 63: 
#line 254
    return (1);
    case 92: 
#line 257
    if (quote) {
#line 258
      p ++;
    }
#line 259
    break;
    case 91: 
#line 262
    open___0 = 1;
#line 263
    break;
    case 93: 
#line 266
    if (open___0) {
#line 267
      return (1);
    }
#line 268
    break;
    }
#line 249
    p ++;
  }
#line 271
  return (0);
}
}
#line 277 "ar.c"
struct nameseq *ar_glob(char *arname , char *member_pattern , unsigned int size ) 
{ 
  struct ar_glob_state state ;
  char **names ;
  struct nameseq *n ;
  unsigned int i ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 287
  tmp = glob_pattern_p((char const   *)member_pattern, (int const   )1);
#line 287
  if (! tmp) {
#line 288
    return ((struct nameseq *)0);
  }
#line 292
  tmp___0 = strlen((char const   *)arname);
#line 292
  i = (unsigned int )tmp___0;
#line 293
  tmp___1 = __builtin_alloca((unsigned long )(i + 2U));
#line 293
  state.arname = (char *)tmp___1;
#line 294
  memmove((void *)state.arname, (void const   *)arname, (size_t )i);
#line 295
  *(state.arname + i) = (char )'(';
#line 296
  *(state.arname + (i + 1U)) = (char )'\000';
#line 297
  state.pattern = member_pattern;
#line 298
  state.size = size;
#line 299
  state.chain = (struct nameseq *)0;
#line 300
  state.n = 0U;
#line 301
  ar_scan(arname, (long (*)())(& ar_glob_match), (long )(& state));
#line 303
  if ((unsigned long )state.chain == (unsigned long )((struct nameseq *)0)) {
#line 304
    return ((struct nameseq *)0);
  }
#line 307
  tmp___2 = __builtin_alloca((unsigned long )state.n * sizeof(char *));
#line 307
  names = (char **)tmp___2;
#line 308
  i = 0U;
#line 309
  n = state.chain;
#line 309
  while ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
#line 310
    tmp___3 = i;
#line 310
    i ++;
#line 310
    *(names + tmp___3) = n->name;
#line 309
    n = n->next;
  }
#line 313
  qsort((void *)((char *)names), (size_t )i, sizeof(*names), & alpha_compare);
#line 316
  i = 0U;
#line 317
  n = state.chain;
#line 317
  while ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
#line 318
    tmp___4 = i;
#line 318
    i ++;
#line 318
    n->name = *(names + tmp___4);
#line 317
    n = n->next;
  }
#line 320
  return (state.chain);
}
}
#line 1 "arscan.o"
#pragma merger("0","/tmp/cil-DjIKTYKu.i","-g,-O0")
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 385
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 356
extern int close(int __fd ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 107
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 286 "arscan.c"
long ar_scan(char *archive , long (*function)() , long arg ) 
{ 
  int long_name ;
  char *namemap ;
  register int desc ;
  int tmp ;
  char buf___1[8] ;
  register int nread ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  register long member_offset ;
  register int nread___0 ;
  struct ar_hdr member_header ;
  char namebuf[sizeof(member_header.ar_name) + 1UL] ;
  char *name ;
  int is_namemap ;
  long eltsize ;
  int eltmode ;
  long fnval ;
  __off_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  register char *p ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int namesize ;
  int tmp___9 ;
  void *tmp___10 ;
  ssize_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  char *clear ;
  char *limit ;
  void *tmp___15 ;
  ssize_t tmp___16 ;

  {
#line 299
  long_name = 0;
#line 301
  namemap = (char *)0;
#line 302
  tmp = open((char const   *)archive, 0, 0);
#line 302
  desc = tmp;
#line 303
  if (desc < 0) {
#line 304
    return (-1L);
  }
#line 308
  tmp___0 = read(desc, (void *)(buf___1), (size_t )8);
#line 308
  nread = (int )tmp___0;
#line 309
  if (nread != 8) {
#line 311
    close(desc);
#line 312
    return (-2L);
  } else {
#line 309
    tmp___1 = memcmp((void const   *)(buf___1), (void const   *)"!<arch>\n", (size_t )8);
#line 309
    if (tmp___1) {
#line 311
      close(desc);
#line 312
      return (-2L);
    }
  }
#line 376
  member_offset = 8L;
#line 410
  while (1) {
#line 432
    tmp___2 = lseek(desc, member_offset, 0);
#line 432
    if (tmp___2 < 0L) {
#line 434
      close(desc);
#line 435
      return (-2L);
    }
#line 514
    tmp___3 = read(desc, (void *)((char *)(& member_header)), sizeof(struct ar_hdr ));
#line 514
    nread___0 = (int )tmp___3;
#line 515
    if (nread___0 == 0) {
#line 517
      break;
    }
#line 519
    if ((unsigned long )nread___0 != sizeof(struct ar_hdr )) {
#line 537
      close(desc);
#line 538
      return (-2L);
    } else {
#line 519
      tmp___4 = memcmp((void const   *)(member_header.ar_fmag), (void const   *)"`\n",
                       (size_t )2);
#line 519
      if (tmp___4) {
#line 537
        close(desc);
#line 538
        return (-2L);
      }
    }
#line 541
    name = namebuf;
#line 542
    memmove((void *)name, (void const   *)(member_header.ar_name), sizeof(member_header.ar_name));
#line 544
    p = name + sizeof(member_header.ar_name);
#line 545
    while (1) {
#line 546
      *p = (char )'\000';
#line 545
      if ((unsigned long )p > (unsigned long )name) {
#line 545
        p --;
#line 545
        if (! ((int )*p == 32)) {
#line 545
          break;
        }
      } else {
#line 545
        break;
      }
    }
#line 556
    tmp___5 = strcmp((char const   *)name, "//");
#line 556
    if (tmp___5) {
#line 556
      tmp___6 = strcmp((char const   *)name, "ARFILENAMES/");
#line 556
      if (tmp___6) {
#line 556
        tmp___7 = 0;
      } else {
#line 556
        tmp___7 = 1;
      }
    } else {
#line 556
      tmp___7 = 1;
    }
#line 556
    is_namemap = tmp___7;
#line 560
    if ((int )*p == 47) {
#line 561
      *p = (char )'\000';
    }
#line 569
    if (! is_namemap) {
#line 569
      if ((int )*(name + 0) == 32) {
#line 569
        goto _L___1;
      } else
#line 569
      if ((int )*(name + 0) == 47) {
        _L___1: /* CIL Label */ 
#line 569
        if ((unsigned long )namemap != (unsigned long )((char *)0)) {
#line 573
          tmp___8 = atoi((char const   *)(name + 1));
#line 573
          name = namemap + tmp___8;
#line 574
          long_name = 1;
        } else {
#line 569
          goto _L___0;
        }
      } else {
#line 569
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 576
    if ((int )*(name + 0) == 35) {
#line 576
      if ((int )*(name + 1) == 49) {
#line 576
        if ((int )*(name + 2) == 47) {
#line 580
          tmp___9 = atoi((char const   *)(name + 3));
#line 580
          namesize = tmp___9;
#line 582
          tmp___10 = __builtin_alloca((unsigned long )(namesize + 1));
#line 582
          name = (char *)tmp___10;
#line 583
          tmp___11 = read(desc, (void *)name, (size_t )namesize);
#line 583
          nread___0 = (int )tmp___11;
#line 584
          if (nread___0 != namesize) {
#line 586
            close(desc);
#line 587
            return (-2L);
          }
#line 589
          *(name + namesize) = (char )'\000';
#line 591
          long_name = 1;
        }
      }
    }
#line 597
    sscanf((char const   * __restrict  )(member_header.ar_mode), (char const   * __restrict  )"%o",
           & eltmode);
#line 598
    eltsize = atol((char const   *)(member_header.ar_size));
#line 604
    tmp___12 = atoi((char const   *)(member_header.ar_gid));
#line 604
    tmp___13 = atoi((char const   *)(member_header.ar_uid));
#line 604
    tmp___14 = atol((char const   *)(member_header.ar_date));
#line 604
    fnval = (*function)(desc, name, ! long_name, member_offset, (unsigned long )member_offset + sizeof(struct ar_hdr ),
                        eltsize, tmp___14, tmp___13, tmp___12, eltmode, arg);
#line 620
    if (fnval) {
#line 622
      close(desc);
#line 623
      return (fnval);
    }
#line 648
    if (is_namemap) {
#line 653
      tmp___15 = __builtin_alloca((unsigned long )eltsize);
#line 653
      namemap = (char *)tmp___15;
#line 654
      tmp___16 = read(desc, (void *)namemap, (size_t )eltsize);
#line 654
      nread___0 = (int )tmp___16;
#line 655
      if ((long )nread___0 != eltsize) {
#line 657
        close(desc);
#line 658
        return (-2L);
      }
#line 664
      limit = namemap + eltsize;
#line 665
      clear = namemap;
#line 665
      while ((unsigned long )clear < (unsigned long )limit) {
#line 667
        if ((int )*clear == 10) {
#line 669
          *clear = (char )'\000';
#line 670
          if ((int )*(clear + -1) == 47) {
#line 671
            *(clear + -1) = (char )'\000';
          }
        }
#line 665
        clear ++;
      }
#line 675
      is_namemap = 0;
    }
#line 678
    member_offset = (long )((unsigned long )member_offset + (sizeof(struct ar_hdr ) + (unsigned long )eltsize));
#line 679
    if (member_offset % 2L != 0L) {
#line 680
      member_offset ++;
    }
  }
#line 685
  close(desc);
#line 686
  return (0L);
}
}
#line 694 "arscan.c"
int ar_name_equal(char *name , char *mem , int truncated ) 
{ 
  char *p ;
  struct ar_hdr hdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 701
  p = strrchr((char const   *)name, '/');
#line 702
  if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 703
    name = p + 1;
  }
#line 706
  if (truncated) {
#line 714
    tmp = strncmp((char const   *)name, (char const   *)mem, sizeof(hdr.ar_name) - 1UL);
#line 714
    return (tmp == 0);
  }
#line 722
  tmp___0 = strcmp((char const   *)name, (char const   *)mem);
#line 722
  if (tmp___0) {
#line 722
    tmp___1 = 0;
  } else {
#line 722
    tmp___1 = 1;
  }
#line 722
  return (tmp___1);
}
}
#line 727 "arscan.c"
static long ar_member_pos(int desc , char *mem , int truncated , long hdrpos , long datapos ,
                          long size , long date , int uid , int gid , int mode , char *name ) 
{ 
  int tmp ;

  {
#line 737
  tmp = ar_name_equal(name, mem, truncated);
#line 737
  if (! tmp) {
#line 738
    return (0L);
  }
#line 739
  return (hdrpos);
}
}
#line 749 "arscan.c"
int ar_member_touch(char *arname , char *memname ) 
{ 
  register long pos ;
  long tmp ;
  register int fd ;
  struct ar_hdr ar_hdr ;
  register int i ;
  struct stat statbuf ;
  __off_t tmp___0 ;
  ssize_t tmp___1 ;
  __off_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  __off_t tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 753
  tmp = ar_scan(arname, (long (*)())(& ar_member_pos), (long )memname);
#line 753
  pos = tmp;
#line 759
  if (pos < 0L) {
#line 760
    return ((int )pos);
  }
#line 761
  if (! pos) {
#line 762
    return (1);
  }
#line 764
  fd = open((char const   *)arname, 2, 438);
#line 765
  if (fd < 0) {
#line 766
    return (-3);
  }
#line 768
  tmp___0 = lseek(fd, pos, 0);
#line 768
  if (tmp___0 < 0L) {
#line 769
    goto lose;
  }
#line 770
  tmp___1 = read(fd, (void *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
#line 770
  if (sizeof(struct ar_hdr ) != (unsigned long )tmp___1) {
#line 771
    goto lose;
  }
#line 773
  tmp___2 = lseek(fd, pos, 0);
#line 773
  if (tmp___2 < 0L) {
#line 774
    goto lose;
  }
#line 775
  tmp___3 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
#line 775
  if (sizeof(struct ar_hdr ) != (unsigned long )tmp___3) {
#line 776
    goto lose;
  }
#line 778
  while (1) {
#line 778
    tmp___4 = fstat(fd, & statbuf);
#line 778
    if (tmp___4 < 0) {
#line 778
      tmp___5 = __errno_location();
#line 778
      if (! (*tmp___5 == 4)) {
#line 778
        break;
      }
    } else {
#line 778
      break;
    }
  }
#line 782
  i = 0;
#line 782
  while ((unsigned long )i < sizeof(ar_hdr.ar_date)) {
#line 783
    ar_hdr.ar_date[i] = (char )' ';
#line 782
    i ++;
  }
#line 784
  sprintf((char * __restrict  )(ar_hdr.ar_date), (char const   * __restrict  )"%ld",
          statbuf.st_mtim.tv_sec);
#line 792
  tmp___6 = lseek(fd, pos, 0);
#line 792
  if (tmp___6 < 0L) {
#line 793
    goto lose;
  }
#line 794
  tmp___7 = write(fd, (void const   *)((char *)(& ar_hdr)), sizeof(struct ar_hdr ));
#line 794
  if (sizeof(struct ar_hdr ) != (unsigned long )tmp___7) {
#line 795
    goto lose;
  }
#line 796
  close(fd);
#line 797
  return (0);
  lose: 
#line 800
  tmp___8 = __errno_location();
#line 800
  i = *tmp___8;
#line 801
  close(fd);
#line 802
  tmp___9 = __errno_location();
#line 802
  *tmp___9 = i;
#line 803
  return (-3);
}
}
#line 1 "commands.o"
#pragma merger("0","/tmp/cil-aSzPiRMr.i","-g,-O0")
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 391 "make.h"
 __attribute__((__noreturn__)) void pfatal_with_name(char *name ) ;
#line 396
char *xrealloc(char *ptr , unsigned int size ) ;
#line 403
char *sindex(char const   *big , unsigned int blen , char const   *small , unsigned int slen ) ;
#line 496
int handling_fatal_signal ;
#line 76 "dep.h"
void uniquize_deps(struct dep *chain ) ;
#line 105 "filedef.h"
struct file *default_file ;
#line 110
void remove_intermediates(int sig ) ;
#line 116
void set_command_state(struct file *file , int state ) ;
#line 117
void notice_finished_file(struct file *file ) ;
#line 105 "variable.h"
void initialize_file_variables(struct file *file , int reading ) ;
#line 113
struct variable *define_variable_in_set(char *name , unsigned int length___0 , char *value ,
                                        enum variable_origin origin , int recursive ,
                                        struct variable_set *set , struct floc  const  *flocp ) ;
#line 51 "job.h"
struct child *children ;
#line 53
void new_job(struct file *file ) ;
#line 54
void reap_children(int block , int err ) ;
#line 69
unsigned int job_slots_used ;
#line 39 "commands.h"
void execute_file_commands(struct file *file ) ;
#line 40
void print_commands(struct commands *cmds ) ;
#line 41
void delete_child_targets(struct child *child ) ;
#line 42
void chop_commands(struct commands *cmds ) ;
#line 27 "commands.c"
int remote_kill(int id , int sig ) ;
#line 35 "commands.c"
static void set_file_variables(struct file *file ) 
{ 
  register char *p ;
  char *at ;
  char *percent ;
  char *star ;
  char *less ;
  unsigned int len ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  register struct dep *d ;
  char *name ;
  unsigned int len___0 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  struct file *tmp___7 ;
  unsigned int slen ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  register unsigned int qmark_len ;
  register unsigned int plus_len ;
  char *caret_value ;
  char *plus_value ;
  register char *cp ;
  char *qmark_value ;
  register char *qp ;
  register struct dep *d___0 ;
  unsigned int len___1 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  char *c ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  char *c___0 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 46
  tmp___2 = ar_name(file->name);
#line 46
  if (tmp___2) {
#line 49
    p = strchr((char const   *)file->name, '(');
#line 50
    tmp = __builtin_alloca((unsigned long )((p - file->name) + 1L));
#line 50
    at = (char *)tmp;
#line 51
    memmove((void *)at, (void const   *)file->name, (size_t )(p - file->name));
#line 52
    *(at + (p - file->name)) = (char )'\000';
#line 53
    tmp___0 = strlen((char const   *)(p + 1));
#line 53
    len = (unsigned int )tmp___0;
#line 54
    tmp___1 = __builtin_alloca((unsigned long )len);
#line 54
    percent = (char *)tmp___1;
#line 55
    memmove((void *)percent, (void const   *)(p + 1), (size_t )(len - 1U));
#line 56
    *(percent + (len - 1U)) = (char )'\000';
  } else {
#line 61
    at = file->name;
#line 62
    percent = (char *)"";
  }
#line 66
  if ((unsigned long )file->stem == (unsigned long )((char *)0)) {
#line 76
    tmp___6 = ar_name(file->name);
#line 76
    if (tmp___6) {
#line 78
      tmp___3 = strchr((char const   *)file->name, '(');
#line 78
      name = tmp___3 + 1;
#line 79
      tmp___4 = strlen((char const   *)name);
#line 79
      len___0 = (unsigned int )(tmp___4 - 1UL);
    } else {
#line 84
      name = file->name;
#line 85
      tmp___5 = strlen((char const   *)name);
#line 85
      len___0 = (unsigned int )tmp___5;
    }
#line 88
    tmp___7 = enter_file((char *)".SUFFIXES");
#line 88
    d = tmp___7->deps;
#line 88
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 90
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 90
        tmp___8 = (d->file)->name;
      } else {
#line 90
        tmp___8 = d->name;
      }
#line 90
      tmp___9 = strlen((char const   *)tmp___8);
#line 90
      slen = (unsigned int )tmp___9;
#line 91
      if (len___0 > slen) {
#line 91
        if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 91
          tmp___10 = (d->file)->name;
        } else {
#line 91
          tmp___10 = d->name;
        }
#line 91
        tmp___11 = strncmp((char const   *)tmp___10, (char const   *)(name + (len___0 - slen)),
                           (size_t )slen);
#line 91
        if (tmp___11 == 0) {
#line 93
          file->stem = savestring((char const   *)name, len___0 - slen);
#line 94
          break;
        }
      }
#line 88
      d = d->next;
    }
#line 97
    if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
#line 98
      file->stem = (char *)"";
    }
  }
#line 100
  star = file->stem;
#line 103
  if ((unsigned long )file->deps != (unsigned long )((struct dep *)0)) {
#line 103
    if ((unsigned long )(file->deps)->name == (unsigned long )((char *)0)) {
#line 103
      tmp___12 = ((file->deps)->file)->name;
    } else {
#line 103
      tmp___12 = (file->deps)->name;
    }
#line 103
    less = tmp___12;
  } else {
#line 103
    less = (char *)"";
  }
#line 105
  if ((unsigned long )file->cmds == (unsigned long )default_file->cmds) {
#line 108
    less = at;
  }
#line 115
  define_variable_in_set((char *)"<", 1U, less, (enum variable_origin )6, 0, (file->variables)->set,
                         (struct floc  const  *)((struct floc *)0));
#line 116
  define_variable_in_set((char *)"*", 1U, star, (enum variable_origin )6, 0, (file->variables)->set,
                         (struct floc  const  *)((struct floc *)0));
#line 117
  define_variable_in_set((char *)"@", 1U, at, (enum variable_origin )6, 0, (file->variables)->set,
                         (struct floc  const  *)((struct floc *)0));
#line 118
  define_variable_in_set((char *)"%", 1U, percent, (enum variable_origin )6, 0, (file->variables)->set,
                         (struct floc  const  *)((struct floc *)0));
#line 134
  plus_len = 0U;
#line 135
  d___0 = file->deps;
#line 135
  while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
#line 136
    if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 136
      tmp___13 = (d___0->file)->name;
    } else {
#line 136
      tmp___13 = d___0->name;
    }
#line 136
    tmp___14 = strlen((char const   *)tmp___13);
#line 136
    plus_len = (unsigned int )((size_t )plus_len + (tmp___14 + 1UL));
#line 135
    d___0 = d___0->next;
  }
#line 138
  if (plus_len == 0U) {
#line 138
    len___1 = 1U;
  } else {
#line 138
    len___1 = plus_len;
  }
#line 139
  tmp___15 = __builtin_alloca((unsigned long )len___1);
#line 139
  plus_value = (char *)tmp___15;
#line 139
  cp = plus_value;
#line 141
  qmark_len = plus_len;
#line 142
  d___0 = file->deps;
#line 142
  while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
#line 144
    if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 144
      tmp___16 = (d___0->file)->name;
    } else {
#line 144
      tmp___16 = d___0->name;
    }
#line 144
    c = tmp___16;
#line 147
    tmp___20 = ar_name(c);
#line 147
    if (tmp___20) {
#line 149
      tmp___17 = strchr((char const   *)c, '(');
#line 149
      c = tmp___17 + 1;
#line 150
      tmp___18 = strlen((char const   *)c);
#line 150
      len___1 = (unsigned int )(tmp___18 - 1UL);
    } else {
#line 154
      tmp___19 = strlen((char const   *)c);
#line 154
      len___1 = (unsigned int )tmp___19;
    }
#line 156
    memmove((void *)cp, (void const   *)c, (size_t )len___1);
#line 157
    cp += len___1;
#line 161
    tmp___21 = cp;
#line 161
    cp ++;
#line 161
    *tmp___21 = (char )' ';
#line 163
    if (! d___0->changed) {
#line 164
      qmark_len -= len___1 + 1U;
    }
#line 142
    d___0 = d___0->next;
  }
#line 169
  if ((unsigned long )cp > (unsigned long )plus_value) {
#line 169
    tmp___22 = -1;
  } else {
#line 169
    tmp___22 = 0;
  }
#line 169
  *(cp + tmp___22) = (char )'\000';
#line 170
  define_variable_in_set((char *)"+", 1U, plus_value, (enum variable_origin )6, 0,
                         (file->variables)->set, (struct floc  const  *)((struct floc *)0));
#line 176
  uniquize_deps(file->deps);
#line 180
  caret_value = plus_value;
#line 180
  cp = caret_value;
#line 181
  if (qmark_len == 0U) {
#line 181
    len___1 = 1U;
  } else {
#line 181
    len___1 = qmark_len;
  }
#line 182
  tmp___23 = __builtin_alloca((unsigned long )len___1);
#line 182
  qmark_value = (char *)tmp___23;
#line 182
  qp = qmark_value;
#line 184
  d___0 = file->deps;
#line 184
  while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
#line 186
    if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 186
      tmp___24 = (d___0->file)->name;
    } else {
#line 186
      tmp___24 = d___0->name;
    }
#line 186
    c___0 = tmp___24;
#line 189
    tmp___28 = ar_name(c___0);
#line 189
    if (tmp___28) {
#line 191
      tmp___25 = strchr((char const   *)c___0, '(');
#line 191
      c___0 = tmp___25 + 1;
#line 192
      tmp___26 = strlen((char const   *)c___0);
#line 192
      len___1 = (unsigned int )(tmp___26 - 1UL);
    } else {
#line 196
      tmp___27 = strlen((char const   *)c___0);
#line 196
      len___1 = (unsigned int )tmp___27;
    }
#line 198
    memmove((void *)cp, (void const   *)c___0, (size_t )len___1);
#line 199
    cp += len___1;
#line 203
    tmp___29 = cp;
#line 203
    cp ++;
#line 203
    *tmp___29 = (char )' ';
#line 205
    if (d___0->changed) {
#line 207
      memmove((void *)qp, (void const   *)c___0, (size_t )len___1);
#line 208
      qp += len___1;
#line 212
      tmp___30 = qp;
#line 212
      qp ++;
#line 212
      *tmp___30 = (char )' ';
    }
#line 184
    d___0 = d___0->next;
  }
#line 219
  if ((unsigned long )cp > (unsigned long )caret_value) {
#line 219
    tmp___31 = -1;
  } else {
#line 219
    tmp___31 = 0;
  }
#line 219
  *(cp + tmp___31) = (char )'\000';
#line 220
  define_variable_in_set((char *)"^", 1U, caret_value, (enum variable_origin )6, 0,
                         (file->variables)->set, (struct floc  const  *)((struct floc *)0));
#line 222
  if ((unsigned long )qp > (unsigned long )qmark_value) {
#line 222
    tmp___32 = -1;
  } else {
#line 222
    tmp___32 = 0;
  }
#line 222
  *(qp + tmp___32) = (char )'\000';
#line 223
  define_variable_in_set((char *)"?", 1U, qmark_value, (enum variable_origin )6, 0,
                         (file->variables)->set, (struct floc  const  *)((struct floc *)0));
#line 227
  return;
}
}
#line 232 "commands.c"
void chop_commands(struct commands *cmds ) 
{ 
  register char *p ;
  unsigned int nlines ;
  unsigned int idx ;
  char **lines ;
  char *tmp ;
  char *end ;
  size_t tmp___0 ;
  int backslash ;
  register char *b ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int flags ;
  unsigned short const   **tmp___5 ;
  unsigned int len ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 243
  if (! cmds) {
#line 244
    return;
  } else
#line 243
  if ((unsigned long )cmds->command_lines != (unsigned long )((char **)0)) {
#line 244
    return;
  }
#line 250
  nlines = 5U;
#line 251
  tmp = xmalloc((unsigned int )(5UL * sizeof(char *)));
#line 251
  lines = (char **)tmp;
#line 252
  idx = 0U;
#line 253
  p = cmds->commands;
#line 254
  while ((int )*p != 0) {
#line 256
    end = p;
    find_end: 
#line 258
    end = strchr((char const   *)end, '\n');
#line 259
    if ((unsigned long )end == (unsigned long )((char *)0)) {
#line 260
      tmp___0 = strlen((char const   *)p);
#line 260
      end = p + tmp___0;
    } else
#line 261
    if ((unsigned long )end > (unsigned long )p) {
#line 261
      if ((int )*(end + -1) == 92) {
#line 263
        backslash = 1;
#line 265
        b = end - 2;
#line 265
        while (1) {
#line 265
          if ((unsigned long )b >= (unsigned long )p) {
#line 265
            if (! ((int )*b == 92)) {
#line 265
              break;
            }
          } else {
#line 265
            break;
          }
#line 266
          backslash = ! backslash;
#line 265
          b --;
        }
#line 267
        if (backslash) {
#line 269
          end ++;
#line 270
          goto find_end;
        }
      }
    }
#line 274
    if (idx == nlines) {
#line 276
      nlines += 2U;
#line 277
      tmp___1 = xrealloc((char *)lines, (unsigned int )((unsigned long )nlines * sizeof(char *)));
#line 277
      lines = (char **)tmp___1;
    }
#line 280
    tmp___2 = idx;
#line 280
    idx ++;
#line 280
    *(lines + tmp___2) = savestring((char const   *)p, (unsigned int )(end - p));
#line 281
    p = end;
#line 282
    if ((int )*p != 0) {
#line 283
      p ++;
    }
  }
#line 286
  if (idx != nlines) {
#line 288
    nlines = idx;
#line 289
    tmp___3 = xrealloc((char *)lines, (unsigned int )((unsigned long )nlines * sizeof(char *)));
#line 289
    lines = (char **)tmp___3;
  }
#line 293
  cmds->ncommand_lines = nlines;
#line 294
  cmds->command_lines = lines;
#line 296
  cmds->any_recurse = 0;
#line 297
  tmp___4 = xmalloc(nlines);
#line 297
  cmds->lines_flags = tmp___4;
#line 298
  idx = 0U;
#line 298
  while (idx < nlines) {
#line 300
    flags = 0;
#line 302
    p = *(lines + idx);
#line 302
    while (1) {
#line 302
      tmp___5 = __ctype_b_loc();
#line 302
      if (! ((int const   )*(*tmp___5 + (int )*p) & 1)) {
#line 302
        if (! ((int )*p == 45)) {
#line 302
          if (! ((int )*p == 64)) {
#line 302
            if (! ((int )*p == 43)) {
#line 302
              break;
            }
          }
        }
      }
#line 305
      switch ((int )*p) {
      case 43: 
#line 308
      flags |= 1;
#line 309
      break;
      case 64: 
#line 311
      flags |= 2;
#line 312
      break;
      case 45: 
#line 314
      flags |= 4;
#line 315
      break;
      }
#line 302
      p ++;
    }
#line 317
    if (! (flags & 1)) {
#line 319
      tmp___6 = strlen((char const   *)p);
#line 319
      len = (unsigned int )tmp___6;
#line 320
      tmp___7 = sindex((char const   *)p, len, "$(MAKE)", 7U);
#line 320
      if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
#line 322
        flags |= 1;
      } else {
#line 320
        tmp___8 = sindex((char const   *)p, len, "${MAKE}", 7U);
#line 320
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
#line 322
          flags |= 1;
        }
      }
    }
#line 325
    *(cmds->lines_flags + idx) = (char )flags;
#line 326
    cmds->any_recurse |= flags & 1;
#line 298
    idx ++;
  }
#line 328
  return;
}
}
#line 334 "commands.c"
void execute_file_commands(struct file *file ) 
{ 
  register char *p ;
  unsigned short const   **tmp ;

  {
#line 343
  p = (file->cmds)->commands;
#line 343
  while ((int )*p != 0) {
#line 344
    tmp = __ctype_b_loc();
#line 344
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
#line 344
      if ((int )*p != 45) {
#line 344
        if ((int )*p != 64) {
#line 345
          break;
        }
      }
    }
#line 343
    p ++;
  }
#line 346
  if ((int )*p == 0) {
#line 349
    set_command_state(file, 2);
#line 350
    file->update_status = (short)0;
#line 351
    notice_finished_file(file);
#line 352
    return;
  }
#line 357
  initialize_file_variables(file, 0);
#line 359
  set_file_variables(file);
#line 362
  new_job(file);
#line 363
  return;
}
}
#line 368 "commands.c"
int handling_fatal_signal  =    0;
#line 372 "commands.c"
void fatal_error_signal(int sig ) 
{ 
  register struct child *c ;
  register struct child *c___0 ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 395
  handling_fatal_signal = 1;
#line 399
  signal(sig, (void (*)(int  ))0);
#line 404
  if (sig == 15) {
#line 407
    c = children;
#line 407
    while ((unsigned long )c != (unsigned long )((struct child *)0)) {
#line 408
      if (! c->remote) {
#line 409
        kill(c->pid, 15);
      }
#line 407
      c = c->next;
    }
  }
#line 415
  if (sig == 15) {
#line 415
    goto _L;
  } else
#line 415
  if (sig == 2) {
#line 415
    goto _L;
  } else
#line 415
  if (sig == 1) {
#line 415
    goto _L;
  } else
#line 415
  if (sig == 3) {
    _L: /* CIL Label */ 
#line 428
    c___0 = children;
#line 428
    while ((unsigned long )c___0 != (unsigned long )((struct child *)0)) {
#line 429
      if (c___0->remote) {
#line 430
        remote_kill(c___0->pid, sig);
      }
#line 428
      c___0 = c___0->next;
    }
#line 432
    c___0 = children;
#line 432
    while ((unsigned long )c___0 != (unsigned long )((struct child *)0)) {
#line 433
      delete_child_targets(c___0);
#line 432
      c___0 = c___0->next;
    }
#line 437
    while (job_slots_used > 0U) {
#line 438
      reap_children(1, 0);
    }
  } else {
#line 442
    while (job_slots_used > 0U) {
#line 443
      reap_children(1, 1);
    }
  }
#line 447
  remove_intermediates(1);
#line 450
  if (sig == 3) {
#line 453
    exit(1);
  }
#line 458
  tmp = getpid();
#line 458
  tmp___0 = kill(tmp, sig);
#line 458
  if (tmp___0 < 0) {
#line 459
    pfatal_with_name((char *)"kill");
  }
#line 462
  return;
}
}
#line 467 "commands.c"
static void delete_target(struct file *file , char *on_behalf_of ) 
{ 
  struct stat st ;
  char *tmp ;
  char *tmp___0 ;
  time_t tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  uintmax_t tmp___10 ;
  uintmax_t tmp___11 ;

  {
#line 474
  if (file->precious) {
#line 475
    return;
  } else
#line 474
  if (file->phony) {
#line 475
    return;
  }
#line 478
  tmp___4 = ar_name(file->name);
#line 478
  if (tmp___4) {
#line 480
    tmp___1 = ar_member_date(file->name);
#line 480
    if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 480
      tmp___2 = (uintmax_t )1000000000;
    } else {
#line 480
      tmp___2 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
    }
#line 480
    if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 480
      tmp___3 = (uintmax_t )1000000000;
    } else {
#line 480
      tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
    }
#line 480
    if ((uintmax_t )tmp___1 != file->last_mtime / tmp___2 - (uintmax_t )(file->last_mtime % tmp___3 < 0UL)) {
#line 482
      if (on_behalf_of) {
#line 483
        tmp = dcgettext((char const   *)((void *)0), "*** [%s] Archive member `%s\' may be bogus; not deleted",
                        5);
#line 483
        error((struct floc  const  *)((struct floc *)0), (char const   *)tmp, on_behalf_of,
              file->name);
      } else {
#line 486
        tmp___0 = dcgettext((char const   *)((void *)0), "*** Archive member `%s\' may be bogus; not deleted",
                            5);
#line 486
        error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0,
              file->name);
      }
    }
#line 489
    return;
  }
#line 493
  tmp___9 = stat((char const   * __restrict  )file->name, (struct stat * __restrict  )(& st));
#line 493
  if (tmp___9 == 0) {
#line 493
    if ((st.st_mode & 61440U) == 32768U) {
#line 493
      if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 493
        tmp___10 = (uintmax_t )1000000000;
      } else {
#line 493
        tmp___10 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
      }
#line 493
      if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 493
        tmp___11 = (uintmax_t )1000000000;
      } else {
#line 493
        tmp___11 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
      }
#line 493
      if ((uintmax_t )st.st_mtim.tv_sec * tmp___10 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___11) / 1000000000UL != file->last_mtime) {
#line 497
        if (on_behalf_of) {
#line 498
          tmp___5 = dcgettext((char const   *)((void *)0), "*** [%s] Deleting file `%s\'",
                              5);
#line 498
          error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___5,
                on_behalf_of, file->name);
        } else {
#line 500
          tmp___6 = dcgettext((char const   *)((void *)0), "*** Deleting file `%s\'",
                              5);
#line 500
          error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                file->name);
        }
#line 501
        tmp___7 = unlink((char const   *)file->name);
#line 501
        if (tmp___7 < 0) {
#line 501
          tmp___8 = __errno_location();
#line 501
          if (*tmp___8 != 2) {
#line 503
            perror_with_name((char *)"unlink: ", file->name);
          }
        }
      }
    }
  }
#line 505
  return;
}
}
#line 511 "commands.c"
void delete_child_targets(struct child *child ) 
{ 
  struct dep *d ;

  {
#line 517
  if (child->deleted) {
#line 518
    return;
  }
#line 521
  delete_target(child->file, (char *)0);
#line 524
  d = (child->file)->also_make;
#line 524
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 525
    delete_target(d->file, (child->file)->name);
#line 524
    d = d->next;
  }
#line 527
  child->deleted = 1U;
#line 528
  return;
}
}
#line 532 "commands.c"
void print_commands(struct commands *cmds ) 
{ 
  register char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *end ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;

  {
#line 538
  tmp = dcgettext((char const   *)((void *)0), "#  commands to execute", 5);
#line 538
  fputs((char const   * __restrict  )tmp, (FILE * __restrict  )stdout);
#line 540
  if ((unsigned long )cmds->fileinfo.filenm == (unsigned long )((char *)0)) {
#line 541
    tmp___0 = dcgettext((char const   *)((void *)0), " (built-in):", 5);
#line 541
    puts((char const   *)tmp___0);
  } else {
#line 543
    tmp___1 = dcgettext((char const   *)((void *)0), " (from `%s\', line %lu):\n",
                        5);
#line 543
    printf((char const   * __restrict  )tmp___1, cmds->fileinfo.filenm, cmds->fileinfo.lineno);
  }
#line 546
  s = cmds->commands;
#line 547
  while ((int )*s != 0) {
#line 551
    while (1) {
#line 551
      tmp___2 = __ctype_b_loc();
#line 551
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192)) {
#line 551
        break;
      }
#line 552
      s ++;
    }
#line 554
    end = strchr((char const   *)s, '\n');
#line 555
    if ((unsigned long )end == (unsigned long )((char *)0)) {
#line 556
      tmp___3 = strlen((char const   *)s);
#line 556
      end = s + tmp___3;
    }
#line 558
    printf((char const   * __restrict  )"\t%.*s\n", (int )(end - s), s);
#line 560
    s = end;
  }
#line 562
  return;
}
}
#line 1 "dir.o"
#pragma merger("0","/tmp/cil-rXs7r6eI.i","-g,-O0")
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 397 "make.h"
char *xstrdup(char const   *ptr ) ;
#line 419
int dir_file_exists_p(char *dirname , char *filename ) ;
#line 421
int file_impossible_p(char *filename ) ;
#line 422
void file_impossible(char *filename ) ;
#line 423
char *dir_name(char *dir ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 249 "dir.c"
static struct directory_contents *directories_contents[199]  ;
#line 264 "dir.c"
static struct directory *directories[199]  ;
#line 271 "dir.c"
static unsigned int open_directories  =    0U;
#line 287
static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) ;
#line 288
static struct directory *find_directory(char *name ) ;
#line 292 "dir.c"
static struct directory *find_directory(char *name ) 
{ 
  register unsigned int hash ;
  register char *p ;
  register struct directory *dir ;
  int tmp ;
  struct stat st ;
  char *tmp___0 ;
  struct directory_contents *dc ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 296
  hash = 0U;
#line 314
  p = name;
#line 314
  while ((int )*p != 0) {
#line 315
    hash += (unsigned int )*p;
#line 315
    hash = (hash << 7) + (hash >> 20);
#line 314
    p ++;
  }
#line 316
  hash %= 199U;
#line 318
  dir = directories[hash];
#line 318
  while ((unsigned long )dir != (unsigned long )((struct directory *)0)) {
#line 319
    if ((unsigned long )dir->name == (unsigned long )name) {
#line 320
      break;
    } else
#line 319
    if ((int )*(dir->name) == (int )*name) {
#line 319
      if ((int )*(dir->name) == 0) {
#line 320
        break;
      } else {
#line 319
        tmp = strcmp((char const   *)(dir->name + 1), (char const   *)(name + 1));
#line 319
        if (! tmp) {
#line 320
          break;
        }
      }
    }
#line 318
    dir = dir->next;
  }
#line 322
  if ((unsigned long )dir == (unsigned long )((struct directory *)0)) {
#line 328
    tmp___0 = xmalloc((unsigned int )sizeof(struct directory ));
#line 328
    dir = (struct directory *)tmp___0;
#line 329
    dir->next = directories[hash];
#line 330
    directories[hash] = dir;
#line 331
    dir->name = savestring((char const   *)name, (unsigned int )(p - name));
#line 346
    tmp___3 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
#line 346
    if (tmp___3 < 0) {
#line 351
      dir->contents = (struct directory_contents *)0;
    } else {
#line 369
      hash = ((unsigned int )st.st_dev << 16) | (unsigned int )st.st_ino;
#line 372
      hash %= 199U;
#line 374
      dc = directories_contents[hash];
#line 374
      while ((unsigned long )dc != (unsigned long )((struct directory_contents *)0)) {
#line 378
        if (dc->dev == st.st_dev) {
#line 378
          if (dc->ino == st.st_ino) {
#line 388
            break;
          }
        }
#line 374
        dc = dc->next;
      }
#line 390
      if ((unsigned long )dc == (unsigned long )((struct directory_contents *)0)) {
#line 394
        tmp___1 = xmalloc((unsigned int )sizeof(struct directory_contents ));
#line 394
        dc = (struct directory_contents *)tmp___1;
#line 398
        dc->dev = st.st_dev;
#line 426
        dc->ino = st.st_ino;
#line 429
        dc->next = directories_contents[hash];
#line 430
        directories_contents[hash] = dc;
#line 432
        dc->dirstream = opendir((char const   *)name);
#line 433
        if ((unsigned long )dc->dirstream == (unsigned long )((DIR *)0)) {
#line 436
          dc->files = (struct dirfile **)0;
        } else {
#line 440
          tmp___2 = xmalloc((unsigned int )(sizeof(struct dirfile *) * 107UL));
#line 440
          dc->files = (struct dirfile **)tmp___2;
#line 442
          memset((void *)((char *)dc->files), 0, sizeof(struct dirfile *) * 107UL);
#line 446
          open_directories ++;
#line 447
          if (open_directories == 10U) {
#line 450
            dir_contents_file_exists_p(dc, (char *)0);
          }
        }
      }
#line 455
      dir->contents = dc;
    }
  }
#line 459
  return (dir);
}
}
#line 465 "dir.c"
static int dir_contents_file_exists_p(struct directory_contents *dir , char *filename ) 
{ 
  register unsigned int hash ;
  register char *p ;
  register struct dirfile *df ;
  register struct dirent *d ;
  int tmp ;
  register unsigned int newhash ;
  unsigned int len ;
  register unsigned int i ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 479
  if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
#line 482
    return (0);
  } else
#line 479
  if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
#line 482
    return (0);
  }
#line 496
  hash = 0U;
#line 497
  if ((unsigned long )filename != (unsigned long )((char *)0)) {
#line 499
    if ((int )*filename == 0) {
#line 502
      return (1);
    }
#line 505
    p = filename;
#line 505
    while ((int )*p != 0) {
#line 506
      hash += (unsigned int )*p;
#line 506
      hash = (hash << 7) + (hash >> 20);
#line 505
      p ++;
    }
#line 507
    hash %= 107U;
#line 511
    df = *(dir->files + hash);
#line 511
    while ((unsigned long )df != (unsigned long )((struct dirfile *)0)) {
#line 513
      if ((unsigned long )df->name == (unsigned long )filename) {
#line 515
        return (! df->impossible);
      } else
#line 513
      if ((int )*(df->name) == (int )*filename) {
#line 513
        if ((int )*(df->name) == 0) {
#line 515
          return (! df->impossible);
        } else {
#line 513
          tmp = strcmp((char const   *)(df->name + 1), (char const   *)(filename + 1));
#line 513
          if (! tmp) {
#line 515
            return (! df->impossible);
          }
        }
      }
#line 511
      df = df->next;
    }
  }
#line 523
  if ((unsigned long )dir->dirstream == (unsigned long )((DIR *)0)) {
#line 549
    return (0);
  }
#line 552
  while (1) {
#line 552
    d = readdir(dir->dirstream);
#line 552
    if (! ((unsigned long )d != (unsigned long )((struct dirent *)0))) {
#line 552
      break;
    }
#line 555
    newhash = 0U;
#line 567
    if (! (d->d_ino != 0UL)) {
#line 568
      continue;
    }
#line 570
    tmp___0 = strlen((char const   *)(d->d_name));
#line 570
    len = (unsigned int )tmp___0;
#line 571
    i = 0U;
#line 571
    while (i < len) {
#line 572
      newhash += (unsigned int )d->d_name[i];
#line 572
      newhash = (newhash << 7) + (newhash >> 20);
#line 571
      i ++;
    }
#line 573
    newhash %= 107U;
#line 593
    tmp___1 = xmalloc((unsigned int )sizeof(struct dirfile ));
#line 593
    df = (struct dirfile *)tmp___1;
#line 594
    df->next = *(dir->files + newhash);
#line 595
    *(dir->files + newhash) = df;
#line 596
    df->name = savestring((char const   *)(d->d_name), len);
#line 597
    df->impossible = (char)0;
#line 602
    if ((unsigned long )filename != (unsigned long )((char *)0)) {
#line 602
      if (newhash == hash) {
#line 602
        if ((unsigned long )(d->d_name) == (unsigned long )filename) {
#line 605
          return (1);
        } else
#line 602
        if ((int )d->d_name[0] == (int )*filename) {
#line 602
          if ((int )d->d_name[0] == 0) {
#line 605
            return (1);
          } else {
#line 602
            tmp___2 = strcmp((char const   *)(d->d_name + 1), (char const   *)(filename + 1));
#line 602
            if (! tmp___2) {
#line 605
              return (1);
            }
          }
        }
      }
    }
  }
#line 611
  if ((unsigned long )d == (unsigned long )((struct dirent *)0)) {
#line 613
    open_directories --;
#line 614
    closedir(dir->dirstream);
#line 615
    dir->dirstream = (DIR *)0;
  }
#line 617
  return (0);
}
}
#line 624 "dir.c"
int dir_file_exists_p(char *dirname , char *filename ) 
{ 
  struct directory *tmp ;
  int tmp___0 ;

  {
#line 629
  tmp = find_directory(dirname);
#line 629
  tmp___0 = dir_contents_file_exists_p(tmp->contents, filename);
#line 629
  return (tmp___0);
}
}
#line 635 "dir.c"
int file_exists_p(char *name ) 
{ 
  char *dirend ;
  char *dirname ;
  char *slash ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 644
  tmp___0 = ar_name(name);
#line 644
  if (tmp___0) {
#line 645
    tmp = ar_member_date(name);
#line 645
    return (tmp != -1L);
  }
#line 656
  dirend = strrchr((char const   *)name, '/');
#line 668
  if ((unsigned long )dirend == (unsigned long )((char *)0)) {
#line 670
    tmp___1 = dir_file_exists_p((char *)".", name);
#line 670
    return (tmp___1);
  }
#line 676
  slash = dirend;
#line 677
  if ((unsigned long )dirend == (unsigned long )name) {
#line 678
    dirname = (char *)"/";
  } else {
#line 687
    tmp___2 = __builtin_alloca((unsigned long )((dirend - name) + 1L));
#line 687
    dirname = (char *)tmp___2;
#line 688
    memmove((void *)dirname, (void const   *)name, (size_t )(dirend - name));
#line 689
    *(dirname + (dirend - name)) = (char )'\000';
  }
#line 691
  tmp___3 = dir_file_exists_p(dirname, slash + 1);
#line 691
  return (tmp___3);
}
}
#line 698 "dir.c"
void file_impossible(char *filename ) 
{ 
  char *dirend ;
  register char *p ;
  register unsigned int hash ;
  register struct directory *dir ;
  register struct dirfile *new ;
  char *dirname ;
  char *slash ;
  void *tmp ;
  char *tmp___0 ;
  ino_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 703
  p = filename;
#line 716
  dirend = strrchr((char const   *)p, '/');
#line 728
  if ((unsigned long )dirend == (unsigned long )((char *)0)) {
#line 732
    dir = find_directory((char *)".");
  } else {
#line 738
    slash = dirend;
#line 739
    if ((unsigned long )dirend == (unsigned long )p) {
#line 740
      dirname = (char *)"/";
    } else {
#line 749
      tmp = __builtin_alloca((unsigned long )((dirend - p) + 1L));
#line 749
      dirname = (char *)tmp;
#line 750
      memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));
#line 751
      *(dirname + (dirend - p)) = (char )'\000';
    }
#line 753
    dir = find_directory(dirname);
#line 754
    p = slash + 1;
#line 754
    filename = p;
  }
#line 757
  hash = 0U;
#line 757
  while ((int )*p != 0) {
#line 758
    hash += (unsigned int )*p;
#line 758
    hash = (hash << 7) + (hash >> 20);
#line 757
    p ++;
  }
#line 759
  hash %= 107U;
#line 761
  if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
#line 765
    tmp___0 = xmalloc((unsigned int )sizeof(struct directory_contents ));
#line 765
    dir->contents = (struct directory_contents *)tmp___0;
#line 776
    tmp___1 = (ino_t )0;
#line 776
    (dir->contents)->ino = tmp___1;
#line 776
    (dir->contents)->dev = tmp___1;
#line 779
    (dir->contents)->files = (struct dirfile **)0;
#line 780
    (dir->contents)->dirstream = (DIR *)0;
  }
#line 783
  if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
#line 786
    tmp___2 = xmalloc((unsigned int )(sizeof(struct dirfile ) * 107UL));
#line 786
    (dir->contents)->files = (struct dirfile **)tmp___2;
#line 788
    memset((void *)((char *)(dir->contents)->files), 0, sizeof(struct dirfile ) * 107UL);
  }
#line 794
  tmp___3 = xmalloc((unsigned int )sizeof(struct dirfile ));
#line 794
  new = (struct dirfile *)tmp___3;
#line 795
  new->next = *((dir->contents)->files + hash);
#line 796
  *((dir->contents)->files + hash) = new;
#line 797
  new->name = xstrdup((char const   *)filename);
#line 798
  new->impossible = (char)1;
#line 799
  return;
}
}
#line 803 "dir.c"
int file_impossible_p(char *filename ) 
{ 
  char *dirend ;
  register char *p ;
  register unsigned int hash ;
  register struct directory_contents *dir ;
  register struct dirfile *next ;
  struct directory *tmp ;
  char *dirname ;
  char *slash ;
  void *tmp___0 ;
  struct directory *tmp___1 ;
  int tmp___2 ;

  {
#line 808
  p = filename;
#line 818
  dirend = strrchr((char const   *)filename, '/');
#line 830
  if ((unsigned long )dirend == (unsigned long )((char *)0)) {
#line 834
    tmp = find_directory((char *)".");
#line 834
    dir = tmp->contents;
  } else {
#line 840
    slash = dirend;
#line 841
    if ((unsigned long )dirend == (unsigned long )filename) {
#line 842
      dirname = (char *)"/";
    } else {
#line 851
      tmp___0 = __builtin_alloca((unsigned long )((dirend - filename) + 1L));
#line 851
      dirname = (char *)tmp___0;
#line 852
      memmove((void *)dirname, (void const   *)p, (size_t )(dirend - p));
#line 853
      *(dirname + (dirend - p)) = (char )'\000';
    }
#line 855
    tmp___1 = find_directory(dirname);
#line 855
    dir = tmp___1->contents;
#line 856
    filename = slash + 1;
#line 856
    p = filename;
  }
#line 859
  if ((unsigned long )dir == (unsigned long )((struct directory_contents *)0)) {
#line 861
    return (0);
  } else
#line 859
  if ((unsigned long )dir->files == (unsigned long )((struct dirfile **)0)) {
#line 861
    return (0);
  }
#line 873
  hash = 0U;
#line 873
  while ((int )*p != 0) {
#line 874
    hash += (unsigned int )*p;
#line 874
    hash = (hash << 7) + (hash >> 20);
#line 873
    p ++;
  }
#line 875
  hash %= 107U;
#line 877
  next = *(dir->files + hash);
#line 877
  while ((unsigned long )next != (unsigned long )((struct dirfile *)0)) {
#line 878
    if ((unsigned long )filename == (unsigned long )next->name) {
#line 879
      return ((int )next->impossible);
    } else
#line 878
    if ((int )*filename == (int )*(next->name)) {
#line 878
      if ((int )*filename == 0) {
#line 879
        return ((int )next->impossible);
      } else {
#line 878
        tmp___2 = strcmp((char const   *)(filename + 1), (char const   *)(next->name + 1));
#line 878
        if (! tmp___2) {
#line 879
          return ((int )next->impossible);
        }
      }
    }
#line 877
    next = next->next;
  }
#line 881
  return (0);
}
}
#line 887 "dir.c"
char *dir_name(char *dir ) 
{ 
  struct directory *tmp ;

  {
#line 891
  tmp = find_directory(dir);
#line 891
  return (tmp->name);
}
}
#line 896 "dir.c"
void print_dir_data_base(void) 
{ 
  register unsigned int i ;
  register unsigned int dirs___0 ;
  register unsigned int files___0 ;
  register unsigned int impossible ;
  register struct directory *dir ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register unsigned int f ;
  register unsigned int im ;
  register unsigned int j ;
  register struct dirfile *df ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 902
  tmp = dcgettext((char const   *)((void *)0), "\n# Directories\n", 5);
#line 902
  puts((char const   *)tmp);
#line 904
  impossible = 0U;
#line 904
  files___0 = impossible;
#line 904
  dirs___0 = files___0;
#line 905
  i = 0U;
#line 905
  while (i < 199U) {
#line 906
    dir = directories[i];
#line 906
    while ((unsigned long )dir != (unsigned long )((struct directory *)0)) {
#line 908
      dirs___0 ++;
#line 909
      if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
#line 910
        tmp___0 = dcgettext((char const   *)((void *)0), "# %s: could not be stat\'d.\n",
                            5);
#line 910
        printf((char const   * __restrict  )tmp___0, dir->name);
      } else
#line 911
      if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
#line 922
        tmp___1 = dcgettext((char const   *)((void *)0), "# %s (device %ld, inode %ld): could not be opened.\n",
                            5);
#line 922
        printf((char const   * __restrict  )tmp___1, dir->name, (long )(dir->contents)->dev,
               (long )(dir->contents)->ino);
      } else {
#line 929
        f = 0U;
#line 929
        im = 0U;
#line 932
        j = 0U;
#line 932
        while (j < 107U) {
#line 933
          df = *((dir->contents)->files + j);
#line 933
          while ((unsigned long )df != (unsigned long )((struct dirfile *)0)) {
#line 934
            if (df->impossible) {
#line 935
              im ++;
            } else {
#line 937
              f ++;
            }
#line 933
            df = df->next;
          }
#line 932
          j ++;
        }
#line 948
        tmp___2 = dcgettext((char const   *)((void *)0), "# %s (device %ld, inode %ld): ",
                            5);
#line 948
        printf((char const   * __restrict  )tmp___2, dir->name, (long )(dir->contents)->dev,
               (long )(dir->contents)->ino);
#line 953
        if (f == 0U) {
#line 954
          tmp___3 = dcgettext((char const   *)((void *)0), "No", 5);
#line 954
          fputs((char const   * __restrict  )tmp___3, (FILE * __restrict  )stdout);
        } else {
#line 956
          printf((char const   * __restrict  )"%u", f);
        }
#line 957
        tmp___4 = dcgettext((char const   *)((void *)0), " files, ", 5);
#line 957
        fputs((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);
#line 958
        if (im == 0U) {
#line 959
          tmp___5 = dcgettext((char const   *)((void *)0), "no", 5);
#line 959
          fputs((char const   * __restrict  )tmp___5, (FILE * __restrict  )stdout);
        } else {
#line 961
          printf((char const   * __restrict  )"%u", im);
        }
#line 962
        tmp___6 = dcgettext((char const   *)((void *)0), " impossibilities", 5);
#line 962
        fputs((char const   * __restrict  )tmp___6, (FILE * __restrict  )stdout);
#line 963
        if ((unsigned long )(dir->contents)->dirstream == (unsigned long )((DIR *)0)) {
#line 964
          puts(".");
        } else {
#line 966
          tmp___7 = dcgettext((char const   *)((void *)0), " so far.", 5);
#line 966
          puts((char const   *)tmp___7);
        }
#line 967
        files___0 += f;
#line 968
        impossible += im;
      }
#line 906
      dir = dir->next;
    }
#line 905
    i ++;
  }
#line 972
  fputs((char const   * __restrict  )"\n# ", (FILE * __restrict  )stdout);
#line 973
  if (files___0 == 0U) {
#line 974
    tmp___8 = dcgettext((char const   *)((void *)0), "No", 5);
#line 974
    fputs((char const   * __restrict  )tmp___8, (FILE * __restrict  )stdout);
  } else {
#line 976
    printf((char const   * __restrict  )"%u", files___0);
  }
#line 977
  tmp___9 = dcgettext((char const   *)((void *)0), " files, ", 5);
#line 977
  fputs((char const   * __restrict  )tmp___9, (FILE * __restrict  )stdout);
#line 978
  if (impossible == 0U) {
#line 979
    tmp___10 = dcgettext((char const   *)((void *)0), "no", 5);
#line 979
    fputs((char const   * __restrict  )tmp___10, (FILE * __restrict  )stdout);
  } else {
#line 981
    printf((char const   * __restrict  )"%u", impossible);
  }
#line 982
  tmp___11 = dcgettext((char const   *)((void *)0), " impossibilities in %u directories.\n",
                       5);
#line 982
  printf((char const   * __restrict  )tmp___11, dirs___0);
#line 983
  return;
}
}
#line 1000
static void *open_dirstream(char const   *directory ) ;
#line 1001
static struct dirent *read_dirstream(void *stream ) ;
#line 1003 "dir.c"
static void *open_dirstream(char const   *directory ) 
{ 
  struct dirstream *new ;
  struct directory *dir ;
  struct directory *tmp ;
  char *tmp___0 ;

  {
#line 1008
  tmp = find_directory((char *)directory);
#line 1008
  dir = tmp;
#line 1010
  if ((unsigned long )dir->contents == (unsigned long )((struct directory_contents *)0)) {
#line 1013
    return ((void *)0);
  } else
#line 1010
  if ((unsigned long )(dir->contents)->files == (unsigned long )((struct dirfile **)0)) {
#line 1013
    return ((void *)0);
  }
#line 1018
  dir_contents_file_exists_p(dir->contents, (char *)0);
#line 1020
  tmp___0 = xmalloc((unsigned int )sizeof(struct dirstream ));
#line 1020
  new = (struct dirstream *)tmp___0;
#line 1021
  new->contents = dir->contents;
#line 1022
  new->bucket = 0U;
#line 1023
  new->elt = *((new->contents)->files + 0);
#line 1025
  return ((void *)new);
}
}
#line 1034 "dir.c"
static char *buf  ;
#line 1035 "dir.c"
static unsigned int bufsz  ;
#line 1028 "dir.c"
static struct dirent *read_dirstream(void *stream ) 
{ 
  struct dirstream *ds ;
  register struct dirfile *df ;
  struct dirent *d ;
  unsigned int len ;
  size_t tmp ;

  {
#line 1032
  ds = (struct dirstream *)stream;
#line 1037
  while (ds->bucket < 107U) {
#line 1039
    while (1) {
#line 1039
      df = ds->elt;
#line 1039
      if (! ((unsigned long )df != (unsigned long )((struct dirfile *)0))) {
#line 1039
        break;
      }
#line 1041
      ds->elt = df->next;
#line 1042
      if (! df->impossible) {
#line 1047
        tmp = strlen((char const   *)df->name);
#line 1047
        len = (unsigned int )(tmp + 1UL);
#line 1048
        if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
#line 1050
          if ((unsigned long )buf != (unsigned long )((char *)0)) {
#line 1051
            free((void *)buf);
          }
#line 1052
          bufsz *= 2U;
#line 1053
          if ((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len > (unsigned long )bufsz) {
#line 1054
            bufsz = (unsigned int )((sizeof(*d) - sizeof(d->d_name)) + (unsigned long )len);
          }
#line 1055
          buf = xmalloc(bufsz);
        }
#line 1057
        d = (struct dirent *)buf;
#line 1058
        d->d_ino = (__ino_t )1;
#line 1063
        d->d_type = (unsigned char)0;
#line 1065
        memcpy((void * __restrict  )(d->d_name), (void const   * __restrict  )df->name,
               (size_t )len);
#line 1066
        return (d);
      }
    }
#line 1069
    (ds->bucket) ++;
#line 1069
    if (ds->bucket == 107U) {
#line 1070
      break;
    }
#line 1071
    ds->elt = *((ds->contents)->files + ds->bucket);
  }
#line 1074
  return ((struct dirent *)0);
}
}
#line 1077 "dir.c"
static void ansi_free(void *p ) 
{ 


  {
#line 1081
  if (p) {
#line 1082
    free(p);
  }
#line 1083
  return;
}
}
#line 1103 "dir.c"
void dir_setup_glob(glob_t *gl ) 
{ 


  {
#line 1108
  gl->gl_opendir = & open_dirstream;
#line 1109
  gl->gl_readdir = & read_dirstream;
#line 1110
  gl->gl_closedir = & ansi_free;
#line 1111
  gl->gl_stat = (int (*)(char const   * , struct stat * ))(& stat);
#line 1114
  return;
}
}
#line 1 "expand.o"
#pragma merger("0","/tmp/cil-Fpr9bQUU.i","-g,-O0")
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 405 "make.h"
char *lindex(char const   *s , char const   *limit , int c ) ;
#line 409
char *find_percent(char *pattern ) ;
#line 466
struct floc  const  *reading_file ;
#line 474
int warn_undefined_variables_flag ;
#line 76 "variable.h"
char *variable_buffer  ;
#line 77
struct variable_set_list *current_variable_set_list ;
#line 80
char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) ;
#line 81
char *variable_expand(char *line ) ;
#line 82
char *allocated_variable_expand_for_file(char *line , struct file *file ) ;
#line 85
char *expand_argument(char *str , char *end ) ;
#line 86
char *variable_expand_string(char *line , char *string , long length___0 ) ;
#line 90
int handle_function(char **op , char **stringp ) ;
#line 92
char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                   unsigned int rlen , int by_word , int suffix_only ) ;
#line 94
char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                      char *replace_percent ) ;
#line 98
char *recursively_expand(struct variable *v ) ;
#line 111
struct variable *lookup_variable(char *name , unsigned int length___0 ) ;
#line 43 "expand.c"
static unsigned int variable_buffer_length  ;
#line 53 "expand.c"
char *variable_buffer_output(char *ptr , char *string , unsigned int length___0 ) 
{ 
  register unsigned int newlen ;
  unsigned int offset ;
  char *tmp ;

  {
#line 58
  newlen = (unsigned int )((long )length___0 + (ptr - variable_buffer));
#line 60
  if (newlen + 5U > variable_buffer_length) {
#line 62
    offset = (unsigned int )(ptr - variable_buffer);
#line 63
    if (newlen + 100U > 2U * variable_buffer_length) {
#line 63
      variable_buffer_length = newlen + 100U;
    } else {
#line 63
      variable_buffer_length = 2U * variable_buffer_length;
    }
#line 66
    tmp = xrealloc(variable_buffer, variable_buffer_length);
#line 66
    variable_buffer = tmp;
#line 68
    ptr = variable_buffer + offset;
  }
#line 71
  memmove((void *)ptr, (void const   *)string, (size_t )length___0);
#line 72
  return (ptr + length___0);
}
}
#line 77 "expand.c"
static char *initialize_variable_output(void) 
{ 
  char *tmp ;

  {
#line 82
  if ((unsigned long )variable_buffer == (unsigned long )((char *)0)) {
#line 84
    variable_buffer_length = 200U;
#line 85
    tmp = xmalloc(variable_buffer_length);
#line 85
    variable_buffer = tmp;
#line 86
    *(variable_buffer + 0) = (char )'\000';
  }
#line 89
  return (variable_buffer);
}
}
#line 94
static char *allocated_variable_append(struct variable *v ) ;
#line 96 "expand.c"
char *recursively_expand(struct variable *v ) 
{ 
  char *value ;
  char *tmp ;

  {
#line 102
  if (v->expanding) {
#line 104
    tmp = dcgettext((char const   *)((void *)0), "Recursive variable `%s\' references itself (eventually)",
                    5);
#line 104
    fatal(reading_file, (char const   *)tmp, v->name);
  }
#line 108
  v->expanding = 1U;
#line 109
  if (v->append) {
#line 110
    value = allocated_variable_append(v);
  } else {
#line 112
    value = allocated_variable_expand_for_file(v->value, (struct file *)0);
  }
#line 113
  v->expanding = 0U;
#line 115
  return (value);
}
}
#line 121 "expand.c"
__inline static void warn_undefined(char *name , unsigned int length___0 ) 
{ 
  char *tmp ;

  {
#line 128
  if (warn_undefined_variables_flag) {
#line 129
    tmp = dcgettext((char const   *)((void *)0), "warning: undefined variable `%.*s\'",
                    5);
#line 129
    error(reading_file, (char const   *)tmp, (int )length___0, name);
  }
#line 131
  return;
}
}
#line 136 "expand.c"
__inline static char *reference_variable(char *o , char *name , unsigned int length___0 ) 
{ 
  register struct variable *v ;
  char *value ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 147
  v = lookup_variable(name, length___0);
#line 149
  if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
#line 150
    warn_undefined(name, length___0);
  }
#line 152
  if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
#line 153
    return (o);
  } else
#line 152
  if ((int )*(v->value) == 0) {
#line 153
    return (o);
  }
#line 155
  if (v->recursive) {
#line 155
    tmp = recursively_expand(v);
#line 155
    value = tmp;
  } else {
#line 155
    value = v->value;
  }
#line 157
  tmp___0 = strlen((char const   *)value);
#line 157
  o = variable_buffer_output(o, value, (unsigned int )tmp___0);
#line 159
  if (v->recursive) {
#line 160
    free((void *)value);
  }
#line 162
  return (o);
}
}
#line 174 "expand.c"
char *variable_expand_string(char *line , char *string , long length___0 ) 
{ 
  register struct variable *v ;
  register char *p ;
  register char *o ;
  register char *p1 ;
  char save_char ;
  unsigned int line_offset ;
  size_t tmp ;
  size_t tmp___0 ;
  char openparen ;
  char closeparen ;
  int tmp___1 ;
  register char *beg ;
  int free_beg ;
  char *op ;
  char *begp ;
  char *end ;
  char *colon ;
  int tmp___2 ;
  char *tmp___3 ;
  int count ;
  char *subst_beg ;
  char *subst_end ;
  char *replace_beg ;
  char *replace_end ;
  char *value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *pattern ;
  char *percent ;
  void *tmp___6 ;
  char *replace ;
  void *tmp___7 ;
  size_t tmp___8 ;
  unsigned short const   **tmp___9 ;
  char name[5] ;
  size_t tmp___10 ;

  {
#line 182
  save_char = (char )'\000';
#line 185
  if (! line) {
#line 186
    line = initialize_variable_output();
  }
#line 188
  p = string;
#line 189
  o = line;
#line 190
  line_offset = (unsigned int )(line - variable_buffer);
#line 192
  if (length___0 >= 0L) {
#line 194
    save_char = *(string + length___0);
#line 195
    *(string + length___0) = (char )'\000';
  }
#line 198
  while (1) {
#line 204
    p1 = strchr((char const   *)p, '$');
#line 206
    if ((unsigned long )p1 != (unsigned long )((char *)0)) {
#line 206
      tmp___0 = (size_t )(p1 - p);
    } else {
#line 206
      tmp = strlen((char const   *)p);
#line 206
      tmp___0 = tmp + 1UL;
    }
#line 206
    o = variable_buffer_output(o, p, (unsigned int )tmp___0);
#line 208
    if ((unsigned long )p1 == (unsigned long )((char *)0)) {
#line 209
      break;
    }
#line 210
    p = p1 + 1;
#line 214
    switch ((int )*p) {
    case 36: 
#line 218
    o = variable_buffer_output(o, p, 1U);
#line 219
    break;
    case 123: 
    case 40: 
#line 225
    openparen = *p;
#line 226
    if ((int )openparen == 40) {
#line 226
      tmp___1 = ')';
    } else {
#line 226
      tmp___1 = '}';
    }
#line 226
    closeparen = (char )tmp___1;
#line 227
    beg = p + 1;
#line 228
    free_beg = 0;
#line 232
    op = o;
#line 233
    begp = p;
#line 234
    tmp___2 = handle_function(& op, & begp);
#line 234
    if (tmp___2) {
#line 236
      o = op;
#line 237
      p = begp;
#line 238
      break;
    }
#line 244
    end = strchr((char const   *)beg, (int )closeparen);
#line 245
    if ((unsigned long )end == (unsigned long )((char *)0)) {
#line 247
      tmp___3 = dcgettext((char const   *)((void *)0), "unterminated variable reference",
                          5);
#line 247
      fatal(reading_file, (char const   *)tmp___3);
    }
#line 248
    p1 = lindex((char const   *)beg, (char const   *)end, '$');
#line 249
    if ((unsigned long )p1 != (unsigned long )((char *)0)) {
#line 253
      count = 0;
#line 254
      p = beg;
#line 254
      while ((int )*p != 0) {
#line 256
        if ((int )*p == (int )openparen) {
#line 257
          count ++;
        } else
#line 258
        if ((int )*p == (int )closeparen) {
#line 258
          count --;
#line 258
          if (count < 0) {
#line 259
            break;
          }
        }
#line 254
        p ++;
      }
#line 264
      if (count < 0) {
#line 266
        beg = expand_argument(beg, p);
#line 267
        free_beg = 1;
#line 268
        end = strchr((char const   *)beg, '\000');
      }
    } else {
#line 275
      p = end;
    }
#line 281
    colon = lindex((char const   *)beg, (char const   *)end, ':');
#line 282
    if ((unsigned long )colon != (unsigned long )((char *)0)) {
#line 287
      subst_beg = colon + 1;
#line 288
      subst_end = strchr((char const   *)subst_beg, '=');
#line 289
      if ((unsigned long )subst_end == (unsigned long )((char *)0)) {
#line 293
        colon = (char *)0;
      } else {
#line 296
        replace_beg = subst_end + 1;
#line 297
        replace_end = end;
#line 301
        v = lookup_variable(beg, (unsigned int )(colon - beg));
#line 302
        if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
#line 303
          warn_undefined(beg, (unsigned int )(colon - beg));
        }
#line 305
        if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 305
          if ((int )*(v->value) != 0) {
#line 307
            if (v->recursive) {
#line 307
              tmp___4 = recursively_expand(v);
#line 307
              tmp___5 = tmp___4;
            } else {
#line 307
              tmp___5 = v->value;
            }
#line 307
            value = tmp___5;
#line 310
            if (free_beg) {
#line 312
              *subst_end = (char )'\000';
#line 313
              pattern = subst_beg;
            } else {
#line 317
              tmp___6 = __builtin_alloca((unsigned long )((subst_end - subst_beg) + 1L));
#line 317
              pattern = (char *)tmp___6;
#line 319
              memmove((void *)pattern, (void const   *)subst_beg, (size_t )(subst_end - subst_beg));
#line 320
              *(pattern + (subst_end - subst_beg)) = (char )'\000';
            }
#line 322
            percent = find_percent(pattern);
#line 323
            if ((unsigned long )percent != (unsigned long )((char *)0)) {
#line 326
              if (free_beg) {
#line 328
                *replace_end = (char )'\000';
#line 329
                replace = replace_beg;
              } else {
#line 333
                tmp___7 = __builtin_alloca((unsigned long )((replace_end - replace_beg) + 1L));
#line 333
                replace = (char *)tmp___7;
#line 336
                memmove((void *)replace, (void const   *)replace_beg, (size_t )(replace_end - replace_beg));
#line 338
                *(replace + (replace_end - replace_beg)) = (char )'\000';
              }
#line 341
              o = patsubst_expand(o, value, pattern, replace, percent, (char *)0);
            } else {
#line 345
              tmp___8 = strlen((char const   *)pattern);
#line 345
              o = subst_expand(o, value, pattern, replace_beg, (unsigned int )tmp___8,
                               (unsigned int )(end - replace_beg), 0, 1);
            }
#line 350
            if (v->recursive) {
#line 351
              free((void *)value);
            }
          }
        }
      }
    }
#line 356
    if ((unsigned long )colon == (unsigned long )((char *)0)) {
#line 359
      o = reference_variable(o, beg, (unsigned int )(end - beg));
    }
#line 361
    if (free_beg) {
#line 362
      free((void *)beg);
    }
#line 364
    break;
    case 0: 
#line 367
    break;
    default: 
#line 370
    tmp___9 = __ctype_b_loc();
#line 370
    if ((int const   )*(*tmp___9 + (int )*(p + -1)) & 1) {
#line 371
      break;
    }
#line 379
    name[0] = (char )'$';
#line 380
    name[1] = (char )'(';
#line 381
    name[2] = *p;
#line 382
    name[3] = (char )')';
#line 383
    name[4] = (char )'\000';
#line 384
    p1 = allocated_variable_expand_for_file(name, (struct file *)0);
#line 385
    tmp___10 = strlen((char const   *)p1);
#line 385
    o = variable_buffer_output(o, p1, (unsigned int )tmp___10);
#line 386
    free((void *)p1);
#line 389
    break;
    }
#line 392
    if ((int )*p == 0) {
#line 393
      break;
    } else {
#line 395
      p ++;
    }
  }
#line 398
  if (save_char) {
#line 399
    *(string + length___0) = save_char;
  }
#line 401
  variable_buffer_output(o, (char *)"", 1U);
#line 402
  return (variable_buffer + line_offset);
}
}
#line 410 "expand.c"
char *variable_expand(char *line ) 
{ 
  char *tmp ;

  {
#line 414
  tmp = variable_expand_string((char *)((void *)0), line, -1L);
#line 414
  return (tmp);
}
}
#line 423 "expand.c"
char *expand_argument(char *str , char *end ) 
{ 
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  if (! end) {
#line 430
    tmp = str;
  } else
#line 429
  if ((int )*end == 0) {
#line 430
    tmp = str;
  } else {
#line 433
    tmp___0 = __builtin_alloca((unsigned long )((end - str) + 1L));
#line 433
    tmp = (char *)tmp___0;
#line 434
    memmove((void *)tmp, (void const   *)str, (size_t )(end - str));
#line 435
    *(tmp + (end - str)) = (char )'\000';
  }
#line 438
  tmp___1 = allocated_variable_expand_for_file(tmp, (struct file *)0);
#line 438
  return (tmp___1);
}
}
#line 444 "expand.c"
static char *variable_expand_for_file(char *line , struct file *file ) 
{ 
  char *result___0 ;
  struct variable_set_list *save ;
  char *tmp ;

  {
#line 452
  if ((unsigned long )file == (unsigned long )((struct file *)0)) {
#line 453
    tmp = variable_expand(line);
#line 453
    return (tmp);
  }
#line 455
  save = current_variable_set_list;
#line 456
  current_variable_set_list = file->variables;
#line 457
  if (file->cmds) {
#line 457
    if ((file->cmds)->fileinfo.filenm) {
#line 458
      reading_file = (struct floc  const  *)(& (file->cmds)->fileinfo);
    } else {
#line 460
      reading_file = (struct floc  const  *)0;
    }
  } else {
#line 460
    reading_file = (struct floc  const  *)0;
  }
#line 461
  result___0 = variable_expand(line);
#line 462
  current_variable_set_list = save;
#line 463
  reading_file = (struct floc  const  *)0;
#line 465
  return (result___0);
}
}
#line 471 "expand.c"
static char *allocated_variable_append(struct variable *v ) 
{ 
  struct variable_set_list *save ;
  int len ;
  size_t tmp ;
  char *var ;
  void *tmp___0 ;
  char *value ;
  char *obuf ;
  unsigned int olen ;
  size_t tmp___2 ;

  {
#line 476
  tmp = strlen((char const   *)v->name);
#line 476
  len = (int )tmp;
#line 477
  tmp___0 = __builtin_alloca((unsigned long )(len + 4));
#line 477
  var = (char *)tmp___0;
#line 480
  obuf = variable_buffer;
#line 481
  olen = variable_buffer_length;
#line 483
  variable_buffer = (char *)0;
#line 485
  if (! ((unsigned long )current_variable_set_list->next != (unsigned long )((struct variable_set_list *)0))) {
#line 485
    __assert_fail("current_variable_set_list->next != 0", "expand.c", 485U, "allocated_variable_append");
  }
#line 486
  save = current_variable_set_list;
#line 487
  current_variable_set_list = current_variable_set_list->next;
#line 489
  *(var + 0) = (char )'$';
#line 490
  *(var + 1) = (char )'(';
#line 491
  strcpy((char * __restrict  )(var + 2), (char const   * __restrict  )v->name);
#line 492
  *(var + (len + 2)) = (char )')';
#line 493
  *(var + (len + 3)) = (char )'\000';
#line 495
  value = variable_expand_for_file(var, (struct file *)0);
#line 497
  current_variable_set_list = save;
#line 499
  tmp___2 = strlen((char const   *)value);
#line 499
  value += tmp___2;
#line 500
  value = variable_buffer_output(value, (char *)" ", 1U);
#line 501
  value = variable_expand_string(value, v->value, -1L);
#line 503
  value = variable_buffer;
#line 510
  variable_buffer = obuf;
#line 511
  variable_buffer_length = olen;
#line 513
  return (value);
}
}
#line 519 "expand.c"
char *allocated_variable_expand_for_file(char *line , struct file *file ) 
{ 
  char *value ;
  char *obuf ;
  unsigned int olen ;

  {
#line 526
  obuf = variable_buffer;
#line 527
  olen = variable_buffer_length;
#line 529
  variable_buffer = (char *)0;
#line 531
  value = variable_expand_for_file(line, file);
#line 538
  variable_buffer = obuf;
#line 539
  variable_buffer_length = olen;
#line 541
  return (value);
}
}
#line 1 "file.o"
#pragma merger("0","/tmp/cil-gHomNjr1.i","-g,-O0")
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 204
extern int fflush(FILE *__stream ) ;
#line 524
extern int putchar(int __c ) ;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 470 "make.h"
int just_print_flag ;
#line 470
int silent_flag ;
#line 470
int ignore_errors_flag ;
#line 471
int question_flag ;
#line 471
int touch_flag ;
#line 474
int posix_pedantic ;
#line 474
int not_parallel ;
#line 99 "filedef.h"
unsigned int num_intermediates ;
#line 103
unsigned int considered ;
#line 111
void snap_deps(void) ;
#line 112
void rename_file(struct file *file , char *name ) ;
#line 113
void rehash_file(struct file *file , char *name ) ;
#line 114
void file_hash_enter(struct file *file , char *name , unsigned int oldhash , char *oldname ) ;
#line 162
uintmax_t file_timestamp_now(void) ;
#line 163
void file_timestamp_sprintf(char *p , uintmax_t ts ) ;
#line 106 "variable.h"
void print_file_variables(struct file *file ) ;
#line 108
void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) ;
#line 137
int export_all_variables ;
#line 35 "file.c"
static struct file *files[1007]  ;
#line 39 "file.c"
unsigned int num_intermediates  =    0U;
#line 43 "file.c"
unsigned int considered  =    0U;
#line 50 "file.c"
struct file *lookup_file(char *name ) 
{ 
  register struct file *f ;
  register char *n ;
  register unsigned int hashval ;
  int tmp___0 ;

  {
#line 61
  if (! ((int )*name != 0)) {
#line 61
    __assert_fail("*name != \'\\0\'", "file.c", 61U, "lookup_file");
  }
#line 78
  while (1) {
#line 78
    if ((int )*(name + 0) == 46) {
#line 78
      if ((int )*(name + 1) == 47) {
#line 78
        if (! ((int )*(name + 2) != 0)) {
#line 78
          break;
        }
      } else {
#line 78
        break;
      }
    } else {
#line 78
      break;
    }
#line 80
    name += 2;
#line 81
    while ((int )*name == 47) {
#line 83
      name ++;
    }
  }
#line 86
  if ((int )*name == 0) {
#line 94
    name = (char *)"./";
  }
#line 98
  hashval = 0U;
#line 99
  n = name;
#line 99
  while ((int )*n != 0) {
#line 100
    hashval += (unsigned int )*n;
#line 100
    hashval = (hashval << 7) + (hashval >> 20);
#line 99
    n ++;
  }
#line 101
  hashval %= 1007U;
#line 103
  f = files[hashval];
#line 103
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 105
    if ((unsigned long )f->hname == (unsigned long )name) {
#line 110
      return (f);
    } else
#line 105
    if ((int )*(f->hname) == (int )*name) {
#line 105
      if ((int )*(f->hname) == 0) {
#line 110
        return (f);
      } else {
#line 105
        tmp___0 = strcmp((char const   *)(f->hname + 1), (char const   *)(name + 1));
#line 105
        if (! tmp___0) {
#line 110
          return (f);
        }
      }
    }
#line 103
    f = f->next;
  }
#line 116
  return ((struct file *)0);
}
}
#line 119 "file.c"
struct file *enter_file(char *name ) 
{ 
  register struct file *f ;
  register struct file *new ;
  register char *n ;
  register unsigned int hashval ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 130
  if (! ((int )*name != 0)) {
#line 130
    __assert_fail("*name != \'\\0\'", "file.c", 130U, "enter_file");
  }
#line 147
  hashval = 0U;
#line 148
  n = name;
#line 148
  while ((int )*n != 0) {
#line 149
    hashval += (unsigned int )*n;
#line 149
    hashval = (hashval << 7) + (hashval >> 20);
#line 148
    n ++;
  }
#line 150
  hashval %= 1007U;
#line 152
  f = files[hashval];
#line 152
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 153
    if ((unsigned long )f->hname == (unsigned long )name) {
#line 154
      break;
    } else
#line 153
    if ((int )*(f->hname) == (int )*name) {
#line 153
      if ((int )*(f->hname) == 0) {
#line 154
        break;
      } else {
#line 153
        tmp___0 = strcmp((char const   *)(f->hname + 1), (char const   *)(name + 1));
#line 153
        if (! tmp___0) {
#line 154
          break;
        }
      }
    }
#line 152
    f = f->next;
  }
#line 156
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 156
    if (! f->double_colon) {
#line 161
      return (f);
    }
  }
#line 164
  tmp___1 = xmalloc((unsigned int )sizeof(struct file ));
#line 164
  new = (struct file *)tmp___1;
#line 165
  memset((void *)((char *)new), 0, sizeof(struct file ));
#line 166
  tmp___2 = name;
#line 166
  new->hname = tmp___2;
#line 166
  new->name = tmp___2;
#line 167
  new->update_status = (short)-1;
#line 169
  if ((unsigned long )f == (unsigned long )((struct file *)0)) {
#line 172
    new->next = files[hashval];
#line 173
    files[hashval] = new;
  } else {
#line 178
    new->double_colon = f;
#line 179
    while ((unsigned long )f->prev != (unsigned long )((struct file *)0)) {
#line 180
      f = f->prev;
    }
#line 181
    f->prev = new;
  }
#line 184
  return (new);
}
}
#line 191 "file.c"
void rehash_file(struct file *file , char *name ) 
{ 
  char *oldname ;
  register unsigned int oldhash ;
  register char *n ;

  {
#line 196
  oldname = file->hname;
#line 200
  while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 201
    file = file->renamed;
  }
#line 205
  oldhash = 0U;
#line 206
  n = oldname;
#line 206
  while ((int )*n != 0) {
#line 207
    oldhash += (unsigned int )*n;
#line 207
    oldhash = (oldhash << 7) + (oldhash >> 20);
#line 206
    n ++;
  }
#line 209
  file_hash_enter(file, name, oldhash, file->name);
#line 210
  return;
}
}
#line 216 "file.c"
void rename_file(struct file *file , char *name ) 
{ 


  {
#line 221
  rehash_file(file, name);
#line 222
  while (file) {
#line 224
    file->name = file->hname;
#line 225
    file = file->prev;
  }
#line 227
  return;
}
}
#line 229 "file.c"
void file_hash_enter(struct file *file , char *name , unsigned int oldhash , char *oldname ) 
{ 
  unsigned int oldbucket ;
  register unsigned int newhash ;
  register unsigned int newbucket ;
  struct file *oldfile ;
  register char *n ;
  register struct file *f ;
  int tmp ;
  struct file *lastf ;
  register struct dep *d ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 236
  oldbucket = oldhash % 1007U;
#line 242
  newhash = 0U;
#line 243
  n = name;
#line 243
  while ((int )*n != 0) {
#line 244
    newhash += (unsigned int )*n;
#line 244
    newhash = (newhash << 7) + (newhash >> 20);
#line 243
    n ++;
  }
#line 245
  newbucket = newhash % 1007U;
#line 249
  oldfile = files[newbucket];
#line 249
  while ((unsigned long )oldfile != (unsigned long )((struct file *)0)) {
#line 250
    if ((unsigned long )oldfile->hname == (unsigned long )name) {
#line 251
      break;
    } else
#line 250
    if ((int )*(oldfile->hname) == (int )*name) {
#line 250
      if ((int )*(oldfile->hname) == 0) {
#line 251
        break;
      } else {
#line 250
        tmp = strcmp((char const   *)(oldfile->hname + 1), (char const   *)(name + 1));
#line 250
        if (! tmp) {
#line 251
          break;
        }
      }
    }
#line 249
    oldfile = oldfile->next;
  }
#line 254
  if ((unsigned long )oldfile == (unsigned long )file) {
#line 255
    return;
  }
#line 257
  if (oldhash != 0U) {
#line 257
    if (newbucket != oldbucket) {
#line 257
      goto _L;
    } else
#line 257
    if ((unsigned long )oldfile != (unsigned long )((struct file *)0)) {
      _L: /* CIL Label */ 
#line 261
      lastf = (struct file *)0;
#line 263
      f = files[oldbucket];
#line 263
      while ((unsigned long )f != (unsigned long )file) {
#line 264
        lastf = f;
#line 263
        f = f->next;
      }
#line 266
      if ((unsigned long )lastf == (unsigned long )((struct file *)0)) {
#line 267
        files[oldbucket] = f->next;
      } else {
#line 269
        lastf->next = f->next;
      }
    }
  }
#line 274
  file->hname = name;
#line 275
  f = file->double_colon;
#line 275
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 276
    f->hname = name;
#line 275
    f = f->prev;
  }
#line 278
  if ((unsigned long )oldfile == (unsigned long )((struct file *)0)) {
#line 282
    if (newbucket != oldbucket) {
#line 285
      file->next = files[newbucket];
#line 286
      files[newbucket] = file;
    }
  } else {
#line 296
    if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
#line 298
      if ((unsigned long )oldfile->cmds == (unsigned long )((struct commands *)0)) {
#line 299
        oldfile->cmds = file->cmds;
      } else
#line 300
      if ((unsigned long )file->cmds != (unsigned long )oldfile->cmds) {
#line 305
        if ((unsigned long )(oldfile->cmds)->fileinfo.filenm != (unsigned long )((char *)0)) {
#line 306
          tmp___0 = dcgettext((char const   *)((void *)0), "Commands were specified for file `%s\' at %s:%lu,",
                              5);
#line 306
          error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___0,
                oldname, (oldfile->cmds)->fileinfo.filenm, (oldfile->cmds)->fileinfo.lineno);
        } else {
#line 312
          tmp___1 = dcgettext((char const   *)((void *)0), "Commands for file `%s\' were found by implicit rule search,",
                              5);
#line 312
          error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___1,
                oldname);
        }
#line 316
        tmp___2 = dcgettext((char const   *)((void *)0), "but `%s\' is now considered the same file as `%s\'.",
                            5);
#line 316
        error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___2,
              oldname, name);
#line 320
        tmp___3 = dcgettext((char const   *)((void *)0), "Commands for `%s\' will be ignored in favor of those for `%s\'.",
                            5);
#line 320
        error((struct floc  const  *)(& (file->cmds)->fileinfo), (char const   *)tmp___3,
              name, oldname);
      }
    }
#line 329
    d = oldfile->deps;
#line 330
    if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
#line 331
      oldfile->deps = file->deps;
    } else {
#line 334
      while ((unsigned long )d->next != (unsigned long )((struct dep *)0)) {
#line 335
        d = d->next;
      }
#line 336
      d->next = file->deps;
    }
#line 339
    merge_variable_set_lists(& oldfile->variables, file->variables);
#line 341
    if (oldfile->double_colon) {
#line 341
      if (file->is_target) {
#line 341
        if (! file->double_colon) {
#line 342
          tmp___4 = dcgettext((char const   *)((void *)0), "can\'t rename single-colon `%s\' to double-colon `%s\'",
                              5);
#line 342
          fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___4,
                oldname, name);
        }
      }
    }
#line 344
    if (! oldfile->double_colon) {
#line 344
      if (file->double_colon) {
#line 346
        if (oldfile->is_target) {
#line 347
          tmp___5 = dcgettext((char const   *)((void *)0), "can\'t rename double-colon `%s\' to single-colon `%s\'",
                              5);
#line 347
          fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___5,
                oldname, name);
        } else {
#line 350
          oldfile->double_colon = file->double_colon;
        }
      }
    }
#line 353
    if (file->last_mtime > oldfile->last_mtime) {
#line 355
      oldfile->last_mtime = file->last_mtime;
    }
#line 357
    oldfile->mtime_before_update = file->mtime_before_update;
#line 360
    oldfile->precious |= file->precious;
#line 361
    oldfile->tried_implicit |= file->tried_implicit;
#line 362
    oldfile->updating |= file->updating;
#line 363
    oldfile->updated |= file->updated;
#line 364
    oldfile->is_target |= file->is_target;
#line 365
    oldfile->cmd_target |= file->cmd_target;
#line 366
    oldfile->phony |= file->phony;
#line 367
    oldfile->ignore_vpath |= file->ignore_vpath;
#line 370
    file->renamed = oldfile;
  }
#line 372
  return;
}
}
#line 379 "file.c"
void remove_intermediates(int sig ) 
{ 
  register int i ;
  register struct file *f ;
  char doneany ;
  int status ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 387
  if (question_flag) {
#line 388
    return;
  } else
#line 387
  if (touch_flag) {
#line 388
    return;
  }
#line 389
  if (sig) {
#line 389
    if (just_print_flag) {
#line 390
      return;
    }
  }
#line 392
  doneany = (char)0;
#line 393
  i = 0;
#line 393
  while (i < 1007) {
#line 394
    f = files[i];
#line 394
    while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 395
      if (f->intermediate) {
#line 395
        if (f->dontcare) {
#line 395
          goto _L;
        } else
#line 395
        if (! f->precious) {
          _L: /* CIL Label */ 
#line 395
          if (! f->secondary) {
#line 395
            if (! f->cmd_target) {
#line 399
              if ((int )f->update_status == -1) {
#line 402
                goto __Cont;
              } else
#line 403
              if (just_print_flag) {
#line 404
                status = 0;
              } else {
#line 407
                status = unlink((char const   *)f->name);
#line 408
                if (status < 0) {
#line 408
                  tmp = __errno_location();
#line 408
                  if (*tmp == 2) {
#line 409
                    goto __Cont;
                  }
                }
              }
#line 411
              if (! f->dontcare) {
#line 413
                if (sig) {
#line 414
                  tmp___0 = dcgettext((char const   *)((void *)0), "*** Deleting intermediate file `%s\'",
                                      5);
#line 414
                  error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0,
                        f->name);
                } else
#line 415
                if (! silent_flag) {
#line 417
                  if (! doneany) {
#line 419
                    fputs((char const   * __restrict  )"rm ", (FILE * __restrict  )stdout);
#line 420
                    doneany = (char)1;
                  } else {
#line 423
                    putchar(' ');
                  }
#line 424
                  fputs((char const   * __restrict  )f->name, (FILE * __restrict  )stdout);
#line 425
                  fflush(stdout);
                }
#line 427
                if (status < 0) {
#line 428
                  perror_with_name((char *)"unlink: ", f->name);
                }
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 394
      f = f->next;
    }
#line 393
    i ++;
  }
#line 432
  if (doneany) {
#line 432
    if (! sig) {
#line 434
      putchar('\n');
#line 435
      fflush(stdout);
    }
  }
#line 437
  return;
}
}
#line 445 "file.c"
void snap_deps(void) 
{ 
  register struct file *f ;
  register struct file *f2 ;
  register struct dep *d ;
  register int i ;
  unsigned int tmp ;
  int i___0 ;
  unsigned int tmp___0 ;

  {
#line 453
  i = 0;
#line 453
  while (i < 1007) {
#line 454
    f = files[i];
#line 454
    while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 455
      f2 = f;
#line 455
      while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
#line 456
        d = f2->deps;
#line 456
        while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 457
          if ((unsigned long )d->name != (unsigned long )((char *)0)) {
#line 459
            d->file = lookup_file(d->name);
#line 460
            if ((unsigned long )d->file == (unsigned long )((struct file *)0)) {
#line 461
              d->file = enter_file(d->name);
            } else {
#line 463
              free((void *)d->name);
            }
#line 464
            d->name = (char *)0;
          }
#line 456
          d = d->next;
        }
#line 455
        f2 = f2->prev;
      }
#line 454
      f = f->next;
    }
#line 453
    i ++;
  }
#line 467
  f = lookup_file((char *)".PRECIOUS");
#line 467
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 468
    d = f->deps;
#line 468
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 469
      f2 = d->file;
#line 469
      while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
#line 470
        f2->precious = 1U;
#line 469
        f2 = f2->prev;
      }
#line 468
      d = d->next;
    }
#line 467
    f = f->prev;
  }
#line 472
  f = lookup_file((char *)".PHONY");
#line 472
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 473
    d = f->deps;
#line 473
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 474
      f2 = d->file;
#line 474
      while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
#line 477
        f2->phony = 1U;
#line 478
        f2->last_mtime = (uintmax_t )-1;
#line 479
        f2->mtime_before_update = (uintmax_t )-1;
#line 474
        f2 = f2->prev;
      }
#line 473
      d = d->next;
    }
#line 472
    f = f->prev;
  }
#line 482
  f = lookup_file((char *)".INTERMEDIATE");
#line 482
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 486
    d = f->deps;
#line 486
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 487
      f2 = d->file;
#line 487
      while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
#line 488
        f2->intermediate = 1U;
#line 487
        f2 = f2->prev;
      }
#line 486
      d = d->next;
    }
#line 482
    f = f->prev;
  }
#line 494
  f = lookup_file((char *)".SECONDARY");
#line 494
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 501
    if (f->deps) {
#line 503
      d = f->deps;
#line 503
      while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 504
        f2 = d->file;
#line 504
        while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
#line 505
          tmp = 1U;
#line 505
          f2->secondary = tmp;
#line 505
          f2->intermediate = tmp;
#line 504
          f2 = f2->prev;
        }
#line 503
        d = d->next;
      }
    } else {
#line 511
      i___0 = 0;
#line 511
      while (i___0 < 1007) {
#line 512
        f2 = files[i___0];
#line 512
        while (f2) {
#line 513
          tmp___0 = 1U;
#line 513
          f2->secondary = tmp___0;
#line 513
          f2->intermediate = tmp___0;
#line 512
          f2 = f2->next;
        }
#line 511
        i___0 ++;
      }
    }
#line 494
    f = f->prev;
  }
#line 517
  f = lookup_file((char *)".EXPORT_ALL_VARIABLES");
#line 518
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 518
    if (f->is_target) {
#line 519
      export_all_variables = 1;
    }
  }
#line 521
  f = lookup_file((char *)".IGNORE");
#line 522
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 522
    if (f->is_target) {
#line 524
      if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
#line 525
        ignore_errors_flag = 1;
      } else {
#line 527
        d = f->deps;
#line 527
        while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 528
          f2 = d->file;
#line 528
          while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
#line 529
            f2->command_flags |= 4;
#line 528
            f2 = f2->prev;
          }
#line 527
          d = d->next;
        }
      }
    }
  }
#line 532
  f = lookup_file((char *)".SILENT");
#line 533
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 533
    if (f->is_target) {
#line 535
      if ((unsigned long )f->deps == (unsigned long )((struct dep *)0)) {
#line 536
        silent_flag = 1;
      } else {
#line 538
        d = f->deps;
#line 538
        while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 539
          f2 = d->file;
#line 539
          while ((unsigned long )f2 != (unsigned long )((struct file *)0)) {
#line 540
            f2->command_flags |= 2;
#line 539
            f2 = f2->prev;
          }
#line 538
          d = d->next;
        }
      }
    }
  }
#line 543
  f = lookup_file((char *)".POSIX");
#line 544
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 544
    if (f->is_target) {
#line 545
      posix_pedantic = 1;
    }
  }
#line 547
  f = lookup_file((char *)".NOTPARALLEL");
#line 548
  if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 548
    if (f->is_target) {
#line 549
      not_parallel = 1;
    }
  }
#line 550
  return;
}
}
#line 554 "file.c"
void set_command_state(struct file *file , int state ) 
{ 
  struct dep *d ;

  {
#line 561
  file->command_state = (enum __anonenum_command_state_55 )state;
#line 563
  d = file->also_make;
#line 563
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 564
    (d->file)->command_state = (enum __anonenum_command_state_55 )state;
#line 563
    d = d->next;
  }
#line 565
  return;
}
}
#line 569 "file.c"
uintmax_t file_timestamp_now(void) 
{ 
  struct timespec timespec ;
  uintmax_t tmp ;
  uintmax_t tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  uintmax_t tmp___3 ;
  uintmax_t tmp___4 ;

  {
#line 574
  tmp___1 = clock_gettime(0, & timespec);
#line 574
  if (tmp___1 == 0) {
#line 575
    if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 575
      tmp = (uintmax_t )1000000000;
    } else {
#line 575
      tmp = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
    }
#line 575
    if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 575
      tmp___0 = (uintmax_t )1000000000;
    } else {
#line 575
      tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
    }
#line 575
    return ((uintmax_t )timespec.tv_sec * tmp + ((uintmax_t )timespec.tv_nsec * tmp___0) / 1000000000UL);
  }
#line 577
  tmp___2 = time((time_t *)0);
#line 577
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 577
    tmp___3 = (uintmax_t )1000000000;
  } else {
#line 577
    tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 577
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 577
    tmp___4 = (uintmax_t )1000000000;
  } else {
#line 577
    tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 577
  return ((uintmax_t )tmp___2 * tmp___3);
}
}
#line 580 "file.c"
void file_timestamp_sprintf(char *p , uintmax_t ts ) 
{ 
  time_t t ;
  uintmax_t tmp ;
  uintmax_t tmp___0 ;
  struct tm *tm ;
  struct tm *tmp___1 ;
  size_t tmp___2 ;
  uintmax_t tmp___3 ;
  uintmax_t tmp___4 ;
  uintmax_t tmp___5 ;
  uintmax_t tmp___6 ;
  uintmax_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 585
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 585
    tmp = (uintmax_t )1000000000;
  } else {
#line 585
    tmp = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 585
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 585
    tmp___0 = (uintmax_t )1000000000;
  } else {
#line 585
    tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 585
  t = (time_t )(ts / tmp - (uintmax_t )(ts % tmp___0 < 0UL));
#line 586
  tmp___1 = localtime((time_t const   *)(& t));
#line 586
  tm = tmp___1;
#line 588
  if (tm) {
#line 589
    sprintf((char * __restrict  )p, (char const   * __restrict  )"%04d-%02d-%02d %02d:%02d:%02d",
            tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min,
            tm->tm_sec);
  } else
#line 592
  if (t < 0L) {
#line 593
    sprintf((char * __restrict  )p, (char const   * __restrict  )"%ld", t);
  } else {
#line 595
    sprintf((char * __restrict  )p, (char const   * __restrict  )"%lu", (unsigned long )t);
  }
#line 596
  tmp___2 = strlen((char const   *)p);
#line 596
  p += tmp___2;
#line 603
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 603
    tmp___3 = (uintmax_t )1000000000;
  } else {
#line 603
    tmp___3 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 603
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 603
    tmp___4 = (uintmax_t )1000000000;
  } else {
#line 603
    tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 603
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 603
    tmp___5 = (uintmax_t )1000000000;
  } else {
#line 603
    tmp___5 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 603
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 603
    tmp___6 = (uintmax_t )1000000000;
  } else {
#line 603
    tmp___6 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 603
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 603
    tmp___7 = (uintmax_t )1000000000;
  } else {
#line 603
    tmp___7 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 603
  sprintf((char * __restrict  )p, (char const   * __restrict  )".%09ld", (long )(((ts % tmp___3 + (uintmax_t )(ts % tmp___4 < 0UL) * tmp___5) * 1000000000UL + (tmp___6 - 1UL)) / tmp___7));
#line 604
  tmp___8 = strlen((char const   *)p);
#line 604
  p += tmp___8 - 1UL;
#line 605
  while ((int )*p == 48) {
#line 606
    p --;
  }
#line 607
  p += (int )*p != 46;
#line 609
  *p = (char )'\000';
#line 610
  return;
}
}
#line 614 "file.c"
static void print_file(struct file *f ) 
{ 
  register struct dep *d ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char buf___1[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
#line 620
  putchar('\n');
#line 621
  if (! f->is_target) {
#line 622
    tmp = dcgettext((char const   *)((void *)0), "# Not a target:", 5);
#line 622
    puts((char const   *)tmp);
  }
#line 623
  if (f->double_colon) {
#line 623
    tmp___0 = ":";
  } else {
#line 623
    tmp___0 = "";
  }
#line 623
  printf((char const   * __restrict  )"%s:%s", f->name, tmp___0);
#line 625
  d = f->deps;
#line 625
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 626
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 626
      tmp___1 = (d->file)->name;
    } else {
#line 626
      tmp___1 = d->name;
    }
#line 626
    printf((char const   * __restrict  )" %s", tmp___1);
#line 625
    d = d->next;
  }
#line 627
  putchar('\n');
#line 629
  if (f->precious) {
#line 630
    tmp___2 = dcgettext((char const   *)((void *)0), "#  Precious file (prerequisite of .PRECIOUS).",
                        5);
#line 630
    puts((char const   *)tmp___2);
  }
#line 631
  if (f->phony) {
#line 632
    tmp___3 = dcgettext((char const   *)((void *)0), "#  Phony target (prerequisite of .PHONY).",
                        5);
#line 632
    puts((char const   *)tmp___3);
  }
#line 633
  if (f->cmd_target) {
#line 634
    tmp___4 = dcgettext((char const   *)((void *)0), "#  Command-line target.", 5);
#line 634
    puts((char const   *)tmp___4);
  }
#line 635
  if (f->dontcare) {
#line 636
    tmp___5 = dcgettext((char const   *)((void *)0), "#  A default or MAKEFILES makefile.",
                        5);
#line 636
    puts((char const   *)tmp___5);
  }
#line 637
  if (f->tried_implicit) {
#line 637
    tmp___6 = dcgettext((char const   *)((void *)0), "#  Implicit rule search has been done.",
                        5);
#line 637
    tmp___8 = tmp___6;
  } else {
#line 637
    tmp___7 = dcgettext((char const   *)((void *)0), "#  Implicit rule search has not been done.",
                        5);
#line 637
    tmp___8 = tmp___7;
  }
#line 637
  puts((char const   *)tmp___8);
#line 640
  if ((unsigned long )f->stem != (unsigned long )((char *)0)) {
#line 641
    tmp___9 = dcgettext((char const   *)((void *)0), "#  Implicit/static pattern stem: `%s\'\n",
                        5);
#line 641
    printf((char const   * __restrict  )tmp___9, f->stem);
  }
#line 642
  if (f->intermediate) {
#line 643
    tmp___10 = dcgettext((char const   *)((void *)0), "#  File is an intermediate prerequisite.",
                         5);
#line 643
    puts((char const   *)tmp___10);
  }
#line 644
  if ((unsigned long )f->also_make != (unsigned long )((struct dep *)0)) {
#line 646
    tmp___11 = dcgettext((char const   *)((void *)0), "#  Also makes:", 5);
#line 646
    fputs((char const   * __restrict  )tmp___11, (FILE * __restrict  )stdout);
#line 647
    d = f->also_make;
#line 647
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 648
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 648
        tmp___12 = (d->file)->name;
      } else {
#line 648
        tmp___12 = d->name;
      }
#line 648
      printf((char const   * __restrict  )" %s", tmp___12);
#line 647
      d = d->next;
    }
#line 649
    putchar('\n');
  }
#line 651
  if (f->last_mtime == 0UL) {
#line 652
    tmp___13 = dcgettext((char const   *)((void *)0), "#  Modification time never checked.",
                         5);
#line 652
    puts((char const   *)tmp___13);
  } else
#line 653
  if (f->last_mtime == 0xffffffffffffffffUL) {
#line 654
    tmp___14 = dcgettext((char const   *)((void *)0), "#  File does not exist.", 5);
#line 654
    puts((char const   *)tmp___14);
  } else {
#line 658
    file_timestamp_sprintf(buf___1, f->last_mtime);
#line 659
    tmp___15 = dcgettext((char const   *)((void *)0), "#  Last modified %s\n", 5);
#line 659
    printf((char const   * __restrict  )tmp___15, buf___1);
  }
#line 661
  if (f->updated) {
#line 661
    tmp___16 = dcgettext((char const   *)((void *)0), "#  File has been updated.",
                         5);
#line 661
    tmp___18 = tmp___16;
  } else {
#line 661
    tmp___17 = dcgettext((char const   *)((void *)0), "#  File has not been updated.",
                         5);
#line 661
    tmp___18 = tmp___17;
  }
#line 661
  puts((char const   *)tmp___18);
#line 663
  switch ((unsigned int )f->command_state) {
  case 2U: 
#line 666
  tmp___19 = dcgettext((char const   *)((void *)0), "#  Commands currently running (THIS IS A BUG).",
                       5);
#line 666
  puts((char const   *)tmp___19);
#line 667
  break;
  case 1U: 
#line 669
  tmp___20 = dcgettext((char const   *)((void *)0), "#  Dependencies commands running (THIS IS A BUG).",
                       5);
#line 669
  puts((char const   *)tmp___20);
#line 670
  break;
  case 3U: 
  case 0U: 
#line 673
  switch ((int )f->update_status) {
  case -1: 
#line 676
  break;
  case 0: 
#line 678
  tmp___21 = dcgettext((char const   *)((void *)0), "#  Successfully updated.", 5);
#line 678
  puts((char const   *)tmp___21);
#line 679
  break;
  case 1: 
#line 681
  if (! question_flag) {
#line 681
    __assert_fail("question_flag", "file.c", 681U, "print_file");
  }
#line 682
  tmp___23 = dcgettext((char const   *)((void *)0), "#  Needs to be updated (-q is set).",
                       5);
#line 682
  puts((char const   *)tmp___23);
#line 683
  break;
  case 2: 
#line 685
  tmp___24 = dcgettext((char const   *)((void *)0), "#  Failed to be updated.", 5);
#line 685
  puts((char const   *)tmp___24);
#line 686
  break;
  default: 
#line 688
  tmp___25 = dcgettext((char const   *)((void *)0), "#  Invalid value in `update_status\' member!",
                       5);
#line 688
  puts((char const   *)tmp___25);
#line 689
  fflush(stdout);
#line 690
  fflush(stderr);
#line 691
  abort();
  }
#line 693
  break;
  default: 
#line 695
  tmp___26 = dcgettext((char const   *)((void *)0), "#  Invalid value in `command_state\' member!",
                       5);
#line 695
  puts((char const   *)tmp___26);
#line 696
  fflush(stdout);
#line 697
  fflush(stderr);
#line 698
  abort();
  }
#line 701
  if ((unsigned long )f->variables != (unsigned long )((struct variable_set_list *)0)) {
#line 702
    print_file_variables(f);
  }
#line 704
  if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
#line 705
    print_commands(f->cmds);
  }
#line 706
  return;
}
}
#line 708 "file.c"
void print_file_data_base(void) 
{ 
  register unsigned int i ;
  register unsigned int nfiles ;
  register unsigned int per_bucket ;
  register struct file *file ;
  char *tmp ;
  register unsigned int this_bucket ;
  register struct file *f ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 714
  tmp = dcgettext((char const   *)((void *)0), "\n# Files", 5);
#line 714
  puts((char const   *)tmp);
#line 716
  nfiles = 0U;
#line 716
  per_bucket = nfiles;
#line 717
  i = 0U;
#line 717
  while (i < 1007U) {
#line 719
    this_bucket = 0U;
#line 721
    file = files[i];
#line 721
    while ((unsigned long )file != (unsigned long )((struct file *)0)) {
#line 725
      this_bucket ++;
#line 727
      f = file;
#line 727
      while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 728
        print_file(f);
#line 727
        f = f->prev;
      }
#line 721
      file = file->next;
    }
#line 731
    nfiles += this_bucket;
#line 732
    if (this_bucket > per_bucket) {
#line 733
      per_bucket = this_bucket;
    }
#line 717
    i ++;
  }
#line 736
  if (nfiles == 0U) {
#line 737
    tmp___0 = dcgettext((char const   *)((void *)0), "\n# No files.", 5);
#line 737
    puts((char const   *)tmp___0);
  } else {
#line 740
    tmp___1 = dcgettext((char const   *)((void *)0), "\n# %u files in %u hash buckets.\n",
                        5);
#line 740
    printf((char const   * __restrict  )tmp___1, nfiles, 1007);
#line 742
    tmp___2 = dcgettext((char const   *)((void *)0), "# average %.3f files per bucket, max %u files in one bucket.\n",
                        5);
#line 742
    printf((char const   * __restrict  )tmp___2, (double )nfiles / (double )1007,
           per_bucket);
  }
#line 746
  return;
}
}
#line 1 "function.o"
#pragma merger("0","/tmp/cil-h0UywAXH.i","-g,-O0")
#line 144 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 767
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 398 "make.h"
char *find_next_token(char **ptr , unsigned int *lengthptr ) ;
#line 399
char *next_token(char *s ) ;
#line 400
char *end_of_token(char *s ) ;
#line 468
extern char **environ ;
#line 91 "variable.h"
int pattern_matches(char *pattern , char *percent , char *str ) ;
#line 102
struct variable_set_list *push_new_variable_scope(void) ;
#line 103
void pop_variable_scope(void) ;
#line 54 "dep.h"
struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) ;
#line 58
struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                               int strip ) ;
#line 57 "job.h"
char **construct_command_argv(char *line , char **restp , struct file *file , char **batch_filename_ptr ) ;
#line 61
void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) ;
#line 30 "debug.h"
int db_level ;
#line 51 "function.c"
char *subst_expand(char *o , char *text , char *subst , char *replace , unsigned int slen ,
                   unsigned int rlen , int by_word , int suffix_only ) 
{ 
  register char *t ;
  register char *p ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 59
  t = text;
#line 62
  if (slen == 0U) {
#line 62
    if (! by_word) {
#line 62
      if (! suffix_only) {
#line 65
        tmp = strlen((char const   *)t);
#line 65
        o = variable_buffer_output(o, t, (unsigned int )tmp);
#line 66
        if (rlen > 0U) {
#line 67
          o = variable_buffer_output(o, replace, rlen);
        }
#line 68
        return (o);
      }
    }
  }
#line 71
  while (1) {
#line 73
    if (by_word | suffix_only) {
#line 73
      if (slen == 0U) {
#line 76
        tmp___0 = next_token(t);
#line 76
        p = end_of_token(tmp___0);
      } else {
#line 73
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 79
      p = sindex((char const   *)t, 0U, (char const   *)subst, slen);
#line 80
      if ((unsigned long )p == (unsigned long )((char *)0)) {
#line 83
        tmp___1 = strlen((char const   *)t);
#line 83
        o = variable_buffer_output(o, t, (unsigned int )tmp___1);
#line 84
        return (o);
      }
    }
#line 89
    if ((unsigned long )p > (unsigned long )t) {
#line 90
      o = variable_buffer_output(o, t, (unsigned int )(p - t));
    }
#line 94
    if (by_word) {
#line 94
      if ((unsigned long )p > (unsigned long )t) {
#line 94
        tmp___2 = __ctype_b_loc();
#line 94
        if ((int const   )*(*tmp___2 + (int )*(p + -1)) & 1) {
#line 94
          goto _L___2;
        } else {
#line 101
          o = variable_buffer_output(o, subst, slen);
        }
      } else
      _L___2: /* CIL Label */ 
#line 94
      if ((int )*(p + slen) != 0) {
#line 94
        tmp___3 = __ctype_b_loc();
#line 94
        if ((int const   )*(*tmp___3 + (int )*(p + slen)) & 1) {
#line 94
          goto _L___1;
        } else {
#line 101
          o = variable_buffer_output(o, subst, slen);
        }
      } else {
#line 94
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 94
    if (suffix_only) {
#line 94
      if ((int )*(p + slen) != 0) {
#line 94
        tmp___4 = __ctype_b_loc();
#line 94
        if ((int const   )*(*tmp___4 + (int )*(p + slen)) & 1) {
#line 94
          goto _L___0;
        } else {
#line 101
          o = variable_buffer_output(o, subst, slen);
        }
      } else {
#line 94
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 102
    if (rlen > 0U) {
#line 104
      o = variable_buffer_output(o, replace, rlen);
    }
#line 107
    t = p + slen;
#line 71
    if (! ((int )*t != 0)) {
#line 71
      break;
    }
  }
#line 110
  return (o);
}
}
#line 121 "function.c"
char *patsubst_expand(char *o , char *text , char *pattern , char *replace , char *pattern_percent ,
                      char *replace_percent ) 
{ 
  unsigned int pattern_prepercent_len ;
  unsigned int pattern_postpercent_len ;
  unsigned int replace_prepercent_len ;
  unsigned int replace_postpercent_len ;
  char *t ;
  int len ;
  int doneany ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int fail ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 129
  replace_postpercent_len = 0U;
#line 132
  doneany = 0;
#line 136
  if ((unsigned long )replace_percent == (unsigned long )((char *)0)) {
#line 137
    replace_percent = find_percent(replace);
  }
#line 138
  if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
#line 142
    replace_prepercent_len = (unsigned int )(replace_percent - replace);
#line 143
    tmp = strlen((char const   *)(replace_percent + 1));
#line 143
    replace_postpercent_len = (unsigned int )tmp;
  } else {
#line 148
    tmp___0 = strlen((char const   *)replace);
#line 148
    replace_prepercent_len = (unsigned int )tmp___0;
  }
#line 150
  if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
#line 151
    pattern_percent = find_percent(pattern);
  }
#line 152
  if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
#line 154
    tmp___1 = strlen((char const   *)replace);
#line 154
    tmp___2 = strlen((char const   *)pattern);
#line 154
    tmp___3 = subst_expand(o, text, pattern, replace, (unsigned int )tmp___2, (unsigned int )tmp___1,
                           1, 0);
#line 154
    return (tmp___3);
  }
#line 159
  pattern_prepercent_len = (unsigned int )(pattern_percent - pattern);
#line 160
  tmp___4 = strlen((char const   *)(pattern_percent + 1));
#line 160
  pattern_postpercent_len = (unsigned int )tmp___4;
#line 162
  while (1) {
#line 162
    t = find_next_token(& text, (unsigned int *)(& len));
#line 162
    if (! ((unsigned long )t != (unsigned long )((char *)0))) {
#line 162
      break;
    }
#line 164
    fail = 0;
#line 167
    if ((unsigned int )len < pattern_prepercent_len + pattern_postpercent_len) {
#line 168
      fail = 1;
    }
#line 171
    if (! fail) {
#line 171
      if (pattern_prepercent_len > 0U) {
#line 171
        if ((int )*t != (int )*pattern) {
#line 175
          fail = 1;
        } else
#line 171
        if ((int )*(t + (pattern_prepercent_len - 1U)) != (int )*(pattern_percent + -1)) {
#line 175
          fail = 1;
        } else {
#line 171
          tmp___5 = strncmp((char const   *)(t + 1), (char const   *)(pattern + 1),
                            (size_t )(pattern_prepercent_len - 1U));
#line 171
          if (! (tmp___5 == 0)) {
#line 175
            fail = 1;
          }
        }
      }
    }
#line 178
    if (! fail) {
#line 178
      if (pattern_postpercent_len > 0U) {
#line 178
        if ((int )*(t + (len - 1)) != (int )*(pattern_percent + pattern_postpercent_len)) {
#line 183
          fail = 1;
        } else
#line 178
        if ((int )*(t + ((unsigned int )len - pattern_postpercent_len)) != (int )*(pattern_percent + 1)) {
#line 183
          fail = 1;
        } else {
#line 178
          tmp___6 = strncmp((char const   *)(t + ((unsigned int )len - pattern_postpercent_len)),
                            (char const   *)(pattern_percent + 1), (size_t )(pattern_postpercent_len - 1U));
#line 178
          if (! (tmp___6 == 0)) {
#line 183
            fail = 1;
          }
        }
      }
    }
#line 185
    if (fail) {
#line 187
      o = variable_buffer_output(o, t, (unsigned int )len);
    } else {
#line 193
      o = variable_buffer_output(o, replace, replace_prepercent_len);
#line 195
      if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
#line 199
        o = variable_buffer_output(o, t + pattern_prepercent_len, (unsigned int )len - (pattern_prepercent_len + pattern_postpercent_len));
#line 203
        o = variable_buffer_output(o, replace_percent + 1, replace_postpercent_len);
      }
    }
#line 209
    if (fail) {
#line 212
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 213
      doneany = 1;
    } else
#line 209
    if (replace_prepercent_len > 0U) {
#line 212
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 213
      doneany = 1;
    } else
#line 209
    if ((unsigned long )replace_percent != (unsigned long )((char *)0)) {
#line 209
      if ((unsigned int )len + replace_postpercent_len > 0U) {
#line 212
        o = variable_buffer_output(o, (char *)" ", 1U);
#line 213
        doneany = 1;
      }
    }
  }
#line 216
  if (doneany) {
#line 218
    o --;
  }
#line 220
  return (o);
}
}
#line 229 "function.c"
static struct function_table_entry  const  *lookup_function(struct function_table_entry  const  *table ,
                                                            char const   *s ) 
{ 
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
#line 234
  tmp = strlen(s);
#line 234
  len = (int )tmp;
#line 236
  while ((unsigned long )table->name != (unsigned long )((void *)0)) {
#line 237
    if ((int const   )table->len <= (int const   )len) {
#line 237
      tmp___0 = __ctype_b_loc();
#line 237
      if ((int const   )*(*tmp___0 + (int )*(s + table->len)) & 1) {
#line 237
        goto _L;
      } else
#line 237
      if ((int const   )*(s + table->len) == 0) {
        _L: /* CIL Label */ 
#line 237
        tmp___1 = strncmp(s, (char const   *)table->name, (size_t )table->len);
#line 237
        if (tmp___1 == 0) {
#line 240
          return (table);
        }
      }
    }
#line 236
    table ++;
  }
#line 242
  return ((struct function_table_entry  const  *)((void *)0));
}
}
#line 248 "function.c"
int pattern_matches(char *pattern , char *percent , char *str ) 
{ 
  unsigned int sfxlen ;
  unsigned int strlength ;
  unsigned int len ;
  size_t tmp ;
  char *new_chars ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 254
  if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 256
    tmp = strlen((char const   *)pattern);
#line 256
    len = (unsigned int )(tmp + 1UL);
#line 257
    tmp___0 = __builtin_alloca((unsigned long )len);
#line 257
    new_chars = (char *)tmp___0;
#line 258
    memmove((void *)new_chars, (void const   *)pattern, (size_t )len);
#line 259
    pattern = new_chars;
#line 260
    percent = find_percent(pattern);
#line 261
    if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 262
      if ((unsigned long )pattern == (unsigned long )str) {
#line 262
        tmp___2 = 1;
      } else
#line 262
      if ((int )*pattern == (int )*str) {
#line 262
        if ((int )*pattern == 0) {
#line 262
          tmp___2 = 1;
        } else {
#line 262
          tmp___1 = strcmp((char const   *)(pattern + 1), (char const   *)(str + 1));
#line 262
          if (tmp___1) {
#line 262
            tmp___2 = 0;
          } else {
#line 262
            tmp___2 = 1;
          }
        }
      } else {
#line 262
        tmp___2 = 0;
      }
#line 262
      return (tmp___2);
    }
  }
#line 265
  tmp___3 = strlen((char const   *)(percent + 1));
#line 265
  sfxlen = (unsigned int )tmp___3;
#line 266
  tmp___4 = strlen((char const   *)str);
#line 266
  strlength = (unsigned int )tmp___4;
#line 268
  if ((long )strlength < (percent - pattern) + (long )sfxlen) {
#line 270
    return (0);
  } else {
#line 268
    tmp___5 = strncmp((char const   *)pattern, (char const   *)str, (size_t )(percent - pattern));
#line 268
    if (! (tmp___5 == 0)) {
#line 270
      return (0);
    }
  }
#line 272
  tmp___6 = strcmp((char const   *)(percent + 1), (char const   *)(str + (strlength - sfxlen)));
#line 272
  if (tmp___6) {
#line 272
    tmp___7 = 0;
  } else {
#line 272
    tmp___7 = 1;
  }
#line 272
  return (tmp___7);
}
}
#line 283 "function.c"
static char *find_next_argument(char startparen , char endparen , char const   *ptr ,
                                char const   *end ) 
{ 
  int count ;

  {
#line 290
  count = 0;
#line 292
  while ((unsigned long )ptr < (unsigned long )end) {
#line 293
    if ((int const   )*ptr == (int const   )startparen) {
#line 294
      count ++;
    } else
#line 296
    if ((int const   )*ptr == (int const   )endparen) {
#line 298
      count --;
#line 299
      if (count < 0) {
#line 300
        return ((char *)((void *)0));
      }
    } else
#line 303
    if ((int const   )*ptr == 44) {
#line 303
      if (! count) {
#line 304
        return ((char *)ptr);
      }
    }
#line 292
    ptr ++;
  }
#line 307
  return ((char *)((void *)0));
}
}
#line 318
static char *string_glob(char *line ) ;
#line 318 "function.c"
static char *result  =    (char *)0;
#line 319 "function.c"
static unsigned int length  ;
#line 314 "function.c"
static char *string_glob(char *line ) 
{ 
  register struct nameseq *chain ;
  register unsigned int idx ;
  struct nameseq *tmp ;
  char *tmp___0 ;
  register char *name ;
  unsigned int len ;
  size_t tmp___1 ;
  struct nameseq *next ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
#line 323
  tmp = parse_file_seq(& line, '\000', (unsigned int )sizeof(struct nameseq ), 0);
#line 323
  chain = multi_glob(tmp, (unsigned int )sizeof(struct nameseq ));
#line 331
  if ((unsigned long )result == (unsigned long )((char *)0)) {
#line 333
    length = 100U;
#line 334
    tmp___0 = xmalloc(100U);
#line 334
    result = tmp___0;
  }
#line 337
  idx = 0U;
#line 338
  while ((unsigned long )chain != (unsigned long )((struct nameseq *)0)) {
#line 340
    name = chain->name;
#line 341
    tmp___1 = strlen((char const   *)name);
#line 341
    len = (unsigned int )tmp___1;
#line 343
    next = chain->next;
#line 344
    free((void *)((char *)chain));
#line 345
    chain = next;
#line 349
    tmp___4 = file_exists_p(name);
#line 349
    if (tmp___4) {
#line 351
      if ((idx + len) + 1U > length) {
#line 353
        length += (len + 1U) * 2U;
#line 354
        tmp___2 = xrealloc(result, length);
#line 354
        result = tmp___2;
      }
#line 356
      memmove((void *)(result + idx), (void const   *)name, (size_t )len);
#line 357
      idx += len;
#line 358
      tmp___3 = idx;
#line 358
      idx ++;
#line 358
      *(result + tmp___3) = (char )' ';
    }
#line 361
    free((void *)name);
  }
#line 365
  if (idx == 0U) {
#line 366
    *(result + 0) = (char )'\000';
  } else {
#line 368
    *(result + (idx - 1U)) = (char )'\000';
  }
#line 370
  return (result);
}
}
#line 377 "function.c"
static char *func_patsubst(char *o , char **argv , char const   *funcname ) 
{ 


  {
#line 383
  o = patsubst_expand(o, *(argv + 2), *(argv + 0), *(argv + 1), (char *)0, (char *)0);
#line 384
  return (o);
}
}
#line 388 "function.c"
static char *func_join(char *o , char **argv , char const   *funcname ) 
{ 
  int doneany ;
  register char *tp ;
  register char *pp ;
  char *list1_iterator ;
  char *list2_iterator ;
  unsigned int len1 ;
  unsigned int len2 ;

  {
#line 394
  doneany = 0;
#line 402
  list1_iterator = *(argv + 0);
#line 403
  list2_iterator = *(argv + 1);
#line 404
  while (1) {
#line 408
    tp = find_next_token(& list1_iterator, & len1);
#line 409
    if ((unsigned long )tp != (unsigned long )((char *)0)) {
#line 410
      o = variable_buffer_output(o, tp, len1);
    }
#line 412
    pp = find_next_token(& list2_iterator, & len2);
#line 413
    if ((unsigned long )pp != (unsigned long )((char *)0)) {
#line 414
      o = variable_buffer_output(o, pp, len2);
    }
#line 416
    if ((unsigned long )tp != (unsigned long )((char *)0)) {
#line 418
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 419
      doneany = 1;
    } else
#line 416
    if ((unsigned long )pp != (unsigned long )((char *)0)) {
#line 418
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 419
      doneany = 1;
    }
#line 404
    if (! ((unsigned long )tp != (unsigned long )((char *)0))) {
#line 404
      if (! ((unsigned long )pp != (unsigned long )((char *)0))) {
#line 404
        break;
      }
    }
  }
#line 423
  if (doneany) {
#line 425
    o --;
  }
#line 427
  return (o);
}
}
#line 431 "function.c"
static char *func_origin(char *o , char **argv , char const   *funcname ) 
{ 
  register struct variable *v ;
  size_t tmp ;
  struct variable *tmp___0 ;

  {
#line 438
  tmp = strlen((char const   *)*(argv + 0));
#line 438
  tmp___0 = lookup_variable(*(argv + 0), (unsigned int )tmp);
#line 438
  v = tmp___0;
#line 439
  if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
#line 440
    o = variable_buffer_output(o, (char *)"undefined", 9U);
  } else {
#line 442
    switch ((unsigned int )v->origin) {
    default: 
#line 446
    abort();
#line 447
    break;
    case 0U: 
#line 449
    o = variable_buffer_output(o, (char *)"default", 7U);
#line 450
    break;
    case 1U: 
#line 452
    o = variable_buffer_output(o, (char *)"environment", 11U);
#line 453
    break;
    case 2U: 
#line 455
    o = variable_buffer_output(o, (char *)"file", 4U);
#line 456
    break;
    case 3U: 
#line 458
    o = variable_buffer_output(o, (char *)"environment override", 20U);
#line 459
    break;
    case 4U: 
#line 461
    o = variable_buffer_output(o, (char *)"command line", 12U);
#line 462
    break;
    case 5U: 
#line 464
    o = variable_buffer_output(o, (char *)"override", 8U);
#line 465
    break;
    case 6U: 
#line 467
    o = variable_buffer_output(o, (char *)"automatic", 9U);
#line 468
    break;
    }
  }
#line 471
  return (o);
}
}
#line 485 "function.c"
static char *func_notdir_suffix(char *o , char **argv , char const   *funcname ) 
{ 
  char *list_iterator ;
  char *p2 ;
  int doneany ;
  unsigned int len ;
  int is_suffix ;
  int tmp ;
  int tmp___0 ;
  int is_notdir ;
  char *p ;

  {
#line 492
  list_iterator = *(argv + 0);
#line 493
  p2 = (char *)0;
#line 494
  doneany = 0;
#line 495
  len = 0U;
#line 497
  if ((unsigned long )funcname == (unsigned long )"suffix") {
#line 497
    tmp___0 = 1;
  } else
#line 497
  if ((int const   )*funcname == (int const   )*"suffix") {
#line 497
    if ((int const   )*funcname == 0) {
#line 497
      tmp___0 = 1;
    } else {
#line 497
      tmp = strcmp(funcname + 1, "suffix" + 1);
#line 497
      if (tmp) {
#line 497
        tmp___0 = 0;
      } else {
#line 497
        tmp___0 = 1;
      }
    }
  } else {
#line 497
    tmp___0 = 0;
  }
#line 497
  is_suffix = tmp___0;
#line 498
  is_notdir = ! is_suffix;
#line 499
  while (1) {
#line 499
    p2 = find_next_token(& list_iterator, & len);
#line 499
    if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
#line 499
      break;
    }
#line 501
    p = p2 + len;
#line 504
    while (1) {
#line 504
      if ((unsigned long )p >= (unsigned long )p2) {
#line 504
        if (! (! is_suffix)) {
#line 504
          if (! ((int )*p != 46)) {
#line 504
            break;
          }
        }
      } else {
#line 504
        break;
      }
#line 506
      if ((int )*p == 47) {
#line 507
        break;
      }
#line 508
      p --;
    }
#line 511
    if ((unsigned long )p >= (unsigned long )p2) {
#line 513
      if (is_notdir) {
#line 514
        p ++;
      } else
#line 515
      if ((int )*p != 46) {
#line 516
        continue;
      }
#line 517
      o = variable_buffer_output(o, p, (unsigned int )((long )len - (p - p2)));
    } else
#line 527
    if (is_notdir) {
#line 528
      o = variable_buffer_output(o, p2, len);
    }
#line 530
    if (is_notdir) {
#line 532
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 533
      doneany = 1;
    } else
#line 530
    if ((unsigned long )p >= (unsigned long )p2) {
#line 532
      o = variable_buffer_output(o, (char *)" ", 1U);
#line 533
      doneany = 1;
    }
  }
#line 536
  if (doneany) {
#line 538
    o --;
  }
#line 541
  return (o);
}
}
#line 546 "function.c"
static char *func_basename_dir(char *o , char **argv , char const   *funcname ) 
{ 
  char *p3 ;
  char *p2 ;
  int doneany ;
  unsigned int len ;
  char *p ;
  int is_basename ;
  int tmp ;
  int tmp___0 ;
  int is_dir ;

  {
#line 553
  p3 = *(argv + 0);
#line 554
  p2 = (char *)0;
#line 555
  doneany = 0;
#line 556
  len = 0U;
#line 557
  p = (char *)0;
#line 558
  if ((unsigned long )funcname == (unsigned long )"basename") {
#line 558
    tmp___0 = 1;
  } else
#line 558
  if ((int const   )*funcname == (int const   )*"basename") {
#line 558
    if ((int const   )*funcname == 0) {
#line 558
      tmp___0 = 1;
    } else {
#line 558
      tmp = strcmp(funcname + 1, "basename" + 1);
#line 558
      if (tmp) {
#line 558
        tmp___0 = 0;
      } else {
#line 558
        tmp___0 = 1;
      }
    }
  } else {
#line 558
    tmp___0 = 0;
  }
#line 558
  is_basename = tmp___0;
#line 559
  is_dir = ! is_basename;
#line 561
  while (1) {
#line 561
    p2 = find_next_token(& p3, & len);
#line 561
    if (! ((unsigned long )p2 != (unsigned long )((char *)0))) {
#line 561
      break;
    }
#line 563
    p = p2 + len;
#line 564
    while (1) {
#line 564
      if ((unsigned long )p >= (unsigned long )p2) {
#line 564
        if (! (! is_basename)) {
#line 564
          if (! ((int )*p != 46)) {
#line 564
            break;
          }
        }
      } else {
#line 564
        break;
      }
#line 566
      if ((int )*p == 47) {
#line 567
        break;
      }
#line 568
      p --;
    }
#line 571
    if ((unsigned long )p >= (unsigned long )p2) {
#line 571
      if (is_dir) {
#line 572
        p ++;
#line 572
        o = variable_buffer_output(o, p2, (unsigned int )(p - p2));
      } else {
#line 571
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 573
    if ((unsigned long )p >= (unsigned long )p2) {
#line 573
      if ((int )*p == 46) {
#line 574
        o = variable_buffer_output(o, p2, (unsigned int )(p - p2));
      } else {
#line 573
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 580
    if (is_dir) {
#line 585
      o = variable_buffer_output(o, (char *)"./", 2U);
    } else {
#line 592
      o = variable_buffer_output(o, p2, len);
    }
#line 594
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 595
    doneany = 1;
  }
#line 597
  if (doneany) {
#line 599
    o --;
  }
#line 602
  return (o);
}
}
#line 605 "function.c"
static char *func_addsuffix_addprefix(char *o , char **argv , char const   *funcname ) 
{ 
  int fixlen ;
  size_t tmp ;
  char *list_iterator ;
  int is_addprefix ;
  int tmp___0 ;
  int tmp___1 ;
  int is_addsuffix ;
  int doneany ;
  char *p ;
  unsigned int len ;

  {
#line 611
  tmp = strlen((char const   *)*(argv + 0));
#line 611
  fixlen = (int )tmp;
#line 612
  list_iterator = *(argv + 1);
#line 613
  if ((unsigned long )funcname == (unsigned long )"addprefix") {
#line 613
    tmp___1 = 1;
  } else
#line 613
  if ((int const   )*funcname == (int const   )*"addprefix") {
#line 613
    if ((int const   )*funcname == 0) {
#line 613
      tmp___1 = 1;
    } else {
#line 613
      tmp___0 = strcmp(funcname + 1, "addprefix" + 1);
#line 613
      if (tmp___0) {
#line 613
        tmp___1 = 0;
      } else {
#line 613
        tmp___1 = 1;
      }
    }
  } else {
#line 613
    tmp___1 = 0;
  }
#line 613
  is_addprefix = tmp___1;
#line 614
  is_addsuffix = ! is_addprefix;
#line 616
  doneany = 0;
#line 620
  while (1) {
#line 620
    p = find_next_token(& list_iterator, & len);
#line 620
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 620
      break;
    }
#line 622
    if (is_addprefix) {
#line 623
      o = variable_buffer_output(o, *(argv + 0), (unsigned int )fixlen);
    }
#line 624
    o = variable_buffer_output(o, p, len);
#line 625
    if (is_addsuffix) {
#line 626
      o = variable_buffer_output(o, *(argv + 0), (unsigned int )fixlen);
    }
#line 627
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 628
    doneany = 1;
  }
#line 631
  if (doneany) {
#line 633
    o --;
  }
#line 635
  return (o);
}
}
#line 638 "function.c"
static char *func_subst(char *o , char **argv , char const   *funcname ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 644
  tmp = strlen((char const   *)*(argv + 1));
#line 644
  tmp___0 = strlen((char const   *)*(argv + 0));
#line 644
  o = subst_expand(o, *(argv + 2), *(argv + 0), *(argv + 1), (unsigned int )tmp___0,
                   (unsigned int )tmp, 0, 0);
#line 647
  return (o);
}
}
#line 651 "function.c"
static char *func_firstword(char *o , char **argv , char const   *funcname ) 
{ 
  unsigned int i ;
  char *words ;
  char *p ;
  char *tmp ;

  {
#line 658
  words = *(argv + 0);
#line 659
  tmp = find_next_token(& words, & i);
#line 659
  p = tmp;
#line 661
  if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 662
    o = variable_buffer_output(o, p, i);
  }
#line 664
  return (o);
}
}
#line 668 "function.c"
static char *func_words(char *o , char **argv , char const   *funcname ) 
{ 
  int i ;
  char *word_iterator ;
  char buf___1[20] ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 674
  i = 0;
#line 675
  word_iterator = *(argv + 0);
#line 678
  while (1) {
#line 678
    tmp = find_next_token(& word_iterator, (unsigned int *)0);
#line 678
    if (! ((unsigned long )tmp != (unsigned long )((char *)0))) {
#line 678
      break;
    }
#line 679
    i ++;
  }
#line 681
  sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%d", i);
#line 682
  tmp___0 = strlen((char const   *)(buf___1));
#line 682
  o = variable_buffer_output(o, buf___1, (unsigned int )tmp___0);
#line 685
  return (o);
}
}
#line 688 "function.c"
char *strip_whitespace(char **begpp , char **endpp ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 693
  while (1) {
#line 693
    tmp = __ctype_b_loc();
#line 693
    if ((int const   )*(*tmp + (int )((unsigned char )*(*begpp))) & 8192) {
#line 693
      if (! ((unsigned long )*begpp <= (unsigned long )*endpp)) {
#line 693
        break;
      }
    } else {
#line 693
      break;
    }
#line 694
    (*begpp) ++;
  }
#line 695
  while (1) {
#line 695
    tmp___0 = __ctype_b_loc();
#line 695
    if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*endpp))) & 8192) {
#line 695
      if (! ((unsigned long )*endpp >= (unsigned long )*begpp)) {
#line 695
        break;
      }
    } else {
#line 695
      break;
    }
#line 696
    (*endpp) --;
  }
#line 697
  return (*begpp);
}
}
#line 700 "function.c"
int is_numeric(char *p ) 
{ 
  char *end ;
  size_t tmp ;
  char *beg ;
  char *tmp___0 ;

  {
#line 704
  tmp = strlen((char const   *)p);
#line 704
  end = (p + tmp) - 1;
#line 705
  beg = p;
#line 706
  strip_whitespace(& p, & end);
#line 708
  while ((unsigned long )p <= (unsigned long )end) {
#line 709
    tmp___0 = p;
#line 709
    p ++;
#line 709
    if (! ((unsigned int )*tmp___0 - 48U <= 9U)) {
#line 710
      return (0);
    }
  }
#line 712
  return (end - beg >= 0L);
}
}
#line 715 "function.c"
void check_numeric(char *s , char *message___0 ) 
{ 
  int tmp ;

  {
#line 720
  tmp = is_numeric(s);
#line 720
  if (! tmp) {
#line 721
    fatal(reading_file, (char const   *)message___0);
  }
#line 722
  return;
}
}
#line 726 "function.c"
static char *func_word(char *o , char **argv , char const   *funcname ) 
{ 
  char *end_p ;
  int i ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 732
  end_p = (char *)0;
#line 733
  i = 0;
#line 734
  p = (char *)0;
#line 737
  tmp = dcgettext((char const   *)((void *)0), "non-numeric first argument to `word\' function",
                  5);
#line 737
  check_numeric(*(argv + 0), tmp);
#line 738
  i = atoi((char const   *)*(argv + 0));
#line 740
  if (i == 0) {
#line 741
    tmp___0 = dcgettext((char const   *)((void *)0), "the `word\' function takes a positive index argument",
                        5);
#line 741
    fatal(reading_file, (char const   *)tmp___0);
  }
#line 744
  end_p = *(argv + 1);
#line 745
  while (1) {
#line 745
    p = find_next_token(& end_p, (unsigned int *)0);
#line 745
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 745
      break;
    }
#line 746
    i --;
#line 746
    if (i == 0) {
#line 747
      break;
    }
  }
#line 749
  if (i == 0) {
#line 750
    o = variable_buffer_output(o, p, (unsigned int )(end_p - p));
  }
#line 752
  return (o);
}
}
#line 755 "function.c"
static char *func_wordlist(char *o , char **argv , char const   *funcname ) 
{ 
  int start ;
  int count ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *p ;
  char *end_p ;
  char *tmp___2 ;

  {
#line 764
  tmp = dcgettext((char const   *)((void *)0), "non-numeric first argument to `wordlist\' function",
                  5);
#line 764
  check_numeric(*(argv + 0), tmp);
#line 766
  tmp___0 = dcgettext((char const   *)((void *)0), "non-numeric second argument to `wordlist\' function",
                      5);
#line 766
  check_numeric(*(argv + 1), tmp___0);
#line 769
  start = atoi((char const   *)*(argv + 0));
#line 770
  tmp___1 = atoi((char const   *)*(argv + 1));
#line 770
  count = (tmp___1 - start) + 1;
#line 772
  if (count > 0) {
#line 775
    end_p = *(argv + 2);
#line 778
    while (1) {
#line 778
      p = find_next_token(& end_p, (unsigned int *)0);
#line 778
      if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 778
        start --;
#line 778
        if (! start) {
#line 778
          break;
        }
      } else {
#line 778
        break;
      }
    }
#line 781
    if (p) {
#line 784
      while (1) {
#line 784
        count --;
#line 784
        if (count) {
#line 784
          tmp___2 = find_next_token(& end_p, (unsigned int *)0);
#line 784
          if (! ((unsigned long )tmp___2 != (unsigned long )((char *)0))) {
#line 784
            break;
          }
        } else {
#line 784
          break;
        }
      }
#line 788
      o = variable_buffer_output(o, p, (unsigned int )(end_p - p));
    }
  }
#line 792
  return (o);
}
}
#line 795 "function.c"
static char *func_findstring(char *o , char **argv , char const   *funcname ) 
{ 
  int i ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 802
  tmp = strlen((char const   *)*(argv + 0));
#line 802
  i = (int )tmp;
#line 803
  tmp___0 = sindex((char const   *)*(argv + 1), 0U, (char const   *)*(argv + 0), (unsigned int )i);
#line 803
  if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 804
    o = variable_buffer_output(o, *(argv + 0), (unsigned int )i);
  }
#line 806
  return (o);
}
}
#line 809 "function.c"
static char *func_foreach(char *o , char **argv , char const   *funcname ) 
{ 
  char *varname ;
  char *tmp ;
  char *list ;
  char *tmp___0 ;
  char *body ;
  int doneany ;
  char *list_iterator ;
  char *p ;
  unsigned int len ;
  register struct variable *var ;
  size_t tmp___1 ;
  char *result___0 ;
  char save ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
#line 816
  tmp = expand_argument(*(argv + 0), (char *)((void *)0));
#line 816
  varname = tmp;
#line 817
  tmp___0 = expand_argument(*(argv + 1), (char *)((void *)0));
#line 817
  list = tmp___0;
#line 818
  body = *(argv + 2);
#line 820
  doneany = 0;
#line 821
  list_iterator = list;
#line 826
  push_new_variable_scope();
#line 827
  tmp___1 = strlen((char const   *)varname);
#line 827
  var = define_variable_in_set(varname, (unsigned int )tmp___1, (char *)"", (enum variable_origin )6,
                               0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 830
  while (1) {
#line 830
    p = find_next_token(& list_iterator, & len);
#line 830
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 830
      break;
    }
#line 832
    result___0 = (char *)0;
#line 835
    save = *(p + len);
#line 837
    *(p + len) = (char )'\000';
#line 838
    free((void *)var->value);
#line 839
    tmp___2 = xstrdup((char const   *)p);
#line 839
    var->value = tmp___2;
#line 840
    *(p + len) = save;
#line 843
    result___0 = allocated_variable_expand_for_file(body, (struct file *)0);
#line 845
    tmp___3 = strlen((char const   *)result___0);
#line 845
    o = variable_buffer_output(o, result___0, (unsigned int )tmp___3);
#line 846
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 847
    doneany = 1;
#line 848
    free((void *)result___0);
  }
#line 851
  if (doneany) {
#line 853
    o --;
  }
#line 855
  pop_variable_scope();
#line 856
  free((void *)varname);
#line 857
  free((void *)list);
#line 859
  return (o);
}
}
#line 869 "function.c"
static char *func_filter_filterout(char *o , char **argv , char const   *funcname ) 
{ 
  struct a_word *wordhead ;
  struct a_word *wordtail ;
  int is_filter ;
  int tmp ;
  int tmp___0 ;
  char *patterns ;
  char *word_iterator ;
  char *p ;
  unsigned int len ;
  struct a_word *w ;
  void *tmp___1 ;
  char *pat_iterator ;
  int doneany ;
  struct a_word *wp ;
  char *percent ;
  char save ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 875
  wordhead = (struct a_word *)0;
#line 876
  wordtail = (struct a_word *)0;
#line 878
  if ((unsigned long )funcname == (unsigned long )"filter") {
#line 878
    tmp___0 = 1;
  } else
#line 878
  if ((int const   )*funcname == (int const   )*"filter") {
#line 878
    if ((int const   )*funcname == 0) {
#line 878
      tmp___0 = 1;
    } else {
#line 878
      tmp = strcmp(funcname + 1, "filter" + 1);
#line 878
      if (tmp) {
#line 878
        tmp___0 = 0;
      } else {
#line 878
        tmp___0 = 1;
      }
    }
  } else {
#line 878
    tmp___0 = 0;
  }
#line 878
  is_filter = tmp___0;
#line 879
  patterns = *(argv + 0);
#line 880
  word_iterator = *(argv + 1);
#line 886
  while (1) {
#line 886
    p = find_next_token(& word_iterator, & len);
#line 886
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 886
      break;
    }
#line 888
    tmp___1 = __builtin_alloca(sizeof(struct a_word ));
#line 888
    w = (struct a_word *)tmp___1;
#line 889
    if ((unsigned long )wordhead == (unsigned long )((struct a_word *)0)) {
#line 890
      wordhead = w;
    } else {
#line 892
      wordtail->next = w;
    }
#line 893
    wordtail = w;
#line 895
    if ((int )*word_iterator != 0) {
#line 896
      word_iterator ++;
    }
#line 897
    *(p + len) = (char )'\000';
#line 898
    w->str = p;
#line 899
    w->matched = 0;
  }
#line 902
  if ((unsigned long )wordhead != (unsigned long )((struct a_word *)0)) {
#line 904
    pat_iterator = patterns;
#line 905
    doneany = 0;
#line 908
    wordtail->next = (struct a_word *)0;
#line 911
    while (1) {
#line 911
      p = find_next_token(& pat_iterator, & len);
#line 911
      if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 911
        break;
      }
#line 914
      save = *(p + len);
#line 915
      *(p + len) = (char )'\000';
#line 917
      percent = find_percent(p);
#line 918
      wp = wordhead;
#line 918
      while ((unsigned long )wp != (unsigned long )((struct a_word *)0)) {
#line 919
        if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 919
          if ((unsigned long )p == (unsigned long )wp->str) {
#line 919
            tmp___3 = 1;
          } else
#line 919
          if ((int )*p == (int )*(wp->str)) {
#line 919
            if ((int )*p == 0) {
#line 919
              tmp___3 = 1;
            } else {
#line 919
              tmp___2 = strcmp((char const   *)(p + 1), (char const   *)(wp->str + 1));
#line 919
              if (tmp___2) {
#line 919
                tmp___3 = 0;
              } else {
#line 919
                tmp___3 = 1;
              }
            }
          } else {
#line 919
            tmp___3 = 0;
          }
#line 919
          tmp___5 = tmp___3;
        } else {
#line 919
          tmp___4 = pattern_matches(p, percent, wp->str);
#line 919
          tmp___5 = tmp___4;
        }
#line 919
        wp->matched |= tmp___5;
#line 918
        wp = wp->next;
      }
#line 922
      *(p + len) = save;
    }
#line 926
    wp = wordhead;
#line 926
    while ((unsigned long )wp != (unsigned long )((struct a_word *)0)) {
#line 927
      if (is_filter) {
#line 927
        tmp___7 = wp->matched;
      } else {
#line 927
        tmp___7 = ! wp->matched;
      }
#line 927
      if (tmp___7) {
#line 929
        tmp___6 = strlen((char const   *)wp->str);
#line 929
        o = variable_buffer_output(o, wp->str, (unsigned int )tmp___6);
#line 930
        o = variable_buffer_output(o, (char *)" ", 1U);
#line 931
        doneany = 1;
      }
#line 926
      wp = wp->next;
    }
#line 934
    if (doneany) {
#line 936
      o --;
    }
  }
#line 939
  return (o);
}
}
#line 943 "function.c"
static char *func_strip(char *o , char **argv , char const   *funcname ) 
{ 
  char *p ;
  int doneany ;
  int i ;
  char *word_start ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 949
  p = *(argv + 0);
#line 950
  doneany = 0;
#line 952
  while ((int )*p != 0) {
#line 954
    i = 0;
#line 955
    word_start = (char *)0;
#line 957
    while (1) {
#line 957
      tmp = __ctype_b_loc();
#line 957
      if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
#line 957
        break;
      }
#line 958
      p ++;
    }
#line 959
    word_start = p;
#line 960
    i = 0;
#line 960
    while (1) {
#line 960
      if ((int )*p != 0) {
#line 960
        tmp___0 = __ctype_b_loc();
#line 960
        if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 8192) {
#line 960
          break;
        }
      } else {
#line 960
        break;
      }
#line 960
      p ++;
#line 960
      i ++;
    }
#line 962
    if (! i) {
#line 963
      break;
    }
#line 964
    o = variable_buffer_output(o, word_start, (unsigned int )i);
#line 965
    o = variable_buffer_output(o, (char *)" ", 1U);
#line 966
    doneany = 1;
  }
#line 969
  if (doneany) {
#line 971
    o --;
  }
#line 972
  return (o);
}
}
#line 978 "function.c"
static char *func_error(char *o , char **argv , char const   *funcname ) 
{ 
  char **argvp ;
  char *msg ;
  char *p ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 991
  len = 0;
#line 991
  argvp = argv;
#line 991
  while ((unsigned long )*argvp != (unsigned long )((char *)0)) {
#line 992
    tmp = strlen((char const   *)*argvp);
#line 992
    len = (int )((size_t )len + (tmp + 2UL));
#line 991
    argvp ++;
  }
#line 994
  tmp___0 = __builtin_alloca((unsigned long )(len + 1));
#line 994
  msg = (char *)tmp___0;
#line 994
  p = msg;
#line 996
  argvp = argv;
#line 996
  while ((unsigned long )*(argvp + 1) != (unsigned long )((char *)0)) {
#line 998
    strcpy((char * __restrict  )p, (char const   * __restrict  )*argvp);
#line 999
    tmp___1 = strlen((char const   *)*argvp);
#line 999
    p += tmp___1;
#line 1000
    tmp___2 = p;
#line 1000
    p ++;
#line 1000
    *tmp___2 = (char )',';
#line 1001
    tmp___3 = p;
#line 1001
    p ++;
#line 1001
    *tmp___3 = (char )' ';
#line 996
    argvp ++;
  }
#line 1003
  strcpy((char * __restrict  )p, (char const   * __restrict  )*argvp);
#line 1005
  if ((int const   )*funcname == 101) {
#line 1006
    fatal(reading_file, "%s", msg);
  }
#line 1009
  error(reading_file, "%s", msg);
#line 1011
  return (o);
}
}
#line 1018 "function.c"
static char *func_sort(char *o , char **argv , char const   *funcname ) 
{ 
  char **words ;
  int nwords ;
  register int wordi ;
  char *t ;
  char *p ;
  unsigned int len ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 1024
  words = (char **)0;
#line 1025
  nwords = 0;
#line 1026
  wordi = 0;
#line 1029
  t = *(argv + 0);
#line 1034
  while (1) {
#line 1034
    p = find_next_token(& t, & len);
#line 1034
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 1034
      break;
    }
#line 1036
    if (wordi >= nwords - 1) {
#line 1038
      nwords = 2 * nwords + 5;
#line 1039
      tmp = xrealloc((char *)words, (unsigned int )((unsigned long )nwords * sizeof(char *)));
#line 1039
      words = (char **)tmp;
    }
#line 1042
    tmp___0 = wordi;
#line 1042
    wordi ++;
#line 1042
    *(words + tmp___0) = savestring((char const   *)p, len);
  }
#line 1045
  if (! wordi) {
#line 1046
    return (o);
  }
#line 1049
  qsort((void *)((char *)words), (size_t )wordi, sizeof(char *), & alpha_compare);
#line 1052
  i = 0;
#line 1052
  while (i < wordi) {
#line 1054
    tmp___1 = strlen((char const   *)*(words + i));
#line 1054
    len = (unsigned int )tmp___1;
#line 1055
    if (i == wordi - 1) {
#line 1058
      o = variable_buffer_output(o, *(words + i), len);
#line 1059
      o = variable_buffer_output(o, (char *)" ", 1U);
    } else {
#line 1055
      tmp___2 = strlen((char const   *)*(words + (i + 1)));
#line 1055
      if (tmp___2 != (size_t )len) {
#line 1058
        o = variable_buffer_output(o, *(words + i), len);
#line 1059
        o = variable_buffer_output(o, (char *)" ", 1U);
      } else {
#line 1055
        tmp___3 = strcmp((char const   *)*(words + i), (char const   *)*(words + (i + 1)));
#line 1055
        if (tmp___3) {
#line 1058
          o = variable_buffer_output(o, *(words + i), len);
#line 1059
          o = variable_buffer_output(o, (char *)" ", 1U);
        }
      }
    }
#line 1061
    free((void *)*(words + i));
#line 1052
    i ++;
  }
#line 1064
  o --;
#line 1066
  free((void *)words);
#line 1068
  return (o);
}
}
#line 1083 "function.c"
static char *func_if(char *o , char **argv , char const   *funcname ) 
{ 
  char *begp ;
  char *endp ;
  size_t tmp ;
  int result___0 ;
  char *expansion ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *expansion___0 ;
  size_t tmp___2 ;

  {
#line 1089
  begp = *(argv + 0);
#line 1090
  tmp = strlen((char const   *)*(argv + 0));
#line 1090
  endp = begp + tmp;
#line 1091
  result___0 = 0;
#line 1097
  strip_whitespace(& begp, & endp);
#line 1099
  if ((unsigned long )begp < (unsigned long )endp) {
#line 1101
    tmp___0 = expand_argument(begp, (char *)((void *)0));
#line 1101
    expansion = tmp___0;
#line 1103
    tmp___1 = strlen((char const   *)expansion);
#line 1103
    result___0 = (int )tmp___1;
#line 1104
    free((void *)expansion);
  }
#line 1111
  argv += 1 + ! result___0;
#line 1113
  if (*(argv + 0)) {
#line 1117
    expansion___0 = expand_argument(*(argv + 0), (char *)((void *)0));
#line 1119
    tmp___2 = strlen((char const   *)expansion___0);
#line 1119
    o = variable_buffer_output(o, expansion___0, (unsigned int )tmp___2);
#line 1121
    free((void *)expansion___0);
  }
#line 1124
  return (o);
}
}
#line 1127 "function.c"
static char *func_wildcard(char *o , char **argv , char const   *funcname ) 
{ 
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 1137
  tmp = string_glob(*(argv + 0));
#line 1137
  p = tmp;
#line 1138
  tmp___0 = strlen((char const   *)p);
#line 1138
  o = variable_buffer_output(o, p, (unsigned int )tmp___0);
#line 1140
  return (o);
}
}
#line 1146 "function.c"
void fold_newlines(char *buffer , int *length___0 ) 
{ 
  char *dst ;
  char *src ;
  char *last_nonnl ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1151
  dst = buffer;
#line 1152
  src = buffer;
#line 1153
  last_nonnl = buffer - 1;
#line 1154
  *(src + *length___0) = (char)0;
#line 1155
  while ((int )*src != 0) {
#line 1157
    if ((int )*(src + 0) == 13) {
#line 1157
      if ((int )*(src + 1) == 10) {
#line 1158
        goto __Cont;
      }
    }
#line 1159
    if ((int )*src == 10) {
#line 1161
      tmp = dst;
#line 1161
      dst ++;
#line 1161
      *tmp = (char )' ';
    } else {
#line 1165
      last_nonnl = dst;
#line 1166
      tmp___0 = dst;
#line 1166
      dst ++;
#line 1166
      *tmp___0 = *src;
    }
    __Cont: /* CIL Label */ 
#line 1155
    src ++;
  }
#line 1169
  last_nonnl ++;
#line 1169
  *last_nonnl = (char )'\000';
#line 1170
  *length___0 = (int )(last_nonnl - buffer);
#line 1171
  return;
}
}
#line 1175 "function.c"
int shell_function_pid  =    0;
#line 1175 "function.c"
int shell_function_completed  ;
#line 1332 "function.c"
static char *func_shell(char *o , char **argv , char const   *funcname ) 
{ 
  char *batch_filename ;
  int i ;
  char **command_argv ;
  char *error_prefix ;
  char **envp ;
  int pipedes[2] ;
  int pid ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *buffer ;
  unsigned int maxlen ;
  int cc ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
#line 1338
  batch_filename = (char *)((void *)0);
#line 1352
  command_argv = construct_command_argv(*(argv + 0), (char **)((void *)0), (struct file *)0,
                                        & batch_filename);
#line 1355
  if ((unsigned long )command_argv == (unsigned long )((char **)0)) {
#line 1356
    return (o);
  }
#line 1366
  envp = environ;
#line 1369
  if ((unsigned long )reading_file != (unsigned long )((struct floc  const  *)0)) {
#line 1371
    tmp = strlen((char const   *)reading_file->filenm);
#line 1371
    tmp___0 = __builtin_alloca((tmp + 11UL) + 4UL);
#line 1371
    error_prefix = (char *)tmp___0;
#line 1372
    sprintf((char * __restrict  )error_prefix, (char const   * __restrict  )"%s:%lu: ",
            reading_file->filenm, reading_file->lineno);
  } else {
#line 1376
    error_prefix = (char *)"";
  }
#line 1397
  tmp___1 = pipe((int *)(pipedes));
#line 1397
  if (tmp___1 < 0) {
#line 1399
    perror_with_name(error_prefix, (char *)"pipe");
#line 1400
    return (o);
  }
#line 1403
  pid = vfork();
#line 1404
  if (pid < 0) {
#line 1405
    perror_with_name(error_prefix, (char *)"fork");
  } else
#line 1406
  if (pid == 0) {
#line 1407
    child_execute_job(0, pipedes[1], command_argv, envp);
  } else {
#line 1420
    shell_function_pid = pid;
#line 1422
    shell_function_completed = 0;
#line 1425
    free((void *)*(command_argv + 0));
#line 1426
    free((void *)((char *)command_argv));
#line 1429
    close(pipedes[1]);
#line 1434
    maxlen = 200U;
#line 1435
    tmp___2 = xmalloc(maxlen + 1U);
#line 1435
    buffer = tmp___2;
#line 1438
    i = 0;
#line 1439
    while (1) {
#line 1441
      if ((unsigned int )i == maxlen) {
#line 1443
        maxlen += 512U;
#line 1444
        tmp___3 = xrealloc(buffer, maxlen + 1U);
#line 1444
        buffer = tmp___3;
      }
#line 1447
      tmp___4 = __errno_location();
#line 1447
      *tmp___4 = 0;
#line 1448
      tmp___5 = read(pipedes[0], (void *)(buffer + i), (size_t )(maxlen - (unsigned int )i));
#line 1448
      cc = (int )tmp___5;
#line 1449
      if (cc > 0) {
#line 1450
        i += cc;
      }
#line 1439
      if (! (cc > 0)) {
#line 1439
        tmp___6 = __errno_location();
#line 1439
        if (! (*tmp___6 == 4)) {
#line 1439
          break;
        }
      }
    }
#line 1459
    close(pipedes[0]);
#line 1464
    while (shell_function_completed == 0) {
#line 1465
      reap_children(1, 0);
    }
#line 1467
    if (batch_filename) {
#line 1468
      while (1) {
#line 1468
        if (2 & db_level) {
#line 1468
          tmp___7 = dcgettext((char const   *)((void *)0), "Cleaning up temporary batch file %s\n",
                              5);
#line 1468
          printf((char const   * __restrict  )tmp___7, batch_filename);
#line 1468
          fflush(stdout);
        }
#line 1468
        break;
      }
#line 1470
      remove((char const   *)batch_filename);
#line 1471
      free((void *)batch_filename);
    }
#line 1473
    shell_function_pid = 0;
#line 1479
    if (shell_function_completed == -1) {
#line 1484
      fputs((char const   * __restrict  )buffer, (FILE * __restrict  )stderr);
#line 1485
      fflush(stderr);
    } else {
#line 1492
      fold_newlines(buffer, & i);
#line 1493
      o = variable_buffer_output(o, buffer, (unsigned int )i);
    }
#line 1496
    free((void *)buffer);
  }
#line 1499
  return (o);
}
}
#line 1637
static char *func_call(char *o , char **argv , char const   *funcname ) ;
#line 1640 "function.c"
static struct function_table_entry function_table[27]  = 
#line 1640
  {      {"addprefix", (unsigned char )(sizeof("addprefix") - 1UL), (unsigned char)2,
      (unsigned char)2, (char)1, & func_addsuffix_addprefix}, 
        {"addsuffix", (unsigned char )(sizeof("addsuffix") - 1UL), (unsigned char)2,
      (unsigned char)2, (char)1, & func_addsuffix_addprefix}, 
        {"basename", (unsigned char )(sizeof("basename") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_basename_dir}, 
        {"dir", (unsigned char )(sizeof("dir") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_basename_dir}, 
        {"notdir", (unsigned char )(sizeof("notdir") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_notdir_suffix}, 
        {"subst", (unsigned char )(sizeof("subst") - 1UL), (unsigned char)3, (unsigned char)3,
      (char)1, & func_subst}, 
        {"suffix", (unsigned char )(sizeof("suffix") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_notdir_suffix}, 
        {"filter", (unsigned char )(sizeof("filter") - 1UL), (unsigned char)2, (unsigned char)2,
      (char)1, & func_filter_filterout}, 
        {"filter-out", (unsigned char )(sizeof("filter-out") - 1UL), (unsigned char)2,
      (unsigned char)2, (char)1, & func_filter_filterout}, 
        {"findstring", (unsigned char )(sizeof("findstring") - 1UL), (unsigned char)2,
      (unsigned char)2, (char)1, & func_findstring}, 
        {"firstword", (unsigned char )(sizeof("firstword") - 1UL), (unsigned char)1,
      (unsigned char)1, (char)1, & func_firstword}, 
        {"join", (unsigned char )(sizeof("join") - 1UL), (unsigned char)2, (unsigned char)2,
      (char)1, & func_join}, 
        {"patsubst", (unsigned char )(sizeof("patsubst") - 1UL), (unsigned char)3, (unsigned char)3,
      (char)1, & func_patsubst}, 
        {"shell", (unsigned char )(sizeof("shell") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_shell}, 
        {"sort", (unsigned char )(sizeof("sort") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_sort}, 
        {"strip", (unsigned char )(sizeof("strip") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_strip}, 
        {"wildcard", (unsigned char )(sizeof("wildcard") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_wildcard}, 
        {"word", (unsigned char )(sizeof("word") - 1UL), (unsigned char)2, (unsigned char)2,
      (char)1, & func_word}, 
        {"wordlist", (unsigned char )(sizeof("wordlist") - 1UL), (unsigned char)3, (unsigned char)3,
      (char)1, & func_wordlist}, 
        {"words", (unsigned char )(sizeof("words") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_words}, 
        {"origin", (unsigned char )(sizeof("origin") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_origin}, 
        {"foreach", (unsigned char )(sizeof("foreach") - 1UL), (unsigned char)3, (unsigned char)3,
      (char)0, & func_foreach}, 
        {"call", (unsigned char )(sizeof("call") - 1UL), (unsigned char)1, (unsigned char)0,
      (char)1, & func_call}, 
        {"error", (unsigned char )(sizeof("error") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_error}, 
        {"warning", (unsigned char )(sizeof("warning") - 1UL), (unsigned char)1, (unsigned char)1,
      (char)1, & func_error}, 
        {"if", (unsigned char )(sizeof("if") - 1UL), (unsigned char)2, (unsigned char)3,
      (char)0, & func_if}, 
        {(char const   *)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (char)0,
      (char *(*)(char *output , char **argv , char const   *fname ))0}};
#line 1679 "function.c"
static char *expand_builtin_function(char *o , int argc , char **argv , struct function_table_entry *entry_p ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1686
  if (argc < (int )entry_p->minimum_args) {
#line 1687
    tmp = dcgettext((char const   *)((void *)0), "Insufficient number of arguments (%d) to function `%s\'",
                    5);
#line 1687
    fatal(reading_file, (char const   *)tmp, argc, entry_p->name);
  }
#line 1691
  if (! entry_p->func_ptr) {
#line 1692
    tmp___0 = dcgettext((char const   *)((void *)0), "Unimplemented on this platform: function `%s\'",
                        5);
#line 1692
    fatal(reading_file, (char const   *)tmp___0, entry_p->name);
  }
#line 1695
  tmp___1 = (*(entry_p->func_ptr))(o, argv, entry_p->name);
#line 1695
  return (tmp___1);
}
}
#line 1703 "function.c"
int handle_function(char **op , char **stringp ) 
{ 
  struct function_table_entry  const  *entry_p ;
  char openparen ;
  char closeparen ;
  int tmp ;
  char *beg ;
  char *end ;
  int count ;
  register char *p ;
  char **argv ;
  char **argvp ;
  int nargs ;
  char *tmp___0 ;
  void *tmp___1 ;
  int len ;
  char *next ;

  {
#line 1709
  openparen = *(*stringp + 0);
#line 1710
  if ((int )openparen == 40) {
#line 1710
    tmp = ')';
  } else {
#line 1710
    tmp = '}';
  }
#line 1710
  closeparen = (char )tmp;
#line 1713
  count = 0;
#line 1718
  beg = *stringp + 1;
#line 1720
  entry_p = lookup_function((struct function_table_entry  const  *)(function_table),
                            (char const   *)beg);
#line 1722
  if (! entry_p) {
#line 1723
    return (0);
  }
#line 1728
  beg = next_token(beg + (int const   )entry_p->len);
#line 1735
  nargs = 1;
#line 1735
  end = beg;
#line 1735
  while ((int )*end != 0) {
#line 1736
    if ((int )*end == 44) {
#line 1737
      nargs ++;
    } else
#line 1738
    if ((int )*end == (int )openparen) {
#line 1739
      count ++;
    } else
#line 1740
    if ((int )*end == (int )closeparen) {
#line 1740
      count --;
#line 1740
      if (count < 0) {
#line 1741
        break;
      }
    }
#line 1735
    end ++;
  }
#line 1743
  if (count >= 0) {
#line 1744
    tmp___0 = dcgettext((char const   *)((void *)0), "unterminated call to function `%s\': missing `%c\'",
                        5);
#line 1744
    fatal(reading_file, (char const   *)tmp___0, entry_p->name, (int )closeparen);
  }
#line 1748
  *stringp = end;
#line 1751
  tmp___1 = __builtin_alloca(sizeof(char *) * (unsigned long )(nargs + 2));
#line 1751
  argv = (char **)tmp___1;
#line 1751
  argvp = argv;
#line 1761
  if (! entry_p->expand_args) {
#line 1763
    len = (int )(end - beg);
#line 1765
    p = xmalloc((unsigned int )(len + 1));
#line 1766
    memcpy((void * __restrict  )p, (void const   * __restrict  )beg, (size_t )len);
#line 1767
    *(p + len) = (char )'\000';
#line 1768
    beg = p;
#line 1769
    end = beg + len;
  }
#line 1772
  p = beg;
#line 1773
  nargs = 0;
#line 1774
  p = beg;
#line 1774
  nargs = 0;
#line 1774
  while ((unsigned long )p < (unsigned long )end) {
#line 1778
    nargs ++;
#line 1780
    if (nargs == (int )entry_p->maximum_args) {
#line 1782
      next = end;
    } else {
#line 1780
      next = find_next_argument(openparen, closeparen, (char const   *)p, (char const   *)end);
#line 1780
      if (! next) {
#line 1782
        next = end;
      }
    }
#line 1784
    if (entry_p->expand_args) {
#line 1785
      *argvp = expand_argument(p, next);
    } else {
#line 1788
      *argvp = p;
#line 1789
      *next = (char )'\000';
    }
#line 1792
    p = next + 1;
#line 1774
    argvp ++;
  }
#line 1794
  *argvp = (char *)((void *)0);
#line 1797
  *op = expand_builtin_function(*op, nargs, argv, (struct function_table_entry *)entry_p);
#line 1800
  if (entry_p->expand_args) {
#line 1801
    argvp = argv;
#line 1801
    while ((unsigned long )*argvp != (unsigned long )((char *)0)) {
#line 1802
      free((void *)*argvp);
#line 1801
      argvp ++;
    }
  } else {
#line 1804
    free((void *)beg);
  }
#line 1806
  return (1);
}
}
#line 1814 "function.c"
static char *func_call(char *o , char **argv , char const   *funcname ) 
{ 
  char *fname ;
  char *cp ;
  int flen ;
  char *body ;
  int i ;
  struct function_table_entry  const  *entry_p ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char num[11] ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 1829
  fname = *(argv + 0);
#line 1830
  while (1) {
#line 1830
    if ((int )*fname != 0) {
#line 1830
      tmp = __ctype_b_loc();
#line 1830
      if (! ((int const   )*(*tmp + (int )((unsigned char )*fname)) & 8192)) {
#line 1830
        break;
      }
    } else {
#line 1830
      break;
    }
#line 1831
    fname ++;
  }
#line 1833
  tmp___0 = strlen((char const   *)fname);
#line 1833
  cp = (fname + tmp___0) - 1;
#line 1834
  while (1) {
#line 1834
    if ((unsigned long )cp > (unsigned long )fname) {
#line 1834
      tmp___1 = __ctype_b_loc();
#line 1834
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*cp)) & 8192)) {
#line 1834
        break;
      }
    } else {
#line 1834
      break;
    }
#line 1835
    cp --;
  }
#line 1836
  *(cp + 1) = (char )'\000';
#line 1839
  if ((int )*fname == 0) {
#line 1840
    return (o);
  }
#line 1844
  entry_p = lookup_function((struct function_table_entry  const  *)(function_table),
                            (char const   *)fname);
#line 1846
  if (entry_p) {
#line 1849
    i = 0;
#line 1849
    while (*(argv + (i + 1))) {
#line 1849
      i ++;
    }
#line 1852
    tmp___2 = expand_builtin_function(o, i, argv + 1, (struct function_table_entry *)entry_p);
#line 1852
    return (tmp___2);
  }
#line 1858
  tmp___3 = strlen((char const   *)fname);
#line 1858
  flen = (int )tmp___3;
#line 1860
  tmp___4 = __builtin_alloca((unsigned long )(flen + 4));
#line 1860
  body = (char *)tmp___4;
#line 1861
  *(body + 0) = (char )'$';
#line 1862
  *(body + 1) = (char )'(';
#line 1863
  memcpy((void * __restrict  )(body + 2), (void const   * __restrict  )fname, (size_t )flen);
#line 1864
  *(body + (flen + 2)) = (char )')';
#line 1865
  *(body + (flen + 3)) = (char )'\000';
#line 1869
  push_new_variable_scope();
#line 1871
  i = 0;
#line 1871
  while (*argv) {
#line 1875
    sprintf((char * __restrict  )(num), (char const   * __restrict  )"%d", i);
#line 1876
    tmp___5 = strlen((char const   *)(num));
#line 1876
    define_variable_in_set(num, (unsigned int )tmp___5, *argv, (enum variable_origin )6,
                           1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 1871
    i ++;
#line 1871
    argv ++;
  }
#line 1882
  o = variable_expand_string(o, body, (long )(flen + 3));
#line 1884
  pop_variable_scope();
#line 1886
  tmp___6 = strlen((char const   *)o);
#line 1886
  return (o + tmp___6);
}
}
#line 1 "getopt.o"
#pragma merger("0","/tmp/cil-qcg1VGq_.i","-g,-O0")
#line 1 "implicit.o"
#pragma merger("0","/tmp/cil-66_5A9NO.i","-g,-O0")
#line 407 "make.h"
void print_spaces(unsigned int n ) ;
#line 432
int vpath_search(char **file , uintmax_t *mtime_ptr ) ;
#line 50 "rule.h"
struct rule *pattern_rules ;
#line 52
unsigned int num_pattern_rules ;
#line 54
unsigned int max_pattern_deps ;
#line 55
unsigned int max_pattern_targets ;
#line 56
unsigned int max_pattern_dep_length ;
#line 26 "implicit.c"
static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) ;
#line 35 "implicit.c"
int try_implicit_rule(struct file *file , unsigned int depth ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 40
  while (1) {
#line 40
    if (8 & db_level) {
#line 40
      print_spaces(depth);
#line 40
      tmp = dcgettext((char const   *)((void *)0), "Looking for an implicit rule for `%s\'.\n",
                      5);
#line 40
      printf((char const   * __restrict  )tmp, file->name);
#line 40
      fflush(stdout);
    }
#line 40
    break;
  }
#line 47
  tmp___0 = pattern_search(file, 0, depth, 0U);
#line 47
  if (tmp___0) {
#line 48
    return (1);
  }
#line 53
  tmp___3 = ar_name(file->name);
#line 53
  if (tmp___3) {
#line 55
    while (1) {
#line 55
      if (8 & db_level) {
#line 55
        print_spaces(depth);
#line 55
        tmp___1 = dcgettext((char const   *)((void *)0), "Looking for archive-member implicit rule for `%s\'.\n",
                            5);
#line 55
        printf((char const   * __restrict  )tmp___1, file->name);
#line 55
        fflush(stdout);
      }
#line 55
      break;
    }
#line 57
    tmp___2 = pattern_search(file, 1, depth, 0U);
#line 57
    if (tmp___2) {
#line 58
      return (1);
    }
  }
#line 62
  return (0);
}
}
#line 80 "implicit.c"
static int pattern_search(struct file *file , int archive , unsigned int depth , unsigned int recursions ) 
{ 
  char *filename ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int namelen ;
  size_t tmp___1 ;
  char *lastslash ;
  struct file *intermediate_file ;
  struct file **intermediate_files ;
  void *tmp___2 ;
  char **intermediate_patterns ;
  void *tmp___3 ;
  char **found_files ;
  void *tmp___4 ;
  unsigned int deps_found ;
  register char *depname ;
  void *tmp___5 ;
  register char *stem ;
  register unsigned int stemlen ;
  struct rule **tryrules ;
  void *tmp___6 ;
  unsigned int nrules ;
  unsigned int *matches ;
  void *tmp___7 ;
  char *checked_lastslash ;
  void *tmp___8 ;
  unsigned int foundrule ;
  int intermed_ok ;
  int specific_rule_matched ;
  register unsigned int i ;
  register struct rule *rule ;
  register struct dep *dep ;
  char *p ;
  char *vp ;
  int tmp___9 ;
  char *tmp___10 ;
  char *target ;
  char *suffix ;
  int check_lastslash ;
  char *tmp___11 ;
  int tmp___12 ;
  unsigned int difference ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  register unsigned int j ;
  int check_lastslash___0 ;
  char *tmp___16 ;
  char *tmp___17 ;
  register unsigned int i___0 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  unsigned int tmp___28 ;
  struct file *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  unsigned int tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  register struct file *f ;
  size_t tmp___37 ;
  unsigned int tmp___38 ;
  register char *s ;
  struct file *imf ;
  register struct file *f___0 ;
  struct file *tmp___39 ;
  char *tmp___40 ;
  unsigned int tmp___41 ;
  char *tmp___42 ;
  struct dep *new ;
  char *tmp___43 ;
  char *tmp___44 ;

  {
#line 88
  if (archive) {
#line 88
    tmp = strchr((char const   *)file->name, '(');
#line 88
    tmp___0 = tmp;
  } else {
#line 88
    tmp___0 = file->name;
  }
#line 88
  filename = tmp___0;
#line 91
  tmp___1 = strlen((char const   *)filename);
#line 91
  namelen = (unsigned int )tmp___1;
#line 99
  intermediate_file = (struct file *)0;
#line 102
  tmp___2 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(struct file *));
#line 102
  intermediate_files = (struct file **)tmp___2;
#line 106
  tmp___3 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));
#line 106
  intermediate_patterns = (char **)tmp___3;
#line 110
  tmp___4 = __builtin_alloca((unsigned long )max_pattern_deps * sizeof(char *));
#line 110
  found_files = (char **)tmp___4;
#line 112
  deps_found = 0U;
#line 115
  tmp___5 = __builtin_alloca((unsigned long )(namelen + max_pattern_dep_length));
#line 115
  depname = (char *)tmp___5;
#line 118
  stem = (char *)0;
#line 119
  stemlen = 0U;
#line 122
  tmp___6 = __builtin_alloca((unsigned long )(num_pattern_rules * max_pattern_targets) * sizeof(struct rule *));
#line 122
  tryrules = (struct rule **)tmp___6;
#line 131
  tmp___7 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(unsigned int ));
#line 131
  matches = (unsigned int *)tmp___7;
#line 136
  tmp___8 = __builtin_alloca((unsigned long )num_pattern_rules * sizeof(char ));
#line 136
  checked_lastslash = (char *)tmp___8;
#line 147
  specific_rule_matched = 0;
#line 149
  i = 0U;
#line 156
  if (archive) {
#line 157
    lastslash = (char *)0;
  } else {
#line 156
    tmp___9 = ar_name(filename);
#line 156
    if (tmp___9) {
#line 157
      lastslash = (char *)0;
    } else {
#line 169
      lastslash = strrchr((char const   *)filename, '/');
#line 182
      if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
#line 182
        if ((int )*(lastslash + 1) == 0) {
#line 183
          lastslash = (char *)0;
        }
      }
    }
  }
#line 189
  nrules = 0U;
#line 190
  rule = pattern_rules;
#line 190
  while ((unsigned long )rule != (unsigned long )((struct rule *)0)) {
#line 194
    if ((unsigned long )rule->deps != (unsigned long )((struct dep *)0)) {
#line 194
      if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
#line 195
        goto __Cont;
      }
    }
#line 199
    if (rule->in_use) {
#line 201
      while (1) {
#line 201
        if (8 & db_level) {
#line 201
          print_spaces(depth);
#line 201
          tmp___10 = dcgettext((char const   *)((void *)0), "Avoiding implicit rule recursion.\n",
                               5);
#line 201
          printf((char const   * __restrict  )tmp___10);
#line 201
          fflush(stdout);
        }
#line 201
        break;
      }
#line 202
      goto __Cont;
    }
#line 205
    i = 0U;
#line 205
    while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
#line 207
      target = *(rule->targets + i);
#line 208
      suffix = *(rule->suffixes + i);
#line 214
      if (recursions > 0U) {
#line 214
        if ((int )*(target + 1) == 0) {
#line 214
          if (! rule->terminal) {
#line 215
            goto __Cont___0;
          }
        }
      }
#line 217
      if (*(rule->lens + i) > namelen) {
#line 219
        goto __Cont___0;
      }
#line 223
      stem = filename + ((suffix - target) - 1L);
#line 224
      stemlen = (namelen - *(rule->lens + i)) + 1U;
#line 234
      if ((unsigned long )lastslash != (unsigned long )((char *)0)) {
#line 234
        tmp___11 = strchr((char const   *)target, '/');
#line 234
        if ((unsigned long )tmp___11 == (unsigned long )((char *)0)) {
#line 234
          tmp___12 = 1;
        } else {
#line 234
          tmp___12 = 0;
        }
      } else {
#line 234
        tmp___12 = 0;
      }
#line 234
      check_lastslash = tmp___12;
#line 236
      if (check_lastslash) {
#line 240
        difference = (unsigned int )((lastslash - filename) + 1L);
#line 241
        if (difference > stemlen) {
#line 242
          goto __Cont___0;
        }
#line 243
        stemlen -= difference;
#line 244
        stem += difference;
      }
#line 248
      if (check_lastslash) {
#line 250
        if ((unsigned long )stem > (unsigned long )(lastslash + 1)) {
#line 250
          tmp___13 = strncmp((char const   *)target, (char const   *)(lastslash + 1),
                             (size_t )((stem - lastslash) - 1L));
#line 250
          if (! (tmp___13 == 0)) {
#line 252
            goto __Cont___0;
          }
        }
      } else
#line 254
      if ((unsigned long )stem > (unsigned long )filename) {
#line 254
        tmp___14 = strncmp((char const   *)target, (char const   *)filename, (size_t )(stem - filename));
#line 254
        if (! (tmp___14 == 0)) {
#line 256
          goto __Cont___0;
        }
      }
#line 263
      if ((int )*suffix != (int )*(stem + stemlen)) {
#line 265
        goto __Cont___0;
      } else
#line 263
      if ((int )*suffix != 0) {
#line 263
        if (! ((unsigned long )(suffix + 1) == (unsigned long )(stem + (stemlen + 1U)))) {
#line 263
          if ((int )*(suffix + 1) == (int )*(stem + (stemlen + 1U))) {
#line 263
            if (! ((int )*(suffix + 1) == 0)) {
#line 263
              tmp___15 = strcmp((char const   *)((suffix + 1) + 1), (char const   *)((stem + (stemlen + 1U)) + 1));
#line 263
              if (tmp___15) {
#line 265
                goto __Cont___0;
              }
            }
          } else {
#line 265
            goto __Cont___0;
          }
        }
      }
#line 268
      if ((int )*(target + 1) != 0) {
#line 269
        specific_rule_matched = 1;
      }
#line 273
      if ((unsigned long )rule->deps == (unsigned long )((struct dep *)0)) {
#line 273
        if ((unsigned long )rule->cmds == (unsigned long )((struct commands *)0)) {
#line 274
          goto __Cont___0;
        }
      }
#line 279
      *(tryrules + nrules) = rule;
#line 280
      *(matches + nrules) = i;
#line 281
      *(checked_lastslash + nrules) = (char )check_lastslash;
#line 282
      nrules ++;
      __Cont___0: /* CIL Label */ 
#line 205
      i ++;
    }
    __Cont: /* CIL Label */ 
#line 190
    rule = rule->next;
  }
#line 288
  if (specific_rule_matched) {
#line 289
    i = 0U;
#line 289
    while (i < nrules) {
#line 290
      if (! (*(tryrules + i))->terminal) {
#line 293
        j = 0U;
#line 293
        while ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0)) {
#line 294
          if ((int )*(*((*(tryrules + i))->targets + j) + 1) == 0) {
#line 295
            break;
          }
#line 293
          j ++;
        }
#line 296
        if ((unsigned long )*((*(tryrules + i))->targets + j) != (unsigned long )((char *)0)) {
#line 297
          *(tryrules + i) = (struct rule *)0;
        }
      }
#line 289
      i ++;
    }
  }
#line 301
  intermed_ok = 0;
#line 301
  while (intermed_ok == ! (! intermed_ok)) {
#line 307
    i = 0U;
#line 307
    while (i < nrules) {
#line 311
      rule = *(tryrules + i);
#line 315
      if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
#line 316
        goto __Cont___1;
      }
#line 320
      if (intermed_ok) {
#line 320
        if (rule->terminal) {
#line 321
          goto __Cont___1;
        }
      }
#line 325
      rule->in_use = (char)1;
#line 329
      stem = (filename + (*(rule->suffixes + *(matches + i)) - *(rule->targets + *(matches + i)))) - 1;
#line 331
      stemlen = (namelen - *(rule->lens + *(matches + i))) + 1U;
#line 332
      check_lastslash___0 = (int )*(checked_lastslash + i);
#line 333
      if (check_lastslash___0) {
#line 335
        stem += (lastslash - filename) + 1L;
#line 336
        stemlen = (unsigned int )((long )stemlen - ((lastslash - filename) + 1L));
      }
#line 339
      while (1) {
#line 339
        if (8 & db_level) {
#line 339
          print_spaces(depth);
#line 339
          tmp___16 = dcgettext((char const   *)((void *)0), "Trying pattern rule with stem `%.*s\'.\n",
                               5);
#line 339
          printf((char const   * __restrict  )tmp___16, (int )stemlen, stem);
#line 339
          fflush(stdout);
        }
#line 339
        break;
      }
#line 344
      deps_found = 0U;
#line 345
      dep = rule->deps;
#line 345
      while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
#line 348
        if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 348
          tmp___17 = (dep->file)->name;
        } else {
#line 348
          tmp___17 = dep->name;
        }
#line 348
        p = strchr((char const   *)tmp___17, '%');
#line 349
        if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 352
          if (check_lastslash___0) {
#line 355
            i___0 = (unsigned int )((lastslash - filename) + 1L);
#line 356
            memmove((void *)depname, (void const   *)filename, (size_t )i___0);
          } else {
#line 359
            i___0 = 0U;
          }
#line 360
          if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 360
            tmp___18 = (dep->file)->name;
          } else {
#line 360
            tmp___18 = dep->name;
          }
#line 360
          if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 360
            tmp___19 = (dep->file)->name;
          } else {
#line 360
            tmp___19 = dep->name;
          }
#line 360
          memmove((void *)(depname + i___0), (void const   *)tmp___19, (size_t )(p - tmp___18));
#line 361
          if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 361
            tmp___20 = (dep->file)->name;
          } else {
#line 361
            tmp___20 = dep->name;
          }
#line 361
          i___0 = (unsigned int )((long )i___0 + (p - tmp___20));
#line 362
          memmove((void *)(depname + i___0), (void const   *)stem, (size_t )stemlen);
#line 363
          i___0 += stemlen;
#line 364
          strcpy((char * __restrict  )(depname + i___0), (char const   * __restrict  )(p + 1));
#line 365
          p = depname;
        } else
#line 368
        if ((unsigned long )dep->name == (unsigned long )((char *)0)) {
#line 368
          p = (dep->file)->name;
        } else {
#line 368
          p = dep->name;
        }
#line 372
        tmp___24 = file_impossible_p(p);
#line 372
        if (tmp___24) {
#line 378
          while (1) {
#line 378
            if (8 & db_level) {
#line 378
              print_spaces(depth);
#line 378
              if ((unsigned long )p == (unsigned long )depname) {
#line 378
                tmp___21 = dcgettext((char const   *)((void *)0), "Rejecting impossible implicit prerequisite `%s\'.\n",
                                     5);
#line 378
                tmp___23 = tmp___21;
              } else {
#line 378
                tmp___22 = dcgettext((char const   *)((void *)0), "Rejecting impossible rule prerequisite `%s\'.\n",
                                     5);
#line 378
                tmp___23 = tmp___22;
              }
#line 378
              printf((char const   * __restrict  )tmp___23, p);
#line 378
              fflush(stdout);
            }
#line 378
            break;
          }
#line 383
          *(tryrules + i) = (struct rule *)0;
#line 384
          break;
        }
#line 387
        *(intermediate_files + deps_found) = (struct file *)0;
#line 389
        while (1) {
#line 389
          if (8 & db_level) {
#line 389
            print_spaces(depth);
#line 389
            if ((unsigned long )p == (unsigned long )depname) {
#line 389
              tmp___25 = dcgettext((char const   *)((void *)0), "Trying implicit prerequisite `%s\'.\n",
                                   5);
#line 389
              tmp___27 = tmp___25;
            } else {
#line 389
              tmp___26 = dcgettext((char const   *)((void *)0), "Trying rule prerequisite `%s\'.\n",
                                   5);
#line 389
              tmp___27 = tmp___26;
            }
#line 389
            printf((char const   * __restrict  )tmp___27, p);
#line 389
            fflush(stdout);
          }
#line 389
          break;
        }
#line 401
        if (! dep->changed) {
#line 401
          goto _L;
        } else
#line 401
        if (check_lastslash___0) {
          _L: /* CIL Label */ 
#line 401
          tmp___29 = lookup_file(p);
#line 401
          if ((unsigned long )tmp___29 != (unsigned long )((struct file *)0)) {
#line 404
            tmp___28 = deps_found;
#line 404
            deps_found ++;
#line 404
            *(found_files + tmp___28) = xstrdup((char const   *)p);
#line 405
            goto __Cont___2;
          } else {
#line 401
            tmp___30 = file_exists_p(p);
#line 401
            if (tmp___30) {
#line 404
              tmp___28 = deps_found;
#line 404
              deps_found ++;
#line 404
              *(found_files + tmp___28) = xstrdup((char const   *)p);
#line 405
              goto __Cont___2;
            }
          }
        }
#line 409
        vp = p;
#line 410
        tmp___33 = vpath_search(& vp, (uintmax_t *)0);
#line 410
        if (tmp___33) {
#line 412
          while (1) {
#line 412
            if (8 & db_level) {
#line 412
              print_spaces(depth);
#line 412
              tmp___31 = dcgettext((char const   *)((void *)0), "Found prerequisite `%s\' as VPATH `%s\'\n",
                                   5);
#line 412
              printf((char const   * __restrict  )tmp___31, p, vp);
#line 412
              fflush(stdout);
            }
#line 412
            break;
          }
#line 414
          strcpy((char * __restrict  )vp, (char const   * __restrict  )p);
#line 415
          tmp___32 = deps_found;
#line 415
          deps_found ++;
#line 415
          *(found_files + tmp___32) = vp;
#line 416
          goto __Cont___2;
        }
#line 423
        if (intermed_ok) {
#line 425
          if ((unsigned long )intermediate_file == (unsigned long )((struct file *)0)) {
#line 426
            tmp___34 = __builtin_alloca(sizeof(struct file ));
#line 426
            intermediate_file = (struct file *)tmp___34;
          }
#line 429
          while (1) {
#line 429
            if (8 & db_level) {
#line 429
              print_spaces(depth);
#line 429
              tmp___35 = dcgettext((char const   *)((void *)0), "Looking for a rule with intermediate file `%s\'.\n",
                                   5);
#line 429
              printf((char const   * __restrict  )tmp___35, p);
#line 429
              fflush(stdout);
            }
#line 429
            break;
          }
#line 433
          memset((void *)((char *)intermediate_file), 0, sizeof(struct file ));
#line 434
          intermediate_file->name = p;
#line 435
          tmp___36 = pattern_search(intermediate_file, 0, depth + 1U, recursions + 1U);
#line 435
          if (tmp___36) {
#line 438
            p = xstrdup((char const   *)p);
#line 439
            *(intermediate_patterns + deps_found) = intermediate_file->name;
#line 441
            intermediate_file->name = p;
#line 442
            *(intermediate_files + deps_found) = intermediate_file;
#line 443
            intermediate_file = (struct file *)0;
#line 447
            *(found_files + deps_found) = xstrdup((char const   *)p);
#line 448
            deps_found ++;
#line 449
            goto __Cont___2;
          }
#line 455
          file_impossible(p);
        }
#line 460
        break;
        __Cont___2: /* CIL Label */ 
#line 345
        dep = dep->next;
      }
#line 464
      rule->in_use = (char)0;
#line 466
      if ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
#line 471
        while (1) {
#line 471
          tmp___38 = deps_found;
#line 471
          deps_found --;
#line 471
          if (! (tmp___38 > 0U)) {
#line 471
            break;
          }
#line 473
          f = *(intermediate_files + deps_found);
#line 474
          free((void *)*(found_files + deps_found));
#line 475
          if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 475
            if ((unsigned long )f->stem < (unsigned long )f->name) {
#line 478
              free((void *)f->stem);
            } else {
#line 475
              tmp___37 = strlen((char const   *)f->name);
#line 475
              if ((unsigned long )f->stem > (unsigned long )(f->name + tmp___37)) {
#line 478
                free((void *)f->stem);
              }
            }
          }
        }
      } else {
#line 483
        break;
      }
      __Cont___1: /* CIL Label */ 
#line 307
      i ++;
    }
#line 488
    if (i < nrules) {
#line 489
      break;
    }
#line 491
    rule = (struct rule *)0;
#line 301
    intermed_ok ++;
  }
#line 496
  if ((unsigned long )rule == (unsigned long )((struct rule *)0)) {
#line 497
    return (0);
  }
#line 499
  foundrule = i;
#line 504
  if (recursions > 0U) {
#line 506
    file->name = *(rule->targets + *(matches + foundrule));
  }
#line 512
  while (1) {
#line 512
    tmp___41 = deps_found;
#line 512
    deps_found --;
#line 512
    if (! (tmp___41 > 0U)) {
#line 512
      break;
    }
#line 516
    if ((unsigned long )*(intermediate_files + deps_found) != (unsigned long )((struct file *)0)) {
#line 525
      imf = *(intermediate_files + deps_found);
#line 526
      tmp___39 = enter_file(imf->name);
#line 526
      f___0 = tmp___39;
#line 527
      f___0->deps = imf->deps;
#line 528
      f___0->cmds = imf->cmds;
#line 529
      f___0->stem = imf->stem;
#line 530
      f___0->also_make = imf->also_make;
#line 531
      imf = lookup_file(*(intermediate_patterns + deps_found));
#line 532
      if ((unsigned long )imf != (unsigned long )((struct file *)0)) {
#line 532
        if (imf->precious) {
#line 533
          f___0->precious = 1U;
        }
      }
#line 534
      f___0->intermediate = 1U;
#line 535
      f___0->tried_implicit = 1U;
#line 536
      dep = f___0->deps;
#line 536
      while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
#line 538
        dep->file = enter_file(dep->name);
#line 540
        if ((unsigned long )dep->name != (unsigned long )(dep->file)->name) {
#line 541
          free((void *)dep->name);
        }
#line 542
        dep->name = (char *)0;
#line 543
        (dep->file)->tried_implicit |= (unsigned int )dep->changed;
#line 536
        dep = dep->next;
      }
#line 545
      num_intermediates ++;
    }
#line 548
    tmp___40 = xmalloc((unsigned int )sizeof(struct dep ));
#line 548
    dep = (struct dep *)tmp___40;
#line 549
    s = *(found_files + deps_found);
#line 550
    if (recursions == 0U) {
#line 552
      dep->name = (char *)0;
#line 553
      dep->file = lookup_file(s);
#line 554
      if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
#line 556
        dep->file = enter_file(s);
      } else {
#line 560
        free((void *)s);
      }
    } else {
#line 564
      dep->name = s;
#line 565
      dep->file = (struct file *)0;
#line 566
      dep->changed = 0;
    }
#line 568
    if ((unsigned long )*(intermediate_files + deps_found) == (unsigned long )((struct file *)0)) {
#line 568
      if ((*(tryrules + foundrule))->terminal) {
#line 575
        if ((unsigned long )dep->file == (unsigned long )((struct file *)0)) {
#line 576
          dep->changed = 1;
        } else {
#line 578
          (dep->file)->tried_implicit = 1U;
        }
      }
    }
#line 580
    dep->next = file->deps;
#line 581
    file->deps = dep;
  }
#line 584
  if (! *(checked_lastslash + foundrule)) {
#line 587
    file->stem = savestring((char const   *)stem, stemlen);
  } else {
#line 592
    tmp___42 = xmalloc((unsigned int )((((lastslash + 1) - filename) + (long )stemlen) + 1L));
#line 592
    file->stem = tmp___42;
#line 594
    memmove((void *)file->stem, (void const   *)filename, (size_t )((lastslash + 1) - filename));
#line 595
    memmove((void *)(file->stem + ((lastslash + 1) - filename)), (void const   *)stem,
            (size_t )stemlen);
#line 596
    *(file->stem + (((lastslash + 1) - filename) + (long )stemlen)) = (char )'\000';
  }
#line 599
  file->cmds = rule->cmds;
#line 604
  if ((unsigned long )*(rule->targets + 1) != (unsigned long )((char *)0)) {
#line 605
    i = 0U;
#line 605
    while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
#line 606
      if (i != *(matches + foundrule)) {
#line 608
        tmp___43 = xmalloc((unsigned int )sizeof(struct dep ));
#line 608
        new = (struct dep *)tmp___43;
#line 609
        tmp___44 = xmalloc((*(rule->lens + i) + stemlen) + 1U);
#line 609
        p = tmp___44;
#line 609
        new->name = p;
#line 610
        memmove((void *)p, (void const   *)*(rule->targets + i), (size_t )((*(rule->suffixes + i) - *(rule->targets + i)) - 1L));
#line 612
        p += (*(rule->suffixes + i) - *(rule->targets + i)) - 1L;
#line 613
        memmove((void *)p, (void const   *)stem, (size_t )stemlen);
#line 614
        p += stemlen;
#line 615
        memmove((void *)p, (void const   *)*(rule->suffixes + i), (size_t )(((long )*(rule->lens + i) - (*(rule->suffixes + i) - *(rule->targets + i))) + 1L));
#line 617
        new->file = enter_file(new->name);
#line 618
        new->next = file->also_make;
#line 619
        file->also_make = new;
      }
#line 605
      i ++;
    }
  }
#line 623
  return (1);
}
}
#line 1 "job.o"
#pragma merger("0","/tmp/cil-EqvKfePu.i","-g,-O0")
#line 196 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 229
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 537
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 581
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 606
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 1006
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *loadavg ,
                                                                                                 int nelem ) ;
#line 446 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 377 "make.h"
void ( /* format attribute */  message)(int prefix , char const   *fmt  , ...) ;
#line 389
 __attribute__((__noreturn__)) void die(int status ) ;
#line 437
void user_access(void) ;
#line 438
void make_access(void) ;
#line 439
void child_access(void) ;
#line 470
int keep_going_flag ;
#line 478
int batch_mode_shell ;
#line 480
unsigned int job_slots ;
#line 481
int job_fds[2] ;
#line 482
int job_rfd ;
#line 484
double max_load_average ;
#line 494
unsigned int commands_started ;
#line 55 "job.h"
void start_waiting_jobs(void) ;
#line 66
void exec_command(char **argv , char **envp ) ;
#line 71
void block_sigs(void) ;
#line 73
void unblock_sigs(void) ;
#line 135 "variable.h"
char **target_environment(struct file *file ) ;
#line 53 "job.c"
char default_shell[8]  = 
#line 53 "job.c"
  {      (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'s',      (char )'h',      (char )'\000'};
#line 56 "job.c"
int batch_mode_shell  =    0;
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 77 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(int *__stat_loc ) ;
#line 100
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 190 "job.c"
int start_remote_job(char **argv , char **envp , int stdin_fd , int *is_remote , int *id_ptr ,
                     int *used_stdin ) ;
#line 192
int start_remote_job_p(int first_p ) ;
#line 193
int remote_status(int *exit_code_ptr , int *signal_ptr , int *coredump_ptr , int block ) ;
#line 196
void child_handler(int sig ) ;
#line 197
static void free_child(struct child *child ) ;
#line 198
static void start_job_command(struct child *child ) ;
#line 199
static int load_too_high(void) ;
#line 200
static int job_next_command(struct child *child ) ;
#line 201
static int start_waiting_job(struct child *c ) ;
#line 208 "job.c"
struct child *children  =    (struct child *)0;
#line 212 "job.c"
unsigned int job_slots_used  =    0U;
#line 216 "job.c"
static int good_stdin_used  =    0;
#line 220 "job.c"
static struct child *waiting_jobs  =    (struct child *)0;
#line 224 "job.c"
int unixy_shell  =    1;
#line 241 "job.c"
static void child_error(char *target_name , int exit_code , int exit_sig , int coredump ,
                        int ignored ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
#line 247
  if (ignored) {
#line 247
    if (silent_flag) {
#line 248
      return;
    }
  }
#line 257
  if (exit_sig == 0) {
#line 258
    if (ignored) {
#line 258
      tmp = dcgettext((char const   *)((void *)0), "[%s] Error %d (ignored)", 5);
#line 258
      tmp___1 = tmp;
    } else {
#line 258
      tmp___0 = dcgettext((char const   *)((void *)0), "*** [%s] Error %d", 5);
#line 258
      tmp___1 = tmp___0;
    }
#line 258
    error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, target_name,
          exit_code);
  } else {
#line 262
    if (coredump) {
#line 262
      tmp___2 = dcgettext((char const   *)((void *)0), " (core dumped)", 5);
#line 262
      tmp___3 = (char const   *)tmp___2;
    } else {
#line 262
      tmp___3 = "";
    }
#line 262
    tmp___4 = strsignal(exit_sig);
#line 262
    error((struct floc  const  *)((struct floc *)0), "*** [%s] %s%s", target_name,
          tmp___4, tmp___3);
  }
#line 266
  return;
}
}
#line 390 "job.c"
static unsigned int dead_children  =    0U;
#line 392 "job.c"
void child_handler(int sig ) 
{ 
  char *tmp ;

  {
#line 396
  dead_children ++;
#line 398
  if (job_rfd >= 0) {
#line 400
    close(job_rfd);
#line 401
    job_rfd = -1;
  }
#line 404
  while (1) {
#line 404
    if (4 & db_level) {
#line 404
      tmp = dcgettext((char const   *)((void *)0), "Got a SIGCHLD; %u unreaped children.\n",
                      5);
#line 404
      printf((char const   * __restrict  )tmp, dead_children);
#line 404
      fflush(stdout);
    }
#line 404
    break;
  }
#line 405
  return;
}
}
#line 666 "job.c"
static int delete_on_error  =    -1;
#line 417 "job.c"
void reap_children(int block , int err ) 
{ 
  int status ;
  int reap_more ;
  int remote ;
  register int pid ;
  int exit_code ;
  int exit_sig ;
  int coredump ;
  register struct child *lastc ;
  register struct child *c ;
  int child_failed ;
  int any_remote ;
  int any_local ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct file *f ;
  struct file *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;

  {
#line 423
  reap_more = 1;
#line 439
  while (1) {
#line 439
    if ((unsigned long )children != (unsigned long )((struct child *)0)) {
#line 439
      goto _L___1;
    } else
#line 439
    if (shell_function_pid != 0) {
      _L___1: /* CIL Label */ 
#line 439
      if (! block) {
#line 439
        if (! reap_more) {
#line 439
          break;
        }
      }
    } else {
#line 439
      break;
    }
#line 442
    remote = 0;
#line 449
    if (err) {
#line 449
      if (block) {
#line 452
        fflush(stdout);
#line 453
        tmp = dcgettext((char const   *)((void *)0), "*** Waiting for unfinished jobs....",
                        5);
#line 453
        error((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
      }
    }
#line 473
    if (dead_children > 0U) {
#line 474
      dead_children --;
    }
#line 476
    any_remote = 0;
#line 477
    any_local = shell_function_pid != 0;
#line 478
    c = children;
#line 478
    while ((unsigned long )c != (unsigned long )((struct child *)0)) {
#line 480
      any_remote = (int )((unsigned int )any_remote | c->remote);
#line 481
      any_local |= ! c->remote;
#line 482
      while (1) {
#line 482
        if (4 & db_level) {
#line 482
          if (c->remote) {
#line 482
            tmp___0 = dcgettext((char const   *)((void *)0), " (remote)", 5);
#line 482
            tmp___1 = (char const   *)tmp___0;
          } else {
#line 482
            tmp___1 = "";
          }
#line 482
          tmp___2 = dcgettext((char const   *)((void *)0), "Live child 0x%08lx (%s) PID %ld %s\n",
                              5);
#line 482
          printf((char const   * __restrict  )tmp___2, (unsigned long )c, (c->file)->name,
                 (long )c->pid, tmp___1);
#line 482
          fflush(stdout);
        }
#line 482
        break;
      }
#line 478
      c = c->next;
    }
#line 491
    if (any_remote) {
#line 492
      pid = remote_status(& exit_code, & exit_sig, & coredump, 0);
    } else {
#line 494
      pid = 0;
    }
#line 496
    if (pid > 0) {
#line 498
      remote = 1;
    } else
#line 499
    if (pid < 0) {
      remote_status_lose: 
#line 503
      tmp___3 = __errno_location();
#line 503
      if (*tmp___3 == 4) {
#line 504
        continue;
      }
#line 506
      pfatal_with_name((char *)"remote_status");
    } else {
#line 512
      if (any_local) {
        local_wait: 
#line 520
        if (! block) {
#line 521
          pid = waitpid(-1, & status, 1);
        } else {
#line 524
          pid = wait(& status);
        }
      } else {
#line 528
        pid = 0;
      }
#line 530
      if (pid < 0) {
#line 533
        tmp___4 = __errno_location();
#line 533
        if (*tmp___4 == 4) {
#line 534
          goto local_wait;
        }
#line 537
        pfatal_with_name((char *)"wait");
      } else
#line 539
      if (pid > 0) {
#line 542
        exit_code = (status & 65280) >> 8;
#line 543
        if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
#line 543
          exit_sig = status & 127;
        } else {
#line 543
          exit_sig = 0;
        }
#line 544
        coredump = status & 128;
      } else {
#line 549
        reap_more = 0;
#line 551
        if (! block) {
#line 552
          break;
        } else
#line 551
        if (! any_remote) {
#line 552
          break;
        }
#line 555
        pid = remote_status(& exit_code, & exit_sig, & coredump, 1);
#line 556
        if (pid < 0) {
#line 557
          goto remote_status_lose;
        } else
#line 558
        if (pid == 0) {
#line 560
          break;
        }
#line 563
        remote = 1;
      }
    }
#line 617
    if (! remote) {
#line 617
      if (pid == shell_function_pid) {
#line 620
        if (exit_sig == 0) {
#line 620
          if (exit_code == 127) {
#line 621
            shell_function_completed = -1;
          } else {
#line 623
            shell_function_completed = 1;
          }
        } else {
#line 623
          shell_function_completed = 1;
        }
#line 624
        break;
      }
    }
#line 627
    if (exit_sig != 0) {
#line 627
      tmp___5 = 1;
    } else
#line 627
    if (exit_code != 0) {
#line 627
      tmp___5 = 1;
    } else {
#line 627
      tmp___5 = 0;
    }
#line 627
    child_failed = tmp___5;
#line 630
    lastc = (struct child *)0;
#line 631
    c = children;
#line 631
    while ((unsigned long )c != (unsigned long )((struct child *)0)) {
#line 632
      if (c->remote == (unsigned int )remote) {
#line 632
        if (c->pid == pid) {
#line 633
          break;
        }
      }
#line 631
      lastc = c;
#line 631
      c = c->next;
    }
#line 635
    if ((unsigned long )c == (unsigned long )((struct child *)0)) {
#line 638
      continue;
    }
#line 640
    while (1) {
#line 640
      if (4 & db_level) {
#line 640
        if (c->remote) {
#line 640
          tmp___6 = dcgettext((char const   *)((void *)0), " (remote)", 5);
#line 640
          tmp___7 = (char const   *)tmp___6;
        } else {
#line 640
          tmp___7 = "";
        }
#line 640
        if (child_failed) {
#line 640
          tmp___8 = dcgettext((char const   *)((void *)0), "Reaping losing child 0x%08lx PID %ld %s\n",
                              5);
#line 640
          tmp___10 = tmp___8;
        } else {
#line 640
          tmp___9 = dcgettext((char const   *)((void *)0), "Reaping winning child 0x%08lx PID %ld %s\n",
                              5);
#line 640
          tmp___10 = tmp___9;
        }
#line 640
        printf((char const   * __restrict  )tmp___10, (unsigned long )c, (long )c->pid,
               tmp___7);
#line 640
        fflush(stdout);
      }
#line 640
      break;
    }
#line 646
    if (c->sh_batch_file) {
#line 647
      while (1) {
#line 647
        if (4 & db_level) {
#line 647
          tmp___11 = dcgettext((char const   *)((void *)0), "Cleaning up temp batch file %s\n",
                               5);
#line 647
          printf((char const   * __restrict  )tmp___11, c->sh_batch_file);
#line 647
          fflush(stdout);
        }
#line 647
        break;
      }
#line 651
      remove((char const   *)c->sh_batch_file);
#line 654
      free((void *)c->sh_batch_file);
#line 655
      c->sh_batch_file = (char *)((void *)0);
    }
#line 659
    if (c->good_stdin) {
#line 660
      good_stdin_used = 0;
    }
#line 662
    if (child_failed) {
#line 662
      if (! c->noerror) {
#line 662
        if (! ignore_errors_flag) {
#line 667
          child_error((c->file)->name, exit_code, exit_sig, coredump, 0);
#line 668
          (c->file)->update_status = (short)2;
#line 669
          if (delete_on_error == -1) {
#line 671
            tmp___12 = lookup_file((char *)".DELETE_ON_ERROR");
#line 671
            f = tmp___12;
#line 672
            if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 672
              if (f->is_target) {
#line 672
                tmp___13 = 1;
              } else {
#line 672
                tmp___13 = 0;
              }
            } else {
#line 672
              tmp___13 = 0;
            }
#line 672
            delete_on_error = tmp___13;
          }
#line 674
          if (exit_sig != 0) {
#line 675
            delete_child_targets(c);
          } else
#line 674
          if (delete_on_error) {
#line 675
            delete_child_targets(c);
          }
        } else {
#line 662
          goto _L___0;
        }
      } else {
#line 662
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 679
      if (child_failed) {
#line 682
        child_error((c->file)->name, exit_code, exit_sig, coredump, 1);
#line 684
        child_failed = 0;
      }
#line 688
      tmp___15 = job_next_command(c);
#line 688
      if (tmp___15) {
#line 690
        if (handling_fatal_signal) {
#line 696
          (c->file)->update_status = (short)2;
        } else {
#line 704
          tmp___14 = start_remote_job_p(0);
#line 704
          c->remote = (unsigned int )tmp___14;
#line 705
          start_job_command(c);
#line 710
          unblock_sigs();
#line 711
          if ((unsigned int )(c->file)->command_state == 2U) {
#line 714
            continue;
          }
        }
#line 717
        if ((int )(c->file)->update_status != 0) {
#line 719
          delete_child_targets(c);
        }
      } else {
#line 725
        (c->file)->update_status = (short)0;
      }
    }
#line 734
    if (! handling_fatal_signal) {
#line 738
      notice_finished_file(c->file);
    }
#line 740
    while (1) {
#line 740
      if (4 & db_level) {
#line 740
        if (c->remote) {
#line 740
          tmp___16 = dcgettext((char const   *)((void *)0), " (remote)", 5);
#line 740
          tmp___17 = (char const   *)tmp___16;
        } else {
#line 740
          tmp___17 = "";
        }
#line 740
        tmp___18 = dcgettext((char const   *)((void *)0), "Removing child 0x%08lx PID %ld %s from chain.\n",
                             5);
#line 740
        printf((char const   * __restrict  )tmp___18, (unsigned long )c, (long )c->pid,
               tmp___17);
#line 740
        fflush(stdout);
      }
#line 740
      break;
    }
#line 749
    block_sigs();
#line 752
    if (job_slots_used > 0U) {
#line 753
      job_slots_used --;
    }
#line 756
    if ((unsigned long )lastc == (unsigned long )((struct child *)0)) {
#line 757
      children = c->next;
    } else {
#line 759
      lastc->next = c->next;
    }
#line 761
    free_child(c);
#line 763
    unblock_sigs();
#line 767
    if (! err) {
#line 767
      if (child_failed) {
#line 767
        if (! keep_going_flag) {
#line 767
          if (! handling_fatal_signal) {
#line 770
            die(2);
          }
        }
      }
    }
#line 773
    block = 0;
  }
#line 776
  return;
}
}
#line 781 "job.c"
static void free_child(struct child *child ) 
{ 
  char token ;
  char *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  char *tmp___2 ;
  register unsigned int i ;
  register char **ep ;
  char **tmp___3 ;

  {
#line 789
  if (job_fds[1] >= 0) {
#line 789
    if (children) {
#line 791
      token = (char )'+';
#line 795
      while (1) {
#line 795
        tmp___1 = write(job_fds[1], (void const   *)(& token), (size_t )1);
#line 795
        if (! (tmp___1 != 1L)) {
#line 795
          break;
        }
#line 796
        tmp___0 = __errno_location();
#line 796
        if (! (*tmp___0 == 4)) {
#line 797
          tmp = dcgettext((char const   *)((void *)0), "write jobserver", 5);
#line 797
          pfatal_with_name(tmp);
        }
      }
#line 799
      while (1) {
#line 799
        if (4 & db_level) {
#line 799
          tmp___2 = dcgettext((char const   *)((void *)0), "Released token for child 0x%08lx (%s).\n",
                              5);
#line 799
          printf((char const   * __restrict  )tmp___2, (unsigned long )child, (child->file)->name);
#line 799
          fflush(stdout);
        }
#line 799
        break;
      }
    }
  }
#line 803
  if (handling_fatal_signal) {
#line 804
    return;
  }
#line 806
  if ((unsigned long )child->command_lines != (unsigned long )((char **)0)) {
#line 809
    i = 0U;
#line 809
    while (i < ((child->file)->cmds)->ncommand_lines) {
#line 810
      free((void *)*(child->command_lines + i));
#line 809
      i ++;
    }
#line 811
    free((void *)((char *)child->command_lines));
  }
#line 814
  if ((unsigned long )child->environment != (unsigned long )((char **)0)) {
#line 816
    ep = child->environment;
#line 817
    while ((unsigned long )*ep != (unsigned long )((char *)0)) {
#line 818
      tmp___3 = ep;
#line 818
      ep ++;
#line 818
      free((void *)*tmp___3);
    }
#line 819
    free((void *)((char *)child->environment));
  }
#line 822
  free((void *)((char *)child));
#line 823
  return;
}
}
#line 826
sigset_t fatal_signal_set ;
#line 829 "job.c"
void block_sigs(void) 
{ 


  {
#line 833
  sigprocmask(0, (sigset_t const   * __restrict  )(& fatal_signal_set), (sigset_t * __restrict  )((sigset_t *)0));
#line 839
  return;
}
}
#line 842 "job.c"
void unblock_sigs(void) 
{ 
  sigset_t empty ;

  {
#line 846
  sigemptyset(& empty);
#line 847
  sigprocmask(2, (sigset_t const   * __restrict  )(& empty), (sigset_t * __restrict  )((sigset_t *)0));
#line 848
  return;
}
}
#line 863 "job.c"
static int bad_stdin  =    -1;
#line 858 "job.c"
static void start_job_command(struct child *child ) 
{ 
  register char *p ;
  int flags ;
  char **argv ;
  unsigned short const   **tmp ;
  char *end ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int pd[2] ;
  int tmp___4 ;
  int is_remote ;
  int id ;
  int used_stdin ;
  int tmp___5 ;
  int tmp___6 ;
  char **parent_environ ;
  int tmp___7 ;

  {
#line 874
  if (! child->command_ptr) {
#line 875
    goto next_command;
  }
#line 879
  flags = (child->file)->command_flags | (int )*(((child->file)->cmds)->lines_flags + (child->command_line - 1U));
#line 882
  p = child->command_ptr;
#line 883
  child->noerror = (unsigned int )(flags & 4);
#line 885
  while ((int )*p != 0) {
#line 887
    if ((int )*p == 64) {
#line 888
      flags |= 2;
    } else
#line 889
    if ((int )*p == 43) {
#line 890
      flags |= 1;
    } else
#line 891
    if ((int )*p == 45) {
#line 892
      child->noerror = 1U;
    } else {
#line 893
      tmp = __ctype_b_loc();
#line 893
      if (! ((int const   )*(*tmp + (int )*p) & 1)) {
#line 894
        break;
      }
    }
#line 895
    p ++;
  }
#line 899
  *(((child->file)->cmds)->lines_flags + (child->command_line - 1U)) = (char )((int )*(((child->file)->cmds)->lines_flags + (child->command_line - 1U)) | flags);
#line 904
  if (question_flag) {
#line 904
    if (! (flags & 1)) {
#line 906
      (child->file)->update_status = (short)1;
#line 907
      notice_finished_file(child->file);
#line 908
      return;
    }
  }
#line 913
  p = next_token(p);
#line 918
  end = (char *)0;
#line 922
  argv = construct_command_argv(p, & end, child->file, & child->sh_batch_file);
#line 924
  if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 925
    child->command_ptr = (char *)((void *)0);
  } else {
#line 928
    tmp___0 = end;
#line 928
    end ++;
#line 928
    *tmp___0 = (char )'\000';
#line 929
    child->command_ptr = end;
  }
#line 933
  if (touch_flag) {
#line 933
    if (! (flags & 1)) {
#line 938
      free((void *)*(argv + 0));
#line 939
      free((void *)((char *)argv));
#line 941
      argv = (char **)0;
    }
  }
#line 944
  if ((unsigned long )argv == (unsigned long )((char **)0)) {
    next_command: 
#line 951
    tmp___1 = job_next_command(child);
#line 951
    if (tmp___1) {
#line 952
      start_job_command(child);
    } else {
#line 957
      set_command_state(child->file, 2);
#line 958
      (child->file)->update_status = (short)0;
#line 959
      notice_finished_file(child->file);
    }
#line 961
    return;
  }
#line 968
  if (just_print_flag) {
#line 968
    tmp___2 = "%s";
  } else
#line 968
  if (! (flags & 2)) {
#line 968
    if (! silent_flag) {
#line 968
      tmp___2 = "%s";
    } else {
#line 968
      tmp___2 = (char const   *)((char *)0);
    }
  } else {
#line 968
    tmp___2 = (char const   *)((char *)0);
  }
#line 968
  message(0, tmp___2, p);
#line 975
  if (*(argv + 0)) {
#line 975
    tmp___3 = strcmp((char const   *)*(argv + 0), "/bin/sh");
#line 975
    if (! tmp___3) {
#line 975
      if (*(argv + 1)) {
#line 975
        if ((int )*(*(argv + 1) + 0) == 45) {
#line 975
          if ((int )*(*(argv + 1) + 1) == 99) {
#line 975
            if ((int )*(*(argv + 1) + 2) == 0) {
#line 975
              if (*(argv + 2)) {
#line 975
                if ((int )*(*(argv + 2) + 0) == 58) {
#line 975
                  if ((int )*(*(argv + 2) + 1) == 0) {
#line 975
                    if ((unsigned long )*(argv + 3) == (unsigned long )((void *)0)) {
#line 986
                      free((void *)*(argv + 0));
#line 987
                      free((void *)((char *)argv));
#line 988
                      goto next_command;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 999
  commands_started ++;
#line 1003
  if (just_print_flag) {
#line 1003
    if (! (flags & 1)) {
#line 1006
      free((void *)*(argv + 0));
#line 1007
      free((void *)((char *)argv));
#line 1009
      goto next_command;
    }
  }
#line 1014
  fflush(stdout);
#line 1015
  fflush(stderr);
#line 1022
  if (bad_stdin == -1) {
#line 1027
    tmp___4 = pipe((int *)(pd));
#line 1027
    if (tmp___4 == 0) {
#line 1030
      close(pd[1]);
#line 1032
      bad_stdin = pd[0];
#line 1037
      fcntl(bad_stdin, 2, 1);
    }
  }
#line 1047
  child->good_stdin = (unsigned int )(! good_stdin_used);
#line 1048
  if (child->good_stdin) {
#line 1049
    good_stdin_used = 1;
  }
#line 1053
  child->deleted = 0U;
#line 1057
  if ((unsigned long )child->environment == (unsigned long )((char **)0)) {
#line 1058
    child->environment = target_environment(child->file);
  }
#line 1065
  if (child->remote) {
#line 1068
    if (child->good_stdin) {
#line 1068
      tmp___5 = 0;
    } else {
#line 1068
      tmp___5 = bad_stdin;
    }
#line 1068
    tmp___6 = start_remote_job(argv, child->environment, tmp___5, & is_remote, & id,
                               & used_stdin);
#line 1068
    if (tmp___6) {
#line 1073
      goto run_local;
    } else {
#line 1076
      if (child->good_stdin) {
#line 1076
        if (! used_stdin) {
#line 1078
          child->good_stdin = 0U;
#line 1079
          good_stdin_used = 0;
        }
      }
#line 1081
      child->remote = (unsigned int )is_remote;
#line 1082
      child->pid = id;
    }
  } else {
    run_local: 
#line 1093
    block_sigs();
#line 1095
    child->remote = 0U;
#line 1107
    parent_environ = environ;
#line 1108
    child->pid = vfork();
#line 1109
    environ = parent_environ;
#line 1110
    if (child->pid == 0) {
#line 1113
      unblock_sigs();
#line 1117
      if (! (flags & 1)) {
#line 1117
        if (job_fds[0] >= 0) {
#line 1119
          close(job_fds[0]);
#line 1120
          close(job_fds[1]);
        }
      }
#line 1122
      if (job_rfd >= 0) {
#line 1123
        close(job_rfd);
      }
#line 1125
      if (child->good_stdin) {
#line 1125
        tmp___7 = 0;
      } else {
#line 1125
        tmp___7 = bad_stdin;
      }
#line 1125
      child_execute_job(tmp___7, 1, argv, child->environment);
    } else
#line 1128
    if (child->pid < 0) {
#line 1131
      unblock_sigs();
#line 1132
      perror_with_name((char *)"vfork", (char *)"");
#line 1133
      goto error;
    }
  }
#line 1242
  set_command_state(child->file, 2);
#line 1246
  free((void *)*(argv + 0));
#line 1247
  free((void *)((char *)argv));
#line 1250
  return;
  error: 
#line 1253
  (child->file)->update_status = (short)2;
#line 1254
  notice_finished_file(child->file);
#line 1255
  return;
}
}
#line 1262 "job.c"
static int start_waiting_job(struct child *c ) 
{ 
  struct file *f ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 1266
  f = c->file;
#line 1272
  tmp = start_remote_job_p(1);
#line 1272
  c->remote = (unsigned int )tmp;
#line 1276
  if (! c->remote) {
#line 1276
    if (job_slots_used > 0U) {
#line 1276
      tmp___0 = load_too_high();
#line 1276
      if (tmp___0) {
#line 1280
        set_command_state(f, 2);
#line 1281
        c->next = waiting_jobs;
#line 1282
        waiting_jobs = c;
#line 1283
        return (0);
      }
    }
  }
#line 1287
  start_job_command(c);
#line 1289
  switch ((unsigned int )f->command_state) {
  case 2U: 
#line 1292
  c->next = children;
#line 1293
  while (1) {
#line 1293
    if (4 & db_level) {
#line 1293
      if (c->remote) {
#line 1293
        tmp___1 = dcgettext((char const   *)((void *)0), " (remote)", 5);
#line 1293
        tmp___2 = (char const   *)tmp___1;
      } else {
#line 1293
        tmp___2 = "";
      }
#line 1293
      tmp___3 = dcgettext((char const   *)((void *)0), "Putting child 0x%08lx (%s) PID %ld%s on the chain.\n",
                          5);
#line 1293
      printf((char const   * __restrict  )tmp___3, (unsigned long )c, (c->file)->name,
             (long )c->pid, tmp___2);
#line 1293
      fflush(stdout);
    }
#line 1293
    break;
  }
#line 1296
  children = c;
#line 1298
  job_slots_used ++;
#line 1299
  unblock_sigs();
#line 1300
  break;
  case 0U: 
#line 1304
  f->update_status = (short)0;
  case 3U: 
#line 1308
  notice_finished_file(f);
#line 1309
  free_child(c);
#line 1310
  break;
  default: 
#line 1313
  if (! ((unsigned int )f->command_state == 3U)) {
#line 1313
    __assert_fail("f->command_state == cs_finished", "job.c", 1313U, "start_waiting_job");
  }
#line 1314
  break;
  }
#line 1317
  return (1);
}
}
#line 1322 "job.c"
void new_job(struct file *file ) 
{ 
  register struct commands *cmds ;
  register struct child *c ;
  char **lines ;
  register unsigned int i ;
  char *tmp ;
  char *in ;
  char *out ;
  char *ref___0 ;
  char openparen ;
  char closeparen ;
  int tmp___0 ;
  int count ;
  char *p ;
  char *tmp___1 ;
  char *tmp___2 ;
  int quoted ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char token ;
  char *tmp___10 ;
  ssize_t tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;

  {
#line 1326
  cmds = file->cmds;
#line 1333
  start_waiting_jobs();
#line 1336
  reap_children(0, 0);
#line 1339
  chop_commands(cmds);
#line 1342
  tmp = xmalloc((unsigned int )((unsigned long )cmds->ncommand_lines * sizeof(char *)));
#line 1342
  lines = (char **)tmp;
#line 1343
  i = 0U;
#line 1343
  while (i < cmds->ncommand_lines) {
#line 1359
    out = *(cmds->command_lines + i);
#line 1359
    in = out;
#line 1360
    while (1) {
#line 1360
      ref___0 = strchr((char const   *)in, '$');
#line 1360
      if (! ((unsigned long )ref___0 != (unsigned long )((char *)0))) {
#line 1360
        break;
      }
#line 1362
      ref___0 ++;
#line 1364
      if ((unsigned long )out != (unsigned long )in) {
#line 1368
        memmove((void *)out, (void const   *)in, (size_t )(ref___0 - in));
      }
#line 1371
      out += ref___0 - in;
#line 1372
      in = ref___0;
#line 1374
      if ((int )*ref___0 == 40) {
#line 1374
        goto _L___1;
      } else
#line 1374
      if ((int )*ref___0 == 123) {
        _L___1: /* CIL Label */ 
#line 1376
        openparen = *ref___0;
#line 1377
        if ((int )openparen == 40) {
#line 1377
          tmp___0 = ')';
        } else {
#line 1377
          tmp___0 = '}';
        }
#line 1377
        closeparen = (char )tmp___0;
#line 1381
        tmp___1 = out;
#line 1381
        out ++;
#line 1381
        tmp___2 = in;
#line 1381
        in ++;
#line 1381
        *tmp___1 = *tmp___2;
#line 1384
        count = 0;
#line 1385
        while ((int )*in != 0) {
#line 1387
          if ((int )*in == (int )closeparen) {
#line 1387
            count --;
#line 1387
            if (count < 0) {
#line 1388
              break;
            } else {
#line 1387
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1389
          if ((int )*in == 92) {
#line 1389
            if ((int )*(in + 1) == 10) {
#line 1395
              quoted = 0;
#line 1396
              p = in - 1;
#line 1396
              while (1) {
#line 1396
                if ((unsigned long )p > (unsigned long )ref___0) {
#line 1396
                  if (! ((int )*p == 92)) {
#line 1396
                    break;
                  }
                } else {
#line 1396
                  break;
                }
#line 1397
                quoted = ! quoted;
#line 1396
                p --;
              }
#line 1399
              if (quoted) {
#line 1405
                tmp___3 = out;
#line 1405
                out ++;
#line 1405
                tmp___4 = in;
#line 1405
                in ++;
#line 1405
                *tmp___3 = *tmp___4;
              } else {
#line 1410
                in = next_token(in + 2);
#line 1414
                while (1) {
#line 1414
                  if ((unsigned long )out > (unsigned long )ref___0) {
#line 1414
                    tmp___5 = __ctype_b_loc();
#line 1414
                    if (! ((int const   )*(*tmp___5 + (int )*(out + -1)) & 1)) {
#line 1414
                      break;
                    }
                  } else {
#line 1414
                    break;
                  }
#line 1415
                  out --;
                }
#line 1418
                tmp___6 = out;
#line 1418
                out ++;
#line 1418
                *tmp___6 = (char )' ';
              }
            } else {
#line 1389
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1423
            if ((int )*in == (int )openparen) {
#line 1424
              count ++;
            }
#line 1426
            tmp___7 = out;
#line 1426
            out ++;
#line 1426
            tmp___8 = in;
#line 1426
            in ++;
#line 1426
            *tmp___7 = *tmp___8;
          }
        }
      }
    }
#line 1434
    if ((unsigned long )out != (unsigned long )in) {
#line 1435
      strcpy((char * __restrict  )out, (char const   * __restrict  )in);
    }
#line 1438
    *(lines + i) = allocated_variable_expand_for_file(*(cmds->command_lines + i),
                                                      file);
#line 1343
    i ++;
  }
#line 1445
  tmp___9 = xmalloc((unsigned int )sizeof(struct child ));
#line 1445
  c = (struct child *)tmp___9;
#line 1446
  memset((void *)((char *)c), 0, sizeof(struct child ));
#line 1447
  c->file = file;
#line 1448
  c->command_lines = lines;
#line 1449
  c->sh_batch_file = (char *)((void *)0);
#line 1452
  job_next_command(c);
#line 1457
  if (job_slots != 0U) {
#line 1458
    while (job_slots_used == job_slots) {
#line 1459
      reap_children(1, 0);
    }
  } else
#line 1474
  if (job_fds[0] >= 0) {
#line 1475
    while (! (! children)) {
#line 1488
      tmp___11 = read(job_rfd, (void *)(& token), (size_t )1);
#line 1488
      if (tmp___11 == 1L) {
#line 1490
        while (1) {
#line 1490
          if (4 & db_level) {
#line 1490
            tmp___10 = dcgettext((char const   *)((void *)0), "Obtained token for child 0x%08lx (%s).\n",
                                 5);
#line 1490
            printf((char const   * __restrict  )tmp___10, (unsigned long )c, (c->file)->name);
#line 1490
            fflush(stdout);
          }
#line 1490
          break;
        }
#line 1492
        break;
      }
#line 1495
      tmp___13 = __errno_location();
#line 1495
      if (*tmp___13 != 4) {
#line 1495
        tmp___14 = __errno_location();
#line 1495
        if (*tmp___14 != 9) {
#line 1496
          tmp___12 = dcgettext((char const   *)((void *)0), "read jobs pipe", 5);
#line 1496
          pfatal_with_name(tmp___12);
        }
      }
#line 1500
      if (job_rfd < 0) {
#line 1501
        job_rfd = dup(job_fds[0]);
      }
#line 1505
      reap_children(0, 0);
    }
  }
#line 1511
  start_waiting_job(c);
#line 1513
  if (job_slots == 1U) {
#line 1513
    goto _L___2;
  } else
#line 1513
  if (not_parallel) {
    _L___2: /* CIL Label */ 
#line 1516
    while ((unsigned int )file->command_state == 2U) {
#line 1517
      reap_children(1, 0);
    }
  }
#line 1519
  return;
}
}
#line 1525 "job.c"
static int job_next_command(struct child *child ) 
{ 
  unsigned int tmp ;

  {
#line 1529
  while (1) {
#line 1529
    if (! ((unsigned long )child->command_ptr == (unsigned long )((char *)0))) {
#line 1529
      if (! ((int )*(child->command_ptr) == 0)) {
#line 1529
        break;
      }
    }
#line 1532
    if (child->command_line == ((child->file)->cmds)->ncommand_lines) {
#line 1535
      child->command_ptr = (char *)0;
#line 1536
      return (0);
    } else {
#line 1540
      tmp = child->command_line;
#line 1540
      (child->command_line) ++;
#line 1540
      child->command_ptr = *(child->command_lines + tmp);
    }
  }
#line 1542
  return (1);
}
}
#line 1559 "job.c"
static int lossage  =    -1;
#line 1545 "job.c"
static int load_too_high(void) 
{ 
  double load ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 1553
  if (max_load_average < (double )0) {
#line 1554
    return (0);
  }
#line 1556
  make_access();
#line 1557
  tmp___4 = getloadavg(& load, 1);
#line 1557
  if (tmp___4 != 1) {
#line 1561
    if (lossage == -1) {
#line 1561
      goto _L;
    } else {
#line 1561
      tmp___2 = __errno_location();
#line 1561
      if (*tmp___2 != lossage) {
        _L: /* CIL Label */ 
#line 1563
        tmp___1 = __errno_location();
#line 1563
        if (*tmp___1 == 0) {
#line 1565
          tmp = dcgettext((char const   *)((void *)0), "cannot enforce load limits on this operating system",
                          5);
#line 1565
          error((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
        } else {
#line 1568
          tmp___0 = dcgettext((char const   *)((void *)0), "cannot enforce load limit: ",
                              5);
#line 1568
          perror_with_name(tmp___0, (char *)"getloadavg");
        }
      }
    }
#line 1570
    tmp___3 = __errno_location();
#line 1570
    lossage = *tmp___3;
#line 1571
    load = (double )0;
  }
#line 1573
  user_access();
#line 1575
  return (load >= max_load_average);
}
}
#line 1581 "job.c"
void start_waiting_jobs(void) 
{ 
  struct child *job ;
  int tmp ;

  {
#line 1586
  if ((unsigned long )waiting_jobs == (unsigned long )((struct child *)0)) {
#line 1587
    return;
  }
#line 1589
  while (1) {
#line 1592
    reap_children(0, 0);
#line 1595
    job = waiting_jobs;
#line 1596
    waiting_jobs = job->next;
#line 1589
    tmp = start_waiting_job(job);
#line 1589
    if (tmp) {
#line 1589
      if (! ((unsigned long )waiting_jobs != (unsigned long )((struct child *)0))) {
#line 1589
        break;
      }
    } else {
#line 1589
      break;
    }
  }
#line 1603
  return;
}
}
#line 2162 "job.c"
void child_execute_job(int stdin_fd , int stdout_fd , char **argv , char **envp ) 
{ 


  {
#line 2167
  if (stdin_fd != 0) {
#line 2168
    dup2(stdin_fd, 0);
  }
#line 2169
  if (stdout_fd != 1) {
#line 2170
    dup2(stdout_fd, 1);
  }
#line 2171
  if (stdin_fd != 0) {
#line 2172
    close(stdin_fd);
  }
#line 2173
  if (stdout_fd != 1) {
#line 2174
    close(stdout_fd);
  }
#line 2177
  exec_command(argv, envp);
#line 2178
  return;
}
}
#line 2187 "job.c"
void exec_command(char **argv , char **envp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *shell ;
  char **new_argv ;
  int argc ;
  void *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 2257
  child_access();
#line 2260
  environ = envp;
#line 2261
  execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 2263
  tmp = __errno_location();
#line 2263
  switch (*tmp) {
  case 2: 
#line 2266
  tmp___0 = dcgettext((char const   *)((void *)0), "%s: Command not found", 5);
#line 2266
  error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, *(argv + 0));
#line 2267
  break;
  case 8: 
#line 2276
  shell = getenv("SHELL");
#line 2277
  if ((unsigned long )shell == (unsigned long )((char *)0)) {
#line 2278
    shell = default_shell;
  }
#line 2280
  argc = 1;
#line 2281
  while ((unsigned long )*(argv + argc) != (unsigned long )((char *)0)) {
#line 2282
    argc ++;
  }
#line 2284
  tmp___1 = __builtin_alloca((unsigned long )((1 + argc) + 1) * sizeof(char *));
#line 2284
  new_argv = (char **)tmp___1;
#line 2285
  *(new_argv + 0) = shell;
#line 2286
  *(new_argv + 1) = *(argv + 0);
#line 2287
  while (argc > 0) {
#line 2289
    *(new_argv + (1 + argc)) = *(argv + argc);
#line 2290
    argc --;
  }
#line 2293
  execvp((char const   *)shell, (char * const  *)new_argv);
#line 2294
  tmp___3 = __errno_location();
#line 2294
  if (*tmp___3 == 2) {
#line 2295
    tmp___2 = dcgettext((char const   *)((void *)0), "%s: Shell program not found",
                        5);
#line 2295
    error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, shell);
  } else {
#line 2297
    perror_with_name((char *)"execvp: ", shell);
  }
#line 2298
  break;
  default: 
#line 2302
  perror_with_name((char *)"execvp: ", *(argv + 0));
#line 2303
  break;
  }
#line 2306
  _exit(127);
}
}
#line 2416
static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                              char *ifs , char **batch_filename_ptr ) ;
#line 2416 "job.c"
static char sh_chars[19]  = 
#line 2416
  {      (char )'#',      (char )';',      (char )'\"',      (char )'*', 
        (char )'?',      (char )'[',      (char )']',      (char )'&', 
        (char )'|',      (char )'<',      (char )'>',      (char )'(', 
        (char )')',      (char )'{',      (char )'}',      (char )'$', 
        (char )'`',      (char )'^',      (char )'\000'};
#line 2417 "job.c"
static char *sh_cmds[25]  = 
#line 2417
  {      (char *)"cd",      (char *)"eval",      (char *)"exec",      (char *)"exit", 
        (char *)"login",      (char *)"logout",      (char *)"set",      (char *)"umask", 
        (char *)"wait",      (char *)"while",      (char *)"for",      (char *)"case", 
        (char *)"if",      (char *)":",      (char *)".",      (char *)"break", 
        (char *)"continue",      (char *)"export",      (char *)"read",      (char *)"readonly", 
        (char *)"shift",      (char *)"times",      (char *)"trap",      (char *)"switch", 
        (char *)0};
#line 2786 "job.c"
static char minus_c[5]  = {      (char )' ',      (char )'-',      (char )'c',      (char )' ', 
        (char )'\000'};
#line 2338 "job.c"
static char **construct_command_argv_internal(char *line , char **restp , char *shell ,
                                              char *ifs , char **batch_filename_ptr ) 
{ 
  register int i ;
  register char *p ;
  register char *ap ;
  char *end ;
  int instring ;
  int word_has_equals ;
  int seen_nonequals ;
  int last_argument_was_empty ;
  char **new_argv ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  register int j ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  register int j___0 ;
  int tmp___16 ;
  unsigned int shell_len ;
  size_t tmp___17 ;
  unsigned int line_len ;
  size_t tmp___18 ;
  char *new_line ;
  void *tmp___19 ;
  char *command_ptr ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  unsigned short const   **tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
#line 2430
  new_argv = (char **)0;
#line 2443
  if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 2444
    *restp = (char *)((void *)0);
  }
#line 2447
  while (1) {
#line 2447
    tmp = __ctype_b_loc();
#line 2447
    if (! ((int const   )*(*tmp + (int )*line) & 1)) {
#line 2447
      break;
    }
#line 2448
    line ++;
  }
#line 2449
  if ((int )*line == 0) {
#line 2450
    return ((char **)0);
  }
#line 2453
  if ((unsigned long )shell == (unsigned long )((char *)0)) {
#line 2454
    shell = default_shell;
  } else {
#line 2491
    tmp___0 = strcmp((char const   *)shell, (char const   *)(default_shell));
#line 2491
    if (tmp___0) {
#line 2492
      goto slow;
    }
  }
#line 2496
  if ((unsigned long )ifs != (unsigned long )((char *)0)) {
#line 2497
    ap = ifs;
#line 2497
    while ((int )*ap != 0) {
#line 2498
      if ((int )*ap != 32) {
#line 2498
        if ((int )*ap != 9) {
#line 2498
          if ((int )*ap != 10) {
#line 2499
            goto slow;
          }
        }
      }
#line 2497
      ap ++;
    }
  }
#line 2501
  tmp___1 = strlen((char const   *)line);
#line 2501
  i = (int )(tmp___1 + 1UL);
#line 2504
  tmp___2 = xmalloc((unsigned int )((unsigned long )i * sizeof(char *)));
#line 2504
  new_argv = (char **)tmp___2;
#line 2507
  tmp___4 = xmalloc((unsigned int )i);
#line 2507
  tmp___3 = tmp___4;
#line 2507
  *(new_argv + 0) = tmp___3;
#line 2507
  ap = tmp___3;
#line 2508
  end = ap + i;
#line 2511
  i = 0;
#line 2512
  last_argument_was_empty = 0;
#line 2512
  seen_nonequals = last_argument_was_empty;
#line 2512
  word_has_equals = seen_nonequals;
#line 2512
  instring = word_has_equals;
#line 2513
  p = line;
#line 2513
  while ((int )*p != 0) {
#line 2515
    if ((unsigned long )ap > (unsigned long )end) {
#line 2516
      abort();
    }
#line 2518
    if (instring) {
      string_char: 
#line 2523
      if ((int )*p == instring) {
#line 2525
        instring = 0;
#line 2526
        if ((unsigned long )ap == (unsigned long )*(new_argv + 0)) {
#line 2527
          last_argument_was_empty = 1;
        } else
#line 2526
        if ((int )*(ap - 1) == 0) {
#line 2527
          last_argument_was_empty = 1;
        }
      } else
#line 2529
      if ((int )*p == 92) {
#line 2529
        if ((int )*(p + 1) == 10) {
#line 2530
          goto swallow_escaped_newline;
        } else {
#line 2529
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2531
      if ((int )*p == 10) {
#line 2531
        if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 2534
          *restp = p;
#line 2535
          goto end_of_line;
        } else {
#line 2531
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2541
      if (instring == 34) {
#line 2541
        tmp___6 = strchr("\\$`", (int )*p);
#line 2541
        if ((unsigned long )tmp___6 != (unsigned long )((char *)0)) {
#line 2541
          if (unixy_shell) {
#line 2542
            goto slow;
          } else {
#line 2544
            tmp___5 = ap;
#line 2544
            ap ++;
#line 2544
            *tmp___5 = *p;
          }
        } else {
#line 2544
          tmp___5 = ap;
#line 2544
          ap ++;
#line 2544
          *tmp___5 = *p;
        }
      } else {
#line 2544
        tmp___5 = ap;
#line 2544
        ap ++;
#line 2544
        *tmp___5 = *p;
      }
    } else {
#line 2546
      tmp___15 = strchr((char const   *)(sh_chars), (int )*p);
#line 2546
      if ((unsigned long )tmp___15 != (unsigned long )((char *)0)) {
#line 2548
        goto slow;
      } else {
#line 2556
        switch ((int )*p) {
        case 61: 
#line 2563
        if (! seen_nonequals) {
#line 2563
          if (unixy_shell) {
#line 2564
            goto slow;
          }
        }
#line 2565
        word_has_equals = 1;
#line 2566
        tmp___7 = ap;
#line 2566
        ap ++;
#line 2566
        *tmp___7 = (char )'=';
#line 2567
        break;
        case 92: 
#line 2571
        if ((int )*(p + 1) == 10) {
          swallow_escaped_newline: 
#line 2577
          p += 2;
#line 2583
          if ((int )*p == 9) {
#line 2587
            tmp___8 = strlen((char const   *)p);
#line 2587
            memmove((void *)p, (void const   *)(p + 1), tmp___8);
          }
#line 2589
          if (instring) {
#line 2590
            goto string_char;
          } else
#line 2593
          if ((unsigned long )ap != (unsigned long )*(new_argv + i)) {
#line 2597
            goto end_of_arg;
          } else {
#line 2599
            tmp___9 = next_token(p);
#line 2599
            p = tmp___9 - 1;
          }
        } else
#line 2602
        if ((int )*(p + 1) != 0) {
#line 2631
          tmp___10 = ap;
#line 2631
          ap ++;
#line 2631
          p ++;
#line 2631
          *tmp___10 = *p;
        }
#line 2633
        break;
        case 34: 
        case 39: 
#line 2637
        instring = (int )*p;
#line 2638
        break;
        case 10: 
#line 2641
        if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 2644
          *restp = p;
#line 2645
          goto end_of_line;
        } else {
#line 2649
          tmp___11 = ap;
#line 2649
          ap ++;
#line 2649
          *tmp___11 = (char )'\n';
        }
#line 2650
        break;
        end_of_arg: 
        case 9: 
        case 32: 
#line 2657
        tmp___12 = ap;
#line 2657
        ap ++;
#line 2657
        *tmp___12 = (char )'\000';
#line 2658
        i ++;
#line 2658
        *(new_argv + i) = ap;
#line 2659
        last_argument_was_empty = 0;
#line 2663
        seen_nonequals |= ! word_has_equals;
#line 2664
        if (word_has_equals) {
#line 2664
          if (! seen_nonequals) {
#line 2667
            goto slow;
          }
        }
#line 2668
        word_has_equals = 0;
#line 2673
        if (i == 1) {
#line 2676
          j = 0;
#line 2676
          while ((unsigned long )sh_cmds[j] != (unsigned long )((char *)0)) {
#line 2677
            if ((unsigned long )sh_cmds[j] == (unsigned long )*(new_argv + 0)) {
#line 2678
              goto slow;
            } else
#line 2677
            if ((int )*(sh_cmds[j]) == (int )*(*(new_argv + 0))) {
#line 2677
              if ((int )*(sh_cmds[j]) == 0) {
#line 2678
                goto slow;
              } else {
#line 2677
                tmp___13 = strcmp((char const   *)(sh_cmds[j] + 1), (char const   *)(*(new_argv + 0) + 1));
#line 2677
                if (! tmp___13) {
#line 2678
                  goto slow;
                }
              }
            }
#line 2676
            j ++;
          }
        }
#line 2682
        p = next_token(p);
#line 2684
        p --;
#line 2685
        break;
        default: 
#line 2688
        tmp___14 = ap;
#line 2688
        ap ++;
#line 2688
        *tmp___14 = *p;
#line 2689
        break;
        }
      }
    }
#line 2513
    p ++;
  }
  end_of_line: 
#line 2694
  if (instring) {
#line 2696
    goto slow;
  }
#line 2700
  *ap = (char )'\000';
#line 2701
  if ((int )*(*(new_argv + i) + 0) != 0) {
#line 2702
    i ++;
  } else
#line 2701
  if (last_argument_was_empty) {
#line 2702
    i ++;
  }
#line 2703
  *(new_argv + i) = (char *)0;
#line 2705
  if (i == 1) {
#line 2708
    j___0 = 0;
#line 2708
    while ((unsigned long )sh_cmds[j___0] != (unsigned long )((char *)0)) {
#line 2709
      if ((unsigned long )sh_cmds[j___0] == (unsigned long )*(new_argv + 0)) {
#line 2710
        goto slow;
      } else
#line 2709
      if ((int )*(sh_cmds[j___0]) == (int )*(*(new_argv + 0))) {
#line 2709
        if ((int )*(sh_cmds[j___0]) == 0) {
#line 2710
          goto slow;
        } else {
#line 2709
          tmp___16 = strcmp((char const   *)(sh_cmds[j___0] + 1), (char const   *)(*(new_argv + 0) + 1));
#line 2709
          if (! tmp___16) {
#line 2710
            goto slow;
          }
        }
      }
#line 2708
      j___0 ++;
    }
  }
#line 2713
  if ((unsigned long )*(new_argv + 0) == (unsigned long )((char *)0)) {
#line 2715
    return ((char **)0);
  } else {
#line 2717
    return (new_argv);
  }
  slow: ;
#line 2722
  if ((unsigned long )new_argv != (unsigned long )((char **)0)) {
#line 2725
    free((void *)*(new_argv + 0));
#line 2726
    free((void *)new_argv);
  }
#line 2784
  tmp___17 = strlen((char const   *)shell);
#line 2784
  shell_len = (unsigned int )tmp___17;
#line 2790
  tmp___18 = strlen((char const   *)line);
#line 2790
  line_len = (unsigned int )tmp___18;
#line 2792
  tmp___19 = __builtin_alloca((((unsigned long )shell_len + (sizeof(minus_c) - 1UL)) + (unsigned long )(line_len * 2U)) + 1UL);
#line 2792
  new_line = (char *)tmp___19;
#line 2794
  command_ptr = (char *)((void *)0);
#line 2796
  ap = new_line;
#line 2797
  memmove((void *)ap, (void const   *)shell, (size_t )shell_len);
#line 2798
  ap += shell_len;
#line 2799
  memmove((void *)ap, (void const   *)(minus_c), sizeof(minus_c) - 1UL);
#line 2800
  ap += sizeof(minus_c) - 1UL;
#line 2801
  command_ptr = ap;
#line 2802
  p = line;
#line 2802
  while ((int )*p != 0) {
#line 2804
    if ((unsigned long )restp != (unsigned long )((void *)0)) {
#line 2804
      if ((int )*p == 10) {
#line 2806
        *restp = p;
#line 2807
        break;
      } else {
#line 2804
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2809
    if ((int )*p == 92) {
#line 2809
      if ((int )*(p + 1) == 10) {
#line 2814
        p += 2;
#line 2820
        if ((int )*p == 9) {
#line 2821
          tmp___20 = strlen((char const   *)p);
#line 2821
          memmove((void *)p, (void const   *)(p + 1), tmp___20);
        }
#line 2823
        p = next_token(p);
#line 2824
        p --;
#line 2825
        if (unixy_shell) {
#line 2825
          if (! batch_mode_shell) {
#line 2826
            tmp___21 = ap;
#line 2826
            ap ++;
#line 2826
            *tmp___21 = (char )'\\';
          }
        }
#line 2827
        tmp___22 = ap;
#line 2827
        ap ++;
#line 2827
        *tmp___22 = (char )' ';
#line 2828
        goto __Cont;
      }
    }
#line 2832
    if (unixy_shell) {
#line 2832
      if (! batch_mode_shell) {
#line 2832
        if ((int )*p == 92) {
#line 2836
          tmp___23 = ap;
#line 2836
          ap ++;
#line 2836
          *tmp___23 = (char )'\\';
        } else
#line 2832
        if ((int )*p == 39) {
#line 2836
          tmp___23 = ap;
#line 2836
          ap ++;
#line 2836
          *tmp___23 = (char )'\\';
        } else
#line 2832
        if ((int )*p == 34) {
#line 2836
          tmp___23 = ap;
#line 2836
          ap ++;
#line 2836
          *tmp___23 = (char )'\\';
        } else {
#line 2832
          tmp___24 = __ctype_b_loc();
#line 2832
          if ((int const   )*(*tmp___24 + (int )((unsigned char )*p)) & 8192) {
#line 2836
            tmp___23 = ap;
#line 2836
            ap ++;
#line 2836
            *tmp___23 = (char )'\\';
          } else {
#line 2832
            tmp___25 = strchr((char const   *)(sh_chars), (int )*p);
#line 2832
            if ((unsigned long )tmp___25 != (unsigned long )((char *)0)) {
#line 2836
              tmp___23 = ap;
#line 2836
              ap ++;
#line 2836
              *tmp___23 = (char )'\\';
            }
          }
        }
      }
    }
#line 2846
    tmp___26 = ap;
#line 2846
    ap ++;
#line 2846
    *tmp___26 = *p;
    __Cont: /* CIL Label */ 
#line 2802
    p ++;
  }
#line 2848
  if ((unsigned long )ap == (unsigned long )(((new_line + shell_len) + sizeof(minus_c)) - 1)) {
#line 2850
    return ((char **)0);
  }
#line 2851
  *ap = (char )'\000';
#line 2905
  if (unixy_shell) {
#line 2906
    new_argv = construct_command_argv_internal(new_line, (char **)((void *)0), (char *)0,
                                               (char *)0, (char **)0);
  } else {
#line 2924
    tmp___27 = dcgettext((char const   *)((void *)0), "%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n",
                         5);
#line 2924
    fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27, "job.c",
          2925);
  }
#line 2930
  return (new_argv);
}
}
#line 2947 "job.c"
char **construct_command_argv(char *line , char **restp , struct file *file , char **batch_filename_ptr ) 
{ 
  char *shell ;
  char *ifs ;
  char **argv ;
  int save ;

  {
#line 2999
  save = warn_undefined_variables_flag;
#line 3000
  warn_undefined_variables_flag = 0;
#line 3002
  shell = allocated_variable_expand_for_file((char *)"$(SHELL)", file);
#line 3013
  ifs = allocated_variable_expand_for_file((char *)"$(IFS)", file);
#line 3015
  warn_undefined_variables_flag = save;
#line 3018
  argv = construct_command_argv_internal(line, restp, shell, ifs, batch_filename_ptr);
#line 3020
  free((void *)shell);
#line 3021
  free((void *)ifs);
#line 3023
  return (argv);
}
}
#line 1 "main.o"
#pragma merger("0","/tmp/cil-Cly36iXy.i","-g,-O0")
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 109 "gettext.h"
char *textdomain(char const   *domainname ) ;
#line 114
char *bindtextdomain(char const   *domainname , char const   *dirname ) ;
#line 202 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 240
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 304
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 142 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 514
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 101 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 685
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 390 "make.h"
void log_working_directory(int entering ) ;
#line 410
FILE *open_tmpfile(char **name , char const   *template ) ;
#line 425
void define_default_variables(void) ;
#line 426
void set_default_suffixes(void) ;
#line 427
void install_default_suffix_rules(void) ;
#line 428
void install_default_implicit_rules(void) ;
#line 430
void build_vpath_lists(void) ;
#line 435
void construct_include_path(char **arg_dirs ) ;
#line 470 "make.h"
int just_print_flag  ;
#line 470 "make.h"
int silent_flag  ;
#line 470 "make.h"
int keep_going_flag  ;
#line 471
int print_data_base_flag ;
#line 471 "make.h"
int touch_flag  ;
#line 472
int env_overrides ;
#line 472
int no_builtin_rules_flag ;
#line 472
int no_builtin_variables_flag ;
#line 473
int print_version_flag ;
#line 473
int print_directory_flag ;
#line 474 "make.h"
int warn_undefined_variables_flag  ;
#line 474 "make.h"
int posix_pedantic  ;
#line 474 "make.h"
int not_parallel  ;
#line 475 "make.h"
int clock_skew_detected  ;
#line 489 "make.h"
char *program  ;
#line 490 "make.h"
char *starting_directory  ;
#line 491 "make.h"
unsigned int makelevel  ;
#line 492
char *version_string ;
#line 492
char *remote_description ;
#line 60 "dep.h"
char *tilde_expand(char *name ) ;
#line 74
struct dep *read_all_makefiles(char **makefiles___0 ) ;
#line 75
int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) ;
#line 105 "filedef.h"
struct file *default_goal_file  ;
#line 105 "filedef.h"
struct file *default_file  ;
#line 104 "variable.h"
void define_automatic_variables(void) ;
#line 109
struct variable *try_variable_definition(struct floc  const  *flocp , char *line ,
                                         enum variable_origin origin , int target_var ) ;
#line 66 "rule.h"
void count_implicit_rule_limits(void) ;
#line 67
void convert_to_pattern(void) ;
#line 110 "getopt.h"
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 48 "main.c"
void remote_setup(void) ;
#line 49
void remote_cleanup(void) ;
#line 52
void print_variable_data_base(void) ;
#line 54
void print_rule_data_base(void) ;
#line 56
void print_vpath_data_base(void) ;
#line 72
static void print_data_base(void) ;
#line 73
static void print_version(void) ;
#line 74
static void decode_switches(int argc , char **argv , int env ) ;
#line 75
static void decode_env_switches(char *envar , unsigned int len ) ;
#line 76
static void define_makeflags(int all , int makefile ) ;
#line 77
static char *quote_for_env(char *out , char *in ) ;
#line 143 "main.c"
static struct stringlist *db_flags  ;
#line 144 "main.c"
static int debug_flag  =    0;
#line 146 "main.c"
int db_level  =    0;
#line 156 "main.c"
int env_overrides  =    0;
#line 161 "main.c"
int ignore_errors_flag  =    0;
#line 166 "main.c"
int print_data_base_flag  =    0;
#line 171 "main.c"
int question_flag  =    0;
#line 175 "main.c"
int no_builtin_rules_flag  =    0;
#line 176 "main.c"
int no_builtin_variables_flag  =    0;
#line 181 "main.c"
int default_keep_going_flag  =    0;
#line 185 "main.c"
int print_directory_flag  =    0;
#line 190 "main.c"
int inhibit_print_directory_flag  =    0;
#line 194 "main.c"
int print_version_flag  =    0;
#line 198 "main.c"
static struct stringlist *makefiles  =    (struct stringlist *)0;
#line 202 "main.c"
unsigned int job_slots  =    1U;
#line 203 "main.c"
unsigned int default_job_slots  =    1U;
#line 207 "main.c"
static unsigned int inf_jobs  =    0U;
#line 211 "main.c"
static struct stringlist *jobserver_fds  =    (struct stringlist *)0;
#line 213 "main.c"
int job_fds[2]  = {      -1,      -1};
#line 214 "main.c"
int job_rfd  =    -1;
#line 221 "main.c"
double max_load_average  =    - 1.0;
#line 222 "main.c"
double default_load_average  =    - 1.0;
#line 230 "main.c"
static struct stringlist *directories___0  =    (struct stringlist *)0;
#line 234 "main.c"
static struct stringlist *include_directories  =    (struct stringlist *)0;
#line 238 "main.c"
static struct stringlist *old_files  =    (struct stringlist *)0;
#line 242 "main.c"
static struct stringlist *new_files  =    (struct stringlist *)0;
#line 246 "main.c"
static int print_usage_flag  =    0;
#line 255 "main.c"
static struct command_switch  const  switches[29]  = 
#line 255
  {      {'b', (enum __anonenum_type_56 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)0, (char *)0, (char *)"Ignored for compatibility"}, 
        {'C', (enum __anonenum_type_56 )2, (char *)(& directories___0), 0U, 0U, 0U, (char *)0,
      (char *)0, (char *)"directory", (char *)"DIRECTORY", (char *)"Change to DIRECTORY before doing anything"}, 
        {'d',
      (enum __anonenum_type_56 )0, (char *)(& debug_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)0, (char *)0, (char *)"Print lots of debugging information"}, 
        {128,
      (enum __anonenum_type_56 )2, (char *)(& db_flags), 1U, 1U, 0U, (char *)"basic",
      (char *)0, (char *)"debug", (char *)"FLAGS", (char *)"Print various types of debugging information"}, 
        {'e',
      (enum __anonenum_type_56 )0, (char *)(& env_overrides), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"environment-overrides", (char *)0, (char *)"Environment variables override makefiles"}, 
        {'f',
      (enum __anonenum_type_56 )2, (char *)(& makefiles), 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)"file", (char *)"FILE", (char *)"Read FILE as a makefile"}, 
        {'h', (enum __anonenum_type_56 )0, (char *)(& print_usage_flag), 0U, 0U, 0U,
      (char *)0, (char *)0, (char *)"help", (char *)0, (char *)"Print this message and exit"}, 
        {'i',
      (enum __anonenum_type_56 )0, (char *)(& ignore_errors_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"ignore-errors", (char *)0, (char *)"Ignore errors from commands"}, 
        {'I',
      (enum __anonenum_type_56 )2, (char *)(& include_directories), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"include-dir", (char *)"DIRECTORY", (char *)"Search DIRECTORY for included makefiles"}, 
        {'j',
      (enum __anonenum_type_56 )3, (char *)(& job_slots), 1U, 1U, 0U, (char *)(& inf_jobs),
      (char *)(& default_job_slots), (char *)"jobs", (char *)"N", (char *)"Allow N jobs at once; infinite jobs with no arg"}, 
        {129,
      (enum __anonenum_type_56 )2, (char *)(& jobserver_fds), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"jobserver-fds", (char *)0, (char *)0}, 
        {'k', (enum __anonenum_type_56 )0, (char *)(& keep_going_flag), 1U, 1U, 0U, (char *)0,
      (char *)(& default_keep_going_flag), (char *)"keep-going", (char *)0, (char *)"Keep going when some targets can\'t be made"}, 
        {'l',
      (enum __anonenum_type_56 )4, (char *)(& max_load_average), 1U, 1U, 0U, (char *)(& default_load_average),
      (char *)(& default_load_average), (char *)"load-average", (char *)"N", (char *)"Don\'t start multiple jobs unless load is below N"}, 
        {'m',
      (enum __anonenum_type_56 )5, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0,
      (char *)0, (char *)"-b"}, 
        {'n', (enum __anonenum_type_56 )0, (char *)(& just_print_flag), 1U, 1U, 1U, (char *)0,
      (char *)0, (char *)"just-print", (char *)0, (char *)"Don\'t actually run any commands; just print them"}, 
        {'o',
      (enum __anonenum_type_56 )2, (char *)(& old_files), 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)"old-file", (char *)"FILE", (char *)"Consider FILE to be very old and don\'t remake it"}, 
        {'p',
      (enum __anonenum_type_56 )0, (char *)(& print_data_base_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"print-data-base", (char *)0, (char *)"Print make\'s internal database"}, 
        {'q',
      (enum __anonenum_type_56 )0, (char *)(& question_flag), 1U, 1U, 1U, (char *)0,
      (char *)0, (char *)"question", (char *)0, (char *)"Run no commands; exit status says if up to date"}, 
        {'r',
      (enum __anonenum_type_56 )0, (char *)(& no_builtin_rules_flag), 1U, 1U, 0U,
      (char *)0, (char *)0, (char *)"no-builtin-rules", (char *)0, (char *)"Disable the built-in implicit rules"}, 
        {'R',
      (enum __anonenum_type_56 )0, (char *)(& no_builtin_variables_flag), 1U, 1U,
      0U, (char *)0, (char *)0, (char *)"no-builtin-variables", (char *)0, (char *)"Disable the built-in variable settings"}, 
        {'s',
      (enum __anonenum_type_56 )0, (char *)(& silent_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"silent", (char *)0, (char *)"Don\'t echo commands"}, 
        {'S', (enum __anonenum_type_56 )1, (char *)(& keep_going_flag), 1U, 1U, 0U, (char *)0,
      (char *)(& default_keep_going_flag), (char *)"no-keep-going", (char *)0, (char *)"Turns off -k"}, 
        {'t',
      (enum __anonenum_type_56 )0, (char *)(& touch_flag), 1U, 1U, 1U, (char *)0,
      (char *)0, (char *)"touch", (char *)0, (char *)"Touch targets instead of remaking them"}, 
        {'v',
      (enum __anonenum_type_56 )0, (char *)(& print_version_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"version", (char *)0, (char *)"Print the version number of make and exit"}, 
        {'w',
      (enum __anonenum_type_56 )0, (char *)(& print_directory_flag), 1U, 1U, 0U, (char *)0,
      (char *)0, (char *)"print-directory", (char *)0, (char *)"Print the current directory"}, 
        {130,
      (enum __anonenum_type_56 )0, (char *)(& inhibit_print_directory_flag), 1U, 1U,
      0U, (char *)0, (char *)0, (char *)"no-print-directory", (char *)0, (char *)"Turn off -w, even if it was turned on implicitly"}, 
        {'W',
      (enum __anonenum_type_56 )2, (char *)(& new_files), 0U, 0U, 0U, (char *)0, (char *)0,
      (char *)"what-if", (char *)"FILE", (char *)"Consider FILE to be infinitely new"}, 
        {131,
      (enum __anonenum_type_56 )0, (char *)(& warn_undefined_variables_flag), 1U,
      1U, 0U, (char *)0, (char *)0, (char *)"warn-undefined-variables", (char *)0,
      (char *)"Warn when an undefined variable is referenced"}, 
        {'\000', 0U, (char *)0, 0U, 0U, 0U, (char *)0, (char *)0, (char *)0, (char *)0,
      (char *)0}};
#line 364 "main.c"
static struct option long_option_aliases[9]  = 
#line 364
  {      {"quiet", 0, (int *)0, 's'}, 
        {"stop", 0, (int *)0, 'S'}, 
        {"new-file", 1, (int *)0, 'W'}, 
        {"assume-new", 1, (int *)0, 'W'}, 
        {"assume-old", 1, (int *)0, 'o'}, 
        {"max-load", 2, (int *)0, 'l'}, 
        {"dry-run", 0, (int *)0, 'n'}, 
        {"recon", 0, (int *)0, 'n'}, 
        {"makefile", 1, (int *)0, 'f'}};
#line 385 "main.c"
static struct dep *goals  ;
#line 385 "main.c"
static struct dep *lastgoal  ;
#line 395 "main.c"
static struct command_variable *command_variables  ;
#line 403 "main.c"
char *directory_before_chdir  ;
#line 444 "main.c"
sigset_t fatal_signal_set  ;
#line 451 "main.c"
static struct file *enter_command_line_file(char *name ) 
{ 
  char *tmp ;
  char *expanded ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct file *tmp___2 ;

  {
#line 455
  if ((int )*(name + 0) == 0) {
#line 456
    tmp = dcgettext((char const   *)((void *)0), "empty string invalid as file name",
                    5);
#line 456
    fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
  }
#line 458
  if ((int )*(name + 0) == 126) {
#line 460
    tmp___0 = tilde_expand(name);
#line 460
    expanded = tmp___0;
#line 461
    if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 462
      name = expanded;
    }
  }
#line 468
  while (1) {
#line 468
    if ((int )*(name + 0) == 46) {
#line 468
      if ((int )*(name + 1) == 47) {
#line 468
        if (! ((int )*(name + 2) != 0)) {
#line 468
          break;
        }
      } else {
#line 468
        break;
      }
    } else {
#line 468
      break;
    }
#line 470
    name += 2;
#line 471
    while ((int )*name == 47) {
#line 473
      name ++;
    }
  }
#line 476
  if ((int )*name == 0) {
#line 480
    while (1) {
#line 481
      name --;
#line 480
      if (! ((int )*(name + 0) != 46)) {
#line 480
        break;
      }
    }
#line 483
    *(name + 2) = (char )'\000';
  }
#line 486
  tmp___1 = xstrdup((char const   *)name);
#line 486
  tmp___2 = enter_file(tmp___1);
#line 486
  return (tmp___2);
}
}
#line 491 "main.c"
static void debug_signal_handler(int sig ) 
{ 


  {
#line 495
  if (db_level) {
#line 495
    db_level = 0;
  } else {
#line 495
    db_level = 1;
  }
#line 496
  return;
}
}
#line 498 "main.c"
static void decode_debug_flags(void) 
{ 
  char **pp ;
  char const   *p ;
  int tmp ;
  char *tmp___0 ;

  {
#line 503
  if (debug_flag) {
#line 504
    db_level = 4095;
  }
#line 506
  if (! db_flags) {
#line 507
    return;
  }
#line 509
  pp = db_flags->list;
#line 509
  while (*pp) {
#line 511
    p = (char const   *)*pp;
#line 513
    while (1) {
#line 515
      tmp = tolower((int )*(p + 0));
#line 515
      switch (tmp) {
      case 97: 
#line 518
      db_level |= 4095;
#line 519
      break;
      case 98: 
#line 521
      db_level |= 1;
#line 522
      break;
      case 105: 
#line 524
      db_level |= 9;
#line 525
      break;
      case 106: 
#line 527
      db_level |= 4;
#line 528
      break;
      case 109: 
#line 530
      db_level |= 257;
#line 531
      break;
      case 118: 
#line 533
      db_level |= 3;
#line 534
      break;
      default: 
#line 536
      tmp___0 = dcgettext((char const   *)((void *)0), "unknown debug level specification `%s\'",
                          5);
#line 536
      fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0, p);
      }
#line 539
      while (1) {
#line 539
        p ++;
#line 539
        if (! ((int const   )*p != 0)) {
#line 539
          break;
        }
#line 540
        if ((int const   )*p == 44) {
#line 541
          break;
        } else
#line 540
        if ((int const   )*p == 32) {
#line 541
          break;
        }
      }
#line 543
      if ((int const   )*p == 0) {
#line 544
        break;
      }
#line 546
      p ++;
    }
#line 509
    pp ++;
  }
#line 549
  return;
}
}
#line 733 "main.c"
FILE *open_tmpfile(char **name , char const   *template ) 
{ 
  int fd ;
  size_t tmp ;
  FILE *tmp___0 ;

  {
#line 745
  tmp = strlen(template);
#line 745
  *name = xmalloc((unsigned int )(tmp + 1UL));
#line 746
  strcpy((char * __restrict  )*name, (char const   * __restrict  )template);
#line 750
  fd = mkstemp(*name);
#line 751
  if (fd == -1) {
#line 752
    return ((FILE *)0);
  }
#line 753
  tmp___0 = fdopen(fd, "w");
#line 753
  return (tmp___0);
}
}
#line 785
int main(int argc , char **argv , char **envp ) ;
#line 785 "main.c"
static char *stdin_nm  =    (char *)0;
#line 776 "main.c"
int main(int argc , char **argv , char **envp ) 
{ 
  register struct file *f ;
  register unsigned int i ;
  char **p ;
  struct dep *read_makefiles___0 ;
  char current_directory[4096] ;
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  __sighandler_t tmp___3 ;
  __sighandler_t tmp___4 ;
  char *tmp___5 ;
  int do_not_define ;
  register char *ep ;
  struct variable *tmp___6 ;
  char *tmp___7 ;
  struct command_variable *cv ;
  struct variable *v ;
  unsigned int len ;
  char *value ;
  char *p___0 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *dir ;
  char *expanded ;
  char *tmp___14 ;
  int tmp___15 ;
  struct variable *v___0 ;
  struct variable *tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char *tmp___19 ;
  register unsigned int i___0 ;
  FILE *outfile ;
  char *tmp___20 ;
  char *tmp___21 ;
  char buf___1[2048] ;
  unsigned int n ;
  size_t tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  struct sigaction sa ;
  char **tmp___26 ;
  char *cp ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  char c ;
  char *tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  ssize_t tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  uintmax_t tmp___42 ;
  uintmax_t tmp___43 ;
  uintmax_t *makefile_mtimes ;
  unsigned int mm_idx ;
  char **nargv ;
  int nargc ;
  int orig_db_level ;
  char *tmp___44 ;
  register struct dep *d ;
  register struct dep *last ;
  register struct file *f___0 ;
  char *tmp___45 ;
  char *tmp___46 ;
  unsigned int tmp___47 ;
  uintmax_t tmp___48 ;
  int tmp___49 ;
  int any_remade ;
  int any_failed ;
  register unsigned int i___1 ;
  struct dep *d___0 ;
  uintmax_t tmp___50 ;
  uintmax_t tmp___51 ;
  uintmax_t mtime ;
  char *tmp___52 ;
  uintmax_t tmp___53 ;
  int tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  register unsigned int i___2 ;
  register unsigned int j ;
  char *p___1 ;
  int tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  char bad ;
  int tmp___62 ;
  char *tmp___63 ;
  char *sgi_loses ;
  void *tmp___64 ;
  int tmp___65 ;
  char **p___2 ;
  char *tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  int *tmp___69 ;
  int status ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  char *tmp___75 ;

  {
#line 802
  default_goal_file = (struct file *)0;
#line 803
  reading_file = (struct floc  const  *)0;
#line 818
  setlocale(6, "");
#line 819
  bindtextdomain("make", "/usr/local/share/locale");
#line 820
  textdomain("make");
#line 830
  sigemptyset(& fatal_signal_set);
#line 848
  tmp = signal(1, & fatal_error_signal);
#line 848
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))1)) {
#line 848
    signal(1, (void (*)(int  ))1);
  } else {
#line 848
    sigaddset(& fatal_signal_set, 1);
  }
#line 851
  tmp___0 = signal(3, & fatal_error_signal);
#line 851
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
#line 851
    signal(3, (void (*)(int  ))1);
  } else {
#line 851
    sigaddset(& fatal_signal_set, 3);
  }
#line 853
  tmp___1 = signal(2, & fatal_error_signal);
#line 853
  if ((unsigned long )tmp___1 == (unsigned long )((void (*)(int  ))1)) {
#line 853
    signal(2, (void (*)(int  ))1);
  } else {
#line 853
    sigaddset(& fatal_signal_set, 2);
  }
#line 854
  tmp___2 = signal(15, & fatal_error_signal);
#line 854
  if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))1)) {
#line 854
    signal(15, (void (*)(int  ))1);
  } else {
#line 854
    sigaddset(& fatal_signal_set, 15);
  }
#line 860
  tmp___3 = signal(24, & fatal_error_signal);
#line 860
  if ((unsigned long )tmp___3 == (unsigned long )((void (*)(int  ))1)) {
#line 860
    signal(24, (void (*)(int  ))1);
  } else {
#line 860
    sigaddset(& fatal_signal_set, 24);
  }
#line 863
  tmp___4 = signal(25, & fatal_error_signal);
#line 863
  if ((unsigned long )tmp___4 == (unsigned long )((void (*)(int  ))1)) {
#line 863
    signal(25, (void (*)(int  ))1);
  } else {
#line 863
    sigaddset(& fatal_signal_set, 25);
  }
#line 875
  signal(17, (void (*)(int  ))0);
#line 885
  setlinebuf(stdout);
#line 897
  if ((unsigned long )*(argv + 0) == (unsigned long )((char *)0)) {
#line 898
    *(argv + 0) = (char *)"";
  }
#line 899
  if ((int )*(*(argv + 0) + 0) == 0) {
#line 900
    program = (char *)"make";
  } else {
#line 906
    program = strrchr((char const   *)*(argv + 0), '/');
#line 922
    if ((unsigned long )program == (unsigned long )((char *)0)) {
#line 923
      program = *(argv + 0);
    } else {
#line 925
      program ++;
    }
  }
#line 929
  user_access();
#line 936
  tmp___5 = getcwd(current_directory, (size_t )4096);
#line 936
  if ((unsigned long )tmp___5 == (unsigned long )((char *)0)) {
#line 940
    perror_with_name((char *)"getcwd: ", (char *)"");
#line 944
    current_directory[0] = (char )'\000';
#line 945
    directory_before_chdir = (char *)0;
  } else {
#line 948
    directory_before_chdir = xstrdup((char const   *)(current_directory));
  }
#line 959
  i = 0U;
#line 959
  while ((unsigned long )*(envp + i) != (unsigned long )((char *)0)) {
#line 962
    ep = *(envp + i);
#line 965
    do_not_define = 0;
#line 967
    while ((int )*ep != 61) {
#line 968
      ep ++;
    }
#line 980
    if (! do_not_define) {
#line 981
      tmp___6 = define_variable_in_set(*(envp + i), (unsigned int )(ep - *(envp + i)),
                                       ep + 1, (enum variable_origin )1, 1, current_variable_set_list->set,
                                       (struct floc  const  *)((struct floc *)0));
#line 981
      tmp___6->export = (enum variable_export )0;
    }
#line 959
    i ++;
  }
#line 1040
  decode_env_switches((char *)"MAKEFLAGS", 9U);
#line 1047
  decode_switches(argc, argv, 0);
#line 1057
  decode_debug_flags();
#line 1061
  if (print_version_flag) {
#line 1062
    print_version();
  } else
#line 1061
  if (print_data_base_flag) {
#line 1062
    print_version();
  } else
#line 1061
  if (db_level) {
#line 1062
    print_version();
  }
#line 1065
  if (print_version_flag) {
#line 1066
    die(0);
  }
#line 1104
  if ((int )current_directory[0] != 0) {
#line 1104
    if ((unsigned long )*(argv + 0) != (unsigned long )((char *)0)) {
#line 1104
      if ((int )*(*(argv + 0) + 0) != 47) {
#line 1104
        tmp___7 = strchr((char const   *)*(argv + 0), '/');
#line 1104
        if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
#line 1106
          *(argv + 0) = concat(current_directory, (char *)"/", *(argv + 0));
        }
      }
    }
  }
#line 1113
  define_variable_in_set((char *)"MAKE_COMMAND", 12U, *(argv + 0), (enum variable_origin )0,
                         0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 1114
  define_variable_in_set((char *)"MAKE", 4U, (char *)"$(MAKE_COMMAND)", (enum variable_origin )0,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 1116
  if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
#line 1120
    len = 0U;
#line 1125
    cv = command_variables;
#line 1125
    while ((unsigned long )cv != (unsigned long )((struct command_variable *)0)) {
#line 1127
      v = cv->variable;
#line 1128
      tmp___8 = strlen((char const   *)v->name);
#line 1128
      len = (unsigned int )((size_t )len + 2UL * tmp___8);
#line 1129
      if (! v->recursive) {
#line 1130
        len ++;
      }
#line 1131
      len ++;
#line 1132
      tmp___9 = strlen((char const   *)v->value);
#line 1132
      len = (unsigned int )((size_t )len + 2UL * tmp___9);
#line 1133
      len ++;
#line 1125
      cv = cv->next;
    }
#line 1137
    tmp___10 = __builtin_alloca((unsigned long )len);
#line 1137
    value = (char *)tmp___10;
#line 1137
    p___0 = value;
#line 1138
    cv = command_variables;
#line 1138
    while ((unsigned long )cv != (unsigned long )((struct command_variable *)0)) {
#line 1140
      v = cv->variable;
#line 1141
      p___0 = quote_for_env(p___0, v->name);
#line 1142
      if (! v->recursive) {
#line 1143
        tmp___11 = p___0;
#line 1143
        p___0 ++;
#line 1143
        *tmp___11 = (char )':';
      }
#line 1144
      tmp___12 = p___0;
#line 1144
      p___0 ++;
#line 1144
      *tmp___12 = (char )'=';
#line 1145
      p___0 = quote_for_env(p___0, v->value);
#line 1146
      tmp___13 = p___0;
#line 1146
      p___0 ++;
#line 1146
      *tmp___13 = (char )' ';
#line 1138
      cv = cv->next;
    }
#line 1148
    *(p___0 + -1) = (char )'\000';
#line 1152
    define_variable_in_set((char *)"-*-command-variables-*-", 23U, value, (enum variable_origin )6,
                           0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 1161
    define_variable_in_set((char *)"MAKEOVERRIDES", 13U, (char *)"${-*-command-variables-*-}",
                           (enum variable_origin )1, 1, current_variable_set_list->set,
                           (struct floc  const  *)((struct floc *)0));
  }
#line 1166
  if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
#line 1167
    i = 0U;
#line 1167
    while ((unsigned long )*(directories___0->list + i) != (unsigned long )((char *)0)) {
#line 1169
      dir = *(directories___0->list + i);
#line 1170
      if ((int )*(dir + 0) == 126) {
#line 1172
        tmp___14 = tilde_expand(dir);
#line 1172
        expanded = tmp___14;
#line 1173
        if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 1174
          dir = expanded;
        }
      }
#line 1176
      tmp___15 = chdir((char const   *)dir);
#line 1176
      if (tmp___15 < 0) {
#line 1177
        pfatal_with_name(dir);
      }
#line 1178
      if ((unsigned long )dir != (unsigned long )*(directories___0->list + i)) {
#line 1179
        free((void *)dir);
      }
#line 1167
      i ++;
    }
  }
#line 1197
  tmp___16 = lookup_variable((char *)"MAKELEVEL", 9U);
#line 1197
  v___0 = tmp___16;
#line 1198
  if ((unsigned long )v___0 != (unsigned long )((struct variable *)0)) {
#line 1198
    if ((int )*(v___0->value) != 0) {
#line 1198
      if ((int )*(v___0->value) != 45) {
#line 1199
        tmp___17 = atoi((char const   *)v___0->value);
#line 1199
        makelevel = (unsigned int )tmp___17;
      } else {
#line 1201
        makelevel = 0U;
      }
    } else {
#line 1201
      makelevel = 0U;
    }
  } else {
#line 1201
    makelevel = 0U;
  }
#line 1205
  if (! silent_flag) {
#line 1205
    if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
#line 1206
      print_directory_flag = 1;
    } else
#line 1205
    if (makelevel > 0U) {
#line 1206
      print_directory_flag = 1;
    }
  }
#line 1209
  if (inhibit_print_directory_flag) {
#line 1210
    print_directory_flag = 0;
  }
#line 1213
  if (no_builtin_variables_flag) {
#line 1214
    no_builtin_rules_flag = 1;
  }
#line 1218
  if ((unsigned long )include_directories == (unsigned long )((struct stringlist *)0)) {
#line 1218
    tmp___18 = (char **)0;
  } else {
#line 1218
    tmp___18 = include_directories->list;
  }
#line 1218
  construct_include_path(tmp___18);
#line 1222
  if ((unsigned long )directories___0 == (unsigned long )((struct stringlist *)0)) {
#line 1224
    starting_directory = current_directory;
  } else {
#line 1230
    tmp___19 = getcwd(current_directory, (size_t )4096);
#line 1230
    if ((unsigned long )tmp___19 == (unsigned long )((char *)0)) {
#line 1234
      perror_with_name((char *)"getcwd: ", (char *)"");
#line 1238
      starting_directory = (char *)0;
    } else {
#line 1241
      starting_directory = current_directory;
    }
  }
#line 1244
  define_variable_in_set((char *)"CURDIR", 6U, current_directory, (enum variable_origin )0,
                         0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 1248
  if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
#line 1251
    i___0 = 0U;
#line 1251
    while (i___0 < makefiles->idx) {
#line 1252
      if ((int )*(*(makefiles->list + i___0) + 0) == 45) {
#line 1252
        if ((int )*(*(makefiles->list + i___0) + 1) == 0) {
#line 1259
          if (stdin_nm) {
#line 1260
            tmp___20 = dcgettext((char const   *)((void *)0), "Makefile from standard input specified twice.",
                                 5);
#line 1260
            fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___20);
          }
#line 1268
          outfile = open_tmpfile(& stdin_nm, "/tmp/GmXXXXXX");
#line 1269
          if ((unsigned long )outfile == (unsigned long )((FILE *)0)) {
#line 1270
            tmp___21 = dcgettext((char const   *)((void *)0), "fopen (temporary file)",
                                 5);
#line 1270
            pfatal_with_name(tmp___21);
          }
#line 1271
          while (1) {
#line 1271
            tmp___25 = feof(stdin);
#line 1271
            if (tmp___25) {
#line 1271
              break;
            }
#line 1274
            tmp___22 = fread((void * __restrict  )(buf___1), (size_t )1, sizeof(buf___1),
                             (FILE * __restrict  )stdin);
#line 1274
            n = (unsigned int )tmp___22;
#line 1275
            if (n > 0U) {
#line 1275
              tmp___24 = fwrite((void const   * __restrict  )(buf___1), (size_t )1,
                                (size_t )n, (FILE * __restrict  )outfile);
#line 1275
              if (tmp___24 != (size_t )n) {
#line 1276
                tmp___23 = dcgettext((char const   *)((void *)0), "fwrite (temporary file)",
                                     5);
#line 1276
                pfatal_with_name(tmp___23);
              }
            }
          }
#line 1278
          fclose(outfile);
#line 1282
          *(makefiles->list + i___0) = xstrdup((char const   *)stdin_nm);
#line 1285
          f = enter_file(stdin_nm);
#line 1286
          f->updated = 1U;
#line 1287
          f->update_status = (short)0;
#line 1288
          f->command_state = (enum __anonenum_command_state_55 )3;
#line 1291
          f->intermediate = 0U;
#line 1292
          f->dontcare = 0U;
        }
      }
#line 1251
      i___0 ++;
    }
  }
#line 1315
  memset((void *)((char *)(& sa)), 0, sizeof(struct sigaction ));
#line 1316
  sa.__sigaction_handler.sa_handler = & child_handler;
#line 1319
  sa.sa_flags = 536870912;
#line 1328
  sigaction(17, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 1338
  signal(10, & debug_signal_handler);
#line 1343
  set_default_suffixes();
#line 1351
  install_default_suffix_rules();
#line 1355
  define_automatic_variables();
#line 1360
  define_makeflags(0, 0);
#line 1363
  define_default_variables();
#line 1367
  default_file = enter_file((char *)".DEFAULT");
#line 1369
  if ((unsigned long )makefiles == (unsigned long )((struct stringlist *)0)) {
#line 1369
    tmp___26 = (char **)0;
  } else {
#line 1369
    tmp___26 = makefiles->list;
  }
#line 1369
  read_makefiles___0 = read_all_makefiles(tmp___26);
#line 1407
  decode_env_switches((char *)"MAKEFLAGS", 9U);
#line 1425
  if (jobserver_fds) {
#line 1429
    i = 1U;
#line 1429
    while (i < jobserver_fds->idx) {
#line 1430
      if (! ((unsigned long )*(jobserver_fds->list + 0) == (unsigned long )*(jobserver_fds->list + i))) {
#line 1430
        if ((int )*(*(jobserver_fds->list + 0)) == (int )*(*(jobserver_fds->list + i))) {
#line 1430
          if (! ((int )*(*(jobserver_fds->list + 0)) == 0)) {
#line 1430
            tmp___28 = strcmp((char const   *)(*(jobserver_fds->list + 0) + 1), (char const   *)(*(jobserver_fds->list + i) + 1));
#line 1430
            if (tmp___28) {
#line 1431
              tmp___27 = dcgettext((char const   *)((void *)0), "internal error: multiple --jobserver-fds options",
                                   5);
#line 1431
              fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27);
            }
          }
        } else {
#line 1431
          tmp___27 = dcgettext((char const   *)((void *)0), "internal error: multiple --jobserver-fds options",
                               5);
#line 1431
          fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___27);
        }
      }
#line 1429
      i ++;
    }
#line 1435
    cp = *(jobserver_fds->list + 0);
#line 1437
    tmp___30 = sscanf((char const   * __restrict  )cp, (char const   * __restrict  )"%d,%d",
                      & job_fds[0], & job_fds[1]);
#line 1437
    if (tmp___30 != 2) {
#line 1438
      tmp___29 = dcgettext((char const   *)((void *)0), "internal error: invalid --jobserver-fds string `%s\'",
                           5);
#line 1438
      fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___29, cp);
    }
#line 1447
    if (job_slots > 0U) {
#line 1448
      tmp___31 = dcgettext((char const   *)((void *)0), "warning: -jN forced in submake: disabling jobserver mode.",
                           5);
#line 1448
      error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___31);
    } else {
#line 1456
      job_rfd = dup(job_fds[0]);
#line 1456
      if (job_rfd < 0) {
#line 1458
        tmp___33 = __errno_location();
#line 1458
        if (*tmp___33 != 9) {
#line 1459
          tmp___32 = dcgettext((char const   *)((void *)0), "dup jobserver", 5);
#line 1459
          pfatal_with_name(tmp___32);
        }
#line 1461
        tmp___34 = dcgettext((char const   *)((void *)0), "warning: jobserver unavailable: using -j1.  Add `+\' to parent make rule.",
                             5);
#line 1461
        error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___34);
#line 1463
        job_slots = 1U;
      }
    }
#line 1466
    if (job_slots > 0U) {
#line 1468
      close(job_fds[0]);
#line 1469
      close(job_fds[1]);
#line 1470
      job_fds[1] = -1;
#line 1470
      job_fds[0] = job_fds[1];
#line 1471
      free((void *)jobserver_fds->list);
#line 1472
      free((void *)jobserver_fds);
#line 1473
      jobserver_fds = (struct stringlist *)0;
    }
  }
#line 1480
  if (job_slots > 1U) {
#line 1482
    c = (char )'+';
#line 1484
    tmp___36 = pipe((int *)(job_fds));
#line 1484
    if (tmp___36 < 0) {
#line 1485
      tmp___35 = dcgettext((char const   *)((void *)0), "creating jobs pipe", 5);
#line 1485
      pfatal_with_name(tmp___35);
    } else {
#line 1484
      job_rfd = dup(job_fds[0]);
#line 1484
      if (job_rfd < 0) {
#line 1485
        tmp___35 = dcgettext((char const   *)((void *)0), "creating jobs pipe", 5);
#line 1485
        pfatal_with_name(tmp___35);
      }
    }
#line 1492
    while (1) {
#line 1492
      job_slots --;
#line 1492
      if (! job_slots) {
#line 1492
        break;
      }
#line 1493
      while (1) {
#line 1493
        tmp___39 = write(job_fds[1], (void const   *)(& c), (size_t )1);
#line 1493
        if (! (tmp___39 != 1L)) {
#line 1493
          break;
        }
#line 1494
        tmp___38 = __errno_location();
#line 1494
        if (! (*tmp___38 == 4)) {
#line 1495
          tmp___37 = dcgettext((char const   *)((void *)0), "init jobserver pipe",
                               5);
#line 1495
          pfatal_with_name(tmp___37);
        }
      }
    }
#line 1499
    tmp___40 = xmalloc((unsigned int )sizeof(struct stringlist ));
#line 1499
    jobserver_fds = (struct stringlist *)tmp___40;
#line 1501
    tmp___41 = xmalloc((unsigned int )sizeof(char *));
#line 1501
    jobserver_fds->list = (char **)tmp___41;
#line 1502
    *(jobserver_fds->list + 0) = xmalloc((unsigned int )(sizeof("1024") * 2UL + 1UL));
#line 1504
    sprintf((char * __restrict  )*(jobserver_fds->list + 0), (char const   * __restrict  )"%d,%d",
            job_fds[0], job_fds[1]);
#line 1505
    jobserver_fds->idx = 1U;
#line 1506
    jobserver_fds->max = 1U;
  }
#line 1512
  define_makeflags(1, 0);
#line 1517
  snap_deps();
#line 1524
  convert_to_pattern();
#line 1531
  install_default_implicit_rules();
#line 1535
  count_implicit_rule_limits();
#line 1539
  build_vpath_lists();
#line 1545
  if ((unsigned long )old_files != (unsigned long )((struct stringlist *)0)) {
#line 1546
    p = old_files->list;
#line 1546
    while ((unsigned long )*p != (unsigned long )((char *)0)) {
#line 1548
      f = enter_command_line_file(*p);
#line 1549
      tmp___42 = (uintmax_t )1;
#line 1549
      f->mtime_before_update = tmp___42;
#line 1549
      f->last_mtime = tmp___42;
#line 1550
      f->updated = 1U;
#line 1551
      f->update_status = (short)0;
#line 1552
      f->command_state = (enum __anonenum_command_state_55 )3;
#line 1546
      p ++;
    }
  }
#line 1555
  if ((unsigned long )new_files != (unsigned long )((struct stringlist *)0)) {
#line 1557
    p = new_files->list;
#line 1557
    while ((unsigned long )*p != (unsigned long )((char *)0)) {
#line 1559
      f = enter_command_line_file(*p);
#line 1560
      tmp___43 = 0xfffffffffffffffeUL;
#line 1560
      f->mtime_before_update = tmp___43;
#line 1560
      f->last_mtime = tmp___43;
#line 1557
      p ++;
    }
  }
#line 1565
  remote_setup();
#line 1567
  if ((unsigned long )read_makefiles___0 != (unsigned long )((struct dep *)0)) {
#line 1571
    makefile_mtimes = (uintmax_t *)0;
#line 1572
    mm_idx = 0U;
#line 1573
    nargv = argv;
#line 1574
    nargc = argc;
#line 1575
    orig_db_level = db_level;
#line 1577
    if (! (256 & db_level)) {
#line 1578
      db_level = 0;
    }
#line 1580
    while (1) {
#line 1580
      if (1 & db_level) {
#line 1580
        tmp___44 = dcgettext((char const   *)((void *)0), "Updating makefiles....\n",
                             5);
#line 1580
        printf((char const   * __restrict  )tmp___44);
#line 1580
        fflush(stdout);
      }
#line 1580
      break;
    }
#line 1586
    last = (struct dep *)0;
#line 1587
    d = read_makefiles___0;
#line 1588
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 1590
      f___0 = d->file;
#line 1591
      if (f___0->double_colon) {
#line 1592
        f___0 = f___0->double_colon;
#line 1592
        while ((unsigned long )f___0 != (unsigned long )((void *)0)) {
#line 1594
          if ((unsigned long )f___0->deps == (unsigned long )((struct dep *)0)) {
#line 1594
            if ((unsigned long )f___0->cmds != (unsigned long )((struct commands *)0)) {
#line 1604
              while (1) {
#line 1604
                if (2 & db_level) {
#line 1604
                  tmp___45 = dcgettext((char const   *)((void *)0), "Makefile `%s\' might loop; not remaking it.\n",
                                       5);
#line 1604
                  printf((char const   * __restrict  )tmp___45, f___0->name);
#line 1604
                  fflush(stdout);
                }
#line 1604
                break;
              }
#line 1608
              if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
#line 1609
                read_makefiles___0 = d->next;
              } else {
#line 1611
                last->next = d->next;
              }
#line 1614
              free((void *)((char *)d));
#line 1616
              if ((unsigned long )last == (unsigned long )((struct dep *)0)) {
#line 1616
                d = read_makefiles___0;
              } else {
#line 1616
                d = last->next;
              }
#line 1618
              break;
            }
          }
#line 1592
          f___0 = f___0->prev;
        }
      }
#line 1621
      if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
#line 1621
        goto _L;
      } else
#line 1621
      if (! f___0->double_colon) {
        _L: /* CIL Label */ 
#line 1623
        tmp___46 = xrealloc((char *)makefile_mtimes, (unsigned int )((unsigned long )(mm_idx + 1U) * sizeof(uintmax_t )));
#line 1623
        makefile_mtimes = (uintmax_t *)tmp___46;
#line 1626
        tmp___47 = mm_idx;
#line 1626
        mm_idx ++;
#line 1626
        if ((d->file)->last_mtime) {
#line 1626
          *(makefile_mtimes + tmp___47) = (d->file)->last_mtime;
        } else {
#line 1626
          tmp___48 = f_mtime(d->file, 0);
#line 1626
          *(makefile_mtimes + tmp___47) = tmp___48;
        }
#line 1627
        last = d;
#line 1628
        d = d->next;
      }
    }
#line 1634
    define_makeflags(1, 1);
#line 1636
    tmp___49 = update_goal_chain(read_makefiles___0, 1);
#line 1636
    switch (tmp___49) {
    default: 
#line 1641
    __assert_fail("BOGUS_UPDATE_STATUS", "main.c", 1641U, "main");
#line 1642
    break;
    case -1: 
#line 1646
    break;
    case 2: 
#line 1652
    any_remade = 0;
#line 1655
    any_failed = 0;
#line 1659
    i___1 = 0U;
#line 1659
    d___0 = read_makefiles___0;
#line 1659
    while ((unsigned long )d___0 != (unsigned long )((struct dep *)0)) {
#line 1663
      (d___0->file)->considered = 0U;
#line 1665
      if ((d___0->file)->updated) {
#line 1668
        if ((int )(d___0->file)->update_status == 0) {
#line 1671
          if ((d___0->file)->last_mtime) {
#line 1671
            tmp___51 = (d___0->file)->last_mtime;
          } else {
#line 1671
            tmp___50 = f_mtime(d___0->file, 0);
#line 1671
            tmp___51 = tmp___50;
          }
#line 1671
          any_remade |= tmp___51 != *(makefile_mtimes + i___1);
        } else
#line 1674
        if (! (d___0->changed & (1 << 2))) {
#line 1679
          tmp___52 = dcgettext((char const   *)((void *)0), "Failed to remake makefile `%s\'.",
                               5);
#line 1679
          error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___52,
                (d___0->file)->name);
#line 1681
          if ((d___0->file)->last_mtime) {
#line 1681
            mtime = (d___0->file)->last_mtime;
          } else {
#line 1681
            tmp___53 = f_mtime(d___0->file, 0);
#line 1681
            mtime = tmp___53;
          }
#line 1682
          if (mtime != 0xffffffffffffffffUL) {
#line 1682
            if (mtime != *(makefile_mtimes + i___1)) {
#line 1682
              tmp___54 = 1;
            } else {
#line 1682
              tmp___54 = 0;
            }
          } else {
#line 1682
            tmp___54 = 0;
          }
#line 1682
          any_remade |= tmp___54;
        }
      } else
#line 1688
      if (! (d___0->changed & (1 << 2))) {
#line 1691
        if (d___0->changed & (1 << 1)) {
#line 1694
          if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 1694
            tmp___55 = (d___0->file)->name;
          } else {
#line 1694
            tmp___55 = d___0->name;
          }
#line 1694
          tmp___56 = dcgettext((char const   *)((void *)0), "Included makefile `%s\' was not found.",
                               5);
#line 1694
          error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___56,
                tmp___55);
        } else {
#line 1700
          if ((unsigned long )d___0->name == (unsigned long )((char *)0)) {
#line 1700
            tmp___57 = (d___0->file)->name;
          } else {
#line 1700
            tmp___57 = d___0->name;
          }
#line 1700
          tmp___58 = dcgettext((char const   *)((void *)0), "Makefile `%s\' was not found",
                               5);
#line 1700
          error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___58,
                tmp___57);
#line 1702
          any_failed = 1;
        }
      }
#line 1659
      i___1 ++;
#line 1659
      d___0 = d___0->next;
    }
#line 1707
    read_makefiles___0 = (struct dep *)0;
#line 1709
    if (any_remade) {
#line 1710
      goto re_exec;
    }
#line 1711
    if (any_failed) {
#line 1712
      die(2);
    }
#line 1713
    break;
    re_exec: 
    case 0: 
#line 1720
    remove_intermediates(0);
#line 1722
    if (print_data_base_flag) {
#line 1723
      print_data_base();
    }
#line 1725
    log_working_directory(0);
#line 1727
    if ((unsigned long )makefiles != (unsigned long )((struct stringlist *)0)) {
#line 1730
      j = 0U;
#line 1731
      i___2 = 1U;
#line 1731
      while (i___2 < (unsigned int )argc) {
#line 1732
        tmp___59 = strncmp((char const   *)*(argv + i___2), "-f", (size_t )2);
#line 1732
        if (tmp___59 == 0) {
#line 1734
          p___1 = *(argv + i___2) + 2;
#line 1735
          if ((int )*p___1 == 0) {
#line 1736
            i___2 ++;
#line 1736
            *(argv + i___2) = *(makefiles->list + j);
          } else {
#line 1738
            *(argv + i___2) = concat((char *)"-f", *(makefiles->list + j), (char *)"");
          }
#line 1739
          j ++;
        }
#line 1731
        i___2 ++;
      }
    }
#line 1744
    if (stdin_nm) {
#line 1746
      tmp___60 = xmalloc((unsigned int )((unsigned long )(nargc + 2) * sizeof(char *)));
#line 1746
      nargv = (char **)tmp___60;
#line 1747
      memmove((void *)((char *)nargv), (void const   *)((char *)argv), (unsigned long )argc * sizeof(char *));
#line 1748
      tmp___61 = nargc;
#line 1748
      nargc ++;
#line 1748
      *(nargv + tmp___61) = concat((char *)"-o", stdin_nm, (char *)"");
#line 1749
      *(nargv + nargc) = (char *)0;
    }
#line 1752
    if ((unsigned long )directories___0 != (unsigned long )((struct stringlist *)0)) {
#line 1752
      if (directories___0->idx > 0U) {
#line 1755
        if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
#line 1757
          tmp___62 = chdir((char const   *)directory_before_chdir);
#line 1757
          if (tmp___62 < 0) {
#line 1759
            perror_with_name((char *)"chdir", (char *)"");
#line 1760
            bad = (char)1;
          } else {
#line 1763
            bad = (char)0;
          }
        } else {
#line 1766
          bad = (char)1;
        }
#line 1767
        if (bad) {
#line 1768
          tmp___63 = dcgettext((char const   *)((void *)0), "Couldn\'t change back to original directory.",
                               5);
#line 1768
          fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___63);
        }
      }
    }
#line 1772
    p = environ;
#line 1772
    while ((unsigned long )*p != (unsigned long )((char *)0)) {
#line 1773
      tmp___65 = strncmp((char const   *)*p, "MAKELEVEL=", (size_t )10);
#line 1773
      if (tmp___65 == 0) {
#line 1779
        tmp___64 = __builtin_alloca(40UL);
#line 1779
        sgi_loses = (char *)tmp___64;
#line 1780
        *p = sgi_loses;
#line 1781
        sprintf((char * __restrict  )*p, (char const   * __restrict  )"MAKELEVEL=%u",
                makelevel);
#line 1782
        break;
      }
#line 1772
      p ++;
    }
#line 1799
    if (1 & db_level) {
#line 1802
      tmp___66 = dcgettext((char const   *)((void *)0), "Re-executing:", 5);
#line 1802
      fputs((char const   * __restrict  )tmp___66, (FILE * __restrict  )stdout);
#line 1803
      p___2 = nargv;
#line 1803
      while ((unsigned long )*p___2 != (unsigned long )((char *)0)) {
#line 1804
        printf((char const   * __restrict  )" %s", *p___2);
#line 1803
        p___2 ++;
      }
#line 1805
      putchar('\n');
    }
#line 1808
    fflush(stdout);
#line 1809
    fflush(stderr);
#line 1812
    if (job_rfd >= 0) {
#line 1813
      close(job_rfd);
    }
#line 1816
    exec_command(nargv, environ);
    }
#line 1824
    db_level = orig_db_level;
  }
#line 1828
  define_makeflags(1, 0);
#line 1832
  if (stdin_nm) {
#line 1832
    tmp___68 = unlink((char const   *)stdin_nm);
#line 1832
    if (tmp___68 < 0) {
#line 1832
      tmp___69 = __errno_location();
#line 1832
      if (*tmp___69 != 2) {
#line 1833
        tmp___67 = dcgettext((char const   *)((void *)0), "unlink (temporary file): ",
                             5);
#line 1833
        perror_with_name(tmp___67, stdin_nm);
      }
    }
  }
#line 1839
  if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
#line 1841
    if ((unsigned long )default_goal_file != (unsigned long )((struct file *)0)) {
#line 1843
      tmp___70 = xmalloc((unsigned int )sizeof(struct dep ));
#line 1843
      goals = (struct dep *)tmp___70;
#line 1844
      goals->next = (struct dep *)0;
#line 1845
      goals->name = (char *)0;
#line 1846
      goals->file = default_goal_file;
    }
  } else {
#line 1850
    lastgoal->next = (struct dep *)0;
  }
#line 1852
  if (! goals) {
#line 1854
    if ((unsigned long )read_makefiles___0 == (unsigned long )((struct dep *)0)) {
#line 1855
      tmp___71 = dcgettext((char const   *)((void *)0), "No targets specified and no makefile found",
                           5);
#line 1855
      fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___71);
    }
#line 1857
    tmp___72 = dcgettext((char const   *)((void *)0), "No targets", 5);
#line 1857
    fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___72);
  }
#line 1862
  while (1) {
#line 1862
    if (1 & db_level) {
#line 1862
      tmp___73 = dcgettext((char const   *)((void *)0), "Updating goal targets....\n",
                           5);
#line 1862
      printf((char const   * __restrict  )tmp___73);
#line 1862
      fflush(stdout);
    }
#line 1862
    break;
  }
#line 1864
  tmp___74 = update_goal_chain(goals, 0);
#line 1864
  switch (tmp___74) {
  case 0: 
  case -1: 
#line 1870
  status = 0;
#line 1871
  break;
  case 2: 
#line 1875
  status = 2;
#line 1876
  break;
  case 1: 
#line 1879
  status = 1;
#line 1880
  break;
  default: 
#line 1882
  abort();
  }
#line 1886
  if (clock_skew_detected) {
#line 1887
    tmp___75 = dcgettext((char const   *)((void *)0), "warning:  Clock skew detected.  Your build may be incomplete.",
                         5);
#line 1887
    error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___75);
  }
#line 1891
  die(status);
#line 1894
  return (0);
}
}
#line 1899 "main.c"
static char options[1UL + (sizeof(switches) / sizeof(switches[0])) * 3UL]  ;
#line 1900 "main.c"
static struct option long_options[sizeof(switches) / sizeof(switches[0]) + sizeof(long_option_aliases) / sizeof(long_option_aliases[0])]  ;
#line 1905 "main.c"
static void init_switches(void) 
{ 
  register char *p ;
  register int c ;
  register unsigned int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1912
  if ((int )options[0] != 0) {
#line 1914
    return;
  }
#line 1916
  p = options;
#line 1920
  tmp = p;
#line 1920
  p ++;
#line 1920
  *tmp = (char )'-';
#line 1922
  i = 0U;
#line 1922
  while (switches[i].c != 0) {
#line 1924
    if ((unsigned long )switches[i].long_name == (unsigned long )((char * const  )0)) {
#line 1924
      long_options[i].name = "";
    } else {
#line 1924
      long_options[i].name = (char const   *)switches[i].long_name;
    }
#line 1926
    long_options[i].flag = (int *)0;
#line 1927
    long_options[i].val = (int )switches[i].c;
#line 1928
    if (switches[i].c <= 127) {
#line 1929
      tmp___0 = p;
#line 1929
      p ++;
#line 1929
      *tmp___0 = (char )switches[i].c;
    }
#line 1930
    switch ((unsigned int const   )switches[i].type) {
    case 5U: 
    case 1U: 
    case 0U: 
#line 1935
    long_options[i].has_arg = 0;
#line 1936
    break;
    case 4U: 
    case 3U: 
    case 2U: 
#line 1941
    if (switches[i].c <= 127) {
#line 1942
      tmp___1 = p;
#line 1942
      p ++;
#line 1942
      *tmp___1 = (char )':';
    }
#line 1943
    if ((unsigned long )switches[i].noarg_value != (unsigned long )((char * const  )0)) {
#line 1945
      if (switches[i].c <= 127) {
#line 1946
        tmp___2 = p;
#line 1946
        p ++;
#line 1946
        *tmp___2 = (char )':';
      }
#line 1947
      long_options[i].has_arg = 2;
    } else {
#line 1950
      long_options[i].has_arg = 1;
    }
#line 1951
    break;
    }
#line 1922
    i ++;
  }
#line 1954
  *p = (char )'\000';
#line 1955
  c = 0;
#line 1955
  while ((unsigned long )c < sizeof(long_option_aliases) / sizeof(long_option_aliases[0])) {
#line 1958
    tmp___3 = i;
#line 1958
    i ++;
#line 1958
    long_options[tmp___3] = long_option_aliases[c];
#line 1955
    c ++;
  }
#line 1959
  long_options[i].name = (char const   *)0;
#line 1960
  return;
}
}
#line 1962 "main.c"
static void handle_non_switch_argument(char *arg , int env ) 
{ 
  struct variable *v ;
  struct command_variable *cv ;
  char *tmp ;
  struct file *f ;
  struct file *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct variable *v___0 ;
  char *value ;
  unsigned int oldlen ;
  unsigned int newlen ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 1969
  if ((int )*(arg + 0) == 45) {
#line 1969
    if ((int )*(arg + 1) == 0) {
#line 1971
      return;
    }
  }
#line 1972
  v = try_variable_definition((struct floc  const  *)0, arg, (enum variable_origin )4,
                              0);
#line 1973
  if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 1977
    tmp = xmalloc((unsigned int )sizeof(*cv));
#line 1977
    cv = (struct command_variable *)tmp;
#line 1979
    cv->variable = v;
#line 1980
    cv->next = command_variables;
#line 1981
    command_variables = cv;
  } else
#line 1983
  if (! env) {
#line 1988
    tmp___0 = enter_command_line_file(arg);
#line 1988
    f = tmp___0;
#line 1989
    f->cmd_target = 1U;
#line 1991
    if ((unsigned long )goals == (unsigned long )((struct dep *)0)) {
#line 1993
      tmp___1 = xmalloc((unsigned int )sizeof(struct dep ));
#line 1993
      goals = (struct dep *)tmp___1;
#line 1994
      lastgoal = goals;
    } else {
#line 1998
      tmp___2 = xmalloc((unsigned int )sizeof(struct dep ));
#line 1998
      lastgoal->next = (struct dep *)tmp___2;
#line 1999
      lastgoal = lastgoal->next;
    }
#line 2001
    lastgoal->name = (char *)0;
#line 2002
    lastgoal->file = f;
#line 2009
    v___0 = lookup_variable((char *)"MAKECMDGOALS", 12U);
#line 2010
    if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
#line 2011
      value = f->name;
    } else {
#line 2017
      tmp___3 = strlen((char const   *)v___0->value);
#line 2017
      oldlen = (unsigned int )tmp___3;
#line 2018
      tmp___4 = strlen((char const   *)f->name);
#line 2018
      newlen = (unsigned int )tmp___4;
#line 2019
      tmp___5 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));
#line 2019
      value = (char *)tmp___5;
#line 2020
      memmove((void *)value, (void const   *)v___0->value, (size_t )oldlen);
#line 2021
      *(value + oldlen) = (char )' ';
#line 2022
      memmove((void *)(value + (oldlen + 1U)), (void const   *)f->name, (size_t )(newlen + 1U));
    }
#line 2024
    define_variable_in_set((char *)"MAKECMDGOALS", 12U, value, (enum variable_origin )0,
                           0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
  }
#line 2027
  return;
}
}
#line 2031 "main.c"
static void print_usage(int bad ) 
{ 
  register struct command_switch  const  *cs ;
  FILE *usageto ;
  char *tmp ;
  char *tmp___0 ;
  char buf___1[1024] ;
  char shortarg[50] ;
  char longarg[50] ;
  char *p ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  unsigned int i ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  struct command_switch  const  *ncs ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 2038
  if (print_version_flag) {
#line 2039
    print_version();
  }
#line 2041
  if (bad) {
#line 2041
    usageto = stderr;
  } else {
#line 2041
    usageto = stdout;
  }
#line 2043
  tmp = dcgettext((char const   *)((void *)0), "Usage: %s [options] [target] ...\n",
                  5);
#line 2043
  fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )tmp, program);
#line 2045
  tmp___0 = dcgettext((char const   *)((void *)0), "Options:\n", 5);
#line 2045
  fputs((char const   * __restrict  )tmp___0, (FILE * __restrict  )usageto);
#line 2046
  cs = switches;
#line 2046
  while (cs->c != 0) {
#line 2050
    if (! cs->description) {
#line 2051
      goto __Cont;
    } else
#line 2050
    if ((int )*(cs->description + 0) == 45) {
#line 2051
      goto __Cont;
    }
#line 2053
    switch (long_options[cs - switches].has_arg) {
    case 0: 
#line 2056
    longarg[0] = (char )'\000';
#line 2056
    shortarg[0] = longarg[0];
#line 2057
    break;
    case 1: 
#line 2059
    tmp___1 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                        5);
#line 2059
    sprintf((char * __restrict  )(longarg), (char const   * __restrict  )"=%s", tmp___1);
#line 2060
    tmp___2 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                        5);
#line 2060
    sprintf((char * __restrict  )(shortarg), (char const   * __restrict  )" %s", tmp___2);
#line 2061
    break;
    case 2: 
#line 2063
    tmp___3 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                        5);
#line 2063
    sprintf((char * __restrict  )(longarg), (char const   * __restrict  )"[=%s]",
            tmp___3);
#line 2064
    tmp___4 = dcgettext((char const   *)((void *)0), (char const   *)cs->argdesc,
                        5);
#line 2064
    sprintf((char * __restrict  )(shortarg), (char const   * __restrict  )" [%s]",
            tmp___4);
#line 2065
    break;
    }
#line 2068
    p = buf___1;
#line 2070
    if (cs->c <= 127) {
#line 2072
      sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"  -%c%s",
              cs->c, shortarg);
#line 2073
      tmp___5 = strlen((char const   *)p);
#line 2073
      p += tmp___5;
    }
#line 2075
    if ((unsigned long )cs->long_name != (unsigned long )((char * const  )0)) {
#line 2078
      if (! (cs->c <= 127)) {
#line 2078
        tmp___6 = "  ";
      } else {
#line 2078
        tmp___6 = ", ";
      }
#line 2078
      sprintf((char * __restrict  )p, (char const   * __restrict  )"%s--%s%s", tmp___6,
              cs->long_name, longarg);
#line 2081
      tmp___7 = strlen((char const   *)p);
#line 2081
      p += tmp___7;
#line 2082
      i = 0U;
#line 2082
      while ((unsigned long )i < sizeof(long_option_aliases) / sizeof(long_option_aliases[0])) {
#line 2085
        if (long_option_aliases[i].val == (int )cs->c) {
#line 2087
          sprintf((char * __restrict  )p, (char const   * __restrict  )", --%s%s",
                  long_option_aliases[i].name, longarg);
#line 2089
          tmp___8 = strlen((char const   *)p);
#line 2089
          p += tmp___8;
        }
#line 2082
        i ++;
      }
    }
#line 2093
    ncs = cs;
#line 2094
    while (1) {
#line 2094
      ncs ++;
#line 2094
      if (! (ncs->c != 0)) {
#line 2094
        break;
      }
#line 2095
      if (ncs->description) {
#line 2095
        if ((int )*(ncs->description + 0) == 45) {
#line 2095
          if ((int )*(ncs->description + 1) == (int )cs->c) {
#line 2102
            sprintf((char * __restrict  )p, (char const   * __restrict  )", -%c%s",
                    ncs->c, shortarg);
#line 2103
            tmp___9 = strlen((char const   *)p);
#line 2103
            p += tmp___9;
#line 2104
            if ((unsigned long )ncs->long_name != (unsigned long )((char * const  )0)) {
#line 2106
              sprintf((char * __restrict  )p, (char const   * __restrict  )", --%s%s",
                      ncs->long_name, longarg);
#line 2107
              tmp___10 = strlen((char const   *)p);
#line 2107
              p += tmp___10;
            }
          }
        }
      }
    }
#line 2112
    if (p - buf___1 > 28L) {
#line 2117
      fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )"%s\n", buf___1);
#line 2118
      buf___1[0] = (char )'\000';
    }
#line 2121
    tmp___11 = dcgettext((char const   *)((void *)0), (char const   *)cs->description,
                         5);
#line 2121
    fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )"%*s%s.\n",
            -30, buf___1, tmp___11);
    __Cont: /* CIL Label */ 
#line 2046
    cs ++;
  }
#line 2126
  tmp___12 = dcgettext((char const   *)((void *)0), "\nReport bugs to <bug-make@gnu.org>.\n",
                       5);
#line 2126
  fprintf((FILE * __restrict  )usageto, (char const   * __restrict  )tmp___12);
#line 2127
  return;
}
}
#line 2132 "main.c"
static void decode_switches(int argc , char **argv , int env ) 
{ 
  int bad ;
  register struct command_switch  const  *cs ;
  register struct stringlist *sl ;
  register int c ;
  int doit ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int i ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 2138
  bad = 0;
#line 2146
  init_switches();
#line 2150
  opterr = ! env;
#line 2152
  optind = 0;
#line 2154
  while (optind < argc) {
#line 2157
    c = getopt_long(argc, (char * const  *)argv, (char const   *)(options), (struct option  const  *)(long_options),
                    (int *)0);
#line 2158
    if (c == -1) {
#line 2160
      break;
    } else
#line 2161
    if (c == 1) {
#line 2163
      handle_non_switch_argument(optarg, env);
    } else
#line 2164
    if (c == 63) {
#line 2168
      bad = 1;
    } else {
#line 2170
      cs = switches;
#line 2170
      while (cs->c != 0) {
#line 2171
        if (cs->c == (int const   )c) {
#line 2177
          if (! env) {
#line 2177
            tmp = 1;
          } else
#line 2177
          if (cs->env) {
#line 2177
            tmp = 1;
          } else {
#line 2177
            tmp = 0;
          }
#line 2177
          doit = tmp;
#line 2179
          switch ((unsigned int const   )cs->type) {
          default: 
#line 2182
          abort();
          case 5U: 
#line 2185
          break;
          case 1U: 
          case 0U: 
#line 2189
          if (doit) {
#line 2190
            *((int *)cs->value_ptr) = (unsigned int const   )cs->type == 0U;
          }
#line 2191
          break;
          case 2U: 
#line 2194
          if (! doit) {
#line 2195
            break;
          }
#line 2197
          if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 2198
            optarg = (char *)cs->noarg_value;
          }
#line 2200
          sl = *((struct stringlist **)cs->value_ptr);
#line 2201
          if ((unsigned long )sl == (unsigned long )((struct stringlist *)0)) {
#line 2203
            tmp___0 = xmalloc((unsigned int )sizeof(struct stringlist ));
#line 2203
            sl = (struct stringlist *)tmp___0;
#line 2205
            sl->max = 5U;
#line 2206
            sl->idx = 0U;
#line 2207
            tmp___1 = xmalloc((unsigned int )(5UL * sizeof(char *)));
#line 2207
            sl->list = (char **)tmp___1;
#line 2208
            *((struct stringlist **)cs->value_ptr) = sl;
          } else
#line 2210
          if (sl->idx == sl->max - 1U) {
#line 2212
            sl->max += 5U;
#line 2213
            tmp___2 = xrealloc((char *)sl->list, (unsigned int )((unsigned long )sl->max * sizeof(char *)));
#line 2213
            sl->list = (char **)tmp___2;
          }
#line 2217
          tmp___3 = sl->idx;
#line 2217
          (sl->idx) ++;
#line 2217
          *(sl->list + tmp___3) = optarg;
#line 2218
          *(sl->list + sl->idx) = (char *)0;
#line 2219
          break;
          case 3U: 
#line 2222
          if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 2222
            if (argc > optind) {
#line 2222
              if ((unsigned int )*(*(argv + optind) + 0) - 48U <= 9U) {
#line 2224
                tmp___4 = optind;
#line 2224
                optind ++;
#line 2224
                optarg = *(argv + tmp___4);
              }
            }
          }
#line 2226
          if (! doit) {
#line 2227
            break;
          }
#line 2229
          if ((unsigned long )optarg != (unsigned long )((char *)0)) {
#line 2231
            tmp___5 = atoi((char const   *)optarg);
#line 2231
            i = tmp___5;
#line 2232
            if (i < 1) {
#line 2234
              if (doit) {
#line 2235
                tmp___6 = dcgettext((char const   *)((void *)0), "the `-%c\' option requires a positive integral argument",
                                    5);
#line 2235
                error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                      cs->c);
              }
#line 2237
              bad = 1;
            } else {
#line 2240
              *((unsigned int *)cs->value_ptr) = (unsigned int )i;
            }
          } else {
#line 2243
            *((unsigned int *)cs->value_ptr) = *((unsigned int *)cs->noarg_value);
          }
#line 2245
          break;
          case 4U: 
#line 2249
          if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 2249
            if (optind < argc) {
#line 2249
              if ((unsigned int )*(*(argv + optind) + 0) - 48U <= 9U) {
#line 2251
                tmp___7 = optind;
#line 2251
                optind ++;
#line 2251
                optarg = *(argv + tmp___7);
              } else
#line 2249
              if ((int )*(*(argv + optind) + 0) == 46) {
#line 2251
                tmp___7 = optind;
#line 2251
                optind ++;
#line 2251
                optarg = *(argv + tmp___7);
              }
            }
          }
#line 2253
          if (doit) {
#line 2254
            if ((unsigned long )optarg != (unsigned long )((char *)0)) {
#line 2254
              tmp___8 = atof((char const   *)optarg);
#line 2254
              *((double *)cs->value_ptr) = tmp___8;
            } else {
#line 2254
              *((double *)cs->value_ptr) = *((double *)cs->noarg_value);
            }
          }
#line 2258
          break;
          }
#line 2263
          break;
        }
#line 2170
        cs ++;
      }
    }
  }
#line 2271
  while (optind < argc) {
#line 2272
    tmp___9 = optind;
#line 2272
    optind ++;
#line 2272
    handle_non_switch_argument(*(argv + tmp___9), env);
  }
#line 2275
  if (! env) {
#line 2275
    if (bad) {
#line 2275
      goto _L;
    } else
#line 2275
    if (print_usage_flag) {
      _L: /* CIL Label */ 
#line 2277
      print_usage(bad);
#line 2278
      if (bad) {
#line 2278
        tmp___10 = 2;
      } else {
#line 2278
        tmp___10 = 0;
      }
#line 2278
      die(tmp___10);
    }
  }
#line 2280
  return;
}
}
#line 2287 "main.c"
static void decode_env_switches(char *envar , unsigned int len ) 
{ 
  char *varref ;
  void *tmp ;
  char *value ;
  char *p ;
  int argc ;
  char **argv ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 2292
  tmp = __builtin_alloca((unsigned long )((2U + len) + 2U));
#line 2292
  varref = (char *)tmp;
#line 2298
  *(varref + 0) = (char )'$';
#line 2299
  *(varref + 1) = (char )'(';
#line 2300
  memmove((void *)(varref + 2), (void const   *)envar, (size_t )len);
#line 2301
  *(varref + (2U + len)) = (char )')';
#line 2302
  *(varref + ((2U + len) + 1U)) = (char )'\000';
#line 2303
  value = variable_expand(varref);
#line 2306
  value = next_token(value);
#line 2307
  tmp___0 = strlen((char const   *)value);
#line 2307
  len = (unsigned int )tmp___0;
#line 2308
  if (len == 0U) {
#line 2309
    return;
  }
#line 2312
  tmp___1 = __builtin_alloca((unsigned long )((1U + len) + 1U) * sizeof(char *));
#line 2312
  argv = (char **)tmp___1;
#line 2317
  tmp___2 = xmalloc(2U * len);
#line 2317
  p = tmp___2;
#line 2321
  *(argv + 0) = (char *)0;
#line 2322
  argc = 1;
#line 2323
  *(argv + argc) = p;
#line 2324
  while ((int )*value != 0) {
#line 2326
    if ((int )*value == 92) {
#line 2326
      if ((int )*(value + 1) != 0) {
#line 2327
        value ++;
      } else {
#line 2326
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2328
      tmp___5 = __ctype_b_loc();
#line 2328
      if ((int const   )*(*tmp___5 + (int )*value) & 1) {
#line 2331
        tmp___3 = p;
#line 2331
        p ++;
#line 2331
        *tmp___3 = (char )'\000';
#line 2332
        argc ++;
#line 2332
        *(argv + argc) = p;
#line 2333
        while (1) {
#line 2334
          value ++;
#line 2333
          tmp___4 = __ctype_b_loc();
#line 2333
          if (! ((int const   )*(*tmp___4 + (int )*value) & 1)) {
#line 2333
            break;
          }
        }
#line 2336
        continue;
      }
    }
#line 2338
    tmp___6 = p;
#line 2338
    p ++;
#line 2338
    tmp___7 = value;
#line 2338
    value ++;
#line 2338
    *tmp___6 = *tmp___7;
  }
#line 2340
  *p = (char )'\000';
#line 2341
  argc ++;
#line 2341
  *(argv + argc) = (char *)0;
#line 2343
  if ((int )*(*(argv + 1) + 0) != 45) {
#line 2343
    tmp___8 = strchr((char const   *)*(argv + 1), '=');
#line 2343
    if ((unsigned long )tmp___8 == (unsigned long )((char *)0)) {
#line 2348
      *(argv + 1) = concat((char *)"-", *(argv + 1), (char *)"");
    }
  }
#line 2351
  decode_switches(argc, argv, 1);
#line 2352
  return;
}
}
#line 2360 "main.c"
static char *quote_for_env(char *out , char *in ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 2364
  while ((int )*in != 0) {
#line 2366
    if ((int )*in == 36) {
#line 2367
      tmp = out;
#line 2367
      out ++;
#line 2367
      *tmp = (char )'$';
    } else {
#line 2368
      tmp___1 = __ctype_b_loc();
#line 2368
      if ((int const   )*(*tmp___1 + (int )*in) & 1) {
#line 2369
        tmp___0 = out;
#line 2369
        out ++;
#line 2369
        *tmp___0 = (char )'\\';
      } else
#line 2368
      if ((int )*in == 92) {
#line 2369
        tmp___0 = out;
#line 2369
        out ++;
#line 2369
        *tmp___0 = (char )'\\';
      }
    }
#line 2370
    tmp___2 = out;
#line 2370
    out ++;
#line 2370
    tmp___3 = in;
#line 2370
    in ++;
#line 2370
    *tmp___2 = *tmp___3;
  }
#line 2373
  return (out);
}
}
#line 2384 "main.c"
static char const   ref[17]  = 
#line 2384
  {      (char const   )'$',      (char const   )'(',      (char const   )'M',      (char const   )'A', 
        (char const   )'K',      (char const   )'E',      (char const   )'O',      (char const   )'V', 
        (char const   )'E',      (char const   )'R',      (char const   )'R',      (char const   )'I', 
        (char const   )'D',      (char const   )'E',      (char const   )'S',      (char const   )')', 
        (char const   )'\000'};
#line 2385 "main.c"
static char const   posixref[27]  = 
#line 2385
  {      (char const   )'$',      (char const   )'(',      (char const   )'-',      (char const   )'*', 
        (char const   )'-',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'-',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
        (char const   )'i',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )'s',      (char const   )'-',      (char const   )'*', 
        (char const   )'-',      (char const   )')',      (char const   )'\000'};
#line 2380 "main.c"
static void define_makeflags(int all , int makefile ) 
{ 
  register struct command_switch  const  *cs ;
  char *flagstring ;
  register char *p ;
  unsigned int words ;
  struct variable *v ;
  struct flag *flags ;
  unsigned int flagslen ;
  struct flag *new ;
  void *tmp ;
  size_t tmp___0 ;
  struct flag *new___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  struct flag *new___1 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char *buf___1 ;
  void *tmp___5 ;
  struct flag *new___2 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  struct flag *new___3 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char *buf___2 ;
  void *tmp___11 ;
  struct flag *new___4 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  struct stringlist *sl ;
  register unsigned int i ;
  struct flag *new___5 ;
  void *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  unsigned int tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;

  {
#line 2403
  flags = (struct flag *)0;
#line 2404
  flagslen = 0U;
#line 2421
  cs = switches;
#line 2421
  while (cs->c != 0) {
#line 2422
    if (cs->toenv) {
#line 2422
      if (! makefile) {
#line 2422
        goto _L___4;
      } else
#line 2422
      if (! cs->no_makefile) {
        _L___4: /* CIL Label */ 
#line 2423
        switch ((unsigned int const   )cs->type) {
        default: 
#line 2426
        abort();
        case 5U: 
#line 2429
        break;
        case 1U: 
        case 0U: 
#line 2433
        if (! *((int *)cs->value_ptr) == ((unsigned int const   )cs->type == 1U)) {
#line 2433
          if ((unsigned long )cs->default_value == (unsigned long )((char * const  )0)) {
#line 2433
            goto _L;
          } else
#line 2433
          if (*((int *)cs->value_ptr) != *((int *)cs->default_value)) {
            _L: /* CIL Label */ 
#line 2436
            while (1) {
#line 2436
              tmp = __builtin_alloca(sizeof(struct flag ));
#line 2436
              new = (struct flag *)tmp;
#line 2436
              new->cs = cs;
#line 2436
              new->arg = (char *)0;
#line 2436
              new->next = flags;
#line 2436
              flags = new;
#line 2436
              if ((unsigned long )new->arg == (unsigned long )((char *)0)) {
#line 2436
                flagslen ++;
              } else {
#line 2436
                flagslen += 4U;
              }
#line 2436
              if (! (cs->c <= 127)) {
#line 2436
                tmp___0 = strlen((char const   *)cs->long_name);
#line 2436
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___0));
              }
#line 2436
              break;
            }
          }
        }
#line 2437
        break;
        case 3U: 
#line 2440
        if (all) {
#line 2442
          if ((unsigned long )cs->default_value != (unsigned long )((char * const  )0)) {
#line 2442
            if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->default_value)) {
#line 2445
              break;
            } else {
#line 2442
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 2446
          if ((unsigned long )cs->noarg_value != (unsigned long )((char * const  )0)) {
#line 2446
            if (*((unsigned int *)cs->value_ptr) == *((unsigned int *)cs->noarg_value)) {
#line 2449
              while (1) {
#line 2449
                tmp___1 = __builtin_alloca(sizeof(struct flag ));
#line 2449
                new___0 = (struct flag *)tmp___1;
#line 2449
                new___0->cs = cs;
#line 2449
                new___0->arg = (char *)"";
#line 2449
                new___0->next = flags;
#line 2449
                flags = new___0;
#line 2449
                if ((unsigned long )new___0->arg == (unsigned long )((char *)0)) {
#line 2449
                  flagslen ++;
                } else {
#line 2449
                  flagslen += 4U;
                }
#line 2449
                if (! (cs->c <= 127)) {
#line 2449
                  tmp___2 = strlen((char const   *)cs->long_name);
#line 2449
                  flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___2));
                }
#line 2449
                break;
              }
            } else {
#line 2446
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 2450
          if (cs->c == 106) {
#line 2452
            while (1) {
#line 2452
              tmp___3 = __builtin_alloca(sizeof(struct flag ));
#line 2452
              new___1 = (struct flag *)tmp___3;
#line 2452
              new___1->cs = cs;
#line 2452
              new___1->arg = (char *)"1";
#line 2452
              new___1->next = flags;
#line 2452
              flags = new___1;
#line 2452
              if ((unsigned long )new___1->arg == (unsigned long )((char *)0)) {
#line 2452
                flagslen ++;
              } else {
#line 2452
                flagslen += 7U;
              }
#line 2452
              if (! (cs->c <= 127)) {
#line 2452
                tmp___4 = strlen((char const   *)cs->long_name);
#line 2452
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___4));
              }
#line 2452
              break;
            }
          } else {
#line 2455
            tmp___5 = __builtin_alloca(30UL);
#line 2455
            buf___1 = (char *)tmp___5;
#line 2456
            sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%u",
                    *((unsigned int *)cs->value_ptr));
#line 2457
            while (1) {
#line 2457
              tmp___6 = __builtin_alloca(sizeof(struct flag ));
#line 2457
              new___2 = (struct flag *)tmp___6;
#line 2457
              new___2->cs = cs;
#line 2457
              new___2->arg = buf___1;
#line 2457
              new___2->next = flags;
#line 2457
              flags = new___2;
#line 2457
              if ((unsigned long )new___2->arg == (unsigned long )((char *)0)) {
#line 2457
                flagslen ++;
              } else {
#line 2457
                tmp___7 = strlen((char const   *)buf___1);
#line 2457
                flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___7));
              }
#line 2457
              if (! (cs->c <= 127)) {
#line 2457
                tmp___8 = strlen((char const   *)cs->long_name);
#line 2457
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___8));
              }
#line 2457
              break;
            }
          }
        }
#line 2460
        break;
        case 4U: 
#line 2464
        if (all) {
#line 2466
          if ((unsigned long )cs->default_value != (unsigned long )((char * const  )0)) {
#line 2466
            if (*((double *)cs->value_ptr) == *((double *)cs->default_value)) {
#line 2469
              break;
            } else {
#line 2466
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 2470
          if ((unsigned long )cs->noarg_value != (unsigned long )((char * const  )0)) {
#line 2470
            if (*((double *)cs->value_ptr) == *((double *)cs->noarg_value)) {
#line 2473
              while (1) {
#line 2473
                tmp___9 = __builtin_alloca(sizeof(struct flag ));
#line 2473
                new___3 = (struct flag *)tmp___9;
#line 2473
                new___3->cs = cs;
#line 2473
                new___3->arg = (char *)"";
#line 2473
                new___3->next = flags;
#line 2473
                flags = new___3;
#line 2473
                if ((unsigned long )new___3->arg == (unsigned long )((char *)0)) {
#line 2473
                  flagslen ++;
                } else {
#line 2473
                  flagslen += 4U;
                }
#line 2473
                if (! (cs->c <= 127)) {
#line 2473
                  tmp___10 = strlen((char const   *)cs->long_name);
#line 2473
                  flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___10));
                }
#line 2473
                break;
              }
            } else {
#line 2470
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 2476
            tmp___11 = __builtin_alloca(100UL);
#line 2476
            buf___2 = (char *)tmp___11;
#line 2477
            sprintf((char * __restrict  )buf___2, (char const   * __restrict  )"%g",
                    *((double *)cs->value_ptr));
#line 2478
            while (1) {
#line 2478
              tmp___12 = __builtin_alloca(sizeof(struct flag ));
#line 2478
              new___4 = (struct flag *)tmp___12;
#line 2478
              new___4->cs = cs;
#line 2478
              new___4->arg = buf___2;
#line 2478
              new___4->next = flags;
#line 2478
              flags = new___4;
#line 2478
              if ((unsigned long )new___4->arg == (unsigned long )((char *)0)) {
#line 2478
                flagslen ++;
              } else {
#line 2478
                tmp___13 = strlen((char const   *)buf___2);
#line 2478
                flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___13));
              }
#line 2478
              if (! (cs->c <= 127)) {
#line 2478
                tmp___14 = strlen((char const   *)cs->long_name);
#line 2478
                flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___14));
              }
#line 2478
              break;
            }
          }
        }
#line 2481
        break;
        case 2U: 
#line 2485
        if (all) {
#line 2487
          sl = *((struct stringlist **)cs->value_ptr);
#line 2488
          if ((unsigned long )sl != (unsigned long )((struct stringlist *)0)) {
#line 2493
            i = sl->idx;
#line 2494
            while (1) {
#line 2494
              tmp___18 = i;
#line 2494
              i --;
#line 2494
              if (! (tmp___18 > 0U)) {
#line 2494
                break;
              }
#line 2495
              while (1) {
#line 2495
                tmp___15 = __builtin_alloca(sizeof(struct flag ));
#line 2495
                new___5 = (struct flag *)tmp___15;
#line 2495
                new___5->cs = cs;
#line 2495
                new___5->arg = *(sl->list + i);
#line 2495
                new___5->next = flags;
#line 2495
                flags = new___5;
#line 2495
                if ((unsigned long )new___5->arg == (unsigned long )((char *)0)) {
#line 2495
                  flagslen ++;
                } else {
#line 2495
                  tmp___16 = strlen((char const   *)*(sl->list + i));
#line 2495
                  flagslen = (unsigned int )((size_t )flagslen + (4UL + 3UL * tmp___16));
                }
#line 2495
                if (! (cs->c <= 127)) {
#line 2495
                  tmp___17 = strlen((char const   *)cs->long_name);
#line 2495
                  flagslen = (unsigned int )((size_t )flagslen + (2UL + tmp___17));
                }
#line 2495
                break;
              }
            }
          }
        }
#line 2498
        break;
        }
      }
    }
#line 2421
    cs ++;
  }
#line 2501
  flagslen = (unsigned int )((unsigned long )flagslen + (4UL + sizeof(posixref)));
#line 2507
  tmp___19 = __builtin_alloca((unsigned long )((1U + flagslen) + 1U));
#line 2507
  flagstring = (char *)tmp___19;
#line 2508
  memset((void *)flagstring, 0, (size_t )((1U + flagslen) + 1U));
#line 2509
  p = flagstring;
#line 2510
  words = 1U;
#line 2511
  tmp___20 = p;
#line 2511
  p ++;
#line 2511
  *tmp___20 = (char )'-';
#line 2512
  while ((unsigned long )flags != (unsigned long )((struct flag *)0)) {
#line 2515
    if ((flags->cs)->c <= 127) {
#line 2516
      tmp___21 = p;
#line 2516
      p ++;
#line 2516
      *tmp___21 = (char )(flags->cs)->c;
    } else {
#line 2519
      if ((int )*p != 45) {
#line 2521
        tmp___22 = p;
#line 2521
        p ++;
#line 2521
        *tmp___22 = (char )' ';
#line 2522
        tmp___23 = p;
#line 2522
        p ++;
#line 2522
        *tmp___23 = (char )'-';
      }
#line 2524
      tmp___24 = p;
#line 2524
      p ++;
#line 2524
      *tmp___24 = (char )'-';
#line 2525
      strcpy((char * __restrict  )p, (char const   * __restrict  )(flags->cs)->long_name);
#line 2526
      tmp___25 = strlen((char const   *)p);
#line 2526
      p += tmp___25;
    }
#line 2528
    if ((unsigned long )flags->arg != (unsigned long )((char *)0)) {
#line 2534
      if ((int )*(flags->arg + 0) != 0) {
#line 2537
        tmp___26 = p;
#line 2537
        p ++;
#line 2537
        if (! ((flags->cs)->c <= 127)) {
#line 2537
          *tmp___26 = (char )'=';
        } else {
#line 2537
          *tmp___26 = (char )' ';
        }
#line 2538
        p = quote_for_env(p, flags->arg);
      }
#line 2540
      words ++;
#line 2542
      tmp___27 = p;
#line 2542
      p ++;
#line 2542
      *tmp___27 = (char )' ';
#line 2543
      tmp___28 = p;
#line 2543
      p ++;
#line 2543
      *tmp___28 = (char )'-';
    } else
#line 2545
    if (! ((flags->cs)->c <= 127)) {
#line 2547
      words ++;
#line 2550
      tmp___29 = p;
#line 2550
      p ++;
#line 2550
      *tmp___29 = (char )' ';
#line 2551
      tmp___30 = p;
#line 2551
      p ++;
#line 2551
      *tmp___30 = (char )'-';
    }
#line 2553
    flags = flags->next;
  }
#line 2558
  if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
#line 2560
    *(flagstring + 0) = (char )'\000';
  } else
#line 2561
  if ((int )*(p + -1) == 45) {
#line 2564
    p -= 2;
#line 2565
    *p = (char )'\000';
  } else {
#line 2569
    *p = (char )'\000';
  }
#line 2573
  define_variable_in_set((char *)"MFLAGS", 6U, flagstring, (enum variable_origin )1,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 2575
  if (all) {
#line 2575
    if ((unsigned long )command_variables != (unsigned long )((struct command_variable *)0)) {
#line 2580
      if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
#line 2582
        p = flagstring;
      } else {
#line 2586
        if ((int )*(p + -1) != 45) {
#line 2589
          tmp___31 = p;
#line 2589
          p ++;
#line 2589
          *tmp___31 = (char )' ';
#line 2590
          tmp___32 = p;
#line 2590
          p ++;
#line 2590
          *tmp___32 = (char )'-';
        }
#line 2593
        tmp___33 = p;
#line 2593
        p ++;
#line 2593
        *tmp___33 = (char )'-';
#line 2594
        tmp___34 = p;
#line 2594
        p ++;
#line 2594
        *tmp___34 = (char )' ';
      }
#line 2598
      if (posix_pedantic) {
#line 2600
        memmove((void *)p, (void const   *)(posixref), sizeof(posixref) - 1UL);
#line 2601
        p += sizeof(posixref) - 1UL;
      } else {
#line 2605
        memmove((void *)p, (void const   *)(ref), sizeof(ref) - 1UL);
#line 2606
        p += sizeof(ref) - 1UL;
      }
    } else {
#line 2575
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 2609
  if ((unsigned long )p == (unsigned long )(flagstring + 1)) {
#line 2611
    words = 0U;
#line 2612
    p --;
  } else
#line 2614
  if ((int )*(p + -1) == 45) {
#line 2616
    p -= 2;
  }
#line 2618
  *p = (char )'\000';
#line 2620
  if ((int )*(flagstring + 0) == 45) {
#line 2620
    if ((int )*(flagstring + 1) != 45) {
#line 2620
      tmp___35 = 1;
    } else {
#line 2620
      tmp___35 = 0;
    }
  } else {
#line 2620
    tmp___35 = 0;
  }
#line 2620
  v = define_variable_in_set((char *)"MAKEFLAGS", 9U, flagstring + tmp___35, (enum variable_origin )2,
                             1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 2634
  if (! all) {
#line 2638
    v->export = (enum variable_export )0;
  }
#line 2639
  return;
}
}
#line 2646
char *make_host ;
#line 2647 "main.c"
static int printed_version  =    0;
#line 2643 "main.c"
static void print_version(void) 
{ 
  char *precede ;
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 2649
  if (print_data_base_flag) {
#line 2649
    tmp = "# ";
  } else {
#line 2649
    tmp = "";
  }
#line 2649
  precede = (char *)tmp;
#line 2651
  if (printed_version) {
#line 2653
    return;
  }
#line 2655
  printf((char const   * __restrict  )"%sGNU Make version %s", precede, version_string);
#line 2656
  if ((unsigned long )remote_description != (unsigned long )((char *)0)) {
#line 2656
    if ((int )*remote_description != 0) {
#line 2657
      printf((char const   * __restrict  )"-%s", remote_description);
    }
  }
#line 2659
  tmp___0 = dcgettext((char const   *)((void *)0), ", by Richard Stallman and Roland McGrath.\n%sBuilt for %s\n%sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n%s\tFree Software Foundation, Inc.\n%sThis is free software; see the source for copying conditions.\n%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n%sPARTICULAR PURPOSE.\n\n%sReport bugs to <bug-make@gnu.org>.\n\n",
                      5);
#line 2659
  printf((char const   * __restrict  )tmp___0, precede, make_host, precede, precede,
         precede, precede, precede, precede);
#line 2670
  printed_version = 1;
#line 2674
  fflush(stdout);
#line 2675
  return;
}
}
#line 2679 "main.c"
static void print_data_base(void) 
{ 
  time_t when ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 2684
  when = time((time_t *)0);
#line 2685
  tmp = ctime((time_t const   *)(& when));
#line 2685
  tmp___0 = dcgettext((char const   *)((void *)0), "\n# Make data base, printed on %s",
                      5);
#line 2685
  printf((char const   * __restrict  )tmp___0, tmp);
#line 2687
  print_variable_data_base();
#line 2688
  print_dir_data_base();
#line 2689
  print_rule_data_base();
#line 2690
  print_file_data_base();
#line 2691
  print_vpath_data_base();
#line 2693
  when = time((time_t *)0);
#line 2694
  tmp___1 = ctime((time_t const   *)(& when));
#line 2694
  tmp___2 = dcgettext((char const   *)((void *)0), "\n# Finished Make data base on %s\n",
                      5);
#line 2694
  printf((char const   * __restrict  )tmp___2, tmp___1);
#line 2695
  return;
}
}
#line 2703 "main.c"
static char dying  =    (char)0;
#line 2699
 __attribute__((__noreturn__)) void die(int status ) ;
#line 2699 "main.c"
void die(int status ) 
{ 
  int err ;

  {
#line 2705
  if (! dying) {
#line 2709
    dying = (char)1;
#line 2711
    if (print_version_flag) {
#line 2712
      print_version();
    }
#line 2715
    err = status != 0;
#line 2715
    while (job_slots_used > 0U) {
#line 2716
      reap_children(1, err);
#line 2715
      err = 0;
    }
#line 2719
    remote_cleanup();
#line 2722
    remove_intermediates(0);
#line 2724
    if (print_data_base_flag) {
#line 2725
      print_data_base();
    }
#line 2732
    if ((unsigned long )directory_before_chdir != (unsigned long )((char *)0)) {
#line 2733
      chdir((char const   *)directory_before_chdir);
    }
#line 2735
    log_working_directory(0);
  }
#line 2738
  exit(status);
}
}
#line 2748 "main.c"
static int entered  =    0;
#line 2744 "main.c"
void log_working_directory(int entering ) 
{ 
  char *msg ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 2749
  if (entering) {
#line 2749
    tmp = dcgettext((char const   *)((void *)0), "Entering", 5);
#line 2749
    tmp___1 = tmp;
  } else {
#line 2749
    tmp___0 = dcgettext((char const   *)((void *)0), "Leaving", 5);
#line 2749
    tmp___1 = tmp___0;
  }
#line 2749
  msg = tmp___1;
#line 2754
  if (! print_directory_flag) {
#line 2755
    return;
  } else
#line 2754
  if (entering == entered) {
#line 2755
    return;
  }
#line 2757
  entered = entering;
#line 2759
  if (print_data_base_flag) {
#line 2760
    fputs((char const   * __restrict  )"# ", (FILE * __restrict  )stdout);
  }
#line 2762
  if (makelevel == 0U) {
#line 2763
    printf((char const   * __restrict  )"%s: %s ", program, msg);
  } else {
#line 2765
    printf((char const   * __restrict  )"%s[%u]: %s ", program, makelevel, msg);
  }
#line 2767
  if ((unsigned long )starting_directory == (unsigned long )((char *)0)) {
#line 2768
    tmp___2 = dcgettext((char const   *)((void *)0), "an unknown directory", 5);
#line 2768
    puts((char const   *)tmp___2);
  } else {
#line 2770
    tmp___3 = dcgettext((char const   *)((void *)0), "directory `%s\'\n", 5);
#line 2770
    printf((char const   * __restrict  )tmp___3, starting_directory);
  }
#line 2771
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 1 "misc.o"
#pragma merger("0","/tmp/cil-WVSTX0Wp.i","-g,-O0")
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 327 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 687
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 703
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 713
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 720
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 730
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int errnum ) ;
#line 401 "make.h"
void collapse_continuations(char *line ) ;
#line 402
void remove_comments(char *line ) ;
#line 408
char *find_char_unquote(char *string , char *stopchars , int blank ) ;
#line 73 "dep.h"
struct dep *copy_dep_chain(struct dep *d ) ;
#line 60 "misc.c"
int alpha_compare(void const   *v1 , void const   *v2 ) 
{ 
  char const   *s1 ;
  char const   *s2 ;
  int tmp ;

  {
#line 64
  s1 = (char const   *)*((char **)v1);
#line 65
  s2 = (char const   *)*((char **)v2);
#line 67
  if ((int const   )*s1 != (int const   )*s2) {
#line 68
    return ((int )((int const   )*s1 - (int const   )*s2));
  }
#line 69
  tmp = strcmp(s1, s2);
#line 69
  return (tmp);
}
}
#line 76 "misc.c"
void collapse_continuations(char *line ) 
{ 
  register char *in ;
  register char *out ;
  register char *p ;
  register int backslash ;
  register unsigned int bs_write ;
  char *tmp ;
  unsigned int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 84
  in = strchr((char const   *)line, '\n');
#line 85
  if ((unsigned long )in == (unsigned long )((char *)0)) {
#line 86
    return;
  }
#line 88
  out = in;
#line 89
  while (1) {
#line 89
    if ((unsigned long )out > (unsigned long )line) {
#line 89
      if (! ((int )*(out + -1) == 92)) {
#line 89
        break;
      }
    } else {
#line 89
      break;
    }
#line 90
    out --;
  }
#line 92
  while ((int )*in != 0) {
#line 97
    backslash = 0;
#line 98
    bs_write = 0U;
#line 99
    p = in - 1;
#line 99
    while (1) {
#line 99
      if ((unsigned long )p >= (unsigned long )line) {
#line 99
        if (! ((int )*p == 92)) {
#line 99
          break;
        }
      } else {
#line 99
        break;
      }
#line 101
      if (backslash) {
#line 102
        bs_write ++;
      }
#line 103
      backslash = ! backslash;
#line 107
      if ((unsigned long )in == (unsigned long )(out - 1)) {
#line 108
        abort();
      }
#line 99
      p --;
    }
#line 112
    while (1) {
#line 112
      tmp___0 = bs_write;
#line 112
      bs_write --;
#line 112
      if (! (tmp___0 > 0U)) {
#line 112
        break;
      }
#line 113
      tmp = out;
#line 113
      out ++;
#line 113
      *tmp = (char )'\\';
    }
#line 116
    in ++;
#line 120
    if (backslash) {
#line 122
      in = next_token(in);
#line 123
      while (1) {
#line 123
        if ((unsigned long )out > (unsigned long )line) {
#line 123
          tmp___1 = __ctype_b_loc();
#line 123
          if (! ((int const   )*(*tmp___1 + (int )*(out + -1)) & 1)) {
#line 123
            break;
          }
        } else {
#line 123
          break;
        }
#line 124
        out --;
      }
#line 125
      tmp___2 = out;
#line 125
      out ++;
#line 125
      *tmp___2 = (char )' ';
    } else {
#line 129
      tmp___3 = out;
#line 129
      out ++;
#line 129
      *tmp___3 = (char )'\n';
    }
#line 133
    while ((int )*in != 0) {
#line 134
      if ((int )*in == 92) {
#line 136
        p = in + 1;
#line 137
        while ((int )*p == 92) {
#line 138
          p ++;
        }
#line 139
        if ((int )*p == 10) {
#line 141
          in = p;
#line 142
          break;
        }
#line 144
        while ((unsigned long )in < (unsigned long )p) {
#line 145
          tmp___4 = out;
#line 145
          out ++;
#line 145
          tmp___5 = in;
#line 145
          in ++;
#line 145
          *tmp___4 = *tmp___5;
        }
      } else {
#line 148
        tmp___6 = out;
#line 148
        out ++;
#line 148
        tmp___7 = in;
#line 148
        in ++;
#line 148
        *tmp___6 = *tmp___7;
      }
    }
  }
#line 151
  *out = (char )'\000';
#line 152
  return;
}
}
#line 158 "misc.c"
void remove_comments(char *line ) 
{ 
  char *comment ;

  {
#line 164
  comment = find_char_unquote(line, (char *)"#", 0);
#line 166
  if ((unsigned long )comment != (unsigned long )((char *)0)) {
#line 168
    *comment = (char )'\000';
  }
#line 169
  return;
}
}
#line 173 "misc.c"
void print_spaces(unsigned int n ) 
{ 
  unsigned int tmp ;

  {
#line 177
  while (1) {
#line 177
    tmp = n;
#line 177
    n --;
#line 177
    if (! (tmp > 0U)) {
#line 177
      break;
    }
#line 178
    putchar(' ');
  }
#line 179
  return;
}
}
#line 185 "misc.c"
char *concat(char *s1 , char *s2 , char *s3 ) 
{ 
  register unsigned int len1 ;
  register unsigned int len2 ;
  register unsigned int len3 ;
  register char *result___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 192
  if ((int )*s1 != 0) {
#line 192
    tmp = strlen((char const   *)s1);
#line 192
    len1 = (unsigned int )tmp;
  } else {
#line 192
    len1 = 0U;
  }
#line 193
  if ((int )*s2 != 0) {
#line 193
    tmp___0 = strlen((char const   *)s2);
#line 193
    len2 = (unsigned int )tmp___0;
  } else {
#line 193
    len2 = 0U;
  }
#line 194
  if ((int )*s3 != 0) {
#line 194
    tmp___1 = strlen((char const   *)s3);
#line 194
    len3 = (unsigned int )tmp___1;
  } else {
#line 194
    len3 = 0U;
  }
#line 196
  tmp___2 = xmalloc(((len1 + len2) + len3) + 1U);
#line 196
  result___0 = tmp___2;
#line 198
  if ((int )*s1 != 0) {
#line 199
    memmove((void *)result___0, (void const   *)s1, (size_t )len1);
  }
#line 200
  if ((int )*s2 != 0) {
#line 201
    memmove((void *)(result___0 + len1), (void const   *)s2, (size_t )len2);
  }
#line 202
  if ((int )*s3 != 0) {
#line 203
    memmove((void *)((result___0 + len1) + len2), (void const   *)s3, (size_t )len3);
  }
#line 204
  *(((result___0 + len1) + len2) + len3) = (char )'\000';
#line 206
  return (result___0);
}
}
#line 211 "misc.c"
void ( /* format attribute */  message)(int prefix , char const   *fmt  , ...) 
{ 
  va_list args ;

  {
#line 225
  log_working_directory(1);
#line 227
  if ((unsigned long )fmt != (unsigned long )((char const   *)0)) {
#line 229
    if (prefix) {
#line 231
      if (makelevel == 0U) {
#line 232
        printf((char const   * __restrict  )"%s: ", program);
      } else {
#line 234
        printf((char const   * __restrict  )"%s[%u]: ", program, makelevel);
      }
    }
#line 236
    __builtin_va_start(args, fmt);
#line 237
    vfprintf((FILE * __restrict  )stdout, (char const   * __restrict  )fmt, args);
#line 238
    __builtin_va_end(args);
#line 239
    putchar('\n');
  }
#line 242
  fflush(stdout);
#line 243
  return;
}
}
#line 247 "misc.c"
void ( /* format attribute */  error)(struct floc  const  *flocp , char const   *fmt 
                                      , ...) 
{ 
  va_list args ;

  {
#line 261
  log_working_directory(1);
#line 263
  if (flocp) {
#line 263
    if (flocp->filenm) {
#line 264
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%lu: ",
              flocp->filenm, flocp->lineno);
    } else {
#line 263
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 265
  if (makelevel == 0U) {
#line 266
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", program);
  } else {
#line 268
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s[%u]: ",
            program, makelevel);
  }
#line 270
  __builtin_va_start(args, fmt);
#line 271
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
#line 272
  __builtin_va_end(args);
#line 274
  _IO_putc('\n', stderr);
#line 275
  fflush(stderr);
#line 276
  return;
}
}
#line 280
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(struct floc  const  *flocp ,
                                                                     char const   *fmt 
                                                                     , ...) ;
#line 280 "misc.c"
void ( /* format attribute */  fatal)(struct floc  const  *flocp , char const   *fmt 
                                      , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
#line 294
  log_working_directory(1);
#line 296
  if (flocp) {
#line 296
    if (flocp->filenm) {
#line 297
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%lu: *** ",
              flocp->filenm, flocp->lineno);
    } else {
#line 296
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 298
  if (makelevel == 0U) {
#line 299
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: *** ",
            program);
  } else {
#line 301
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s[%u]: *** ",
            program, makelevel);
  }
#line 303
  __builtin_va_start(args, fmt);
#line 304
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
#line 305
  __builtin_va_end(args);
#line 307
  tmp = dcgettext((char const   *)((void *)0), ".  Stop.\n", 5);
#line 307
  fputs((char const   * __restrict  )tmp, (FILE * __restrict  )stderr);
#line 309
  die(2);
}
}
#line 336 "misc.c"
void perror_with_name(char *str , char *name ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 340
  tmp = __errno_location();
#line 340
  tmp___0 = strerror(*tmp);
#line 340
  error((struct floc  const  *)((struct floc *)0), "%s%s: %s", str, name, tmp___0);
#line 341
  return;
}
}
#line 345
 __attribute__((__noreturn__)) void pfatal_with_name(char *name ) ;
#line 345 "misc.c"
void pfatal_with_name(char *name ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 349
  tmp = __errno_location();
#line 349
  tmp___0 = strerror(*tmp);
#line 349
  fatal((struct floc  const  *)((struct floc *)0), "%s: %s", name, tmp___0);
}
}
#line 363 "misc.c"
char *xmalloc(unsigned int size ) 
{ 
  char *result___0 ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 367
  tmp = malloc((size_t )size);
#line 367
  result___0 = (char *)tmp;
#line 368
  if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
#line 369
    tmp___0 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
#line 369
    fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___0);
  }
#line 370
  return (result___0);
}
}
#line 374 "misc.c"
char *xrealloc(char *ptr , unsigned int size ) 
{ 
  char *result___0 ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 382
  if (ptr) {
#line 382
    tmp = realloc((void *)ptr, (size_t )size);
#line 382
    result___0 = (char *)tmp;
  } else {
#line 382
    tmp___0 = malloc((size_t )size);
#line 382
    result___0 = (char *)tmp___0;
  }
#line 383
  if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
#line 384
    tmp___1 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
#line 384
    fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1);
  }
#line 385
  return (result___0);
}
}
#line 389 "misc.c"
char *xstrdup(char const   *ptr ) 
{ 
  char *result___0 ;
  char *tmp ;

  {
#line 396
  result___0 = strdup(ptr);
#line 401
  if ((unsigned long )result___0 == (unsigned long )((char *)0)) {
#line 402
    tmp = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
#line 402
    fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp);
  }
#line 405
  return (result___0);
}
}
#line 413 "misc.c"
char *savestring(char const   *str , unsigned int length___0 ) 
{ 
  register char *out ;
  char *tmp ;

  {
#line 418
  tmp = xmalloc(length___0 + 1U);
#line 418
  out = tmp;
#line 419
  if (length___0 > 0U) {
#line 420
    memmove((void *)out, (void const   *)str, (size_t )length___0);
  }
#line 421
  *(out + length___0) = (char )'\000';
#line 422
  return (out);
}
}
#line 429 "misc.c"
char *sindex(char const   *big , unsigned int blen , char const   *small , unsigned int slen ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  register unsigned int b ;
  int tmp___1 ;

  {
#line 436
  if (! blen) {
#line 437
    tmp = strlen(big);
#line 437
    blen = (unsigned int )tmp;
  }
#line 438
  if (! slen) {
#line 439
    tmp___0 = strlen(small);
#line 439
    slen = (unsigned int )tmp___0;
  }
#line 441
  if (slen) {
#line 441
    if (blen >= slen) {
#line 446
      slen --;
#line 447
      blen -= slen;
#line 449
      b = 0U;
#line 449
      while (b < blen) {
#line 450
        if ((int const   )*big == (int const   )*small) {
#line 450
          tmp___1 = strncmp(big + 1, small + 1, (size_t )slen);
#line 450
          if (tmp___1 == 0) {
#line 451
            return ((char *)big);
          }
        }
#line 449
        b ++;
#line 449
        big ++;
      }
    }
  }
#line 454
  return ((char *)0);
}
}
#line 463 "misc.c"
char *lindex(char const   *s , char const   *limit , int c ) 
{ 
  char const   *tmp ;

  {
#line 468
  while ((unsigned long )s < (unsigned long )limit) {
#line 469
    tmp = s;
#line 469
    s ++;
#line 469
    if ((int const   )*tmp == (int const   )c) {
#line 470
      return ((char *)(s - 1));
    }
  }
#line 472
  return ((char *)0);
}
}
#line 477 "misc.c"
char *end_of_token(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
#line 481
  while (1) {
#line 481
    if ((int )*s != 0) {
#line 481
      tmp = __ctype_b_loc();
#line 481
      if ((int const   )*(*tmp + (int )*s) & 1) {
#line 481
        break;
      }
    } else {
#line 481
      break;
    }
#line 482
    s ++;
  }
#line 483
  return (s);
}
}
#line 519 "misc.c"
char *next_token(char *s ) 
{ 
  register char *p ;
  unsigned short const   **tmp ;

  {
#line 523
  p = s;
#line 525
  while (1) {
#line 525
    tmp = __ctype_b_loc();
#line 525
    if (! ((int const   )*(*tmp + (int )*p) & 1)) {
#line 525
      break;
    }
#line 526
    p ++;
  }
#line 527
  return (p);
}
}
#line 533 "misc.c"
char *find_next_token(char **ptr , unsigned int *lengthptr ) 
{ 
  char *p ;
  char *tmp ;
  char *end ;

  {
#line 538
  tmp = next_token(*ptr);
#line 538
  p = tmp;
#line 541
  if ((int )*p == 0) {
#line 542
    return ((char *)0);
  }
#line 544
  end = end_of_token(p);
#line 544
  *ptr = end;
#line 545
  if ((unsigned long )lengthptr != (unsigned long )((unsigned int *)0)) {
#line 546
    *lengthptr = (unsigned int )(end - p);
  }
#line 547
  return (p);
}
}
#line 553 "misc.c"
struct dep *copy_dep_chain(struct dep *d ) 
{ 
  register struct dep *c ;
  struct dep *firstnew ;
  struct dep *lastnew ;
  char *tmp ;
  struct dep *tmp___0 ;

  {
#line 558
  firstnew = (struct dep *)0;
#line 559
  lastnew = (struct dep *)0;
#line 561
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 563
    tmp = xmalloc((unsigned int )sizeof(struct dep ));
#line 563
    c = (struct dep *)tmp;
#line 564
    memmove((void *)((char *)c), (void const   *)((char *)d), sizeof(struct dep ));
#line 565
    if ((unsigned long )c->name != (unsigned long )((char *)0)) {
#line 566
      c->name = xstrdup((char const   *)c->name);
    }
#line 567
    c->next = (struct dep *)0;
#line 568
    if ((unsigned long )firstnew == (unsigned long )((struct dep *)0)) {
#line 569
      lastnew = c;
#line 569
      firstnew = lastnew;
    } else {
#line 571
      tmp___0 = c;
#line 571
      lastnew->next = tmp___0;
#line 571
      lastnew = tmp___0;
    }
#line 573
    d = d->next;
  }
#line 576
  return (firstnew);
}
}
#line 635 "misc.c"
static int user_uid  =    -1;
#line 635 "misc.c"
static int user_gid  =    -1;
#line 635 "misc.c"
static int make_uid  =    -1;
#line 635 "misc.c"
static int make_gid  =    -1;
#line 637 "misc.c"
static enum __anonenum_current_access_55 current_access  ;
#line 642 "misc.c"
static void log_access(char *flavor ) 
{ 
  __gid_t tmp ;
  __gid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  char *tmp___3 ;

  {
#line 646
  if (! (4 & db_level)) {
#line 647
    return;
  }
#line 653
  tmp = getgid();
#line 653
  tmp___0 = getegid();
#line 653
  tmp___1 = getuid();
#line 653
  tmp___2 = geteuid();
#line 653
  tmp___3 = dcgettext((char const   *)((void *)0), "%s access: user %lu (real %lu), group %lu (real %lu)\n",
                      5);
#line 653
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___3, flavor,
          (unsigned long )tmp___2, (unsigned long )tmp___1, (unsigned long )tmp___0,
          (unsigned long )tmp);
#line 656
  fflush(stderr);
#line 657
  return;
}
}
#line 660 "misc.c"
static void init_access(void) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;
  __uid_t tmp___1 ;
  __gid_t tmp___2 ;
  char *tmp___3 ;

  {
#line 664
  tmp = getuid();
#line 664
  user_uid = (int )tmp;
#line 665
  tmp___0 = getgid();
#line 665
  user_gid = (int )tmp___0;
#line 667
  tmp___1 = geteuid();
#line 667
  make_uid = (int )tmp___1;
#line 668
  tmp___2 = getegid();
#line 668
  make_gid = (int )tmp___2;
#line 671
  if (user_uid == -1) {
#line 672
    pfatal_with_name((char *)"get{e}[gu]id");
  } else
#line 671
  if (user_gid == -1) {
#line 672
    pfatal_with_name((char *)"get{e}[gu]id");
  } else
#line 671
  if (make_uid == -1) {
#line 672
    pfatal_with_name((char *)"get{e}[gu]id");
  } else
#line 671
  if (make_gid == -1) {
#line 672
    pfatal_with_name((char *)"get{e}[gu]id");
  }
#line 674
  tmp___3 = dcgettext((char const   *)((void *)0), "Initialized", 5);
#line 674
  log_access(tmp___3);
#line 676
  current_access = (enum __anonenum_current_access_55 )0;
#line 678
  return;
}
}
#line 684 "misc.c"
void user_access(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 689
  if (! (user_uid != -1)) {
#line 690
    init_access();
  }
#line 692
  if ((unsigned int )current_access == 1U) {
#line 693
    return;
  }
#line 705
  tmp = seteuid((__uid_t )user_uid);
#line 705
  if (tmp < 0) {
#line 706
    pfatal_with_name((char *)"user_access: seteuid");
  }
#line 739
  tmp___0 = setegid((__gid_t )user_gid);
#line 739
  if (tmp___0 < 0) {
#line 740
    pfatal_with_name((char *)"user_access: setegid");
  }
#line 751
  current_access = (enum __anonenum_current_access_55 )1;
#line 753
  log_access((char *)"User");
#line 756
  return;
}
}
#line 760 "misc.c"
void make_access(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 765
  if (! (user_uid != -1)) {
#line 766
    init_access();
  }
#line 768
  if ((unsigned int )current_access == 0U) {
#line 769
    return;
  }
#line 774
  tmp = seteuid((__uid_t )make_uid);
#line 774
  if (tmp < 0) {
#line 775
    pfatal_with_name((char *)"make_access: seteuid");
  }
#line 787
  tmp___0 = setegid((__gid_t )make_gid);
#line 787
  if (tmp___0 < 0) {
#line 788
    pfatal_with_name((char *)"make_access: setegid");
  }
#line 799
  current_access = (enum __anonenum_current_access_55 )0;
#line 801
  log_access((char *)"Make");
#line 804
  return;
}
}
#line 808 "misc.c"
void child_access(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 813
  if (! (user_uid != -1)) {
#line 814
    abort();
  }
#line 820
  tmp = setuid((__uid_t )user_uid);
#line 820
  if (tmp < 0) {
#line 821
    pfatal_with_name((char *)"child_access: setuid");
  }
#line 828
  tmp___0 = setgid((__gid_t )user_gid);
#line 828
  if (tmp___0 < 0) {
#line 829
    pfatal_with_name((char *)"child_access: setgid");
  }
#line 835
  log_access((char *)"Child");
#line 838
  return;
}
}
#line 1 "read.o"
#pragma merger("0","/tmp/cil-zjn5zLsB.i","-g,-O0")
#line 232 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 851 "/usr/include/unistd.h"
extern char *getlogin(void) ;
#line 431 "make.h"
void construct_vpath_list(char *pattern , char *dirpath ) ;
#line 466 "make.h"
struct floc  const  *reading_file  ;
#line 177 "./glob/glob.h"
extern int glob(char const   *__pattern , int __flags , int (*__errfunc)(char const   * ,
                                                                         int  ) ,
                glob_t *__pglob ) ;
#line 182
extern void globfree(glob_t *__pglob ) ;
#line 105 "filedef.h"
struct file *suffix_file ;
#line 64 "rule.h"
struct pattern_var *create_pattern_var(char *target , char *suffix ) ;
#line 68
void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                         struct dep *deps , struct commands *commands , int override ) ;
#line 115 "/usr/include/pwd.h"
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
#line 86 "read.c"
static struct conditionals toplevel_conditionals  ;
#line 87 "read.c"
static struct conditionals *conditionals  =    & toplevel_conditionals;
#line 92 "read.c"
static char *default_include_directories[5]  = {      (char *)"/usr/local/include",      (char *)"/usr/gnu/include",      (char *)"/usr/local/include",      (char *)"/usr/include", 
        (char *)0};
#line 112 "read.c"
static char **include_directories___0  ;
#line 116 "read.c"
static unsigned int max_incl_len  ;
#line 125 "read.c"
static struct dep *read_makefiles  =    (struct dep *)0;
#line 127
static int read_makefile(char *filename , int flags ) ;
#line 128
static unsigned long readline(struct linebuffer *linebuffer , FILE *stream , struct floc  const  *flocp ) ;
#line 130
static void do_define(char *name , unsigned int namelen , enum variable_origin origin ,
                      FILE *infile , struct floc *flocp ) ;
#line 133
static int conditional_line(char *line , struct floc  const  *flocp ) ;
#line 134
static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                         struct dep *deps , unsigned int cmds_started , char *commands ,
                         unsigned int commands_idx , int two_colon , struct floc  const  *flocp ,
                         int set_default ) ;
#line 138
static void record_target_var(struct nameseq *filenames , char *defn , int two_colon ,
                              enum variable_origin origin , struct floc  const  *flocp ) ;
#line 142
static enum make_word_type get_next_mword(char *buffer , char *delim , char **startp ,
                                          unsigned int *length___0 ) ;
#line 217 "read.c"
static char *default_makefiles[4]  = {      (char *)"GNUmakefile",      (char *)"makefile",      (char *)"Makefile",      (char *)0};
#line 147 "read.c"
struct dep *read_all_makefiles(char **makefiles___0 ) 
{ 
  unsigned int num_makefiles ;
  char *tmp ;
  char *value ;
  char *name ;
  char *p ;
  unsigned int length___0 ;
  int save ;
  char *tmp___0 ;
  int tmp___1 ;
  struct dep *tail ;
  register struct dep *d ;
  int tmp___2 ;
  register char **p___0 ;
  int tmp___3 ;
  int tmp___4 ;
  struct dep *tail___0 ;
  struct dep *d___0 ;
  char *tmp___5 ;

  {
#line 151
  num_makefiles = 0U;
#line 153
  while (1) {
#line 153
    if (1 & db_level) {
#line 153
      tmp = dcgettext((char const   *)((void *)0), "Reading makefiles...\n", 5);
#line 153
      printf((char const   * __restrict  )tmp);
#line 153
      fflush(stdout);
    }
#line 153
    break;
  }
#line 166
  save = warn_undefined_variables_flag;
#line 167
  warn_undefined_variables_flag = 0;
#line 169
  value = allocated_variable_expand_for_file((char *)"$(MAKEFILES)", (struct file *)0);
#line 171
  warn_undefined_variables_flag = save;
#line 176
  p = value;
#line 178
  while (1) {
#line 178
    name = find_next_token(& p, & length___0);
#line 178
    if (! ((unsigned long )name != (unsigned long )((char *)0))) {
#line 178
      break;
    }
#line 180
    if ((int )*p != 0) {
#line 181
      tmp___0 = p;
#line 181
      p ++;
#line 181
      *tmp___0 = (char )'\000';
    }
#line 182
    name = xstrdup((char const   *)name);
#line 183
    tmp___1 = read_makefile(name, (1 | (1 << 1)) | (1 << 2));
#line 183
    if (tmp___1 < 2) {
#line 185
      free((void *)name);
    }
  }
#line 188
  free((void *)value);
#line 193
  if ((unsigned long )makefiles___0 != (unsigned long )((char **)0)) {
#line 194
    while ((unsigned long )*makefiles___0 != (unsigned long )((char *)0)) {
#line 196
      tail = read_makefiles;
#line 199
      tmp___2 = read_makefile(*makefiles___0, 0);
#line 199
      if (! tmp___2) {
#line 200
        perror_with_name((char *)"", *makefiles___0);
      }
#line 203
      d = read_makefiles;
#line 204
      while ((unsigned long )d->next != (unsigned long )tail) {
#line 205
        d = d->next;
      }
#line 208
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 208
        *makefiles___0 = (d->file)->name;
      } else {
#line 208
        *makefiles___0 = d->name;
      }
#line 209
      num_makefiles ++;
#line 210
      makefiles___0 ++;
    }
  }
#line 215
  if (num_makefiles == 0U) {
#line 228
    p___0 = default_makefiles;
#line 229
    while (1) {
#line 229
      if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
#line 229
        tmp___3 = file_exists_p(*p___0);
#line 229
        if (tmp___3) {
#line 229
          break;
        }
      } else {
#line 229
        break;
      }
#line 230
      p___0 ++;
    }
#line 232
    if ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
#line 234
      tmp___4 = read_makefile(*p___0, 0);
#line 234
      if (! tmp___4) {
#line 235
        perror_with_name((char *)"", *p___0);
      }
    } else {
#line 241
      tail___0 = read_makefiles;
#line 243
      while (1) {
#line 243
        if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
#line 243
          if (! ((unsigned long )tail___0->next != (unsigned long )((struct dep *)0))) {
#line 243
            break;
          }
        } else {
#line 243
          break;
        }
#line 244
        tail___0 = tail___0->next;
      }
#line 245
      p___0 = default_makefiles;
#line 245
      while ((unsigned long )*p___0 != (unsigned long )((char *)0)) {
#line 247
        tmp___5 = xmalloc((unsigned int )sizeof(struct dep ));
#line 247
        d___0 = (struct dep *)tmp___5;
#line 248
        d___0->name = (char *)0;
#line 249
        d___0->file = enter_file(*p___0);
#line 250
        (d___0->file)->dontcare = 1U;
#line 253
        d___0->changed = 1 << 2;
#line 254
        if ((unsigned long )tail___0 == (unsigned long )((struct dep *)0)) {
#line 255
          read_makefiles = d___0;
        } else {
#line 257
          tail___0->next = d___0;
        }
#line 258
        tail___0 = d___0;
#line 245
        p___0 ++;
      }
#line 260
      if ((unsigned long )tail___0 != (unsigned long )((struct dep *)0)) {
#line 261
        tail___0->next = (struct dep *)0;
      }
    }
  }
#line 265
  return (read_makefiles);
}
}
#line 283 "read.c"
static char *collapsed  =    (char *)0;
#line 284 "read.c"
static unsigned int collapsed_length  =    0U;
#line 278 "read.c"
static int read_makefile(char *filename , int flags ) 
{ 
  register FILE *infile ;
  struct linebuffer lb ;
  unsigned int commands_len ;
  char *commands ;
  unsigned int commands_idx ;
  unsigned int cmds_started ;
  unsigned int tgts_started ;
  char *p ;
  char *p2 ;
  int len ;
  int reading_target ;
  int ignoring ;
  int in_ignored_define ;
  int no_targets ;
  int using_filename ;
  struct floc fileinfo ;
  char *passed_filename ;
  struct nameseq *filenames ;
  struct dep *deps ;
  unsigned int nlines ;
  int two_colon ;
  char *pattern ;
  char *pattern_percent ;
  int makefile_errno ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *expanded ;
  char *tmp___4 ;
  int *tmp___5 ;
  register unsigned int i ;
  char *name ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  unsigned int len___0 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  int i___0 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  unsigned short const   **tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned short const   **tmp___34 ;
  char *tmp___35 ;
  struct variable *tmp___36 ;
  int tmp___37 ;
  unsigned short const   **tmp___38 ;
  int tmp___39 ;
  struct variable *v ;
  unsigned int len___1 ;
  unsigned int len___2 ;
  struct variable *v___0 ;
  char *pattern___0 ;
  unsigned int len___3 ;
  struct conditionals *save ;
  struct conditionals new_conditionals ;
  struct nameseq *files___0 ;
  int noerror ;
  int tmp___40 ;
  char *tmp___41 ;
  char const   *tmp___42 ;
  char *tmp___43 ;
  struct nameseq *tmp___44 ;
  struct floc fi ;
  struct nameseq *next ;
  char *name___0 ;
  int r ;
  int tmp___45 ;
  int *tmp___46 ;
  char *tmp___47 ;
  unsigned short const   **tmp___48 ;
  char *tmp___49 ;
  enum make_word_type wtype ;
  enum variable_origin v_origin ;
  char *cmdleft ;
  char *lb_next ;
  unsigned int len___4 ;
  unsigned int plen ;
  char *colonp ;
  struct floc fi___0 ;
  char *tmp___50 ;
  char *tmp___51 ;
  unsigned long p2_off ;
  unsigned long cmd_off ;
  char *pend ;
  size_t tmp___52 ;
  size_t tmp___53 ;
  size_t tmp___54 ;
  char *tmp___55 ;
  char *tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char *tmp___60 ;
  struct nameseq *tmp___61 ;
  unsigned int l ;
  size_t tmp___63 ;
  size_t tmp___64 ;
  int tmp___65 ;
  unsigned int l___0 ;
  char *tmp___66 ;
  register char *q ;
  register int backslash ;
  char *tmp___67 ;
  struct nameseq *target ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  struct nameseq *tmp___71 ;
  struct nameseq *tmp___72 ;
  unsigned int len___5 ;
  size_t tmp___73 ;
  char *tmp___74 ;
  unsigned int tmp___75 ;
  struct variable *tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  struct floc fi___1 ;
  int tmp___83 ;
  char *tmp___84 ;
  struct floc fi___2 ;

  {
#line 287
  commands_len = 200U;
#line 289
  commands_idx = 0U;
#line 294
  ignoring = 0;
#line 294
  in_ignored_define = 0;
#line 295
  no_targets = 0;
#line 296
  using_filename = 0;
#line 298
  passed_filename = filename;
#line 300
  filenames = (struct nameseq *)0;
#line 302
  nlines = 0U;
#line 303
  two_colon = 0;
#line 304
  pattern = (char *)0;
#line 329
  fileinfo.filenm = filename;
#line 330
  fileinfo.lineno = 1UL;
#line 332
  pattern_percent = (char *)0;
#line 333
  tgts_started = (unsigned int )fileinfo.lineno;
#line 333
  cmds_started = tgts_started;
#line 335
  if (2 & db_level) {
#line 337
    tmp = dcgettext((char const   *)((void *)0), "Reading makefile `%s\'", 5);
#line 337
    printf((char const   * __restrict  )tmp, fileinfo.filenm);
#line 338
    if (flags & 1) {
#line 339
      tmp___0 = dcgettext((char const   *)((void *)0), " (no default goal)", 5);
#line 339
      printf((char const   * __restrict  )tmp___0);
    }
#line 340
    if (flags & (1 << 1)) {
#line 341
      tmp___1 = dcgettext((char const   *)((void *)0), " (search path)", 5);
#line 341
      printf((char const   * __restrict  )tmp___1);
    }
#line 342
    if (flags & (1 << 2)) {
#line 343
      tmp___2 = dcgettext((char const   *)((void *)0), " (don\'t care)", 5);
#line 343
      printf((char const   * __restrict  )tmp___2);
    }
#line 344
    if (flags & (1 << 3)) {
#line 345
      tmp___3 = dcgettext((char const   *)((void *)0), " (no ~ expansion)", 5);
#line 345
      printf((char const   * __restrict  )tmp___3);
    }
#line 346
    puts("...");
  }
#line 353
  if (! (flags & (1 << 3))) {
#line 353
    if ((int )*(filename + 0) == 126) {
#line 355
      tmp___4 = tilde_expand(filename);
#line 355
      expanded = tmp___4;
#line 356
      if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 357
        filename = expanded;
      }
    }
  }
#line 360
  infile = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 362
  tmp___5 = __errno_location();
#line 362
  makefile_errno = *tmp___5;
#line 367
  if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
#line 367
    if (flags & (1 << 1)) {
#line 367
      if ((int )*filename != 47) {
#line 370
        i = 0U;
#line 370
        while ((unsigned long )*(include_directories___0 + i) != (unsigned long )((char *)0)) {
#line 372
          tmp___6 = concat(*(include_directories___0 + i), (char *)"/", filename);
#line 372
          name = tmp___6;
#line 373
          infile = fopen((char const   * __restrict  )name, (char const   * __restrict  )"r");
#line 374
          if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
#line 375
            free((void *)name);
          } else {
#line 378
            filename = name;
#line 379
            break;
          }
#line 370
          i ++;
        }
      }
    }
  }
#line 385
  tmp___7 = xmalloc((unsigned int )sizeof(struct dep ));
#line 385
  deps = (struct dep *)tmp___7;
#line 386
  deps->next = read_makefiles;
#line 387
  read_makefiles = deps;
#line 388
  deps->name = (char *)0;
#line 389
  deps->file = lookup_file(filename);
#line 390
  if ((unsigned long )deps->file == (unsigned long )((struct file *)0)) {
#line 392
    tmp___8 = xstrdup((char const   *)filename);
#line 392
    deps->file = enter_file(tmp___8);
#line 393
    if (flags & (1 << 2)) {
#line 394
      (deps->file)->dontcare = 1U;
    }
  }
#line 396
  if ((unsigned long )filename != (unsigned long )passed_filename) {
#line 397
    free((void *)filename);
  }
#line 398
  filename = (deps->file)->name;
#line 399
  deps->changed = flags;
#line 400
  deps = (struct dep *)0;
#line 404
  if ((unsigned long )infile == (unsigned long )((FILE *)0)) {
#line 409
    tmp___9 = __errno_location();
#line 409
    *tmp___9 = makefile_errno;
#line 410
    return (0);
  }
#line 413
  reading_file = (struct floc  const  *)(& fileinfo);
#line 420
  lb.size = 200U;
#line 420
  tmp___10 = xmalloc(lb.size);
#line 420
  lb.buffer = tmp___10;
#line 421
  commands = xmalloc(200U);
#line 423
  while (1) {
#line 423
    tmp___83 = feof(infile);
#line 423
    if (tmp___83) {
#line 423
      break;
    }
#line 425
    fileinfo.lineno += (unsigned long )nlines;
#line 426
    tmp___11 = readline(& lb, infile, (struct floc  const  *)(& fileinfo));
#line 426
    nlines = (unsigned int )tmp___11;
#line 430
    if ((int )*(lb.buffer + 0) == 9) {
#line 435
      if (no_targets) {
#line 437
        continue;
      }
#line 443
      if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 445
        if (ignoring) {
#line 447
          continue;
        }
#line 450
        p = lb.buffer;
#line 451
        if (commands_idx == 0U) {
#line 452
          cmds_started = (unsigned int )fileinfo.lineno;
        }
#line 453
        tmp___12 = strlen((char const   *)p);
#line 453
        len___0 = (unsigned int )tmp___12;
#line 454
        if ((len___0 + 1U) + commands_idx > commands_len) {
#line 456
          commands_len = ((len___0 + 1U) + commands_idx) * 2U;
#line 457
          tmp___13 = xrealloc(commands, commands_len);
#line 457
          commands = tmp___13;
        }
#line 459
        memmove((void *)(commands + commands_idx), (void const   *)p, (size_t )len___0);
#line 460
        commands_idx += len___0;
#line 461
        tmp___14 = commands_idx;
#line 461
        commands_idx ++;
#line 461
        *(commands + tmp___14) = (char )'\n';
#line 463
        continue;
      }
    }
#line 469
    if (collapsed_length < lb.size) {
#line 471
      collapsed_length = lb.size;
#line 472
      if ((unsigned long )collapsed != (unsigned long )((char *)0)) {
#line 473
        free((void *)collapsed);
      }
#line 474
      tmp___15 = xmalloc(collapsed_length);
#line 474
      collapsed = tmp___15;
    }
#line 476
    strcpy((char * __restrict  )collapsed, (char const   * __restrict  )lb.buffer);
#line 478
    collapse_continuations(collapsed);
#line 479
    remove_comments(collapsed);
#line 483
    p = collapsed;
#line 484
    while (1) {
#line 484
      tmp___16 = __ctype_b_loc();
#line 484
      if (! ((int const   )*(*tmp___16 + (int )((unsigned char )*p)) & 8192)) {
#line 484
        break;
      }
#line 485
      p ++;
    }
#line 486
    if ((int )*p == 0) {
#line 488
      continue;
    }
#line 494
    p2 = p + 1;
#line 494
    while (1) {
#line 494
      if ((int )*p2 != 0) {
#line 494
        tmp___17 = __ctype_b_loc();
#line 494
        if ((int const   )*(*tmp___17 + (int )((unsigned char )*p2)) & 8192) {
#line 494
          break;
        }
      } else {
#line 494
        break;
      }
#line 494
      p2 ++;
    }
#line 496
    len = (int )(p2 - p);
#line 501
    reading_target = 0;
#line 502
    while (1) {
#line 502
      tmp___18 = __ctype_b_loc();
#line 502
      if (! ((int const   )*(*tmp___18 + (int )((unsigned char )*p2)) & 8192)) {
#line 502
        break;
      }
#line 503
      p2 ++;
    }
#line 504
    if ((int )*p2 == 0) {
#line 505
      p2 = (char *)((void *)0);
    } else
#line 506
    if ((int )*(p2 + 0) == 58) {
#line 506
      if ((int )*(p2 + 1) == 0) {
#line 508
        reading_target = 1;
#line 509
        goto skip_conditionals;
      }
    }
#line 516
    if (! in_ignored_define) {
#line 516
      if (len == 5) {
#line 516
        tmp___21 = strncmp("ifdef", (char const   *)p, (size_t )5);
#line 516
        if (tmp___21 == 0) {
#line 516
          goto _L;
        } else {
#line 516
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 516
      if (len == 6) {
#line 516
        tmp___22 = strncmp("ifndef", (char const   *)p, (size_t )6);
#line 516
        if (tmp___22 == 0) {
#line 516
          goto _L;
        } else {
#line 516
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 516
      if (len == 4) {
#line 516
        tmp___23 = strncmp("ifeq", (char const   *)p, (size_t )4);
#line 516
        if (tmp___23 == 0) {
#line 516
          goto _L;
        } else {
#line 516
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 516
      if (len == 5) {
#line 516
        tmp___24 = strncmp("ifneq", (char const   *)p, (size_t )5);
#line 516
        if (tmp___24 == 0) {
#line 516
          goto _L;
        } else {
#line 516
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 516
      if (len == 4) {
#line 516
        tmp___25 = strncmp("else", (char const   *)p, (size_t )4);
#line 516
        if (tmp___25 == 0) {
#line 516
          goto _L;
        } else {
#line 516
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 516
      if (len == 5) {
#line 516
        tmp___26 = strncmp("endif", (char const   *)p, (size_t )5);
#line 516
        if (tmp___26 == 0) {
          _L: /* CIL Label */ 
#line 521
          tmp___19 = conditional_line(p, (struct floc  const  *)(& fileinfo));
#line 521
          i___0 = tmp___19;
#line 522
          if (i___0 >= 0) {
#line 523
            ignoring = i___0;
          } else {
#line 525
            tmp___20 = dcgettext((char const   *)((void *)0), "invalid syntax in conditional",
                                 5);
#line 525
            fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___20);
          }
#line 526
          continue;
        }
      }
    }
#line 529
    if (len == 5) {
#line 529
      tmp___28 = strncmp("endef", (char const   *)p, (size_t )5);
#line 529
      if (tmp___28 == 0) {
#line 531
        if (in_ignored_define) {
#line 532
          in_ignored_define = 0;
        } else {
#line 534
          tmp___27 = dcgettext((char const   *)((void *)0), "extraneous `endef\'",
                               5);
#line 534
          fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___27);
        }
#line 535
        continue;
      }
    }
#line 538
    if (len == 6) {
#line 538
      tmp___31 = strncmp("define", (char const   *)p, (size_t )6);
#line 538
      if (tmp___31 == 0) {
#line 540
        if (ignoring) {
#line 541
          in_ignored_define = 1;
        } else {
#line 544
          p2 = next_token(p + 6);
#line 545
          if ((int )*p2 == 0) {
#line 546
            tmp___29 = dcgettext((char const   *)((void *)0), "empty variable name",
                                 5);
#line 546
            fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___29);
          }
#line 552
          p = strchr((char const   *)p2, '\000');
#line 553
          while (1) {
#line 553
            tmp___30 = __ctype_b_loc();
#line 553
            if (! ((int const   )*(*tmp___30 + (int )*(p + -1)) & 1)) {
#line 553
              break;
            }
#line 554
            p --;
          }
#line 555
          do_define(p2, (unsigned int )(p - p2), (enum variable_origin )2, infile,
                    & fileinfo);
        }
#line 557
        continue;
      }
    }
#line 560
    if (len == 8) {
#line 560
      tmp___39 = strncmp("override", (char const   *)p, (size_t )8);
#line 560
      if (tmp___39 == 0) {
#line 562
        p2 = next_token(p + 8);
#line 563
        if ((int )*p2 == 0) {
#line 564
          tmp___32 = dcgettext((char const   *)((void *)0), "empty `override\' directive",
                               5);
#line 564
          error((struct floc  const  *)(& fileinfo), (char const   *)tmp___32);
        }
#line 565
        tmp___37 = strncmp((char const   *)p2, "define", (size_t )6);
#line 565
        if (tmp___37 == 0) {
#line 565
          tmp___38 = __ctype_b_loc();
#line 565
          if ((int const   )*(*tmp___38 + (int )*(p2 + 6)) & 1) {
#line 565
            goto _L___6;
          } else
#line 565
          if ((int )*(p2 + 6) == 0) {
            _L___6: /* CIL Label */ 
#line 567
            if (ignoring) {
#line 568
              in_ignored_define = 1;
            } else {
#line 571
              p2 = next_token(p2 + 6);
#line 572
              if ((int )*p2 == 0) {
#line 573
                tmp___33 = dcgettext((char const   *)((void *)0), "empty variable name",
                                     5);
#line 573
                fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___33);
              }
#line 579
              p = strchr((char const   *)p2, '\000');
#line 580
              while (1) {
#line 580
                tmp___34 = __ctype_b_loc();
#line 580
                if (! ((int const   )*(*tmp___34 + (int )*(p + -1)) & 1)) {
#line 580
                  break;
                }
#line 581
                p --;
              }
#line 582
              do_define(p2, (unsigned int )(p - p2), (enum variable_origin )5, infile,
                        & fileinfo);
            }
          } else {
#line 565
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 585
        if (! ignoring) {
#line 585
          tmp___36 = try_variable_definition((struct floc  const  *)(& fileinfo),
                                             p2, (enum variable_origin )5, 0);
#line 585
          if (! tmp___36) {
#line 587
            tmp___35 = dcgettext((char const   *)((void *)0), "invalid `override\' directive",
                                 5);
#line 587
            error((struct floc  const  *)(& fileinfo), (char const   *)tmp___35);
          }
        }
#line 589
        continue;
      }
    }
    skip_conditionals: 
#line 593
    if (ignoring) {
#line 596
      continue;
    }
#line 598
    if (! reading_target) {
#line 598
      if (len == 6) {
#line 598
        tmp___82 = strncmp("export", (char const   *)p, (size_t )6);
#line 598
        if (tmp___82 == 0) {
#line 601
          p2 = next_token(p + 6);
#line 602
          if ((int )*p2 == 0) {
#line 603
            export_all_variables = 1;
          }
#line 604
          v = try_variable_definition((struct floc  const  *)(& fileinfo), p2, (enum variable_origin )2,
                                      0);
#line 605
          if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 606
            v->export = (enum variable_export )0;
          } else {
#line 610
            p = find_next_token(& p2, & len___1);
#line 610
            while ((unsigned long )p != (unsigned long )((char *)0)) {
#line 613
              v = lookup_variable(p, len___1);
#line 614
              if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
#line 615
                v = define_variable_in_set(p, len___1, (char *)"", (enum variable_origin )2,
                                           0, current_variable_set_list->set, (struct floc  const  *)(& fileinfo));
              }
#line 616
              v->export = (enum variable_export )0;
#line 610
              p = find_next_token(& p2, & len___1);
            }
          }
        } else {
#line 598
          goto _L___14;
        }
      } else {
#line 598
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 620
    if (! reading_target) {
#line 620
      if (len == 8) {
#line 620
        tmp___81 = strncmp("unexport", (char const   *)p, (size_t )8);
#line 620
        if (tmp___81 == 0) {
#line 624
          p2 = next_token(p + 8);
#line 625
          if ((int )*p2 == 0) {
#line 626
            export_all_variables = 0;
          }
#line 627
          p = find_next_token(& p2, & len___2);
#line 627
          while ((unsigned long )p != (unsigned long )((char *)0)) {
#line 630
            v___0 = lookup_variable(p, len___2);
#line 631
            if ((unsigned long )v___0 == (unsigned long )((struct variable *)0)) {
#line 632
              v___0 = define_variable_in_set(p, len___2, (char *)"", (enum variable_origin )2,
                                             0, current_variable_set_list->set, (struct floc  const  *)(& fileinfo));
            }
#line 633
            v___0->export = (enum variable_export )1;
#line 627
            p = find_next_token(& p2, & len___2);
          }
        } else {
#line 620
          goto _L___13;
        }
      } else {
#line 620
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 636
    if (len == 5) {
#line 636
      tmp___80 = strncmp("vpath", (char const   *)p, (size_t )5);
#line 636
      if (tmp___80 == 0) {
#line 640
        p2 = variable_expand(p + 5);
#line 641
        p = find_next_token(& p2, & len___3);
#line 642
        if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 644
          pattern___0 = savestring((char const   *)p, len___3);
#line 645
          p = find_next_token(& p2, & len___3);
        } else {
#line 651
          pattern___0 = (char *)0;
        }
#line 652
        construct_vpath_list(pattern___0, p);
#line 653
        if ((unsigned long )pattern___0 != (unsigned long )((char *)0)) {
#line 654
          free((void *)pattern___0);
        }
      } else {
#line 636
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 656
    if (len == 7) {
#line 656
      tmp___77 = strncmp("include", (char const   *)p, (size_t )7);
#line 656
      if (tmp___77 == 0) {
#line 656
        goto _L___8;
      } else {
#line 656
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 656
    if (len == 8) {
#line 656
      tmp___78 = strncmp("-include", (char const   *)p, (size_t )8);
#line 656
      if (tmp___78 == 0) {
#line 656
        goto _L___8;
      } else {
#line 656
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 656
    if (len == 8) {
#line 656
      tmp___79 = strncmp("sinclude", (char const   *)p, (size_t )8);
#line 656
      if (tmp___79 == 0) {
        _L___8: /* CIL Label */ 
#line 665
        noerror = (int )*(p + 0) != 105;
#line 667
        if (noerror) {
#line 667
          tmp___40 = 8;
        } else {
#line 667
          tmp___40 = 7;
        }
#line 667
        tmp___41 = next_token(p + tmp___40);
#line 667
        p = allocated_variable_expand_for_file(tmp___41, (struct file *)0);
#line 668
        if ((int )*p == 0) {
#line 670
          if (noerror) {
#line 670
            tmp___42 = "-";
          } else {
#line 670
            tmp___42 = "";
          }
#line 670
          tmp___43 = dcgettext((char const   *)((void *)0), "no file name for `%sinclude\'",
                               5);
#line 670
          error((struct floc  const  *)(& fileinfo), (char const   *)tmp___43, tmp___42);
#line 672
          continue;
        }
#line 676
        p2 = p;
#line 677
        tmp___44 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct nameseq ),
                                  1);
#line 677
        files___0 = multi_glob(tmp___44, (unsigned int )sizeof(struct nameseq ));
#line 681
        free((void *)p);
#line 685
        save = conditionals;
#line 686
        memset((void *)((char *)(& new_conditionals)), 0, sizeof(new_conditionals));
#line 687
        conditionals = & new_conditionals;
#line 691
        while (1) {
#line 691
          if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 691
            fi.filenm = fileinfo.filenm;
#line 691
            fi.lineno = (unsigned long )tgts_started;
#line 691
            record_files(filenames, pattern, pattern_percent, deps, cmds_started,
                         commands, commands_idx, two_colon, (struct floc  const  *)(& fi),
                         ! (flags & 1));
#line 691
            using_filename |= commands_idx > 0U;
          }
#line 691
          filenames = (struct nameseq *)0;
#line 691
          commands_idx = 0U;
#line 691
          if (pattern) {
#line 691
            free((void *)pattern);
#line 691
            pattern = (char *)0;
          }
#line 691
          break;
        }
#line 694
        while ((unsigned long )files___0 != (unsigned long )((struct nameseq *)0)) {
#line 696
          next = files___0->next;
#line 697
          name___0 = files___0->name;
#line 700
          free((void *)((char *)files___0));
#line 701
          files___0 = next;
#line 703
          if (noerror) {
#line 703
            tmp___45 = 1 << 2;
          } else {
#line 703
            tmp___45 = 0;
          }
#line 703
          r = read_makefile(name___0, ((1 << 1) | (1 << 3)) | tmp___45);
#line 705
          if (! r) {
#line 705
            if (! noerror) {
#line 706
              tmp___46 = __errno_location();
#line 706
              tmp___47 = strerror(*tmp___46);
#line 706
              error((struct floc  const  *)(& fileinfo), "%s: %s", name___0, tmp___47);
            }
          }
#line 708
          if (r < 2) {
#line 709
            free((void *)name___0);
          }
        }
#line 713
        if (conditionals->ignoring) {
#line 714
          free((void *)conditionals->ignoring);
        }
#line 715
        if (conditionals->seen_else) {
#line 716
          free((void *)conditionals->seen_else);
        }
#line 719
        conditionals = save;
#line 720
        reading_file = (struct floc  const  *)(& fileinfo);
      } else {
#line 656
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ 
#line 723
      tmp___76 = try_variable_definition((struct floc  const  *)(& fileinfo), p, (enum variable_origin )2,
                                         0);
#line 723
      if (! tmp___76) {
#line 726
        if ((int )*(lb.buffer + 0) == 9) {
#line 728
          p = collapsed;
#line 729
          while (1) {
#line 729
            tmp___48 = __ctype_b_loc();
#line 729
            if (! ((int const   )*(*tmp___48 + (int )*p) & 1)) {
#line 729
              break;
            }
#line 730
            p ++;
          }
#line 731
          if ((int )*p == 0) {
#line 733
            continue;
          }
#line 738
          tmp___49 = dcgettext((char const   *)((void *)0), "commands commence before first target",
                               5);
#line 738
          fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___49);
        } else {
#line 755
          plen = 0U;
#line 760
          while (1) {
#line 760
            if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 760
              fi___0.filenm = fileinfo.filenm;
#line 760
              fi___0.lineno = (unsigned long )tgts_started;
#line 760
              record_files(filenames, pattern, pattern_percent, deps, cmds_started,
                           commands, commands_idx, two_colon, (struct floc  const  *)(& fi___0),
                           ! (flags & 1));
#line 760
              using_filename |= commands_idx > 0U;
            }
#line 760
            filenames = (struct nameseq *)0;
#line 760
            commands_idx = 0U;
#line 760
            if (pattern) {
#line 760
              free((void *)pattern);
#line 760
              pattern = (char *)0;
            }
#line 760
            break;
          }
#line 761
          tgts_started = (unsigned int )fileinfo.lineno;
#line 765
          cmdleft = find_char_unquote(lb.buffer, (char *)";#", 0);
#line 766
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 766
            if ((int )*cmdleft == 35) {
#line 769
              *cmdleft = (char )'\000';
#line 770
              cmdleft = (char *)0;
            } else {
#line 766
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 772
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 774
            tmp___50 = cmdleft;
#line 774
            cmdleft ++;
#line 774
            *tmp___50 = (char )'\000';
          }
#line 776
          collapse_continuations(lb.buffer);
#line 782
          wtype = get_next_mword(lb.buffer, (char *)((void *)0), & lb_next, & len___4);
#line 783
          switch ((unsigned int )wtype) {
          case 1U: 
#line 786
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 787
            tmp___51 = dcgettext((char const   *)((void *)0), "missing rule before commands",
                                 5);
#line 787
            fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___51);
          }
#line 790
          continue;
          case 5U: 
          case 4U: 
#line 796
          no_targets = 1;
#line 797
          continue;
          default: 
#line 800
          break;
          }
#line 803
          p2 = variable_expand_string((char *)((void *)0), lb_next, (long )len___4);
#line 804
          while (1) {
#line 806
            lb_next += len___4;
#line 807
            if ((unsigned long )cmdleft == (unsigned long )((char *)0)) {
#line 810
              cmdleft = find_char_unquote(p2, (char *)";", 0);
#line 812
              if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 814
                p2_off = (unsigned long )(p2 - variable_buffer);
#line 815
                cmd_off = (unsigned long )(cmdleft - variable_buffer);
#line 816
                tmp___52 = strlen((char const   *)p2);
#line 816
                pend = p2 + tmp___52;
#line 820
                *cmdleft = (char )'\000';
#line 830
                variable_expand_string(pend, lb_next, -1L);
#line 831
                tmp___53 = strlen((char const   *)lb_next);
#line 831
                lb_next += tmp___53;
#line 832
                p2 = variable_buffer + p2_off;
#line 833
                cmdleft = (variable_buffer + cmd_off) + 1;
              }
            }
#line 837
            colonp = find_char_unquote(p2, (char *)":", 0);
#line 848
            if ((unsigned long )colonp != (unsigned long )((char *)0)) {
#line 849
              break;
            }
#line 851
            wtype = get_next_mword(lb_next, (char *)((void *)0), & lb_next, & len___4);
#line 852
            if ((unsigned int )wtype == 1U) {
#line 853
              break;
            }
#line 855
            tmp___54 = strlen((char const   *)p2);
#line 855
            p2 += tmp___54;
#line 856
            tmp___55 = p2;
#line 856
            p2 ++;
#line 856
            *tmp___55 = (char )' ';
#line 857
            p2 = variable_expand_string(p2, lb_next, (long )len___4);
          }
#line 863
          p2 = next_token(variable_buffer);
#line 868
          if ((unsigned int )wtype == 1U) {
#line 870
            if ((int )*p2 != 0) {
#line 873
              tmp___59 = strncmp((char const   *)lb.buffer, "        ", (size_t )8);
#line 873
              if (tmp___59 == 0) {
#line 873
                tmp___57 = dcgettext((char const   *)((void *)0), " (did you mean TAB instead of 8 spaces?)",
                                     5);
#line 873
                tmp___58 = (char const   *)tmp___57;
              } else {
#line 873
                tmp___58 = "";
              }
#line 873
              tmp___60 = dcgettext((char const   *)((void *)0), "missing separator%s",
                                   5);
#line 873
              fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___60,
                    tmp___58);
            }
#line 876
            continue;
          }
#line 881
          *colonp = (char )'\000';
#line 882
          tmp___61 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct nameseq ),
                                    1);
#line 882
          filenames = multi_glob(tmp___61, (unsigned int )sizeof(struct nameseq ));
#line 886
          *p2 = (char )':';
#line 888
          if (! filenames) {
#line 892
            no_targets = 1;
#line 893
            continue;
          }
#line 896
          if (! ((int )*p2 != 0)) {
#line 896
            __assert_fail("*p2 != \'\\0\'", "read.c", 896U, "read_makefile");
          }
#line 897
          p2 ++;
#line 900
          two_colon = (int )*p2 == 58;
#line 901
          if (two_colon) {
#line 902
            p2 ++;
          }
#line 908
          if ((int )*lb_next != 0) {
#line 910
            l = (unsigned int )(p2 - variable_buffer);
#line 911
            tmp___63 = strlen((char const   *)p2);
#line 911
            plen = (unsigned int )tmp___63;
#line 912
            tmp___64 = strlen((char const   *)lb_next);
#line 912
            variable_buffer_output(p2 + plen, lb_next, (unsigned int )(tmp___64 + 1UL));
#line 914
            p2 = variable_buffer + l;
          }
#line 920
          wtype = get_next_mword(p2, (char *)((void *)0), & p, & len___4);
#line 922
          v_origin = (enum variable_origin )2;
#line 923
          if ((unsigned int )wtype == 2U) {
#line 923
            if ((unsigned long )len___4 == sizeof("override") - 1UL) {
#line 923
              tmp___65 = strncmp((char const   *)p, "override", (size_t )len___4);
#line 923
              if (tmp___65 == 0) {
#line 926
                v_origin = (enum variable_origin )5;
#line 927
                wtype = get_next_mword(p + len___4, (char *)((void *)0), & p, & len___4);
              }
            }
          }
#line 930
          if ((unsigned int )wtype != 1U) {
#line 931
            wtype = get_next_mword(p + len___4, (char *)((void *)0), (char **)((void *)0),
                                   (unsigned int *)((void *)0));
          }
#line 933
          if ((unsigned int )wtype == 8U) {
#line 935
            record_target_var(filenames, p, two_colon, v_origin, (struct floc  const  *)(& fileinfo));
#line 936
            filenames = (struct nameseq *)0;
#line 937
            continue;
          }
#line 942
          find_char_unquote(lb_next, (char *)"=", 0);
#line 945
          no_targets = 0;
#line 948
          if ((int )*lb_next != 0) {
#line 950
            l___0 = (unsigned int )(p2 - variable_buffer);
#line 951
            variable_expand_string(p2 + plen, lb_next, -1L);
#line 952
            p2 = variable_buffer + l___0;
#line 955
            if ((unsigned long )cmdleft == (unsigned long )((char *)0)) {
#line 957
              cmdleft = find_char_unquote(p2, (char *)";", 0);
#line 958
              if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 959
                tmp___66 = cmdleft;
#line 959
                cmdleft ++;
#line 959
                *tmp___66 = (char )'\000';
              }
            }
          }
#line 964
          p = strchr((char const   *)p2, ':');
#line 965
          while (1) {
#line 965
            if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 965
              if (! ((int )*(p + -1) == 92)) {
#line 965
                break;
              }
            } else {
#line 965
              break;
            }
#line 967
            q = p + -1;
#line 968
            backslash = 0;
#line 969
            while (1) {
#line 969
              tmp___67 = q;
#line 969
              q --;
#line 969
              if (! ((int )*tmp___67 == 92)) {
#line 969
                break;
              }
#line 970
              backslash = ! backslash;
            }
#line 971
            if (backslash) {
#line 972
              p = strchr((char const   *)(p + 1), ':');
            } else {
#line 974
              break;
            }
          }
#line 1005
          if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 1008
            target = parse_file_seq(& p2, ':', (unsigned int )sizeof(struct nameseq ),
                                    1);
#line 1009
            p2 ++;
#line 1010
            if ((unsigned long )target == (unsigned long )((struct nameseq *)0)) {
#line 1011
              tmp___68 = dcgettext((char const   *)((void *)0), "missing target pattern",
                                   5);
#line 1011
              fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___68);
            } else
#line 1012
            if ((unsigned long )target->next != (unsigned long )((struct nameseq *)0)) {
#line 1013
              tmp___69 = dcgettext((char const   *)((void *)0), "multiple target patterns",
                                   5);
#line 1013
              fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___69);
            }
#line 1014
            pattern = target->name;
#line 1015
            pattern_percent = find_percent(pattern);
#line 1016
            if ((unsigned long )pattern_percent == (unsigned long )((char *)0)) {
#line 1017
              tmp___70 = dcgettext((char const   *)((void *)0), "target pattern contains no `%%\'",
                                   5);
#line 1017
              fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___70);
            }
#line 1018
            free((void *)((char *)target));
          } else {
#line 1021
            pattern = (char *)0;
          }
#line 1024
          tmp___71 = parse_file_seq(& p2, '\000', (unsigned int )sizeof(struct dep ),
                                    1);
#line 1024
          tmp___72 = multi_glob(tmp___71, (unsigned int )sizeof(struct dep ));
#line 1024
          deps = (struct dep *)tmp___72;
#line 1028
          commands_idx = 0U;
#line 1029
          if ((unsigned long )cmdleft != (unsigned long )((char *)0)) {
#line 1032
            tmp___73 = strlen((char const   *)cmdleft);
#line 1032
            len___5 = (unsigned int )tmp___73;
#line 1034
            cmds_started = (unsigned int )fileinfo.lineno;
#line 1037
            if (len___5 + 2U > commands_len) {
#line 1039
              commands_len = (len___5 + 2U) * 2U;
#line 1040
              tmp___74 = xrealloc(commands, commands_len);
#line 1040
              commands = tmp___74;
            }
#line 1042
            memmove((void *)commands, (void const   *)cmdleft, (size_t )len___5);
#line 1043
            commands_idx += len___5;
#line 1044
            tmp___75 = commands_idx;
#line 1044
            commands_idx ++;
#line 1044
            *(commands + tmp___75) = (char )'\n';
          }
#line 1047
          continue;
        }
      }
    }
#line 1053
    while (1) {
#line 1053
      if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 1053
        fi___1.filenm = fileinfo.filenm;
#line 1053
        fi___1.lineno = (unsigned long )tgts_started;
#line 1053
        record_files(filenames, pattern, pattern_percent, deps, cmds_started, commands,
                     commands_idx, two_colon, (struct floc  const  *)(& fi___1), ! (flags & 1));
#line 1053
        using_filename |= commands_idx > 0U;
      }
#line 1053
      filenames = (struct nameseq *)0;
#line 1053
      commands_idx = 0U;
#line 1053
      if (pattern) {
#line 1053
        free((void *)pattern);
#line 1053
        pattern = (char *)0;
      }
#line 1053
      break;
    }
#line 1054
    no_targets = 0;
  }
#line 1057
  if (conditionals->if_cmds) {
#line 1058
    tmp___84 = dcgettext((char const   *)((void *)0), "missing `endif\'", 5);
#line 1058
    fatal((struct floc  const  *)(& fileinfo), (char const   *)tmp___84);
  }
#line 1061
  while (1) {
#line 1061
    if ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 1061
      fi___2.filenm = fileinfo.filenm;
#line 1061
      fi___2.lineno = (unsigned long )tgts_started;
#line 1061
      record_files(filenames, pattern, pattern_percent, deps, cmds_started, commands,
                   commands_idx, two_colon, (struct floc  const  *)(& fi___2), ! (flags & 1));
#line 1061
      using_filename |= commands_idx > 0U;
    }
#line 1061
    filenames = (struct nameseq *)0;
#line 1061
    commands_idx = 0U;
#line 1061
    if (pattern) {
#line 1061
      free((void *)pattern);
#line 1061
      pattern = (char *)0;
    }
#line 1061
    break;
  }
#line 1063
  free((void *)lb.buffer);
#line 1064
  free((void *)commands);
#line 1065
  fclose(infile);
#line 1067
  reading_file = (struct floc  const  *)0;
#line 1069
  return (1 + using_filename);
}
}
#line 1078 "read.c"
static void do_define(char *name , unsigned int namelen , enum variable_origin origin ,
                      FILE *infile , struct floc *flocp ) 
{ 
  struct linebuffer lb ;
  unsigned int nlines ;
  unsigned int length___0 ;
  char *definition ;
  char *tmp ;
  register unsigned int idx ;
  register char *p ;
  char *var ;
  void *tmp___0 ;
  char *tmp___1 ;
  unsigned int len ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 1087
  nlines = 0U;
#line 1088
  length___0 = 100U;
#line 1089
  tmp = xmalloc(100U);
#line 1089
  definition = tmp;
#line 1090
  idx = 0U;
#line 1094
  tmp___0 = __builtin_alloca((unsigned long )(namelen + 1U));
#line 1094
  var = (char *)tmp___0;
#line 1095
  memmove((void *)var, (void const   *)name, (size_t )namelen);
#line 1096
  *(var + namelen) = (char )'\000';
#line 1097
  var = variable_expand(var);
#line 1099
  lb.size = 200U;
#line 1099
  tmp___1 = xmalloc(lb.size);
#line 1099
  lb.buffer = tmp___1;
#line 1100
  while (1) {
#line 1100
    tmp___12 = feof(infile);
#line 1100
    if (tmp___12) {
#line 1100
      break;
    }
#line 1104
    flocp->lineno += (unsigned long )nlines;
#line 1105
    tmp___2 = readline(& lb, infile, (struct floc  const  *)flocp);
#line 1105
    nlines = (unsigned int )tmp___2;
#line 1107
    collapse_continuations(lb.buffer);
#line 1109
    p = next_token(lb.buffer);
#line 1110
    tmp___3 = strlen((char const   *)p);
#line 1110
    len = (unsigned int )tmp___3;
#line 1111
    if (len == 5U) {
#line 1111
      goto _L___0;
    } else
#line 1111
    if (len > 5U) {
#line 1111
      tmp___10 = __ctype_b_loc();
#line 1111
      if ((int const   )*(*tmp___10 + (int )*(p + 5)) & 1) {
        _L___0: /* CIL Label */ 
#line 1111
        tmp___11 = strncmp((char const   *)p, "endef", (size_t )5);
#line 1111
        if (tmp___11 == 0) {
#line 1114
          p += 5;
#line 1115
          remove_comments(p);
#line 1116
          tmp___5 = next_token(p);
#line 1116
          if ((int )*tmp___5 != 0) {
#line 1117
            tmp___4 = dcgettext((char const   *)((void *)0), "Extraneous text after `endef\' directive",
                                5);
#line 1117
            error((struct floc  const  *)flocp, (char const   *)tmp___4);
          }
#line 1119
          if (idx == 0U) {
#line 1120
            *(definition + 0) = (char )'\000';
          } else {
#line 1122
            *(definition + (idx - 1U)) = (char )'\000';
          }
#line 1123
          tmp___6 = strlen((char const   *)var);
#line 1123
          define_variable_in_set(var, (unsigned int )tmp___6, definition, origin,
                                 1, current_variable_set_list->set, (struct floc  const  *)flocp);
#line 1125
          free((void *)definition);
#line 1126
          free((void *)lb.buffer);
#line 1127
          return;
        } else {
#line 1111
          goto _L___1;
        }
      } else {
#line 1111
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1131
      tmp___7 = strlen((char const   *)lb.buffer);
#line 1131
      len = (unsigned int )tmp___7;
#line 1133
      if ((idx + len) + 1U > length___0) {
#line 1135
        length___0 = (idx + len) * 2U;
#line 1136
        tmp___8 = xrealloc(definition, length___0 + 1U);
#line 1136
        definition = tmp___8;
      }
#line 1139
      memmove((void *)(definition + idx), (void const   *)lb.buffer, (size_t )len);
#line 1140
      idx += len;
#line 1142
      tmp___9 = idx;
#line 1142
      idx ++;
#line 1142
      *(definition + tmp___9) = (char )'\n';
    }
  }
#line 1147
  tmp___13 = dcgettext((char const   *)((void *)0), "missing `endef\', unterminated `define\'",
                       5);
#line 1147
  fatal((struct floc  const  *)flocp, (char const   *)tmp___13);
#line 1150
  return;
}
}
#line 1164 "read.c"
static int conditional_line(char *line , struct floc  const  *flocp ) 
{ 
  int notdef ;
  char *cmdname ;
  register unsigned int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct variable *v ;
  register char *p ;
  char *tmp___9 ;
  int tmp___10 ;
  char *s1 ;
  char *s2 ;
  unsigned int len ;
  char termin ;
  int tmp___11 ;
  register int count ;
  char *p___0 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  register int count___0 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 1173
  if ((int )*line == 105) {
#line 1176
    notdef = (int )*(line + 2) == 110;
#line 1177
    if (notdef) {
#line 1179
      if ((int )*(line + 3) == 100) {
#line 1179
        cmdname = (char *)"ifndef";
      } else {
#line 1179
        cmdname = (char *)"ifneq";
      }
#line 1180
      if ((int )*(cmdname + 3) == 100) {
#line 1180
        tmp = 7;
      } else {
#line 1180
        tmp = 6;
      }
#line 1180
      line += tmp;
    } else {
#line 1184
      if ((int )*(line + 2) == 100) {
#line 1184
        cmdname = (char *)"ifdef";
      } else {
#line 1184
        cmdname = (char *)"ifeq";
      }
#line 1185
      if ((int )*(cmdname + 2) == 100) {
#line 1185
        tmp___0 = 6;
      } else {
#line 1185
        tmp___0 = 5;
      }
#line 1185
      line += tmp___0;
    }
  } else {
#line 1191
    notdef = (int )*(line + 1) == 110;
#line 1192
    if (notdef) {
#line 1192
      cmdname = (char *)"endif";
    } else {
#line 1192
      cmdname = (char *)"else";
    }
#line 1193
    if (notdef) {
#line 1193
      tmp___1 = 5;
    } else {
#line 1193
      tmp___1 = 4;
    }
#line 1193
    line += tmp___1;
  }
#line 1196
  line = next_token(line);
#line 1198
  if ((int )*cmdname == 101) {
#line 1200
    if ((int )*line != 0) {
#line 1201
      tmp___2 = dcgettext((char const   *)((void *)0), "Extraneous text after `%s\' directive",
                          5);
#line 1201
      error(flocp, (char const   *)tmp___2, cmdname);
    }
#line 1203
    if (conditionals->if_cmds == 0U) {
#line 1204
      tmp___3 = dcgettext((char const   *)((void *)0), "extraneous `%s\'", 5);
#line 1204
      fatal(flocp, (char const   *)tmp___3, cmdname);
    }
#line 1206
    if (notdef) {
#line 1207
      (conditionals->if_cmds) --;
    } else
#line 1208
    if (*(conditionals->seen_else + (conditionals->if_cmds - 1U))) {
#line 1209
      tmp___4 = dcgettext((char const   *)((void *)0), "only one `else\' per conditional",
                          5);
#line 1209
      fatal(flocp, (char const   *)tmp___4);
    } else {
#line 1213
      *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(! *(conditionals->ignoring + (conditionals->if_cmds - 1U)));
#line 1217
      *(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)1;
    }
#line 1219
    i = 0U;
#line 1219
    while (i < conditionals->if_cmds) {
#line 1220
      if (*(conditionals->ignoring + i)) {
#line 1221
        return (1);
      }
#line 1219
      i ++;
    }
#line 1222
    return (0);
  }
#line 1225
  if (conditionals->allocated == 0U) {
#line 1227
    conditionals->allocated = 5U;
#line 1228
    tmp___5 = xmalloc(conditionals->allocated);
#line 1228
    conditionals->ignoring = tmp___5;
#line 1229
    tmp___6 = xmalloc(conditionals->allocated);
#line 1229
    conditionals->seen_else = tmp___6;
  }
#line 1232
  (conditionals->if_cmds) ++;
#line 1233
  if (conditionals->if_cmds > conditionals->allocated) {
#line 1235
    conditionals->allocated += 5U;
#line 1236
    tmp___7 = xrealloc(conditionals->ignoring, conditionals->allocated);
#line 1236
    conditionals->ignoring = tmp___7;
#line 1238
    tmp___8 = xrealloc(conditionals->seen_else, conditionals->allocated);
#line 1238
    conditionals->seen_else = tmp___8;
  }
#line 1243
  *(conditionals->seen_else + (conditionals->if_cmds - 1U)) = (char)0;
#line 1246
  i = 0U;
#line 1246
  while (i < conditionals->if_cmds - 1U) {
#line 1247
    if (*(conditionals->ignoring + i)) {
#line 1252
      *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char)1;
#line 1253
      return (1);
    }
#line 1246
    i ++;
  }
#line 1256
  if (notdef) {
#line 1256
    tmp___20 = 3;
  } else {
#line 1256
    tmp___20 = 2;
  }
#line 1256
  if ((int )*(cmdname + tmp___20) == 100) {
#line 1260
    tmp___9 = end_of_token(line);
#line 1260
    p = tmp___9;
#line 1261
    i = (unsigned int )(p - line);
#line 1262
    p = next_token(p);
#line 1263
    if ((int )*p != 0) {
#line 1264
      return (-1);
    }
#line 1265
    v = lookup_variable(line, i);
#line 1266
    if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 1266
      if ((int )*(v->value) != 0) {
#line 1266
        tmp___10 = 1;
      } else {
#line 1266
        tmp___10 = 0;
      }
    } else {
#line 1266
      tmp___10 = 0;
    }
#line 1266
    *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___10 == notdef);
  } else {
#line 1274
    if ((int )*line == 40) {
#line 1274
      tmp___11 = ',';
    } else {
#line 1274
      tmp___11 = (int )*line;
    }
#line 1274
    termin = (char )tmp___11;
#line 1276
    if ((int )termin != 44) {
#line 1276
      if ((int )termin != 34) {
#line 1276
        if ((int )termin != 39) {
#line 1277
          return (-1);
        }
      }
    }
#line 1279
    line ++;
#line 1279
    s1 = line;
#line 1281
    if ((int )termin == 44) {
#line 1283
      count = 0;
#line 1284
      while ((int )*line != 0) {
#line 1285
        if ((int )*line == 40) {
#line 1286
          count ++;
        } else
#line 1287
        if ((int )*line == 41) {
#line 1288
          count --;
        } else
#line 1289
        if ((int )*line == 44) {
#line 1289
          if (count <= 0) {
#line 1290
            break;
          }
        }
#line 1284
        line ++;
      }
    } else {
#line 1293
      while (1) {
#line 1293
        if ((int )*line != 0) {
#line 1293
          if (! ((int )*line != (int )termin)) {
#line 1293
            break;
          }
        } else {
#line 1293
          break;
        }
#line 1294
        line ++;
      }
    }
#line 1296
    if ((int )*line == 0) {
#line 1297
      return (-1);
    }
#line 1299
    if ((int )termin == 44) {
#line 1302
      tmp___12 = line;
#line 1302
      line ++;
#line 1302
      p___0 = tmp___12;
#line 1303
      while (1) {
#line 1303
        tmp___13 = __ctype_b_loc();
#line 1303
        if (! ((int const   )*(*tmp___13 + (int )*(p___0 + -1)) & 1)) {
#line 1303
          break;
        }
#line 1304
        p___0 --;
      }
#line 1305
      *p___0 = (char )'\000';
    } else {
#line 1308
      tmp___14 = line;
#line 1308
      line ++;
#line 1308
      *tmp___14 = (char )'\000';
    }
#line 1310
    s2 = variable_expand(s1);
#line 1313
    tmp___15 = strlen((char const   *)s2);
#line 1313
    len = (unsigned int )tmp___15;
#line 1314
    tmp___16 = __builtin_alloca((unsigned long )(len + 1U));
#line 1314
    s1 = (char *)tmp___16;
#line 1315
    memmove((void *)s1, (void const   *)s2, (size_t )(len + 1U));
#line 1317
    if ((int )termin != 44) {
#line 1319
      line = next_token(line);
    }
#line 1321
    if ((int )termin == 44) {
#line 1321
      termin = (char )')';
    } else {
#line 1321
      termin = *line;
    }
#line 1322
    if ((int )termin != 41) {
#line 1322
      if ((int )termin != 34) {
#line 1322
        if ((int )termin != 39) {
#line 1323
          return (-1);
        }
      }
    }
#line 1326
    if ((int )termin == 41) {
#line 1328
      count___0 = 0;
#line 1329
      s2 = next_token(line);
#line 1330
      line = s2;
#line 1330
      while ((int )*line != 0) {
#line 1332
        if ((int )*line == 40) {
#line 1333
          count___0 ++;
        } else
#line 1334
        if ((int )*line == 41) {
#line 1336
          if (count___0 <= 0) {
#line 1337
            break;
          } else {
#line 1339
            count___0 --;
          }
        }
#line 1330
        line ++;
      }
    } else {
#line 1345
      line ++;
#line 1346
      s2 = line;
#line 1347
      while (1) {
#line 1347
        if ((int )*line != 0) {
#line 1347
          if (! ((int )*line != (int )termin)) {
#line 1347
            break;
          }
        } else {
#line 1347
          break;
        }
#line 1348
        line ++;
      }
    }
#line 1351
    if ((int )*line == 0) {
#line 1352
      return (-1);
    }
#line 1354
    *line = (char )'\000';
#line 1355
    line ++;
#line 1355
    line = next_token(line);
#line 1356
    if ((int )*line != 0) {
#line 1357
      tmp___17 = dcgettext((char const   *)((void *)0), "Extraneous text after `%s\' directive",
                           5);
#line 1357
      error(flocp, (char const   *)tmp___17, cmdname);
    }
#line 1359
    s2 = variable_expand(s2);
#line 1360
    if ((unsigned long )s1 == (unsigned long )s2) {
#line 1360
      tmp___19 = 1;
    } else
#line 1360
    if ((int )*s1 == (int )*s2) {
#line 1360
      if ((int )*s1 == 0) {
#line 1360
        tmp___19 = 1;
      } else {
#line 1360
        tmp___18 = strcmp((char const   *)(s1 + 1), (char const   *)(s2 + 1));
#line 1360
        if (tmp___18) {
#line 1360
          tmp___19 = 0;
        } else {
#line 1360
          tmp___19 = 1;
        }
      }
    } else {
#line 1360
      tmp___19 = 0;
    }
#line 1360
    *(conditionals->ignoring + (conditionals->if_cmds - 1U)) = (char )(tmp___19 == notdef);
  }
#line 1365
  i = 0U;
#line 1365
  while (i < conditionals->if_cmds) {
#line 1366
    if (*(conditionals->ignoring + i)) {
#line 1367
      return (1);
    }
#line 1365
    i ++;
  }
#line 1368
  return (0);
}
}
#line 1373 "read.c"
void uniquize_deps(struct dep *chain ) 
{ 
  register struct dep *d ;
  struct dep *last ;
  struct dep *next ;
  struct dep *n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 1383
  d = chain;
#line 1383
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 1387
    last = d;
#line 1388
    next = d->next;
#line 1389
    while ((unsigned long )next != (unsigned long )((struct dep *)0)) {
#line 1390
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1390
        tmp = (d->file)->name;
      } else {
#line 1390
        tmp = d->name;
      }
#line 1390
      if ((unsigned long )next->name == (unsigned long )((char *)0)) {
#line 1390
        tmp___0 = (next->file)->name;
      } else {
#line 1390
        tmp___0 = next->name;
      }
#line 1390
      if ((unsigned long )tmp == (unsigned long )tmp___0) {
#line 1390
        goto _L___0;
      } else {
#line 1390
        if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1390
          tmp___1 = (d->file)->name;
        } else {
#line 1390
          tmp___1 = d->name;
        }
#line 1390
        if ((unsigned long )next->name == (unsigned long )((char *)0)) {
#line 1390
          tmp___2 = (next->file)->name;
        } else {
#line 1390
          tmp___2 = next->name;
        }
#line 1390
        if ((int )*tmp___1 == (int )*tmp___2) {
#line 1390
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1390
            tmp___3 = (d->file)->name;
          } else {
#line 1390
            tmp___3 = d->name;
          }
#line 1390
          if ((int )*tmp___3 == 0) {
#line 1390
            goto _L___0;
          } else {
#line 1390
            if ((unsigned long )next->name == (unsigned long )((char *)0)) {
#line 1390
              tmp___4 = (next->file)->name;
            } else {
#line 1390
              tmp___4 = next->name;
            }
#line 1390
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1390
              tmp___5 = (d->file)->name;
            } else {
#line 1390
              tmp___5 = d->name;
            }
#line 1390
            tmp___6 = strcmp((char const   *)(tmp___5 + 1), (char const   *)(tmp___4 + 1));
#line 1390
            if (tmp___6) {
#line 1402
              last = next;
#line 1403
              next = next->next;
            } else {
              _L___0: /* CIL Label */ 
#line 1392
              n = next->next;
#line 1393
              last->next = n;
#line 1394
              if ((unsigned long )next->name != (unsigned long )((char *)0)) {
#line 1394
                if ((unsigned long )next->name != (unsigned long )d->name) {
#line 1395
                  free((void *)next->name);
                }
              }
#line 1396
              if ((unsigned long )next != (unsigned long )d) {
#line 1397
                free((void *)((char *)next));
              }
#line 1398
              next = n;
            }
          }
        } else {
#line 1402
          last = next;
#line 1403
          next = next->next;
        }
      }
    }
#line 1383
    d = d->next;
  }
#line 1406
  return;
}
}
#line 1417 "read.c"
static void record_target_var(struct nameseq *filenames , char *defn , int two_colon ,
                              enum variable_origin origin , struct floc  const  *flocp ) 
{ 
  struct nameseq *nextf ;
  struct variable_set_list *global ;
  struct variable *v ;
  register char *name ;
  struct variable_set_list *vlist ;
  char *fname ;
  char *percent ;
  struct pattern_var *p ;
  struct file *f ;
  char *tmp ;
  struct variable *gv ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1428
  global = current_variable_set_list;
#line 1433
  while ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 1436
    name = filenames->name;
#line 1441
    nextf = filenames->next;
#line 1442
    free((void *)((char *)filenames));
#line 1446
    percent = find_percent(name);
#line 1447
    if (percent) {
#line 1452
      p = create_pattern_var(name, percent);
#line 1453
      vlist = p->vars;
#line 1454
      fname = p->target;
    } else {
#line 1461
      f = enter_file(name);
#line 1462
      initialize_file_variables(f, 1);
#line 1463
      vlist = f->variables;
#line 1464
      fname = f->name;
    }
#line 1468
    current_variable_set_list = vlist;
#line 1469
    v = try_variable_definition(flocp, defn, origin, 1);
#line 1470
    if (! v) {
#line 1471
      tmp = dcgettext((char const   *)((void *)0), "Malformed per-target variable definition",
                      5);
#line 1471
      error(flocp, (char const   *)tmp);
    }
#line 1472
    v->per_target = 1U;
#line 1476
    if ((unsigned int )origin != 5U) {
#line 1479
      tmp___0 = strlen((char const   *)v->name);
#line 1479
      len = (int )tmp___0;
#line 1481
      current_variable_set_list = global;
#line 1482
      gv = lookup_variable(v->name, (unsigned int )len);
#line 1483
      if (gv) {
#line 1483
        if ((unsigned int )gv->origin == 3U) {
#line 1484
          define_variable_in_set(v->name, (unsigned int )len, gv->value, gv->origin,
                                 (int )gv->recursive, vlist->set, flocp);
        } else
#line 1483
        if ((unsigned int )gv->origin == 4U) {
#line 1484
          define_variable_in_set(v->name, (unsigned int )len, gv->value, gv->origin,
                                 (int )gv->recursive, vlist->set, flocp);
        }
      }
    }
#line 1489
    if ((unsigned long )name != (unsigned long )fname) {
#line 1489
      if ((unsigned long )name < (unsigned long )fname) {
#line 1490
        free((void *)name);
      } else {
#line 1489
        tmp___1 = strlen((char const   *)fname);
#line 1489
        if ((unsigned long )name > (unsigned long )(fname + tmp___1)) {
#line 1490
          free((void *)name);
        }
      }
    }
#line 1433
    filenames = nextf;
  }
#line 1493
  current_variable_set_list = global;
#line 1494
  return;
}
}
#line 1719 "read.c"
static char *percent___0  =    (char *)"%";
#line 1507 "read.c"
static void record_files(struct nameseq *filenames , char *pattern , char *pattern_percent ,
                         struct dep *deps , unsigned int cmds_started , char *commands ,
                         unsigned int commands_idx , int two_colon , struct floc  const  *flocp ,
                         int set_default ) 
{ 
  struct nameseq *nextf ;
  int implicit ;
  unsigned int max_targets ;
  unsigned int target_idx ;
  char **targets ;
  char **target_percents ;
  struct commands *cmds ;
  char *tmp ;
  register char *name ;
  register struct file *f ;
  register struct dep *d ;
  struct dep *this ;
  char *implicit_percent ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct dep *tmp___6 ;
  char *tmp___7 ;
  char *buffer ;
  char *tmp___8 ;
  char *o ;
  char *percent ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  struct dep *nextd ;
  struct dep *firstdeps ;
  struct dep *moredeps ;
  char *buffer___0 ;
  char *tmp___16 ;
  char *o___0 ;
  char *tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  int reject ;
  register struct dep *d2 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  register unsigned int len ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;

  {
#line 1521
  implicit = 0;
#line 1522
  max_targets = 0U;
#line 1522
  target_idx = 0U;
#line 1523
  targets = (char **)0;
#line 1523
  target_percents = (char **)0;
#line 1526
  if (commands_idx > 0U) {
#line 1528
    tmp = xmalloc((unsigned int )sizeof(struct commands ));
#line 1528
    cmds = (struct commands *)tmp;
#line 1529
    cmds->fileinfo.filenm = (char *)flocp->filenm;
#line 1530
    cmds->fileinfo.lineno = (unsigned long )cmds_started;
#line 1531
    cmds->commands = savestring((char const   *)commands, commands_idx);
#line 1532
    cmds->command_lines = (char **)0;
  } else {
#line 1535
    cmds = (struct commands *)0;
  }
#line 1537
  while ((unsigned long )filenames != (unsigned long )((struct nameseq *)0)) {
#line 1540
    name = filenames->name;
#line 1546
    nextf = filenames->next;
#line 1547
    free((void *)filenames);
#line 1549
    implicit_percent = find_percent(name);
#line 1550
    implicit |= (unsigned long )implicit_percent != (unsigned long )((char *)0);
#line 1552
    if (implicit) {
#line 1552
      if ((unsigned long )pattern != (unsigned long )((char *)0)) {
#line 1553
        tmp___0 = dcgettext((char const   *)((void *)0), "mixed implicit and static pattern rules",
                            5);
#line 1553
        fatal(flocp, (char const   *)tmp___0);
      }
    }
#line 1555
    if (implicit) {
#line 1555
      if ((unsigned long )implicit_percent == (unsigned long )((char *)0)) {
#line 1556
        tmp___1 = dcgettext((char const   *)((void *)0), "mixed implicit and normal rules",
                            5);
#line 1556
        fatal(flocp, (char const   *)tmp___1);
      }
    }
#line 1558
    if (implicit) {
#line 1560
      if ((unsigned long )targets == (unsigned long )((char **)0)) {
#line 1562
        max_targets = 5U;
#line 1563
        tmp___2 = xmalloc((unsigned int )(5UL * sizeof(char *)));
#line 1563
        targets = (char **)tmp___2;
#line 1564
        tmp___3 = xmalloc((unsigned int )(5UL * sizeof(char *)));
#line 1564
        target_percents = (char **)tmp___3;
#line 1565
        target_idx = 0U;
      } else
#line 1567
      if (target_idx == max_targets - 1U) {
#line 1569
        max_targets += 5U;
#line 1570
        tmp___4 = xrealloc((char *)targets, (unsigned int )((unsigned long )max_targets * sizeof(char *)));
#line 1570
        targets = (char **)tmp___4;
#line 1572
        tmp___5 = xrealloc((char *)target_percents, (unsigned int )((unsigned long )max_targets * sizeof(char *)));
#line 1572
        target_percents = (char **)tmp___5;
      }
#line 1576
      *(targets + target_idx) = name;
#line 1577
      *(target_percents + target_idx) = implicit_percent;
#line 1578
      target_idx ++;
#line 1579
      goto __Cont;
    }
#line 1585
    if ((unsigned long )nextf != (unsigned long )((struct nameseq *)0)) {
#line 1585
      tmp___6 = copy_dep_chain(deps);
#line 1585
      this = tmp___6;
    } else {
#line 1585
      this = deps;
    }
#line 1587
    if ((unsigned long )pattern != (unsigned long )((char *)0)) {
#line 1593
      tmp___11 = pattern_matches(pattern, pattern_percent, name);
#line 1593
      if (tmp___11) {
#line 1605
        tmp___8 = variable_expand((char *)"");
#line 1605
        buffer = tmp___8;
#line 1607
        d = this;
#line 1607
        while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 1610
          tmp___9 = find_percent(d->name);
#line 1610
          percent = tmp___9;
#line 1611
          if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 1612
            goto __Cont___0;
          }
#line 1613
          o = patsubst_expand(buffer, name, pattern, d->name, pattern_percent, percent);
#line 1617
          if ((unsigned long )o == (unsigned long )buffer) {
#line 1618
            tmp___10 = dcgettext((char const   *)((void *)0), "target `%s\' leaves prerequisite pattern empty",
                                 5);
#line 1618
            fatal(flocp, (char const   *)tmp___10, name);
          }
#line 1621
          free((void *)d->name);
#line 1622
          d->name = savestring((char const   *)buffer, (unsigned int )(o - buffer));
          __Cont___0: /* CIL Label */ 
#line 1607
          d = d->next;
        }
      } else {
#line 1596
        tmp___7 = dcgettext((char const   *)((void *)0), "target `%s\' doesn\'t match the target pattern",
                            5);
#line 1596
        error(flocp, (char const   *)tmp___7, name);
#line 1598
        this = (struct dep *)0;
      }
    }
#line 1627
    if (! two_colon) {
#line 1631
      f = enter_file(name);
#line 1633
      if (f->double_colon) {
#line 1634
        tmp___12 = dcgettext((char const   *)((void *)0), "target file `%s\' has both : and :: entries",
                             5);
#line 1634
        fatal(flocp, (char const   *)tmp___12, f->name);
      }
#line 1639
      if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1639
        if ((unsigned long )cmds == (unsigned long )f->cmds) {
#line 1640
          tmp___13 = dcgettext((char const   *)((void *)0), "target `%s\' given more than once in the same rule.",
                               5);
#line 1640
          error(flocp, (char const   *)tmp___13, f->name);
        } else {
#line 1639
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1647
      if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1647
        if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
#line 1647
          if (f->is_target) {
#line 1649
            tmp___14 = dcgettext((char const   *)((void *)0), "warning: overriding commands for target `%s\'",
                                 5);
#line 1649
            error((struct floc  const  *)(& cmds->fileinfo), (char const   *)tmp___14,
                  f->name);
#line 1652
            tmp___15 = dcgettext((char const   *)((void *)0), "warning: ignoring old commands for target `%s\'",
                                 5);
#line 1652
            error((struct floc  const  *)(& (f->cmds)->fileinfo), (char const   *)tmp___15,
                  f->name);
          }
        }
      }
#line 1657
      f->is_target = 1U;
#line 1660
      if ((unsigned long )f == (unsigned long )default_file) {
#line 1660
        if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
#line 1660
          if ((unsigned long )cmds == (unsigned long )((struct commands *)0)) {
#line 1661
            f->cmds = (struct commands *)0;
          }
        }
      }
#line 1662
      if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1663
        f->cmds = cmds;
      }
#line 1666
      if ((unsigned long )f == (unsigned long )suffix_file) {
#line 1666
        if ((unsigned long )this == (unsigned long )((struct dep *)0)) {
#line 1668
          d = f->deps;
#line 1669
          while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 1671
            nextd = d->next;
#line 1672
            free((void *)d->name);
#line 1673
            free((void *)((char *)d));
#line 1674
            d = nextd;
          }
#line 1676
          f->deps = (struct dep *)0;
        } else {
#line 1666
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1678
      if ((unsigned long )f->deps != (unsigned long )((struct dep *)0)) {
#line 1683
        if ((unsigned long )cmds != (unsigned long )((struct commands *)0)) {
#line 1689
          firstdeps = this;
#line 1690
          moredeps = f->deps;
        } else {
#line 1695
          firstdeps = f->deps;
#line 1696
          moredeps = this;
        }
#line 1699
        if ((unsigned long )firstdeps == (unsigned long )((struct dep *)0)) {
#line 1700
          firstdeps = moredeps;
        } else {
#line 1703
          d = firstdeps;
#line 1704
          while ((unsigned long )d->next != (unsigned long )((struct dep *)0)) {
#line 1705
            d = d->next;
          }
#line 1706
          d->next = moredeps;
        }
#line 1709
        f->deps = firstdeps;
      } else {
#line 1712
        f->deps = this;
      }
#line 1717
      if ((unsigned long )pattern != (unsigned long )((char *)0)) {
#line 1720
        tmp___16 = variable_expand((char *)"");
#line 1720
        buffer___0 = tmp___16;
#line 1721
        tmp___17 = patsubst_expand(buffer___0, name, pattern, percent___0, pattern_percent,
                                   percent___0);
#line 1721
        o___0 = tmp___17;
#line 1723
        f->stem = savestring((char const   *)buffer___0, (unsigned int )(o___0 - buffer___0));
      }
    } else {
#line 1730
      f = lookup_file(name);
#line 1733
      if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 1733
        if (f->is_target) {
#line 1733
          if (! f->double_colon) {
#line 1734
            tmp___18 = dcgettext((char const   *)((void *)0), "target file `%s\' has both : and :: entries",
                                 5);
#line 1734
            fatal(flocp, (char const   *)tmp___18, f->name);
          }
        }
      }
#line 1736
      f = enter_file(name);
#line 1741
      if ((unsigned long )f->double_colon == (unsigned long )((struct file *)0)) {
#line 1744
        f->double_colon = f;
      }
#line 1745
      f->is_target = 1U;
#line 1746
      f->deps = this;
#line 1747
      f->cmds = cmds;
    }
#line 1751
    if ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 1751
      if ((unsigned long )name != (unsigned long )f->name) {
#line 1751
        if ((unsigned long )name < (unsigned long )f->name) {
#line 1754
          free((void *)name);
#line 1755
          name = f->name;
        } else {
#line 1751
          tmp___19 = strlen((char const   *)f->name);
#line 1751
          if ((unsigned long )name > (unsigned long )(f->name + tmp___19)) {
#line 1754
            free((void *)name);
#line 1755
            name = f->name;
          }
        }
      }
    }
#line 1760
    if ((unsigned long )default_goal_file == (unsigned long )((struct file *)0)) {
#line 1760
      if (set_default) {
#line 1760
        if ((int )*name != 46) {
#line 1760
          goto _L___1;
        } else {
#line 1760
          tmp___33 = strchr((char const   *)name, '/');
#line 1760
          if ((unsigned long )tmp___33 != (unsigned long )((char *)0)) {
            _L___1: /* CIL Label */ 
#line 1767
            reject = 0;
#line 1772
            d = suffix_file->deps;
#line 1772
            while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 1775
              if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1775
                tmp___20 = (d->file)->name;
              } else {
#line 1775
                tmp___20 = d->name;
              }
#line 1775
              if ((int )*tmp___20 != 46) {
#line 1775
                if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1775
                  tmp___21 = (d->file)->name;
                } else {
#line 1775
                  tmp___21 = d->name;
                }
#line 1775
                if ((unsigned long )name == (unsigned long )tmp___21) {
#line 1777
                  reject = 1;
#line 1778
                  break;
                } else {
#line 1775
                  if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1775
                    tmp___22 = (d->file)->name;
                  } else {
#line 1775
                    tmp___22 = d->name;
                  }
#line 1775
                  if ((int )*name == (int )*tmp___22) {
#line 1775
                    if ((int )*name == 0) {
#line 1777
                      reject = 1;
#line 1778
                      break;
                    } else {
#line 1775
                      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1775
                        tmp___23 = (d->file)->name;
                      } else {
#line 1775
                        tmp___23 = d->name;
                      }
#line 1775
                      tmp___24 = strcmp((char const   *)(name + 1), (char const   *)(tmp___23 + 1));
#line 1775
                      if (! tmp___24) {
#line 1777
                        reject = 1;
#line 1778
                        break;
                      }
                    }
                  }
                }
              }
#line 1780
              d2 = suffix_file->deps;
#line 1780
              while ((unsigned long )d2 != (unsigned long )((struct dep *)0)) {
#line 1782
                if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 1782
                  tmp___25 = (d2->file)->name;
                } else {
#line 1782
                  tmp___25 = d2->name;
                }
#line 1782
                tmp___26 = strlen((char const   *)tmp___25);
#line 1782
                len = (unsigned int )tmp___26;
#line 1783
                if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 1783
                  tmp___27 = (d2->file)->name;
                } else {
#line 1783
                  tmp___27 = d2->name;
                }
#line 1783
                tmp___28 = strncmp((char const   *)name, (char const   *)tmp___27,
                                   (size_t )len);
#line 1783
                if (! (tmp___28 == 0)) {
#line 1784
                  goto __Cont___1;
                }
#line 1785
                if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1785
                  tmp___29 = (d->file)->name;
                } else {
#line 1785
                  tmp___29 = d->name;
                }
#line 1785
                if ((unsigned long )(name + len) == (unsigned long )tmp___29) {
#line 1787
                  reject = 1;
#line 1788
                  break;
                } else {
#line 1785
                  if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1785
                    tmp___30 = (d->file)->name;
                  } else {
#line 1785
                    tmp___30 = d->name;
                  }
#line 1785
                  if ((int )*(name + len) == (int )*tmp___30) {
#line 1785
                    if ((int )*(name + len) == 0) {
#line 1787
                      reject = 1;
#line 1788
                      break;
                    } else {
#line 1785
                      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 1785
                        tmp___31 = (d->file)->name;
                      } else {
#line 1785
                        tmp___31 = d->name;
                      }
#line 1785
                      tmp___32 = strcmp((char const   *)((name + len) + 1), (char const   *)(tmp___31 + 1));
#line 1785
                      if (! tmp___32) {
#line 1787
                        reject = 1;
#line 1788
                        break;
                      }
                    }
                  }
                }
                __Cont___1: /* CIL Label */ 
#line 1780
                d2 = d2->next;
              }
#line 1791
              if (reject) {
#line 1792
                break;
              }
#line 1772
              d = d->next;
            }
#line 1795
            if (! reject) {
#line 1796
              default_goal_file = f;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1537
    filenames = nextf;
  }
#line 1800
  if (implicit) {
#line 1802
    *(targets + target_idx) = (char *)0;
#line 1803
    *(target_percents + target_idx) = (char *)0;
#line 1804
    create_pattern_rule(targets, target_percents, two_colon, deps, cmds, 1);
#line 1805
    free((void *)((char *)target_percents));
  }
#line 1807
  return;
}
}
#line 1815 "read.c"
char *find_char_unquote(char *string , char *stopchars , int blank ) 
{ 
  unsigned int string_len ;
  register char *p ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  register int i ;
  size_t tmp___1 ;

  {
#line 1821
  string_len = 0U;
#line 1822
  p = string;
#line 1824
  while (1) {
#line 1826
    while (1) {
#line 1826
      if ((int )*p != 0) {
#line 1826
        tmp = strchr((char const   *)stopchars, (int )*p);
#line 1826
        if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 1826
          if (! (! blank)) {
#line 1826
            tmp___0 = __ctype_b_loc();
#line 1826
            if ((int const   )*(*tmp___0 + (int )*p) & 1) {
#line 1826
              break;
            }
          }
        } else {
#line 1826
          break;
        }
      } else {
#line 1826
        break;
      }
#line 1828
      p ++;
    }
#line 1829
    if ((int )*p == 0) {
#line 1830
      break;
    }
#line 1832
    if ((unsigned long )p > (unsigned long )string) {
#line 1832
      if ((int )*(p + -1) == 92) {
#line 1835
        i = -2;
#line 1836
        while (1) {
#line 1836
          if ((unsigned long )(p + i) >= (unsigned long )string) {
#line 1836
            if (! ((int )*(p + i) == 92)) {
#line 1836
              break;
            }
          } else {
#line 1836
            break;
          }
#line 1837
          i --;
        }
#line 1838
        i ++;
#line 1840
        if (string_len == 0U) {
#line 1841
          tmp___1 = strlen((char const   *)string);
#line 1841
          string_len = (unsigned int )tmp___1;
        }
#line 1844
        memmove((void *)(p + i), (void const   *)(p + i / 2), (size_t )((((long )string_len - (p - string)) - (long )(i / 2)) + 1L));
#line 1845
        p += i / 2;
#line 1846
        if (i % 2 == 0) {
#line 1849
          return (p);
        }
      } else {
#line 1855
        return (p);
      }
    } else {
#line 1855
      return (p);
    }
  }
#line 1859
  return ((char *)0);
}
}
#line 1864 "read.c"
char *find_percent(char *pattern ) 
{ 
  char *tmp ;

  {
#line 1868
  tmp = find_char_unquote(pattern, (char *)"%", 0);
#line 1868
  return (tmp);
}
}
#line 1884 "read.c"
struct nameseq *parse_file_seq(char **stringp , int stopchar , unsigned int size ,
                               int strip ) 
{ 
  register struct nameseq *new ;
  register struct nameseq *new1 ;
  register struct nameseq *lastnew1 ;
  register char *p ;
  char *q ;
  char *name ;
  char stopchars[3] ;
  size_t tmp ;
  char *tmp___0 ;
  struct nameseq *n ;
  struct nameseq *lastn ;
  char *paren ;
  char *libname ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1891
  new = (struct nameseq *)0;
#line 1893
  p = *stringp;
#line 1903
  stopchars[0] = (char )stopchar;
#line 1904
  stopchars[1] = (char )'\000';
#line 1907
  while (1) {
#line 1910
    p = next_token(p);
#line 1911
    if ((int )*p == 0) {
#line 1912
      break;
    }
#line 1913
    if ((int )*p == stopchar) {
#line 1914
      break;
    }
#line 1917
    q = p;
#line 1918
    p = find_char_unquote(q, stopchars, 1);
#line 1942
    if ((unsigned long )p == (unsigned long )((char *)0)) {
#line 1943
      tmp = strlen((char const   *)q);
#line 1943
      p = q + tmp;
    }
#line 1945
    if (strip) {
#line 1951
      while (1) {
#line 1951
        if (p - q > 2L) {
#line 1951
          if ((int )*(q + 0) == 46) {
#line 1951
            if (! ((int )*(q + 1) == 47)) {
#line 1951
              break;
            }
          } else {
#line 1951
            break;
          }
        } else {
#line 1951
          break;
        }
#line 1954
        q += 2;
#line 1955
        while (1) {
#line 1955
          if ((unsigned long )q < (unsigned long )p) {
#line 1955
            if (! ((int )*q == 47)) {
#line 1955
              break;
            }
          } else {
#line 1955
            break;
          }
#line 1957
          q ++;
        }
      }
    }
#line 1962
    if ((unsigned long )q == (unsigned long )p) {
#line 1970
      name = savestring("./", 2U);
    } else {
#line 1999
      name = savestring((char const   *)q, (unsigned int )(p - q));
    }
#line 2003
    tmp___0 = xmalloc(size);
#line 2003
    new1 = (struct nameseq *)tmp___0;
#line 2004
    new1->name = name;
#line 2005
    new1->next = new;
#line 2006
    new = new1;
  }
#line 2016
  new1 = new;
#line 2017
  lastnew1 = (struct nameseq *)0;
#line 2018
  while ((unsigned long )new1 != (unsigned long )((struct nameseq *)0)) {
#line 2019
    if ((int )*(new1->name + 0) != 40) {
#line 2019
      tmp___2 = strlen((char const   *)new1->name);
#line 2019
      if ((int )*(new1->name + (tmp___2 - 1UL)) == 41) {
#line 2019
        tmp___3 = strchr((char const   *)new1->name, '(');
#line 2019
        if ((unsigned long )tmp___3 == (unsigned long )((char *)0)) {
#line 2026
          n = new1->next;
#line 2026
          lastn = new1;
#line 2027
          paren = (char *)0;
#line 2028
          while (1) {
#line 2028
            if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
#line 2028
              paren = strchr((char const   *)n->name, '(');
#line 2028
              if (! ((unsigned long )paren == (unsigned long )((char *)0))) {
#line 2028
                break;
              }
            } else {
#line 2028
              break;
            }
#line 2030
            lastn = n;
#line 2031
            n = n->next;
          }
#line 2033
          if ((unsigned long )n != (unsigned long )((struct nameseq *)0)) {
#line 2033
            if ((int )*(n->name + 0) != 40) {
#line 2045
              paren ++;
#line 2046
              tmp___1 = __builtin_alloca((unsigned long )((paren - n->name) + 1L));
#line 2046
              libname = (char *)tmp___1;
#line 2047
              memmove((void *)libname, (void const   *)n->name, (size_t )(paren - n->name));
#line 2048
              *(libname + (paren - n->name)) = (char )'\000';
#line 2050
              if ((int )*paren == 0) {
#line 2054
                lastn->next = n->next;
#line 2055
                free((void *)n->name);
#line 2056
                free((void *)((char *)n));
#line 2058
                n = lastn->next;
              } else {
#line 2063
                name = concat(libname, paren, (char *)")");
#line 2064
                free((void *)n->name);
#line 2065
                n->name = name;
              }
#line 2068
              if ((int )*(new1->name + 1) == 0) {
#line 2072
                if ((unsigned long )lastnew1 == (unsigned long )((struct nameseq *)0)) {
#line 2073
                  new = new1->next;
                } else {
#line 2075
                  lastnew1->next = new1->next;
                }
#line 2076
                lastn = new1;
#line 2077
                new1 = new1->next;
#line 2078
                free((void *)lastn->name);
#line 2079
                free((void *)((char *)lastn));
              } else {
#line 2084
                name = concat(libname, new1->name, (char *)"");
#line 2085
                free((void *)new1->name);
#line 2086
                new1->name = name;
#line 2087
                new1 = new1->next;
              }
#line 2094
              while ((unsigned long )new1 != (unsigned long )n) {
#line 2096
                name = concat(libname, new1->name, (char *)")");
#line 2097
                free((void *)new1->name);
#line 2098
                new1->name = name;
#line 2099
                lastnew1 = new1;
#line 2100
                new1 = new1->next;
              }
            } else {
#line 2106
              lastnew1 = new1;
#line 2107
              new1 = new1->next;
            }
          } else {
#line 2106
            lastnew1 = new1;
#line 2107
            new1 = new1->next;
          }
        } else {
#line 2112
          lastnew1 = new1;
#line 2113
          new1 = new1->next;
        }
      } else {
#line 2112
        lastnew1 = new1;
#line 2113
        new1 = new1->next;
      }
    } else {
#line 2112
      lastnew1 = new1;
#line 2113
      new1 = new1->next;
    }
  }
#line 2118
  *stringp = p;
#line 2119
  return (new);
}
}
#line 2127 "read.c"
static unsigned long readline(struct linebuffer *linebuffer , FILE *stream , struct floc  const  *flocp ) 
{ 
  char *buffer ;
  register char *p ;
  register char *end ;
  register int len ;
  register int lastlen ;
  register char *p2 ;
  register unsigned int nlines ;
  register int backslash ;
  size_t tmp ;
  char *tmp___0 ;
  register unsigned int p_off ;
  char *tmp___1 ;
  register unsigned int p_off___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 2133
  buffer = linebuffer->buffer;
#line 2134
  p = linebuffer->buffer;
#line 2135
  end = p + linebuffer->size;
#line 2136
  lastlen = 0;
#line 2138
  nlines = 0U;
#line 2141
  *p = (char )'\000';
#line 2143
  while (1) {
#line 2143
    tmp___3 = fgets((char * __restrict  )p, (int )(end - p), (FILE * __restrict  )stream);
#line 2143
    if (! ((unsigned long )tmp___3 != (unsigned long )((char *)0))) {
#line 2143
      break;
    }
#line 2145
    tmp = strlen((char const   *)p);
#line 2145
    len = (int )tmp;
#line 2146
    if (len == 0) {
#line 2153
      tmp___0 = dcgettext((char const   *)((void *)0), "warning: NUL character seen; rest of line ignored",
                          5);
#line 2153
      error(flocp, (char const   *)tmp___0);
#line 2154
      *(p + 0) = (char )'\n';
#line 2155
      len = 1;
    }
#line 2158
    p += len;
#line 2159
    if ((int )*(p + -1) != 10) {
#line 2162
      p_off = (unsigned int )(p - buffer);
#line 2163
      linebuffer->size *= 2U;
#line 2164
      tmp___1 = xrealloc(buffer, linebuffer->size);
#line 2164
      buffer = tmp___1;
#line 2165
      p = buffer + p_off;
#line 2166
      end = buffer + linebuffer->size;
#line 2167
      linebuffer->buffer = buffer;
#line 2168
      *p = (char )'\000';
#line 2169
      lastlen = len;
#line 2170
      continue;
    }
#line 2173
    nlines ++;
#line 2178
    if (len > 1) {
#line 2178
      if ((int )*(p + -2) == 13) {
#line 2180
        len --;
#line 2181
        p --;
#line 2182
        *(p + -1) = (char )'\n';
      }
    }
#line 2186
    if (len == 1) {
#line 2186
      if ((unsigned long )p > (unsigned long )buffer) {
#line 2194
        len += lastlen;
      }
    }
#line 2195
    lastlen = len;
#line 2196
    backslash = 0;
#line 2197
    p2 = p - 2;
#line 2197
    while (1) {
#line 2197
      len --;
#line 2197
      if (! (len > 0)) {
#line 2197
        break;
      }
#line 2199
      if ((int )*p2 == 92) {
#line 2200
        backslash = ! backslash;
      } else {
#line 2202
        break;
      }
#line 2197
      p2 --;
    }
#line 2205
    if (! backslash) {
#line 2207
      *(p + -1) = (char )'\000';
#line 2208
      break;
    }
#line 2211
    if (end - p <= 1L) {
#line 2214
      p_off___0 = (unsigned int )(p - buffer);
#line 2215
      linebuffer->size *= 2U;
#line 2216
      tmp___2 = xrealloc(buffer, linebuffer->size);
#line 2216
      buffer = tmp___2;
#line 2217
      p = buffer + p_off___0;
#line 2218
      end = buffer + linebuffer->size;
#line 2219
      linebuffer->buffer = buffer;
    }
  }
#line 2223
  tmp___4 = ferror(stream);
#line 2223
  if (tmp___4) {
#line 2224
    pfatal_with_name((char *)flocp->filenm);
  }
#line 2226
  return ((unsigned long )nlines);
}
}
#line 2248 "read.c"
static enum make_word_type get_next_mword(char *buffer , char *delim , char **startp ,
                                          unsigned int *length___0 ) 
{ 
  enum make_word_type wtype ;
  char *p ;
  char *beg ;
  char c ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char closeparen ;
  int count ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 2255
  wtype = (enum make_word_type )0;
#line 2256
  p = buffer;
#line 2260
  while (1) {
#line 2260
    tmp = __ctype_b_loc();
#line 2260
    if (! ((int const   )*(*tmp + (int )*p) & 1)) {
#line 2260
      break;
    }
#line 2261
    p ++;
  }
#line 2263
  beg = p;
#line 2264
  tmp___0 = p;
#line 2264
  p ++;
#line 2264
  c = *tmp___0;
#line 2265
  switch ((int )c) {
  case 0: 
#line 2268
  wtype = (enum make_word_type )1;
#line 2269
  break;
  case 35: 
#line 2272
  wtype = (enum make_word_type )7;
#line 2273
  break;
  case 59: 
#line 2276
  wtype = (enum make_word_type )6;
#line 2277
  break;
  case 61: 
#line 2280
  wtype = (enum make_word_type )8;
#line 2281
  break;
  case 58: 
#line 2284
  wtype = (enum make_word_type )4;
#line 2285
  switch ((int )*p) {
  case 58: 
#line 2288
  p ++;
#line 2289
  wtype = (enum make_word_type )5;
#line 2290
  break;
  case 61: 
#line 2293
  p ++;
#line 2294
  wtype = (enum make_word_type )8;
#line 2295
  break;
  }
#line 2297
  break;
  case 63: 
  case 43: 
#line 2301
  if ((int )*p == 61) {
#line 2303
    p ++;
#line 2304
    wtype = (enum make_word_type )8;
#line 2305
    break;
  }
  default: 
#line 2309
  if (delim) {
#line 2309
    tmp___1 = strchr((char const   *)delim, (int )c);
#line 2309
    if (tmp___1) {
#line 2310
      wtype = (enum make_word_type )2;
    }
  }
#line 2311
  break;
  }
#line 2315
  if ((unsigned int )wtype != 0U) {
#line 2316
    goto done;
  }
#line 2324
  wtype = (enum make_word_type )2;
#line 2327
  while (1) {
#line 2332
    switch ((int )c) {
    case 35: 
    case 61: 
    case 9: 
    case 32: 
    case 0: 
#line 2339
    goto done_word;
    case 58: 
#line 2350
    goto done_word;
    case 36: 
#line 2353
    tmp___2 = p;
#line 2353
    p ++;
#line 2353
    c = *tmp___2;
#line 2354
    if ((int )c == 36) {
#line 2355
      break;
    }
#line 2359
    wtype = (enum make_word_type )3;
#line 2361
    if ((int )c == 40) {
#line 2362
      closeparen = (char )')';
    } else
#line 2363
    if ((int )c == 123) {
#line 2364
      closeparen = (char )'}';
    } else {
#line 2367
      break;
    }
#line 2369
    count = 0;
#line 2369
    while ((int )*p != 0) {
#line 2371
      if ((int )*p == (int )c) {
#line 2372
        count ++;
      } else
#line 2373
      if ((int )*p == (int )closeparen) {
#line 2373
        count --;
#line 2373
        if (count < 0) {
#line 2375
          p ++;
#line 2376
          break;
        }
      }
#line 2369
      p ++;
    }
#line 2379
    break;
    case 43: 
    case 63: 
#line 2383
    if ((int )*p == 61) {
#line 2384
      goto done_word;
    }
#line 2385
    break;
    case 92: 
#line 2388
    switch ((int )*p) {
    case 92: 
    case 61: 
    case 59: 
    case 58: 
#line 2394
    p ++;
#line 2395
    break;
    }
#line 2397
    break;
    default: 
#line 2400
    if (delim) {
#line 2400
      tmp___3 = strchr((char const   *)delim, (int )c);
#line 2400
      if (tmp___3) {
#line 2401
        goto done_word;
      }
    }
#line 2402
    break;
    }
#line 2405
    tmp___4 = p;
#line 2405
    p ++;
#line 2405
    c = *tmp___4;
  }
  done_word: 
#line 2408
  p --;
  done: 
#line 2411
  if (startp) {
#line 2412
    *startp = beg;
  }
#line 2413
  if (length___0) {
#line 2414
    *length___0 = (unsigned int )(p - beg);
  }
#line 2415
  return (wtype);
}
}
#line 2421 "read.c"
void construct_include_path(char **arg_dirs ) 
{ 
  register unsigned int i ;
  struct stat stbuf ;
  register unsigned int defsize ;
  register unsigned int max ;
  register char **dirs___0 ;
  char *tmp ;
  register unsigned int idx ;
  char *dir ;
  char **tmp___0 ;
  char *expanded ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned int len ;
  size_t tmp___7 ;

  {
#line 2433
  defsize = (unsigned int )(sizeof(default_include_directories) / sizeof(default_include_directories[0]));
#line 2435
  max = 5U;
#line 2436
  tmp = xmalloc((unsigned int )((unsigned long )(5U + defsize) * sizeof(char *)));
#line 2436
  dirs___0 = (char **)tmp;
#line 2437
  idx = 0U;
#line 2446
  if ((unsigned long )arg_dirs != (unsigned long )((char **)0)) {
#line 2447
    while ((unsigned long )*arg_dirs != (unsigned long )((char *)0)) {
#line 2449
      tmp___0 = arg_dirs;
#line 2449
      arg_dirs ++;
#line 2449
      dir = *tmp___0;
#line 2451
      if ((int )*(dir + 0) == 126) {
#line 2453
        tmp___1 = tilde_expand(dir);
#line 2453
        expanded = tmp___1;
#line 2454
        if ((unsigned long )expanded != (unsigned long )((char *)0)) {
#line 2455
          dir = expanded;
        }
      }
#line 2458
      tmp___4 = stat((char const   * __restrict  )dir, (struct stat * __restrict  )(& stbuf));
#line 2458
      if (tmp___4 == 0) {
#line 2458
        if ((stbuf.st_mode & 61440U) == 16384U) {
#line 2460
          if (idx == max - 1U) {
#line 2462
            max += 5U;
#line 2463
            tmp___2 = xrealloc((char *)dirs___0, (unsigned int )((unsigned long )(max + defsize) * sizeof(char *)));
#line 2463
            dirs___0 = (char **)tmp___2;
          }
#line 2466
          tmp___3 = idx;
#line 2466
          idx ++;
#line 2466
          *(dirs___0 + tmp___3) = dir;
        } else {
#line 2458
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2468
      if ((unsigned long )dir != (unsigned long )*(arg_dirs + -1)) {
#line 2469
        free((void *)dir);
      }
    }
  }
#line 2490
  i = 0U;
#line 2490
  while ((unsigned long )default_include_directories[i] != (unsigned long )((char *)0)) {
#line 2491
    tmp___6 = stat((char const   * __restrict  )default_include_directories[i], (struct stat * __restrict  )(& stbuf));
#line 2491
    if (tmp___6 == 0) {
#line 2491
      if ((stbuf.st_mode & 61440U) == 16384U) {
#line 2493
        tmp___5 = idx;
#line 2493
        idx ++;
#line 2493
        *(dirs___0 + tmp___5) = default_include_directories[i];
      }
    }
#line 2490
    i ++;
  }
#line 2495
  *(dirs___0 + idx) = (char *)0;
#line 2499
  max_incl_len = 0U;
#line 2500
  i = 0U;
#line 2500
  while (i < idx) {
#line 2502
    tmp___7 = strlen((char const   *)*(dirs___0 + i));
#line 2502
    len = (unsigned int )tmp___7;
#line 2504
    if ((int )*(*(dirs___0 + i) + (len - 1U)) == 47) {
#line 2507
      *(dirs___0 + i) = savestring((char const   *)*(dirs___0 + i), len - 1U);
    }
#line 2508
    if (len > max_incl_len) {
#line 2509
      max_incl_len = len;
    }
#line 2500
    i ++;
  }
#line 2512
  include_directories___0 = dirs___0;
#line 2513
  return;
}
}
#line 2518 "read.c"
char *tilde_expand(char *name ) 
{ 
  char *home_dir ;
  int is_variable ;
  int save ;
  char *logname ;
  char *tmp ;
  struct passwd *p ;
  struct passwd *tmp___0 ;
  char *new ;
  char *tmp___1 ;
  struct passwd *pwent ;
  char *userend ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 2523
  if ((int )*(name + 1) == 47) {
#line 2523
    goto _L___0;
  } else
#line 2523
  if ((int )*(name + 1) == 0) {
    _L___0: /* CIL Label */ 
#line 2531
    save = warn_undefined_variables_flag;
#line 2532
    warn_undefined_variables_flag = 0;
#line 2534
    home_dir = allocated_variable_expand_for_file((char *)"$(HOME)", (struct file *)0);
#line 2536
    warn_undefined_variables_flag = save;
#line 2539
    is_variable = (int )*(home_dir + 0) != 0;
#line 2540
    if (! is_variable) {
#line 2542
      free((void *)home_dir);
#line 2543
      home_dir = getenv("HOME");
    }
#line 2546
    if ((unsigned long )home_dir == (unsigned long )((char *)0)) {
#line 2546
      goto _L;
    } else
#line 2546
    if ((int )*(home_dir + 0) == 0) {
      _L: /* CIL Label */ 
#line 2549
      tmp = getlogin();
#line 2549
      logname = tmp;
#line 2550
      home_dir = (char *)0;
#line 2551
      if ((unsigned long )logname != (unsigned long )((char *)0)) {
#line 2553
        tmp___0 = getpwnam((char const   *)logname);
#line 2553
        p = tmp___0;
#line 2554
        if ((unsigned long )p != (unsigned long )((struct passwd *)0)) {
#line 2555
          home_dir = p->pw_dir;
        }
      }
    }
#line 2559
    if ((unsigned long )home_dir != (unsigned long )((char *)0)) {
#line 2561
      tmp___1 = concat(home_dir, (char *)"", name + 1);
#line 2561
      new = tmp___1;
#line 2562
      if (is_variable) {
#line 2563
        free((void *)home_dir);
      }
#line 2564
      return (new);
    }
  } else {
#line 2571
    tmp___2 = strchr((char const   *)(name + 1), '/');
#line 2571
    userend = tmp___2;
#line 2572
    if ((unsigned long )userend != (unsigned long )((char *)0)) {
#line 2573
      *userend = (char )'\000';
    }
#line 2574
    pwent = getpwnam((char const   *)(name + 1));
#line 2575
    if ((unsigned long )pwent != (unsigned long )((struct passwd *)0)) {
#line 2577
      if ((unsigned long )userend == (unsigned long )((char *)0)) {
#line 2578
        tmp___3 = xstrdup((char const   *)pwent->pw_dir);
#line 2578
        return (tmp___3);
      } else {
#line 2580
        tmp___4 = concat(pwent->pw_dir, (char *)"/", userend + 1);
#line 2580
        return (tmp___4);
      }
    } else
#line 2582
    if ((unsigned long )userend != (unsigned long )((char *)0)) {
#line 2583
      *userend = (char )'/';
    }
  }
#line 2587
  return ((char *)0);
}
}
#line 2600 "read.c"
struct nameseq *multi_glob(struct nameseq *chain , unsigned int size ) 
{ 
  register struct nameseq *new ;
  register struct nameseq *old ;
  struct nameseq *nexto ;
  glob_t gl ;
  char *memname ;
  char *newname ;
  char *tmp ;
  char *arname ;
  int tmp___0 ;
  int tmp___1 ;
  register int i ;
  struct nameseq *found ;
  struct nameseq *tmp___2 ;
  struct nameseq *elt ;
  char *tmp___3 ;
  unsigned int alen ;
  size_t tmp___4 ;
  unsigned int mlen ;
  size_t tmp___5 ;
  char *tmp___6 ;
  struct nameseq *f ;
  struct nameseq *elt___0 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 2606
  new = (struct nameseq *)0;
#line 2611
  dir_setup_glob(& gl);
#line 2613
  old = chain;
#line 2613
  while ((unsigned long )old != (unsigned long )((struct nameseq *)0)) {
#line 2619
    nexto = old->next;
#line 2621
    if ((int )*(old->name + 0) == 126) {
#line 2623
      tmp = tilde_expand(old->name);
#line 2623
      newname = tmp;
#line 2624
      if ((unsigned long )newname != (unsigned long )((char *)0)) {
#line 2626
        free((void *)old->name);
#line 2627
        old->name = newname;
      }
    }
#line 2632
    tmp___0 = ar_name(old->name);
#line 2632
    if (tmp___0) {
#line 2640
      ar_parse_name(old->name, & arname, & memname);
#line 2641
      free((void *)old->name);
#line 2642
      old->name = arname;
    } else {
#line 2645
      memname = (char *)0;
    }
#line 2648
    tmp___1 = glob((char const   *)old->name, (1 << 4) | (1 << 9), (int (*)(char const   * ,
                                                                            int  ))((void *)0),
                   & gl);
#line 2648
    switch (tmp___1) {
    case 0: 
#line 2652
    i = (int )gl.gl_pathc;
#line 2653
    while (1) {
#line 2653
      tmp___8 = i;
#line 2653
      i --;
#line 2653
      if (! (tmp___8 > 0)) {
#line 2653
        break;
      }
#line 2656
      if ((unsigned long )memname != (unsigned long )((char *)0)) {
#line 2659
        tmp___2 = ar_glob(*(gl.gl_pathv + i), memname, size);
#line 2659
        found = tmp___2;
#line 2661
        if ((unsigned long )found == (unsigned long )((struct nameseq *)0)) {
#line 2664
          tmp___3 = xmalloc(size);
#line 2664
          elt = (struct nameseq *)tmp___3;
#line 2666
          tmp___4 = strlen((char const   *)*(gl.gl_pathv + i));
#line 2666
          alen = (unsigned int )tmp___4;
#line 2667
          tmp___5 = strlen((char const   *)memname);
#line 2667
          mlen = (unsigned int )tmp___5;
#line 2668
          tmp___6 = xmalloc(((alen + 1U) + mlen) + 2U);
#line 2668
          elt->name = tmp___6;
#line 2669
          memmove((void *)elt->name, (void const   *)*(gl.gl_pathv + i), (size_t )alen);
#line 2670
          *(elt->name + alen) = (char )'(';
#line 2671
          memmove((void *)(elt->name + (alen + 1U)), (void const   *)memname, (size_t )mlen);
#line 2672
          *(elt->name + ((alen + 1U) + mlen)) = (char )')';
#line 2673
          *(elt->name + (((alen + 1U) + mlen) + 1U)) = (char )'\000';
#line 2674
          elt->next = new;
#line 2675
          new = elt;
        } else {
#line 2680
          f = found;
#line 2681
          while ((unsigned long )f->next != (unsigned long )((struct nameseq *)0)) {
#line 2682
            f = f->next;
          }
#line 2686
          f->next = new;
#line 2687
          new = found;
        }
#line 2690
        free((void *)memname);
      } else {
#line 2695
        tmp___7 = xmalloc(size);
#line 2695
        elt___0 = (struct nameseq *)tmp___7;
#line 2696
        elt___0->name = xstrdup((char const   *)*(gl.gl_pathv + i));
#line 2697
        elt___0->next = new;
#line 2698
        new = elt___0;
      }
    }
#line 2701
    globfree(& gl);
#line 2702
    free((void *)old->name);
#line 2703
    free((void *)((char *)old));
#line 2704
    break;
    case 1: 
#line 2708
    tmp___9 = dcgettext((char const   *)((void *)0), "virtual memory exhausted", 5);
#line 2708
    fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___9);
#line 2709
    break;
    default: 
#line 2712
    old->next = new;
#line 2713
    new = old;
#line 2714
    break;
    }
#line 2613
    old = nexto;
  }
#line 2718
  return (new);
}
}
#line 1 "remake.o"
#pragma merger("0","/tmp/cil-pzv2IiRZ.i","-g,-O0")
#line 433 "make.h"
int gpath_search(char *file , int len ) ;
#line 59 "remake.c"
unsigned int commands_started  =    0U;
#line 61
static int update_file(struct file *file , unsigned int depth ) ;
#line 62
static int update_file_1(struct file *file , unsigned int depth ) ;
#line 63
static int check_dep(struct file *file , unsigned int depth , uintmax_t this_mtime ,
                     int *must_make_ptr ) ;
#line 64
static int touch_file(struct file *file ) ;
#line 65
static void remake_file(struct file *file ) ;
#line 66
static uintmax_t name_mtime(char *name ) ;
#line 67
static int library_search(char **lib , uintmax_t *mtime_ptr ) ;
#line 77 "remake.c"
int update_goal_chain(struct dep *goals___0 , int makefiles___0 ) 
{ 
  int t ;
  int q ;
  int n ;
  unsigned int j ;
  int status ;
  struct dep *g ;
  register struct dep *g___0 ;
  register struct dep *lastgoal___0 ;
  struct file *file ;
  int stop ;
  int any_not_updated ;
  unsigned int ocommands_started ;
  int x ;
  int tmp ;
  int tmp___0 ;
  uintmax_t mtime ;
  uintmax_t tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t tmp___3 ;
  uintmax_t tmp___4 ;
  uintmax_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 82
  t = touch_flag;
#line 82
  q = question_flag;
#line 82
  n = just_print_flag;
#line 83
  j = job_slots;
#line 84
  status = -1;
#line 91
  goals___0 = copy_dep_chain(goals___0);
#line 100
  g = goals___0;
#line 100
  while ((unsigned long )g != (unsigned long )((struct dep *)0)) {
#line 101
    g->changed = 0;
#line 100
    g = g->next;
  }
#line 105
  considered = 1U;
#line 109
  while ((unsigned long )goals___0 != (unsigned long )((struct dep *)0)) {
#line 115
    start_waiting_jobs();
#line 119
    reap_children(1, 0);
#line 121
    lastgoal___0 = (struct dep *)0;
#line 122
    g___0 = goals___0;
#line 123
    while ((unsigned long )g___0 != (unsigned long )((struct dep *)0)) {
#line 127
      stop = 0;
#line 127
      any_not_updated = 0;
#line 129
      if ((g___0->file)->double_colon) {
#line 129
        file = (g___0->file)->double_colon;
      } else {
#line 129
        file = g___0->file;
      }
#line 129
      while ((unsigned long )file != (unsigned long )((void *)0)) {
#line 135
        while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 135
          file = file->renamed;
        }
#line 136
        if (makefiles___0) {
#line 138
          if (file->cmd_target) {
#line 140
            touch_flag = t;
#line 141
            question_flag = q;
#line 142
            just_print_flag = n;
          } else {
#line 145
            just_print_flag = 0;
#line 145
            question_flag = just_print_flag;
#line 145
            touch_flag = question_flag;
          }
        }
#line 151
        ocommands_started = commands_started;
#line 153
        if (makefiles___0) {
#line 153
          tmp = 1;
        } else {
#line 153
          tmp = 0;
        }
#line 153
        x = update_file(file, (unsigned int )tmp);
#line 154
        while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 154
          file = file->renamed;
        }
#line 159
        g___0->changed = (int )((unsigned int )g___0->changed + (commands_started - ocommands_started));
#line 165
        stop = 0;
#line 166
        if (x != 0) {
#line 166
          goto _L;
        } else
#line 166
        if (file->updated) {
          _L: /* CIL Label */ 
#line 166
          if (status < 1) {
#line 168
            if ((int )file->update_status != 0) {
#line 172
              status = (int )file->update_status;
#line 176
              if (! keep_going_flag) {
#line 176
                if (! question_flag) {
#line 176
                  if (! makefiles___0) {
#line 176
                    tmp___0 = 1;
                  } else {
#line 176
                    tmp___0 = 0;
                  }
                } else {
#line 176
                  tmp___0 = 0;
                }
              } else {
#line 176
                tmp___0 = 0;
              }
#line 176
              stop = tmp___0;
            } else {
#line 181
              if (makefiles___0) {
#line 181
                if (file->last_mtime) {
#line 181
                  tmp___2 = file->last_mtime;
                } else {
#line 181
                  tmp___1 = f_mtime(file, 0);
#line 181
                  tmp___2 = tmp___1;
                }
#line 181
                tmp___5 = tmp___2;
              } else {
#line 181
                if (file->last_mtime) {
#line 181
                  tmp___4 = file->last_mtime;
                } else {
#line 181
                  tmp___3 = f_mtime(file, 1);
#line 181
                  tmp___4 = tmp___3;
                }
#line 181
                tmp___5 = tmp___4;
              }
#line 181
              mtime = tmp___5;
#line 182
              while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 182
                file = file->renamed;
              }
#line 184
              if (file->updated) {
#line 184
                if (g___0->changed) {
#line 184
                  if (mtime != file->mtime_before_update) {
#line 193
                    if (! makefiles___0) {
#line 195
                      status = 0;
                    } else
#line 193
                    if (! just_print_flag) {
#line 193
                      if (! question_flag) {
#line 195
                        status = 0;
                      }
                    }
#line 196
                    if (makefiles___0) {
#line 196
                      if (file->dontcare) {
#line 198
                        stop = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 205
        any_not_updated |= ! file->updated;
#line 207
        if (stop) {
#line 208
          break;
        }
#line 129
        file = file->prev;
      }
#line 212
      file = g___0->file;
#line 214
      if (stop) {
#line 214
        goto _L___0;
      } else
#line 214
      if (! any_not_updated) {
        _L___0: /* CIL Label */ 
#line 219
        if (! makefiles___0) {
#line 219
          if ((int )file->update_status == 0) {
#line 219
            if (! g___0->changed) {
#line 219
              if (! silent_flag) {
#line 219
                if (! question_flag) {
#line 226
                  if (file->phony) {
#line 226
                    tmp___6 = dcgettext((char const   *)((void *)0), "Nothing to be done for `%s\'.",
                                        5);
#line 226
                    tmp___8 = tmp___6;
                  } else
#line 226
                  if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 226
                    tmp___6 = dcgettext((char const   *)((void *)0), "Nothing to be done for `%s\'.",
                                        5);
#line 226
                    tmp___8 = tmp___6;
                  } else {
#line 226
                    tmp___7 = dcgettext((char const   *)((void *)0), "`%s\' is up to date.",
                                        5);
#line 226
                    tmp___8 = tmp___7;
                  }
#line 226
                  message(1, (char const   *)tmp___8, file->name);
                }
              }
            }
          }
        }
#line 232
        if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
#line 233
          goals___0 = g___0->next;
        } else {
#line 235
          lastgoal___0->next = g___0->next;
        }
#line 238
        free((void *)((char *)g___0));
#line 240
        if ((unsigned long )lastgoal___0 == (unsigned long )((struct dep *)0)) {
#line 240
          g___0 = goals___0;
        } else {
#line 240
          g___0 = lastgoal___0->next;
        }
#line 242
        if (stop) {
#line 243
          break;
        }
      } else {
#line 247
        lastgoal___0 = g___0;
#line 248
        g___0 = g___0->next;
      }
    }
#line 254
    if ((unsigned long )g___0 == (unsigned long )((struct dep *)0)) {
#line 255
      considered = (unsigned int )(! considered);
    }
  }
#line 258
  if (makefiles___0) {
#line 260
    touch_flag = t;
#line 261
    question_flag = q;
#line 262
    just_print_flag = n;
#line 263
    job_slots = j;
  }
#line 265
  return (status);
}
}
#line 280 "remake.c"
static int update_file(struct file *file , unsigned int depth ) 
{ 
  register int status ;
  register struct file *f ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct dep *d ;
  int tmp___2 ;

  {
#line 285
  status = 0;
#line 288
  if (file->double_colon) {
#line 288
    f = file->double_colon;
  } else {
#line 288
    f = file;
  }
#line 294
  if (f->considered == considered) {
#line 296
    while (1) {
#line 296
      if (2 & db_level) {
#line 296
        print_spaces(depth);
#line 296
        tmp = dcgettext((char const   *)((void *)0), "Pruning file `%s\'.\n", 5);
#line 296
        printf((char const   * __restrict  )tmp, file->name);
#line 296
        fflush(stdout);
      }
#line 296
      break;
    }
#line 297
    if ((unsigned int )f->command_state == 3U) {
#line 297
      tmp___0 = (int )f->update_status;
    } else {
#line 297
      tmp___0 = 0;
    }
#line 297
    return (tmp___0);
  }
#line 302
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 304
    f->considered = considered;
#line 306
    tmp___1 = update_file_1(f, depth);
#line 306
    status |= tmp___1;
#line 307
    while ((unsigned long )f->renamed != (unsigned long )((struct file *)0)) {
#line 307
      f = f->renamed;
    }
#line 309
    if (status != 0) {
#line 309
      if (! keep_going_flag) {
#line 310
        break;
      }
    }
#line 312
    if ((unsigned int )f->command_state == 2U) {
#line 317
      status = 0;
#line 318
      break;
    } else
#line 312
    if ((unsigned int )f->command_state == 1U) {
#line 317
      status = 0;
#line 318
      break;
    }
#line 302
    f = f->prev;
  }
#line 324
  while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 328
    f->considered = considered;
#line 330
    d = f->deps;
#line 330
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 331
      tmp___2 = update_file(d->file, depth + 1U);
#line 331
      status |= tmp___2;
#line 330
      d = d->next;
    }
#line 324
    f = f->prev;
  }
#line 334
  return (status);
}
}
#line 339 "remake.c"
static int update_file_1(struct file *file , unsigned int depth ) 
{ 
  register uintmax_t this_mtime ;
  int noexist ;
  int must_make ;
  int deps_changed ;
  int dep_status ;
  register struct dep *d ;
  register struct dep *lastd ;
  int running ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct file *tmp___4 ;
  uintmax_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  uintmax_t mtime ;
  uintmax_t tmp___11 ;
  char *tmp___12 ;
  struct file *tmp___13 ;
  int tmp___14 ;
  register struct file *f ;
  int tmp___15 ;
  uintmax_t tmp___16 ;
  uintmax_t tmp___17 ;
  uintmax_t mtime___0 ;
  uintmax_t tmp___18 ;
  uintmax_t tmp___19 ;
  int tmp___20 ;
  register struct file *f___0 ;
  int tmp___21 ;
  uintmax_t tmp___22 ;
  uintmax_t tmp___23 ;
  int tmp___24 ;
  struct file *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  uintmax_t d_mtime ;
  uintmax_t tmp___30 ;
  uintmax_t tmp___31 ;
  int tmp___32 ;
  char const   *fmt ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;

  {
#line 346
  dep_status = 0;
#line 348
  running = 0;
#line 350
  while (1) {
#line 350
    if (2 & db_level) {
#line 350
      print_spaces(depth);
#line 350
      tmp = dcgettext((char const   *)((void *)0), "Considering target file `%s\'.\n",
                      5);
#line 350
      printf((char const   * __restrict  )tmp, file->name);
#line 350
      fflush(stdout);
    }
#line 350
    break;
  }
#line 352
  if (file->updated) {
#line 354
    if ((int )file->update_status > 0) {
#line 356
      while (1) {
#line 356
        if (2 & db_level) {
#line 356
          print_spaces(depth);
#line 356
          tmp___0 = dcgettext((char const   *)((void *)0), "Recently tried and failed to update file `%s\'.\n",
                              5);
#line 356
          printf((char const   * __restrict  )tmp___0, file->name);
#line 356
          fflush(stdout);
        }
#line 356
        break;
      }
#line 358
      return ((int )file->update_status);
    }
#line 361
    while (1) {
#line 361
      if (2 & db_level) {
#line 361
        print_spaces(depth);
#line 361
        tmp___1 = dcgettext((char const   *)((void *)0), "File `%s\' was considered already.\n",
                            5);
#line 361
        printf((char const   * __restrict  )tmp___1, file->name);
#line 361
        fflush(stdout);
      }
#line 361
      break;
    }
#line 362
    return (0);
  }
#line 365
  switch ((unsigned int )file->command_state) {
  case 1U: 
  case 0U: 
#line 369
  break;
  case 2U: 
#line 371
  while (1) {
#line 371
    if (2 & db_level) {
#line 371
      print_spaces(depth);
#line 371
      tmp___2 = dcgettext((char const   *)((void *)0), "Still updating file `%s\'.\n",
                          5);
#line 371
      printf((char const   * __restrict  )tmp___2, file->name);
#line 371
      fflush(stdout);
    }
#line 371
    break;
  }
#line 372
  return (0);
  case 3U: 
#line 374
  while (1) {
#line 374
    if (2 & db_level) {
#line 374
      print_spaces(depth);
#line 374
      tmp___3 = dcgettext((char const   *)((void *)0), "Finished updating file `%s\'.\n",
                          5);
#line 374
      printf((char const   * __restrict  )tmp___3, file->name);
#line 374
      fflush(stdout);
    }
#line 374
    break;
  }
#line 375
  return ((int )file->update_status);
  default: 
#line 377
  abort();
  }
#line 380
  depth ++;
#line 383
  if (file->double_colon) {
#line 383
    tmp___4 = file->double_colon;
  } else {
#line 383
    tmp___4 = file;
  }
#line 383
  tmp___4->updating = 1U;
#line 391
  if (file->last_mtime) {
#line 391
    this_mtime = file->last_mtime;
  } else {
#line 391
    tmp___5 = f_mtime(file, 1);
#line 391
    this_mtime = tmp___5;
  }
#line 392
  while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 392
    file = file->renamed;
  }
#line 393
  noexist = this_mtime == 0xffffffffffffffffUL;
#line 394
  if (noexist) {
#line 395
    while (1) {
#line 395
      if (1 & db_level) {
#line 395
        print_spaces(depth);
#line 395
        tmp___6 = dcgettext((char const   *)((void *)0), "File `%s\' does not exist.\n",
                            5);
#line 395
        printf((char const   * __restrict  )tmp___6, file->name);
#line 395
        fflush(stdout);
      }
#line 395
      break;
    }
  }
#line 397
  must_make = noexist;
#line 402
  if (! file->phony) {
#line 402
    if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 402
      if (! file->tried_implicit) {
#line 404
        tmp___9 = try_implicit_rule(file, depth);
#line 404
        if (tmp___9) {
#line 405
          while (1) {
#line 405
            if (8 & db_level) {
#line 405
              print_spaces(depth);
#line 405
              tmp___7 = dcgettext((char const   *)((void *)0), "Found an implicit rule for `%s\'.\n",
                                  5);
#line 405
              printf((char const   * __restrict  )tmp___7, file->name);
#line 405
              fflush(stdout);
            }
#line 405
            break;
          }
        } else {
#line 407
          while (1) {
#line 407
            if (8 & db_level) {
#line 407
              print_spaces(depth);
#line 407
              tmp___8 = dcgettext((char const   *)((void *)0), "No implicit rule found for `%s\'.\n",
                                  5);
#line 407
              printf((char const   * __restrict  )tmp___8, file->name);
#line 407
              fflush(stdout);
            }
#line 407
            break;
          }
        }
#line 408
        file->tried_implicit = 1U;
      }
    }
  }
#line 410
  if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 410
    if (! file->is_target) {
#line 410
      if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
#line 410
        if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
#line 413
          while (1) {
#line 413
            if (8 & db_level) {
#line 413
              print_spaces(depth);
#line 413
              tmp___10 = dcgettext((char const   *)((void *)0), "Using default commands for `%s\'.\n",
                                   5);
#line 413
              printf((char const   * __restrict  )tmp___10, file->name);
#line 413
              fflush(stdout);
            }
#line 413
            break;
          }
#line 414
          file->cmds = default_file->cmds;
        }
      }
    }
  }
#line 420
  lastd = (struct dep *)0;
#line 421
  d = file->deps;
#line 422
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 426
    while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
#line 426
      d->file = (d->file)->renamed;
    }
#line 428
    if ((d->file)->last_mtime) {
#line 428
      mtime = (d->file)->last_mtime;
    } else {
#line 428
      tmp___11 = f_mtime(d->file, 1);
#line 428
      mtime = tmp___11;
    }
#line 429
    while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
#line 429
      d->file = (d->file)->renamed;
    }
#line 431
    if ((d->file)->double_colon) {
#line 431
      tmp___13 = (d->file)->double_colon;
    } else {
#line 431
      tmp___13 = d->file;
    }
#line 431
    if (tmp___13->updating) {
#line 433
      tmp___12 = dcgettext((char const   *)((void *)0), "Circular %s <- %s dependency dropped.",
                           5);
#line 433
      error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___12, file->name,
            (d->file)->name);
#line 438
      if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
#line 439
        file->deps = d->next;
      } else {
#line 441
        lastd->next = d->next;
      }
#line 442
      d = d->next;
#line 443
      continue;
    }
#line 446
    (d->file)->parent = file;
#line 447
    tmp___14 = check_dep(d->file, depth, this_mtime, & must_make);
#line 447
    dep_status |= tmp___14;
#line 448
    while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
#line 448
      d->file = (d->file)->renamed;
    }
#line 451
    f = d->file;
#line 452
    if (f->double_colon) {
#line 453
      f = f->double_colon;
    }
#line 454
    while (1) {
#line 456
      if ((unsigned int )f->command_state == 2U) {
#line 456
        tmp___15 = 1;
      } else
#line 456
      if ((unsigned int )f->command_state == 1U) {
#line 456
        tmp___15 = 1;
      } else {
#line 456
        tmp___15 = 0;
      }
#line 456
      running |= tmp___15;
#line 458
      f = f->prev;
#line 454
      if (! ((unsigned long )f != (unsigned long )((struct file *)0))) {
#line 454
        break;
      }
    }
#line 463
    if (dep_status != 0) {
#line 463
      if (! keep_going_flag) {
#line 464
        break;
      }
    }
#line 466
    if (! running) {
#line 467
      if ((d->file)->last_mtime) {
#line 467
        tmp___17 = (d->file)->last_mtime;
      } else {
#line 467
        tmp___16 = f_mtime(d->file, 1);
#line 467
        tmp___17 = tmp___16;
      }
#line 467
      d->changed = tmp___17 != mtime;
    }
#line 469
    lastd = d;
#line 470
    d = d->next;
  }
#line 476
  if (must_make) {
#line 478
    d = file->deps;
#line 478
    while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 479
      if ((d->file)->intermediate) {
#line 481
        if ((d->file)->last_mtime) {
#line 481
          tmp___19 = (d->file)->last_mtime;
        } else {
#line 481
          tmp___18 = f_mtime(d->file, 1);
#line 481
          tmp___19 = tmp___18;
        }
#line 481
        mtime___0 = tmp___19;
#line 482
        while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
#line 482
          d->file = (d->file)->renamed;
        }
#line 483
        (d->file)->parent = file;
#line 484
        tmp___20 = update_file(d->file, depth);
#line 484
        dep_status |= tmp___20;
#line 485
        while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
#line 485
          d->file = (d->file)->renamed;
        }
#line 488
        f___0 = d->file;
#line 489
        if (f___0->double_colon) {
#line 490
          f___0 = f___0->double_colon;
        }
#line 491
        while (1) {
#line 493
          if ((unsigned int )f___0->command_state == 2U) {
#line 493
            tmp___21 = 1;
          } else
#line 493
          if ((unsigned int )f___0->command_state == 1U) {
#line 493
            tmp___21 = 1;
          } else {
#line 493
            tmp___21 = 0;
          }
#line 493
          running |= tmp___21;
#line 495
          f___0 = f___0->prev;
#line 491
          if (! ((unsigned long )f___0 != (unsigned long )((struct file *)0))) {
#line 491
            break;
          }
        }
#line 500
        if (dep_status != 0) {
#line 500
          if (! keep_going_flag) {
#line 501
            break;
          }
        }
#line 503
        if (! running) {
#line 504
          if (file->phony) {
#line 504
            if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
#line 504
              tmp___24 = 1;
            } else {
#line 504
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 504
            if ((d->file)->last_mtime) {
#line 504
              tmp___23 = (d->file)->last_mtime;
            } else {
#line 504
              tmp___22 = f_mtime(d->file, 1);
#line 504
              tmp___23 = tmp___22;
            }
#line 504
            if (tmp___23 != mtime___0) {
#line 504
              tmp___24 = 1;
            } else {
#line 504
              tmp___24 = 0;
            }
          }
#line 504
          d->changed = tmp___24;
        }
      }
#line 478
      d = d->next;
    }
  }
#line 509
  if (file->double_colon) {
#line 509
    tmp___25 = file->double_colon;
  } else {
#line 509
    tmp___25 = file;
  }
#line 509
  tmp___25->updating = 0U;
#line 511
  while (1) {
#line 511
    if (2 & db_level) {
#line 511
      print_spaces(depth);
#line 511
      tmp___26 = dcgettext((char const   *)((void *)0), "Finished prerequisites of target file `%s\'.\n",
                           5);
#line 511
      printf((char const   * __restrict  )tmp___26, file->name);
#line 511
      fflush(stdout);
    }
#line 511
    break;
  }
#line 513
  if (running) {
#line 515
    set_command_state(file, 1);
#line 516
    depth --;
#line 517
    while (1) {
#line 517
      if (2 & db_level) {
#line 517
        print_spaces(depth);
#line 517
        tmp___27 = dcgettext((char const   *)((void *)0), "The prerequisites of `%s\' are being made.\n",
                             5);
#line 517
        printf((char const   * __restrict  )tmp___27, file->name);
#line 517
        fflush(stdout);
      }
#line 517
      break;
    }
#line 518
    return (0);
  }
#line 523
  if (dep_status != 0) {
#line 525
    file->update_status = (short )dep_status;
#line 526
    notice_finished_file(file);
#line 528
    depth --;
#line 530
    while (1) {
#line 530
      if (2 & db_level) {
#line 530
        print_spaces(depth);
#line 530
        tmp___28 = dcgettext((char const   *)((void *)0), "Giving up on target file `%s\'.\n",
                             5);
#line 530
        printf((char const   * __restrict  )tmp___28, file->name);
#line 530
        fflush(stdout);
      }
#line 530
      break;
    }
#line 532
    if (depth == 0U) {
#line 532
      if (keep_going_flag) {
#line 532
        if (! just_print_flag) {
#line 532
          if (! question_flag) {
#line 534
            tmp___29 = dcgettext((char const   *)((void *)0), "Target `%s\' not remade because of errors.",
                                 5);
#line 534
            error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___29,
                  file->name);
          }
        }
      }
    }
#line 537
    return (dep_status);
  }
#line 540
  if ((unsigned int )file->command_state == 1U) {
#line 549
    set_command_state(file, 0);
  }
#line 554
  deps_changed = 0;
#line 555
  d = file->deps;
#line 555
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 557
    if ((d->file)->last_mtime) {
#line 557
      tmp___31 = (d->file)->last_mtime;
    } else {
#line 557
      tmp___30 = f_mtime(d->file, 1);
#line 557
      tmp___31 = tmp___30;
    }
#line 557
    d_mtime = tmp___31;
#line 558
    while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
#line 558
      d->file = (d->file)->renamed;
    }
#line 563
    if (d_mtime == 0xffffffffffffffffUL) {
#line 563
      if (! (d->file)->intermediate) {
#line 566
        must_make = 1;
      }
    }
#line 570
    deps_changed |= d->changed;
#line 574
    if (noexist) {
#line 574
      tmp___32 = 1;
    } else
#line 574
    if (d_mtime > this_mtime) {
#line 574
      tmp___32 = 1;
    } else {
#line 574
      tmp___32 = 0;
    }
#line 574
    d->changed |= tmp___32;
#line 576
    if (! noexist) {
#line 576
      if (3 & db_level) {
#line 578
        fmt = (char const   *)0;
#line 580
        if (d_mtime == 0xffffffffffffffffUL) {
#line 582
          if (1 & db_level) {
#line 583
            tmp___33 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' of target `%s\' does not exist.\n",
                                 5);
#line 583
            fmt = (char const   *)tmp___33;
          }
        } else
#line 585
        if (d->changed) {
#line 587
          if (1 & db_level) {
#line 588
            tmp___34 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' is newer than target `%s\'.\n",
                                 5);
#line 588
            fmt = (char const   *)tmp___34;
          }
        } else
#line 590
        if (2 & db_level) {
#line 591
          tmp___35 = dcgettext((char const   *)((void *)0), "Prerequisite `%s\' is older than target `%s\'.\n",
                               5);
#line 591
          fmt = (char const   *)tmp___35;
        }
#line 593
        if (fmt) {
#line 595
          print_spaces(depth);
#line 596
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 596
            tmp___36 = (d->file)->name;
          } else {
#line 596
            tmp___36 = d->name;
          }
#line 596
          printf((char const   * __restrict  )fmt, tmp___36, file->name);
#line 597
          fflush(stdout);
        }
      }
    }
#line 555
    d = d->next;
  }
#line 603
  depth --;
#line 605
  if (file->double_colon) {
#line 605
    if ((unsigned long )file->deps == (unsigned long )((struct dep *)0)) {
#line 607
      must_make = 1;
#line 608
      while (1) {
#line 608
        if (1 & db_level) {
#line 608
          print_spaces(depth);
#line 608
          tmp___37 = dcgettext((char const   *)((void *)0), "Target `%s\' is double-colon and has no prerequisites.\n",
                               5);
#line 608
          printf((char const   * __restrict  )tmp___37, file->name);
#line 608
          fflush(stdout);
        }
#line 608
        break;
      }
    } else {
#line 605
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 611
  if (! noexist) {
#line 611
    if (file->is_target) {
#line 611
      if (! deps_changed) {
#line 611
        if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 613
          must_make = 0;
#line 614
          while (1) {
#line 614
            if (2 & db_level) {
#line 614
              print_spaces(depth);
#line 614
              tmp___38 = dcgettext((char const   *)((void *)0), "No commands for `%s\' and no prerequisites actually changed.\n",
                                   5);
#line 614
              printf((char const   * __restrict  )tmp___38, file->name);
#line 614
              fflush(stdout);
            }
#line 614
            break;
          }
        }
      }
    }
  }
#line 618
  if (! must_make) {
#line 620
    if (2 & db_level) {
#line 622
      print_spaces(depth);
#line 623
      tmp___39 = dcgettext((char const   *)((void *)0), "No need to remake target `%s\'",
                           5);
#line 623
      printf((char const   * __restrict  )tmp___39, file->name);
#line 624
      if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
#line 624
        if ((int )*(file->name) == (int )*(file->hname)) {
#line 624
          if (! ((int )*(file->name) == 0)) {
#line 624
            tmp___41 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));
#line 624
            if (tmp___41) {
#line 625
              tmp___40 = dcgettext((char const   *)((void *)0), "; using VPATH name `%s\'",
                                   5);
#line 625
              printf((char const   * __restrict  )tmp___40, file->hname);
            }
          }
        } else {
#line 625
          tmp___40 = dcgettext((char const   *)((void *)0), "; using VPATH name `%s\'",
                               5);
#line 625
          printf((char const   * __restrict  )tmp___40, file->hname);
        }
      }
#line 626
      puts(".");
#line 627
      fflush(stdout);
    }
#line 630
    notice_finished_file(file);
#line 636
    while (file) {
#line 638
      file->name = file->hname;
#line 639
      file = file->prev;
    }
#line 642
    return (0);
  }
#line 645
  while (1) {
#line 645
    if (1 & db_level) {
#line 645
      print_spaces(depth);
#line 645
      tmp___42 = dcgettext((char const   *)((void *)0), "Must remake target `%s\'.\n",
                           5);
#line 645
      printf((char const   * __restrict  )tmp___42, file->name);
#line 645
      fflush(stdout);
    }
#line 645
    break;
  }
#line 649
  if (! ((unsigned long )file->name == (unsigned long )file->hname)) {
#line 649
    if ((int )*(file->name) == (int )*(file->hname)) {
#line 649
      if (! ((int )*(file->name) == 0)) {
#line 649
        tmp___44 = strcmp((char const   *)(file->name + 1), (char const   *)(file->hname + 1));
#line 649
        if (tmp___44) {
#line 649
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
#line 651
      while (1) {
#line 651
        if (1 & db_level) {
#line 651
          tmp___43 = dcgettext((char const   *)((void *)0), "  Ignoring VPATH name `%s\'.\n",
                               5);
#line 651
          printf((char const   * __restrict  )tmp___43, file->hname);
#line 651
          fflush(stdout);
        }
#line 651
        break;
      }
#line 652
      file->ignore_vpath = 1U;
    }
  }
#line 656
  remake_file(file);
#line 658
  if ((unsigned int )file->command_state != 3U) {
#line 660
    while (1) {
#line 660
      if (2 & db_level) {
#line 660
        print_spaces(depth);
#line 660
        tmp___45 = dcgettext((char const   *)((void *)0), "Commands of `%s\' are being run.\n",
                             5);
#line 660
        printf((char const   * __restrict  )tmp___45, file->name);
#line 660
        fflush(stdout);
      }
#line 660
      break;
    }
#line 661
    return (0);
  }
#line 664
  switch ((int )file->update_status) {
  case 2: 
#line 667
  while (1) {
#line 667
    if (1 & db_level) {
#line 667
      print_spaces(depth);
#line 667
      tmp___46 = dcgettext((char const   *)((void *)0), "Failed to remake target file `%s\'.\n",
                           5);
#line 667
      printf((char const   * __restrict  )tmp___46, file->name);
#line 667
      fflush(stdout);
    }
#line 667
    break;
  }
#line 668
  break;
  case 0: 
#line 670
  while (1) {
#line 670
    if (1 & db_level) {
#line 670
      print_spaces(depth);
#line 670
      tmp___47 = dcgettext((char const   *)((void *)0), "Successfully remade target file `%s\'.\n",
                           5);
#line 670
      printf((char const   * __restrict  )tmp___47, file->name);
#line 670
      fflush(stdout);
    }
#line 670
    break;
  }
#line 671
  break;
  case 1: 
#line 673
  while (1) {
#line 673
    if (1 & db_level) {
#line 673
      print_spaces(depth);
#line 673
      tmp___48 = dcgettext((char const   *)((void *)0), "Target file `%s\' needs remade under -q.\n",
                           5);
#line 673
      printf((char const   * __restrict  )tmp___48, file->name);
#line 673
      fflush(stdout);
    }
#line 673
    break;
  }
#line 674
  break;
  default: 
#line 676
  if ((int )file->update_status >= 0) {
#line 676
    if (! ((int )file->update_status <= 2)) {
#line 676
      __assert_fail("file->update_status >= 0 && file->update_status <= 2", "remake.c",
                    676U, "update_file_1");
    }
  } else {
#line 676
    __assert_fail("file->update_status >= 0 && file->update_status <= 2", "remake.c",
                  676U, "update_file_1");
  }
#line 677
  break;
  }
#line 680
  file->updated = 1U;
#line 681
  return ((int )file->update_status);
}
}
#line 690 "remake.c"
void notice_finished_file(struct file *file ) 
{ 
  struct dep *d ;
  int ran ;
  unsigned int i ;
  int tmp ;
  struct file *f ;
  int i___0 ;

  {
#line 695
  ran = (unsigned int )file->command_state == 2U;
#line 697
  file->command_state = (enum __anonenum_command_state_55 )3;
#line 698
  file->updated = 1U;
#line 700
  if (touch_flag) {
#line 700
    if ((int )file->update_status == 0) {
#line 709
      if ((unsigned long )file->cmds != (unsigned long )((struct commands *)0)) {
#line 709
        if ((file->cmds)->any_recurse) {
#line 714
          i = 0U;
#line 714
          while (i < (file->cmds)->ncommand_lines) {
#line 715
            if (! ((int )*((file->cmds)->lines_flags + i) & 1)) {
#line 716
              goto have_nonrecursing;
            }
#line 714
            i ++;
          }
        } else {
#line 709
          goto have_nonrecursing;
        }
      } else
      have_nonrecursing: 
#line 721
      if (file->phony) {
#line 722
        file->update_status = (short)0;
      } else {
#line 725
        tmp = touch_file(file);
#line 725
        file->update_status = (short )tmp;
      }
    }
  }
#line 729
  if (file->mtime_before_update == 0UL) {
#line 730
    file->mtime_before_update = file->last_mtime;
  }
#line 732
  if (ran) {
#line 732
    if (! file->phony) {
#line 735
      i___0 = 0;
#line 741
      if (question_flag) {
#line 741
        goto _L___0;
      } else
#line 741
      if (just_print_flag) {
        _L___0: /* CIL Label */ 
#line 743
        i___0 = (int )(file->cmds)->ncommand_lines;
#line 743
        while (i___0 > 0) {
#line 744
          if (! ((int )*((file->cmds)->lines_flags + (i___0 - 1)) & 1)) {
#line 745
            break;
          }
#line 743
          i___0 --;
        }
      } else
#line 750
      if (file->is_target) {
#line 750
        if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 751
          i___0 = 1;
        }
      }
#line 753
      if (i___0 == 0) {
#line 753
        file->last_mtime = (uintmax_t )0;
      } else {
#line 753
        file->last_mtime = 0xfffffffffffffffeUL;
      }
#line 757
      f = file->double_colon;
#line 757
      while ((unsigned long )f != (unsigned long )((struct file *)0)) {
#line 758
        f->last_mtime = file->last_mtime;
#line 757
        f = f->next;
      }
    }
  }
#line 761
  if (ran) {
#line 761
    if ((int )file->update_status != -1) {
#line 766
      d = file->also_make;
#line 766
      while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 768
        (d->file)->command_state = (enum __anonenum_command_state_55 )3;
#line 769
        (d->file)->updated = 1U;
#line 770
        (d->file)->update_status = file->update_status;
#line 772
        if (ran) {
#line 772
          if (! (d->file)->phony) {
#line 777
            f_mtime(d->file, 0);
          }
        }
#line 766
        d = d->next;
      }
    } else {
#line 761
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 779
  if ((int )file->update_status == -1) {
#line 782
    file->update_status = (short)0;
  }
#line 783
  return;
}
}
#line 792 "remake.c"
static int check_dep(struct file *file , unsigned int depth , uintmax_t this_mtime ,
                     int *must_make_ptr ) 
{ 
  register struct dep *d ;
  int dep_status ;
  struct file *tmp ;
  uintmax_t mtime ;
  uintmax_t tmp___0 ;
  uintmax_t mtime___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  uintmax_t tmp___5 ;
  register struct dep *lastd ;
  char *tmp___6 ;
  struct file *tmp___7 ;
  int tmp___8 ;
  struct file *tmp___9 ;

  {
#line 800
  dep_status = 0;
#line 802
  depth ++;
#line 803
  if (file->double_colon) {
#line 803
    tmp = file->double_colon;
  } else {
#line 803
    tmp = file;
  }
#line 803
  tmp->updating = 1U;
#line 805
  if (! file->intermediate) {
#line 810
    dep_status = update_file(file, depth);
#line 811
    while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 811
      file = file->renamed;
    }
#line 812
    if (file->last_mtime) {
#line 812
      mtime = file->last_mtime;
    } else {
#line 812
      tmp___0 = f_mtime(file, 1);
#line 812
      mtime = tmp___0;
    }
#line 813
    while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 813
      file = file->renamed;
    }
#line 814
    if (mtime == 0xffffffffffffffffUL) {
#line 815
      *must_make_ptr = 1;
    } else
#line 814
    if (mtime > this_mtime) {
#line 815
      *must_make_ptr = 1;
    }
  } else {
#line 822
    if (! file->phony) {
#line 822
      if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 822
        if (! file->tried_implicit) {
#line 824
          tmp___3 = try_implicit_rule(file, depth);
#line 824
          if (tmp___3) {
#line 825
            while (1) {
#line 825
              if (8 & db_level) {
#line 825
                print_spaces(depth);
#line 825
                tmp___1 = dcgettext((char const   *)((void *)0), "Found an implicit rule for `%s\'.\n",
                                    5);
#line 825
                printf((char const   * __restrict  )tmp___1, file->name);
#line 825
                fflush(stdout);
              }
#line 825
              break;
            }
          } else {
#line 827
            while (1) {
#line 827
              if (8 & db_level) {
#line 827
                print_spaces(depth);
#line 827
                tmp___2 = dcgettext((char const   *)((void *)0), "No implicit rule found for `%s\'.\n",
                                    5);
#line 827
                printf((char const   * __restrict  )tmp___2, file->name);
#line 827
                fflush(stdout);
              }
#line 827
              break;
            }
          }
#line 828
          file->tried_implicit = 1U;
        }
      }
    }
#line 830
    if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 830
      if (! file->is_target) {
#line 830
        if ((unsigned long )default_file != (unsigned long )((struct file *)0)) {
#line 830
          if ((unsigned long )default_file->cmds != (unsigned long )((struct commands *)0)) {
#line 833
            while (1) {
#line 833
              if (8 & db_level) {
#line 833
                print_spaces(depth);
#line 833
                tmp___4 = dcgettext((char const   *)((void *)0), "Using default commands for `%s\'.\n",
                                    5);
#line 833
                printf((char const   * __restrict  )tmp___4, file->name);
#line 833
                fflush(stdout);
              }
#line 833
              break;
            }
#line 834
            file->cmds = default_file->cmds;
          }
        }
      }
    }
#line 839
    while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 839
      file = file->renamed;
    }
#line 840
    if (file->last_mtime) {
#line 840
      mtime___0 = file->last_mtime;
    } else {
#line 840
      tmp___5 = f_mtime(file, 1);
#line 840
      mtime___0 = tmp___5;
    }
#line 841
    while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 841
      file = file->renamed;
    }
#line 842
    if (mtime___0 != 0xffffffffffffffffUL) {
#line 842
      if (mtime___0 > this_mtime) {
#line 843
        *must_make_ptr = 1;
      } else {
#line 842
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 851
      lastd = (struct dep *)0;
#line 852
      d = file->deps;
#line 853
      while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 855
        if ((d->file)->double_colon) {
#line 855
          tmp___7 = (d->file)->double_colon;
        } else {
#line 855
          tmp___7 = d->file;
        }
#line 855
        if (tmp___7->updating) {
#line 857
          tmp___6 = dcgettext((char const   *)((void *)0), "Circular %s <- %s dependency dropped.",
                              5);
#line 857
          error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___6,
                file->name, (d->file)->name);
#line 859
          if ((unsigned long )lastd == (unsigned long )((struct dep *)0)) {
#line 861
            file->deps = d->next;
#line 862
            free((void *)((char *)d));
#line 863
            d = file->deps;
          } else {
#line 867
            lastd->next = d->next;
#line 868
            free((void *)((char *)d));
#line 869
            d = lastd->next;
          }
#line 871
          continue;
        }
#line 874
        (d->file)->parent = file;
#line 875
        tmp___8 = check_dep(d->file, depth, this_mtime, must_make_ptr);
#line 875
        dep_status |= tmp___8;
#line 877
        while ((unsigned long )(d->file)->renamed != (unsigned long )((struct file *)0)) {
#line 877
          d->file = (d->file)->renamed;
        }
#line 878
        if (dep_status != 0) {
#line 878
          if (! keep_going_flag) {
#line 879
            break;
          }
        }
#line 881
        if ((unsigned int )(d->file)->command_state == 2U) {
#line 886
          set_command_state(file, 1);
        } else
#line 881
        if ((unsigned int )(d->file)->command_state == 1U) {
#line 886
          set_command_state(file, 1);
        }
#line 888
        lastd = d;
#line 889
        d = d->next;
      }
    }
  }
#line 894
  if (file->double_colon) {
#line 894
    tmp___9 = file->double_colon;
  } else {
#line 894
    tmp___9 = file;
  }
#line 894
  tmp___9->updating = 0U;
#line 895
  return (dep_status);
}
}
#line 902 "remake.c"
static int touch_file(struct file *file ) 
{ 
  int tmp ;
  int fd ;
  int tmp___0 ;
  struct stat statbuf ;
  char buf___1 ;
  int status ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;

  {
#line 906
  if (! silent_flag) {
#line 907
    message(0, "touch %s", file->name);
  }
#line 910
  tmp___5 = ar_name(file->name);
#line 910
  if (tmp___5) {
#line 911
    tmp = ar_touch(file->name);
#line 911
    return (tmp);
  } else {
#line 915
    tmp___0 = open((char const   *)file->name, 66, 438);
#line 915
    fd = tmp___0;
#line 917
    if (fd < 0) {
#line 918
      perror_with_name((char *)"touch: open: ", file->name);
#line 918
      return (1);
    } else {
#line 925
      while (1) {
#line 926
        status = fstat(fd, & statbuf);
#line 925
        if (status < 0) {
#line 925
          tmp___1 = __errno_location();
#line 925
          if (! (*tmp___1 == 4)) {
#line 925
            break;
          }
        } else {
#line 925
          break;
        }
      }
#line 929
      if (status < 0) {
#line 930
        perror_with_name((char *)"touch: fstat: ", file->name);
#line 930
        return (1);
      }
#line 932
      tmp___2 = read(fd, (void *)(& buf___1), (size_t )1);
#line 932
      if (tmp___2 < 0L) {
#line 933
        perror_with_name((char *)"touch: read: ", file->name);
#line 933
        return (1);
      }
#line 934
      tmp___3 = lseek(fd, 0L, 0);
#line 934
      if (tmp___3 < 0L) {
#line 935
        perror_with_name((char *)"touch: lseek: ", file->name);
#line 935
        return (1);
      }
#line 936
      tmp___4 = write(fd, (void const   *)(& buf___1), (size_t )1);
#line 936
      if (tmp___4 < 0L) {
#line 937
        perror_with_name((char *)"touch: write: ", file->name);
#line 937
        return (1);
      }
#line 940
      if (statbuf.st_size == 0L) {
#line 942
        close(fd);
#line 943
        fd = open((char const   *)file->name, 514, 438);
#line 944
        if (fd < 0) {
#line 945
          perror_with_name((char *)"touch: open: ", file->name);
#line 945
          return (1);
        }
      }
#line 947
      close(fd);
    }
  }
#line 951
  return (0);
}
}
#line 958 "remake.c"
static void remake_file(struct file *file ) 
{ 
  char const   *msg_noparent ;
  char *tmp ;
  char const   *msg_parent ;
  char *tmp___0 ;

  {
#line 962
  if ((unsigned long )file->cmds == (unsigned long )((struct commands *)0)) {
#line 964
    if (file->phony) {
#line 966
      file->update_status = (short)0;
    } else
#line 967
    if (file->is_target) {
#line 970
      file->update_status = (short)0;
    } else {
#line 973
      tmp = dcgettext((char const   *)((void *)0), "%sNo rule to make target `%s\'%s",
                      5);
#line 973
      msg_noparent = (char const   *)tmp;
#line 975
      tmp___0 = dcgettext((char const   *)((void *)0), "%sNo rule to make target `%s\', needed by `%s\'%s",
                          5);
#line 975
      msg_parent = (char const   *)tmp___0;
#line 979
      if (! keep_going_flag) {
#line 979
        if (! file->dontcare) {
#line 981
          if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
#line 982
            fatal((struct floc  const  *)((struct floc *)0), msg_noparent, "", file->name,
                  "");
          }
#line 984
          fatal((struct floc  const  *)((struct floc *)0), msg_parent, "", file->name,
                (file->parent)->name, "");
        }
      }
#line 987
      if (! file->dontcare) {
#line 989
        if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
#line 990
          error((struct floc  const  *)((struct floc *)0), msg_noparent, "*** ", file->name,
                ".");
        } else {
#line 992
          error((struct floc  const  *)((struct floc *)0), msg_parent, "*** ", file->name,
                (file->parent)->name, ".");
        }
      }
#line 995
      file->update_status = (short)2;
    }
  } else {
#line 1000
    chop_commands(file->cmds);
#line 1003
    if (! touch_flag) {
#line 1005
      execute_file_commands(file);
#line 1006
      return;
    } else
#line 1003
    if ((file->cmds)->any_recurse) {
#line 1005
      execute_file_commands(file);
#line 1006
      return;
    }
#line 1010
    file->update_status = (short)0;
  }
#line 1014
  notice_finished_file(file);
#line 1015
  return;
}
}
#line 1145 "remake.c"
static uintmax_t now  =    (uintmax_t )0;
#line 1025 "remake.c"
uintmax_t f_mtime(struct file *file , int search ) 
{ 
  uintmax_t mtime ;
  char *arname ;
  char *memname ;
  struct file *arfile ;
  int arname_used ;
  char *name ;
  unsigned int arlen ;
  unsigned int memlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  uintmax_t tmp___4 ;
  uintmax_t tmp___5 ;
  char *name___0 ;
  uintmax_t tmp___6 ;
  uintmax_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char mtimebuf[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;
  char nowbuf[(((((((sizeof(uintmax_t ) * 8UL - 1UL) - 24UL) * 302UL) / 1000UL + 1UL) + 1UL) + 4UL) + 25UL) + 1UL] ;
  char *tmp___14 ;

  {
#line 1035
  tmp___13 = ar_name(file->name);
#line 1035
  if (tmp___13) {
#line 1041
    arname_used = 0;
#line 1044
    ar_parse_name(file->name, & arname, & memname);
#line 1048
    arfile = lookup_file(arname);
#line 1049
    if ((unsigned long )arfile == (unsigned long )((struct file *)0)) {
#line 1051
      arfile = enter_file(arname);
#line 1052
      arname_used = 1;
    }
#line 1054
    mtime = f_mtime(arfile, search);
#line 1055
    while ((unsigned long )arfile->renamed != (unsigned long )((struct file *)0)) {
#line 1055
      arfile = arfile->renamed;
    }
#line 1056
    if (search) {
#line 1056
      tmp___2 = strcmp((char const   *)arfile->hname, (char const   *)arname);
#line 1056
      if (tmp___2) {
#line 1064
        if (! arname_used) {
#line 1066
          free((void *)arname);
#line 1067
          arname_used = 1;
        }
#line 1070
        arname = arfile->hname;
#line 1071
        tmp = strlen((char const   *)arname);
#line 1071
        arlen = (unsigned int )tmp;
#line 1072
        tmp___0 = strlen((char const   *)memname);
#line 1072
        memlen = (unsigned int )tmp___0;
#line 1076
        tmp___1 = xmalloc(((arlen + 1U) + memlen) + 2U);
#line 1076
        name = tmp___1;
#line 1077
        memmove((void *)name, (void const   *)arname, (size_t )arlen);
#line 1078
        *(name + arlen) = (char )'(';
#line 1079
        memmove((void *)((name + arlen) + 1), (void const   *)memname, (size_t )memlen);
#line 1080
        *(name + ((arlen + 1U) + memlen)) = (char )')';
#line 1081
        *(name + (((arlen + 1U) + memlen) + 1U)) = (char )'\000';
#line 1085
        if ((unsigned long )arfile->name == (unsigned long )arfile->hname) {
#line 1086
          rename_file(file, name);
        } else {
#line 1088
          rehash_file(file, name);
        }
#line 1089
        while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 1089
          file = file->renamed;
        }
      }
    }
#line 1092
    if (! arname_used) {
#line 1093
      free((void *)arname);
    }
#line 1094
    free((void *)memname);
#line 1096
    if (mtime == 0xffffffffffffffffUL) {
#line 1098
      return ((uintmax_t )-1);
    }
#line 1100
    tmp___3 = ar_member_date(file->hname);
#line 1100
    if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 1100
      tmp___4 = (uintmax_t )1000000000;
    } else {
#line 1100
      tmp___4 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
    }
#line 1100
    if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 1100
      tmp___5 = (uintmax_t )1000000000;
    } else {
#line 1100
      tmp___5 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
    }
#line 1100
    mtime = (uintmax_t )tmp___3 * tmp___4;
  } else {
#line 1105
    mtime = name_mtime(file->name);
#line 1107
    if (mtime == 0xffffffffffffffffUL) {
#line 1107
      if (search) {
#line 1107
        if (! file->ignore_vpath) {
#line 1110
          name___0 = file->name;
#line 1111
          tmp___11 = vpath_search(& name___0, & mtime);
#line 1111
          if (tmp___11) {
#line 1111
            goto _L;
          } else
#line 1111
          if ((int )*(name___0 + 0) == 45) {
#line 1111
            if ((int )*(name___0 + 1) == 108) {
#line 1111
              tmp___12 = library_search(& name___0, & mtime);
#line 1111
              if (tmp___12) {
                _L: /* CIL Label */ 
#line 1116
                if (mtime != 0UL) {
#line 1119
                  file->last_mtime = mtime;
                }
#line 1124
                tmp___8 = strlen((char const   *)name___0);
#line 1124
                tmp___9 = strlen((char const   *)file->name);
#line 1124
                tmp___10 = gpath_search(name___0, (int )((tmp___8 - tmp___9) - 1UL));
#line 1124
                if (tmp___10) {
#line 1126
                  rename_file(file, name___0);
#line 1127
                  while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 1127
                    file = file->renamed;
                  }
#line 1128
                  if (file->last_mtime) {
#line 1128
                    tmp___7 = file->last_mtime;
                  } else {
#line 1128
                    tmp___6 = f_mtime(file, 1);
#line 1128
                    tmp___7 = tmp___6;
                  }
#line 1128
                  return (tmp___7);
                }
#line 1131
                rehash_file(file, name___0);
#line 1132
                while ((unsigned long )file->renamed != (unsigned long )((struct file *)0)) {
#line 1132
                  file = file->renamed;
                }
#line 1133
                mtime = name_mtime(name___0);
              }
            }
          }
        }
      }
    }
  }
#line 1146
  if (! clock_skew_detected) {
#line 1146
    if (mtime != 0xffffffffffffffffUL) {
#line 1146
      if (mtime > now) {
#line 1146
        if (! file->updated) {
#line 1153
          now = file_timestamp_now();
#line 1168
          if (mtime > now) {
#line 1175
            file_timestamp_sprintf(mtimebuf, mtime);
#line 1176
            file_timestamp_sprintf(nowbuf, now);
#line 1177
            tmp___14 = dcgettext((char const   *)((void *)0), "*** Warning: File `%s\' has modification time in the future (%s > %s)",
                                 5);
#line 1177
            error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___14,
                  file->name, mtimebuf, nowbuf);
#line 1179
            clock_skew_detected = 1;
          }
        }
      }
    }
  }
#line 1185
  if (file->double_colon) {
#line 1186
    file = file->double_colon;
  }
#line 1188
  while (1) {
#line 1195
    if (mtime != 0xffffffffffffffffUL) {
#line 1195
      if ((unsigned int )file->command_state == 0U) {
#line 1195
        if (! file->tried_implicit) {
#line 1195
          if (file->intermediate) {
#line 1197
            file->intermediate = 0U;
          }
        }
      }
    }
#line 1199
    file->last_mtime = mtime;
#line 1200
    file = file->prev;
#line 1188
    if (! ((unsigned long )file != (unsigned long )((struct file *)0))) {
#line 1188
      break;
    }
  }
#line 1204
  return (mtime);
}
}
#line 1210 "remake.c"
static uintmax_t name_mtime(char *name ) 
{ 
  struct stat st ;
  int tmp ;
  uintmax_t tmp___0 ;
  uintmax_t tmp___1 ;

  {
#line 1216
  tmp = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
#line 1216
  if (tmp < 0) {
#line 1217
    return ((uintmax_t )-1);
  }
#line 1219
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 1219
    tmp___0 = (uintmax_t )1000000000;
  } else {
#line 1219
    tmp___0 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 1219
  if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 1219
    tmp___1 = (uintmax_t )1000000000;
  } else {
#line 1219
    tmp___1 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
  }
#line 1219
  return ((uintmax_t )st.st_mtim.tv_sec * tmp___0 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___1) / 1000000000UL);
}
}
#line 1232 "remake.c"
static char *dirs[4]  = {      (char *)"/lib",      (char *)"/usr/lib",      (char *)"/usr/local/lib",      (char *)0};
#line 1249 "remake.c"
static char *libpatterns  =    (char *)((void *)0);
#line 1275 "remake.c"
static char *buf___0  =    (char *)((void *)0);
#line 1276 "remake.c"
static int buflen  =    0;
#line 1277 "remake.c"
static int libdir_maxlen  =    -1;
#line 1227 "remake.c"
static int library_search(char **lib , uintmax_t *mtime_ptr ) 
{ 
  char *libname ;
  uintmax_t mtime ;
  char *p ;
  char *p2 ;
  unsigned int len ;
  char *file ;
  char **dp ;
  int save ;
  char *tmp ;
  char *libbuf ;
  char *tmp___0 ;
  char c ;
  char *p3 ;
  char *p4 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int l ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 1251
  libname = *lib + 2;
#line 1261
  if (! libpatterns) {
#line 1263
    save = warn_undefined_variables_flag;
#line 1264
    warn_undefined_variables_flag = 0;
#line 1266
    tmp = variable_expand((char *)"$(strip $(.LIBPATTERNS))");
#line 1266
    libpatterns = xstrdup((char const   *)tmp);
#line 1268
    warn_undefined_variables_flag = save;
  }
#line 1272
  p2 = libpatterns;
#line 1273
  while (1) {
#line 1273
    p = find_next_token(& p2, & len);
#line 1273
    if (! ((unsigned long )p != (unsigned long )((char *)0))) {
#line 1273
      break;
    }
#line 1278
    tmp___0 = variable_expand((char *)"");
#line 1278
    libbuf = tmp___0;
#line 1282
    c = *(p + len);
#line 1285
    *(p + len) = (char )'\000';
#line 1286
    p3 = find_percent(p);
#line 1287
    if (! p3) {
#line 1291
      tmp___1 = dcgettext((char const   *)((void *)0), ".LIBPATTERNS element `%s\' is not a pattern",
                          5);
#line 1291
      error((struct floc  const  *)((struct floc *)0), (char const   *)tmp___1, p);
#line 1292
      while (len) {
#line 1293
        *p = (char )' ';
#line 1292
        len --;
#line 1292
        p ++;
      }
#line 1294
      *p = c;
#line 1295
      continue;
    }
#line 1297
    p4 = variable_buffer_output(libbuf, p, (unsigned int )(p3 - p));
#line 1298
    tmp___2 = strlen((char const   *)libname);
#line 1298
    p4 = variable_buffer_output(p4, libname, (unsigned int )tmp___2);
#line 1299
    p4 = variable_buffer_output(p4, p3 + 1, (unsigned int )((long )len - (p3 - p)));
#line 1300
    *(p + len) = c;
#line 1304
    mtime = name_mtime(libbuf);
#line 1305
    if (mtime != 0xffffffffffffffffUL) {
#line 1307
      *lib = xstrdup((char const   *)libbuf);
#line 1308
      if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
#line 1309
        *mtime_ptr = mtime;
      }
#line 1310
      return (1);
    }
#line 1315
    file = libbuf;
#line 1316
    tmp___3 = vpath_search(& file, mtime_ptr);
#line 1316
    if (tmp___3) {
#line 1318
      *lib = file;
#line 1319
      return (1);
    }
#line 1324
    if (! buflen) {
#line 1326
      dp = dirs;
#line 1326
      while ((unsigned long )*dp != (unsigned long )((char *)0)) {
#line 1328
        tmp___4 = strlen((char const   *)*dp);
#line 1328
        l = (int )tmp___4;
#line 1329
        if (l > libdir_maxlen) {
#line 1330
          libdir_maxlen = l;
        }
#line 1326
        dp ++;
      }
#line 1332
      tmp___5 = strlen((char const   *)libbuf);
#line 1332
      buflen = (int )tmp___5;
#line 1333
      buf___0 = xmalloc((unsigned int )((libdir_maxlen + buflen) + 2));
    } else {
#line 1335
      tmp___7 = strlen((char const   *)libbuf);
#line 1335
      if ((size_t )buflen < tmp___7) {
#line 1337
        tmp___6 = strlen((char const   *)libbuf);
#line 1337
        buflen = (int )tmp___6;
#line 1338
        buf___0 = xrealloc(buf___0, (unsigned int )((libdir_maxlen + buflen) + 2));
      }
    }
#line 1341
    dp = dirs;
#line 1341
    while ((unsigned long )*dp != (unsigned long )((char *)0)) {
#line 1343
      sprintf((char * __restrict  )buf___0, (char const   * __restrict  )"%s/%s",
              *dp, libbuf);
#line 1344
      mtime = name_mtime(buf___0);
#line 1345
      if (mtime != 0xffffffffffffffffUL) {
#line 1347
        *lib = xstrdup((char const   *)buf___0);
#line 1348
        if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
#line 1349
          *mtime_ptr = mtime;
        }
#line 1350
        return (1);
      }
#line 1341
      dp ++;
    }
  }
#line 1355
  return (0);
}
}
#line 1 "rule.o"
#pragma merger("0","/tmp/cil-0tmpYMlz.i","-g,-O0")
#line 105 "filedef.h"
struct file *suffix_file  ;
#line 101 "variable.h"
struct variable_set_list *create_new_variable_set(void) ;
#line 107
void print_variable_set(struct variable_set *set , char *prefix ) ;
#line 50 "rule.h"
struct rule *pattern_rules  ;
#line 51 "rule.h"
struct rule *last_pattern_rule  ;
#line 52 "rule.h"
unsigned int num_pattern_rules  ;
#line 54 "rule.h"
unsigned int max_pattern_deps  ;
#line 55 "rule.h"
unsigned int max_pattern_targets  ;
#line 56 "rule.h"
unsigned int max_pattern_dep_length  ;
#line 59 "rule.h"
unsigned int maxsuffix  ;
#line 62
void install_pattern_rule(struct pspec *p , int terminal ) ;
#line 63
int new_pattern_rule(struct rule *rule , int override ) ;
#line 65
struct pattern_var *lookup_pattern_var(char *target ) ;
#line 28 "rule.c"
static void freerule(struct rule *rule , struct rule *lastrule ) ;
#line 56 "rule.c"
static struct pattern_var *pattern_vars  ;
#line 60 "rule.c"
static struct pattern_var *last_pattern_var  ;
#line 76 "rule.c"
void count_implicit_rule_limits(void) 
{ 
  char *name ;
  unsigned int namelen ;
  register struct rule *rule ;
  register struct rule *lastrule ;
  unsigned int ndeps ;
  register struct dep *dep ;
  struct rule *next ;
  unsigned int ntargets ;
  unsigned int len ;
  size_t tmp ;
  char *p ;
  char *tmp___0 ;
  char *p2 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 83
  max_pattern_deps = 0U;
#line 83
  max_pattern_targets = max_pattern_deps;
#line 83
  num_pattern_rules = max_pattern_targets;
#line 84
  max_pattern_dep_length = 0U;
#line 86
  name = (char *)0;
#line 87
  namelen = 0U;
#line 88
  rule = pattern_rules;
#line 89
  lastrule = (struct rule *)0;
#line 90
  while ((unsigned long )rule != (unsigned long )((struct rule *)0)) {
#line 92
    ndeps = 0U;
#line 94
    next = rule->next;
#line 97
    num_pattern_rules ++;
#line 99
    ntargets = 0U;
#line 100
    while ((unsigned long )*(rule->targets + ntargets) != (unsigned long )((char *)0)) {
#line 101
      ntargets ++;
    }
#line 103
    if (ntargets > max_pattern_targets) {
#line 104
      max_pattern_targets = ntargets;
    }
#line 106
    dep = rule->deps;
#line 106
    while ((unsigned long )dep != (unsigned long )((struct dep *)0)) {
#line 108
      tmp = strlen((char const   *)dep->name);
#line 108
      len = (unsigned int )tmp;
#line 117
      tmp___0 = strrchr((char const   *)dep->name, '/');
#line 117
      p = tmp___0;
#line 118
      if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 118
        tmp___1 = strchr((char const   *)dep->name, '%');
#line 118
        tmp___2 = tmp___1;
      } else {
#line 118
        tmp___2 = (char *)0;
      }
#line 118
      p2 = tmp___2;
#line 120
      ndeps ++;
#line 122
      if (len > max_pattern_dep_length) {
#line 123
        max_pattern_dep_length = len;
      }
#line 125
      if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 125
        if ((unsigned long )p2 > (unsigned long )p) {
#line 129
          if ((unsigned long )p == (unsigned long )dep->name) {
#line 130
            p ++;
          }
#line 131
          if (p - dep->name > (long )namelen) {
#line 133
            if ((unsigned long )name != (unsigned long )((char *)0)) {
#line 134
              free((void *)name);
            }
#line 135
            namelen = (unsigned int )(p - dep->name);
#line 136
            tmp___3 = xmalloc(namelen + 1U);
#line 136
            name = tmp___3;
          }
#line 138
          memmove((void *)name, (void const   *)dep->name, (size_t )(p - dep->name));
#line 139
          *(name + (p - dep->name)) = (char )'\000';
#line 145
          tmp___4 = dir_file_exists_p(name, (char *)"");
#line 145
          if (tmp___4) {
#line 145
            tmp___5 = 0;
          } else {
#line 145
            tmp___5 = 1;
          }
#line 145
          dep->changed = tmp___5;
#line 149
          if (dep->changed) {
#line 149
            if ((int )*name == 47) {
#line 156
              freerule(rule, lastrule);
#line 157
              num_pattern_rules --;
#line 158
              goto end_main_loop;
            }
          }
        } else {
#line 163
          dep->changed = 0;
        }
      } else {
#line 163
        dep->changed = 0;
      }
#line 106
      dep = dep->next;
    }
#line 166
    if (ndeps > max_pattern_deps) {
#line 167
      max_pattern_deps = ndeps;
    }
#line 169
    lastrule = rule;
    end_main_loop: 
#line 171
    rule = next;
  }
#line 174
  if ((unsigned long )name != (unsigned long )((char *)0)) {
#line 175
    free((void *)name);
  }
#line 176
  return;
}
}
#line 184 "rule.c"
static void convert_suffix_rule(char *target , char *source , struct commands *cmds ) 
{ 
  char *targname ;
  char *targpercent ;
  char *depname ;
  char **names ;
  char **percents ;
  struct dep *deps ;
  unsigned int len ;
  size_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 194
  if ((unsigned long )target == (unsigned long )((char *)0)) {
#line 201
    targname = savestring("(%.o)", 5U);
#line 203
    targpercent = targname + 1;
  } else {
#line 208
    tmp = strlen((char const   *)target);
#line 208
    len = (unsigned int )tmp;
#line 209
    targname = xmalloc((1U + len) + 1U);
#line 210
    *(targname + 0) = (char )'%';
#line 211
    memmove((void *)(targname + 1), (void const   *)target, (size_t )(len + 1U));
#line 212
    targpercent = targname;
  }
#line 215
  tmp___0 = xmalloc((unsigned int )(2UL * sizeof(char *)));
#line 215
  names = (char **)tmp___0;
#line 216
  tmp___1 = __builtin_alloca(2UL * sizeof(char *));
#line 216
  percents = (char **)tmp___1;
#line 217
  *(names + 0) = targname;
#line 218
  *(percents + 0) = targpercent;
#line 219
  tmp___2 = (char *)0;
#line 219
  *(percents + 1) = tmp___2;
#line 219
  *(names + 1) = tmp___2;
#line 221
  if ((unsigned long )source == (unsigned long )((char *)0)) {
#line 222
    deps = (struct dep *)0;
  } else {
#line 226
    tmp___3 = strlen((char const   *)source);
#line 226
    len = (unsigned int )tmp___3;
#line 227
    depname = xmalloc((1U + len) + 1U);
#line 228
    *(depname + 0) = (char )'%';
#line 229
    memmove((void *)(depname + 1), (void const   *)source, (size_t )(len + 1U));
#line 230
    tmp___4 = xmalloc((unsigned int )sizeof(struct dep ));
#line 230
    deps = (struct dep *)tmp___4;
#line 231
    deps->next = (struct dep *)0;
#line 232
    deps->name = depname;
  }
#line 235
  create_pattern_rule(names, percents, 0, deps, cmds, 0);
#line 236
  return;
}
}
#line 242 "rule.c"
void convert_to_pattern(void) 
{ 
  register struct dep *d ;
  register struct dep *d2 ;
  register struct file *f ;
  register char *rulename ;
  register unsigned int slen ;
  register unsigned int s2len ;
  register unsigned int namelen ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 252
  maxsuffix = 0U;
#line 253
  d = suffix_file->deps;
#line 253
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 255
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 255
      tmp = (d->file)->name;
    } else {
#line 255
      tmp = d->name;
    }
#line 255
    tmp___0 = strlen((char const   *)tmp);
#line 255
    namelen = (unsigned int )tmp___0;
#line 256
    if (namelen > maxsuffix) {
#line 257
      maxsuffix = namelen;
    }
#line 253
    d = d->next;
  }
#line 260
  tmp___1 = __builtin_alloca((unsigned long )(maxsuffix * 2U + 1U));
#line 260
  rulename = (char *)tmp___1;
#line 262
  d = suffix_file->deps;
#line 262
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 266
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 266
      tmp___2 = (d->file)->name;
    } else {
#line 266
      tmp___2 = d->name;
    }
#line 266
    convert_suffix_rule(tmp___2, (char *)0, (struct commands *)0);
#line 268
    f = d->file;
#line 269
    if ((unsigned long )f->cmds != (unsigned long )((struct commands *)0)) {
#line 271
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 271
        tmp___3 = (d->file)->name;
      } else {
#line 271
        tmp___3 = d->name;
      }
#line 271
      convert_suffix_rule((char *)"", tmp___3, f->cmds);
    }
#line 274
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 274
      tmp___4 = (d->file)->name;
    } else {
#line 274
      tmp___4 = d->name;
    }
#line 274
    tmp___5 = strlen((char const   *)tmp___4);
#line 274
    slen = (unsigned int )tmp___5;
#line 275
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 275
      tmp___6 = (d->file)->name;
    } else {
#line 275
      tmp___6 = d->name;
    }
#line 275
    memmove((void *)rulename, (void const   *)tmp___6, (size_t )slen);
#line 276
    d2 = suffix_file->deps;
#line 276
    while ((unsigned long )d2 != (unsigned long )((struct dep *)0)) {
#line 278
      if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 278
        tmp___7 = (d2->file)->name;
      } else {
#line 278
        tmp___7 = d2->name;
      }
#line 278
      tmp___8 = strlen((char const   *)tmp___7);
#line 278
      s2len = (unsigned int )tmp___8;
#line 280
      if (slen == s2len) {
#line 280
        if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 280
          tmp___9 = (d->file)->name;
        } else {
#line 280
          tmp___9 = d->name;
        }
#line 280
        if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 280
          tmp___10 = (d2->file)->name;
        } else {
#line 280
          tmp___10 = d2->name;
        }
#line 280
        if ((unsigned long )tmp___9 == (unsigned long )tmp___10) {
#line 281
          goto __Cont;
        } else {
#line 280
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 280
            tmp___11 = (d->file)->name;
          } else {
#line 280
            tmp___11 = d->name;
          }
#line 280
          if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 280
            tmp___12 = (d2->file)->name;
          } else {
#line 280
            tmp___12 = d2->name;
          }
#line 280
          if ((int )*tmp___11 == (int )*tmp___12) {
#line 280
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 280
              tmp___13 = (d->file)->name;
            } else {
#line 280
              tmp___13 = d->name;
            }
#line 280
            if ((int )*tmp___13 == 0) {
#line 281
              goto __Cont;
            } else {
#line 280
              if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 280
                tmp___14 = (d2->file)->name;
              } else {
#line 280
                tmp___14 = d2->name;
              }
#line 280
              if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 280
                tmp___15 = (d->file)->name;
              } else {
#line 280
                tmp___15 = d->name;
              }
#line 280
              tmp___16 = strcmp((char const   *)(tmp___15 + 1), (char const   *)(tmp___14 + 1));
#line 280
              if (! tmp___16) {
#line 281
                goto __Cont;
              }
            }
          }
        }
      }
#line 283
      if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 283
        tmp___17 = (d2->file)->name;
      } else {
#line 283
        tmp___17 = d2->name;
      }
#line 283
      memmove((void *)(rulename + slen), (void const   *)tmp___17, (size_t )(s2len + 1U));
#line 284
      f = lookup_file(rulename);
#line 285
      if ((unsigned long )f == (unsigned long )((struct file *)0)) {
#line 286
        goto __Cont;
      } else
#line 285
      if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
#line 286
        goto __Cont;
      }
#line 288
      if (s2len == 2U) {
#line 288
        if ((int )*(rulename + slen) == 46) {
#line 288
          if ((int )*(rulename + (slen + 1U)) == 97) {
#line 291
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 291
              tmp___18 = (d->file)->name;
            } else {
#line 291
              tmp___18 = d->name;
            }
#line 291
            convert_suffix_rule((char *)0, tmp___18, f->cmds);
          }
        }
      }
#line 297
      if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 297
        tmp___19 = (d->file)->name;
      } else {
#line 297
        tmp___19 = d->name;
      }
#line 297
      if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 297
        tmp___20 = (d2->file)->name;
      } else {
#line 297
        tmp___20 = d2->name;
      }
#line 297
      convert_suffix_rule(tmp___20, tmp___19, f->cmds);
      __Cont: /* CIL Label */ 
#line 276
      d2 = d2->next;
    }
#line 262
    d = d->next;
  }
#line 300
  return;
}
}
#line 311 "rule.c"
int new_pattern_rule(struct rule *rule , int override ) 
{ 
  register struct rule *r ;
  register struct rule *lastrule ;
  register unsigned int i ;
  register unsigned int j ;
  int tmp ;
  register struct dep *d ;
  register struct dep *d2 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 319
  rule->in_use = (char)0;
#line 320
  rule->terminal = (char)0;
#line 322
  rule->next = (struct rule *)0;
#line 325
  lastrule = (struct rule *)0;
#line 326
  r = pattern_rules;
#line 326
  while ((unsigned long )r != (unsigned long )((struct rule *)0)) {
#line 327
    i = 0U;
#line 327
    while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
#line 329
      j = 0U;
#line 329
      while ((unsigned long )*(r->targets + j) != (unsigned long )((char *)0)) {
#line 330
        if (! ((unsigned long )*(rule->targets + i) == (unsigned long )*(r->targets + j))) {
#line 330
          if ((int )*(*(rule->targets + i)) == (int )*(*(r->targets + j))) {
#line 330
            if (! ((int )*(*(rule->targets + i)) == 0)) {
#line 330
              tmp = strcmp((char const   *)(*(rule->targets + i) + 1), (char const   *)(*(r->targets + j) + 1));
#line 330
              if (tmp) {
#line 331
                break;
              }
            }
          } else {
#line 331
            break;
          }
        }
#line 329
        j ++;
      }
#line 332
      if ((unsigned long )*(r->targets + j) == (unsigned long )((char *)0)) {
#line 336
        d = rule->deps;
#line 336
        d2 = r->deps;
#line 336
        while (1) {
#line 336
          if ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 336
            if (! ((unsigned long )d2 != (unsigned long )((struct dep *)0))) {
#line 336
              break;
            }
          } else {
#line 336
            break;
          }
#line 338
          if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 338
            tmp___0 = (d->file)->name;
          } else {
#line 338
            tmp___0 = d->name;
          }
#line 338
          if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 338
            tmp___1 = (d2->file)->name;
          } else {
#line 338
            tmp___1 = d2->name;
          }
#line 338
          if (! ((unsigned long )tmp___0 == (unsigned long )tmp___1)) {
#line 338
            if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 338
              tmp___2 = (d->file)->name;
            } else {
#line 338
              tmp___2 = d->name;
            }
#line 338
            if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 338
              tmp___3 = (d2->file)->name;
            } else {
#line 338
              tmp___3 = d2->name;
            }
#line 338
            if ((int )*tmp___2 == (int )*tmp___3) {
#line 338
              if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 338
                tmp___4 = (d->file)->name;
              } else {
#line 338
                tmp___4 = d->name;
              }
#line 338
              if (! ((int )*tmp___4 == 0)) {
#line 338
                if ((unsigned long )d2->name == (unsigned long )((char *)0)) {
#line 338
                  tmp___5 = (d2->file)->name;
                } else {
#line 338
                  tmp___5 = d2->name;
                }
#line 338
                if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 338
                  tmp___6 = (d->file)->name;
                } else {
#line 338
                  tmp___6 = d->name;
                }
#line 338
                tmp___7 = strcmp((char const   *)(tmp___6 + 1), (char const   *)(tmp___5 + 1));
#line 338
                if (tmp___7) {
#line 339
                  break;
                }
              }
            } else {
#line 339
              break;
            }
          }
#line 336
          d = d->next;
#line 336
          d2 = d2->next;
        }
#line 340
        if ((unsigned long )d == (unsigned long )((struct dep *)0)) {
#line 340
          if ((unsigned long )d2 == (unsigned long )((struct dep *)0)) {
#line 343
            if (override) {
#line 346
              freerule(r, lastrule);
#line 348
              if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
#line 349
                pattern_rules = rule;
              } else {
#line 351
                last_pattern_rule->next = rule;
              }
#line 352
              last_pattern_rule = rule;
#line 355
              goto matched;
            } else {
#line 360
              freerule(rule, (struct rule *)0);
#line 361
              return (0);
            }
          }
        }
      }
#line 327
      i ++;
    }
#line 326
    lastrule = r;
#line 326
    r = r->next;
  }
  matched: ;
#line 369
  if ((unsigned long )r == (unsigned long )((struct rule *)0)) {
#line 372
    if ((unsigned long )pattern_rules == (unsigned long )((struct rule *)0)) {
#line 373
      pattern_rules = rule;
    } else {
#line 375
      last_pattern_rule->next = rule;
    }
#line 376
    last_pattern_rule = rule;
  }
#line 379
  return (1);
}
}
#line 388 "rule.c"
void install_pattern_rule(struct pspec *p , int terminal ) 
{ 
  register struct rule *r ;
  char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  struct nameseq *tmp___4 ;
  struct nameseq *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 396
  tmp = xmalloc((unsigned int )sizeof(struct rule ));
#line 396
  r = (struct rule *)tmp;
#line 398
  tmp___0 = xmalloc((unsigned int )(2UL * sizeof(char *)));
#line 398
  r->targets = (char **)tmp___0;
#line 399
  tmp___1 = xmalloc((unsigned int )(2UL * sizeof(char *)));
#line 399
  r->suffixes = (char **)tmp___1;
#line 400
  tmp___2 = xmalloc((unsigned int )(2UL * sizeof(unsigned int )));
#line 400
  r->lens = (unsigned int *)tmp___2;
#line 402
  *(r->targets + 1) = (char *)0;
#line 403
  *(r->suffixes + 1) = (char *)0;
#line 404
  *(r->lens + 1) = 0U;
#line 406
  tmp___3 = strlen((char const   *)p->target);
#line 406
  *(r->lens + 0) = (unsigned int )tmp___3;
#line 409
  *(r->targets + 0) = savestring((char const   *)p->target, *(r->lens + 0));
#line 410
  *(r->suffixes + 0) = find_percent(*(r->targets + 0));
#line 411
  if ((unsigned long )*(r->suffixes + 0) == (unsigned long )((char *)0)) {
#line 413
    abort();
  } else {
#line 415
    (*(r->suffixes + 0)) ++;
  }
#line 417
  ptr = p->dep;
#line 418
  tmp___4 = parse_file_seq(& ptr, '\000', (unsigned int )sizeof(struct dep ), 1);
#line 418
  tmp___5 = multi_glob(tmp___4, (unsigned int )sizeof(struct dep ));
#line 418
  r->deps = (struct dep *)tmp___5;
#line 422
  tmp___7 = new_pattern_rule(r, 0);
#line 422
  if (tmp___7) {
#line 424
    r->terminal = (char )terminal;
#line 425
    tmp___6 = xmalloc((unsigned int )sizeof(struct commands ));
#line 425
    r->cmds = (struct commands *)tmp___6;
#line 426
    (r->cmds)->fileinfo.filenm = (char *)0;
#line 427
    (r->cmds)->fileinfo.lineno = 0UL;
#line 430
    (r->cmds)->commands = xstrdup((char const   *)p->commands);
#line 431
    (r->cmds)->command_lines = (char **)0;
  }
#line 433
  return;
}
}
#line 440 "rule.c"
static void freerule(struct rule *rule , struct rule *lastrule ) 
{ 
  struct rule *next ;
  register unsigned int i ;
  register struct dep *dep ;
  struct dep *t ;

  {
#line 444
  next = rule->next;
#line 448
  i = 0U;
#line 448
  while ((unsigned long )*(rule->targets + i) != (unsigned long )((char *)0)) {
#line 449
    free((void *)*(rule->targets + i));
#line 448
    i ++;
  }
#line 451
  dep = rule->deps;
#line 452
  while (dep) {
#line 456
    t = dep->next;
#line 459
    free((void *)((char *)dep));
#line 460
    dep = t;
  }
#line 463
  free((void *)((char *)rule->targets));
#line 464
  free((void *)((char *)rule->suffixes));
#line 465
  free((void *)((char *)rule->lens));
#line 478
  free((void *)((char *)rule));
#line 480
  if ((unsigned long )pattern_rules == (unsigned long )rule) {
#line 481
    if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
#line 482
      abort();
    } else {
#line 484
      pattern_rules = next;
    }
  } else
#line 485
  if ((unsigned long )lastrule != (unsigned long )((struct rule *)0)) {
#line 486
    lastrule->next = next;
  }
#line 487
  if ((unsigned long )last_pattern_rule == (unsigned long )rule) {
#line 488
    last_pattern_rule = lastrule;
  }
#line 489
  return;
}
}
#line 502 "rule.c"
void create_pattern_rule(char **targets , char **target_percents , int terminal ,
                         struct dep *deps , struct commands *commands , int override ) 
{ 
  register struct rule *r ;
  char *tmp ;
  register unsigned int max_targets ;
  register unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 511
  tmp = xmalloc((unsigned int )sizeof(struct rule ));
#line 511
  r = (struct rule *)tmp;
#line 514
  r->cmds = commands;
#line 515
  r->deps = deps;
#line 516
  r->targets = targets;
#line 518
  max_targets = 2U;
#line 519
  tmp___0 = xmalloc((unsigned int )(2UL * sizeof(unsigned int )));
#line 519
  r->lens = (unsigned int *)tmp___0;
#line 520
  tmp___1 = xmalloc((unsigned int )(2UL * sizeof(char *)));
#line 520
  r->suffixes = (char **)tmp___1;
#line 521
  i = 0U;
#line 521
  while ((unsigned long )*(targets + i) != (unsigned long )((char *)0)) {
#line 523
    if (i == max_targets - 1U) {
#line 525
      max_targets += 5U;
#line 526
      tmp___2 = xrealloc((char *)r->lens, (unsigned int )((unsigned long )max_targets * sizeof(unsigned int )));
#line 526
      r->lens = (unsigned int *)tmp___2;
#line 528
      tmp___3 = xrealloc((char *)r->suffixes, (unsigned int )((unsigned long )max_targets * sizeof(char *)));
#line 528
      r->suffixes = (char **)tmp___3;
    }
#line 531
    tmp___4 = strlen((char const   *)*(targets + i));
#line 531
    *(r->lens + i) = (unsigned int )tmp___4;
#line 532
    if ((unsigned long )target_percents == (unsigned long )((char **)0)) {
#line 532
      tmp___5 = find_percent(*(targets + i));
#line 532
      tmp___6 = tmp___5;
    } else {
#line 532
      tmp___6 = *(target_percents + i);
    }
#line 532
    *(r->suffixes + i) = tmp___6 + 1;
#line 534
    if ((unsigned long )*(r->suffixes + i) == (unsigned long )((char *)0)) {
#line 535
      abort();
    }
#line 521
    i ++;
  }
#line 538
  if (i < max_targets - 1U) {
#line 540
    tmp___7 = xrealloc((char *)r->lens, (unsigned int )((unsigned long )(i + 1U) * sizeof(unsigned int )));
#line 540
    r->lens = (unsigned int *)tmp___7;
#line 542
    tmp___8 = xrealloc((char *)r->suffixes, (unsigned int )((unsigned long )(i + 1U) * sizeof(char *)));
#line 542
    r->suffixes = (char **)tmp___8;
  }
#line 546
  tmp___9 = new_pattern_rule(r, override);
#line 546
  if (tmp___9) {
#line 547
    r->terminal = (char )terminal;
  }
#line 548
  return;
}
}
#line 552 "rule.c"
struct pattern_var *create_pattern_var(char *target , char *suffix ) 
{ 
  register struct pattern_var *p ;
  unsigned int len ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 556
  p = (struct pattern_var *)0;
#line 557
  tmp = strlen((char const   *)target);
#line 557
  len = (unsigned int )tmp;
#line 560
  p = pattern_vars;
#line 560
  while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 561
    if (p->len == len) {
#line 561
      tmp___0 = strcmp((char const   *)p->target, (char const   *)target);
#line 561
      if (! tmp___0) {
#line 562
        break;
      }
    }
#line 560
    p = p->next;
  }
#line 564
  if ((unsigned long )p == (unsigned long )((struct pattern_var *)0)) {
#line 566
    tmp___1 = xmalloc((unsigned int )sizeof(struct pattern_var ));
#line 566
    p = (struct pattern_var *)tmp___1;
#line 567
    if ((unsigned long )last_pattern_var != (unsigned long )((struct pattern_var *)0)) {
#line 568
      last_pattern_var->next = p;
    } else {
#line 570
      pattern_vars = p;
    }
#line 571
    last_pattern_var = p;
#line 572
    p->next = (struct pattern_var *)0;
#line 573
    p->target = target;
#line 574
    p->len = len;
#line 575
    p->suffix = suffix + 1;
#line 576
    p->vars = create_new_variable_set();
  }
#line 579
  return (p);
}
}
#line 584 "rule.c"
struct pattern_var *lookup_pattern_var(char *target ) 
{ 
  struct pattern_var *p ;
  unsigned int targlen ;
  size_t tmp ;
  char *stem ;
  unsigned int stemlen ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 589
  tmp = strlen((char const   *)target);
#line 589
  targlen = (unsigned int )tmp;
#line 591
  p = pattern_vars;
#line 591
  while ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
#line 596
    if (p->len > targlen) {
#line 598
      goto __Cont;
    }
#line 602
    stem = target + ((p->suffix - p->target) - 1L);
#line 603
    stemlen = (targlen - p->len) + 1U;
#line 606
    if ((unsigned long )stem > (unsigned long )target) {
#line 606
      tmp___0 = strncmp((char const   *)p->target, (char const   *)target, (size_t )(stem - target));
#line 606
      if (! (tmp___0 == 0)) {
#line 607
        goto __Cont;
      }
    }
#line 614
    if ((int )*(p->suffix) == (int )*(stem + stemlen)) {
#line 614
      if ((int )*(p->suffix) == 0) {
#line 616
        break;
      } else
#line 614
      if ((unsigned long )(p->suffix + 1) == (unsigned long )(stem + (stemlen + 1U))) {
#line 616
        break;
      } else
#line 614
      if ((int )*(p->suffix + 1) == (int )*(stem + (stemlen + 1U))) {
#line 614
        if ((int )*(p->suffix + 1) == 0) {
#line 616
          break;
        } else {
#line 614
          tmp___1 = strcmp((char const   *)((p->suffix + 1) + 1), (char const   *)((stem + (stemlen + 1U)) + 1));
#line 614
          if (! tmp___1) {
#line 616
            break;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 591
    p = p->next;
  }
#line 619
  return (p);
}
}
#line 624 "rule.c"
static void print_rule(struct rule *r ) 
{ 
  register unsigned int i ;
  register struct dep *d ;
  char *tmp ;

  {
#line 631
  i = 0U;
#line 631
  while ((unsigned long )*(r->targets + i) != (unsigned long )((char *)0)) {
#line 633
    fputs((char const   * __restrict  )*(r->targets + i), (FILE * __restrict  )stdout);
#line 634
    if ((unsigned long )*(r->targets + (i + 1U)) != (unsigned long )((char *)0)) {
#line 635
      putchar(' ');
    } else {
#line 637
      putchar(':');
    }
#line 631
    i ++;
  }
#line 639
  if (r->terminal) {
#line 640
    putchar(':');
  }
#line 642
  d = r->deps;
#line 642
  while ((unsigned long )d != (unsigned long )((struct dep *)0)) {
#line 643
    if ((unsigned long )d->name == (unsigned long )((char *)0)) {
#line 643
      tmp = (d->file)->name;
    } else {
#line 643
      tmp = d->name;
    }
#line 643
    printf((char const   * __restrict  )" %s", tmp);
#line 642
    d = d->next;
  }
#line 644
  putchar('\n');
#line 646
  if ((unsigned long )r->cmds != (unsigned long )((struct commands *)0)) {
#line 647
    print_commands(r->cmds);
  }
#line 648
  return;
}
}
#line 650 "rule.c"
void print_rule_data_base(void) 
{ 
  register unsigned int rules ;
  register unsigned int terminal ;
  register struct rule *r ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct pattern_var *p ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 656
  puts("\n# Implicit Rules");
#line 658
  terminal = 0U;
#line 658
  rules = terminal;
#line 659
  r = pattern_rules;
#line 659
  while ((unsigned long )r != (unsigned long )((struct rule *)0)) {
#line 661
    rules ++;
#line 663
    putchar('\n');
#line 664
    print_rule(r);
#line 666
    if (r->terminal) {
#line 667
      terminal ++;
    }
#line 659
    r = r->next;
  }
#line 670
  if (rules == 0U) {
#line 671
    tmp = dcgettext((char const   *)((void *)0), "\n# No implicit rules.", 5);
#line 671
    puts((char const   *)tmp);
  } else {
#line 674
    tmp___0 = dcgettext((char const   *)((void *)0), "\n# %u implicit rules, %u",
                        5);
#line 674
    printf((char const   * __restrict  )tmp___0, rules, terminal);
#line 676
    printf((char const   * __restrict  )" (%.1f%%)", ((double )terminal / (double )rules) * 100.0);
#line 683
    tmp___1 = dcgettext((char const   *)((void *)0), " terminal.", 5);
#line 683
    puts((char const   *)tmp___1);
  }
#line 686
  if (num_pattern_rules != rules) {
#line 690
    if (num_pattern_rules != 0U) {
#line 691
      tmp___2 = dcgettext((char const   *)((void *)0), "BUG: num_pattern_rules wrong!  %u != %u",
                          5);
#line 691
      fatal((struct floc  const  *)((struct floc *)0), (char const   *)tmp___2, num_pattern_rules,
            rules);
    }
  }
#line 695
  tmp___3 = dcgettext((char const   *)((void *)0), "\n# Pattern-specific variable values",
                      5);
#line 695
  puts((char const   *)tmp___3);
#line 700
  rules = 0U;
#line 701
  p = pattern_vars;
#line 701
  while ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
#line 703
    rules ++;
#line 705
    printf((char const   * __restrict  )"\n%s :\n", p->target);
#line 706
    print_variable_set((p->vars)->set, (char *)"# ");
#line 701
    p = p->next;
  }
#line 709
  if (rules == 0U) {
#line 710
    tmp___4 = dcgettext((char const   *)((void *)0), "\n# No pattern-specific variable values.",
                        5);
#line 710
    puts((char const   *)tmp___4);
  } else {
#line 713
    tmp___5 = dcgettext((char const   *)((void *)0), "\n# %u pattern-specific variable values",
                        5);
#line 713
    printf((char const   * __restrict  )tmp___5, rules);
  }
#line 716
  return;
}
}
#line 1 "signame.o"
#pragma merger("0","/tmp/cil-69Lai5Wm.i","-g,-O0")
#line 23 "signame.h"
void signame_init(void) ;
#line 28
char *sig_abbrev(int number ) ;
#line 32
int sig_number(char const   *abbrev ) ;
#line 65 "signame.c"
static num_abbrev sig_table[130]  ;
#line 67 "signame.c"
static int sig_table_nelts  =    0;
#line 71 "signame.c"
static void init_sig(int number , char const   *abbrev , char const   *name ) 
{ 
  int tmp ;

  {
#line 85
  if (sig_table_nelts < 130) {
#line 87
    sig_table[sig_table_nelts].number = number;
#line 88
    tmp = sig_table_nelts;
#line 88
    sig_table_nelts ++;
#line 88
    sig_table[tmp].abbrev = abbrev;
  }
#line 90
  return;
}
}
#line 92 "signame.c"
void signame_init(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 108
  tmp = dcgettext((char const   *)((void *)0), "Hangup", 5);
#line 108
  init_sig(1, "HUP", (char const   *)tmp);
#line 111
  tmp___0 = dcgettext((char const   *)((void *)0), "Interrupt", 5);
#line 111
  init_sig(2, "INT", (char const   *)tmp___0);
#line 114
  tmp___1 = dcgettext((char const   *)((void *)0), "Quit", 5);
#line 114
  init_sig(3, "QUIT", (char const   *)tmp___1);
#line 117
  tmp___2 = dcgettext((char const   *)((void *)0), "Illegal Instruction", 5);
#line 117
  init_sig(4, "ILL", (char const   *)tmp___2);
#line 120
  tmp___3 = dcgettext((char const   *)((void *)0), "Trace/breakpoint trap", 5);
#line 120
  init_sig(5, "TRAP", (char const   *)tmp___3);
#line 125
  tmp___4 = dcgettext((char const   *)((void *)0), "Aborted", 5);
#line 125
  init_sig(6, "ABRT", (char const   *)tmp___4);
#line 128
  tmp___5 = dcgettext((char const   *)((void *)0), "IOT trap", 5);
#line 128
  init_sig(6, "IOT", (char const   *)tmp___5);
#line 134
  tmp___6 = dcgettext((char const   *)((void *)0), "Floating point exception", 5);
#line 134
  init_sig(8, "FPE", (char const   *)tmp___6);
#line 137
  tmp___7 = dcgettext((char const   *)((void *)0), "Killed", 5);
#line 137
  init_sig(9, "KILL", (char const   *)tmp___7);
#line 140
  tmp___8 = dcgettext((char const   *)((void *)0), "Bus error", 5);
#line 140
  init_sig(7, "BUS", (char const   *)tmp___8);
#line 143
  tmp___9 = dcgettext((char const   *)((void *)0), "Segmentation fault", 5);
#line 143
  init_sig(11, "SEGV", (char const   *)tmp___9);
#line 146
  tmp___10 = dcgettext((char const   *)((void *)0), "Bad system call", 5);
#line 146
  init_sig(31, "SYS", (char const   *)tmp___10);
#line 149
  tmp___11 = dcgettext((char const   *)((void *)0), "Broken pipe", 5);
#line 149
  init_sig(13, "PIPE", (char const   *)tmp___11);
#line 152
  tmp___12 = dcgettext((char const   *)((void *)0), "Alarm clock", 5);
#line 152
  init_sig(14, "ALRM", (char const   *)tmp___12);
#line 155
  tmp___13 = dcgettext((char const   *)((void *)0), "Terminated", 5);
#line 155
  init_sig(15, "TERM", (char const   *)tmp___13);
#line 158
  tmp___14 = dcgettext((char const   *)((void *)0), "User defined signal 1", 5);
#line 158
  init_sig(10, "USR1", (char const   *)tmp___14);
#line 161
  tmp___15 = dcgettext((char const   *)((void *)0), "User defined signal 2", 5);
#line 161
  init_sig(12, "USR2", (char const   *)tmp___15);
#line 166
  tmp___16 = dcgettext((char const   *)((void *)0), "Child exited", 5);
#line 166
  init_sig(17, "CHLD", (char const   *)tmp___16);
#line 169
  tmp___17 = dcgettext((char const   *)((void *)0), "Child exited", 5);
#line 169
  init_sig(17, "CLD", (char const   *)tmp___17);
#line 172
  tmp___18 = dcgettext((char const   *)((void *)0), "Power failure", 5);
#line 172
  init_sig(30, "PWR", (char const   *)tmp___18);
#line 175
  tmp___19 = dcgettext((char const   *)((void *)0), "Stopped", 5);
#line 175
  init_sig(20, "TSTP", (char const   *)tmp___19);
#line 178
  tmp___20 = dcgettext((char const   *)((void *)0), "Stopped (tty input)", 5);
#line 178
  init_sig(21, "TTIN", (char const   *)tmp___20);
#line 181
  tmp___21 = dcgettext((char const   *)((void *)0), "Stopped (tty output)", 5);
#line 181
  init_sig(22, "TTOU", (char const   *)tmp___21);
#line 184
  tmp___22 = dcgettext((char const   *)((void *)0), "Stopped (signal)", 5);
#line 184
  init_sig(19, "STOP", (char const   *)tmp___22);
#line 187
  tmp___23 = dcgettext((char const   *)((void *)0), "CPU time limit exceeded", 5);
#line 187
  init_sig(24, "XCPU", (char const   *)tmp___23);
#line 190
  tmp___24 = dcgettext((char const   *)((void *)0), "File size limit exceeded", 5);
#line 190
  init_sig(25, "XFSZ", (char const   *)tmp___24);
#line 193
  tmp___25 = dcgettext((char const   *)((void *)0), "Virtual timer expired", 5);
#line 193
  init_sig(26, "VTALRM", (char const   *)tmp___25);
#line 196
  tmp___26 = dcgettext((char const   *)((void *)0), "Profiling timer expired", 5);
#line 196
  init_sig(27, "PROF", (char const   *)tmp___26);
#line 202
  tmp___27 = dcgettext((char const   *)((void *)0), "Window changed", 5);
#line 202
  init_sig(28, "WINCH", (char const   *)tmp___27);
#line 205
  tmp___28 = dcgettext((char const   *)((void *)0), "Continued", 5);
#line 205
  init_sig(18, "CONT", (char const   *)tmp___28);
#line 208
  tmp___29 = dcgettext((char const   *)((void *)0), "Urgent I/O condition", 5);
#line 208
  init_sig(23, "URG", (char const   *)tmp___29);
#line 215
  tmp___30 = dcgettext((char const   *)((void *)0), "I/O possible", 5);
#line 215
  init_sig(29, "IO", (char const   *)tmp___30);
#line 224
  tmp___31 = dcgettext((char const   *)((void *)0), "I/O possible", 5);
#line 224
  init_sig(29, "POLL", (char const   *)tmp___31);
#line 238
  return;
}
}
#line 242 "signame.c"
char *sig_abbrev(int number ) 
{ 
  int i ;

  {
#line 248
  if (sig_table_nelts == 0) {
#line 249
    signame_init();
  }
#line 251
  i = 0;
#line 251
  while (i < sig_table_nelts) {
#line 252
    if (sig_table[i].number == number) {
#line 253
      return ((char *)sig_table[i].abbrev);
    }
#line 251
    i ++;
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 260 "signame.c"
int sig_number(char const   *abbrev ) 
{ 
  int i ;
  int tmp ;

  {
#line 266
  if (sig_table_nelts == 0) {
#line 267
    signame_init();
  }
#line 270
  if ((int const   )*(abbrev + 0) == 83) {
#line 270
    if ((int const   )*(abbrev + 1) == 73) {
#line 270
      if ((int const   )*(abbrev + 2) == 71) {
#line 271
        abbrev += 3;
      }
    }
  }
#line 273
  i = 0;
#line 273
  while (i < sig_table_nelts) {
#line 274
    if ((int const   )*(abbrev + 0) == (int const   )*(sig_table[i].abbrev + 0)) {
#line 274
      tmp = strcmp(abbrev, sig_table[i].abbrev);
#line 274
      if (tmp == 0) {
#line 276
        return (sig_table[i].number);
      }
    }
#line 273
    i ++;
  }
#line 277
  return (-1);
}
}
#line 1 "variable.o"
#pragma merger("0","/tmp/cil-juvxJCsk.i","-g,-O0")
#line 137 "variable.h"
int export_all_variables  ;
#line 42 "variable.c"
static struct variable *variable_table[523]  ;
#line 43 "variable.c"
static struct variable_set global_variable_set  =    {variable_table, 523U};
#line 45 "variable.c"
static struct variable_set_list global_setlist  =    {(struct variable_set_list *)0, & global_variable_set};
#line 47 "variable.c"
struct variable_set_list *current_variable_set_list  =    & global_setlist;
#line 49
static struct variable *lookup_variable_in_set(char *name , unsigned int length___0 ,
                                               struct variable_set *set ) ;
#line 61 "variable.c"
struct variable *define_variable_in_set(char *name , unsigned int length___0 , char *value ,
                                        enum variable_origin origin , int recursive ,
                                        struct variable_set *set , struct floc  const  *flocp ) 
{ 
  register unsigned int i ;
  register unsigned int hashval ;
  register struct variable *v ;
  int tmp ;
  char *tmp___0 ;

  {
#line 75
  hashval = 0U;
#line 76
  i = 0U;
#line 76
  while (i < length___0) {
#line 77
    hashval += (unsigned int )*(name + i);
#line 77
    hashval = (hashval << 7) + (hashval >> 20);
#line 76
    i ++;
  }
#line 78
  hashval %= set->buckets;
#line 80
  v = *(set->table + hashval);
#line 80
  while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 81
    if ((int )*(v->name) == (int )*name) {
#line 81
      tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));
#line 81
      if (tmp == 0) {
#line 81
        if ((int )*(v->name + length___0) == 0) {
#line 84
          break;
        }
      }
    }
#line 80
    v = v->next;
  }
#line 86
  if (env_overrides) {
#line 86
    if ((unsigned int )origin == 1U) {
#line 87
      origin = (enum variable_origin )3;
    }
  }
#line 89
  if ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 91
    if (env_overrides) {
#line 91
      if ((unsigned int )v->origin == 1U) {
#line 94
        v->origin = (enum variable_origin )3;
      }
    }
#line 99
    if ((int )origin >= (int )v->origin) {
#line 101
      if ((unsigned long )v->value != (unsigned long )((char *)0)) {
#line 102
        free((void *)v->value);
      }
#line 103
      v->value = xstrdup((char const   *)value);
#line 104
      if ((unsigned long )flocp != (unsigned long )((struct floc  const  *)0)) {
#line 105
        v->fileinfo = (struct floc )*flocp;
      } else {
#line 107
        v->fileinfo.filenm = (char *)0;
      }
#line 108
      v->origin = origin;
#line 109
      v->recursive = (unsigned int )recursive;
    }
#line 111
    return (v);
  }
#line 116
  tmp___0 = xmalloc((unsigned int )sizeof(struct variable ));
#line 116
  v = (struct variable *)tmp___0;
#line 117
  v->name = savestring((char const   *)name, length___0);
#line 118
  v->value = xstrdup((char const   *)value);
#line 119
  if ((unsigned long )flocp != (unsigned long )((struct floc  const  *)0)) {
#line 120
    v->fileinfo = (struct floc )*flocp;
  } else {
#line 122
    v->fileinfo.filenm = (char *)0;
  }
#line 123
  v->origin = origin;
#line 124
  v->recursive = (unsigned int )recursive;
#line 125
  v->expanding = 0U;
#line 126
  v->per_target = 0U;
#line 127
  v->append = 0U;
#line 128
  v->export = (enum variable_export )3;
#line 129
  v->next = *(set->table + hashval);
#line 130
  *(set->table + hashval) = v;
#line 131
  return (v);
}
}
#line 144 "variable.c"
struct variable *lookup_variable(char *name , unsigned int length___0 ) 
{ 
  register struct variable_set_list *setlist ;
  struct variable *firstv ;
  register unsigned int i ;
  register unsigned int rawhash ;
  register struct variable_set *set ;
  register unsigned int hashval ;
  register struct variable *v ;
  int tmp ;

  {
#line 150
  firstv = (struct variable *)0;
#line 153
  rawhash = 0U;
#line 155
  i = 0U;
#line 155
  while (i < length___0) {
#line 156
    rawhash += (unsigned int )*(name + i);
#line 156
    rawhash = (rawhash << 7) + (rawhash >> 20);
#line 155
    i ++;
  }
#line 158
  setlist = current_variable_set_list;
#line 158
  while ((unsigned long )setlist != (unsigned long )((struct variable_set_list *)0)) {
#line 161
    set = setlist->set;
#line 162
    hashval = rawhash % set->buckets;
#line 166
    v = *(set->table + hashval);
#line 166
    while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 167
      if ((int )*(v->name) == (int )*name) {
#line 167
        tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));
#line 167
        if (tmp == 0) {
#line 167
          if ((int )*(v->name + length___0) == 0) {
#line 170
            break;
          }
        }
      }
#line 166
      v = v->next;
    }
#line 173
    if (! v) {
#line 174
      goto __Cont;
    }
#line 177
    if (! v->expanding) {
#line 178
      return (v);
    }
#line 182
    if (! firstv) {
#line 183
      firstv = v;
    }
    __Cont: /* CIL Label */ 
#line 158
    setlist = setlist->next;
  }
#line 245
  return (firstv);
}
}
#line 253 "variable.c"
static struct variable *lookup_variable_in_set(char *name , unsigned int length___0 ,
                                               struct variable_set *set ) 
{ 
  register unsigned int i ;
  register unsigned int hash ;
  register struct variable *v ;
  int tmp ;

  {
#line 260
  hash = 0U;
#line 263
  i = 0U;
#line 263
  while (i < length___0) {
#line 264
    hash += (unsigned int )*(name + i);
#line 264
    hash = (hash << 7) + (hash >> 20);
#line 263
    i ++;
  }
#line 265
  hash %= set->buckets;
#line 267
  v = *(set->table + hash);
#line 267
  while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 268
    if ((int )*(v->name) == (int )*name) {
#line 268
      tmp = strncmp((char const   *)(v->name + 1), (char const   *)(name + 1), (size_t )(length___0 - 1U));
#line 268
      if (tmp == 0) {
#line 268
        if ((int )*(v->name + length___0) == 0) {
#line 271
          return (v);
        }
      }
    }
#line 267
    v = v->next;
  }
#line 273
  return ((struct variable *)0);
}
}
#line 282 "variable.c"
void initialize_file_variables(struct file *file , int reading ) 
{ 
  register struct variable_set_list *l ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct pattern_var *p ;
  struct pattern_var *tmp___2 ;
  char *tmp___3 ;

  {
#line 287
  l = file->variables;
#line 289
  if ((unsigned long )l == (unsigned long )((struct variable_set_list *)0)) {
#line 291
    tmp = xmalloc((unsigned int )sizeof(struct variable_set_list ));
#line 291
    l = (struct variable_set_list *)tmp;
#line 293
    tmp___0 = xmalloc((unsigned int )sizeof(struct variable_set ));
#line 293
    l->set = (struct variable_set *)tmp___0;
#line 294
    (l->set)->buckets = 23U;
#line 295
    tmp___1 = xmalloc((unsigned int )((unsigned long )(l->set)->buckets * sizeof(struct variable *)));
#line 295
    (l->set)->table = (struct variable **)tmp___1;
#line 297
    memset((void *)((char *)(l->set)->table), 0, (unsigned long )(l->set)->buckets * sizeof(struct variable *));
#line 299
    file->variables = l;
  }
#line 302
  if ((unsigned long )file->parent == (unsigned long )((struct file *)0)) {
#line 303
    l->next = & global_setlist;
  } else {
#line 306
    initialize_file_variables(file->parent, reading);
#line 307
    l->next = (file->parent)->variables;
  }
#line 313
  if (! reading) {
#line 313
    if (! file->pat_searched) {
#line 315
      tmp___2 = lookup_pattern_var(file->name);
#line 315
      p = tmp___2;
#line 317
      file->pat_searched = 1U;
#line 318
      if ((unsigned long )p != (unsigned long )((struct pattern_var *)0)) {
#line 322
        tmp___3 = xmalloc((unsigned int )sizeof(struct variable_set_list ));
#line 322
        file->pat_variables = (struct variable_set_list *)tmp___3;
#line 324
        (file->pat_variables)->set = (p->vars)->set;
      }
    }
  }
#line 330
  if ((unsigned long )file->pat_variables != (unsigned long )((struct variable_set_list *)0)) {
#line 332
    (file->pat_variables)->next = l->next;
#line 333
    l->next = file->pat_variables;
  }
#line 335
  return;
}
}
#line 340 "variable.c"
void pop_variable_scope(void) 
{ 
  register struct variable_set_list *setlist ;
  register struct variable_set *set ;
  register unsigned int i ;
  register struct variable *next ;
  register struct variable *v ;

  {
#line 343
  setlist = current_variable_set_list;
#line 344
  set = setlist->set;
#line 347
  current_variable_set_list = setlist->next;
#line 348
  free((void *)((char *)setlist));
#line 350
  i = 0U;
#line 350
  while (i < set->buckets) {
#line 352
    next = *(set->table + i);
#line 353
    while ((unsigned long )next != (unsigned long )((struct variable *)0)) {
#line 355
      v = next;
#line 356
      next = v->next;
#line 358
      free((void *)v->name);
#line 359
      if (v->value) {
#line 360
        free((void *)v->value);
      }
#line 361
      free((void *)((char *)v));
    }
#line 350
    i ++;
  }
#line 364
  free((void *)((char *)set->table));
#line 365
  free((void *)((char *)set));
#line 366
  return;
}
}
#line 368 "variable.c"
struct variable_set_list *create_new_variable_set(void) 
{ 
  register struct variable_set_list *setlist ;
  register struct variable_set *set ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 374
  tmp = xmalloc((unsigned int )sizeof(struct variable_set ));
#line 374
  set = (struct variable_set *)tmp;
#line 375
  set->buckets = 13U;
#line 376
  tmp___0 = xmalloc((unsigned int )((unsigned long )set->buckets * sizeof(struct variable *)));
#line 376
  set->table = (struct variable **)tmp___0;
#line 378
  memset((void *)((char *)set->table), 0, (unsigned long )set->buckets * sizeof(struct variable *));
#line 380
  tmp___1 = xmalloc((unsigned int )sizeof(struct variable_set_list ));
#line 380
  setlist = (struct variable_set_list *)tmp___1;
#line 382
  setlist->set = set;
#line 383
  setlist->next = current_variable_set_list;
#line 385
  return (setlist);
}
}
#line 390 "variable.c"
struct variable_set_list *push_new_variable_scope(void) 
{ 


  {
#line 393
  current_variable_set_list = create_new_variable_set();
#line 393
  return (current_variable_set_list);
}
}
#line 398 "variable.c"
static void merge_variable_sets(struct variable_set *set0 , struct variable_set *set1 ) 
{ 
  register unsigned int bucket1 ;
  register struct variable *v1 ;
  struct variable *next ;
  unsigned int bucket0 ;
  register struct variable *v0 ;
  register char *n ;
  int tmp ;

  {
#line 404
  bucket1 = 0U;
#line 404
  while (bucket1 < set1->buckets) {
#line 406
    v1 = *(set1->table + bucket1);
#line 407
    while ((unsigned long )v1 != (unsigned long )((struct variable *)0)) {
#line 409
      next = v1->next;
#line 413
      if (set1->buckets >= set0->buckets) {
#line 414
        bucket0 = bucket1;
      } else {
#line 418
        bucket0 = 0U;
#line 419
        n = v1->name;
#line 419
        while ((int )*n != 0) {
#line 420
          bucket0 += (unsigned int )*n;
#line 420
          bucket0 = (bucket0 << 7) + (bucket0 >> 20);
#line 419
          n ++;
        }
      }
#line 422
      bucket0 %= set0->buckets;
#line 424
      v0 = *(set0->table + bucket0);
#line 424
      while ((unsigned long )v0 != (unsigned long )((struct variable *)0)) {
#line 425
        if ((unsigned long )v0->name == (unsigned long )v1->name) {
#line 426
          break;
        } else
#line 425
        if ((int )*(v0->name) == (int )*(v1->name)) {
#line 425
          if ((int )*(v0->name) == 0) {
#line 426
            break;
          } else {
#line 425
            tmp = strcmp((char const   *)(v0->name + 1), (char const   *)(v1->name + 1));
#line 425
            if (! tmp) {
#line 426
              break;
            }
          }
        }
#line 424
        v0 = v0->next;
      }
#line 428
      if ((unsigned long )v0 == (unsigned long )((struct variable *)0)) {
#line 431
        v1->next = *(set0->table + bucket0);
#line 432
        *(set0->table + bucket0) = v1;
      } else {
#line 438
        free((void *)v1->value);
#line 439
        free((void *)((char *)v1));
      }
#line 442
      v1 = next;
    }
#line 404
    bucket1 ++;
  }
#line 445
  return;
}
}
#line 449 "variable.c"
void merge_variable_set_lists(struct variable_set_list **setlist0 , struct variable_set_list *setlist1 ) 
{ 
  register struct variable_set_list *list0 ;
  struct variable_set_list *last0 ;
  struct variable_set_list *next ;

  {
#line 453
  list0 = *setlist0;
#line 454
  last0 = (struct variable_set_list *)0;
#line 456
  while (1) {
#line 456
    if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
#line 456
      if (! ((unsigned long )list0 != (unsigned long )((struct variable_set_list *)0))) {
#line 456
        break;
      }
    } else {
#line 456
      break;
    }
#line 458
    next = setlist1;
#line 459
    setlist1 = setlist1->next;
#line 461
    merge_variable_sets(list0->set, next->set);
#line 463
    last0 = list0;
#line 464
    list0 = list0->next;
  }
#line 467
  if ((unsigned long )setlist1 != (unsigned long )((struct variable_set_list *)0)) {
#line 469
    if ((unsigned long )last0 == (unsigned long )((struct variable_set_list *)0)) {
#line 470
      *setlist0 = setlist1;
    } else {
#line 472
      last0->next = setlist1;
    }
  }
#line 474
  return;
}
}
#line 479 "variable.c"
void define_automatic_variables(void) 
{ 
  register struct variable *v ;
  char buf___1[200] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 490
  sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%u", makelevel);
#line 491
  define_variable_in_set((char *)"MAKELEVEL", 9U, buf___1, (enum variable_origin )1,
                         0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 493
  if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
#line 493
    tmp = "";
  } else
#line 493
  if ((int )*(remote_description + 0) == 0) {
#line 493
    tmp = "";
  } else {
#line 493
    tmp = (char const   *)remote_description;
  }
#line 493
  if ((unsigned long )remote_description == (unsigned long )((char *)0)) {
#line 493
    tmp___0 = "";
  } else
#line 493
  if ((int )*(remote_description + 0) == 0) {
#line 493
    tmp___0 = "";
  } else {
#line 493
    tmp___0 = "-";
  }
#line 493
  sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%s%s%s", version_string,
          tmp___0, tmp);
#line 499
  define_variable_in_set((char *)"MAKE_VERSION", 12U, buf___1, (enum variable_origin )0,
                         0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 527
  v = define_variable_in_set((char *)"SHELL", 5U, default_shell, (enum variable_origin )0,
                             0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 528
  v->export = (enum variable_export )0;
#line 535
  if ((int )*(v->value) == 0) {
#line 537
    free((void *)v->value);
#line 538
    v->origin = (enum variable_origin )2;
#line 539
    v->value = xstrdup((char const   *)(default_shell));
  } else
#line 535
  if ((unsigned int )v->origin == 1U) {
#line 537
    free((void *)v->value);
#line 538
    v->origin = (enum variable_origin )2;
#line 539
    v->value = xstrdup((char const   *)(default_shell));
  } else
#line 535
  if ((unsigned int )v->origin == 3U) {
#line 537
    free((void *)v->value);
#line 538
    v->origin = (enum variable_origin )2;
#line 539
    v->value = xstrdup((char const   *)(default_shell));
  }
#line 544
  v = define_variable_in_set((char *)"MAKEFILES", 9U, (char *)"", (enum variable_origin )0,
                             0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 545
  v->export = (enum variable_export )2;
#line 559
  define_variable_in_set((char *)"@D", 2U, (char *)"$(patsubst %/,%,$(dir $@))", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 560
  define_variable_in_set((char *)"%D", 2U, (char *)"$(patsubst %/,%,$(dir $%))", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 561
  define_variable_in_set((char *)"*D", 2U, (char *)"$(patsubst %/,%,$(dir $*))", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 562
  define_variable_in_set((char *)"<D", 2U, (char *)"$(patsubst %/,%,$(dir $<))", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 563
  define_variable_in_set((char *)"?D", 2U, (char *)"$(patsubst %/,%,$(dir $?))", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 564
  define_variable_in_set((char *)"^D", 2U, (char *)"$(patsubst %/,%,$(dir $^))", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 565
  define_variable_in_set((char *)"+D", 2U, (char *)"$(patsubst %/,%,$(dir $+))", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 567
  define_variable_in_set((char *)"@F", 2U, (char *)"$(notdir $@)", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 568
  define_variable_in_set((char *)"%F", 2U, (char *)"$(notdir $%)", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 569
  define_variable_in_set((char *)"*F", 2U, (char *)"$(notdir $*)", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 570
  define_variable_in_set((char *)"<F", 2U, (char *)"$(notdir $<)", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 571
  define_variable_in_set((char *)"?F", 2U, (char *)"$(notdir $?)", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 572
  define_variable_in_set((char *)"^F", 2U, (char *)"$(notdir $^)", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 573
  define_variable_in_set((char *)"+F", 2U, (char *)"$(notdir $+)", (enum variable_origin )6,
                         1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 574
  return;
}
}
#line 582 "variable.c"
char **target_environment(struct file *file ) 
{ 
  struct variable_set_list *set_list ;
  register struct variable_set_list *s ;
  struct variable_bucket **table ;
  unsigned int buckets ;
  register unsigned int i ;
  register unsigned int nvariables ;
  char **result___0 ;
  unsigned int mklev_hash ;
  char *p ;
  char *tmp ;
  void *tmp___0 ;
  register struct variable_set *set ;
  register struct variable *v ;
  unsigned int j ;
  register struct variable_bucket *ov ;
  register char *p___0 ;
  int tmp___1 ;
  struct variable *gv ;
  size_t tmp___2 ;
  register char *np ;
  int tmp___3 ;
  register struct variable_bucket *entry ;
  void *tmp___4 ;
  char *tmp___5 ;
  register struct variable_bucket *b ;
  register struct variable *v___0 ;
  char *value ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;

  {
#line 600
  if ((unsigned long )file == (unsigned long )((struct file *)0)) {
#line 601
    set_list = current_variable_set_list;
  } else {
#line 603
    set_list = file->variables;
  }
#line 606
  s = set_list;
#line 607
  buckets = (s->set)->buckets;
#line 608
  s = s->next;
#line 608
  while ((unsigned long )s != (unsigned long )((struct variable_set_list *)0)) {
#line 609
    if ((s->set)->buckets < buckets) {
#line 610
      buckets = (s->set)->buckets;
    }
#line 608
    s = s->next;
  }
#line 614
  p = (char *)"MAKELEVEL";
#line 615
  mklev_hash = 0U;
#line 616
  while ((int )*p != 0) {
#line 617
    tmp = p;
#line 617
    p ++;
#line 617
    mklev_hash += (unsigned int )*tmp;
#line 617
    mklev_hash = (mklev_hash << 7) + (mklev_hash >> 20);
  }
#line 621
  tmp___0 = __builtin_alloca((unsigned long )buckets * sizeof(struct variable_bucket *));
#line 621
  table = (struct variable_bucket **)tmp___0;
#line 623
  memset((void *)((char *)table), 0, (unsigned long )buckets * sizeof(struct variable_bucket *));
#line 627
  nvariables = 0U;
#line 628
  s = set_list;
#line 628
  while ((unsigned long )s != (unsigned long )((struct variable_set_list *)0)) {
#line 630
    set = s->set;
#line 631
    i = 0U;
#line 631
    while (i < set->buckets) {
#line 634
      v = *(set->table + i);
#line 634
      while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 636
        j = i % buckets;
#line 638
        p___0 = v->name;
#line 640
        if (i == mklev_hash % set->buckets) {
#line 640
          if ((unsigned long )v->name == (unsigned long )"MAKELEVEL") {
#line 644
            goto __Cont;
          } else
#line 640
          if ((int )*(v->name) == (int )*"MAKELEVEL") {
#line 640
            if ((int )*(v->name) == 0) {
#line 644
              goto __Cont;
            } else {
#line 640
              tmp___1 = strcmp((char const   *)(v->name + 1), "MAKELEVEL" + 1);
#line 640
              if (! tmp___1) {
#line 644
                goto __Cont;
              }
            }
          }
        }
#line 649
        if (v->per_target) {
#line 649
          if ((unsigned int )v->export == 3U) {
#line 653
            tmp___2 = strlen((char const   *)v->name);
#line 653
            gv = lookup_variable_in_set(v->name, (unsigned int )tmp___2, & global_variable_set);
#line 655
            if (gv) {
#line 656
              v->export = gv->export;
            }
          }
        }
#line 659
        switch ((unsigned int )v->export) {
        case 3U: 
#line 662
        if ((unsigned int )v->origin == 0U) {
#line 664
          goto __Cont;
        } else
#line 662
        if ((unsigned int )v->origin == 6U) {
#line 664
          goto __Cont;
        }
#line 666
        if (! export_all_variables) {
#line 666
          if ((unsigned int )v->origin != 4U) {
#line 666
            if ((unsigned int )v->origin != 1U) {
#line 666
              if ((unsigned int )v->origin != 3U) {
#line 669
                goto __Cont;
              }
            }
          }
        }
#line 671
        if ((int )*p___0 != 95) {
#line 671
          if ((int )*p___0 < 65) {
#line 671
            goto _L;
          } else
#line 671
          if ((int )*p___0 > 90) {
            _L: /* CIL Label */ 
#line 671
            if ((int )*p___0 < 97) {
#line 673
              goto __Cont;
            } else
#line 671
            if ((int )*p___0 > 122) {
#line 673
              goto __Cont;
            }
          }
        }
#line 674
        p___0 ++;
#line 674
        while ((int )*p___0 != 0) {
#line 675
          if ((int )*p___0 != 95) {
#line 675
            if ((int )*p___0 < 97) {
#line 675
              goto _L___1;
            } else
#line 675
            if ((int )*p___0 > 122) {
              _L___1: /* CIL Label */ 
#line 675
              if ((int )*p___0 < 65) {
#line 675
                goto _L___0;
              } else
#line 675
              if ((int )*p___0 > 90) {
                _L___0: /* CIL Label */ 
#line 675
                if ((int )*p___0 < 48) {
#line 677
                  goto __Cont___0;
                } else
#line 675
                if ((int )*p___0 > 57) {
#line 677
                  goto __Cont___0;
                }
              }
            }
          }
          __Cont___0: /* CIL Label */ 
#line 674
          p___0 ++;
        }
#line 678
        if ((int )*p___0 != 0) {
#line 679
          goto __Cont;
        }
#line 680
        break;
        case 0U: 
#line 683
        break;
        case 1U: 
#line 686
        goto __Cont;
        case 2U: 
#line 689
        if ((unsigned int )v->origin == 0U) {
#line 690
          goto __Cont;
        }
#line 691
        break;
        }
#line 696
        if (set->buckets != buckets) {
#line 700
          j = 0U;
#line 701
          np = v->name;
#line 701
          while ((int )*np != 0) {
#line 702
            j += (unsigned int )*np;
#line 702
            j = (j << 7) + (j >> 20);
#line 701
            np ++;
          }
#line 703
          j %= buckets;
        }
#line 706
        ov = *(table + j);
#line 706
        while ((unsigned long )ov != (unsigned long )((struct variable_bucket *)0)) {
#line 707
          if ((unsigned long )v->name == (unsigned long )(ov->variable)->name) {
#line 708
            break;
          } else
#line 707
          if ((int )*(v->name) == (int )*((ov->variable)->name)) {
#line 707
            if ((int )*(v->name) == 0) {
#line 708
              break;
            } else {
#line 707
              tmp___3 = strcmp((char const   *)(v->name + 1), (char const   *)((ov->variable)->name + 1));
#line 707
              if (! tmp___3) {
#line 708
                break;
              }
            }
          }
#line 706
          ov = ov->next;
        }
#line 710
        if ((unsigned long )ov == (unsigned long )((struct variable_bucket *)0)) {
#line 713
          tmp___4 = __builtin_alloca(sizeof(struct variable_bucket ));
#line 713
          entry = (struct variable_bucket *)tmp___4;
#line 715
          entry->next = *(table + j);
#line 716
          entry->variable = v;
#line 717
          *(table + j) = entry;
#line 718
          nvariables ++;
        }
        __Cont: /* CIL Label */ 
#line 634
        v = v->next;
      }
#line 631
      i ++;
    }
#line 628
    s = s->next;
  }
#line 724
  tmp___5 = xmalloc((unsigned int )((unsigned long )(nvariables + 2U) * sizeof(char *)));
#line 724
  result___0 = (char **)tmp___5;
#line 725
  nvariables = 0U;
#line 726
  i = 0U;
#line 726
  while (i < buckets) {
#line 729
    b = *(table + i);
#line 729
    while ((unsigned long )b != (unsigned long )((struct variable_bucket *)0)) {
#line 731
      v___0 = b->variable;
#line 736
      if (v___0->recursive) {
#line 736
        if ((unsigned int )v___0->origin != 1U) {
#line 736
          if ((unsigned int )v___0->origin != 3U) {
#line 739
            tmp___6 = recursively_expand(v___0);
#line 739
            value = tmp___6;
#line 745
            tmp___7 = nvariables;
#line 745
            nvariables ++;
#line 745
            *(result___0 + tmp___7) = concat(v___0->name, (char *)"=", value);
#line 746
            free((void *)value);
          } else {
#line 757
            tmp___8 = nvariables;
#line 757
            nvariables ++;
#line 757
            *(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);
          }
        } else {
#line 757
          tmp___8 = nvariables;
#line 757
          nvariables ++;
#line 757
          *(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);
        }
      } else {
#line 757
        tmp___8 = nvariables;
#line 757
        nvariables ++;
#line 757
        *(result___0 + tmp___8) = concat(v___0->name, (char *)"=", v___0->value);
      }
#line 729
      b = b->next;
    }
#line 726
    i ++;
  }
#line 761
  tmp___9 = xmalloc(100U);
#line 761
  *(result___0 + nvariables) = tmp___9;
#line 762
  sprintf((char * __restrict  )*(result___0 + nvariables), (char const   * __restrict  )"MAKELEVEL=%u",
          makelevel + 1U);
#line 763
  nvariables ++;
#line 763
  *(result___0 + nvariables) = (char *)0;
#line 765
  return (result___0);
}
}
#line 781 "variable.c"
struct variable *try_variable_definition(struct floc  const  *flocp , char *line ,
                                         enum variable_origin origin , int target_var ) 
{ 
  register int c ;
  register char *p ;
  register char *beg ;
  register char *end ;
  enum __anonenum_flavor_56 flavor ;
  char *name ;
  char *expanded_name ;
  char *value ;
  char *alloc_value ;
  struct variable *v ;
  int append ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char closeparen ;
  int count ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  unsigned int oldlen ;
  unsigned int newlen ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;

  {
#line 789
  p = line;
#line 792
  flavor = (enum __anonenum_flavor_56 )0;
#line 794
  alloc_value = (char *)((void *)0);
#line 796
  append = 0;
#line 798
  while (1) {
#line 800
    tmp = p;
#line 800
    p ++;
#line 800
    c = (int )*tmp;
#line 801
    if (c == 0) {
#line 802
      return ((struct variable *)0);
    } else
#line 801
    if (c == 35) {
#line 802
      return ((struct variable *)0);
    }
#line 803
    if (c == 61) {
#line 805
      end = p - 1;
#line 806
      flavor = (enum __anonenum_flavor_56 )2;
#line 807
      break;
    } else
#line 809
    if (c == 58) {
#line 810
      if ((int )*p == 61) {
#line 812
        tmp___0 = p;
#line 812
        p ++;
#line 812
        end = tmp___0 - 1;
#line 813
        flavor = (enum __anonenum_flavor_56 )1;
#line 814
        break;
      } else {
#line 818
        return ((struct variable *)0);
      }
    } else
#line 819
    if (c == 43) {
#line 819
      if ((int )*p == 61) {
#line 821
        tmp___1 = p;
#line 821
        p ++;
#line 821
        end = tmp___1 - 1;
#line 822
        flavor = (enum __anonenum_flavor_56 )3;
#line 823
        break;
      } else {
#line 819
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 825
    if (c == 63) {
#line 825
      if ((int )*p == 61) {
#line 827
        tmp___2 = p;
#line 827
        p ++;
#line 827
        end = tmp___2 - 1;
#line 828
        flavor = (enum __anonenum_flavor_56 )4;
#line 829
        break;
      } else {
#line 825
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 831
    if (c == 36) {
#line 837
      tmp___3 = p;
#line 837
      p ++;
#line 837
      c = (int )*tmp___3;
#line 838
      if (c == 40) {
#line 839
        closeparen = (char )')';
      } else
#line 840
      if (c == 123) {
#line 841
        closeparen = (char )'}';
      } else {
#line 843
        continue;
      }
#line 847
      count = 0;
#line 848
      while ((int )*p != 0) {
#line 850
        if ((int )*p == c) {
#line 851
          count ++;
        } else
#line 852
        if ((int )*p == (int )closeparen) {
#line 852
          count --;
#line 852
          if (count < 0) {
#line 854
            p ++;
#line 855
            break;
          }
        }
#line 848
        p ++;
      }
    }
  }
#line 861
  beg = next_token(line);
#line 862
  while (1) {
#line 862
    if ((unsigned long )end > (unsigned long )beg) {
#line 862
      tmp___4 = __ctype_b_loc();
#line 862
      if (! ((int const   )*(*tmp___4 + (int )*(end + -1)) & 1)) {
#line 862
        break;
      }
    } else {
#line 862
      break;
    }
#line 863
    end --;
  }
#line 864
  p = next_token(p);
#line 867
  tmp___5 = __builtin_alloca((unsigned long )((end - beg) + 1L));
#line 867
  name = (char *)tmp___5;
#line 868
  memmove((void *)name, (void const   *)beg, (size_t )(end - beg));
#line 869
  *(name + (end - beg)) = (char )'\000';
#line 870
  expanded_name = allocated_variable_expand_for_file(name, (struct file *)0);
#line 872
  if ((int )*(expanded_name + 0) == 0) {
#line 873
    tmp___6 = dcgettext((char const   *)((void *)0), "empty variable name", 5);
#line 873
    fatal(flocp, (char const   *)tmp___6);
  }
#line 877
  switch ((unsigned int )flavor) {
  case 0U: 
#line 881
  abort();
  case 1U: 
#line 887
  alloc_value = allocated_variable_expand_for_file(p, (struct file *)0);
#line 887
  value = alloc_value;
#line 888
  break;
  case 4U: 
#line 892
  tmp___7 = strlen((char const   *)expanded_name);
#line 892
  v = lookup_variable(expanded_name, (unsigned int )tmp___7);
#line 893
  if (v) {
#line 895
    free((void *)expanded_name);
#line 896
    return (v);
  }
#line 898
  flavor = (enum __anonenum_flavor_56 )2;
  case 2U: 
#line 903
  value = p;
#line 904
  break;
  case 3U: 
#line 908
  if (target_var) {
#line 910
    append = 1;
#line 911
    flavor = (enum __anonenum_flavor_56 )2;
#line 912
    value = p;
#line 913
    break;
  }
#line 918
  tmp___8 = strlen((char const   *)expanded_name);
#line 918
  v = lookup_variable(expanded_name, (unsigned int )tmp___8);
#line 919
  if ((unsigned long )v == (unsigned long )((struct variable *)0)) {
#line 923
    value = p;
#line 924
    flavor = (enum __anonenum_flavor_56 )2;
  } else {
#line 932
    if (v->recursive) {
#line 935
      flavor = (enum __anonenum_flavor_56 )2;
    } else {
#line 942
      alloc_value = allocated_variable_expand_for_file(p, (struct file *)0);
#line 942
      p = alloc_value;
    }
#line 944
    tmp___9 = strlen((char const   *)v->value);
#line 944
    oldlen = (unsigned int )tmp___9;
#line 945
    tmp___10 = strlen((char const   *)p);
#line 945
    newlen = (unsigned int )tmp___10;
#line 946
    tmp___11 = __builtin_alloca((unsigned long )(((oldlen + 1U) + newlen) + 1U));
#line 946
    value = (char *)tmp___11;
#line 947
    memmove((void *)value, (void const   *)v->value, (size_t )oldlen);
#line 948
    *(value + oldlen) = (char )' ';
#line 949
    memmove((void *)(value + (oldlen + 1U)), (void const   *)p, (size_t )(newlen + 1U));
  }
  }
#line 1055
  tmp___12 = strlen((char const   *)expanded_name);
#line 1055
  v = define_variable_in_set(expanded_name, (unsigned int )tmp___12, value, origin,
                             (unsigned int )flavor == 2U, current_variable_set_list->set,
                             flocp);
#line 1058
  v->append = (unsigned int )append;
#line 1060
  if (alloc_value) {
#line 1061
    free((void *)alloc_value);
  }
#line 1062
  free((void *)expanded_name);
#line 1064
  return (v);
}
}
#line 1069 "variable.c"
static void print_variable(struct variable *v , char *prefix ) 
{ 
  char const   *origin ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  register char *p ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;

  {
#line 1076
  switch ((unsigned int )v->origin) {
  case 0U: 
#line 1079
  tmp = dcgettext((char const   *)((void *)0), "default", 5);
#line 1079
  origin = (char const   *)tmp;
#line 1080
  break;
  case 1U: 
#line 1082
  tmp___0 = dcgettext((char const   *)((void *)0), "environment", 5);
#line 1082
  origin = (char const   *)tmp___0;
#line 1083
  break;
  case 2U: 
#line 1085
  tmp___1 = dcgettext((char const   *)((void *)0), "makefile", 5);
#line 1085
  origin = (char const   *)tmp___1;
#line 1086
  break;
  case 3U: 
#line 1088
  tmp___2 = dcgettext((char const   *)((void *)0), "environment under -e", 5);
#line 1088
  origin = (char const   *)tmp___2;
#line 1089
  break;
  case 4U: 
#line 1091
  tmp___3 = dcgettext((char const   *)((void *)0), "command line", 5);
#line 1091
  origin = (char const   *)tmp___3;
#line 1092
  break;
  case 5U: 
#line 1094
  tmp___4 = dcgettext((char const   *)((void *)0), "`override\' directive", 5);
#line 1094
  origin = (char const   *)tmp___4;
#line 1095
  break;
  case 6U: 
#line 1097
  tmp___5 = dcgettext((char const   *)((void *)0), "automatic", 5);
#line 1097
  origin = (char const   *)tmp___5;
#line 1098
  break;
  default: 
#line 1101
  abort();
  }
#line 1103
  fputs((char const   * __restrict  )"# ", (FILE * __restrict  )stdout);
#line 1104
  fputs((char const   * __restrict  )origin, (FILE * __restrict  )stdout);
#line 1105
  if (v->fileinfo.filenm) {
#line 1106
    printf((char const   * __restrict  )" (from `%s\', line %lu)", v->fileinfo.filenm,
           v->fileinfo.lineno);
  }
#line 1107
  putchar('\n');
#line 1108
  fputs((char const   * __restrict  )prefix, (FILE * __restrict  )stdout);
#line 1111
  if (v->recursive) {
#line 1111
    tmp___8 = strchr((char const   *)v->value, '\n');
#line 1111
    if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
#line 1112
      printf((char const   * __restrict  )"define %s\n%s\nendef\n", v->name, v->value);
    } else {
#line 1111
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1117
    if (v->recursive) {
#line 1117
      if (v->append) {
#line 1117
        tmp___6 = "+";
      } else {
#line 1117
        tmp___6 = "";
      }
#line 1117
      tmp___7 = tmp___6;
    } else {
#line 1117
      tmp___7 = ":";
    }
#line 1117
    printf((char const   * __restrict  )"%s %s= ", v->name, tmp___7);
#line 1120
    p = next_token(v->value);
#line 1121
    if ((unsigned long )p != (unsigned long )v->value) {
#line 1121
      if ((int )*p == 0) {
#line 1123
        printf((char const   * __restrict  )"$(subst ,,%s)", v->value);
      } else {
#line 1121
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1124
    if (v->recursive) {
#line 1125
      fputs((char const   * __restrict  )v->value, (FILE * __restrict  )stdout);
    } else {
#line 1128
      p = v->value;
#line 1128
      while ((int )*p != 0) {
#line 1130
        if ((int )*p == 36) {
#line 1131
          putchar('$');
        }
#line 1132
        putchar((int )*p);
#line 1128
        p ++;
      }
    }
#line 1134
    putchar('\n');
  }
#line 1136
  return;
}
}
#line 1142 "variable.c"
void print_variable_set(struct variable_set *set , char *prefix ) 
{ 
  register unsigned int i ;
  register unsigned int nvariables ;
  register unsigned int per_bucket ;
  register struct variable *v ;
  register unsigned int this_bucket ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1150
  nvariables = 0U;
#line 1150
  per_bucket = nvariables;
#line 1151
  i = 0U;
#line 1151
  while (i < set->buckets) {
#line 1153
    this_bucket = 0U;
#line 1155
    v = *(set->table + i);
#line 1155
    while ((unsigned long )v != (unsigned long )((struct variable *)0)) {
#line 1157
      this_bucket ++;
#line 1158
      print_variable(v, prefix);
#line 1155
      v = v->next;
    }
#line 1161
    nvariables += this_bucket;
#line 1162
    if (this_bucket > per_bucket) {
#line 1163
      per_bucket = this_bucket;
    }
#line 1151
    i ++;
  }
#line 1166
  if (nvariables == 0U) {
#line 1167
    tmp = dcgettext((char const   *)((void *)0), "# No variables.", 5);
#line 1167
    puts((char const   *)tmp);
  } else {
#line 1170
    tmp___0 = dcgettext((char const   *)((void *)0), "# %u variables in %u hash buckets.\n",
                        5);
#line 1170
    printf((char const   * __restrict  )tmp___0, nvariables, set->buckets);
#line 1173
    tmp___1 = dcgettext((char const   *)((void *)0), "# average of %.1f variables per bucket, max %u in one bucket.\n",
                        5);
#line 1173
    printf((char const   * __restrict  )tmp___1, (double )nvariables / (double )set->buckets,
           per_bucket);
  }
#line 1187
  return;
}
}
#line 1192 "variable.c"
void print_variable_data_base(void) 
{ 
  char *tmp ;

  {
#line 1195
  tmp = dcgettext((char const   *)((void *)0), "\n# Variables\n", 5);
#line 1195
  puts((char const   *)tmp);
#line 1197
  print_variable_set(& global_variable_set, (char *)"");
#line 1198
  return;
}
}
#line 1203 "variable.c"
void print_file_variables(struct file *file ) 
{ 


  {
#line 1207
  if ((unsigned long )file->variables != (unsigned long )((struct variable_set_list *)0)) {
#line 1208
    print_variable_set((file->variables)->set, (char *)"# ");
  }
#line 1209
  return;
}
}
#line 1 "vpath.o"
#pragma merger("0","/tmp/cil-2njetZm2.i","-g,-O0")
#line 42 "vpath.c"
static struct vpath *vpaths  ;
#line 46 "vpath.c"
static struct vpath *general_vpath  ;
#line 50 "vpath.c"
static struct vpath *gpaths  ;
#line 52
static int selective_vpath_search(struct vpath *path , char **file , uintmax_t *mtime_ptr ) ;
#line 58 "vpath.c"
void build_vpath_lists(void) 
{ 
  register struct vpath *new ;
  register struct vpath *old ;
  register struct vpath *nexto ;
  register char *p ;
  int save ;
  struct vpath *save_vpaths ;
  int save___0 ;
  struct vpath *save_vpaths___0 ;

  {
#line 61
  new = (struct vpath *)0;
#line 66
  old = vpaths;
#line 66
  while ((unsigned long )old != (unsigned long )((struct vpath *)0)) {
#line 68
    nexto = old->next;
#line 69
    old->next = new;
#line 70
    new = old;
#line 66
    old = nexto;
  }
#line 73
  vpaths = new;
#line 81
  save = warn_undefined_variables_flag;
#line 82
  warn_undefined_variables_flag = 0;
#line 84
  p = variable_expand((char *)"$(strip $(VPATH))");
#line 86
  warn_undefined_variables_flag = save;
#line 89
  if ((int )*p != 0) {
#line 92
    save_vpaths = vpaths;
#line 96
    vpaths = (struct vpath *)0;
#line 99
    construct_vpath_list((char *)"%", p);
#line 103
    general_vpath = vpaths;
#line 104
    vpaths = save_vpaths;
  }
#line 113
  save___0 = warn_undefined_variables_flag;
#line 114
  warn_undefined_variables_flag = 0;
#line 116
  p = variable_expand((char *)"$(strip $(GPATH))");
#line 118
  warn_undefined_variables_flag = save___0;
#line 121
  if ((int )*p != 0) {
#line 124
    save_vpaths___0 = vpaths;
#line 128
    vpaths = (struct vpath *)0;
#line 131
    construct_vpath_list((char *)"%", p);
#line 135
    gpaths = vpaths;
#line 136
    vpaths = save_vpaths___0;
  }
#line 138
  return;
}
}
#line 159 "vpath.c"
void construct_vpath_list(char *pattern , char *dirpath ) 
{ 
  register unsigned int elem ;
  register char *p ;
  register char **vpath ;
  register unsigned int maxvpath ;
  unsigned int maxelem ;
  char *percent ;
  register struct vpath *path ;
  register struct vpath *lastpath ;
  struct vpath *next ;
  int tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *v ;
  unsigned int len ;
  unsigned short const   **tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  struct vpath *path___0 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;

  {
#line 168
  percent = (char *)((void *)0);
#line 170
  if ((unsigned long )pattern != (unsigned long )((char *)0)) {
#line 172
    pattern = xstrdup((char const   *)pattern);
#line 173
    percent = find_percent(pattern);
  }
#line 176
  if ((unsigned long )dirpath == (unsigned long )((char *)0)) {
#line 181
    lastpath = (struct vpath *)0;
#line 182
    path = vpaths;
#line 183
    while ((unsigned long )path != (unsigned long )((struct vpath *)0)) {
#line 185
      next = path->next;
#line 187
      if ((unsigned long )pattern == (unsigned long )((char *)0)) {
#line 187
        goto _L___1;
      } else
#line 187
      if ((unsigned long )percent == (unsigned long )((char *)0)) {
#line 187
        if ((unsigned long )path->percent == (unsigned long )((char *)0)) {
#line 187
          goto _L___2;
        } else {
#line 187
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 187
      if (percent - pattern == path->percent - path->pattern) {
        _L___2: /* CIL Label */ 
#line 187
        if ((unsigned long )pattern == (unsigned long )path->pattern) {
#line 187
          goto _L___1;
        } else
#line 187
        if ((int )*pattern == (int )*(path->pattern)) {
#line 187
          if ((int )*pattern == 0) {
#line 187
            goto _L___1;
          } else {
#line 187
            tmp = strcmp((char const   *)(pattern + 1), (char const   *)(path->pattern + 1));
#line 187
            if (tmp) {
#line 204
              lastpath = path;
            } else {
              _L___1: /* CIL Label */ 
#line 193
              if ((unsigned long )lastpath == (unsigned long )((struct vpath *)0)) {
#line 194
                vpaths = path->next;
              } else {
#line 196
                lastpath->next = next;
              }
#line 199
              free((void *)path->pattern);
#line 200
              free((void *)((char *)path->searchpath));
#line 201
              free((void *)((char *)path));
            }
          }
        } else {
#line 204
          lastpath = path;
        }
      } else {
#line 204
        lastpath = path;
      }
#line 206
      path = next;
    }
#line 209
    if ((unsigned long )pattern != (unsigned long )((char *)0)) {
#line 210
      free((void *)pattern);
    }
#line 211
    return;
  }
#line 222
  maxelem = 2U;
#line 223
  p = dirpath;
#line 224
  while ((int )*p != 0) {
#line 225
    tmp___0 = p;
#line 225
    p ++;
#line 225
    if ((int )*tmp___0 == 58) {
#line 226
      maxelem ++;
    } else {
#line 225
      tmp___1 = __ctype_b_loc();
#line 225
      if ((int const   )*(*tmp___1 + (int )*p) & 1) {
#line 226
        maxelem ++;
      }
    }
  }
#line 228
  tmp___2 = xmalloc((unsigned int )((unsigned long )maxelem * sizeof(char *)));
#line 228
  vpath = (char **)tmp___2;
#line 229
  maxvpath = 0U;
#line 232
  p = dirpath;
#line 233
  while (1) {
#line 233
    if (! ((int )*p == 58)) {
#line 233
      tmp___3 = __ctype_b_loc();
#line 233
      if (! ((int const   )*(*tmp___3 + (int )*p) & 1)) {
#line 233
        break;
      }
    }
#line 234
    p ++;
  }
#line 236
  elem = 0U;
#line 237
  while ((int )*p != 0) {
#line 243
    v = p;
#line 244
    while (1) {
#line 244
      if ((int )*p != 0) {
#line 244
        if ((int )*p != 58) {
#line 244
          tmp___4 = __ctype_b_loc();
#line 244
          if ((int const   )*(*tmp___4 + (int )*p) & 1) {
#line 244
            break;
          }
        } else {
#line 244
          break;
        }
      } else {
#line 244
        break;
      }
#line 245
      p ++;
    }
#line 247
    len = (unsigned int )(p - v);
#line 254
    if (len > 1U) {
#line 254
      if ((int )*(p + -1) == 47) {
#line 255
        len --;
      }
    }
#line 257
    if (len > 1U) {
#line 257
      goto _L___4;
    } else
#line 257
    if ((int )*v != 46) {
      _L___4: /* CIL Label */ 
#line 259
      v = savestring((char const   *)v, len);
#line 263
      tmp___6 = dir_file_exists_p(v, (char *)"");
#line 263
      if (tmp___6) {
#line 266
        tmp___5 = elem;
#line 266
        elem ++;
#line 266
        *(vpath + tmp___5) = dir_name(v);
#line 267
        free((void *)v);
#line 268
        if (len > maxvpath) {
#line 269
          maxvpath = len;
        }
      } else {
#line 273
        free((void *)v);
      }
    }
#line 277
    while (1) {
#line 277
      if (! ((int )*p == 58)) {
#line 277
        tmp___7 = __ctype_b_loc();
#line 277
        if (! ((int const   )*(*tmp___7 + (int )*p) & 1)) {
#line 277
          break;
        }
      }
#line 278
      p ++;
    }
  }
#line 281
  if (elem > 0U) {
#line 287
    if (elem < maxelem - 1U) {
#line 288
      tmp___8 = xrealloc((char *)vpath, (unsigned int )((unsigned long )(elem + 1U) * sizeof(char *)));
#line 288
      vpath = (char **)tmp___8;
    }
#line 292
    *(vpath + elem) = (char *)0;
#line 295
    tmp___9 = xmalloc((unsigned int )sizeof(struct vpath ));
#line 295
    path___0 = (struct vpath *)tmp___9;
#line 296
    path___0->searchpath = vpath;
#line 297
    path___0->maxlen = maxvpath;
#line 298
    path___0->next = vpaths;
#line 299
    vpaths = path___0;
#line 302
    path___0->pattern = pattern;
#line 303
    path___0->percent = percent;
#line 304
    tmp___10 = strlen((char const   *)pattern);
#line 304
    path___0->patlen = (unsigned int )tmp___10;
  } else {
#line 309
    free((void *)((char *)vpath));
#line 310
    if ((unsigned long )pattern != (unsigned long )((char *)0)) {
#line 311
      free((void *)pattern);
    }
  }
#line 313
  return;
}
}
#line 318 "vpath.c"
int gpath_search(char *file , int len ) 
{ 
  register char **gp ;
  int tmp ;

  {
#line 325
  if (gpaths) {
#line 325
    if ((unsigned int )len <= gpaths->maxlen) {
#line 326
      gp = gpaths->searchpath;
#line 326
      while ((unsigned long )*gp != (unsigned long )((void *)0)) {
#line 327
        tmp = strncmp((char const   *)*gp, (char const   *)file, (size_t )len);
#line 327
        if (tmp == 0) {
#line 327
          if ((int )*(*gp + len) == 0) {
#line 328
            return (1);
          }
        }
#line 326
        gp ++;
      }
    }
  }
#line 330
  return (0);
}
}
#line 339 "vpath.c"
int vpath_search(char **file , uintmax_t *mtime_ptr ) 
{ 
  register struct vpath *v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 349
  if ((int )*(*file) == 47) {
#line 355
    return (0);
  } else
#line 349
  if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
#line 349
    if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
#line 355
      return (0);
    }
  }
#line 357
  v = vpaths;
#line 357
  while ((unsigned long )v != (unsigned long )((struct vpath *)0)) {
#line 358
    tmp___0 = pattern_matches(v->pattern, v->percent, *file);
#line 358
    if (tmp___0) {
#line 359
      tmp = selective_vpath_search(v, file, mtime_ptr);
#line 359
      if (tmp) {
#line 360
        return (1);
      }
    }
#line 357
    v = v->next;
  }
#line 362
  if ((unsigned long )general_vpath != (unsigned long )((struct vpath *)0)) {
#line 362
    tmp___1 = selective_vpath_search(general_vpath, file, mtime_ptr);
#line 362
    if (tmp___1) {
#line 364
      return (1);
    }
  }
#line 366
  return (0);
}
}
#line 376 "vpath.c"
static int selective_vpath_search(struct vpath *path , char **file , uintmax_t *mtime_ptr ) 
{ 
  int not_target ;
  char *name ;
  char *n ;
  char *filename ;
  register char **vpath ;
  unsigned int maxvpath ;
  register unsigned int i ;
  unsigned int flen ;
  unsigned int vlen ;
  unsigned int name_dplen ;
  int exists ;
  struct file *f ;
  struct file *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int exists_in_cache ;
  size_t tmp___3 ;
  char *tmp___4 ;
  struct file *f___0 ;
  struct file *tmp___5 ;
  int tmp___6 ;
  struct stat st ;
  uintmax_t tmp___7 ;
  uintmax_t tmp___8 ;
  int tmp___9 ;

  {
#line 385
  vpath = path->searchpath;
#line 386
  maxvpath = path->maxlen;
#line 389
  exists = 0;
#line 395
  tmp = lookup_file(*file);
#line 395
  f = tmp;
#line 396
  if ((unsigned long )f == (unsigned long )((struct file *)0)) {
#line 396
    tmp___0 = 1;
  } else
#line 396
  if (! f->is_target) {
#line 396
    tmp___0 = 1;
  } else {
#line 396
    tmp___0 = 0;
  }
#line 396
  not_target = tmp___0;
#line 399
  tmp___1 = strlen((char const   *)*file);
#line 399
  flen = (unsigned int )tmp___1;
#line 405
  n = strrchr((char const   *)*file, '/');
#line 414
  if ((unsigned long )n != (unsigned long )((char *)0)) {
#line 414
    name_dplen = (unsigned int )(n - *file);
  } else {
#line 414
    name_dplen = 0U;
  }
#line 415
  if (name_dplen > 0U) {
#line 415
    filename = n + 1;
  } else {
#line 415
    filename = *file;
  }
#line 416
  if (name_dplen > 0U) {
#line 417
    flen -= name_dplen + 1U;
  }
#line 423
  tmp___2 = xmalloc(((((maxvpath + 1U) + name_dplen) + 1U) + flen) + 1U);
#line 423
  name = tmp___2;
#line 426
  i = 0U;
#line 426
  while ((unsigned long )*(vpath + i) != (unsigned long )((char *)0)) {
#line 428
    exists_in_cache = 0;
#line 430
    n = name;
#line 433
    tmp___3 = strlen((char const   *)*(vpath + i));
#line 433
    vlen = (unsigned int )tmp___3;
#line 434
    memmove((void *)n, (void const   *)*(vpath + i), (size_t )vlen);
#line 435
    n += vlen;
#line 438
    if (name_dplen > 0U) {
#line 441
      tmp___4 = n;
#line 441
      n ++;
#line 441
      *tmp___4 = (char )'/';
#line 443
      memmove((void *)n, (void const   *)*file, (size_t )name_dplen);
#line 444
      n += name_dplen;
    }
#line 454
    if ((unsigned long )n != (unsigned long )name) {
#line 454
      if ((int )*(n + -1) != 47) {
#line 456
        *n = (char )'/';
#line 457
        memmove((void *)(n + 1), (void const   *)filename, (size_t )(flen + 1U));
      } else {
#line 461
        memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));
      }
    } else {
#line 461
      memmove((void *)n, (void const   *)filename, (size_t )(flen + 1U));
    }
#line 477
    tmp___5 = lookup_file(name);
#line 477
    f___0 = tmp___5;
#line 478
    if ((unsigned long )f___0 != (unsigned long )((struct file *)0)) {
#line 479
      if (not_target) {
#line 479
        tmp___6 = 1;
      } else
#line 479
      if (f___0->is_target) {
#line 479
        tmp___6 = 1;
      } else {
#line 479
        tmp___6 = 0;
      }
#line 479
      exists = tmp___6;
    }
#line 482
    if (! exists) {
#line 492
      *n = (char )'\000';
#line 497
      exists = dir_file_exists_p(name, filename);
#line 497
      exists_in_cache = exists;
    }
#line 501
    if (exists) {
#line 513
      *n = (char )'/';
#line 516
      if (! exists_in_cache) {
#line 516
        goto _L;
      } else {
#line 516
        tmp___9 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
#line 516
        if (tmp___9 == 0) {
          _L: /* CIL Label */ 
#line 522
          *file = savestring((char const   *)name, (unsigned int )(((n + 1) - name) + (long )flen));
#line 524
          if ((unsigned long )mtime_ptr != (unsigned long )((uintmax_t *)0)) {
#line 528
            if (exists_in_cache) {
#line 528
              if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 528
                tmp___7 = (uintmax_t )1000000000;
              } else {
#line 528
                tmp___7 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
              }
#line 528
              if (1000000000UL < 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)))) {
#line 528
                tmp___8 = (uintmax_t )1000000000;
              } else {
#line 528
                tmp___8 = 0xffffffffffffffffUL / (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL)));
              }
#line 528
              *mtime_ptr = (uintmax_t )st.st_mtim.tv_sec * tmp___7 + ((uintmax_t )st.st_mtim.tv_nsec * tmp___8) / 1000000000UL;
            } else {
#line 528
              *mtime_ptr = (uintmax_t )0;
            }
          }
#line 532
          free((void *)name);
#line 533
          return (1);
        } else {
#line 536
          exists = 0;
        }
      }
    }
#line 426
    i ++;
  }
#line 540
  free((void *)name);
#line 541
  return (0);
}
}
#line 546 "vpath.c"
void print_vpath_data_base(void) 
{ 
  register unsigned int nvpaths ;
  register struct vpath *v ;
  char *tmp ;
  register unsigned int i ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  register char **path ;
  register unsigned int i___0 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 552
  tmp = dcgettext((char const   *)((void *)0), "\n# VPATH Search Paths\n", 5);
#line 552
  puts((char const   *)tmp);
#line 554
  nvpaths = 0U;
#line 555
  v = vpaths;
#line 555
  while ((unsigned long )v != (unsigned long )((struct vpath *)0)) {
#line 559
    nvpaths ++;
#line 561
    printf((char const   * __restrict  )"vpath %s ", v->pattern);
#line 563
    i = 0U;
#line 563
    while ((unsigned long )*(v->searchpath + i) != (unsigned long )((char *)0)) {
#line 564
      if ((unsigned long )*(v->searchpath + (i + 1U)) == (unsigned long )((char *)0)) {
#line 564
        tmp___0 = '\n';
      } else {
#line 564
        tmp___0 = ':';
      }
#line 564
      printf((char const   * __restrict  )"%s%c", *(v->searchpath + i), tmp___0);
#line 563
      i ++;
    }
#line 555
    v = v->next;
  }
#line 568
  if ((unsigned long )vpaths == (unsigned long )((struct vpath *)0)) {
#line 569
    tmp___1 = dcgettext((char const   *)((void *)0), "# No `vpath\' search paths.",
                        5);
#line 569
    puts((char const   *)tmp___1);
  } else {
#line 571
    tmp___2 = dcgettext((char const   *)((void *)0), "\n# %u `vpath\' search paths.\n",
                        5);
#line 571
    printf((char const   * __restrict  )tmp___2, nvpaths);
  }
#line 573
  if ((unsigned long )general_vpath == (unsigned long )((struct vpath *)0)) {
#line 574
    tmp___3 = dcgettext((char const   *)((void *)0), "\n# No general (`VPATH\' variable) search path.",
                        5);
#line 574
    puts((char const   *)tmp___3);
  } else {
#line 577
    path = general_vpath->searchpath;
#line 580
    tmp___4 = dcgettext((char const   *)((void *)0), "\n# General (`VPATH\' variable) search path:\n# ",
                        5);
#line 580
    fputs((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);
#line 582
    i___0 = 0U;
#line 582
    while ((unsigned long )*(path + i___0) != (unsigned long )((char *)0)) {
#line 583
      if ((unsigned long )*(path + (i___0 + 1U)) == (unsigned long )((char *)0)) {
#line 583
        tmp___5 = '\n';
      } else {
#line 583
        tmp___5 = ':';
      }
#line 583
      printf((char const   * __restrict  )"%s%c", *(path + i___0), tmp___5);
#line 582
      i___0 ++;
    }
  }
#line 586
  return;
}
}
#line 1 "default.o"
#pragma merger("0","/tmp/cil-1wVmO6Ew.i","-g,-O0")
#line 39 "default.c"
static char default_suffixes[136]  = 
#line 39 "default.c"
  {      (char )'.',      (char )'o',      (char )'u',      (char )'t', 
        (char )' ',      (char )'.',      (char )'a',      (char )' ', 
        (char )'.',      (char )'l',      (char )'n',      (char )' ', 
        (char )'.',      (char )'o',      (char )' ',      (char )'.', 
        (char )'c',      (char )' ',      (char )'.',      (char )'c', 
        (char )'c',      (char )' ',      (char )'.',      (char )'C', 
        (char )' ',      (char )'.',      (char )'c',      (char )'p', 
        (char )'p',      (char )' ',      (char )'.',      (char )'p', 
        (char )' ',      (char )'.',      (char )'f',      (char )' ', 
        (char )'.',      (char )'F',      (char )' ',      (char )'.', 
        (char )'r',      (char )' ',      (char )'.',      (char )'y', 
        (char )' ',      (char )'.',      (char )'l',      (char )' ', 
        (char )'.',      (char )'s',      (char )' ',      (char )'.', 
        (char )'S',      (char )' ',      (char )'.',      (char )'m', 
        (char )'o',      (char )'d',      (char )' ',      (char )'.', 
        (char )'s',      (char )'y',      (char )'m',      (char )' ', 
        (char )'.',      (char )'d',      (char )'e',      (char )'f', 
        (char )' ',      (char )'.',      (char )'h',      (char )' ', 
        (char )'.',      (char )'i',      (char )'n',      (char )'f', 
        (char )'o',      (char )' ',      (char )'.',      (char )'d', 
        (char )'v',      (char )'i',      (char )' ',      (char )'.', 
        (char )'t',      (char )'e',      (char )'x',      (char )' ', 
        (char )'.',      (char )'t',      (char )'e',      (char )'x', 
        (char )'i',      (char )'n',      (char )'f',      (char )'o', 
        (char )' ',      (char )'.',      (char )'t',      (char )'e', 
        (char )'x',      (char )'i',      (char )' ',      (char )'.', 
        (char )'t',      (char )'x',      (char )'i',      (char )'n', 
        (char )'f',      (char )'o',      (char )' ',      (char )'.', 
        (char )'w',      (char )' ',      (char )'.',      (char )'c', 
        (char )'h',      (char )' ',      (char )'.',      (char )'w', 
        (char )'e',      (char )'b',      (char )' ',      (char )'.', 
        (char )'s',      (char )'h',      (char )' ',      (char )'.', 
        (char )'e',      (char )'l',      (char )'c',      (char )' ', 
        (char )'.',      (char )'e',      (char )'l',      (char )'\000'};
#line 50 "default.c"
static struct pspec default_pattern_rules[5]  = {      {(char *)"(%)", (char *)"%", (char *)"$(AR) $(ARFLAGS) $@ $<"}, 
        {(char *)"%.out", (char *)"%", (char *)"@rm -f $@ \n cp $< $@"}, 
        {(char *)"%.c", (char *)"%.w %.ch", (char *)"$(CTANGLE) $^ $@"}, 
        {(char *)"%.tex", (char *)"%.w %.ch", (char *)"$(CWEAVE) $^ $@"}, 
        {(char *)0, (char *)0, (char *)0}};
#line 74 "default.c"
static struct pspec default_terminal_rules[6]  = {      {(char *)"%", (char *)"%,v", (char *)"$(CHECKOUT,v)"}, 
        {(char *)"%", (char *)"RCS/%,v", (char *)"$(CHECKOUT,v)"}, 
        {(char *)"%", (char *)"RCS/%", (char *)"$(CHECKOUT,v)"}, 
        {(char *)"%", (char *)"s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
        {(char *)"%",
      (char *)"SCCS/s.%", (char *)"$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<"}, 
        {(char *)0, (char *)0, (char *)0}};
#line 107 "default.c"
static char *default_suffix_rules[92]  = 
#line 107
  {      (char *)".o",      (char *)"$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".s",      (char *)"$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".S",      (char *)"$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".c",      (char *)"$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".cc",      (char *)"$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".C",      (char *)"$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".cpp",      (char *)"$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".f",      (char *)"$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".p",      (char *)"$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".F",      (char *)"$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@", 
        (char *)".r",      (char *)"$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",      (char *)".mod",      (char *)"$(COMPILE.mod) -o $@ -e $@ $^", 
        (char *)".def.sym",      (char *)"$(COMPILE.def) -o $@ $<",      (char *)".sh",      (char *)"cat $< >$@ \n chmod a+x $@", 
        (char *)".s.o",      (char *)"$(COMPILE.s) -o $@ $<",      (char *)".S.o",      (char *)"$(COMPILE.S) -o $@ $<", 
        (char *)".c.o",      (char *)"$(COMPILE.c) $(OUTPUT_OPTION) $<",      (char *)".cc.o",      (char *)"$(COMPILE.cc) $(OUTPUT_OPTION) $<", 
        (char *)".C.o",      (char *)"$(COMPILE.C) $(OUTPUT_OPTION) $<",      (char *)".cpp.o",      (char *)"$(COMPILE.cpp) $(OUTPUT_OPTION) $<", 
        (char *)".f.o",      (char *)"$(COMPILE.f) $(OUTPUT_OPTION) $<",      (char *)".p.o",      (char *)"$(COMPILE.p) $(OUTPUT_OPTION) $<", 
        (char *)".F.o",      (char *)"$(COMPILE.F) $(OUTPUT_OPTION) $<",      (char *)".r.o",      (char *)"$(COMPILE.r) $(OUTPUT_OPTION) $<", 
        (char *)".mod.o",      (char *)"$(COMPILE.mod) -o $@ $<",      (char *)".c.ln",      (char *)"$(LINT.c) -C$* $<", 
        (char *)".y.ln",      (char *)"$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",      (char *)".l.ln",      (char *)"@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c", 
        (char *)".y.c",      (char *)"$(YACC.y) $< \n mv -f y.tab.c $@",      (char *)".l.c",      (char *)"@$(RM) $@ \n $(LEX.l) $< > $@", 
        (char *)".F.f",      (char *)"$(PREPROCESS.F) $(OUTPUT_OPTION) $<",      (char *)".r.f",      (char *)"$(PREPROCESS.r) $(OUTPUT_OPTION) $<", 
        (char *)".l.r",      (char *)"$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",      (char *)".S.s",      (char *)"$(PREPROCESS.S) $< > $@", 
        (char *)".texinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".texi.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@", 
        (char *)".txinfo.info",      (char *)"$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",      (char *)".tex.dvi",      (char *)"$(TEX) $<", 
        (char *)".texinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".texi.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<", 
        (char *)".txinfo.dvi",      (char *)"$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",      (char *)".w.c",      (char *)"$(CTANGLE) $< - $@", 
        (char *)".web.p",      (char *)"$(TANGLE) $<",      (char *)".w.tex",      (char *)"$(CWEAVE) $< - $@", 
        (char *)".web.tex",      (char *)"$(WEAVE) $<",      (char *)0,      (char *)0};
#line 300 "default.c"
static char *default_variables[118]  = 
#line 300
  {      (char *)"AR",      (char *)"ar",      (char *)"ARFLAGS",      (char *)"rv", 
        (char *)"AS",      (char *)"as",      (char *)"CC",      (char *)"cc", 
        (char *)"CXX",      (char *)"g++",      (char *)"CHECKOUT,v",      (char *)"+$(if $(wildcard $@),,$(CO) $(COFLAGS) $< $@)", 
        (char *)"CO",      (char *)"co",      (char *)"COFLAGS",      (char *)"", 
        (char *)"CPP",      (char *)"$(CC) -E",      (char *)"FC",      (char *)"f77", 
        (char *)"F77",      (char *)"$(FC)",      (char *)"F77FLAGS",      (char *)"$(FFLAGS)", 
        (char *)"GET",      (char *)"get",      (char *)"LD",      (char *)"ld", 
        (char *)"LEX",      (char *)"lex",      (char *)"LINT",      (char *)"lint", 
        (char *)"M2C",      (char *)"m2c",      (char *)"PC",      (char *)"pc", 
        (char *)"YACC",      (char *)"yacc",      (char *)"MAKEINFO",      (char *)"makeinfo", 
        (char *)"TEX",      (char *)"tex",      (char *)"TEXI2DVI",      (char *)"texi2dvi", 
        (char *)"WEAVE",      (char *)"weave",      (char *)"CWEAVE",      (char *)"cweave", 
        (char *)"TANGLE",      (char *)"tangle",      (char *)"CTANGLE",      (char *)"ctangle", 
        (char *)"RM",      (char *)"rm -f",      (char *)"LINK.o",      (char *)"$(CC) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"COMPILE.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.c",      (char *)"$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"COMPILE.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"COMPILE.C",      (char *)"$(COMPILE.cc)", 
        (char *)"COMPILE.cpp",      (char *)"$(COMPILE.cc)",      (char *)"LINK.cc",      (char *)"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"LINK.C",      (char *)"$(LINK.cc)",      (char *)"LINK.cpp",      (char *)"$(LINK.cc)", 
        (char *)"YACC.y",      (char *)"$(YACC) $(YFLAGS)",      (char *)"LEX.l",      (char *)"$(LEX) $(LFLAGS) -t", 
        (char *)"COMPILE.f",      (char *)"$(FC) $(FFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.f",      (char *)"$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"COMPILE.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"COMPILE.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"COMPILE.def",      (char *)"$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",      (char *)"COMPILE.mod",      (char *)"$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)", 
        (char *)"COMPILE.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",      (char *)"LINK.p",      (char *)"$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)", 
        (char *)"LINK.s",      (char *)"$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",      (char *)"COMPILE.s",      (char *)"$(AS) $(ASFLAGS) $(TARGET_MACH)", 
        (char *)"LINK.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",      (char *)"COMPILE.S",      (char *)"$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c", 
        (char *)"PREPROCESS.S",      (char *)"$(CC) -E $(CPPFLAGS)",      (char *)"PREPROCESS.F",      (char *)"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F", 
        (char *)"PREPROCESS.r",      (char *)"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",      (char *)"LINT.c",      (char *)"$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)", 
        (char *)"OUTPUT_OPTION",      (char *)"-o $@",      (char *)".LIBPATTERNS",      (char *)"lib%.so lib%.a", 
        (char *)0,      (char *)0};
#line 513 "default.c"
void set_default_suffixes(void) 
{ 
  char *p ;
  struct nameseq *tmp ;
  struct nameseq *tmp___0 ;

  {
#line 516
  suffix_file = enter_file((char *)".SUFFIXES");
#line 518
  if (no_builtin_rules_flag) {
#line 519
    define_variable_in_set((char *)"SUFFIXES", 8U, (char *)"", (enum variable_origin )0,
                           0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
  } else {
#line 522
    p = default_suffixes;
#line 523
    tmp = parse_file_seq(& p, '\000', (unsigned int )sizeof(struct dep ), 1);
#line 523
    tmp___0 = multi_glob(tmp, (unsigned int )sizeof(struct dep ));
#line 523
    suffix_file->deps = (struct dep *)tmp___0;
#line 526
    define_variable_in_set((char *)"SUFFIXES", 8U, default_suffixes, (enum variable_origin )0,
                           0, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
  }
#line 528
  return;
}
}
#line 535 "default.c"
void install_default_suffix_rules(void) 
{ 
  register char **s ;
  register struct file *f ;
  struct file *tmp ;
  char *tmp___0 ;

  {
#line 540
  if (no_builtin_rules_flag) {
#line 541
    return;
  }
#line 543
  s = default_suffix_rules;
#line 543
  while ((unsigned long )*s != (unsigned long )((char *)0)) {
#line 545
    tmp = enter_file(*(s + 0));
#line 545
    f = tmp;
#line 547
    if ((unsigned long )f->cmds == (unsigned long )((struct commands *)0)) {
#line 549
      tmp___0 = xmalloc((unsigned int )sizeof(struct commands ));
#line 549
      f->cmds = (struct commands *)tmp___0;
#line 550
      (f->cmds)->fileinfo.filenm = (char *)0;
#line 551
      (f->cmds)->commands = *(s + 1);
#line 552
      (f->cmds)->command_lines = (char **)0;
    }
#line 543
    s += 2;
  }
#line 555
  return;
}
}
#line 560 "default.c"
void install_default_implicit_rules(void) 
{ 
  register struct pspec *p ;

  {
#line 565
  if (no_builtin_rules_flag) {
#line 566
    return;
  }
#line 568
  p = default_pattern_rules;
#line 568
  while ((unsigned long )p->target != (unsigned long )((char *)0)) {
#line 569
    install_pattern_rule(p, 0);
#line 568
    p ++;
  }
#line 571
  p = default_terminal_rules;
#line 571
  while ((unsigned long )p->target != (unsigned long )((char *)0)) {
#line 572
    install_pattern_rule(p, 1);
#line 571
    p ++;
  }
#line 573
  return;
}
}
#line 575 "default.c"
void define_default_variables(void) 
{ 
  register char **s ;
  size_t tmp ;

  {
#line 580
  if (no_builtin_variables_flag) {
#line 581
    return;
  }
#line 583
  s = default_variables;
#line 583
  while ((unsigned long )*s != (unsigned long )((char *)0)) {
#line 584
    tmp = strlen((char const   *)*(s + 0));
#line 584
    define_variable_in_set(*(s + 0), (unsigned int )tmp, *(s + 1), (enum variable_origin )0,
                           1, current_variable_set_list->set, (struct floc  const  *)((struct floc *)0));
#line 583
    s += 2;
  }
#line 585
  return;
}
}
#line 1 "remote-stub.o"
#pragma merger("0","/tmp/cil-D1SUSxUT.i","-g,-O0")
#line 26 "remote-stub.c"
char *remote_description  =    (char *)0;
#line 30 "remote-stub.c"
void remote_setup(void) 
{ 


  {
#line 33
  return;
}
}
#line 37 "remote-stub.c"
void remote_cleanup(void) 
{ 


  {
#line 40
  return;
}
}
#line 44 "remote-stub.c"
int start_remote_job_p(int first_p ) 
{ 


  {
#line 48
  return (0);
}
}
#line 58 "remote-stub.c"
int start_remote_job(char **argv , char **envp , int stdin_fd , int *is_remote , int *id_ptr ,
                     int *used_stdin ) 
{ 


  {
#line 66
  return (-1);
}
}
#line 75 "remote-stub.c"
int remote_status(int *exit_code_ptr , int *signal_ptr , int *coredump_ptr , int block ) 
{ 
  int *tmp ;

  {
#line 80
  tmp = __errno_location();
#line 80
  *tmp = 10;
#line 81
  return (-1);
}
}
#line 87 "remote-stub.c"
void block_remote_children(void) 
{ 


  {
#line 90
  return;
}
}
#line 96 "remote-stub.c"
void unblock_remote_children(void) 
{ 


  {
#line 99
  return;
}
}
#line 103 "remote-stub.c"
int remote_kill(int id , int sig ) 
{ 


  {
#line 108
  return (-1);
}
}
#line 1 "version.o"
#pragma merger("0","/tmp/cil-q1MkCrcS.i","-g,-O0")
#line 10 "version.c"
char *version_string  =    (char *)"3.79";
#line 11 "version.c"
char *make_host  =    (char *)"";
#line 1 "getopt1.o"
#pragma merger("0","/tmp/cil-wQnu2qSg.i","-g,-O0")
#line 1 "gettext.o"
#pragma merger("0","/tmp/cil-IP6q2TZB.i","-g,-O0")
#line 451 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 817 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 122 "gettext.c"
static char const   *_nl_normalize_codeset(unsigned char const   *codeset , size_t name_len ) ;
#line 125
static struct loaded_l10nfile *_nl_make_l10nflist(struct loaded_l10nfile **l10nfile_list ,
                                                  char const   *dirlist , size_t dirlist_len ,
                                                  int mask , char const   *language ,
                                                  char const   *territory , char const   *codeset ,
                                                  char const   *normalized_codeset ,
                                                  char const   *modifier , char const   *special ,
                                                  char const   *sponsor , char const   *revision ,
                                                  char const   *filename , int do_allocate ) ;
#line 135
static char const   *_nl_expand_alias(char const   *name ) ;
#line 137
static int _nl_explode_name(char *name , char const   **language , char const   **modifier ,
                            char const   **territory , char const   **codeset , char const   **normalized_codeset ,
                            char const   **special , char const   **sponsor , char const   **revision ) ;
#line 176
static size_t argz_count__(char const   *argz , size_t len ) ;
#line 178 "gettext.c"
static size_t argz_count__(char const   *argz , size_t len ) 
{ 
  size_t count ;
  size_t part_len ;
  size_t tmp ;

  {
#line 183
  count = (size_t )0;
#line 184
  while (len > 0UL) {
#line 186
    tmp = strlen(argz);
#line 186
    part_len = tmp;
#line 187
    argz += part_len + 1UL;
#line 188
    len -= part_len + 1UL;
#line 189
    count ++;
  }
#line 191
  return (count);
}
}
#line 200
static void argz_stringify__(char *argz , size_t len , int sep ) ;
#line 202 "gettext.c"
static void argz_stringify__(char *argz , size_t len , int sep ) 
{ 
  size_t part_len ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 208
  while (len > 0UL) {
#line 210
    tmp = strlen((char const   *)argz);
#line 210
    part_len = tmp;
#line 211
    argz += part_len;
#line 212
    len -= part_len + 1UL;
#line 213
    if (len > 0UL) {
#line 214
      tmp___0 = argz;
#line 214
      argz ++;
#line 214
      *tmp___0 = (char )sep;
    }
  }
#line 216
  return;
}
}
#line 222
static char *argz_next__(char *argz , size_t argz_len , char const   *entry ) ;
#line 225 "gettext.c"
static char *argz_next__(char *argz , size_t argz_len , char const   *entry ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 231
  if (entry) {
#line 233
    if ((unsigned long )entry < (unsigned long )(argz + argz_len)) {
#line 234
      tmp = strchr(entry, '\000');
#line 234
      entry = (char const   *)(tmp + 1);
    }
#line 236
    if ((unsigned long )entry >= (unsigned long )(argz + argz_len)) {
#line 236
      tmp___0 = (char *)((void *)0);
    } else {
#line 236
      tmp___0 = (char *)entry;
    }
#line 236
    return (tmp___0);
  } else
#line 239
  if (argz_len > 0UL) {
#line 240
    return (argz);
  } else {
#line 242
    return ((char *)0);
  }
}
}
#line 249
__inline static int pop(int x ) ;
#line 251 "gettext.c"
__inline static int pop(int x ) 
{ 


  {
#line 256
  x = ((x & -21846) >> 1) + (x & 21845);
#line 257
  x = ((x & -13108) >> 2) + (x & 13107);
#line 258
  x = ((x >> 4) + x) & 3855;
#line 259
  x = ((x >> 8) + x) & 255;
#line 261
  return (x);
}
}
#line 264 "gettext.c"
static struct loaded_l10nfile *_nl_make_l10nflist(struct loaded_l10nfile **l10nfile_list ,
                                                  char const   *dirlist , size_t dirlist_len ,
                                                  int mask , char const   *language ,
                                                  char const   *territory , char const   *codeset ,
                                                  char const   *normalized_codeset ,
                                                  char const   *modifier , char const   *special ,
                                                  char const   *sponsor , char const   *revision ,
                                                  char const   *filename , int do_allocate ) 
{ 
  char *abs_filename ;
  struct loaded_l10nfile *last ;
  struct loaded_l10nfile *retval ;
  char *cp ;
  size_t entries ;
  int cnt ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int compare ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___33 ;
  char *dir ;
  size_t tmp___34 ;
  size_t tmp___35 ;

  {
#line 284
  last = (struct loaded_l10nfile *)((void *)0);
#line 291
  tmp = strlen(language);
#line 291
  if ((mask & 32) != 0) {
#line 291
    tmp___0 = strlen(territory);
#line 291
    tmp___1 = tmp___0 + 1UL;
  } else {
#line 291
    tmp___1 = (size_t )0;
  }
#line 291
  if ((mask & 16) != 0) {
#line 291
    tmp___2 = strlen(codeset);
#line 291
    tmp___3 = tmp___2 + 1UL;
  } else {
#line 291
    tmp___3 = (size_t )0;
  }
#line 291
  if ((mask & 8) != 0) {
#line 291
    tmp___4 = strlen(normalized_codeset);
#line 291
    tmp___5 = tmp___4 + 1UL;
  } else {
#line 291
    tmp___5 = (size_t )0;
  }
#line 291
  if ((mask & 128) != 0) {
#line 291
    tmp___6 = strlen(modifier);
#line 291
    tmp___7 = tmp___6 + 1UL;
  } else
#line 291
  if ((mask & 64) != 0) {
#line 291
    tmp___6 = strlen(modifier);
#line 291
    tmp___7 = tmp___6 + 1UL;
  } else {
#line 291
    tmp___7 = (size_t )0;
  }
#line 291
  if ((mask & 4) != 0) {
#line 291
    tmp___8 = strlen(special);
#line 291
    tmp___9 = tmp___8 + 1UL;
  } else {
#line 291
    tmp___9 = (size_t )0;
  }
#line 291
  if ((mask & 2) != 0) {
#line 291
    goto _L;
  } else
#line 291
  if ((mask & 1) != 0) {
    _L: /* CIL Label */ 
#line 291
    if ((mask & 2) != 0) {
#line 291
      tmp___10 = strlen(sponsor);
#line 291
      tmp___11 = tmp___10 + 1UL;
    } else {
#line 291
      tmp___11 = (size_t )0;
    }
#line 291
    if ((mask & 1) != 0) {
#line 291
      tmp___12 = strlen(revision);
#line 291
      tmp___13 = tmp___12 + 1UL;
    } else {
#line 291
      tmp___13 = (size_t )0;
    }
#line 291
    tmp___14 = (1UL + tmp___11) + tmp___13;
  } else {
#line 291
    tmp___14 = (size_t )0;
  }
#line 291
  tmp___15 = strlen(filename);
#line 291
  tmp___16 = malloc((((((((((dirlist_len + tmp) + tmp___1) + tmp___3) + tmp___5) + tmp___7) + tmp___9) + tmp___14) + 1UL) + tmp___15) + 1UL);
#line 291
  abs_filename = (char *)tmp___16;
#line 312
  if ((unsigned long )abs_filename == (unsigned long )((void *)0)) {
#line 313
    return ((struct loaded_l10nfile *)((void *)0));
  }
#line 315
  retval = (struct loaded_l10nfile *)((void *)0);
#line 316
  last = (struct loaded_l10nfile *)((void *)0);
#line 319
  memcpy((void * __restrict  )abs_filename, (void const   * __restrict  )dirlist,
         dirlist_len);
#line 320
  argz_stringify__(abs_filename, dirlist_len, ':');
#line 321
  cp = abs_filename + (dirlist_len - 1UL);
#line 322
  tmp___17 = cp;
#line 322
  cp ++;
#line 322
  *tmp___17 = (char )'/';
#line 323
  cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )language);
#line 325
  if ((mask & 32) != 0) {
#line 327
    tmp___18 = cp;
#line 327
    cp ++;
#line 327
    *tmp___18 = (char )'_';
#line 328
    cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )territory);
  }
#line 330
  if ((mask & 16) != 0) {
#line 332
    tmp___19 = cp;
#line 332
    cp ++;
#line 332
    *tmp___19 = (char )'.';
#line 333
    cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )codeset);
  }
#line 335
  if ((mask & 8) != 0) {
#line 337
    tmp___20 = cp;
#line 337
    cp ++;
#line 337
    *tmp___20 = (char )'.';
#line 338
    cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )normalized_codeset);
  }
#line 340
  if ((mask & 192) != 0) {
#line 344
    tmp___21 = cp;
#line 344
    cp ++;
#line 344
    if ((mask & 64) != 0) {
#line 344
      *tmp___21 = (char )'+';
    } else {
#line 344
      *tmp___21 = (char )'@';
    }
#line 345
    cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )modifier);
  }
#line 347
  if ((mask & 4) != 0) {
#line 349
    tmp___22 = cp;
#line 349
    cp ++;
#line 349
    *tmp___22 = (char )'+';
#line 350
    cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )special);
  }
#line 352
  if ((mask & 3) != 0) {
#line 354
    tmp___23 = cp;
#line 354
    cp ++;
#line 354
    *tmp___23 = (char )',';
#line 355
    if ((mask & 2) != 0) {
#line 356
      cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )sponsor);
    }
#line 357
    if ((mask & 1) != 0) {
#line 359
      tmp___24 = cp;
#line 359
      cp ++;
#line 359
      *tmp___24 = (char )'_';
#line 360
      cp = stpcpy((char * __restrict  )cp, (char const   * __restrict  )revision);
    }
  }
#line 364
  tmp___25 = cp;
#line 364
  cp ++;
#line 364
  *tmp___25 = (char )'/';
#line 365
  stpcpy((char * __restrict  )cp, (char const   * __restrict  )filename);
#line 369
  last = (struct loaded_l10nfile *)((void *)0);
#line 370
  retval = *l10nfile_list;
#line 370
  while ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 371
    if ((unsigned long )retval->filename != (unsigned long )((void *)0)) {
#line 373
      tmp___26 = strcmp(retval->filename, (char const   *)abs_filename);
#line 373
      compare = tmp___26;
#line 374
      if (compare == 0) {
#line 376
        break;
      }
#line 377
      if (compare < 0) {
#line 380
        retval = (struct loaded_l10nfile *)((void *)0);
#line 381
        break;
      }
#line 384
      last = retval;
    }
#line 370
    retval = retval->next;
  }
#line 387
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 389
    free((void *)abs_filename);
#line 390
    return (retval);
  } else
#line 387
  if (do_allocate == 0) {
#line 389
    free((void *)abs_filename);
#line 390
    return (retval);
  }
#line 393
  tmp___27 = argz_count__(dirlist, dirlist_len);
#line 393
  tmp___28 = pop(mask);
#line 393
  tmp___29 = malloc(sizeof(*retval) + (tmp___27 * (size_t )(1 << tmp___28)) * sizeof(struct loaded_l10nfile *));
#line 393
  retval = (struct loaded_l10nfile *)tmp___29;
#line 397
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
#line 398
    return ((struct loaded_l10nfile *)((void *)0));
  }
#line 400
  retval->filename = (char const   *)abs_filename;
#line 401
  tmp___30 = argz_count__(dirlist, dirlist_len);
#line 401
  if (tmp___30 != 1UL) {
#line 401
    tmp___31 = 1;
  } else
#line 401
  if ((mask & 16) != 0) {
#line 401
    if ((mask & 8) != 0) {
#line 401
      tmp___31 = 1;
    } else {
#line 401
      tmp___31 = 0;
    }
  } else {
#line 401
    tmp___31 = 0;
  }
#line 401
  retval->decided = tmp___31;
#line 404
  retval->data = (void const   *)((void *)0);
#line 406
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 408
    retval->next = *l10nfile_list;
#line 409
    *l10nfile_list = retval;
  } else {
#line 413
    retval->next = last->next;
#line 414
    last->next = retval;
  }
#line 417
  entries = (size_t )0;
#line 421
  tmp___33 = argz_count__(dirlist, dirlist_len);
#line 421
  if (tmp___33 == 1UL) {
#line 421
    cnt = mask - 1;
  } else {
#line 421
    cnt = mask;
  }
#line 422
  while (cnt >= 0) {
#line 423
    if ((cnt & ~ mask) == 0) {
#line 423
      if ((cnt & 71) == 0) {
#line 423
        goto _L___1;
      } else
#line 423
      if ((cnt & 152) == 0) {
        _L___1: /* CIL Label */ 
#line 423
        if ((cnt & 16) == 0) {
#line 423
          goto _L___0;
        } else
#line 423
        if ((cnt & 8) == 0) {
          _L___0: /* CIL Label */ 
#line 428
          dir = (char *)((void *)0);
#line 430
          while (1) {
#line 430
            dir = argz_next__((char *)dirlist, dirlist_len, (char const   *)dir);
#line 430
            if (! ((unsigned long )dir != (unsigned long )((void *)0))) {
#line 430
              break;
            }
#line 432
            tmp___34 = entries;
#line 432
            entries ++;
#line 432
            tmp___35 = strlen((char const   *)dir);
#line 432
            retval->successor[tmp___34] = _nl_make_l10nflist(l10nfile_list, (char const   *)dir,
                                                             tmp___35 + 1UL, cnt,
                                                             language, territory,
                                                             codeset, normalized_codeset,
                                                             modifier, special, sponsor,
                                                             revision, filename, 1);
          }
        }
      }
    }
#line 422
    cnt --;
  }
#line 438
  retval->successor[entries] = (struct loaded_l10nfile *)((void *)0);
#line 440
  return (retval);
}
}
#line 446 "gettext.c"
static char const   *_nl_normalize_codeset(unsigned char const   *codeset , size_t name_len ) 
{ 
  int len ;
  int only_digit ;
  char *retval ;
  char *wp ;
  size_t cnt ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
#line 451
  len = 0;
#line 452
  only_digit = 1;
#line 457
  cnt = (size_t )0;
#line 457
  while (cnt < name_len) {
#line 458
    tmp___0 = __ctype_b_loc();
#line 458
    if ((int const   )*(*tmp___0 + (int )*(codeset + cnt)) & 8) {
#line 460
      len ++;
#line 462
      tmp = __ctype_b_loc();
#line 462
      if ((int const   )*(*tmp + (int )*(codeset + cnt)) & 1024) {
#line 463
        only_digit = 0;
      }
    }
#line 457
    cnt ++;
  }
#line 466
  if (only_digit) {
#line 466
    tmp___1 = 3;
  } else {
#line 466
    tmp___1 = 0;
  }
#line 466
  tmp___2 = malloc((size_t )((tmp___1 + len) + 1));
#line 466
  retval = (char *)tmp___2;
#line 468
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 470
    if (only_digit) {
#line 471
      wp = stpcpy((char * __restrict  )retval, (char const   * __restrict  )"iso");
    } else {
#line 473
      wp = retval;
    }
#line 475
    cnt = (size_t )0;
#line 475
    while (cnt < name_len) {
#line 476
      tmp___7 = __ctype_b_loc();
#line 476
      if ((int const   )*(*tmp___7 + (int )*(codeset + cnt)) & 1024) {
#line 477
        tmp___3 = wp;
#line 477
        wp ++;
#line 477
        tmp___4 = tolower((int )*(codeset + cnt));
#line 477
        *tmp___3 = (char )tmp___4;
      } else {
#line 478
        tmp___6 = __ctype_b_loc();
#line 478
        if ((int const   )*(*tmp___6 + (int )*(codeset + cnt)) & 2048) {
#line 479
          tmp___5 = wp;
#line 479
          wp ++;
#line 479
          *tmp___5 = (char )*(codeset + cnt);
        }
      }
#line 475
      cnt ++;
    }
#line 481
    *wp = (char )'\000';
  }
#line 484
  return ((char const   *)retval);
}
}
#line 501 "gettext.c"
static int _nl_explode_name(char *name , char const   **language , char const   **modifier ,
                            char const   **territory , char const   **codeset , char const   **normalized_codeset ,
                            char const   **special , char const   **sponsor , char const   **revision ) 
{ 
  enum __anonenum_syntax_21 syntax ;
  char *cp ;
  int mask ;
  int tmp ;

  {
#line 518
  *modifier = (char const   *)((void *)0);
#line 519
  *territory = (char const   *)((void *)0);
#line 520
  *codeset = (char const   *)((void *)0);
#line 521
  *normalized_codeset = (char const   *)((void *)0);
#line 522
  *special = (char const   *)((void *)0);
#line 523
  *sponsor = (char const   *)((void *)0);
#line 524
  *revision = (char const   *)((void *)0);
#line 529
  mask = 0;
#line 530
  syntax = (enum __anonenum_syntax_21 )0;
#line 531
  cp = name;
#line 531
  *language = (char const   *)cp;
#line 532
  while (1) {
#line 532
    if ((int )*(cp + 0) != 0) {
#line 532
      if ((int )*(cp + 0) != 95) {
#line 532
        if ((int )*(cp + 0) != 64) {
#line 532
          if ((int )*(cp + 0) != 43) {
#line 532
            if (! ((int )*(cp + 0) != 44)) {
#line 532
              break;
            }
          } else {
#line 532
            break;
          }
        } else {
#line 532
          break;
        }
      } else {
#line 532
        break;
      }
    } else {
#line 532
      break;
    }
#line 534
    cp ++;
  }
#line 536
  if ((unsigned long )*language == (unsigned long )cp) {
#line 539
    cp = strchr(*language, '\000');
  } else
#line 540
  if ((int )*(cp + 0) == 95) {
#line 543
    *(cp + 0) = (char )'\000';
#line 544
    cp ++;
#line 544
    *territory = (char const   *)cp;
#line 546
    while (1) {
#line 546
      if ((int )*(cp + 0) != 0) {
#line 546
        if ((int )*(cp + 0) != 46) {
#line 546
          if ((int )*(cp + 0) != 64) {
#line 546
            if ((int )*(cp + 0) != 43) {
#line 546
              if ((int )*(cp + 0) != 44) {
#line 546
                if (! ((int )*(cp + 0) != 95)) {
#line 546
                  break;
                }
              } else {
#line 546
                break;
              }
            } else {
#line 546
              break;
            }
          } else {
#line 546
            break;
          }
        } else {
#line 546
          break;
        }
      } else {
#line 546
        break;
      }
#line 548
      cp ++;
    }
#line 550
    mask |= 32;
#line 552
    if ((int )*(cp + 0) == 46) {
#line 555
      syntax = (enum __anonenum_syntax_21 )1;
#line 556
      *(cp + 0) = (char )'\000';
#line 557
      cp ++;
#line 557
      *codeset = (char const   *)cp;
#line 559
      while (1) {
#line 559
        if ((int )*(cp + 0) != 0) {
#line 559
          if (! ((int )*(cp + 0) != 64)) {
#line 559
            break;
          }
        } else {
#line 559
          break;
        }
#line 560
        cp ++;
      }
#line 562
      mask |= 16;
#line 564
      if ((unsigned long )*codeset != (unsigned long )cp) {
#line 564
        if ((int const   )*(*codeset + 0) != 0) {
#line 566
          *normalized_codeset = _nl_normalize_codeset((unsigned char const   *)*codeset,
                                                      (size_t )(cp - (char *)*codeset));
#line 569
          tmp = strcmp(*codeset, *normalized_codeset);
#line 569
          if (tmp == 0) {
#line 570
            free((void *)((char *)*normalized_codeset));
          } else {
#line 572
            mask |= 8;
          }
        }
      }
    }
  }
#line 577
  if ((int )*(cp + 0) == 64) {
#line 577
    goto _L;
  } else
#line 577
  if ((unsigned int )syntax != 1U) {
#line 577
    if ((int )*(cp + 0) == 43) {
      _L: /* CIL Label */ 
#line 580
      if ((int )*(cp + 0) == 64) {
#line 580
        syntax = (enum __anonenum_syntax_21 )1;
      } else {
#line 580
        syntax = (enum __anonenum_syntax_21 )2;
      }
#line 581
      *(cp + 0) = (char )'\000';
#line 582
      cp ++;
#line 582
      *modifier = (char const   *)cp;
#line 584
      while (1) {
#line 584
        if ((unsigned int )syntax == 2U) {
#line 584
          if ((int )*(cp + 0) != 0) {
#line 584
            if ((int )*(cp + 0) != 43) {
#line 584
              if ((int )*(cp + 0) != 44) {
#line 584
                if (! ((int )*(cp + 0) != 95)) {
#line 584
                  break;
                }
              } else {
#line 584
                break;
              }
            } else {
#line 584
              break;
            }
          } else {
#line 584
            break;
          }
        } else {
#line 584
          break;
        }
#line 586
        cp ++;
      }
#line 588
      mask |= 192;
    }
  }
#line 591
  if ((unsigned int )syntax != 1U) {
#line 591
    if ((int )*(cp + 0) == 43) {
#line 591
      goto _L___0;
    } else
#line 591
    if ((int )*(cp + 0) == 44) {
#line 591
      goto _L___0;
    } else
#line 591
    if ((int )*(cp + 0) == 95) {
      _L___0: /* CIL Label */ 
#line 593
      syntax = (enum __anonenum_syntax_21 )2;
#line 595
      if ((int )*(cp + 0) == 43) {
#line 598
        *(cp + 0) = (char )'\000';
#line 599
        cp ++;
#line 599
        *special = (char const   *)cp;
#line 601
        while (1) {
#line 601
          if ((int )*(cp + 0) != 0) {
#line 601
            if ((int )*(cp + 0) != 44) {
#line 601
              if (! ((int )*(cp + 0) != 95)) {
#line 601
                break;
              }
            } else {
#line 601
              break;
            }
          } else {
#line 601
            break;
          }
#line 602
          cp ++;
        }
#line 604
        mask |= 4;
      }
#line 607
      if ((int )*(cp + 0) == 44) {
#line 610
        *(cp + 0) = (char )'\000';
#line 611
        cp ++;
#line 611
        *sponsor = (char const   *)cp;
#line 613
        while (1) {
#line 613
          if ((int )*(cp + 0) != 0) {
#line 613
            if (! ((int )*(cp + 0) != 95)) {
#line 613
              break;
            }
          } else {
#line 613
            break;
          }
#line 614
          cp ++;
        }
#line 616
        mask |= 2;
      }
#line 619
      if ((int )*(cp + 0) == 95) {
#line 622
        *(cp + 0) = (char )'\000';
#line 623
        cp ++;
#line 623
        *revision = (char const   *)cp;
#line 625
        mask |= 1;
      }
    }
  }
#line 631
  if ((unsigned int )syntax == 1U) {
#line 633
    if ((unsigned long )*territory != (unsigned long )((void *)0)) {
#line 633
      if ((int const   )*(*territory + 0) == 0) {
#line 634
        mask &= -33;
      }
    }
#line 636
    if ((unsigned long )*codeset != (unsigned long )((void *)0)) {
#line 636
      if ((int const   )*(*codeset + 0) == 0) {
#line 637
        mask &= -17;
      }
    }
#line 639
    if ((unsigned long )*modifier != (unsigned long )((void *)0)) {
#line 639
      if ((int const   )*(*modifier + 0) == 0) {
#line 640
        mask &= -129;
      }
    }
  }
#line 643
  return (mask);
}
}
#line 792
__inline static nls_uint32 SWAP(nls_uint32 i ) ;
#line 794 "gettext.c"
__inline static nls_uint32 SWAP(nls_uint32 i ) 
{ 


  {
#line 798
  return ((((i << 24) | ((i & 65280U) << 8)) | ((i >> 8) & 65280U)) | (i >> 24));
}
}
#line 851 "gettext.c"
int _nl_msg_cat_cntr  =    0;
#line 855 "gettext.c"
static void _nl_load_domain(struct loaded_l10nfile *domain_file ) 
{ 
  int fd ;
  size_t size ;
  struct stat st ;
  struct mo_file_header *data ;
  struct loaded_domain *domain ;
  int tmp ;
  size_t to_read ;
  char *read_ptr ;
  void *tmp___0 ;
  long nb ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  nls_uint32 tmp___3 ;
  nls_uint32 tmp___4 ;
  nls_uint32 tmp___5 ;
  nls_uint32 tmp___6 ;
  nls_uint32 tmp___7 ;
  nls_uint32 tmp___8 ;
  nls_uint32 tmp___9 ;
  nls_uint32 tmp___10 ;
  nls_uint32 tmp___11 ;
  nls_uint32 tmp___12 ;

  {
#line 863
  data = (struct mo_file_header *)-1;
#line 870
  domain_file->decided = 1;
#line 871
  domain_file->data = (void const   *)((void *)0);
#line 877
  if ((unsigned long )domain_file->filename == (unsigned long )((void *)0)) {
#line 878
    return;
  }
#line 881
  fd = open(domain_file->filename, 0);
#line 882
  if (fd == -1) {
#line 883
    return;
  }
#line 886
  tmp = fstat(fd, & st);
#line 886
  if (tmp != 0) {
#line 891
    close(fd);
#line 892
    return;
  } else {
#line 886
    size = (size_t )st.st_size;
#line 886
    if (size != (size_t )st.st_size) {
#line 891
      close(fd);
#line 892
      return;
    } else
#line 886
    if (size < sizeof(struct mo_file_header )) {
#line 891
      close(fd);
#line 892
      return;
    }
  }
#line 912
  if ((unsigned long )data == (unsigned long )((struct mo_file_header *)-1)) {
#line 917
    tmp___0 = malloc(size);
#line 917
    data = (struct mo_file_header *)tmp___0;
#line 918
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 919
      return;
    }
#line 921
    to_read = size;
#line 922
    read_ptr = (char *)data;
#line 923
    while (1) {
#line 925
      tmp___1 = read(fd, (void *)read_ptr, to_read);
#line 925
      nb = tmp___1;
#line 926
      if (nb == -1L) {
#line 928
        close(fd);
#line 929
        return;
      }
#line 932
      read_ptr += nb;
#line 933
      to_read -= (size_t )nb;
#line 923
      if (! (to_read > 0UL)) {
#line 923
        break;
      }
    }
#line 937
    close(fd);
  }
#line 942
  if (data->magic != 2500072158U) {
#line 942
    if (data->magic != 3725722773U) {
#line 951
      free((void *)data);
#line 952
      return;
    }
  }
#line 955
  tmp___2 = malloc(sizeof(struct loaded_domain ));
#line 955
  domain_file->data = (void const   *)((struct loaded_domain *)tmp___2);
#line 957
  if ((unsigned long )domain_file->data == (unsigned long )((void *)0)) {
#line 958
    return;
  }
#line 960
  domain = (struct loaded_domain *)domain_file->data;
#line 961
  domain->data = (char const   *)((char *)data);
#line 966
  domain->mmap_size = size;
#line 967
  domain->must_swap = data->magic != 2500072158U;
#line 970
  if (domain->must_swap) {
#line 970
    tmp___3 = SWAP(data->revision);
#line 970
    tmp___4 = tmp___3;
  } else {
#line 970
    tmp___4 = data->revision;
  }
#line 970
  switch (tmp___4) {
  case 0U: 
#line 973
  if (domain->must_swap) {
#line 973
    tmp___5 = SWAP(data->nstrings);
#line 973
    domain->nstrings = tmp___5;
  } else {
#line 973
    domain->nstrings = data->nstrings;
  }
#line 974
  if (domain->must_swap) {
#line 974
    tmp___6 = SWAP(data->orig_tab_offset);
#line 974
    tmp___7 = tmp___6;
  } else {
#line 974
    tmp___7 = data->orig_tab_offset;
  }
#line 974
  domain->orig_tab = (struct string_desc *)((char *)data + tmp___7);
#line 976
  if (domain->must_swap) {
#line 976
    tmp___8 = SWAP(data->trans_tab_offset);
#line 976
    tmp___9 = tmp___8;
  } else {
#line 976
    tmp___9 = data->trans_tab_offset;
  }
#line 976
  domain->trans_tab = (struct string_desc *)((char *)data + tmp___9);
#line 978
  if (domain->must_swap) {
#line 978
    tmp___10 = SWAP(data->hash_tab_size);
#line 978
    domain->hash_size = tmp___10;
  } else {
#line 978
    domain->hash_size = data->hash_tab_size;
  }
#line 979
  if (domain->must_swap) {
#line 979
    tmp___11 = SWAP(data->hash_tab_offset);
#line 979
    tmp___12 = tmp___11;
  } else {
#line 979
    tmp___12 = data->hash_tab_offset;
  }
#line 979
  domain->hash_tab = (nls_uint32 *)((char *)data + tmp___12);
#line 981
  break;
  default: 
#line 990
  free((void *)data);
#line 991
  free((void *)domain);
#line 992
  domain_file->data = (void const   *)((void *)0);
#line 993
  return;
  }
#line 998
  _nl_msg_cat_cntr ++;
#line 999
  return;
}
}
#line 1105 "gettext.c"
static char *string_space  =    (char *)((void *)0);
#line 1106 "gettext.c"
static size_t string_space_act  =    (size_t )0;
#line 1107 "gettext.c"
static size_t string_space_max  =    (size_t )0;
#line 1108 "gettext.c"
static struct alias_map *map  ;
#line 1109 "gettext.c"
static size_t nmap  =    (size_t )0;
#line 1110 "gettext.c"
static size_t maxmap  =    (size_t )0;
#line 1113
static size_t read_alias_file(char const   *fname , int fname_len ) ;
#line 1115
static void extend_alias_table(void) ;
#line 1116
static int alias_compare(struct alias_map  const  *map1 , struct alias_map  const  *map2 ) ;
#line 1123 "gettext.c"
static char const   *locale_alias_path  =    "/usr/local/share/locale:.";
#line 1119 "gettext.c"
static char const   *_nl_expand_alias(char const   *name ) 
{ 
  struct alias_map *retval ;
  char const   *result___0 ;
  size_t added ;
  struct alias_map item ;
  void *tmp ;
  char const   *start ;

  {
#line 1125
  result___0 = (char const   *)((void *)0);
#line 1132
  while (1) {
#line 1136
    item.alias = name;
#line 1138
    if (nmap > 0UL) {
#line 1139
      tmp = bsearch((void const   *)(& item), (void const   *)map, nmap, sizeof(struct alias_map ),
                    (int (*)(void const   * , void const   * ))(& alias_compare));
#line 1139
      retval = (struct alias_map *)tmp;
    } else {
#line 1145
      retval = (struct alias_map *)((void *)0);
    }
#line 1148
    if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 1150
      result___0 = retval->value;
#line 1151
      break;
    }
#line 1155
    added = (size_t )0;
#line 1156
    while (1) {
#line 1156
      if (added == 0UL) {
#line 1156
        if (! ((int const   )*(locale_alias_path + 0) != 0)) {
#line 1156
          break;
        }
      } else {
#line 1156
        break;
      }
#line 1160
      while ((int const   )*(locale_alias_path + 0) == 58) {
#line 1161
        locale_alias_path ++;
      }
#line 1162
      start = locale_alias_path;
#line 1164
      while (1) {
#line 1164
        if ((int const   )*(locale_alias_path + 0) != 0) {
#line 1164
          if (! ((int const   )*(locale_alias_path + 0) != 58)) {
#line 1164
            break;
          }
        } else {
#line 1164
          break;
        }
#line 1165
        locale_alias_path ++;
      }
#line 1167
      if ((unsigned long )start < (unsigned long )locale_alias_path) {
#line 1168
        added = read_alias_file(start, (int )(locale_alias_path - start));
      }
    }
#line 1132
    if (! (added != 0UL)) {
#line 1132
      break;
    }
  }
#line 1177
  return (result___0);
}
}
#line 1192 "gettext.c"
static char const   aliasfile[14]  = 
#line 1192
  {      (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'e',      (char const   )'.', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'a', 
        (char const   )'s',      (char const   )'\000'};
#line 1180 "gettext.c"
static size_t read_alias_file(char const   *fname , int fname_len ) 
{ 
  FILE *fp ;
  char *full_fname ;
  size_t added ;
  void *tmp ;
  unsigned char buf___1[8192] ;
  unsigned char *alias ;
  unsigned char *value ;
  unsigned char *cp ;
  char *tmp___0 ;
  char altbuf[8192] ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  size_t alias_len ;
  size_t value_len ;
  unsigned char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t new_size ;
  size_t tmp___15 ;
  char *new_pool ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;

  {
#line 1194
  tmp = __builtin_alloca((unsigned long )fname_len + sizeof(aliasfile));
#line 1194
  full_fname = (char *)tmp;
#line 1200
  memcpy((void * __restrict  )full_fname, (void const   * __restrict  )fname, (size_t )fname_len);
#line 1201
  memcpy((void * __restrict  )(full_fname + fname_len), (void const   * __restrict  )(aliasfile),
         sizeof(aliasfile));
#line 1204
  fp = fopen((char const   * __restrict  )full_fname, (char const   * __restrict  )"r");
#line 1205
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1208
    return ((size_t )0);
  }
#line 1211
  added = (size_t )0;
#line 1212
  while (1) {
#line 1212
    tmp___19 = feof(fp);
#line 1212
    if (tmp___19) {
#line 1212
      break;
    }
#line 1224
    tmp___0 = fgets((char * __restrict  )((char *)(buf___1)), (int )sizeof(buf___1),
                    (FILE * __restrict  )fp);
#line 1224
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 1226
      break;
    }
#line 1230
    tmp___3 = strchr((char const   *)((char *)(buf___1)), '\n');
#line 1230
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 1233
      while (1) {
#line 1234
        tmp___1 = fgets((char * __restrict  )(altbuf), (int )sizeof(altbuf), (FILE * __restrict  )fp);
#line 1234
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1237
          break;
        }
#line 1233
        tmp___2 = strchr((char const   *)(altbuf), '\n');
#line 1233
        if (! ((unsigned long )tmp___2 == (unsigned long )((void *)0))) {
#line 1233
          break;
        }
      }
    }
#line 1241
    cp = buf___1;
#line 1243
    while (1) {
#line 1243
      tmp___4 = __ctype_b_loc();
#line 1243
      if (! ((int const   )*(*tmp___4 + (int )*(cp + 0)) & 8192)) {
#line 1243
        break;
      }
#line 1244
      cp ++;
    }
#line 1247
    if ((int )*(cp + 0) != 0) {
#line 1247
      if ((int )*(cp + 0) != 35) {
#line 1249
        tmp___5 = cp;
#line 1249
        cp ++;
#line 1249
        alias = tmp___5;
#line 1250
        while (1) {
#line 1250
          if ((int )*(cp + 0) != 0) {
#line 1250
            tmp___6 = __ctype_b_loc();
#line 1250
            if ((int const   )*(*tmp___6 + (int )*(cp + 0)) & 8192) {
#line 1250
              break;
            }
          } else {
#line 1250
            break;
          }
#line 1251
          cp ++;
        }
#line 1253
        if ((int )*(cp + 0) != 0) {
#line 1254
          tmp___7 = cp;
#line 1254
          cp ++;
#line 1254
          *tmp___7 = (unsigned char )'\000';
        }
#line 1257
        while (1) {
#line 1257
          tmp___8 = __ctype_b_loc();
#line 1257
          if (! ((int const   )*(*tmp___8 + (int )*(cp + 0)) & 8192)) {
#line 1257
            break;
          }
#line 1258
          cp ++;
        }
#line 1260
        if ((int )*(cp + 0) != 0) {
#line 1265
          tmp___9 = cp;
#line 1265
          cp ++;
#line 1265
          value = tmp___9;
#line 1266
          while (1) {
#line 1266
            if ((int )*(cp + 0) != 0) {
#line 1266
              tmp___10 = __ctype_b_loc();
#line 1266
              if ((int const   )*(*tmp___10 + (int )*(cp + 0)) & 8192) {
#line 1266
                break;
              }
            } else {
#line 1266
              break;
            }
#line 1267
            cp ++;
          }
#line 1269
          if ((int )*(cp + 0) == 10) {
#line 1274
            tmp___11 = cp;
#line 1274
            cp ++;
#line 1274
            *tmp___11 = (unsigned char )'\000';
#line 1275
            *cp = (unsigned char )'\n';
          } else
#line 1277
          if ((int )*(cp + 0) != 0) {
#line 1278
            tmp___12 = cp;
#line 1278
            cp ++;
#line 1278
            *tmp___12 = (unsigned char )'\000';
          }
#line 1280
          if (nmap >= maxmap) {
#line 1281
            extend_alias_table();
          }
#line 1283
          tmp___13 = strlen((char const   *)((char *)alias));
#line 1283
          alias_len = tmp___13 + 1UL;
#line 1284
          tmp___14 = strlen((char const   *)((char *)value));
#line 1284
          value_len = tmp___14 + 1UL;
#line 1286
          if ((string_space_act + alias_len) + value_len > string_space_max) {
#line 1289
            if (alias_len + value_len > 1024UL) {
#line 1289
              tmp___15 = alias_len + value_len;
            } else {
#line 1289
              tmp___15 = (size_t )1024;
            }
#line 1289
            new_size = string_space_max + tmp___15;
#line 1292
            tmp___16 = realloc((void *)string_space, new_size);
#line 1292
            new_pool = (char *)tmp___16;
#line 1293
            if ((unsigned long )new_pool == (unsigned long )((void *)0)) {
#line 1296
              return (added);
            }
#line 1298
            string_space = new_pool;
#line 1299
            string_space_max = new_size;
          }
#line 1302
          tmp___17 = memcpy((void * __restrict  )(string_space + string_space_act),
                            (void const   * __restrict  )alias, alias_len);
#line 1302
          (map + nmap)->alias = (char const   *)tmp___17;
#line 1304
          string_space_act += alias_len;
#line 1306
          tmp___18 = memcpy((void * __restrict  )(string_space + string_space_act),
                            (void const   * __restrict  )value, value_len);
#line 1306
          (map + nmap)->value = (char const   *)tmp___18;
#line 1308
          string_space_act += value_len;
#line 1310
          nmap ++;
#line 1311
          added ++;
        }
      }
    }
  }
#line 1318
  fclose(fp);
#line 1320
  if (added > 0UL) {
#line 1321
    qsort((void *)map, nmap, sizeof(struct alias_map ), (int (*)(void const   * ,
                                                                 void const   * ))(& alias_compare));
  }
#line 1325
  return (added);
}
}
#line 1328 "gettext.c"
static void extend_alias_table(void) 
{ 
  size_t new_size ;
  struct alias_map *new_map ;
  void *tmp ;

  {
#line 1334
  if (maxmap == 0UL) {
#line 1334
    new_size = (size_t )100;
  } else {
#line 1334
    new_size = 2UL * maxmap;
  }
#line 1335
  tmp = realloc((void *)map, new_size * sizeof(struct alias_map ));
#line 1335
  new_map = (struct alias_map *)tmp;
#line 1337
  if ((unsigned long )new_map == (unsigned long )((void *)0)) {
#line 1339
    return;
  }
#line 1341
  map = new_map;
#line 1342
  maxmap = new_size;
#line 1343
  return;
}
}
#line 1357 "gettext.c"
static int alias_compare(struct alias_map  const  *map1 , struct alias_map  const  *map2 ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 1365
  p1 = (unsigned char const   *)map1->alias;
#line 1366
  p2 = (unsigned char const   *)map2->alias;
#line 1369
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 1370
    return (0);
  }
#line 1372
  while (1) {
#line 1376
    tmp___1 = __ctype_b_loc();
#line 1376
    if ((int const   )*(*tmp___1 + (int )*p1) & 256) {
#line 1376
      tmp___0 = tolower((int )*p1);
#line 1376
      c1 = (unsigned char )tmp___0;
    } else {
#line 1376
      c1 = (unsigned char )*p1;
    }
#line 1377
    tmp___4 = __ctype_b_loc();
#line 1377
    if ((int const   )*(*tmp___4 + (int )*p2) & 256) {
#line 1377
      tmp___3 = tolower((int )*p2);
#line 1377
      c2 = (unsigned char )tmp___3;
    } else {
#line 1377
      c2 = (unsigned char )*p2;
    }
#line 1378
    if ((int )c1 == 0) {
#line 1379
      break;
    }
#line 1380
    p1 ++;
#line 1381
    p2 ++;
#line 1372
    if (! ((int )c1 == (int )c2)) {
#line 1372
      break;
    }
  }
#line 1385
  return ((int )c1 - (int )c2);
}
}
#line 90 "gettext.h"
char *gettext(char const   *msgid ) ;
#line 95
char *dgettext(char const   *domainname , char const   *msgid ) ;
#line 103
char *dcgettext__(char const   *domainname , char const   *msgid , int category ) ;
#line 1429 "gettext.c"
static struct loaded_l10nfile *_nl_loaded_domains  ;
#line 1434 "gettext.c"
static struct loaded_l10nfile *_nl_find_domain(char const   *dirname , char *locale ,
                                               char const   *domainname ) 
{ 
  struct loaded_l10nfile *retval ;
  char const   *language ;
  char const   *modifier ;
  char const   *territory ;
  char const   *codeset ;
  char const   *normalized_codeset ;
  char const   *special ;
  char const   *sponsor ;
  char const   *revision ;
  char const   *alias_value ;
  int mask ;
  size_t tmp ;
  int cnt ;
  struct loaded_l10nfile *tmp___0 ;
  size_t tmp___1 ;
  int cnt___0 ;

  {
#line 1476
  tmp = strlen(dirname);
#line 1476
  retval = _nl_make_l10nflist(& _nl_loaded_domains, dirname, tmp + 1UL, 0, (char const   *)locale,
                              (char const   *)((void *)0), (char const   *)((void *)0),
                              (char const   *)((void *)0), (char const   *)((void *)0),
                              (char const   *)((void *)0), (char const   *)((void *)0),
                              (char const   *)((void *)0), domainname, 0);
#line 1479
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 1484
    if (retval->decided == 0) {
#line 1485
      _nl_load_domain(retval);
    }
#line 1487
    if ((unsigned long )retval->data != (unsigned long )((void *)0)) {
#line 1488
      return (retval);
    }
#line 1490
    cnt = 0;
#line 1490
    while ((unsigned long )retval->successor[cnt] != (unsigned long )((void *)0)) {
#line 1492
      if ((retval->successor[cnt])->decided == 0) {
#line 1493
        _nl_load_domain(retval->successor[cnt]);
      }
#line 1495
      if ((unsigned long )(retval->successor[cnt])->data != (unsigned long )((void *)0)) {
#line 1496
        break;
      }
#line 1490
      cnt ++;
    }
#line 1498
    if (cnt >= 0) {
#line 1498
      tmp___0 = retval;
    } else {
#line 1498
      tmp___0 = (struct loaded_l10nfile *)((void *)0);
    }
#line 1498
    return (tmp___0);
  }
#line 1505
  alias_value = _nl_expand_alias((char const   *)locale);
#line 1506
  if ((unsigned long )alias_value != (unsigned long )((void *)0)) {
#line 1509
    locale = strdup(alias_value);
#line 1510
    if ((unsigned long )locale == (unsigned long )((void *)0)) {
#line 1511
      return ((struct loaded_l10nfile *)((void *)0));
    }
  }
#line 1525
  mask = _nl_explode_name(locale, & language, & modifier, & territory, & codeset,
                          & normalized_codeset, & special, & sponsor, & revision);
#line 1531
  tmp___1 = strlen(dirname);
#line 1531
  retval = _nl_make_l10nflist(& _nl_loaded_domains, dirname, tmp___1 + 1UL, mask,
                              language, territory, codeset, normalized_codeset, modifier,
                              special, sponsor, revision, domainname, 1);
#line 1535
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
#line 1537
    return ((struct loaded_l10nfile *)((void *)0));
  }
#line 1539
  if (retval->decided == 0) {
#line 1540
    _nl_load_domain(retval);
  }
#line 1541
  if ((unsigned long )retval->data == (unsigned long )((void *)0)) {
#line 1544
    cnt___0 = 0;
#line 1544
    while ((unsigned long )retval->successor[cnt___0] != (unsigned long )((void *)0)) {
#line 1546
      if ((retval->successor[cnt___0])->decided == 0) {
#line 1547
        _nl_load_domain(retval->successor[cnt___0]);
      }
#line 1548
      if ((unsigned long )(retval->successor[cnt___0])->data != (unsigned long )((void *)0)) {
#line 1549
        break;
      }
#line 1544
      cnt___0 ++;
    }
  }
#line 1554
  if ((unsigned long )alias_value != (unsigned long )((void *)0)) {
#line 1555
    free((void *)locale);
  }
#line 1557
  return (retval);
}
}
#line 1642
__inline static unsigned long hash_string(char const   *str_param ) ;
#line 1644 "gettext.c"
__inline static unsigned long hash_string(char const   *str_param ) 
{ 
  unsigned long hval ;
  unsigned long g ;
  char const   *str ;
  char const   *tmp ;

  {
#line 1649
  str = str_param;
#line 1652
  hval = 0UL;
#line 1653
  while ((int const   )*str != 0) {
#line 1655
    hval <<= 4;
#line 1656
    tmp = str;
#line 1656
    str ++;
#line 1656
    hval += (unsigned long )*tmp;
#line 1657
    g = hval & (15UL << 28);
#line 1658
    if (g != 0UL) {
#line 1660
      hval ^= g >> 24;
#line 1661
      hval ^= g;
    }
  }
#line 1664
  return (hval);
}
}
#line 1734 "gettext.c"
static char const   _nl_default_default_domain[9]  = 
#line 1734
  {      (char const   )'m',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000'};
#line 1737 "gettext.c"
static char const   *_nl_current_default_domain  =    _nl_default_default_domain;
#line 1740 "gettext.c"
static char const   _nl_default_dirname[24]  = 
#line 1740
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'s', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'e',      (char const   )'\000'};
#line 1744 "gettext.c"
static struct binding *_nl_domain_bindings  ;
#line 1747
static char *find_msg(struct loaded_l10nfile *domain_file , char const   *msgid ) ;
#line 1749
static char const   *category_to_name(int category ) ;
#line 1750
static char const   *guess_category_value(int category , char const   *categoryname ) ;
#line 1766 "gettext.c"
char *dcgettext__(char const   *domainname , char const   *msgid , int category ) 
{ 
  struct loaded_l10nfile *domain ;
  struct binding *binding ;
  char const   *categoryname ;
  char const   *categoryvalue ;
  char *dirname ;
  char *xdomainname ;
  char *single_locale ;
  char *retval ;
  int saved_errno ;
  int *tmp ;
  int compare ;
  int tmp___0 ;
  size_t dirname_len ;
  size_t tmp___1 ;
  size_t path_max ;
  char *ret ;
  void *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  char *cp ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int cnt ;
  int *tmp___23 ;

  {
#line 1782
  tmp = __errno_location();
#line 1782
  saved_errno = *tmp;
#line 1785
  if ((unsigned long )msgid == (unsigned long )((void *)0)) {
#line 1786
    return ((char *)((void *)0));
  }
#line 1791
  if ((unsigned long )domainname == (unsigned long )((void *)0)) {
#line 1792
    domainname = _nl_current_default_domain;
  }
#line 1795
  binding = _nl_domain_bindings;
#line 1795
  while ((unsigned long )binding != (unsigned long )((void *)0)) {
#line 1797
    tmp___0 = strcmp(domainname, (char const   *)binding->domainname);
#line 1797
    compare = tmp___0;
#line 1798
    if (compare == 0) {
#line 1800
      break;
    }
#line 1801
    if (compare < 0) {
#line 1804
      binding = (struct binding *)((void *)0);
#line 1805
      break;
    }
#line 1795
    binding = binding->next;
  }
#line 1809
  if ((unsigned long )binding == (unsigned long )((void *)0)) {
#line 1810
    dirname = (char *)(_nl_default_dirname);
  } else
#line 1811
  if ((int )*(binding->dirname + 0) == 47) {
#line 1812
    dirname = binding->dirname;
  } else {
#line 1816
    tmp___1 = strlen((char const   *)binding->dirname);
#line 1816
    dirname_len = tmp___1 + 1UL;
#line 1820
    path_max = (size_t )4096U;
#line 1821
    path_max += 2UL;
#line 1823
    tmp___2 = __builtin_alloca(path_max + dirname_len);
#line 1823
    dirname = (char *)tmp___2;
#line 1826
    tmp___3 = __errno_location();
#line 1826
    *tmp___3 = 0;
#line 1827
    while (1) {
#line 1827
      ret = getcwd(dirname, path_max);
#line 1827
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1827
        tmp___6 = __errno_location();
#line 1827
        if (! (*tmp___6 == 34)) {
#line 1827
          break;
        }
      } else {
#line 1827
        break;
      }
#line 1829
      path_max += 32UL;
#line 1830
      tmp___4 = __builtin_alloca(path_max + dirname_len);
#line 1830
      dirname = (char *)tmp___4;
#line 1832
      tmp___5 = __errno_location();
#line 1832
      *tmp___5 = 0;
    }
#line 1835
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1840
      tmp___7 = __errno_location();
#line 1840
      *tmp___7 = saved_errno;
#line 1841
      return ((char *)msgid);
    }
#line 1844
    tmp___8 = strchr((char const   *)dirname, '\000');
#line 1844
    tmp___9 = stpcpy((char * __restrict  )tmp___8, (char const   * __restrict  )"/");
#line 1844
    stpcpy((char * __restrict  )tmp___9, (char const   * __restrict  )binding->dirname);
  }
#line 1848
  categoryname = category_to_name(category);
#line 1849
  categoryvalue = guess_category_value(category, categoryname);
#line 1851
  tmp___10 = strlen(categoryname);
#line 1851
  tmp___11 = strlen(domainname);
#line 1851
  tmp___12 = __builtin_alloca((tmp___10 + tmp___11) + 5UL);
#line 1851
  xdomainname = (char *)tmp___12;
#line 1855
  tmp___13 = stpcpy((char * __restrict  )xdomainname, (char const   * __restrict  )categoryname);
#line 1855
  tmp___14 = stpcpy((char * __restrict  )tmp___13, (char const   * __restrict  )"/");
#line 1855
  tmp___15 = stpcpy((char * __restrict  )tmp___14, (char const   * __restrict  )domainname);
#line 1855
  stpcpy((char * __restrict  )tmp___15, (char const   * __restrict  )".mo");
#line 1860
  tmp___16 = strlen(categoryvalue);
#line 1860
  tmp___17 = __builtin_alloca(tmp___16 + 1UL);
#line 1860
  single_locale = (char *)tmp___17;
#line 1865
  while (1) {
#line 1868
    while (1) {
#line 1868
      if ((int const   )*(categoryvalue + 0) != 0) {
#line 1868
        if (! ((int const   )*(categoryvalue + 0) == 58)) {
#line 1868
          break;
        }
      } else {
#line 1868
        break;
      }
#line 1869
      categoryvalue ++;
    }
#line 1870
    if ((int const   )*(categoryvalue + 0) == 0) {
#line 1876
      *(single_locale + 0) = (char )'C';
#line 1877
      *(single_locale + 1) = (char )'\000';
    } else {
#line 1881
      cp = single_locale;
#line 1882
      while (1) {
#line 1882
        if ((int const   )*(categoryvalue + 0) != 0) {
#line 1882
          if (! ((int const   )*(categoryvalue + 0) != 58)) {
#line 1882
            break;
          }
        } else {
#line 1882
          break;
        }
#line 1883
        tmp___18 = cp;
#line 1883
        cp ++;
#line 1883
        tmp___19 = categoryvalue;
#line 1883
        categoryvalue ++;
#line 1883
        *tmp___18 = (char )*tmp___19;
      }
#line 1884
      *cp = (char )'\000';
    }
#line 1889
    tmp___21 = strcmp((char const   *)single_locale, "C");
#line 1889
    if (tmp___21 == 0) {
#line 1893
      tmp___20 = __errno_location();
#line 1893
      *tmp___20 = saved_errno;
#line 1894
      return ((char *)msgid);
    } else {
#line 1889
      tmp___22 = strcmp((char const   *)single_locale, "POSIX");
#line 1889
      if (tmp___22 == 0) {
#line 1893
        tmp___20 = __errno_location();
#line 1893
        *tmp___20 = saved_errno;
#line 1894
        return ((char *)msgid);
      }
    }
#line 1899
    domain = _nl_find_domain((char const   *)dirname, single_locale, (char const   *)xdomainname);
#line 1901
    if ((unsigned long )domain != (unsigned long )((void *)0)) {
#line 1903
      retval = find_msg(domain, msgid);
#line 1905
      if ((unsigned long )retval == (unsigned long )((void *)0)) {
#line 1909
        cnt = 0;
#line 1909
        while ((unsigned long )domain->successor[cnt] != (unsigned long )((void *)0)) {
#line 1911
          retval = find_msg(domain->successor[cnt], msgid);
#line 1913
          if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 1914
            break;
          }
#line 1909
          cnt ++;
        }
      }
#line 1918
      if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 1921
        tmp___23 = __errno_location();
#line 1921
        *tmp___23 = saved_errno;
#line 1922
        return (retval);
      }
    }
  }
}
}
#line 1933 "gettext.c"
static char *find_msg(struct loaded_l10nfile *domain_file , char const   *msgid ) 
{ 
  size_t top ;
  size_t act ;
  size_t bottom ;
  struct loaded_domain *domain ;
  nls_uint32 len ;
  size_t tmp ;
  nls_uint32 hash_val ;
  unsigned long tmp___0 ;
  nls_uint32 idx ;
  nls_uint32 incr ;
  nls_uint32 nstr ;
  nls_uint32 tmp___1 ;
  nls_uint32 tmp___2 ;
  nls_uint32 tmp___3 ;
  nls_uint32 tmp___4 ;
  nls_uint32 tmp___5 ;
  nls_uint32 tmp___6 ;
  nls_uint32 tmp___7 ;
  nls_uint32 tmp___8 ;
  int tmp___9 ;
  nls_uint32 tmp___10 ;
  nls_uint32 tmp___11 ;
  nls_uint32 tmp___12 ;
  nls_uint32 tmp___13 ;
  nls_uint32 tmp___14 ;
  nls_uint32 tmp___15 ;
  nls_uint32 tmp___16 ;
  int tmp___17 ;
  int cmp_val ;
  nls_uint32 tmp___18 ;
  nls_uint32 tmp___19 ;
  nls_uint32 tmp___20 ;
  nls_uint32 tmp___21 ;
  char *tmp___22 ;

  {
#line 1942
  if (domain_file->decided == 0) {
#line 1943
    _nl_load_domain(domain_file);
  }
#line 1945
  if ((unsigned long )domain_file->data == (unsigned long )((void *)0)) {
#line 1946
    return ((char *)((void *)0));
  }
#line 1948
  domain = (struct loaded_domain *)domain_file->data;
#line 1951
  if (domain->hash_size > 2U) {
#line 1951
    if ((unsigned long )domain->hash_tab != (unsigned long )((void *)0)) {
#line 1954
      tmp = strlen(msgid);
#line 1954
      len = (nls_uint32 )tmp;
#line 1955
      tmp___0 = hash_string(msgid);
#line 1955
      hash_val = (nls_uint32 )tmp___0;
#line 1956
      idx = hash_val % domain->hash_size;
#line 1957
      incr = 1U + hash_val % (domain->hash_size - 2U);
#line 1958
      if (domain->must_swap) {
#line 1958
        tmp___1 = SWAP(*(domain->hash_tab + idx));
#line 1958
        tmp___2 = tmp___1;
      } else {
#line 1958
        tmp___2 = *(domain->hash_tab + idx);
      }
#line 1958
      nstr = tmp___2;
#line 1960
      if (nstr == 0U) {
#line 1962
        return ((char *)((void *)0));
      }
#line 1964
      if (domain->must_swap) {
#line 1964
        tmp___5 = SWAP((domain->orig_tab + (nstr - 1U))->length);
#line 1964
        tmp___6 = tmp___5;
      } else {
#line 1964
        tmp___6 = (domain->orig_tab + (nstr - 1U))->length;
      }
#line 1964
      if (tmp___6 == len) {
#line 1964
        if (domain->must_swap) {
#line 1964
          tmp___7 = SWAP((domain->orig_tab + (nstr - 1U))->offset);
#line 1964
          tmp___8 = tmp___7;
        } else {
#line 1964
          tmp___8 = (domain->orig_tab + (nstr - 1U))->offset;
        }
#line 1964
        tmp___9 = strcmp(msgid, domain->data + tmp___8);
#line 1964
        if (tmp___9 == 0) {
#line 1968
          if (domain->must_swap) {
#line 1968
            tmp___3 = SWAP((domain->trans_tab + (nstr - 1U))->offset);
#line 1968
            tmp___4 = tmp___3;
          } else {
#line 1968
            tmp___4 = (domain->trans_tab + (nstr - 1U))->offset;
          }
#line 1968
          return ((char *)domain->data + tmp___4);
        }
      }
#line 1971
      while (1) {
#line 1973
        if (idx >= domain->hash_size - incr) {
#line 1974
          idx -= domain->hash_size - incr;
        } else {
#line 1976
          idx += incr;
        }
#line 1978
        if (domain->must_swap) {
#line 1978
          tmp___10 = SWAP(*(domain->hash_tab + idx));
#line 1978
          nstr = tmp___10;
        } else {
#line 1978
          nstr = *(domain->hash_tab + idx);
        }
#line 1979
        if (nstr == 0U) {
#line 1981
          return ((char *)((void *)0));
        }
#line 1983
        if (domain->must_swap) {
#line 1983
          tmp___13 = SWAP((domain->orig_tab + (nstr - 1U))->length);
#line 1983
          tmp___14 = tmp___13;
        } else {
#line 1983
          tmp___14 = (domain->orig_tab + (nstr - 1U))->length;
        }
#line 1983
        if (tmp___14 == len) {
#line 1983
          if (domain->must_swap) {
#line 1983
            tmp___15 = SWAP((domain->orig_tab + (nstr - 1U))->offset);
#line 1983
            tmp___16 = tmp___15;
          } else {
#line 1983
            tmp___16 = (domain->orig_tab + (nstr - 1U))->offset;
          }
#line 1983
          tmp___17 = strcmp(msgid, domain->data + tmp___16);
#line 1983
          if (tmp___17 == 0) {
#line 1988
            if (domain->must_swap) {
#line 1988
              tmp___11 = SWAP((domain->trans_tab + (nstr - 1U))->offset);
#line 1988
              tmp___12 = tmp___11;
            } else {
#line 1988
              tmp___12 = (domain->trans_tab + (nstr - 1U))->offset;
            }
#line 1988
            return ((char *)domain->data + tmp___12);
          }
        }
      }
    }
  }
#line 1996
  bottom = (size_t )0;
#line 1997
  top = (size_t )domain->nstrings;
#line 1998
  while (bottom < top) {
#line 2002
    act = (bottom + top) / 2UL;
#line 2003
    if (domain->must_swap) {
#line 2003
      tmp___18 = SWAP((domain->orig_tab + act)->offset);
#line 2003
      tmp___19 = tmp___18;
    } else {
#line 2003
      tmp___19 = (domain->orig_tab + act)->offset;
    }
#line 2003
    cmp_val = strcmp(msgid, domain->data + tmp___19);
#line 2006
    if (cmp_val < 0) {
#line 2007
      top = act;
    } else
#line 2008
    if (cmp_val > 0) {
#line 2009
      bottom = act + 1UL;
    } else {
#line 2011
      break;
    }
  }
#line 2015
  if (bottom >= top) {
#line 2015
    tmp___22 = (char *)((void *)0);
  } else {
#line 2015
    if (domain->must_swap) {
#line 2015
      tmp___20 = SWAP((domain->trans_tab + act)->offset);
#line 2015
      tmp___21 = tmp___20;
    } else {
#line 2015
      tmp___21 = (domain->trans_tab + act)->offset;
    }
#line 2015
    tmp___22 = (char *)domain->data + tmp___21;
  }
#line 2015
  return (tmp___22);
}
}
#line 2021 "gettext.c"
static char const   *category_to_name(int category ) 
{ 
  char const   *retval ;

  {
#line 2028
  switch (category) {
  case 3: 
#line 2032
  retval = "LC_COLLATE";
#line 2033
  break;
  case 0: 
#line 2037
  retval = "LC_CTYPE";
#line 2038
  break;
  case 4: 
#line 2042
  retval = "LC_MONETARY";
#line 2043
  break;
  case 1: 
#line 2047
  retval = "LC_NUMERIC";
#line 2048
  break;
  case 2: 
#line 2052
  retval = "LC_TIME";
#line 2053
  break;
  case 5: 
#line 2057
  retval = "LC_MESSAGES";
#line 2058
  break;
  case 6: 
#line 2069
  retval = "LC_ALL";
#line 2070
  break;
  default: 
#line 2074
  retval = "LC_XXX";
  }
#line 2077
  return (retval);
}
}
#line 2081 "gettext.c"
static char const   *guess_category_value(int category , char const   *categoryname ) 
{ 
  char const   *retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 2091
  tmp = getenv("LANGUAGE");
#line 2091
  retval = (char const   *)tmp;
#line 2092
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 2092
    if ((int const   )*(retval + 0) != 0) {
#line 2093
      return (retval);
    }
  }
#line 2102
  tmp___0 = getenv("LC_ALL");
#line 2102
  retval = (char const   *)tmp___0;
#line 2103
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 2103
    if ((int const   )*(retval + 0) != 0) {
#line 2104
      return (retval);
    }
  }
#line 2107
  tmp___1 = getenv(categoryname);
#line 2107
  retval = (char const   *)tmp___1;
#line 2108
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 2108
    if ((int const   )*(retval + 0) != 0) {
#line 2109
      return (retval);
    }
  }
#line 2112
  tmp___2 = getenv("LANG");
#line 2112
  retval = (char const   *)tmp___2;
#line 2113
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 2113
    if ((int const   )*(retval + 0) != 0) {
#line 2114
      return (retval);
    }
  }
#line 2118
  return ("C");
}
}
#line 2209 "gettext.c"
static char *bindtextdomain__(char const   *domainname , char const   *dirname ) 
{ 
  struct binding *binding ;
  int compare ;
  int tmp ;
  char *tmp___0 ;
  char *new_dirname ;
  int tmp___1 ;
  int tmp___2 ;
  struct binding *new_binding ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2217
  if ((unsigned long )domainname == (unsigned long )((void *)0)) {
#line 2218
    return ((char *)((void *)0));
  } else
#line 2217
  if ((int const   )*(domainname + 0) == 0) {
#line 2218
    return ((char *)((void *)0));
  }
#line 2220
  binding = _nl_domain_bindings;
#line 2220
  while ((unsigned long )binding != (unsigned long )((void *)0)) {
#line 2222
    tmp = strcmp(domainname, (char const   *)binding->domainname);
#line 2222
    compare = tmp;
#line 2223
    if (compare == 0) {
#line 2225
      break;
    }
#line 2226
    if (compare < 0) {
#line 2229
      binding = (struct binding *)((void *)0);
#line 2230
      break;
    }
#line 2220
    binding = binding->next;
  }
#line 2234
  if ((unsigned long )dirname == (unsigned long )((void *)0)) {
#line 2236
    if ((unsigned long )binding == (unsigned long )((void *)0)) {
#line 2236
      tmp___0 = (char *)(_nl_default_dirname);
    } else {
#line 2236
      tmp___0 = binding->dirname;
    }
#line 2236
    return (tmp___0);
  }
#line 2238
  if ((unsigned long )binding != (unsigned long )((void *)0)) {
#line 2243
    tmp___2 = strcmp(dirname, (char const   *)binding->dirname);
#line 2243
    if (tmp___2 != 0) {
#line 2247
      tmp___1 = strcmp(dirname, _nl_default_dirname);
#line 2247
      if (tmp___1 == 0) {
#line 2248
        new_dirname = (char *)(_nl_default_dirname);
      } else {
#line 2252
        new_dirname = strdup(dirname);
#line 2253
        if ((unsigned long )new_dirname == (unsigned long )((void *)0)) {
#line 2254
          return ((char *)((void *)0));
        }
      }
#line 2265
      if ((unsigned long )binding->dirname != (unsigned long )(_nl_default_dirname)) {
#line 2266
        free((void *)binding->dirname);
      }
#line 2268
      binding->dirname = new_dirname;
    }
  } else {
#line 2277
    tmp___3 = malloc(sizeof(*new_binding));
#line 2277
    new_binding = (struct binding *)tmp___3;
#line 2280
    if ((unsigned long )new_binding == (unsigned long )((void *)0)) {
#line 2281
      return ((char *)((void *)0));
    }
#line 2284
    new_binding->domainname = strdup(domainname);
#line 2285
    if ((unsigned long )new_binding->domainname == (unsigned long )((void *)0)) {
#line 2286
      return ((char *)((void *)0));
    }
#line 2295
    tmp___4 = strcmp(dirname, _nl_default_dirname);
#line 2295
    if (tmp___4 == 0) {
#line 2296
      new_binding->dirname = (char *)(_nl_default_dirname);
    } else {
#line 2300
      new_binding->dirname = strdup(dirname);
#line 2301
      if ((unsigned long )new_binding->dirname == (unsigned long )((void *)0)) {
#line 2302
        return ((char *)((void *)0));
      }
    }
#line 2313
    if ((unsigned long )_nl_domain_bindings == (unsigned long )((void *)0)) {
#line 2316
      new_binding->next = _nl_domain_bindings;
#line 2317
      _nl_domain_bindings = new_binding;
    } else {
#line 2313
      tmp___6 = strcmp(domainname, (char const   *)_nl_domain_bindings->domainname);
#line 2313
      if (tmp___6 < 0) {
#line 2316
        new_binding->next = _nl_domain_bindings;
#line 2317
        _nl_domain_bindings = new_binding;
      } else {
#line 2321
        binding = _nl_domain_bindings;
#line 2322
        while (1) {
#line 2322
          if ((unsigned long )binding->next != (unsigned long )((void *)0)) {
#line 2322
            tmp___5 = strcmp(domainname, (char const   *)(binding->next)->domainname);
#line 2322
            if (! (tmp___5 > 0)) {
#line 2322
              break;
            }
          } else {
#line 2322
            break;
          }
#line 2324
          binding = binding->next;
        }
#line 2326
        new_binding->next = binding->next;
#line 2327
        binding->next = new_binding;
      }
    }
#line 2330
    binding = new_binding;
  }
#line 2333
  return (binding->dirname);
}
}
#line 2369 "gettext.c"
static char *dgettext__(char const   *domainname , char const   *msgid ) 
{ 
  char *tmp ;

  {
#line 2374
  tmp = dcgettext__(domainname, msgid, 5);
#line 2374
  return (tmp);
}
}
#line 2421 "gettext.c"
static char *gettext__(char const   *msgid ) 
{ 
  char *tmp ;

  {
#line 2425
  tmp = dgettext__((char const   *)((void *)0), msgid);
#line 2425
  return (tmp);
}
}
#line 2476 "gettext.c"
static char *textdomain__(char const   *domainname ) 
{ 
  char *old ;
  char *tmp ;
  int tmp___0 ;

  {
#line 2483
  if ((unsigned long )domainname == (unsigned long )((void *)0)) {
#line 2484
    return ((char *)_nl_current_default_domain);
  }
#line 2486
  old = (char *)_nl_current_default_domain;
#line 2489
  if ((int const   )*(domainname + 0) == 0) {
#line 2491
    _nl_current_default_domain = _nl_default_default_domain;
  } else {
#line 2489
    tmp___0 = strcmp(domainname, _nl_default_default_domain);
#line 2489
    if (tmp___0 == 0) {
#line 2491
      _nl_current_default_domain = _nl_default_default_domain;
    } else {
#line 2498
      tmp = strdup(domainname);
#line 2498
      _nl_current_default_domain = (char const   *)tmp;
    }
  }
#line 2508
  if ((unsigned long )old != (unsigned long )(_nl_default_default_domain)) {
#line 2509
    free((void *)old);
  }
#line 2511
  return ((char *)_nl_current_default_domain);
}
}
#line 2532 "gettext.c"
char *bindtextdomain(char const   *domainname , char const   *dirname ) 
{ 
  char *tmp ;

  {
#line 2537
  tmp = bindtextdomain__(domainname, dirname);
#line 2537
  return (tmp);
}
}
#line 2540 "gettext.c"
char *dcgettext(char const   *domainname , char const   *msgid , int category ) 
{ 
  char *tmp ;

  {
#line 2546
  tmp = dcgettext__(domainname, msgid, category);
#line 2546
  return (tmp);
}
}
#line 2549 "gettext.c"
char *dgettext(char const   *domainname , char const   *msgid ) 
{ 
  char *tmp ;

  {
#line 2554
  tmp = dgettext__(domainname, msgid);
#line 2554
  return (tmp);
}
}
#line 2557 "gettext.c"
char *gettext(char const   *msgid ) 
{ 
  char *tmp ;

  {
#line 2561
  tmp = gettext__(msgid);
#line 2561
  return (tmp);
}
}
#line 2564 "gettext.c"
char *textdomain(char const   *domainname ) 
{ 
  char *tmp ;

  {
#line 2568
  tmp = textdomain__(domainname);
#line 2568
  return (tmp);
}
}
